,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix
893,178629,,Local Network,Single system,Complete,CVE-2017-7471,https://www.cvedetails.com/cve/CVE-2017-7471/,CWE-732,Low,Complete,Complete,,2018-07-09,7.7,"Quick Emulator (Qemu) built with the VirtFS, host directory sharing via Plan 9 File System (9pfs) support, is vulnerable to an improper access control issue. It could occur while accessing files on a shared host directory. A privileged user inside guest could use this flaw to access host file system beyond the shared folder and potentially escalating their privileges on a host.",2019-10-02,,6,https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9c6b899f7a46893ab3b671e341a2234e9c0c060e,9c6b899f7a46893ab3b671e341a2234e9c0c060e,,1,,,"static int local_name_to_path(FsContext *ctx, V9fsPath *dir_path,
                              const char *name, V9fsPath *target)
 {
     if (dir_path) {
         v9fs_path_sprintf(target, ""%s/%s"", dir_path->data, name);
    } else if (strcmp(name, ""/"")) {
         v9fs_path_sprintf(target, ""%s"", name);
    } else {
        /* We want the path of the export root to be relative, otherwise
         * ""*at()"" syscalls would treat it as ""/"" in the host.
         */
        v9fs_path_sprintf(target, ""%s"", ""."");
     }
     return 0;
 }
","static int local_name_to_path(FsContext *ctx, V9fsPath *dir_path,
                              const char *name, V9fsPath *target)
 {
     if (dir_path) {
         v9fs_path_sprintf(target, ""%s/%s"", dir_path->data, name);
    } else {
         v9fs_path_sprintf(target, ""%s"", name);
     }
     return 0;
 }
",C,"    } else if (strcmp(name, ""/"")) {
    } else {
        /* We want the path of the export root to be relative, otherwise
         * ""*at()"" syscalls would treat it as ""/"" in the host.
         */
        v9fs_path_sprintf(target, ""%s"", ""."");
","    } else {
",372b3fe0b2ecdd39ba850e31c0c6686315c507af,"@@ -1098,8 +1098,13 @@ static int local_name_to_path(FsContext *ctx, V9fsPath *dir_path,
 {
     if (dir_path) {
         v9fs_path_sprintf(target, ""%s/%s"", dir_path->data, name);
-    } else {
+    } else if (strcmp(name, ""/"")) {
         v9fs_path_sprintf(target, ""%s"", name);
+    } else {
+        /* We want the path of the export root to be relative, otherwise
+         * ""*at()"" syscalls would treat it as ""/"" in the host.
+         */
+        v9fs_path_sprintf(target, ""%s"", ""."");
     }
     return 0;
 }",qemu,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/9pfs/9p-local.c;h=f3ebca4f7a564c291745f81404ef48c36a872ad4;hb=9c6b899f7a46893ab3b671e341a2234e9c0c060e,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/9pfs/9p-local.c;h=45e9a1f9b0caccfe5525f1c0127371e473d0bf7b,1,"static int local_name_to_path(FsContext *ctx, V9fsPath *dir_path,
                              const char *name, V9fsPath *target)
 {
     if (dir_path) {
         v9fs_path_sprintf(target, ""%s/%s"", dir_path->data, name);
//flaw_line_below:
    } else {
//fix_flaw_line_below:
//    } else if (strcmp(name, ""/"")) {
         v9fs_path_sprintf(target, ""%s"", name);
//fix_flaw_line_below:
//    } else {
//fix_flaw_line_below:
//        /* We want the path of the export root to be relative, otherwise
//fix_flaw_line_below:
//         * ""*at()"" syscalls would treat it as ""/"" in the host.
//fix_flaw_line_below:
//         */
//fix_flaw_line_below:
//        v9fs_path_sprintf(target, ""%s"", ""."");
     }
     return 0;
 }
"
3677,181413,,Local,Not required,Complete,CVE-2017-7889,https://www.cvedetails.com/cve/CVE-2017-7889/,CWE-732,Low,Complete,Complete,,2017-04-16,7.2,"The mm subsystem in the Linux kernel through 4.10.10 does not properly enforce the CONFIG_STRICT_DEVMEM protection mechanism, which allows local users to read or write to kernel memory locations in the first megabyte (and bypass slab-allocation access restrictions) via an application that opens the /dev/mem file, related to arch/x86/mm/init.c and drivers/char/mem.c.",2019-10-02,Bypass ,23,https://github.com/torvalds/linux/commit/a4866aa812518ed1a37d8ea0c881dc946409de94,a4866aa812518ed1a37d8ea0c881dc946409de94,"mm: Tighten x86 /dev/mem with zeroing reads

Under CONFIG_STRICT_DEVMEM, reading System RAM through /dev/mem is
disallowed. However, on x86, the first 1MB was always allowed for BIOS
and similar things, regardless of it actually being System RAM. It was
possible for heap to end up getting allocated in low 1MB RAM, and then
read by things like x86info or dd, which would trip hardened usercopy:

usercopy: kernel memory exposure attempt detected from ffff880000090000 (dma-kmalloc-256) (4096 bytes)

This changes the x86 exception for the low 1MB by reading back zeros for
System RAM areas instead of blindly allowing them. More work is needed to
extend this to mmap, but currently mmap doesn't go through usercopy, so
hardened usercopy won't Oops the kernel.

Reported-by: Tommi Rantala <tommi.t.rantala@nokia.com>
Tested-by: Tommi Rantala <tommi.t.rantala@nokia.com>
Signed-off-by: Kees Cook <keescook@chromium.org>",6,arch/x86/mm/init.c,"{""sha"": ""889e7619a0914d87ad49dbb5b960933e5dd316ad"", ""filename"": ""arch/x86/mm/init.c"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 11, ""changes"": 41, ""blob_url"": ""https://github.com/torvalds/linux/blob/a4866aa812518ed1a37d8ea0c881dc946409de94/arch/x86/mm/init.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a4866aa812518ed1a37d8ea0c881dc946409de94/arch/x86/mm/init.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/mm/init.c?ref=a4866aa812518ed1a37d8ea0c881dc946409de94"", ""patch"": ""@@ -643,21 +643,40 @@ void __init init_mem_mapping(void)\n  * devmem_is_allowed() checks to see if /dev/mem access to a certain address\n  * is valid. The argument is a physical page number.\n  *\n- *\n- * On x86, access has to be given to the first megabyte of ram because that area\n- * contains BIOS code and data regions used by X and dosemu and similar apps.\n- * Access has to be given to non-kernel-ram areas as well, these contain the PCI\n- * mmio resources as well as potential bios/acpi data regions.\n+ * On x86, access has to be given to the first megabyte of RAM because that\n+ * area traditionally contains BIOS code and data regions used by X, dosemu,\n+ * and similar apps. Since they map the entire memory range, the whole range\n+ * must be allowed (for mapping), but any areas that would otherwise be\n+ * disallowed are flagged as being \""zero filled\"" instead of rejected.\n+ * Access has to be given to non-kernel-ram areas as well, these contain the\n+ * PCI mmio resources as well as potential bios/acpi data regions.\n  */\n int devmem_is_allowed(unsigned long pagenr)\n {\n-\tif (pagenr < 256)\n-\t\treturn 1;\n-\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT))\n+\tif (page_is_ram(pagenr)) {\n+\t\t/*\n+\t\t * For disallowed memory regions in the low 1MB range,\n+\t\t * request that the page be shown as all zeros.\n+\t\t */\n+\t\tif (pagenr < 256)\n+\t\t\treturn 2;\n+\n+\t\treturn 0;\n+\t}\n+\n+\t/*\n+\t * This must follow RAM test, since System RAM is considered a\n+\t * restricted resource under CONFIG_STRICT_IOMEM.\n+\t */\n+\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT)) {\n+\t\t/* Low 1MB bypasses iomem restrictions. */\n+\t\tif (pagenr < 256)\n+\t\t\treturn 1;\n+\n \t\treturn 0;\n-\tif (!page_is_ram(pagenr))\n-\t\treturn 1;\n-\treturn 0;\n+\t}\n+\n+\treturn 1;\n }\n \n void free_init_pages(char *what, unsigned long begin, unsigned long end)""}<_**next**_>{""sha"": ""7e4a9d1296bb7fb666f6b37ced2757a8585b7d75"", ""filename"": ""drivers/char/mem.c"", ""status"": ""modified"", ""additions"": 52, ""deletions"": 30, ""changes"": 82, ""blob_url"": ""https://github.com/torvalds/linux/blob/a4866aa812518ed1a37d8ea0c881dc946409de94/drivers/char/mem.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a4866aa812518ed1a37d8ea0c881dc946409de94/drivers/char/mem.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/char/mem.c?ref=a4866aa812518ed1a37d8ea0c881dc946409de94"", ""patch"": ""@@ -60,6 +60,10 @@ static inline int valid_mmap_phys_addr_range(unsigned long pfn, size_t size)\n #endif\n \n #ifdef CONFIG_STRICT_DEVMEM\n+static inline int page_is_allowed(unsigned long pfn)\n+{\n+\treturn devmem_is_allowed(pfn);\n+}\n static inline int range_is_allowed(unsigned long pfn, unsigned long size)\n {\n \tu64 from = ((u64)pfn) << PAGE_SHIFT;\n@@ -75,6 +79,10 @@ static inline int range_is_allowed(unsigned long pfn, unsigned long size)\n \treturn 1;\n }\n #else\n+static inline int page_is_allowed(unsigned long pfn)\n+{\n+\treturn 1;\n+}\n static inline int range_is_allowed(unsigned long pfn, unsigned long size)\n {\n \treturn 1;\n@@ -122,23 +130,31 @@ static ssize_t read_mem(struct file *file, char __user *buf,\n \n \twhile (count > 0) {\n \t\tunsigned long remaining;\n+\t\tint allowed;\n \n \t\tsz = size_inside_page(p, count);\n \n-\t\tif (!range_is_allowed(p >> PAGE_SHIFT, count))\n+\t\tallowed = page_is_allowed(p >> PAGE_SHIFT);\n+\t\tif (!allowed)\n \t\t\treturn -EPERM;\n+\t\tif (allowed == 2) {\n+\t\t\t/* Show zeros for restricted memory. */\n+\t\t\tremaining = clear_user(buf, sz);\n+\t\t} else {\n+\t\t\t/*\n+\t\t\t * On ia64 if a page has been mapped somewhere as\n+\t\t\t * uncached, then it must also be accessed uncached\n+\t\t\t * by the kernel or data corruption may occur.\n+\t\t\t */\n+\t\t\tptr = xlate_dev_mem_ptr(p);\n+\t\t\tif (!ptr)\n+\t\t\t\treturn -EFAULT;\n \n-\t\t/*\n-\t\t * On ia64 if a page has been mapped somewhere as uncached, then\n-\t\t * it must also be accessed uncached by the kernel or data\n-\t\t * corruption may occur.\n-\t\t */\n-\t\tptr = xlate_dev_mem_ptr(p);\n-\t\tif (!ptr)\n-\t\t\treturn -EFAULT;\n+\t\t\tremaining = copy_to_user(buf, ptr, sz);\n+\n+\t\t\tunxlate_dev_mem_ptr(p, ptr);\n+\t\t}\n \n-\t\tremaining = copy_to_user(buf, ptr, sz);\n-\t\tunxlate_dev_mem_ptr(p, ptr);\n \t\tif (remaining)\n \t\t\treturn -EFAULT;\n \n@@ -181,30 +197,36 @@ static ssize_t write_mem(struct file *file, const char __user *buf,\n #endif\n \n \twhile (count > 0) {\n+\t\tint allowed;\n+\n \t\tsz = size_inside_page(p, count);\n \n-\t\tif (!range_is_allowed(p >> PAGE_SHIFT, sz))\n+\t\tallowed = page_is_allowed(p >> PAGE_SHIFT);\n+\t\tif (!allowed)\n \t\t\treturn -EPERM;\n \n-\t\t/*\n-\t\t * On ia64 if a page has been mapped somewhere as uncached, then\n-\t\t * it must also be accessed uncached by the kernel or data\n-\t\t * corruption may occur.\n-\t\t */\n-\t\tptr = xlate_dev_mem_ptr(p);\n-\t\tif (!ptr) {\n-\t\t\tif (written)\n-\t\t\t\tbreak;\n-\t\t\treturn -EFAULT;\n-\t\t}\n+\t\t/* Skip actual writing when a page is marked as restricted. */\n+\t\tif (allowed == 1) {\n+\t\t\t/*\n+\t\t\t * On ia64 if a page has been mapped somewhere as\n+\t\t\t * uncached, then it must also be accessed uncached\n+\t\t\t * by the kernel or data corruption may occur.\n+\t\t\t */\n+\t\t\tptr = xlate_dev_mem_ptr(p);\n+\t\t\tif (!ptr) {\n+\t\t\t\tif (written)\n+\t\t\t\t\tbreak;\n+\t\t\t\treturn -EFAULT;\n+\t\t\t}\n \n-\t\tcopied = copy_from_user(ptr, buf, sz);\n-\t\tunxlate_dev_mem_ptr(p, ptr);\n-\t\tif (copied) {\n-\t\t\twritten += sz - copied;\n-\t\t\tif (written)\n-\t\t\t\tbreak;\n-\t\t\treturn -EFAULT;\n+\t\t\tcopied = copy_from_user(ptr, buf, sz);\n+\t\t\tunxlate_dev_mem_ptr(p, ptr);\n+\t\t\tif (copied) {\n+\t\t\t\twritten += sz - copied;\n+\t\t\t\tif (written)\n+\t\t\t\t\tbreak;\n+\t\t\t\treturn -EFAULT;\n+\t\t\t}\n \t\t}\n \n \t\tbuf += sz;""}"," int devmem_is_allowed(unsigned long pagenr)
 {
	if (page_is_ram(pagenr)) {
		/*
		 * For disallowed memory regions in the low 1MB range,
		 * request that the page be shown as all zeros.
		 */
		if (pagenr < 256)
			return 2;

		return 0;
	}

	/*
	 * This must follow RAM test, since System RAM is considered a
	 * restricted resource under CONFIG_STRICT_IOMEM.
	 */
	if (iomem_is_exclusive(pagenr << PAGE_SHIFT)) {
		/* Low 1MB bypasses iomem restrictions. */
		if (pagenr < 256)
			return 1;

 		return 0;
	}

	return 1;
 }
"," int devmem_is_allowed(unsigned long pagenr)
 {
	if (pagenr < 256)
		return 1;
	if (iomem_is_exclusive(pagenr << PAGE_SHIFT))
 		return 0;
	if (!page_is_ram(pagenr))
		return 1;
	return 0;
 }
",C,"	if (page_is_ram(pagenr)) {
		/*
		 * For disallowed memory regions in the low 1MB range,
		 * request that the page be shown as all zeros.
		 */
		if (pagenr < 256)
			return 2;

		return 0;
	}

	/*
	 * This must follow RAM test, since System RAM is considered a
	 * restricted resource under CONFIG_STRICT_IOMEM.
	 */
	if (iomem_is_exclusive(pagenr << PAGE_SHIFT)) {
		/* Low 1MB bypasses iomem restrictions. */
		if (pagenr < 256)
			return 1;

	}

	return 1;
","	if (pagenr < 256)
		return 1;
	if (iomem_is_exclusive(pagenr << PAGE_SHIFT))
	if (!page_is_ram(pagenr))
		return 1;
	return 0;
",,"@@ -643,21 +643,40 @@ void __init init_mem_mapping(void)
  * devmem_is_allowed() checks to see if /dev/mem access to a certain address
  * is valid. The argument is a physical page number.
  *
- *
- * On x86, access has to be given to the first megabyte of ram because that area
- * contains BIOS code and data regions used by X and dosemu and similar apps.
- * Access has to be given to non-kernel-ram areas as well, these contain the PCI
- * mmio resources as well as potential bios/acpi data regions.
+ * On x86, access has to be given to the first megabyte of RAM because that
+ * area traditionally contains BIOS code and data regions used by X, dosemu,
+ * and similar apps. Since they map the entire memory range, the whole range
+ * must be allowed (for mapping), but any areas that would otherwise be
+ * disallowed are flagged as being ""zero filled"" instead of rejected.
+ * Access has to be given to non-kernel-ram areas as well, these contain the
+ * PCI mmio resources as well as potential bios/acpi data regions.
  */
 int devmem_is_allowed(unsigned long pagenr)
 {
-	if (pagenr < 256)
-		return 1;
-	if (iomem_is_exclusive(pagenr << PAGE_SHIFT))
+	if (page_is_ram(pagenr)) {
+		/*
+		 * For disallowed memory regions in the low 1MB range,
+		 * request that the page be shown as all zeros.
+		 */
+		if (pagenr < 256)
+			return 2;
+
+		return 0;
+	}
+
+	/*
+	 * This must follow RAM test, since System RAM is considered a
+	 * restricted resource under CONFIG_STRICT_IOMEM.
+	 */
+	if (iomem_is_exclusive(pagenr << PAGE_SHIFT)) {
+		/* Low 1MB bypasses iomem restrictions. */
+		if (pagenr < 256)
+			return 1;
+
 		return 0;
-	if (!page_is_ram(pagenr))
-		return 1;
-	return 0;
+	}
+
+	return 1;
 }
 
 void free_init_pages(char *what, unsigned long begin, unsigned long end)",linux,a4866aa812518ed1a37d8ea0c881dc946409de94,b9b3322f13f350587f17f0a76f008830e3a420d3,1," int devmem_is_allowed(unsigned long pagenr)
 {
//flaw_line_below:
	if (pagenr < 256)
//flaw_line_below:
		return 1;
//flaw_line_below:
	if (iomem_is_exclusive(pagenr << PAGE_SHIFT))
//fix_flaw_line_below:
//	if (page_is_ram(pagenr)) {
//fix_flaw_line_below:
//		/*
//fix_flaw_line_below:
//		 * For disallowed memory regions in the low 1MB range,
//fix_flaw_line_below:
//		 * request that the page be shown as all zeros.
//fix_flaw_line_below:
//		 */
//fix_flaw_line_below:
//		if (pagenr < 256)
//fix_flaw_line_below:
//			return 2;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//		return 0;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	/*
//fix_flaw_line_below:
//	 * This must follow RAM test, since System RAM is considered a
//fix_flaw_line_below:
//	 * restricted resource under CONFIG_STRICT_IOMEM.
//fix_flaw_line_below:
//	 */
//fix_flaw_line_below:
//	if (iomem_is_exclusive(pagenr << PAGE_SHIFT)) {
//fix_flaw_line_below:
//		/* Low 1MB bypasses iomem restrictions. */
//fix_flaw_line_below:
//		if (pagenr < 256)
//fix_flaw_line_below:
//			return 1;
//fix_flaw_line_below:
//
 		return 0;
//flaw_line_below:
	if (!page_is_ram(pagenr))
//flaw_line_below:
		return 1;
//flaw_line_below:
	return 0;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	return 1;
 }
"
3678,181414,,Local,Not required,Complete,CVE-2017-7889,https://www.cvedetails.com/cve/CVE-2017-7889/,CWE-732,Low,Complete,Complete,,2017-04-16,7.2,"The mm subsystem in the Linux kernel through 4.10.10 does not properly enforce the CONFIG_STRICT_DEVMEM protection mechanism, which allows local users to read or write to kernel memory locations in the first megabyte (and bypass slab-allocation access restrictions) via an application that opens the /dev/mem file, related to arch/x86/mm/init.c and drivers/char/mem.c.",2019-10-02,Bypass ,19,https://github.com/torvalds/linux/commit/a4866aa812518ed1a37d8ea0c881dc946409de94,a4866aa812518ed1a37d8ea0c881dc946409de94,"mm: Tighten x86 /dev/mem with zeroing reads

Under CONFIG_STRICT_DEVMEM, reading System RAM through /dev/mem is
disallowed. However, on x86, the first 1MB was always allowed for BIOS
and similar things, regardless of it actually being System RAM. It was
possible for heap to end up getting allocated in low 1MB RAM, and then
read by things like x86info or dd, which would trip hardened usercopy:

usercopy: kernel memory exposure attempt detected from ffff880000090000 (dma-kmalloc-256) (4096 bytes)

This changes the x86 exception for the low 1MB by reading back zeros for
System RAM areas instead of blindly allowing them. More work is needed to
extend this to mmap, but currently mmap doesn't go through usercopy, so
hardened usercopy won't Oops the kernel.

Reported-by: Tommi Rantala <tommi.t.rantala@nokia.com>
Tested-by: Tommi Rantala <tommi.t.rantala@nokia.com>
Signed-off-by: Kees Cook <keescook@chromium.org>",11,drivers/char/mem.c,"{""sha"": ""889e7619a0914d87ad49dbb5b960933e5dd316ad"", ""filename"": ""arch/x86/mm/init.c"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 11, ""changes"": 41, ""blob_url"": ""https://github.com/torvalds/linux/blob/a4866aa812518ed1a37d8ea0c881dc946409de94/arch/x86/mm/init.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a4866aa812518ed1a37d8ea0c881dc946409de94/arch/x86/mm/init.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/mm/init.c?ref=a4866aa812518ed1a37d8ea0c881dc946409de94"", ""patch"": ""@@ -643,21 +643,40 @@ void __init init_mem_mapping(void)\n  * devmem_is_allowed() checks to see if /dev/mem access to a certain address\n  * is valid. The argument is a physical page number.\n  *\n- *\n- * On x86, access has to be given to the first megabyte of ram because that area\n- * contains BIOS code and data regions used by X and dosemu and similar apps.\n- * Access has to be given to non-kernel-ram areas as well, these contain the PCI\n- * mmio resources as well as potential bios/acpi data regions.\n+ * On x86, access has to be given to the first megabyte of RAM because that\n+ * area traditionally contains BIOS code and data regions used by X, dosemu,\n+ * and similar apps. Since they map the entire memory range, the whole range\n+ * must be allowed (for mapping), but any areas that would otherwise be\n+ * disallowed are flagged as being \""zero filled\"" instead of rejected.\n+ * Access has to be given to non-kernel-ram areas as well, these contain the\n+ * PCI mmio resources as well as potential bios/acpi data regions.\n  */\n int devmem_is_allowed(unsigned long pagenr)\n {\n-\tif (pagenr < 256)\n-\t\treturn 1;\n-\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT))\n+\tif (page_is_ram(pagenr)) {\n+\t\t/*\n+\t\t * For disallowed memory regions in the low 1MB range,\n+\t\t * request that the page be shown as all zeros.\n+\t\t */\n+\t\tif (pagenr < 256)\n+\t\t\treturn 2;\n+\n+\t\treturn 0;\n+\t}\n+\n+\t/*\n+\t * This must follow RAM test, since System RAM is considered a\n+\t * restricted resource under CONFIG_STRICT_IOMEM.\n+\t */\n+\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT)) {\n+\t\t/* Low 1MB bypasses iomem restrictions. */\n+\t\tif (pagenr < 256)\n+\t\t\treturn 1;\n+\n \t\treturn 0;\n-\tif (!page_is_ram(pagenr))\n-\t\treturn 1;\n-\treturn 0;\n+\t}\n+\n+\treturn 1;\n }\n \n void free_init_pages(char *what, unsigned long begin, unsigned long end)""}<_**next**_>{""sha"": ""7e4a9d1296bb7fb666f6b37ced2757a8585b7d75"", ""filename"": ""drivers/char/mem.c"", ""status"": ""modified"", ""additions"": 52, ""deletions"": 30, ""changes"": 82, ""blob_url"": ""https://github.com/torvalds/linux/blob/a4866aa812518ed1a37d8ea0c881dc946409de94/drivers/char/mem.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a4866aa812518ed1a37d8ea0c881dc946409de94/drivers/char/mem.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/char/mem.c?ref=a4866aa812518ed1a37d8ea0c881dc946409de94"", ""patch"": ""@@ -60,6 +60,10 @@ static inline int valid_mmap_phys_addr_range(unsigned long pfn, size_t size)\n #endif\n \n #ifdef CONFIG_STRICT_DEVMEM\n+static inline int page_is_allowed(unsigned long pfn)\n+{\n+\treturn devmem_is_allowed(pfn);\n+}\n static inline int range_is_allowed(unsigned long pfn, unsigned long size)\n {\n \tu64 from = ((u64)pfn) << PAGE_SHIFT;\n@@ -75,6 +79,10 @@ static inline int range_is_allowed(unsigned long pfn, unsigned long size)\n \treturn 1;\n }\n #else\n+static inline int page_is_allowed(unsigned long pfn)\n+{\n+\treturn 1;\n+}\n static inline int range_is_allowed(unsigned long pfn, unsigned long size)\n {\n \treturn 1;\n@@ -122,23 +130,31 @@ static ssize_t read_mem(struct file *file, char __user *buf,\n \n \twhile (count > 0) {\n \t\tunsigned long remaining;\n+\t\tint allowed;\n \n \t\tsz = size_inside_page(p, count);\n \n-\t\tif (!range_is_allowed(p >> PAGE_SHIFT, count))\n+\t\tallowed = page_is_allowed(p >> PAGE_SHIFT);\n+\t\tif (!allowed)\n \t\t\treturn -EPERM;\n+\t\tif (allowed == 2) {\n+\t\t\t/* Show zeros for restricted memory. */\n+\t\t\tremaining = clear_user(buf, sz);\n+\t\t} else {\n+\t\t\t/*\n+\t\t\t * On ia64 if a page has been mapped somewhere as\n+\t\t\t * uncached, then it must also be accessed uncached\n+\t\t\t * by the kernel or data corruption may occur.\n+\t\t\t */\n+\t\t\tptr = xlate_dev_mem_ptr(p);\n+\t\t\tif (!ptr)\n+\t\t\t\treturn -EFAULT;\n \n-\t\t/*\n-\t\t * On ia64 if a page has been mapped somewhere as uncached, then\n-\t\t * it must also be accessed uncached by the kernel or data\n-\t\t * corruption may occur.\n-\t\t */\n-\t\tptr = xlate_dev_mem_ptr(p);\n-\t\tif (!ptr)\n-\t\t\treturn -EFAULT;\n+\t\t\tremaining = copy_to_user(buf, ptr, sz);\n+\n+\t\t\tunxlate_dev_mem_ptr(p, ptr);\n+\t\t}\n \n-\t\tremaining = copy_to_user(buf, ptr, sz);\n-\t\tunxlate_dev_mem_ptr(p, ptr);\n \t\tif (remaining)\n \t\t\treturn -EFAULT;\n \n@@ -181,30 +197,36 @@ static ssize_t write_mem(struct file *file, const char __user *buf,\n #endif\n \n \twhile (count > 0) {\n+\t\tint allowed;\n+\n \t\tsz = size_inside_page(p, count);\n \n-\t\tif (!range_is_allowed(p >> PAGE_SHIFT, sz))\n+\t\tallowed = page_is_allowed(p >> PAGE_SHIFT);\n+\t\tif (!allowed)\n \t\t\treturn -EPERM;\n \n-\t\t/*\n-\t\t * On ia64 if a page has been mapped somewhere as uncached, then\n-\t\t * it must also be accessed uncached by the kernel or data\n-\t\t * corruption may occur.\n-\t\t */\n-\t\tptr = xlate_dev_mem_ptr(p);\n-\t\tif (!ptr) {\n-\t\t\tif (written)\n-\t\t\t\tbreak;\n-\t\t\treturn -EFAULT;\n-\t\t}\n+\t\t/* Skip actual writing when a page is marked as restricted. */\n+\t\tif (allowed == 1) {\n+\t\t\t/*\n+\t\t\t * On ia64 if a page has been mapped somewhere as\n+\t\t\t * uncached, then it must also be accessed uncached\n+\t\t\t * by the kernel or data corruption may occur.\n+\t\t\t */\n+\t\t\tptr = xlate_dev_mem_ptr(p);\n+\t\t\tif (!ptr) {\n+\t\t\t\tif (written)\n+\t\t\t\t\tbreak;\n+\t\t\t\treturn -EFAULT;\n+\t\t\t}\n \n-\t\tcopied = copy_from_user(ptr, buf, sz);\n-\t\tunxlate_dev_mem_ptr(p, ptr);\n-\t\tif (copied) {\n-\t\t\twritten += sz - copied;\n-\t\t\tif (written)\n-\t\t\t\tbreak;\n-\t\t\treturn -EFAULT;\n+\t\t\tcopied = copy_from_user(ptr, buf, sz);\n+\t\t\tunxlate_dev_mem_ptr(p, ptr);\n+\t\t\tif (copied) {\n+\t\t\t\twritten += sz - copied;\n+\t\t\t\tif (written)\n+\t\t\t\t\tbreak;\n+\t\t\t\treturn -EFAULT;\n+\t\t\t}\n \t\t}\n \n \t\tbuf += sz;""}","static ssize_t read_mem(struct file *file, char __user *buf,
			size_t count, loff_t *ppos)
{
	phys_addr_t p = *ppos;
	ssize_t read, sz;
	void *ptr;

	if (p != *ppos)
		return 0;

	if (!valid_phys_addr_range(p, count))
		return -EFAULT;
	read = 0;
#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED
	/* we don't have page 0 mapped on sparc and m68k.. */
	if (p < PAGE_SIZE) {
		sz = size_inside_page(p, count);
		if (sz > 0) {
			if (clear_user(buf, sz))
				return -EFAULT;
			buf += sz;
			p += sz;
			count -= sz;
			read += sz;
		}
	}
#endif
 
 	while (count > 0) {
 		unsigned long remaining;
		int allowed;
 
 		sz = size_inside_page(p, count);
 
		allowed = page_is_allowed(p >> PAGE_SHIFT);
		if (!allowed)
 			return -EPERM;
		if (allowed == 2) {
			/* Show zeros for restricted memory. */
			remaining = clear_user(buf, sz);
		} else {
			/*
			 * On ia64 if a page has been mapped somewhere as
			 * uncached, then it must also be accessed uncached
			 * by the kernel or data corruption may occur.
			 */
			ptr = xlate_dev_mem_ptr(p);
			if (!ptr)
				return -EFAULT;
 
			remaining = copy_to_user(buf, ptr, sz);

			unxlate_dev_mem_ptr(p, ptr);
		}
 
 		if (remaining)
 			return -EFAULT;
 
		buf += sz;
		p += sz;
		count -= sz;
		read += sz;
	}

	*ppos += read;
	return read;
}
","static ssize_t read_mem(struct file *file, char __user *buf,
			size_t count, loff_t *ppos)
{
	phys_addr_t p = *ppos;
	ssize_t read, sz;
	void *ptr;

	if (p != *ppos)
		return 0;

	if (!valid_phys_addr_range(p, count))
		return -EFAULT;
	read = 0;
#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED
	/* we don't have page 0 mapped on sparc and m68k.. */
	if (p < PAGE_SIZE) {
		sz = size_inside_page(p, count);
		if (sz > 0) {
			if (clear_user(buf, sz))
				return -EFAULT;
			buf += sz;
			p += sz;
			count -= sz;
			read += sz;
		}
	}
#endif
 
 	while (count > 0) {
 		unsigned long remaining;
 
 		sz = size_inside_page(p, count);
 
		if (!range_is_allowed(p >> PAGE_SHIFT, count))
 			return -EPERM;
 
		/*
		 * On ia64 if a page has been mapped somewhere as uncached, then
		 * it must also be accessed uncached by the kernel or data
		 * corruption may occur.
		 */
		ptr = xlate_dev_mem_ptr(p);
		if (!ptr)
			return -EFAULT;
 
		remaining = copy_to_user(buf, ptr, sz);
		unxlate_dev_mem_ptr(p, ptr);
 		if (remaining)
 			return -EFAULT;
 
		buf += sz;
		p += sz;
		count -= sz;
		read += sz;
	}

	*ppos += read;
	return read;
}
",C,"		int allowed;
		allowed = page_is_allowed(p >> PAGE_SHIFT);
		if (!allowed)
		if (allowed == 2) {
			/* Show zeros for restricted memory. */
			remaining = clear_user(buf, sz);
		} else {
			/*
			 * On ia64 if a page has been mapped somewhere as
			 * uncached, then it must also be accessed uncached
			 * by the kernel or data corruption may occur.
			 */
			ptr = xlate_dev_mem_ptr(p);
			if (!ptr)
				return -EFAULT;
			remaining = copy_to_user(buf, ptr, sz);

			unxlate_dev_mem_ptr(p, ptr);
		}
","		if (!range_is_allowed(p >> PAGE_SHIFT, count))
		/*
		 * On ia64 if a page has been mapped somewhere as uncached, then
		 * it must also be accessed uncached by the kernel or data
		 * corruption may occur.
		 */
		ptr = xlate_dev_mem_ptr(p);
		if (!ptr)
			return -EFAULT;
		remaining = copy_to_user(buf, ptr, sz);
		unxlate_dev_mem_ptr(p, ptr);
",,"@@ -60,6 +60,10 @@ static inline int valid_mmap_phys_addr_range(unsigned long pfn, size_t size)
 #endif
 
 #ifdef CONFIG_STRICT_DEVMEM
+static inline int page_is_allowed(unsigned long pfn)
+{
+	return devmem_is_allowed(pfn);
+}
 static inline int range_is_allowed(unsigned long pfn, unsigned long size)
 {
 	u64 from = ((u64)pfn) << PAGE_SHIFT;
@@ -75,6 +79,10 @@ static inline int range_is_allowed(unsigned long pfn, unsigned long size)
 	return 1;
 }
 #else
+static inline int page_is_allowed(unsigned long pfn)
+{
+	return 1;
+}
 static inline int range_is_allowed(unsigned long pfn, unsigned long size)
 {
 	return 1;
@@ -122,23 +130,31 @@ static ssize_t read_mem(struct file *file, char __user *buf,
 
 	while (count > 0) {
 		unsigned long remaining;
+		int allowed;
 
 		sz = size_inside_page(p, count);
 
-		if (!range_is_allowed(p >> PAGE_SHIFT, count))
+		allowed = page_is_allowed(p >> PAGE_SHIFT);
+		if (!allowed)
 			return -EPERM;
+		if (allowed == 2) {
+			/* Show zeros for restricted memory. */
+			remaining = clear_user(buf, sz);
+		} else {
+			/*
+			 * On ia64 if a page has been mapped somewhere as
+			 * uncached, then it must also be accessed uncached
+			 * by the kernel or data corruption may occur.
+			 */
+			ptr = xlate_dev_mem_ptr(p);
+			if (!ptr)
+				return -EFAULT;
 
-		/*
-		 * On ia64 if a page has been mapped somewhere as uncached, then
-		 * it must also be accessed uncached by the kernel or data
-		 * corruption may occur.
-		 */
-		ptr = xlate_dev_mem_ptr(p);
-		if (!ptr)
-			return -EFAULT;
+			remaining = copy_to_user(buf, ptr, sz);
+
+			unxlate_dev_mem_ptr(p, ptr);
+		}
 
-		remaining = copy_to_user(buf, ptr, sz);
-		unxlate_dev_mem_ptr(p, ptr);
 		if (remaining)
 			return -EFAULT;
 
@@ -181,30 +197,36 @@ static ssize_t write_mem(struct file *file, const char __user *buf,
 #endif
 
 	while (count > 0) {
+		int allowed;
+
 		sz = size_inside_page(p, count);
 
-		if (!range_is_allowed(p >> PAGE_SHIFT, sz))
+		allowed = page_is_allowed(p >> PAGE_SHIFT);
+		if (!allowed)
 			return -EPERM;
 
-		/*
-		 * On ia64 if a page has been mapped somewhere as uncached, then
-		 * it must also be accessed uncached by the kernel or data
-		 * corruption may occur.
-		 */
-		ptr = xlate_dev_mem_ptr(p);
-		if (!ptr) {
-			if (written)
-				break;
-			return -EFAULT;
-		}
+		/* Skip actual writing when a page is marked as restricted. */
+		if (allowed == 1) {
+			/*
+			 * On ia64 if a page has been mapped somewhere as
+			 * uncached, then it must also be accessed uncached
+			 * by the kernel or data corruption may occur.
+			 */
+			ptr = xlate_dev_mem_ptr(p);
+			if (!ptr) {
+				if (written)
+					break;
+				return -EFAULT;
+			}
 
-		copied = copy_from_user(ptr, buf, sz);
-		unxlate_dev_mem_ptr(p, ptr);
-		if (copied) {
-			written += sz - copied;
-			if (written)
-				break;
-			return -EFAULT;
+			copied = copy_from_user(ptr, buf, sz);
+			unxlate_dev_mem_ptr(p, ptr);
+			if (copied) {
+				written += sz - copied;
+				if (written)
+					break;
+				return -EFAULT;
+			}
 		}
 
 		buf += sz;",linux,a4866aa812518ed1a37d8ea0c881dc946409de94,b9b3322f13f350587f17f0a76f008830e3a420d3,1,"static ssize_t read_mem(struct file *file, char __user *buf,
			size_t count, loff_t *ppos)
{
	phys_addr_t p = *ppos;
	ssize_t read, sz;
	void *ptr;

	if (p != *ppos)
		return 0;

	if (!valid_phys_addr_range(p, count))
		return -EFAULT;
	read = 0;
#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED
	/* we don't have page 0 mapped on sparc and m68k.. */
	if (p < PAGE_SIZE) {
		sz = size_inside_page(p, count);
		if (sz > 0) {
			if (clear_user(buf, sz))
				return -EFAULT;
			buf += sz;
			p += sz;
			count -= sz;
			read += sz;
		}
	}
#endif
 
 	while (count > 0) {
 		unsigned long remaining;
//fix_flaw_line_below:
//		int allowed;
 
 		sz = size_inside_page(p, count);
 
//flaw_line_below:
		if (!range_is_allowed(p >> PAGE_SHIFT, count))
//fix_flaw_line_below:
//		allowed = page_is_allowed(p >> PAGE_SHIFT);
//fix_flaw_line_below:
//		if (!allowed)
 			return -EPERM;
//fix_flaw_line_below:
//		if (allowed == 2) {
//fix_flaw_line_below:
//			/* Show zeros for restricted memory. */
//fix_flaw_line_below:
//			remaining = clear_user(buf, sz);
//fix_flaw_line_below:
//		} else {
//fix_flaw_line_below:
//			/*
//fix_flaw_line_below:
//			 * On ia64 if a page has been mapped somewhere as
//fix_flaw_line_below:
//			 * uncached, then it must also be accessed uncached
//fix_flaw_line_below:
//			 * by the kernel or data corruption may occur.
//fix_flaw_line_below:
//			 */
//fix_flaw_line_below:
//			ptr = xlate_dev_mem_ptr(p);
//fix_flaw_line_below:
//			if (!ptr)
//fix_flaw_line_below:
//				return -EFAULT;
 
//flaw_line_below:
		/*
//flaw_line_below:
		 * On ia64 if a page has been mapped somewhere as uncached, then
//flaw_line_below:
		 * it must also be accessed uncached by the kernel or data
//flaw_line_below:
		 * corruption may occur.
//flaw_line_below:
		 */
//flaw_line_below:
		ptr = xlate_dev_mem_ptr(p);
//flaw_line_below:
		if (!ptr)
//flaw_line_below:
			return -EFAULT;
//fix_flaw_line_below:
//			remaining = copy_to_user(buf, ptr, sz);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//			unxlate_dev_mem_ptr(p, ptr);
//fix_flaw_line_below:
//		}
 
//flaw_line_below:
		remaining = copy_to_user(buf, ptr, sz);
//flaw_line_below:
		unxlate_dev_mem_ptr(p, ptr);
 		if (remaining)
 			return -EFAULT;
 
		buf += sz;
		p += sz;
		count -= sz;
		read += sz;
	}

	*ppos += read;
	return read;
}
"
3679,181415,,Local,Not required,Complete,CVE-2017-7889,https://www.cvedetails.com/cve/CVE-2017-7889/,CWE-732,Low,Complete,Complete,,2017-04-16,7.2,"The mm subsystem in the Linux kernel through 4.10.10 does not properly enforce the CONFIG_STRICT_DEVMEM protection mechanism, which allows local users to read or write to kernel memory locations in the first megabyte (and bypass slab-allocation access restrictions) via an application that opens the /dev/mem file, related to arch/x86/mm/init.c and drivers/char/mem.c.",2019-10-02,Bypass ,25,https://github.com/torvalds/linux/commit/a4866aa812518ed1a37d8ea0c881dc946409de94,a4866aa812518ed1a37d8ea0c881dc946409de94,"mm: Tighten x86 /dev/mem with zeroing reads

Under CONFIG_STRICT_DEVMEM, reading System RAM through /dev/mem is
disallowed. However, on x86, the first 1MB was always allowed for BIOS
and similar things, regardless of it actually being System RAM. It was
possible for heap to end up getting allocated in low 1MB RAM, and then
read by things like x86info or dd, which would trip hardened usercopy:

usercopy: kernel memory exposure attempt detected from ffff880000090000 (dma-kmalloc-256) (4096 bytes)

This changes the x86 exception for the low 1MB by reading back zeros for
System RAM areas instead of blindly allowing them. More work is needed to
extend this to mmap, but currently mmap doesn't go through usercopy, so
hardened usercopy won't Oops the kernel.

Reported-by: Tommi Rantala <tommi.t.rantala@nokia.com>
Tested-by: Tommi Rantala <tommi.t.rantala@nokia.com>
Signed-off-by: Kees Cook <keescook@chromium.org>",19,drivers/char/mem.c,"{""sha"": ""889e7619a0914d87ad49dbb5b960933e5dd316ad"", ""filename"": ""arch/x86/mm/init.c"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 11, ""changes"": 41, ""blob_url"": ""https://github.com/torvalds/linux/blob/a4866aa812518ed1a37d8ea0c881dc946409de94/arch/x86/mm/init.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a4866aa812518ed1a37d8ea0c881dc946409de94/arch/x86/mm/init.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/mm/init.c?ref=a4866aa812518ed1a37d8ea0c881dc946409de94"", ""patch"": ""@@ -643,21 +643,40 @@ void __init init_mem_mapping(void)\n  * devmem_is_allowed() checks to see if /dev/mem access to a certain address\n  * is valid. The argument is a physical page number.\n  *\n- *\n- * On x86, access has to be given to the first megabyte of ram because that area\n- * contains BIOS code and data regions used by X and dosemu and similar apps.\n- * Access has to be given to non-kernel-ram areas as well, these contain the PCI\n- * mmio resources as well as potential bios/acpi data regions.\n+ * On x86, access has to be given to the first megabyte of RAM because that\n+ * area traditionally contains BIOS code and data regions used by X, dosemu,\n+ * and similar apps. Since they map the entire memory range, the whole range\n+ * must be allowed (for mapping), but any areas that would otherwise be\n+ * disallowed are flagged as being \""zero filled\"" instead of rejected.\n+ * Access has to be given to non-kernel-ram areas as well, these contain the\n+ * PCI mmio resources as well as potential bios/acpi data regions.\n  */\n int devmem_is_allowed(unsigned long pagenr)\n {\n-\tif (pagenr < 256)\n-\t\treturn 1;\n-\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT))\n+\tif (page_is_ram(pagenr)) {\n+\t\t/*\n+\t\t * For disallowed memory regions in the low 1MB range,\n+\t\t * request that the page be shown as all zeros.\n+\t\t */\n+\t\tif (pagenr < 256)\n+\t\t\treturn 2;\n+\n+\t\treturn 0;\n+\t}\n+\n+\t/*\n+\t * This must follow RAM test, since System RAM is considered a\n+\t * restricted resource under CONFIG_STRICT_IOMEM.\n+\t */\n+\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT)) {\n+\t\t/* Low 1MB bypasses iomem restrictions. */\n+\t\tif (pagenr < 256)\n+\t\t\treturn 1;\n+\n \t\treturn 0;\n-\tif (!page_is_ram(pagenr))\n-\t\treturn 1;\n-\treturn 0;\n+\t}\n+\n+\treturn 1;\n }\n \n void free_init_pages(char *what, unsigned long begin, unsigned long end)""}<_**next**_>{""sha"": ""7e4a9d1296bb7fb666f6b37ced2757a8585b7d75"", ""filename"": ""drivers/char/mem.c"", ""status"": ""modified"", ""additions"": 52, ""deletions"": 30, ""changes"": 82, ""blob_url"": ""https://github.com/torvalds/linux/blob/a4866aa812518ed1a37d8ea0c881dc946409de94/drivers/char/mem.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a4866aa812518ed1a37d8ea0c881dc946409de94/drivers/char/mem.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/char/mem.c?ref=a4866aa812518ed1a37d8ea0c881dc946409de94"", ""patch"": ""@@ -60,6 +60,10 @@ static inline int valid_mmap_phys_addr_range(unsigned long pfn, size_t size)\n #endif\n \n #ifdef CONFIG_STRICT_DEVMEM\n+static inline int page_is_allowed(unsigned long pfn)\n+{\n+\treturn devmem_is_allowed(pfn);\n+}\n static inline int range_is_allowed(unsigned long pfn, unsigned long size)\n {\n \tu64 from = ((u64)pfn) << PAGE_SHIFT;\n@@ -75,6 +79,10 @@ static inline int range_is_allowed(unsigned long pfn, unsigned long size)\n \treturn 1;\n }\n #else\n+static inline int page_is_allowed(unsigned long pfn)\n+{\n+\treturn 1;\n+}\n static inline int range_is_allowed(unsigned long pfn, unsigned long size)\n {\n \treturn 1;\n@@ -122,23 +130,31 @@ static ssize_t read_mem(struct file *file, char __user *buf,\n \n \twhile (count > 0) {\n \t\tunsigned long remaining;\n+\t\tint allowed;\n \n \t\tsz = size_inside_page(p, count);\n \n-\t\tif (!range_is_allowed(p >> PAGE_SHIFT, count))\n+\t\tallowed = page_is_allowed(p >> PAGE_SHIFT);\n+\t\tif (!allowed)\n \t\t\treturn -EPERM;\n+\t\tif (allowed == 2) {\n+\t\t\t/* Show zeros for restricted memory. */\n+\t\t\tremaining = clear_user(buf, sz);\n+\t\t} else {\n+\t\t\t/*\n+\t\t\t * On ia64 if a page has been mapped somewhere as\n+\t\t\t * uncached, then it must also be accessed uncached\n+\t\t\t * by the kernel or data corruption may occur.\n+\t\t\t */\n+\t\t\tptr = xlate_dev_mem_ptr(p);\n+\t\t\tif (!ptr)\n+\t\t\t\treturn -EFAULT;\n \n-\t\t/*\n-\t\t * On ia64 if a page has been mapped somewhere as uncached, then\n-\t\t * it must also be accessed uncached by the kernel or data\n-\t\t * corruption may occur.\n-\t\t */\n-\t\tptr = xlate_dev_mem_ptr(p);\n-\t\tif (!ptr)\n-\t\t\treturn -EFAULT;\n+\t\t\tremaining = copy_to_user(buf, ptr, sz);\n+\n+\t\t\tunxlate_dev_mem_ptr(p, ptr);\n+\t\t}\n \n-\t\tremaining = copy_to_user(buf, ptr, sz);\n-\t\tunxlate_dev_mem_ptr(p, ptr);\n \t\tif (remaining)\n \t\t\treturn -EFAULT;\n \n@@ -181,30 +197,36 @@ static ssize_t write_mem(struct file *file, const char __user *buf,\n #endif\n \n \twhile (count > 0) {\n+\t\tint allowed;\n+\n \t\tsz = size_inside_page(p, count);\n \n-\t\tif (!range_is_allowed(p >> PAGE_SHIFT, sz))\n+\t\tallowed = page_is_allowed(p >> PAGE_SHIFT);\n+\t\tif (!allowed)\n \t\t\treturn -EPERM;\n \n-\t\t/*\n-\t\t * On ia64 if a page has been mapped somewhere as uncached, then\n-\t\t * it must also be accessed uncached by the kernel or data\n-\t\t * corruption may occur.\n-\t\t */\n-\t\tptr = xlate_dev_mem_ptr(p);\n-\t\tif (!ptr) {\n-\t\t\tif (written)\n-\t\t\t\tbreak;\n-\t\t\treturn -EFAULT;\n-\t\t}\n+\t\t/* Skip actual writing when a page is marked as restricted. */\n+\t\tif (allowed == 1) {\n+\t\t\t/*\n+\t\t\t * On ia64 if a page has been mapped somewhere as\n+\t\t\t * uncached, then it must also be accessed uncached\n+\t\t\t * by the kernel or data corruption may occur.\n+\t\t\t */\n+\t\t\tptr = xlate_dev_mem_ptr(p);\n+\t\t\tif (!ptr) {\n+\t\t\t\tif (written)\n+\t\t\t\t\tbreak;\n+\t\t\t\treturn -EFAULT;\n+\t\t\t}\n \n-\t\tcopied = copy_from_user(ptr, buf, sz);\n-\t\tunxlate_dev_mem_ptr(p, ptr);\n-\t\tif (copied) {\n-\t\t\twritten += sz - copied;\n-\t\t\tif (written)\n-\t\t\t\tbreak;\n-\t\t\treturn -EFAULT;\n+\t\t\tcopied = copy_from_user(ptr, buf, sz);\n+\t\t\tunxlate_dev_mem_ptr(p, ptr);\n+\t\t\tif (copied) {\n+\t\t\t\twritten += sz - copied;\n+\t\t\t\tif (written)\n+\t\t\t\t\tbreak;\n+\t\t\t\treturn -EFAULT;\n+\t\t\t}\n \t\t}\n \n \t\tbuf += sz;""}","static ssize_t write_mem(struct file *file, const char __user *buf,
			 size_t count, loff_t *ppos)
{
	phys_addr_t p = *ppos;
	ssize_t written, sz;
	unsigned long copied;
	void *ptr;

	if (p != *ppos)
		return -EFBIG;

	if (!valid_phys_addr_range(p, count))
		return -EFAULT;

	written = 0;

#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED
	/* we don't have page 0 mapped on sparc and m68k.. */
	if (p < PAGE_SIZE) {
		sz = size_inside_page(p, count);
		/* Hmm. Do something? */
		buf += sz;
		p += sz;
		count -= sz;
		written += sz;
	}
 #endif
 
 	while (count > 0) {
		int allowed;

 		sz = size_inside_page(p, count);
 
		allowed = page_is_allowed(p >> PAGE_SHIFT);
		if (!allowed)
 			return -EPERM;
 
		/* Skip actual writing when a page is marked as restricted. */
		if (allowed == 1) {
			/*
			 * On ia64 if a page has been mapped somewhere as
			 * uncached, then it must also be accessed uncached
			 * by the kernel or data corruption may occur.
			 */
			ptr = xlate_dev_mem_ptr(p);
			if (!ptr) {
				if (written)
					break;
				return -EFAULT;
			}
 
			copied = copy_from_user(ptr, buf, sz);
			unxlate_dev_mem_ptr(p, ptr);
			if (copied) {
				written += sz - copied;
				if (written)
					break;
				return -EFAULT;
			}
 		}
 
 		buf += sz;
		p += sz;
		count -= sz;
		written += sz;
	}

	*ppos += written;
	return written;
}
","static ssize_t write_mem(struct file *file, const char __user *buf,
			 size_t count, loff_t *ppos)
{
	phys_addr_t p = *ppos;
	ssize_t written, sz;
	unsigned long copied;
	void *ptr;

	if (p != *ppos)
		return -EFBIG;

	if (!valid_phys_addr_range(p, count))
		return -EFAULT;

	written = 0;

#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED
	/* we don't have page 0 mapped on sparc and m68k.. */
	if (p < PAGE_SIZE) {
		sz = size_inside_page(p, count);
		/* Hmm. Do something? */
		buf += sz;
		p += sz;
		count -= sz;
		written += sz;
	}
 #endif
 
 	while (count > 0) {
 		sz = size_inside_page(p, count);
 
		if (!range_is_allowed(p >> PAGE_SHIFT, sz))
 			return -EPERM;
 
		/*
		 * On ia64 if a page has been mapped somewhere as uncached, then
		 * it must also be accessed uncached by the kernel or data
		 * corruption may occur.
		 */
		ptr = xlate_dev_mem_ptr(p);
		if (!ptr) {
			if (written)
				break;
			return -EFAULT;
		}
 
		copied = copy_from_user(ptr, buf, sz);
		unxlate_dev_mem_ptr(p, ptr);
		if (copied) {
			written += sz - copied;
			if (written)
				break;
			return -EFAULT;
 		}
 
 		buf += sz;
		p += sz;
		count -= sz;
		written += sz;
	}

	*ppos += written;
	return written;
}
",C,"		int allowed;

		allowed = page_is_allowed(p >> PAGE_SHIFT);
		if (!allowed)
		/* Skip actual writing when a page is marked as restricted. */
		if (allowed == 1) {
			/*
			 * On ia64 if a page has been mapped somewhere as
			 * uncached, then it must also be accessed uncached
			 * by the kernel or data corruption may occur.
			 */
			ptr = xlate_dev_mem_ptr(p);
			if (!ptr) {
				if (written)
					break;
				return -EFAULT;
			}
			copied = copy_from_user(ptr, buf, sz);
			unxlate_dev_mem_ptr(p, ptr);
			if (copied) {
				written += sz - copied;
				if (written)
					break;
				return -EFAULT;
			}
","		if (!range_is_allowed(p >> PAGE_SHIFT, sz))
		/*
		 * On ia64 if a page has been mapped somewhere as uncached, then
		 * it must also be accessed uncached by the kernel or data
		 * corruption may occur.
		 */
		ptr = xlate_dev_mem_ptr(p);
		if (!ptr) {
			if (written)
				break;
			return -EFAULT;
		}
		copied = copy_from_user(ptr, buf, sz);
		unxlate_dev_mem_ptr(p, ptr);
		if (copied) {
			written += sz - copied;
			if (written)
				break;
			return -EFAULT;
",,"@@ -60,6 +60,10 @@ static inline int valid_mmap_phys_addr_range(unsigned long pfn, size_t size)
 #endif
 
 #ifdef CONFIG_STRICT_DEVMEM
+static inline int page_is_allowed(unsigned long pfn)
+{
+	return devmem_is_allowed(pfn);
+}
 static inline int range_is_allowed(unsigned long pfn, unsigned long size)
 {
 	u64 from = ((u64)pfn) << PAGE_SHIFT;
@@ -75,6 +79,10 @@ static inline int range_is_allowed(unsigned long pfn, unsigned long size)
 	return 1;
 }
 #else
+static inline int page_is_allowed(unsigned long pfn)
+{
+	return 1;
+}
 static inline int range_is_allowed(unsigned long pfn, unsigned long size)
 {
 	return 1;
@@ -122,23 +130,31 @@ static ssize_t read_mem(struct file *file, char __user *buf,
 
 	while (count > 0) {
 		unsigned long remaining;
+		int allowed;
 
 		sz = size_inside_page(p, count);
 
-		if (!range_is_allowed(p >> PAGE_SHIFT, count))
+		allowed = page_is_allowed(p >> PAGE_SHIFT);
+		if (!allowed)
 			return -EPERM;
+		if (allowed == 2) {
+			/* Show zeros for restricted memory. */
+			remaining = clear_user(buf, sz);
+		} else {
+			/*
+			 * On ia64 if a page has been mapped somewhere as
+			 * uncached, then it must also be accessed uncached
+			 * by the kernel or data corruption may occur.
+			 */
+			ptr = xlate_dev_mem_ptr(p);
+			if (!ptr)
+				return -EFAULT;
 
-		/*
-		 * On ia64 if a page has been mapped somewhere as uncached, then
-		 * it must also be accessed uncached by the kernel or data
-		 * corruption may occur.
-		 */
-		ptr = xlate_dev_mem_ptr(p);
-		if (!ptr)
-			return -EFAULT;
+			remaining = copy_to_user(buf, ptr, sz);
+
+			unxlate_dev_mem_ptr(p, ptr);
+		}
 
-		remaining = copy_to_user(buf, ptr, sz);
-		unxlate_dev_mem_ptr(p, ptr);
 		if (remaining)
 			return -EFAULT;
 
@@ -181,30 +197,36 @@ static ssize_t write_mem(struct file *file, const char __user *buf,
 #endif
 
 	while (count > 0) {
+		int allowed;
+
 		sz = size_inside_page(p, count);
 
-		if (!range_is_allowed(p >> PAGE_SHIFT, sz))
+		allowed = page_is_allowed(p >> PAGE_SHIFT);
+		if (!allowed)
 			return -EPERM;
 
-		/*
-		 * On ia64 if a page has been mapped somewhere as uncached, then
-		 * it must also be accessed uncached by the kernel or data
-		 * corruption may occur.
-		 */
-		ptr = xlate_dev_mem_ptr(p);
-		if (!ptr) {
-			if (written)
-				break;
-			return -EFAULT;
-		}
+		/* Skip actual writing when a page is marked as restricted. */
+		if (allowed == 1) {
+			/*
+			 * On ia64 if a page has been mapped somewhere as
+			 * uncached, then it must also be accessed uncached
+			 * by the kernel or data corruption may occur.
+			 */
+			ptr = xlate_dev_mem_ptr(p);
+			if (!ptr) {
+				if (written)
+					break;
+				return -EFAULT;
+			}
 
-		copied = copy_from_user(ptr, buf, sz);
-		unxlate_dev_mem_ptr(p, ptr);
-		if (copied) {
-			written += sz - copied;
-			if (written)
-				break;
-			return -EFAULT;
+			copied = copy_from_user(ptr, buf, sz);
+			unxlate_dev_mem_ptr(p, ptr);
+			if (copied) {
+				written += sz - copied;
+				if (written)
+					break;
+				return -EFAULT;
+			}
 		}
 
 		buf += sz;",linux,a4866aa812518ed1a37d8ea0c881dc946409de94,b9b3322f13f350587f17f0a76f008830e3a420d3,1,"static ssize_t write_mem(struct file *file, const char __user *buf,
			 size_t count, loff_t *ppos)
{
	phys_addr_t p = *ppos;
	ssize_t written, sz;
	unsigned long copied;
	void *ptr;

	if (p != *ppos)
		return -EFBIG;

	if (!valid_phys_addr_range(p, count))
		return -EFAULT;

	written = 0;

#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED
	/* we don't have page 0 mapped on sparc and m68k.. */
	if (p < PAGE_SIZE) {
		sz = size_inside_page(p, count);
		/* Hmm. Do something? */
		buf += sz;
		p += sz;
		count -= sz;
		written += sz;
	}
 #endif
 
 	while (count > 0) {
//fix_flaw_line_below:
//		int allowed;
//fix_flaw_line_below:
//
 		sz = size_inside_page(p, count);
 
//flaw_line_below:
		if (!range_is_allowed(p >> PAGE_SHIFT, sz))
//fix_flaw_line_below:
//		allowed = page_is_allowed(p >> PAGE_SHIFT);
//fix_flaw_line_below:
//		if (!allowed)
 			return -EPERM;
 
//flaw_line_below:
		/*
//flaw_line_below:
		 * On ia64 if a page has been mapped somewhere as uncached, then
//flaw_line_below:
		 * it must also be accessed uncached by the kernel or data
//flaw_line_below:
		 * corruption may occur.
//flaw_line_below:
		 */
//flaw_line_below:
		ptr = xlate_dev_mem_ptr(p);
//flaw_line_below:
		if (!ptr) {
//flaw_line_below:
			if (written)
//flaw_line_below:
				break;
//flaw_line_below:
			return -EFAULT;
//flaw_line_below:
		}
//fix_flaw_line_below:
//		/* Skip actual writing when a page is marked as restricted. */
//fix_flaw_line_below:
//		if (allowed == 1) {
//fix_flaw_line_below:
//			/*
//fix_flaw_line_below:
//			 * On ia64 if a page has been mapped somewhere as
//fix_flaw_line_below:
//			 * uncached, then it must also be accessed uncached
//fix_flaw_line_below:
//			 * by the kernel or data corruption may occur.
//fix_flaw_line_below:
//			 */
//fix_flaw_line_below:
//			ptr = xlate_dev_mem_ptr(p);
//fix_flaw_line_below:
//			if (!ptr) {
//fix_flaw_line_below:
//				if (written)
//fix_flaw_line_below:
//					break;
//fix_flaw_line_below:
//				return -EFAULT;
//fix_flaw_line_below:
//			}
 
//flaw_line_below:
		copied = copy_from_user(ptr, buf, sz);
//flaw_line_below:
		unxlate_dev_mem_ptr(p, ptr);
//flaw_line_below:
		if (copied) {
//flaw_line_below:
			written += sz - copied;
//flaw_line_below:
			if (written)
//flaw_line_below:
				break;
//flaw_line_below:
			return -EFAULT;
//fix_flaw_line_below:
//			copied = copy_from_user(ptr, buf, sz);
//fix_flaw_line_below:
//			unxlate_dev_mem_ptr(p, ptr);
//fix_flaw_line_below:
//			if (copied) {
//fix_flaw_line_below:
//				written += sz - copied;
//fix_flaw_line_below:
//				if (written)
//fix_flaw_line_below:
//					break;
//fix_flaw_line_below:
//				return -EFAULT;
//fix_flaw_line_below:
//			}
 		}
 
 		buf += sz;
		p += sz;
		count -= sz;
		written += sz;
	}

	*ppos += written;
	return written;
}
"
4576,182312,,Remote,Not required,Partial,CVE-2018-14043,https://www.cvedetails.com/cve/CVE-2018-14043/,CWE-732,Low,Partial,Partial,,2018-07-13,7.5,"mstdlib (aka the M Standard Library for C) 1.2.0 has incorrect file access control in situations where M_fs_perms_can_access attempts to delete an existing file (that lacks public read/write access) during a copy operation, related to fs/m_fs.c and fs/m_fs_path.c. An attacker could create the file and then would have access to the data.",2019-10-02,,1,https://github.com/Monetra/mstdlib/commit/db124b8f607dd0a40a9aef2d4d468fad433522a7,db124b8f607dd0a40a9aef2d4d468fad433522a7,fs: Don't try to delete the file when copying. It could cause a security issue if the file exists and doesn't allow other's to read/write. delete could allow someone to create the file and have access to the data.,2,base/fs/m_fs.c,"{""sha"": ""57f2a313bd3b217f64fd91d2d4a81272ac148734"", ""filename"": ""base/fs/m_fs.c"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 27, ""changes"": 52, ""blob_url"": ""https://github.com/Monetra/mstdlib/blob/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs.c"", ""raw_url"": ""https://github.com/Monetra/mstdlib/raw/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs.c"", ""contents_url"": ""https://api.github.com/repos/Monetra/mstdlib/contents/base/fs/m_fs.c?ref=db124b8f607dd0a40a9aef2d4d468fad433522a7"", ""patch"": ""@@ -101,6 +101,15 @@ static M_bool M_fs_isfileintodir(const char *p1, const char *p2, char **new_p2)\n \treturn M_TRUE;\n }\n \n+/* Used by copy and move to determine if we can write to the given path\n+ * based on a file already existing there or not.\n+ *\n+ * access is used to determine existence because we don't want to overwrite\n+ * if there already is a file. This is not guaranteed because if there is\n+ * a race condition where a file is created after this check it will be\n+ * overwritten. Not much we can do about that. It shouldn't pose a security\n+ * issue since this is more of a request than a requirement.\n+ */\n static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uint32 mode)\n {\n \tM_fs_info_t  *info = NULL;\n@@ -129,8 +138,7 @@ static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uin\n \n \tif (type != M_FS_TYPE_DIR) {\n \t\t/* File exists at path. */\n-\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS)\n-\t\t{\n+\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n \t\t\tret = M_FALSE;\n \t\t\tgoto done;\n \t\t}\n@@ -209,19 +217,6 @@ static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M\n \tsize_t         offset;\n \tM_fs_error_t   res;\n \n-\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it\n- \t * to new file. */\n-\tif (M_fs_perms_can_access(path_new, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n-\t\t/* Try to delete the file since we'll be overwrite it. This is so when we create the file we create it without\n- \t\t * any permissions and to ensure that anything that has the file already open won't be able to read the new\n-\t\t * contents we're writing to the file or be able to change the perms. There is an unavoidable race condition\n-\t\t * between deleting and creating the file where someone could create the file and have access. However,\n-\t\t * depending on the OS they may have access even if the file is created with no perms... */\n-\t\tres = M_fs_delete(path_new, M_FALSE, NULL, M_FS_PROGRESS_NOEXTRA);\n-\t\tif (res != M_FS_ERROR_SUCCESS) {\n-\t\t\treturn res;\n-\t\t}\n-\t}\n \t/* Open the old file */\n \tres = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);\n \tif (res != M_FS_ERROR_SUCCESS) {\n@@ -236,6 +231,9 @@ static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M\n \t\t}\n \t\tperms = M_fs_info_get_perms(info);\n \t}\n+\n+\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it\n+\t * to new file. */\n \tres = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);\n \tM_fs_info_destroy(info);\n \tif (res != M_FS_ERROR_SUCCESS) {\n@@ -333,7 +331,7 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode\n \t}\n \n \t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n- \t * existing to rename because any check we perform may not be true when rename is called. */\n+\t * existing to rename because any check we perform may not be true when rename is called. */\n \tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n \tif (res != M_FS_ERROR_SUCCESS) {\n \t\tM_free(norm_path_new);\n@@ -351,7 +349,7 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode\n \t\treturn res;\n \t}\n \n- \t/* There is a race condition where the path could not exist but be created between the exists check and calling\n+\t/* There is a race condition where the path could not exist but be created between the exists check and calling\n \t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n \t * situation won't cause an error. */\n \tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n@@ -399,15 +397,15 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode\n \t\t\tres = M_fs_delete(norm_path_old, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t\t} else {\n \t\t\t/* Failure - Delete the new files that were copied but only if we are not overwriting. We don't\n- \t\t\t * want to remove any existing files (especially if the dest is a dir). */\n+\t\t\t * want to remove any existing files (especially if the dest is a dir). */\n \t\t\tif (!(mode & M_FS_FILE_MODE_OVERWRITE)) {\n \t\t\t\tM_fs_delete(norm_path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t\t\t}\n \t\t\tres = M_FS_ERROR_GENERIC;\n \t\t}\n \t} else {\n \t\t/* Call the cb with the result of the move whether it was a success for fail. We call the cb only if the\n- \t\t * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */\n+\t\t * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */\n \t\tif (cb) {\n \t\t\tM_fs_progress_set_result(progress, res);\n \t\t\tif (!cb(progress)) {\n@@ -465,7 +463,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \t}\n \n \t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n- \t * existing to rename because any check we perform may not be true when rename is called. */\n+\t * existing to rename because any check we perform may not be true when rename is called. */\n \tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n \tif (res != M_FS_ERROR_SUCCESS) {\n \t\tM_free(norm_path_new);\n@@ -485,7 +483,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \n \ttype = M_fs_info_get_type(info);\n \n- \t/* There is a race condition where the path could not exist but be created between the exists check and calling\n+\t/* There is a race condition where the path could not exist but be created between the exists check and calling\n \t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n \t * situation won't cause an error. */\n \tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n@@ -497,7 +495,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \n \tentries = M_fs_dir_entries_create();\n \t/* No need to destroy info  because it's now owned by entries and will be destroyed when entries is destroyed.\n- \t * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is\n+\t * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is\n \t * stored in the entry. */\n \tM_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path_new, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));\n \tif (type == M_FS_TYPE_DIR) {\n@@ -523,7 +521,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \n \t\t\ttype = M_fs_dir_entry_get_type(entry);\n \t\t\t/* The total isn't the total number of files but the total number of operations. \n- \t\t\t * Making dirs and symlinks is one operation and copying a file will be split into\n+\t\t\t * Making dirs and symlinks is one operation and copying a file will be split into\n \t\t\t * multiple operations. Copying uses the M_FS_BUF_SIZE to read and write in\n \t\t\t * chunks. We determine how many chunks will be needed to read the entire file and\n \t\t\t * use that for the number of operations for the file. */\n@@ -600,7 +598,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \t}\n \n \t/* Delete the file(s) if it could not be copied properly, but only if we are not overwriting.\n- \t * If we're overwriting then there could be other files in that location (especially if it's a dir). */\n+\t * If we're overwriting then there could be other files in that location (especially if it's a dir). */\n \tif (res != M_FS_ERROR_SUCCESS && !(mode & M_FS_FILE_MODE_OVERWRITE)) {\n \t\tM_fs_delete(path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t}\n@@ -659,7 +657,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress\n \tentries = M_fs_dir_entries_create();\n \n \t/* Recursive directory deletion isn't intuitive. We have to generate a list of files and delete the list.\n- \t * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior\n+\t * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior\n \t * is undefined in Posix and HFS is known to skip files if the directory contents is modifies as the\n \t * directory is being walked. */\n \tif (type == M_FS_TYPE_DIR && remove_children) {\n@@ -671,7 +669,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress\n \t}\n \n \t/* Add the original path to the list of entries. This may be the only entry in the list. We need to add\n- \t * it after a potential walk because we can't delete a directory that isn't empty.\n+\t * it after a potential walk because we can't delete a directory that isn't empty.\n \t * Note: \n \t *   - The info will be owned by the entry and destroyed when it is destroyed. \n \t *   - The basic info param doesn't get the info in this case. it's set so the info is stored in the entry. */\n@@ -680,7 +678,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress\n \tlen = M_fs_dir_entries_len(entries);\n \tif (cb) {\n \t\t/* Create the progress. The same progress will be used for the entire operation. It will be updated with\n- \t\t * new info as necessary. */\n+\t\t * new info as necessary. */\n \t\tprogress = M_fs_progress_create();\n \n \t\t/* Get the total size of all files to be deleted if using the progress cb and size totals is set. */""}<_**next**_>{""sha"": ""952fe45f15c30f70e88bdb4293c37ea72992c9bc"", ""filename"": ""base/fs/m_fs_path.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 3, ""changes"": 22, ""blob_url"": ""https://github.com/Monetra/mstdlib/blob/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs_path.c"", ""raw_url"": ""https://github.com/Monetra/mstdlib/raw/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs_path.c"", ""contents_url"": ""https://api.github.com/repos/Monetra/mstdlib/contents/base/fs/m_fs_path.c?ref=db124b8f607dd0a40a9aef2d4d468fad433522a7"", ""patch"": ""@@ -254,7 +254,7 @@ char *M_fs_path_join_parts(const M_list_str_t *path, M_fs_system_t sys_type)\n \tsys_type = M_fs_path_get_system_type(sys_type);\n \n \t/* Remove any empty parts (except for the first part which denotes an abs path on Unix\n- \t * or a UNC path on Windows). */\n+\t * or a UNC path on Windows). */\n \tparts = M_list_str_duplicate(path);\n \tfor (i=len-1; i>0; i--) {\n \t\tpart = M_list_str_at(parts, i);\n@@ -536,7 +536,7 @@ M_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)\n \t}\n \n \t/* Hidden. Check if the first character of the last part of the path. Either the file or directory name itself\n- \t * starts with a '.'. */\n+\t * starts with a '.'. */\n \tpath_parts = M_fs_path_componentize_path(path, M_FS_SYSTEM_UNIX);\n \tlen = M_list_str_len(path_parts);\n \tif (len > 0) {\n@@ -601,7 +601,23 @@ char *M_fs_path_tmpdir(M_fs_system_t sys_type)\n \td = M_fs_path_mac_tmpdir();\n #else\n \tconst char *const_temp;\n-\t/* Try Unix env var. */\n+\t/* Unix doens't have a fancy function to get the standard\n+\t * temporary directory an application can use. Instead there\n+\t * is a convoluted set of possible paths that could be used.\n+\t *\n+\t * We're going to go though each one in a priority order and\n+\t * verify if we can read and write the directory. If so then\n+\t * that's the one that will be used. We are fine using access\n+\t * here because it doesn't matter if the path ends up being\n+\t * changed out from underneath us later on. When it's used\n+\t * at that time it will fail. Right now we just want to get\n+\t * a path that can be tried. */\n+\n+\t/* Try Unix env vars.\n+\t *\n+\t * This is not ideal but a valid way to set the temporary directory\n+\t * for a user. Per Single Unix Specification 4 and probably other things.\n+\t */\n #  ifdef HAVE_SECURE_GETENV\n \tconst_temp = secure_getenv(\""TMPDIR\"");\n #  else""}"," static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uint32 mode)
 {
 	M_fs_info_t  *info = NULL;
	char         *pold = NULL;
	char         *pnew = NULL;
	M_fs_type_t   type;
	M_bool        ret  = M_TRUE;

	if (mode & M_FS_FILE_MODE_OVERWRITE)
		return M_TRUE;

	/* If we're not overwriting we need to verify existance.
 	 *
 	 * For files we need to check if the file name exists in the
	 * directory it's being copied to.
	 *
	 * For directories we need to check if the directory name
	 * exists in the directory it's being copied to.
	 */

	if (M_fs_info(&info, p1, M_FS_PATH_INFO_FLAGS_BASIC) != M_FS_ERROR_SUCCESS)
		return M_FALSE;

	type = M_fs_info_get_type(info);
	M_fs_info_destroy(info);
 
 	if (type != M_FS_TYPE_DIR) {
 		/* File exists at path. */
		if (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {
 			ret = M_FALSE;
 			goto done;
 		}
	}

	/* Is dir */
	pold = M_fs_path_basename(p1, M_FS_SYSTEM_AUTO);
	pnew = M_fs_path_join(p2, pnew, M_FS_SYSTEM_AUTO);
	if (M_fs_perms_can_access(pnew, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {
		ret = M_FALSE;
		goto done;
	}

done:
	M_free(pnew);
	M_free(pold);
	return ret;
}
"," static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uint32 mode)
 {
 	M_fs_info_t  *info = NULL;
	char         *pold = NULL;
	char         *pnew = NULL;
	M_fs_type_t   type;
	M_bool        ret  = M_TRUE;

	if (mode & M_FS_FILE_MODE_OVERWRITE)
		return M_TRUE;

	/* If we're not overwriting we need to verify existance.
 	 *
 	 * For files we need to check if the file name exists in the
	 * directory it's being copied to.
	 *
	 * For directories we need to check if the directory name
	 * exists in the directory it's being copied to.
	 */

	if (M_fs_info(&info, p1, M_FS_PATH_INFO_FLAGS_BASIC) != M_FS_ERROR_SUCCESS)
		return M_FALSE;

	type = M_fs_info_get_type(info);
	M_fs_info_destroy(info);
 
 	if (type != M_FS_TYPE_DIR) {
 		/* File exists at path. */
		if (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS)
		{
 			ret = M_FALSE;
 			goto done;
 		}
	}

	/* Is dir */
	pold = M_fs_path_basename(p1, M_FS_SYSTEM_AUTO);
	pnew = M_fs_path_join(p2, pnew, M_FS_SYSTEM_AUTO);
	if (M_fs_perms_can_access(pnew, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {
		ret = M_FALSE;
		goto done;
	}

done:
	M_free(pnew);
	M_free(pold);
	return ret;
}
",C,"		if (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {
","		if (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS)
		{
",,"@@ -101,6 +101,15 @@ static M_bool M_fs_isfileintodir(const char *p1, const char *p2, char **new_p2)
 	return M_TRUE;
 }
 
+/* Used by copy and move to determine if we can write to the given path
+ * based on a file already existing there or not.
+ *
+ * access is used to determine existence because we don't want to overwrite
+ * if there already is a file. This is not guaranteed because if there is
+ * a race condition where a file is created after this check it will be
+ * overwritten. Not much we can do about that. It shouldn't pose a security
+ * issue since this is more of a request than a requirement.
+ */
 static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uint32 mode)
 {
 	M_fs_info_t  *info = NULL;
@@ -129,8 +138,7 @@ static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uin
 
 	if (type != M_FS_TYPE_DIR) {
 		/* File exists at path. */
-		if (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS)
-		{
+		if (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {
 			ret = M_FALSE;
 			goto done;
 		}
@@ -209,19 +217,6 @@ static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M
 	size_t         offset;
 	M_fs_error_t   res;
 
-	/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it
- 	 * to new file. */
-	if (M_fs_perms_can_access(path_new, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {
-		/* Try to delete the file since we'll be overwrite it. This is so when we create the file we create it without
- 		 * any permissions and to ensure that anything that has the file already open won't be able to read the new
-		 * contents we're writing to the file or be able to change the perms. There is an unavoidable race condition
-		 * between deleting and creating the file where someone could create the file and have access. However,
-		 * depending on the OS they may have access even if the file is created with no perms... */
-		res = M_fs_delete(path_new, M_FALSE, NULL, M_FS_PROGRESS_NOEXTRA);
-		if (res != M_FS_ERROR_SUCCESS) {
-			return res;
-		}
-	}
 	/* Open the old file */
 	res = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);
 	if (res != M_FS_ERROR_SUCCESS) {
@@ -236,6 +231,9 @@ static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M
 		}
 		perms = M_fs_info_get_perms(info);
 	}
+
+	/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it
+	 * to new file. */
 	res = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);
 	M_fs_info_destroy(info);
 	if (res != M_FS_ERROR_SUCCESS) {
@@ -333,7 +331,7 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode
 	}
 
 	/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path
- 	 * existing to rename because any check we perform may not be true when rename is called. */
+	 * existing to rename because any check we perform may not be true when rename is called. */
 	res = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);
 	if (res != M_FS_ERROR_SUCCESS) {
 		M_free(norm_path_new);
@@ -351,7 +349,7 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode
 		return res;
 	}
 
- 	/* There is a race condition where the path could not exist but be created between the exists check and calling
+	/* There is a race condition where the path could not exist but be created between the exists check and calling
 	 * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this
 	 * situation won't cause an error. */
 	if (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {
@@ -399,15 +397,15 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode
 			res = M_fs_delete(norm_path_old, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 		} else {
 			/* Failure - Delete the new files that were copied but only if we are not overwriting. We don't
- 			 * want to remove any existing files (especially if the dest is a dir). */
+			 * want to remove any existing files (especially if the dest is a dir). */
 			if (!(mode & M_FS_FILE_MODE_OVERWRITE)) {
 				M_fs_delete(norm_path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 			}
 			res = M_FS_ERROR_GENERIC;
 		}
 	} else {
 		/* Call the cb with the result of the move whether it was a success for fail. We call the cb only if the
- 		 * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */
+		 * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */
 		if (cb) {
 			M_fs_progress_set_result(progress, res);
 			if (!cb(progress)) {
@@ -465,7 +463,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 	}
 
 	/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path
- 	 * existing to rename because any check we perform may not be true when rename is called. */
+	 * existing to rename because any check we perform may not be true when rename is called. */
 	res = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);
 	if (res != M_FS_ERROR_SUCCESS) {
 		M_free(norm_path_new);
@@ -485,7 +483,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 
 	type = M_fs_info_get_type(info);
 
- 	/* There is a race condition where the path could not exist but be created between the exists check and calling
+	/* There is a race condition where the path could not exist but be created between the exists check and calling
 	 * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this
 	 * situation won't cause an error. */
 	if (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {
@@ -497,7 +495,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 
 	entries = M_fs_dir_entries_create();
 	/* No need to destroy info  because it's now owned by entries and will be destroyed when entries is destroyed.
- 	 * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is
+	 * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is
 	 * stored in the entry. */
 	M_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path_new, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));
 	if (type == M_FS_TYPE_DIR) {
@@ -523,7 +521,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 
 			type = M_fs_dir_entry_get_type(entry);
 			/* The total isn't the total number of files but the total number of operations. 
- 			 * Making dirs and symlinks is one operation and copying a file will be split into
+			 * Making dirs and symlinks is one operation and copying a file will be split into
 			 * multiple operations. Copying uses the M_FS_BUF_SIZE to read and write in
 			 * chunks. We determine how many chunks will be needed to read the entire file and
 			 * use that for the number of operations for the file. */
@@ -600,7 +598,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 	}
 
 	/* Delete the file(s) if it could not be copied properly, but only if we are not overwriting.
- 	 * If we're overwriting then there could be other files in that location (especially if it's a dir). */
+	 * If we're overwriting then there could be other files in that location (especially if it's a dir). */
 	if (res != M_FS_ERROR_SUCCESS && !(mode & M_FS_FILE_MODE_OVERWRITE)) {
 		M_fs_delete(path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 	}
@@ -659,7 +657,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress
 	entries = M_fs_dir_entries_create();
 
 	/* Recursive directory deletion isn't intuitive. We have to generate a list of files and delete the list.
- 	 * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior
+	 * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior
 	 * is undefined in Posix and HFS is known to skip files if the directory contents is modifies as the
 	 * directory is being walked. */
 	if (type == M_FS_TYPE_DIR && remove_children) {
@@ -671,7 +669,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress
 	}
 
 	/* Add the original path to the list of entries. This may be the only entry in the list. We need to add
- 	 * it after a potential walk because we can't delete a directory that isn't empty.
+	 * it after a potential walk because we can't delete a directory that isn't empty.
 	 * Note: 
 	 *   - The info will be owned by the entry and destroyed when it is destroyed. 
 	 *   - The basic info param doesn't get the info in this case. it's set so the info is stored in the entry. */
@@ -680,7 +678,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress
 	len = M_fs_dir_entries_len(entries);
 	if (cb) {
 		/* Create the progress. The same progress will be used for the entire operation. It will be updated with
- 		 * new info as necessary. */
+		 * new info as necessary. */
 		progress = M_fs_progress_create();
 
 		/* Get the total size of all files to be deleted if using the progress cb and size totals is set. */",mstdlib,db124b8f607dd0a40a9aef2d4d468fad433522a7,f82091aa7497f952e3183019ae73611c26ccb0b1,1," static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uint32 mode)
 {
 	M_fs_info_t  *info = NULL;
	char         *pold = NULL;
	char         *pnew = NULL;
	M_fs_type_t   type;
	M_bool        ret  = M_TRUE;

	if (mode & M_FS_FILE_MODE_OVERWRITE)
		return M_TRUE;

	/* If we're not overwriting we need to verify existance.
 	 *
 	 * For files we need to check if the file name exists in the
	 * directory it's being copied to.
	 *
	 * For directories we need to check if the directory name
	 * exists in the directory it's being copied to.
	 */

	if (M_fs_info(&info, p1, M_FS_PATH_INFO_FLAGS_BASIC) != M_FS_ERROR_SUCCESS)
		return M_FALSE;

	type = M_fs_info_get_type(info);
	M_fs_info_destroy(info);
 
 	if (type != M_FS_TYPE_DIR) {
 		/* File exists at path. */
//flaw_line_below:
		if (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS)
//flaw_line_below:
		{
//fix_flaw_line_below:
//		if (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {
 			ret = M_FALSE;
 			goto done;
 		}
	}

	/* Is dir */
	pold = M_fs_path_basename(p1, M_FS_SYSTEM_AUTO);
	pnew = M_fs_path_join(p2, pnew, M_FS_SYSTEM_AUTO);
	if (M_fs_perms_can_access(pnew, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {
		ret = M_FALSE;
		goto done;
	}

done:
	M_free(pnew);
	M_free(pold);
	return ret;
}
"
4577,182313,,Remote,Not required,Partial,CVE-2018-14043,https://www.cvedetails.com/cve/CVE-2018-14043/,CWE-732,Low,Partial,Partial,,2018-07-13,7.5,"mstdlib (aka the M Standard Library for C) 1.2.0 has incorrect file access control in situations where M_fs_perms_can_access attempts to delete an existing file (that lacks public read/write access) during a copy operation, related to fs/m_fs.c and fs/m_fs_path.c. An attacker could create the file and then would have access to the data.",2019-10-02,,5,https://github.com/Monetra/mstdlib/commit/db124b8f607dd0a40a9aef2d4d468fad433522a7,db124b8f607dd0a40a9aef2d4d468fad433522a7,fs: Don't try to delete the file when copying. It could cause a security issue if the file exists and doesn't allow other's to read/write. delete could allow someone to create the file and have access to the data.,5,base/fs/m_fs.c,"{""sha"": ""57f2a313bd3b217f64fd91d2d4a81272ac148734"", ""filename"": ""base/fs/m_fs.c"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 27, ""changes"": 52, ""blob_url"": ""https://github.com/Monetra/mstdlib/blob/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs.c"", ""raw_url"": ""https://github.com/Monetra/mstdlib/raw/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs.c"", ""contents_url"": ""https://api.github.com/repos/Monetra/mstdlib/contents/base/fs/m_fs.c?ref=db124b8f607dd0a40a9aef2d4d468fad433522a7"", ""patch"": ""@@ -101,6 +101,15 @@ static M_bool M_fs_isfileintodir(const char *p1, const char *p2, char **new_p2)\n \treturn M_TRUE;\n }\n \n+/* Used by copy and move to determine if we can write to the given path\n+ * based on a file already existing there or not.\n+ *\n+ * access is used to determine existence because we don't want to overwrite\n+ * if there already is a file. This is not guaranteed because if there is\n+ * a race condition where a file is created after this check it will be\n+ * overwritten. Not much we can do about that. It shouldn't pose a security\n+ * issue since this is more of a request than a requirement.\n+ */\n static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uint32 mode)\n {\n \tM_fs_info_t  *info = NULL;\n@@ -129,8 +138,7 @@ static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uin\n \n \tif (type != M_FS_TYPE_DIR) {\n \t\t/* File exists at path. */\n-\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS)\n-\t\t{\n+\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n \t\t\tret = M_FALSE;\n \t\t\tgoto done;\n \t\t}\n@@ -209,19 +217,6 @@ static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M\n \tsize_t         offset;\n \tM_fs_error_t   res;\n \n-\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it\n- \t * to new file. */\n-\tif (M_fs_perms_can_access(path_new, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n-\t\t/* Try to delete the file since we'll be overwrite it. This is so when we create the file we create it without\n- \t\t * any permissions and to ensure that anything that has the file already open won't be able to read the new\n-\t\t * contents we're writing to the file or be able to change the perms. There is an unavoidable race condition\n-\t\t * between deleting and creating the file where someone could create the file and have access. However,\n-\t\t * depending on the OS they may have access even if the file is created with no perms... */\n-\t\tres = M_fs_delete(path_new, M_FALSE, NULL, M_FS_PROGRESS_NOEXTRA);\n-\t\tif (res != M_FS_ERROR_SUCCESS) {\n-\t\t\treturn res;\n-\t\t}\n-\t}\n \t/* Open the old file */\n \tres = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);\n \tif (res != M_FS_ERROR_SUCCESS) {\n@@ -236,6 +231,9 @@ static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M\n \t\t}\n \t\tperms = M_fs_info_get_perms(info);\n \t}\n+\n+\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it\n+\t * to new file. */\n \tres = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);\n \tM_fs_info_destroy(info);\n \tif (res != M_FS_ERROR_SUCCESS) {\n@@ -333,7 +331,7 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode\n \t}\n \n \t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n- \t * existing to rename because any check we perform may not be true when rename is called. */\n+\t * existing to rename because any check we perform may not be true when rename is called. */\n \tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n \tif (res != M_FS_ERROR_SUCCESS) {\n \t\tM_free(norm_path_new);\n@@ -351,7 +349,7 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode\n \t\treturn res;\n \t}\n \n- \t/* There is a race condition where the path could not exist but be created between the exists check and calling\n+\t/* There is a race condition where the path could not exist but be created between the exists check and calling\n \t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n \t * situation won't cause an error. */\n \tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n@@ -399,15 +397,15 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode\n \t\t\tres = M_fs_delete(norm_path_old, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t\t} else {\n \t\t\t/* Failure - Delete the new files that were copied but only if we are not overwriting. We don't\n- \t\t\t * want to remove any existing files (especially if the dest is a dir). */\n+\t\t\t * want to remove any existing files (especially if the dest is a dir). */\n \t\t\tif (!(mode & M_FS_FILE_MODE_OVERWRITE)) {\n \t\t\t\tM_fs_delete(norm_path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t\t\t}\n \t\t\tres = M_FS_ERROR_GENERIC;\n \t\t}\n \t} else {\n \t\t/* Call the cb with the result of the move whether it was a success for fail. We call the cb only if the\n- \t\t * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */\n+\t\t * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */\n \t\tif (cb) {\n \t\t\tM_fs_progress_set_result(progress, res);\n \t\t\tif (!cb(progress)) {\n@@ -465,7 +463,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \t}\n \n \t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n- \t * existing to rename because any check we perform may not be true when rename is called. */\n+\t * existing to rename because any check we perform may not be true when rename is called. */\n \tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n \tif (res != M_FS_ERROR_SUCCESS) {\n \t\tM_free(norm_path_new);\n@@ -485,7 +483,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \n \ttype = M_fs_info_get_type(info);\n \n- \t/* There is a race condition where the path could not exist but be created between the exists check and calling\n+\t/* There is a race condition where the path could not exist but be created between the exists check and calling\n \t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n \t * situation won't cause an error. */\n \tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n@@ -497,7 +495,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \n \tentries = M_fs_dir_entries_create();\n \t/* No need to destroy info  because it's now owned by entries and will be destroyed when entries is destroyed.\n- \t * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is\n+\t * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is\n \t * stored in the entry. */\n \tM_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path_new, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));\n \tif (type == M_FS_TYPE_DIR) {\n@@ -523,7 +521,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \n \t\t\ttype = M_fs_dir_entry_get_type(entry);\n \t\t\t/* The total isn't the total number of files but the total number of operations. \n- \t\t\t * Making dirs and symlinks is one operation and copying a file will be split into\n+\t\t\t * Making dirs and symlinks is one operation and copying a file will be split into\n \t\t\t * multiple operations. Copying uses the M_FS_BUF_SIZE to read and write in\n \t\t\t * chunks. We determine how many chunks will be needed to read the entire file and\n \t\t\t * use that for the number of operations for the file. */\n@@ -600,7 +598,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \t}\n \n \t/* Delete the file(s) if it could not be copied properly, but only if we are not overwriting.\n- \t * If we're overwriting then there could be other files in that location (especially if it's a dir). */\n+\t * If we're overwriting then there could be other files in that location (especially if it's a dir). */\n \tif (res != M_FS_ERROR_SUCCESS && !(mode & M_FS_FILE_MODE_OVERWRITE)) {\n \t\tM_fs_delete(path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t}\n@@ -659,7 +657,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress\n \tentries = M_fs_dir_entries_create();\n \n \t/* Recursive directory deletion isn't intuitive. We have to generate a list of files and delete the list.\n- \t * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior\n+\t * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior\n \t * is undefined in Posix and HFS is known to skip files if the directory contents is modifies as the\n \t * directory is being walked. */\n \tif (type == M_FS_TYPE_DIR && remove_children) {\n@@ -671,7 +669,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress\n \t}\n \n \t/* Add the original path to the list of entries. This may be the only entry in the list. We need to add\n- \t * it after a potential walk because we can't delete a directory that isn't empty.\n+\t * it after a potential walk because we can't delete a directory that isn't empty.\n \t * Note: \n \t *   - The info will be owned by the entry and destroyed when it is destroyed. \n \t *   - The basic info param doesn't get the info in this case. it's set so the info is stored in the entry. */\n@@ -680,7 +678,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress\n \tlen = M_fs_dir_entries_len(entries);\n \tif (cb) {\n \t\t/* Create the progress. The same progress will be used for the entire operation. It will be updated with\n- \t\t * new info as necessary. */\n+\t\t * new info as necessary. */\n \t\tprogress = M_fs_progress_create();\n \n \t\t/* Get the total size of all files to be deleted if using the progress cb and size totals is set. */""}<_**next**_>{""sha"": ""952fe45f15c30f70e88bdb4293c37ea72992c9bc"", ""filename"": ""base/fs/m_fs_path.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 3, ""changes"": 22, ""blob_url"": ""https://github.com/Monetra/mstdlib/blob/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs_path.c"", ""raw_url"": ""https://github.com/Monetra/mstdlib/raw/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs_path.c"", ""contents_url"": ""https://api.github.com/repos/Monetra/mstdlib/contents/base/fs/m_fs_path.c?ref=db124b8f607dd0a40a9aef2d4d468fad433522a7"", ""patch"": ""@@ -254,7 +254,7 @@ char *M_fs_path_join_parts(const M_list_str_t *path, M_fs_system_t sys_type)\n \tsys_type = M_fs_path_get_system_type(sys_type);\n \n \t/* Remove any empty parts (except for the first part which denotes an abs path on Unix\n- \t * or a UNC path on Windows). */\n+\t * or a UNC path on Windows). */\n \tparts = M_list_str_duplicate(path);\n \tfor (i=len-1; i>0; i--) {\n \t\tpart = M_list_str_at(parts, i);\n@@ -536,7 +536,7 @@ M_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)\n \t}\n \n \t/* Hidden. Check if the first character of the last part of the path. Either the file or directory name itself\n- \t * starts with a '.'. */\n+\t * starts with a '.'. */\n \tpath_parts = M_fs_path_componentize_path(path, M_FS_SYSTEM_UNIX);\n \tlen = M_list_str_len(path_parts);\n \tif (len > 0) {\n@@ -601,7 +601,23 @@ char *M_fs_path_tmpdir(M_fs_system_t sys_type)\n \td = M_fs_path_mac_tmpdir();\n #else\n \tconst char *const_temp;\n-\t/* Try Unix env var. */\n+\t/* Unix doens't have a fancy function to get the standard\n+\t * temporary directory an application can use. Instead there\n+\t * is a convoluted set of possible paths that could be used.\n+\t *\n+\t * We're going to go though each one in a priority order and\n+\t * verify if we can read and write the directory. If so then\n+\t * that's the one that will be used. We are fine using access\n+\t * here because it doesn't matter if the path ends up being\n+\t * changed out from underneath us later on. When it's used\n+\t * at that time it will fail. Right now we just want to get\n+\t * a path that can be tried. */\n+\n+\t/* Try Unix env vars.\n+\t *\n+\t * This is not ideal but a valid way to set the temporary directory\n+\t * for a user. Per Single Unix Specification 4 and probably other things.\n+\t */\n #  ifdef HAVE_SECURE_GETENV\n \tconst_temp = secure_getenv(\""TMPDIR\"");\n #  else""}","M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode, M_fs_progress_cb_t cb, M_uint32 progress_flags)
{
	char                   *norm_path_old;
	char                   *norm_path_new;
	char                   *join_path_old;
	char                   *join_path_new;
	M_fs_dir_entries_t     *entries;
	const M_fs_dir_entry_t *entry;
	M_fs_info_t            *info;
	M_fs_progress_t        *progress            = NULL;
	M_fs_dir_walk_filter_t  filter              = M_FS_DIR_WALK_FILTER_ALL|M_FS_DIR_WALK_FILTER_RECURSE;
	M_fs_type_t             type;
	size_t                  len;
	size_t                  i;
	M_uint64                total_count         = 0;
	M_uint64                total_size          = 0;
	M_uint64                total_size_progress = 0;
	M_uint64                entry_size;
	M_fs_error_t            res;

	if (path_old == NULL || *path_old == '\0' || path_new == NULL || *path_new == '\0') {
		return M_FS_ERROR_INVALID;
	}

	/* It's okay if new path doesn't exist. */
	res = M_fs_path_norm(&norm_path_new, path_new, M_FS_PATH_NORM_RESDIR, M_FS_SYSTEM_AUTO);
	if (res != M_FS_ERROR_SUCCESS) {
		M_free(norm_path_new);
		return res;
	}

	/* If a path is a file and the destination is a directory the file should be copied
	 * into the directory. E.g. /file.txt -> /dir = /dir/file.txt */
	if (M_fs_isfileintodir(path_old, path_new, &norm_path_old)) {
		M_free(norm_path_new);
		res = M_fs_copy(path_old, norm_path_old, mode, cb, progress_flags);
		M_free(norm_path_old);
		return res;
 	}
 
 	/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path
	 * existing to rename because any check we perform may not be true when rename is called. */
 	res = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);
 	if (res != M_FS_ERROR_SUCCESS) {
 		M_free(norm_path_new);
		M_free(norm_path_old);
		return res;
	}

	progress = M_fs_progress_create();

	res = M_fs_info(&info, path_old, (mode & M_FS_FILE_MODE_PRESERVE_PERMS)?M_FS_PATH_INFO_FLAGS_NONE:M_FS_PATH_INFO_FLAGS_BASIC);
	if (res != M_FS_ERROR_SUCCESS) {
		M_fs_progress_destroy(progress);
		M_free(norm_path_new);
		M_free(norm_path_old);
		return res;
	}
 
 	type = M_fs_info_get_type(info);
 
	/* There is a race condition where the path could not exist but be created between the exists check and calling
 	 * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this
 	 * situation won't cause an error. */
 	if (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {
		M_fs_progress_destroy(progress);
		M_free(norm_path_new);
		M_free(norm_path_old);
		return M_FS_ERROR_FILE_EXISTS;
	}
 
 	entries = M_fs_dir_entries_create();
 	/* No need to destroy info  because it's now owned by entries and will be destroyed when entries is destroyed.
	 * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is
 	 * stored in the entry. */
 	M_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path_new, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));
 	if (type == M_FS_TYPE_DIR) {
		if (mode & M_FS_FILE_MODE_PRESERVE_PERMS) {
			filter |= M_FS_DIR_WALK_FILTER_READ_INFO_FULL;
		} else if (cb && progress_flags & (M_FS_PROGRESS_SIZE_TOTAL|M_FS_PROGRESS_SIZE_CUR)) {
			filter |= M_FS_DIR_WALK_FILTER_READ_INFO_BASIC;
		}
		/* Get all the files under the dir. */
		M_fs_dir_entries_merge(&entries, M_fs_dir_walk_entries(norm_path_old, NULL, filter));
	}

	/* Put all dirs first. We need to ensure the dir(s) exist before we can copy files. */
	M_fs_dir_entries_sort(entries, M_FS_DIR_SORT_ISDIR, M_TRUE, M_FS_DIR_SORT_NAME_CASECMP, M_TRUE);

	len = M_fs_dir_entries_len(entries);
	if (cb) {
		total_size = 0;
		for (i=0; i<len; i++) {
			entry       = M_fs_dir_entries_at(entries, i);
			entry_size  = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));
			total_size += entry_size;
 
 			type = M_fs_dir_entry_get_type(entry);
 			/* The total isn't the total number of files but the total number of operations. 
			 * Making dirs and symlinks is one operation and copying a file will be split into
 			 * multiple operations. Copying uses the M_FS_BUF_SIZE to read and write in
 			 * chunks. We determine how many chunks will be needed to read the entire file and
 			 * use that for the number of operations for the file. */
			if (type == M_FS_TYPE_DIR || type == M_FS_TYPE_SYMLINK) {
				total_count++;
			} else {
				total_count += (entry_size + M_FS_BUF_SIZE - 1) / M_FS_BUF_SIZE;
			}
		}
		/* Change the progress total size to reflect all entries. */
		if (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {
			M_fs_progress_set_size_total(progress, total_size);
		}
		/* Change the progress count to reflect the count. */
		if (progress_flags & M_FS_PROGRESS_COUNT) {
			M_fs_progress_set_count_total(progress, total_count);
		}
	}
	for (i=0; i<len; i++) {
		entry         = M_fs_dir_entries_at(entries, i);
		type          = M_fs_dir_entry_get_type(entry);
		join_path_old = M_fs_path_join(norm_path_old, M_fs_dir_entry_get_name(entry), M_FS_SYSTEM_AUTO);
		join_path_new = M_fs_path_join(norm_path_new, M_fs_dir_entry_get_name(entry), M_FS_SYSTEM_AUTO);

		entry_size           = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));
		total_size_progress += entry_size;

		if (cb) {
			M_fs_progress_set_path(progress, join_path_new);
			if (progress_flags & M_FS_PROGRESS_SIZE_CUR) {
				M_fs_progress_set_size_current(progress, entry_size);
			}
		}

		/* op */
		if (type == M_FS_TYPE_DIR || type == M_FS_TYPE_SYMLINK) {
			if (type == M_FS_TYPE_DIR) {
				res = M_fs_dir_mkdir(join_path_new, M_FALSE, NULL);
			} else if (type == M_FS_TYPE_SYMLINK) {
				res = M_fs_symlink(join_path_new, M_fs_dir_entry_get_resolved_name(entry));
			} 
			if (res == M_FS_ERROR_SUCCESS && (mode & M_FS_FILE_MODE_PRESERVE_PERMS)) {
				res = M_fs_perms_set_perms(M_fs_info_get_perms(M_fs_dir_entry_get_info(entry)), join_path_new);
			}
		} else {
			res = M_fs_copy_file(join_path_old, join_path_new, mode, cb, progress_flags, progress, M_fs_info_get_perms(M_fs_dir_entry_get_info(entry)));
		}

		M_free(join_path_old);
		M_free(join_path_new);

		/* Call the callback and stop processing if requested. */
		if ((type == M_FS_TYPE_DIR || type == M_FS_TYPE_SYMLINK) && cb) {
			M_fs_progress_set_type(progress, M_fs_dir_entry_get_type(entry));
			M_fs_progress_set_result(progress, res);

			if (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {
				M_fs_progress_set_size_total_progess(progress, total_size_progress);
			}
			if (progress_flags & M_FS_PROGRESS_SIZE_CUR) {
				M_fs_progress_set_size_current_progress(progress, entry_size);
			}
			if (progress_flags & M_FS_PROGRESS_COUNT) {
				M_fs_progress_set_count(progress, M_fs_progress_get_count(progress)+1);
			}

			if (!cb(progress)) {
				res = M_FS_ERROR_CANCELED;
			}
		}
		if (res != M_FS_ERROR_SUCCESS) {
			break;
		}
 	}
 
 	/* Delete the file(s) if it could not be copied properly, but only if we are not overwriting.
	 * If we're overwriting then there could be other files in that location (especially if it's a dir). */
 	if (res != M_FS_ERROR_SUCCESS && !(mode & M_FS_FILE_MODE_OVERWRITE)) {
 		M_fs_delete(path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 	}

	M_fs_dir_entries_destroy(entries);
	M_fs_progress_destroy(progress);
	M_free(norm_path_new);
	M_free(norm_path_old);

	return res;
}
","M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode, M_fs_progress_cb_t cb, M_uint32 progress_flags)
{
	char                   *norm_path_old;
	char                   *norm_path_new;
	char                   *join_path_old;
	char                   *join_path_new;
	M_fs_dir_entries_t     *entries;
	const M_fs_dir_entry_t *entry;
	M_fs_info_t            *info;
	M_fs_progress_t        *progress            = NULL;
	M_fs_dir_walk_filter_t  filter              = M_FS_DIR_WALK_FILTER_ALL|M_FS_DIR_WALK_FILTER_RECURSE;
	M_fs_type_t             type;
	size_t                  len;
	size_t                  i;
	M_uint64                total_count         = 0;
	M_uint64                total_size          = 0;
	M_uint64                total_size_progress = 0;
	M_uint64                entry_size;
	M_fs_error_t            res;

	if (path_old == NULL || *path_old == '\0' || path_new == NULL || *path_new == '\0') {
		return M_FS_ERROR_INVALID;
	}

	/* It's okay if new path doesn't exist. */
	res = M_fs_path_norm(&norm_path_new, path_new, M_FS_PATH_NORM_RESDIR, M_FS_SYSTEM_AUTO);
	if (res != M_FS_ERROR_SUCCESS) {
		M_free(norm_path_new);
		return res;
	}

	/* If a path is a file and the destination is a directory the file should be copied
	 * into the directory. E.g. /file.txt -> /dir = /dir/file.txt */
	if (M_fs_isfileintodir(path_old, path_new, &norm_path_old)) {
		M_free(norm_path_new);
		res = M_fs_copy(path_old, norm_path_old, mode, cb, progress_flags);
		M_free(norm_path_old);
		return res;
 	}
 
 	/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path
 	 * existing to rename because any check we perform may not be true when rename is called. */
 	res = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);
 	if (res != M_FS_ERROR_SUCCESS) {
 		M_free(norm_path_new);
		M_free(norm_path_old);
		return res;
	}

	progress = M_fs_progress_create();

	res = M_fs_info(&info, path_old, (mode & M_FS_FILE_MODE_PRESERVE_PERMS)?M_FS_PATH_INFO_FLAGS_NONE:M_FS_PATH_INFO_FLAGS_BASIC);
	if (res != M_FS_ERROR_SUCCESS) {
		M_fs_progress_destroy(progress);
		M_free(norm_path_new);
		M_free(norm_path_old);
		return res;
	}
 
 	type = M_fs_info_get_type(info);
 
 	/* There is a race condition where the path could not exist but be created between the exists check and calling
 	 * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this
 	 * situation won't cause an error. */
 	if (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {
		M_fs_progress_destroy(progress);
		M_free(norm_path_new);
		M_free(norm_path_old);
		return M_FS_ERROR_FILE_EXISTS;
	}
 
 	entries = M_fs_dir_entries_create();
 	/* No need to destroy info  because it's now owned by entries and will be destroyed when entries is destroyed.
 	 * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is
 	 * stored in the entry. */
 	M_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path_new, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));
 	if (type == M_FS_TYPE_DIR) {
		if (mode & M_FS_FILE_MODE_PRESERVE_PERMS) {
			filter |= M_FS_DIR_WALK_FILTER_READ_INFO_FULL;
		} else if (cb && progress_flags & (M_FS_PROGRESS_SIZE_TOTAL|M_FS_PROGRESS_SIZE_CUR)) {
			filter |= M_FS_DIR_WALK_FILTER_READ_INFO_BASIC;
		}
		/* Get all the files under the dir. */
		M_fs_dir_entries_merge(&entries, M_fs_dir_walk_entries(norm_path_old, NULL, filter));
	}

	/* Put all dirs first. We need to ensure the dir(s) exist before we can copy files. */
	M_fs_dir_entries_sort(entries, M_FS_DIR_SORT_ISDIR, M_TRUE, M_FS_DIR_SORT_NAME_CASECMP, M_TRUE);

	len = M_fs_dir_entries_len(entries);
	if (cb) {
		total_size = 0;
		for (i=0; i<len; i++) {
			entry       = M_fs_dir_entries_at(entries, i);
			entry_size  = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));
			total_size += entry_size;
 
 			type = M_fs_dir_entry_get_type(entry);
 			/* The total isn't the total number of files but the total number of operations. 
 			 * Making dirs and symlinks is one operation and copying a file will be split into
 			 * multiple operations. Copying uses the M_FS_BUF_SIZE to read and write in
 			 * chunks. We determine how many chunks will be needed to read the entire file and
 			 * use that for the number of operations for the file. */
			if (type == M_FS_TYPE_DIR || type == M_FS_TYPE_SYMLINK) {
				total_count++;
			} else {
				total_count += (entry_size + M_FS_BUF_SIZE - 1) / M_FS_BUF_SIZE;
			}
		}
		/* Change the progress total size to reflect all entries. */
		if (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {
			M_fs_progress_set_size_total(progress, total_size);
		}
		/* Change the progress count to reflect the count. */
		if (progress_flags & M_FS_PROGRESS_COUNT) {
			M_fs_progress_set_count_total(progress, total_count);
		}
	}
	for (i=0; i<len; i++) {
		entry         = M_fs_dir_entries_at(entries, i);
		type          = M_fs_dir_entry_get_type(entry);
		join_path_old = M_fs_path_join(norm_path_old, M_fs_dir_entry_get_name(entry), M_FS_SYSTEM_AUTO);
		join_path_new = M_fs_path_join(norm_path_new, M_fs_dir_entry_get_name(entry), M_FS_SYSTEM_AUTO);

		entry_size           = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));
		total_size_progress += entry_size;

		if (cb) {
			M_fs_progress_set_path(progress, join_path_new);
			if (progress_flags & M_FS_PROGRESS_SIZE_CUR) {
				M_fs_progress_set_size_current(progress, entry_size);
			}
		}

		/* op */
		if (type == M_FS_TYPE_DIR || type == M_FS_TYPE_SYMLINK) {
			if (type == M_FS_TYPE_DIR) {
				res = M_fs_dir_mkdir(join_path_new, M_FALSE, NULL);
			} else if (type == M_FS_TYPE_SYMLINK) {
				res = M_fs_symlink(join_path_new, M_fs_dir_entry_get_resolved_name(entry));
			} 
			if (res == M_FS_ERROR_SUCCESS && (mode & M_FS_FILE_MODE_PRESERVE_PERMS)) {
				res = M_fs_perms_set_perms(M_fs_info_get_perms(M_fs_dir_entry_get_info(entry)), join_path_new);
			}
		} else {
			res = M_fs_copy_file(join_path_old, join_path_new, mode, cb, progress_flags, progress, M_fs_info_get_perms(M_fs_dir_entry_get_info(entry)));
		}

		M_free(join_path_old);
		M_free(join_path_new);

		/* Call the callback and stop processing if requested. */
		if ((type == M_FS_TYPE_DIR || type == M_FS_TYPE_SYMLINK) && cb) {
			M_fs_progress_set_type(progress, M_fs_dir_entry_get_type(entry));
			M_fs_progress_set_result(progress, res);

			if (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {
				M_fs_progress_set_size_total_progess(progress, total_size_progress);
			}
			if (progress_flags & M_FS_PROGRESS_SIZE_CUR) {
				M_fs_progress_set_size_current_progress(progress, entry_size);
			}
			if (progress_flags & M_FS_PROGRESS_COUNT) {
				M_fs_progress_set_count(progress, M_fs_progress_get_count(progress)+1);
			}

			if (!cb(progress)) {
				res = M_FS_ERROR_CANCELED;
			}
		}
		if (res != M_FS_ERROR_SUCCESS) {
			break;
		}
 	}
 
 	/* Delete the file(s) if it could not be copied properly, but only if we are not overwriting.
 	 * If we're overwriting then there could be other files in that location (especially if it's a dir). */
 	if (res != M_FS_ERROR_SUCCESS && !(mode & M_FS_FILE_MODE_OVERWRITE)) {
 		M_fs_delete(path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 	}

	M_fs_dir_entries_destroy(entries);
	M_fs_progress_destroy(progress);
	M_free(norm_path_new);
	M_free(norm_path_old);

	return res;
}
",C,"	 * existing to rename because any check we perform may not be true when rename is called. */
	/* There is a race condition where the path could not exist but be created between the exists check and calling
	 * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is
			 * Making dirs and symlinks is one operation and copying a file will be split into
	 * If we're overwriting then there could be other files in that location (especially if it's a dir). */
"," 	 * existing to rename because any check we perform may not be true when rename is called. */
 	/* There is a race condition where the path could not exist but be created between the exists check and calling
 	 * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is
 			 * Making dirs and symlinks is one operation and copying a file will be split into
 	 * If we're overwriting then there could be other files in that location (especially if it's a dir). */
",,"@@ -101,6 +101,15 @@ static M_bool M_fs_isfileintodir(const char *p1, const char *p2, char **new_p2)
 	return M_TRUE;
 }
 
+/* Used by copy and move to determine if we can write to the given path
+ * based on a file already existing there or not.
+ *
+ * access is used to determine existence because we don't want to overwrite
+ * if there already is a file. This is not guaranteed because if there is
+ * a race condition where a file is created after this check it will be
+ * overwritten. Not much we can do about that. It shouldn't pose a security
+ * issue since this is more of a request than a requirement.
+ */
 static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uint32 mode)
 {
 	M_fs_info_t  *info = NULL;
@@ -129,8 +138,7 @@ static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uin
 
 	if (type != M_FS_TYPE_DIR) {
 		/* File exists at path. */
-		if (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS)
-		{
+		if (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {
 			ret = M_FALSE;
 			goto done;
 		}
@@ -209,19 +217,6 @@ static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M
 	size_t         offset;
 	M_fs_error_t   res;
 
-	/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it
- 	 * to new file. */
-	if (M_fs_perms_can_access(path_new, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {
-		/* Try to delete the file since we'll be overwrite it. This is so when we create the file we create it without
- 		 * any permissions and to ensure that anything that has the file already open won't be able to read the new
-		 * contents we're writing to the file or be able to change the perms. There is an unavoidable race condition
-		 * between deleting and creating the file where someone could create the file and have access. However,
-		 * depending on the OS they may have access even if the file is created with no perms... */
-		res = M_fs_delete(path_new, M_FALSE, NULL, M_FS_PROGRESS_NOEXTRA);
-		if (res != M_FS_ERROR_SUCCESS) {
-			return res;
-		}
-	}
 	/* Open the old file */
 	res = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);
 	if (res != M_FS_ERROR_SUCCESS) {
@@ -236,6 +231,9 @@ static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M
 		}
 		perms = M_fs_info_get_perms(info);
 	}
+
+	/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it
+	 * to new file. */
 	res = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);
 	M_fs_info_destroy(info);
 	if (res != M_FS_ERROR_SUCCESS) {
@@ -333,7 +331,7 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode
 	}
 
 	/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path
- 	 * existing to rename because any check we perform may not be true when rename is called. */
+	 * existing to rename because any check we perform may not be true when rename is called. */
 	res = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);
 	if (res != M_FS_ERROR_SUCCESS) {
 		M_free(norm_path_new);
@@ -351,7 +349,7 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode
 		return res;
 	}
 
- 	/* There is a race condition where the path could not exist but be created between the exists check and calling
+	/* There is a race condition where the path could not exist but be created between the exists check and calling
 	 * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this
 	 * situation won't cause an error. */
 	if (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {
@@ -399,15 +397,15 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode
 			res = M_fs_delete(norm_path_old, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 		} else {
 			/* Failure - Delete the new files that were copied but only if we are not overwriting. We don't
- 			 * want to remove any existing files (especially if the dest is a dir). */
+			 * want to remove any existing files (especially if the dest is a dir). */
 			if (!(mode & M_FS_FILE_MODE_OVERWRITE)) {
 				M_fs_delete(norm_path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 			}
 			res = M_FS_ERROR_GENERIC;
 		}
 	} else {
 		/* Call the cb with the result of the move whether it was a success for fail. We call the cb only if the
- 		 * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */
+		 * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */
 		if (cb) {
 			M_fs_progress_set_result(progress, res);
 			if (!cb(progress)) {
@@ -465,7 +463,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 	}
 
 	/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path
- 	 * existing to rename because any check we perform may not be true when rename is called. */
+	 * existing to rename because any check we perform may not be true when rename is called. */
 	res = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);
 	if (res != M_FS_ERROR_SUCCESS) {
 		M_free(norm_path_new);
@@ -485,7 +483,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 
 	type = M_fs_info_get_type(info);
 
- 	/* There is a race condition where the path could not exist but be created between the exists check and calling
+	/* There is a race condition where the path could not exist but be created between the exists check and calling
 	 * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this
 	 * situation won't cause an error. */
 	if (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {
@@ -497,7 +495,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 
 	entries = M_fs_dir_entries_create();
 	/* No need to destroy info  because it's now owned by entries and will be destroyed when entries is destroyed.
- 	 * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is
+	 * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is
 	 * stored in the entry. */
 	M_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path_new, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));
 	if (type == M_FS_TYPE_DIR) {
@@ -523,7 +521,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 
 			type = M_fs_dir_entry_get_type(entry);
 			/* The total isn't the total number of files but the total number of operations. 
- 			 * Making dirs and symlinks is one operation and copying a file will be split into
+			 * Making dirs and symlinks is one operation and copying a file will be split into
 			 * multiple operations. Copying uses the M_FS_BUF_SIZE to read and write in
 			 * chunks. We determine how many chunks will be needed to read the entire file and
 			 * use that for the number of operations for the file. */
@@ -600,7 +598,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 	}
 
 	/* Delete the file(s) if it could not be copied properly, but only if we are not overwriting.
- 	 * If we're overwriting then there could be other files in that location (especially if it's a dir). */
+	 * If we're overwriting then there could be other files in that location (especially if it's a dir). */
 	if (res != M_FS_ERROR_SUCCESS && !(mode & M_FS_FILE_MODE_OVERWRITE)) {
 		M_fs_delete(path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 	}
@@ -659,7 +657,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress
 	entries = M_fs_dir_entries_create();
 
 	/* Recursive directory deletion isn't intuitive. We have to generate a list of files and delete the list.
- 	 * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior
+	 * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior
 	 * is undefined in Posix and HFS is known to skip files if the directory contents is modifies as the
 	 * directory is being walked. */
 	if (type == M_FS_TYPE_DIR && remove_children) {
@@ -671,7 +669,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress
 	}
 
 	/* Add the original path to the list of entries. This may be the only entry in the list. We need to add
- 	 * it after a potential walk because we can't delete a directory that isn't empty.
+	 * it after a potential walk because we can't delete a directory that isn't empty.
 	 * Note: 
 	 *   - The info will be owned by the entry and destroyed when it is destroyed. 
 	 *   - The basic info param doesn't get the info in this case. it's set so the info is stored in the entry. */
@@ -680,7 +678,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress
 	len = M_fs_dir_entries_len(entries);
 	if (cb) {
 		/* Create the progress. The same progress will be used for the entire operation. It will be updated with
- 		 * new info as necessary. */
+		 * new info as necessary. */
 		progress = M_fs_progress_create();
 
 		/* Get the total size of all files to be deleted if using the progress cb and size totals is set. */",mstdlib,db124b8f607dd0a40a9aef2d4d468fad433522a7,f82091aa7497f952e3183019ae73611c26ccb0b1,1,"M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode, M_fs_progress_cb_t cb, M_uint32 progress_flags)
{
	char                   *norm_path_old;
	char                   *norm_path_new;
	char                   *join_path_old;
	char                   *join_path_new;
	M_fs_dir_entries_t     *entries;
	const M_fs_dir_entry_t *entry;
	M_fs_info_t            *info;
	M_fs_progress_t        *progress            = NULL;
	M_fs_dir_walk_filter_t  filter              = M_FS_DIR_WALK_FILTER_ALL|M_FS_DIR_WALK_FILTER_RECURSE;
	M_fs_type_t             type;
	size_t                  len;
	size_t                  i;
	M_uint64                total_count         = 0;
	M_uint64                total_size          = 0;
	M_uint64                total_size_progress = 0;
	M_uint64                entry_size;
	M_fs_error_t            res;

	if (path_old == NULL || *path_old == '\0' || path_new == NULL || *path_new == '\0') {
		return M_FS_ERROR_INVALID;
	}

	/* It's okay if new path doesn't exist. */
	res = M_fs_path_norm(&norm_path_new, path_new, M_FS_PATH_NORM_RESDIR, M_FS_SYSTEM_AUTO);
	if (res != M_FS_ERROR_SUCCESS) {
		M_free(norm_path_new);
		return res;
	}

	/* If a path is a file and the destination is a directory the file should be copied
	 * into the directory. E.g. /file.txt -> /dir = /dir/file.txt */
	if (M_fs_isfileintodir(path_old, path_new, &norm_path_old)) {
		M_free(norm_path_new);
		res = M_fs_copy(path_old, norm_path_old, mode, cb, progress_flags);
		M_free(norm_path_old);
		return res;
 	}
 
 	/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path
//flaw_line_below:
 	 * existing to rename because any check we perform may not be true when rename is called. */
//fix_flaw_line_below:
//	 * existing to rename because any check we perform may not be true when rename is called. */
 	res = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);
 	if (res != M_FS_ERROR_SUCCESS) {
 		M_free(norm_path_new);
		M_free(norm_path_old);
		return res;
	}

	progress = M_fs_progress_create();

	res = M_fs_info(&info, path_old, (mode & M_FS_FILE_MODE_PRESERVE_PERMS)?M_FS_PATH_INFO_FLAGS_NONE:M_FS_PATH_INFO_FLAGS_BASIC);
	if (res != M_FS_ERROR_SUCCESS) {
		M_fs_progress_destroy(progress);
		M_free(norm_path_new);
		M_free(norm_path_old);
		return res;
	}
 
 	type = M_fs_info_get_type(info);
 
//flaw_line_below:
 	/* There is a race condition where the path could not exist but be created between the exists check and calling
//fix_flaw_line_below:
//	/* There is a race condition where the path could not exist but be created between the exists check and calling
 	 * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this
 	 * situation won't cause an error. */
 	if (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {
		M_fs_progress_destroy(progress);
		M_free(norm_path_new);
		M_free(norm_path_old);
		return M_FS_ERROR_FILE_EXISTS;
	}
 
 	entries = M_fs_dir_entries_create();
 	/* No need to destroy info  because it's now owned by entries and will be destroyed when entries is destroyed.
//flaw_line_below:
 	 * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is
//fix_flaw_line_below:
//	 * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is
 	 * stored in the entry. */
 	M_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path_new, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));
 	if (type == M_FS_TYPE_DIR) {
		if (mode & M_FS_FILE_MODE_PRESERVE_PERMS) {
			filter |= M_FS_DIR_WALK_FILTER_READ_INFO_FULL;
		} else if (cb && progress_flags & (M_FS_PROGRESS_SIZE_TOTAL|M_FS_PROGRESS_SIZE_CUR)) {
			filter |= M_FS_DIR_WALK_FILTER_READ_INFO_BASIC;
		}
		/* Get all the files under the dir. */
		M_fs_dir_entries_merge(&entries, M_fs_dir_walk_entries(norm_path_old, NULL, filter));
	}

	/* Put all dirs first. We need to ensure the dir(s) exist before we can copy files. */
	M_fs_dir_entries_sort(entries, M_FS_DIR_SORT_ISDIR, M_TRUE, M_FS_DIR_SORT_NAME_CASECMP, M_TRUE);

	len = M_fs_dir_entries_len(entries);
	if (cb) {
		total_size = 0;
		for (i=0; i<len; i++) {
			entry       = M_fs_dir_entries_at(entries, i);
			entry_size  = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));
			total_size += entry_size;
 
 			type = M_fs_dir_entry_get_type(entry);
 			/* The total isn't the total number of files but the total number of operations. 
//flaw_line_below:
 			 * Making dirs and symlinks is one operation and copying a file will be split into
//fix_flaw_line_below:
//			 * Making dirs and symlinks is one operation and copying a file will be split into
 			 * multiple operations. Copying uses the M_FS_BUF_SIZE to read and write in
 			 * chunks. We determine how many chunks will be needed to read the entire file and
 			 * use that for the number of operations for the file. */
			if (type == M_FS_TYPE_DIR || type == M_FS_TYPE_SYMLINK) {
				total_count++;
			} else {
				total_count += (entry_size + M_FS_BUF_SIZE - 1) / M_FS_BUF_SIZE;
			}
		}
		/* Change the progress total size to reflect all entries. */
		if (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {
			M_fs_progress_set_size_total(progress, total_size);
		}
		/* Change the progress count to reflect the count. */
		if (progress_flags & M_FS_PROGRESS_COUNT) {
			M_fs_progress_set_count_total(progress, total_count);
		}
	}
	for (i=0; i<len; i++) {
		entry         = M_fs_dir_entries_at(entries, i);
		type          = M_fs_dir_entry_get_type(entry);
		join_path_old = M_fs_path_join(norm_path_old, M_fs_dir_entry_get_name(entry), M_FS_SYSTEM_AUTO);
		join_path_new = M_fs_path_join(norm_path_new, M_fs_dir_entry_get_name(entry), M_FS_SYSTEM_AUTO);

		entry_size           = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));
		total_size_progress += entry_size;

		if (cb) {
			M_fs_progress_set_path(progress, join_path_new);
			if (progress_flags & M_FS_PROGRESS_SIZE_CUR) {
				M_fs_progress_set_size_current(progress, entry_size);
			}
		}

		/* op */
		if (type == M_FS_TYPE_DIR || type == M_FS_TYPE_SYMLINK) {
			if (type == M_FS_TYPE_DIR) {
				res = M_fs_dir_mkdir(join_path_new, M_FALSE, NULL);
			} else if (type == M_FS_TYPE_SYMLINK) {
				res = M_fs_symlink(join_path_new, M_fs_dir_entry_get_resolved_name(entry));
			} 
			if (res == M_FS_ERROR_SUCCESS && (mode & M_FS_FILE_MODE_PRESERVE_PERMS)) {
				res = M_fs_perms_set_perms(M_fs_info_get_perms(M_fs_dir_entry_get_info(entry)), join_path_new);
			}
		} else {
			res = M_fs_copy_file(join_path_old, join_path_new, mode, cb, progress_flags, progress, M_fs_info_get_perms(M_fs_dir_entry_get_info(entry)));
		}

		M_free(join_path_old);
		M_free(join_path_new);

		/* Call the callback and stop processing if requested. */
		if ((type == M_FS_TYPE_DIR || type == M_FS_TYPE_SYMLINK) && cb) {
			M_fs_progress_set_type(progress, M_fs_dir_entry_get_type(entry));
			M_fs_progress_set_result(progress, res);

			if (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {
				M_fs_progress_set_size_total_progess(progress, total_size_progress);
			}
			if (progress_flags & M_FS_PROGRESS_SIZE_CUR) {
				M_fs_progress_set_size_current_progress(progress, entry_size);
			}
			if (progress_flags & M_FS_PROGRESS_COUNT) {
				M_fs_progress_set_count(progress, M_fs_progress_get_count(progress)+1);
			}

			if (!cb(progress)) {
				res = M_FS_ERROR_CANCELED;
			}
		}
		if (res != M_FS_ERROR_SUCCESS) {
			break;
		}
 	}
 
 	/* Delete the file(s) if it could not be copied properly, but only if we are not overwriting.
//flaw_line_below:
 	 * If we're overwriting then there could be other files in that location (especially if it's a dir). */
//fix_flaw_line_below:
//	 * If we're overwriting then there could be other files in that location (especially if it's a dir). */
 	if (res != M_FS_ERROR_SUCCESS && !(mode & M_FS_FILE_MODE_OVERWRITE)) {
 		M_fs_delete(path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 	}

	M_fs_dir_entries_destroy(entries);
	M_fs_progress_destroy(progress);
	M_free(norm_path_new);
	M_free(norm_path_old);

	return res;
}
"
4578,182314,,Remote,Not required,Partial,CVE-2018-14043,https://www.cvedetails.com/cve/CVE-2018-14043/,CWE-732,Low,Partial,Partial,,2018-07-13,7.5,"mstdlib (aka the M Standard Library for C) 1.2.0 has incorrect file access control in situations where M_fs_perms_can_access attempts to delete an existing file (that lacks public read/write access) during a copy operation, related to fs/m_fs.c and fs/m_fs_path.c. An attacker could create the file and then would have access to the data.",2019-10-02,,3,https://github.com/Monetra/mstdlib/commit/db124b8f607dd0a40a9aef2d4d468fad433522a7,db124b8f607dd0a40a9aef2d4d468fad433522a7,fs: Don't try to delete the file when copying. It could cause a security issue if the file exists and doesn't allow other's to read/write. delete could allow someone to create the file and have access to the data.,13,base/fs/m_fs.c,"{""sha"": ""57f2a313bd3b217f64fd91d2d4a81272ac148734"", ""filename"": ""base/fs/m_fs.c"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 27, ""changes"": 52, ""blob_url"": ""https://github.com/Monetra/mstdlib/blob/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs.c"", ""raw_url"": ""https://github.com/Monetra/mstdlib/raw/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs.c"", ""contents_url"": ""https://api.github.com/repos/Monetra/mstdlib/contents/base/fs/m_fs.c?ref=db124b8f607dd0a40a9aef2d4d468fad433522a7"", ""patch"": ""@@ -101,6 +101,15 @@ static M_bool M_fs_isfileintodir(const char *p1, const char *p2, char **new_p2)\n \treturn M_TRUE;\n }\n \n+/* Used by copy and move to determine if we can write to the given path\n+ * based on a file already existing there or not.\n+ *\n+ * access is used to determine existence because we don't want to overwrite\n+ * if there already is a file. This is not guaranteed because if there is\n+ * a race condition where a file is created after this check it will be\n+ * overwritten. Not much we can do about that. It shouldn't pose a security\n+ * issue since this is more of a request than a requirement.\n+ */\n static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uint32 mode)\n {\n \tM_fs_info_t  *info = NULL;\n@@ -129,8 +138,7 @@ static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uin\n \n \tif (type != M_FS_TYPE_DIR) {\n \t\t/* File exists at path. */\n-\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS)\n-\t\t{\n+\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n \t\t\tret = M_FALSE;\n \t\t\tgoto done;\n \t\t}\n@@ -209,19 +217,6 @@ static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M\n \tsize_t         offset;\n \tM_fs_error_t   res;\n \n-\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it\n- \t * to new file. */\n-\tif (M_fs_perms_can_access(path_new, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n-\t\t/* Try to delete the file since we'll be overwrite it. This is so when we create the file we create it without\n- \t\t * any permissions and to ensure that anything that has the file already open won't be able to read the new\n-\t\t * contents we're writing to the file or be able to change the perms. There is an unavoidable race condition\n-\t\t * between deleting and creating the file where someone could create the file and have access. However,\n-\t\t * depending on the OS they may have access even if the file is created with no perms... */\n-\t\tres = M_fs_delete(path_new, M_FALSE, NULL, M_FS_PROGRESS_NOEXTRA);\n-\t\tif (res != M_FS_ERROR_SUCCESS) {\n-\t\t\treturn res;\n-\t\t}\n-\t}\n \t/* Open the old file */\n \tres = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);\n \tif (res != M_FS_ERROR_SUCCESS) {\n@@ -236,6 +231,9 @@ static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M\n \t\t}\n \t\tperms = M_fs_info_get_perms(info);\n \t}\n+\n+\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it\n+\t * to new file. */\n \tres = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);\n \tM_fs_info_destroy(info);\n \tif (res != M_FS_ERROR_SUCCESS) {\n@@ -333,7 +331,7 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode\n \t}\n \n \t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n- \t * existing to rename because any check we perform may not be true when rename is called. */\n+\t * existing to rename because any check we perform may not be true when rename is called. */\n \tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n \tif (res != M_FS_ERROR_SUCCESS) {\n \t\tM_free(norm_path_new);\n@@ -351,7 +349,7 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode\n \t\treturn res;\n \t}\n \n- \t/* There is a race condition where the path could not exist but be created between the exists check and calling\n+\t/* There is a race condition where the path could not exist but be created between the exists check and calling\n \t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n \t * situation won't cause an error. */\n \tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n@@ -399,15 +397,15 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode\n \t\t\tres = M_fs_delete(norm_path_old, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t\t} else {\n \t\t\t/* Failure - Delete the new files that were copied but only if we are not overwriting. We don't\n- \t\t\t * want to remove any existing files (especially if the dest is a dir). */\n+\t\t\t * want to remove any existing files (especially if the dest is a dir). */\n \t\t\tif (!(mode & M_FS_FILE_MODE_OVERWRITE)) {\n \t\t\t\tM_fs_delete(norm_path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t\t\t}\n \t\t\tres = M_FS_ERROR_GENERIC;\n \t\t}\n \t} else {\n \t\t/* Call the cb with the result of the move whether it was a success for fail. We call the cb only if the\n- \t\t * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */\n+\t\t * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */\n \t\tif (cb) {\n \t\t\tM_fs_progress_set_result(progress, res);\n \t\t\tif (!cb(progress)) {\n@@ -465,7 +463,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \t}\n \n \t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n- \t * existing to rename because any check we perform may not be true when rename is called. */\n+\t * existing to rename because any check we perform may not be true when rename is called. */\n \tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n \tif (res != M_FS_ERROR_SUCCESS) {\n \t\tM_free(norm_path_new);\n@@ -485,7 +483,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \n \ttype = M_fs_info_get_type(info);\n \n- \t/* There is a race condition where the path could not exist but be created between the exists check and calling\n+\t/* There is a race condition where the path could not exist but be created between the exists check and calling\n \t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n \t * situation won't cause an error. */\n \tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n@@ -497,7 +495,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \n \tentries = M_fs_dir_entries_create();\n \t/* No need to destroy info  because it's now owned by entries and will be destroyed when entries is destroyed.\n- \t * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is\n+\t * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is\n \t * stored in the entry. */\n \tM_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path_new, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));\n \tif (type == M_FS_TYPE_DIR) {\n@@ -523,7 +521,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \n \t\t\ttype = M_fs_dir_entry_get_type(entry);\n \t\t\t/* The total isn't the total number of files but the total number of operations. \n- \t\t\t * Making dirs and symlinks is one operation and copying a file will be split into\n+\t\t\t * Making dirs and symlinks is one operation and copying a file will be split into\n \t\t\t * multiple operations. Copying uses the M_FS_BUF_SIZE to read and write in\n \t\t\t * chunks. We determine how many chunks will be needed to read the entire file and\n \t\t\t * use that for the number of operations for the file. */\n@@ -600,7 +598,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \t}\n \n \t/* Delete the file(s) if it could not be copied properly, but only if we are not overwriting.\n- \t * If we're overwriting then there could be other files in that location (especially if it's a dir). */\n+\t * If we're overwriting then there could be other files in that location (especially if it's a dir). */\n \tif (res != M_FS_ERROR_SUCCESS && !(mode & M_FS_FILE_MODE_OVERWRITE)) {\n \t\tM_fs_delete(path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t}\n@@ -659,7 +657,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress\n \tentries = M_fs_dir_entries_create();\n \n \t/* Recursive directory deletion isn't intuitive. We have to generate a list of files and delete the list.\n- \t * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior\n+\t * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior\n \t * is undefined in Posix and HFS is known to skip files if the directory contents is modifies as the\n \t * directory is being walked. */\n \tif (type == M_FS_TYPE_DIR && remove_children) {\n@@ -671,7 +669,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress\n \t}\n \n \t/* Add the original path to the list of entries. This may be the only entry in the list. We need to add\n- \t * it after a potential walk because we can't delete a directory that isn't empty.\n+\t * it after a potential walk because we can't delete a directory that isn't empty.\n \t * Note: \n \t *   - The info will be owned by the entry and destroyed when it is destroyed. \n \t *   - The basic info param doesn't get the info in this case. it's set so the info is stored in the entry. */\n@@ -680,7 +678,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress\n \tlen = M_fs_dir_entries_len(entries);\n \tif (cb) {\n \t\t/* Create the progress. The same progress will be used for the entire operation. It will be updated with\n- \t\t * new info as necessary. */\n+\t\t * new info as necessary. */\n \t\tprogress = M_fs_progress_create();\n \n \t\t/* Get the total size of all files to be deleted if using the progress cb and size totals is set. */""}<_**next**_>{""sha"": ""952fe45f15c30f70e88bdb4293c37ea72992c9bc"", ""filename"": ""base/fs/m_fs_path.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 3, ""changes"": 22, ""blob_url"": ""https://github.com/Monetra/mstdlib/blob/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs_path.c"", ""raw_url"": ""https://github.com/Monetra/mstdlib/raw/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs_path.c"", ""contents_url"": ""https://api.github.com/repos/Monetra/mstdlib/contents/base/fs/m_fs_path.c?ref=db124b8f607dd0a40a9aef2d4d468fad433522a7"", ""patch"": ""@@ -254,7 +254,7 @@ char *M_fs_path_join_parts(const M_list_str_t *path, M_fs_system_t sys_type)\n \tsys_type = M_fs_path_get_system_type(sys_type);\n \n \t/* Remove any empty parts (except for the first part which denotes an abs path on Unix\n- \t * or a UNC path on Windows). */\n+\t * or a UNC path on Windows). */\n \tparts = M_list_str_duplicate(path);\n \tfor (i=len-1; i>0; i--) {\n \t\tpart = M_list_str_at(parts, i);\n@@ -536,7 +536,7 @@ M_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)\n \t}\n \n \t/* Hidden. Check if the first character of the last part of the path. Either the file or directory name itself\n- \t * starts with a '.'. */\n+\t * starts with a '.'. */\n \tpath_parts = M_fs_path_componentize_path(path, M_FS_SYSTEM_UNIX);\n \tlen = M_list_str_len(path_parts);\n \tif (len > 0) {\n@@ -601,7 +601,23 @@ char *M_fs_path_tmpdir(M_fs_system_t sys_type)\n \td = M_fs_path_mac_tmpdir();\n #else\n \tconst char *const_temp;\n-\t/* Try Unix env var. */\n+\t/* Unix doens't have a fancy function to get the standard\n+\t * temporary directory an application can use. Instead there\n+\t * is a convoluted set of possible paths that could be used.\n+\t *\n+\t * We're going to go though each one in a priority order and\n+\t * verify if we can read and write the directory. If so then\n+\t * that's the one that will be used. We are fine using access\n+\t * here because it doesn't matter if the path ends up being\n+\t * changed out from underneath us later on. When it's used\n+\t * at that time it will fail. Right now we just want to get\n+\t * a path that can be tried. */\n+\n+\t/* Try Unix env vars.\n+\t *\n+\t * This is not ideal but a valid way to set the temporary directory\n+\t * for a user. Per Single Unix Specification 4 and probably other things.\n+\t */\n #  ifdef HAVE_SECURE_GETENV\n \tconst_temp = secure_getenv(\""TMPDIR\"");\n #  else""}","static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M_fs_file_mode_t mode, M_fs_progress_cb_t cb, M_fs_progress_flags_t progress_flags, M_fs_progress_t *progress, const M_fs_perms_t *perms)
{
	M_fs_file_t   *fd_old;
	M_fs_file_t   *fd_new;
	M_fs_info_t   *info         = NULL;
	unsigned char  temp[M_FS_BUF_SIZE];
	size_t         read_len;
	size_t         wrote_len;
	size_t         wrote_total  = 0;
 	size_t         offset;
 	M_fs_error_t   res;
 
 	/* Open the old file */
 	res = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);
 	if (res != M_FS_ERROR_SUCCESS) {
		return res;
	}

	if (perms == NULL && mode & M_FS_FILE_MODE_PRESERVE_PERMS) {
		res = M_fs_info_file(&info, fd_old, M_FS_PATH_INFO_FLAGS_NONE);
		if (res != M_FS_ERROR_SUCCESS) {
			M_fs_file_close(fd_old);
			return res;
 		}
 		perms = M_fs_info_get_perms(info);
 	}

	/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it
	 * to new file. */
 	res = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);
 	M_fs_info_destroy(info);
 	if (res != M_FS_ERROR_SUCCESS) {
		M_fs_file_close(fd_old);
		return res;
	}

	/* Copy the contents of old into new. */
	while ((res = M_fs_file_read(fd_old, temp, sizeof(temp), &read_len, M_FS_FILE_RW_NORMAL)) == M_FS_ERROR_SUCCESS && read_len != 0) {
		offset = 0;
		while (offset < read_len) {
			res          = M_fs_file_write(fd_new, temp+offset, read_len-offset, &wrote_len, M_FS_FILE_RW_NORMAL);
			offset      += wrote_len;
			wrote_total += wrote_len;

			if (cb) {
				M_fs_progress_set_result(progress, res);
				if (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {
					M_fs_progress_set_size_total_progess(progress, M_fs_progress_get_size_total_progess(progress)+wrote_len);
				}
				if (progress_flags & M_FS_PROGRESS_SIZE_CUR) {
					M_fs_progress_set_size_current_progress(progress, wrote_total);
				}
				if (progress_flags & M_FS_PROGRESS_COUNT) {
					M_fs_progress_set_count(progress, M_fs_progress_get_count(progress)+1);
				}
				if (!cb(progress)) {
					res = M_FS_ERROR_CANCELED;
				}
			}

			if (res != M_FS_ERROR_SUCCESS) {
				break;
			}
		}
		if (res != M_FS_ERROR_SUCCESS) {
			break;
		}
	}
	M_fs_file_close(fd_old);
	M_fs_file_close(fd_new);
	if (res != M_FS_ERROR_SUCCESS) {
		return res;
	}

	return M_FS_ERROR_SUCCESS;
}
","static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M_fs_file_mode_t mode, M_fs_progress_cb_t cb, M_fs_progress_flags_t progress_flags, M_fs_progress_t *progress, const M_fs_perms_t *perms)
{
	M_fs_file_t   *fd_old;
	M_fs_file_t   *fd_new;
	M_fs_info_t   *info         = NULL;
	unsigned char  temp[M_FS_BUF_SIZE];
	size_t         read_len;
	size_t         wrote_len;
	size_t         wrote_total  = 0;
 	size_t         offset;
 	M_fs_error_t   res;
 
	/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it
 	 * to new file. */
	if (M_fs_perms_can_access(path_new, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {
		/* Try to delete the file since we'll be overwrite it. This is so when we create the file we create it without
 		 * any permissions and to ensure that anything that has the file already open won't be able to read the new
		 * contents we're writing to the file or be able to change the perms. There is an unavoidable race condition
		 * between deleting and creating the file where someone could create the file and have access. However,
		 * depending on the OS they may have access even if the file is created with no perms... */
		res = M_fs_delete(path_new, M_FALSE, NULL, M_FS_PROGRESS_NOEXTRA);
		if (res != M_FS_ERROR_SUCCESS) {
			return res;
		}
	}
 	/* Open the old file */
 	res = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);
 	if (res != M_FS_ERROR_SUCCESS) {
		return res;
	}

	if (perms == NULL && mode & M_FS_FILE_MODE_PRESERVE_PERMS) {
		res = M_fs_info_file(&info, fd_old, M_FS_PATH_INFO_FLAGS_NONE);
		if (res != M_FS_ERROR_SUCCESS) {
			M_fs_file_close(fd_old);
			return res;
 		}
 		perms = M_fs_info_get_perms(info);
 	}
 	res = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);
 	M_fs_info_destroy(info);
 	if (res != M_FS_ERROR_SUCCESS) {
		M_fs_file_close(fd_old);
		return res;
	}

	/* Copy the contents of old into new. */
	while ((res = M_fs_file_read(fd_old, temp, sizeof(temp), &read_len, M_FS_FILE_RW_NORMAL)) == M_FS_ERROR_SUCCESS && read_len != 0) {
		offset = 0;
		while (offset < read_len) {
			res          = M_fs_file_write(fd_new, temp+offset, read_len-offset, &wrote_len, M_FS_FILE_RW_NORMAL);
			offset      += wrote_len;
			wrote_total += wrote_len;

			if (cb) {
				M_fs_progress_set_result(progress, res);
				if (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {
					M_fs_progress_set_size_total_progess(progress, M_fs_progress_get_size_total_progess(progress)+wrote_len);
				}
				if (progress_flags & M_FS_PROGRESS_SIZE_CUR) {
					M_fs_progress_set_size_current_progress(progress, wrote_total);
				}
				if (progress_flags & M_FS_PROGRESS_COUNT) {
					M_fs_progress_set_count(progress, M_fs_progress_get_count(progress)+1);
				}
				if (!cb(progress)) {
					res = M_FS_ERROR_CANCELED;
				}
			}

			if (res != M_FS_ERROR_SUCCESS) {
				break;
			}
		}
		if (res != M_FS_ERROR_SUCCESS) {
			break;
		}
	}
	M_fs_file_close(fd_old);
	M_fs_file_close(fd_new);
	if (res != M_FS_ERROR_SUCCESS) {
		return res;
	}

	return M_FS_ERROR_SUCCESS;
}
",C,"
	/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it
	 * to new file. */
","	/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it
 	 * to new file. */
	if (M_fs_perms_can_access(path_new, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {
		/* Try to delete the file since we'll be overwrite it. This is so when we create the file we create it without
 		 * any permissions and to ensure that anything that has the file already open won't be able to read the new
		 * contents we're writing to the file or be able to change the perms. There is an unavoidable race condition
		 * between deleting and creating the file where someone could create the file and have access. However,
		 * depending on the OS they may have access even if the file is created with no perms... */
		res = M_fs_delete(path_new, M_FALSE, NULL, M_FS_PROGRESS_NOEXTRA);
		if (res != M_FS_ERROR_SUCCESS) {
			return res;
		}
	}
",,"@@ -101,6 +101,15 @@ static M_bool M_fs_isfileintodir(const char *p1, const char *p2, char **new_p2)
 	return M_TRUE;
 }
 
+/* Used by copy and move to determine if we can write to the given path
+ * based on a file already existing there or not.
+ *
+ * access is used to determine existence because we don't want to overwrite
+ * if there already is a file. This is not guaranteed because if there is
+ * a race condition where a file is created after this check it will be
+ * overwritten. Not much we can do about that. It shouldn't pose a security
+ * issue since this is more of a request than a requirement.
+ */
 static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uint32 mode)
 {
 	M_fs_info_t  *info = NULL;
@@ -129,8 +138,7 @@ static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uin
 
 	if (type != M_FS_TYPE_DIR) {
 		/* File exists at path. */
-		if (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS)
-		{
+		if (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {
 			ret = M_FALSE;
 			goto done;
 		}
@@ -209,19 +217,6 @@ static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M
 	size_t         offset;
 	M_fs_error_t   res;
 
-	/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it
- 	 * to new file. */
-	if (M_fs_perms_can_access(path_new, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {
-		/* Try to delete the file since we'll be overwrite it. This is so when we create the file we create it without
- 		 * any permissions and to ensure that anything that has the file already open won't be able to read the new
-		 * contents we're writing to the file or be able to change the perms. There is an unavoidable race condition
-		 * between deleting and creating the file where someone could create the file and have access. However,
-		 * depending on the OS they may have access even if the file is created with no perms... */
-		res = M_fs_delete(path_new, M_FALSE, NULL, M_FS_PROGRESS_NOEXTRA);
-		if (res != M_FS_ERROR_SUCCESS) {
-			return res;
-		}
-	}
 	/* Open the old file */
 	res = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);
 	if (res != M_FS_ERROR_SUCCESS) {
@@ -236,6 +231,9 @@ static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M
 		}
 		perms = M_fs_info_get_perms(info);
 	}
+
+	/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it
+	 * to new file. */
 	res = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);
 	M_fs_info_destroy(info);
 	if (res != M_FS_ERROR_SUCCESS) {
@@ -333,7 +331,7 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode
 	}
 
 	/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path
- 	 * existing to rename because any check we perform may not be true when rename is called. */
+	 * existing to rename because any check we perform may not be true when rename is called. */
 	res = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);
 	if (res != M_FS_ERROR_SUCCESS) {
 		M_free(norm_path_new);
@@ -351,7 +349,7 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode
 		return res;
 	}
 
- 	/* There is a race condition where the path could not exist but be created between the exists check and calling
+	/* There is a race condition where the path could not exist but be created between the exists check and calling
 	 * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this
 	 * situation won't cause an error. */
 	if (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {
@@ -399,15 +397,15 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode
 			res = M_fs_delete(norm_path_old, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 		} else {
 			/* Failure - Delete the new files that were copied but only if we are not overwriting. We don't
- 			 * want to remove any existing files (especially if the dest is a dir). */
+			 * want to remove any existing files (especially if the dest is a dir). */
 			if (!(mode & M_FS_FILE_MODE_OVERWRITE)) {
 				M_fs_delete(norm_path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 			}
 			res = M_FS_ERROR_GENERIC;
 		}
 	} else {
 		/* Call the cb with the result of the move whether it was a success for fail. We call the cb only if the
- 		 * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */
+		 * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */
 		if (cb) {
 			M_fs_progress_set_result(progress, res);
 			if (!cb(progress)) {
@@ -465,7 +463,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 	}
 
 	/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path
- 	 * existing to rename because any check we perform may not be true when rename is called. */
+	 * existing to rename because any check we perform may not be true when rename is called. */
 	res = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);
 	if (res != M_FS_ERROR_SUCCESS) {
 		M_free(norm_path_new);
@@ -485,7 +483,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 
 	type = M_fs_info_get_type(info);
 
- 	/* There is a race condition where the path could not exist but be created between the exists check and calling
+	/* There is a race condition where the path could not exist but be created between the exists check and calling
 	 * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this
 	 * situation won't cause an error. */
 	if (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {
@@ -497,7 +495,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 
 	entries = M_fs_dir_entries_create();
 	/* No need to destroy info  because it's now owned by entries and will be destroyed when entries is destroyed.
- 	 * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is
+	 * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is
 	 * stored in the entry. */
 	M_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path_new, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));
 	if (type == M_FS_TYPE_DIR) {
@@ -523,7 +521,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 
 			type = M_fs_dir_entry_get_type(entry);
 			/* The total isn't the total number of files but the total number of operations. 
- 			 * Making dirs and symlinks is one operation and copying a file will be split into
+			 * Making dirs and symlinks is one operation and copying a file will be split into
 			 * multiple operations. Copying uses the M_FS_BUF_SIZE to read and write in
 			 * chunks. We determine how many chunks will be needed to read the entire file and
 			 * use that for the number of operations for the file. */
@@ -600,7 +598,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 	}
 
 	/* Delete the file(s) if it could not be copied properly, but only if we are not overwriting.
- 	 * If we're overwriting then there could be other files in that location (especially if it's a dir). */
+	 * If we're overwriting then there could be other files in that location (especially if it's a dir). */
 	if (res != M_FS_ERROR_SUCCESS && !(mode & M_FS_FILE_MODE_OVERWRITE)) {
 		M_fs_delete(path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 	}
@@ -659,7 +657,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress
 	entries = M_fs_dir_entries_create();
 
 	/* Recursive directory deletion isn't intuitive. We have to generate a list of files and delete the list.
- 	 * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior
+	 * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior
 	 * is undefined in Posix and HFS is known to skip files if the directory contents is modifies as the
 	 * directory is being walked. */
 	if (type == M_FS_TYPE_DIR && remove_children) {
@@ -671,7 +669,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress
 	}
 
 	/* Add the original path to the list of entries. This may be the only entry in the list. We need to add
- 	 * it after a potential walk because we can't delete a directory that isn't empty.
+	 * it after a potential walk because we can't delete a directory that isn't empty.
 	 * Note: 
 	 *   - The info will be owned by the entry and destroyed when it is destroyed. 
 	 *   - The basic info param doesn't get the info in this case. it's set so the info is stored in the entry. */
@@ -680,7 +678,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress
 	len = M_fs_dir_entries_len(entries);
 	if (cb) {
 		/* Create the progress. The same progress will be used for the entire operation. It will be updated with
- 		 * new info as necessary. */
+		 * new info as necessary. */
 		progress = M_fs_progress_create();
 
 		/* Get the total size of all files to be deleted if using the progress cb and size totals is set. */",mstdlib,db124b8f607dd0a40a9aef2d4d468fad433522a7,f82091aa7497f952e3183019ae73611c26ccb0b1,1,"static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M_fs_file_mode_t mode, M_fs_progress_cb_t cb, M_fs_progress_flags_t progress_flags, M_fs_progress_t *progress, const M_fs_perms_t *perms)
{
	M_fs_file_t   *fd_old;
	M_fs_file_t   *fd_new;
	M_fs_info_t   *info         = NULL;
	unsigned char  temp[M_FS_BUF_SIZE];
	size_t         read_len;
	size_t         wrote_len;
	size_t         wrote_total  = 0;
 	size_t         offset;
 	M_fs_error_t   res;
 
//flaw_line_below:
	/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it
//flaw_line_below:
 	 * to new file. */
//flaw_line_below:
	if (M_fs_perms_can_access(path_new, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {
//flaw_line_below:
		/* Try to delete the file since we'll be overwrite it. This is so when we create the file we create it without
//flaw_line_below:
 		 * any permissions and to ensure that anything that has the file already open won't be able to read the new
//flaw_line_below:
		 * contents we're writing to the file or be able to change the perms. There is an unavoidable race condition
//flaw_line_below:
		 * between deleting and creating the file where someone could create the file and have access. However,
//flaw_line_below:
		 * depending on the OS they may have access even if the file is created with no perms... */
//flaw_line_below:
		res = M_fs_delete(path_new, M_FALSE, NULL, M_FS_PROGRESS_NOEXTRA);
//flaw_line_below:
		if (res != M_FS_ERROR_SUCCESS) {
//flaw_line_below:
			return res;
//flaw_line_below:
		}
//flaw_line_below:
	}
 	/* Open the old file */
 	res = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);
 	if (res != M_FS_ERROR_SUCCESS) {
		return res;
	}

	if (perms == NULL && mode & M_FS_FILE_MODE_PRESERVE_PERMS) {
		res = M_fs_info_file(&info, fd_old, M_FS_PATH_INFO_FLAGS_NONE);
		if (res != M_FS_ERROR_SUCCESS) {
			M_fs_file_close(fd_old);
			return res;
 		}
 		perms = M_fs_info_get_perms(info);
 	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it
//fix_flaw_line_below:
//	 * to new file. */
 	res = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);
 	M_fs_info_destroy(info);
 	if (res != M_FS_ERROR_SUCCESS) {
		M_fs_file_close(fd_old);
		return res;
	}

	/* Copy the contents of old into new. */
	while ((res = M_fs_file_read(fd_old, temp, sizeof(temp), &read_len, M_FS_FILE_RW_NORMAL)) == M_FS_ERROR_SUCCESS && read_len != 0) {
		offset = 0;
		while (offset < read_len) {
			res          = M_fs_file_write(fd_new, temp+offset, read_len-offset, &wrote_len, M_FS_FILE_RW_NORMAL);
			offset      += wrote_len;
			wrote_total += wrote_len;

			if (cb) {
				M_fs_progress_set_result(progress, res);
				if (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {
					M_fs_progress_set_size_total_progess(progress, M_fs_progress_get_size_total_progess(progress)+wrote_len);
				}
				if (progress_flags & M_FS_PROGRESS_SIZE_CUR) {
					M_fs_progress_set_size_current_progress(progress, wrote_total);
				}
				if (progress_flags & M_FS_PROGRESS_COUNT) {
					M_fs_progress_set_count(progress, M_fs_progress_get_count(progress)+1);
				}
				if (!cb(progress)) {
					res = M_FS_ERROR_CANCELED;
				}
			}

			if (res != M_FS_ERROR_SUCCESS) {
				break;
			}
		}
		if (res != M_FS_ERROR_SUCCESS) {
			break;
		}
	}
	M_fs_file_close(fd_old);
	M_fs_file_close(fd_new);
	if (res != M_FS_ERROR_SUCCESS) {
		return res;
	}

	return M_FS_ERROR_SUCCESS;
}
"
4579,182315,,Remote,Not required,Partial,CVE-2018-14043,https://www.cvedetails.com/cve/CVE-2018-14043/,CWE-732,Low,Partial,Partial,,2018-07-13,7.5,"mstdlib (aka the M Standard Library for C) 1.2.0 has incorrect file access control in situations where M_fs_perms_can_access attempts to delete an existing file (that lacks public read/write access) during a copy operation, related to fs/m_fs.c and fs/m_fs_path.c. An attacker could create the file and then would have access to the data.",2019-10-02,,3,https://github.com/Monetra/mstdlib/commit/db124b8f607dd0a40a9aef2d4d468fad433522a7,db124b8f607dd0a40a9aef2d4d468fad433522a7,fs: Don't try to delete the file when copying. It could cause a security issue if the file exists and doesn't allow other's to read/write. delete could allow someone to create the file and have access to the data.,3,base/fs/m_fs.c,"{""sha"": ""57f2a313bd3b217f64fd91d2d4a81272ac148734"", ""filename"": ""base/fs/m_fs.c"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 27, ""changes"": 52, ""blob_url"": ""https://github.com/Monetra/mstdlib/blob/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs.c"", ""raw_url"": ""https://github.com/Monetra/mstdlib/raw/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs.c"", ""contents_url"": ""https://api.github.com/repos/Monetra/mstdlib/contents/base/fs/m_fs.c?ref=db124b8f607dd0a40a9aef2d4d468fad433522a7"", ""patch"": ""@@ -101,6 +101,15 @@ static M_bool M_fs_isfileintodir(const char *p1, const char *p2, char **new_p2)\n \treturn M_TRUE;\n }\n \n+/* Used by copy and move to determine if we can write to the given path\n+ * based on a file already existing there or not.\n+ *\n+ * access is used to determine existence because we don't want to overwrite\n+ * if there already is a file. This is not guaranteed because if there is\n+ * a race condition where a file is created after this check it will be\n+ * overwritten. Not much we can do about that. It shouldn't pose a security\n+ * issue since this is more of a request than a requirement.\n+ */\n static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uint32 mode)\n {\n \tM_fs_info_t  *info = NULL;\n@@ -129,8 +138,7 @@ static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uin\n \n \tif (type != M_FS_TYPE_DIR) {\n \t\t/* File exists at path. */\n-\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS)\n-\t\t{\n+\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n \t\t\tret = M_FALSE;\n \t\t\tgoto done;\n \t\t}\n@@ -209,19 +217,6 @@ static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M\n \tsize_t         offset;\n \tM_fs_error_t   res;\n \n-\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it\n- \t * to new file. */\n-\tif (M_fs_perms_can_access(path_new, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n-\t\t/* Try to delete the file since we'll be overwrite it. This is so when we create the file we create it without\n- \t\t * any permissions and to ensure that anything that has the file already open won't be able to read the new\n-\t\t * contents we're writing to the file or be able to change the perms. There is an unavoidable race condition\n-\t\t * between deleting and creating the file where someone could create the file and have access. However,\n-\t\t * depending on the OS they may have access even if the file is created with no perms... */\n-\t\tres = M_fs_delete(path_new, M_FALSE, NULL, M_FS_PROGRESS_NOEXTRA);\n-\t\tif (res != M_FS_ERROR_SUCCESS) {\n-\t\t\treturn res;\n-\t\t}\n-\t}\n \t/* Open the old file */\n \tres = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);\n \tif (res != M_FS_ERROR_SUCCESS) {\n@@ -236,6 +231,9 @@ static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M\n \t\t}\n \t\tperms = M_fs_info_get_perms(info);\n \t}\n+\n+\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it\n+\t * to new file. */\n \tres = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);\n \tM_fs_info_destroy(info);\n \tif (res != M_FS_ERROR_SUCCESS) {\n@@ -333,7 +331,7 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode\n \t}\n \n \t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n- \t * existing to rename because any check we perform may not be true when rename is called. */\n+\t * existing to rename because any check we perform may not be true when rename is called. */\n \tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n \tif (res != M_FS_ERROR_SUCCESS) {\n \t\tM_free(norm_path_new);\n@@ -351,7 +349,7 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode\n \t\treturn res;\n \t}\n \n- \t/* There is a race condition where the path could not exist but be created between the exists check and calling\n+\t/* There is a race condition where the path could not exist but be created between the exists check and calling\n \t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n \t * situation won't cause an error. */\n \tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n@@ -399,15 +397,15 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode\n \t\t\tres = M_fs_delete(norm_path_old, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t\t} else {\n \t\t\t/* Failure - Delete the new files that were copied but only if we are not overwriting. We don't\n- \t\t\t * want to remove any existing files (especially if the dest is a dir). */\n+\t\t\t * want to remove any existing files (especially if the dest is a dir). */\n \t\t\tif (!(mode & M_FS_FILE_MODE_OVERWRITE)) {\n \t\t\t\tM_fs_delete(norm_path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t\t\t}\n \t\t\tres = M_FS_ERROR_GENERIC;\n \t\t}\n \t} else {\n \t\t/* Call the cb with the result of the move whether it was a success for fail. We call the cb only if the\n- \t\t * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */\n+\t\t * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */\n \t\tif (cb) {\n \t\t\tM_fs_progress_set_result(progress, res);\n \t\t\tif (!cb(progress)) {\n@@ -465,7 +463,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \t}\n \n \t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n- \t * existing to rename because any check we perform may not be true when rename is called. */\n+\t * existing to rename because any check we perform may not be true when rename is called. */\n \tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n \tif (res != M_FS_ERROR_SUCCESS) {\n \t\tM_free(norm_path_new);\n@@ -485,7 +483,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \n \ttype = M_fs_info_get_type(info);\n \n- \t/* There is a race condition where the path could not exist but be created between the exists check and calling\n+\t/* There is a race condition where the path could not exist but be created between the exists check and calling\n \t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n \t * situation won't cause an error. */\n \tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n@@ -497,7 +495,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \n \tentries = M_fs_dir_entries_create();\n \t/* No need to destroy info  because it's now owned by entries and will be destroyed when entries is destroyed.\n- \t * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is\n+\t * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is\n \t * stored in the entry. */\n \tM_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path_new, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));\n \tif (type == M_FS_TYPE_DIR) {\n@@ -523,7 +521,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \n \t\t\ttype = M_fs_dir_entry_get_type(entry);\n \t\t\t/* The total isn't the total number of files but the total number of operations. \n- \t\t\t * Making dirs and symlinks is one operation and copying a file will be split into\n+\t\t\t * Making dirs and symlinks is one operation and copying a file will be split into\n \t\t\t * multiple operations. Copying uses the M_FS_BUF_SIZE to read and write in\n \t\t\t * chunks. We determine how many chunks will be needed to read the entire file and\n \t\t\t * use that for the number of operations for the file. */\n@@ -600,7 +598,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \t}\n \n \t/* Delete the file(s) if it could not be copied properly, but only if we are not overwriting.\n- \t * If we're overwriting then there could be other files in that location (especially if it's a dir). */\n+\t * If we're overwriting then there could be other files in that location (especially if it's a dir). */\n \tif (res != M_FS_ERROR_SUCCESS && !(mode & M_FS_FILE_MODE_OVERWRITE)) {\n \t\tM_fs_delete(path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t}\n@@ -659,7 +657,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress\n \tentries = M_fs_dir_entries_create();\n \n \t/* Recursive directory deletion isn't intuitive. We have to generate a list of files and delete the list.\n- \t * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior\n+\t * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior\n \t * is undefined in Posix and HFS is known to skip files if the directory contents is modifies as the\n \t * directory is being walked. */\n \tif (type == M_FS_TYPE_DIR && remove_children) {\n@@ -671,7 +669,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress\n \t}\n \n \t/* Add the original path to the list of entries. This may be the only entry in the list. We need to add\n- \t * it after a potential walk because we can't delete a directory that isn't empty.\n+\t * it after a potential walk because we can't delete a directory that isn't empty.\n \t * Note: \n \t *   - The info will be owned by the entry and destroyed when it is destroyed. \n \t *   - The basic info param doesn't get the info in this case. it's set so the info is stored in the entry. */\n@@ -680,7 +678,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress\n \tlen = M_fs_dir_entries_len(entries);\n \tif (cb) {\n \t\t/* Create the progress. The same progress will be used for the entire operation. It will be updated with\n- \t\t * new info as necessary. */\n+\t\t * new info as necessary. */\n \t\tprogress = M_fs_progress_create();\n \n \t\t/* Get the total size of all files to be deleted if using the progress cb and size totals is set. */""}<_**next**_>{""sha"": ""952fe45f15c30f70e88bdb4293c37ea72992c9bc"", ""filename"": ""base/fs/m_fs_path.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 3, ""changes"": 22, ""blob_url"": ""https://github.com/Monetra/mstdlib/blob/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs_path.c"", ""raw_url"": ""https://github.com/Monetra/mstdlib/raw/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs_path.c"", ""contents_url"": ""https://api.github.com/repos/Monetra/mstdlib/contents/base/fs/m_fs_path.c?ref=db124b8f607dd0a40a9aef2d4d468fad433522a7"", ""patch"": ""@@ -254,7 +254,7 @@ char *M_fs_path_join_parts(const M_list_str_t *path, M_fs_system_t sys_type)\n \tsys_type = M_fs_path_get_system_type(sys_type);\n \n \t/* Remove any empty parts (except for the first part which denotes an abs path on Unix\n- \t * or a UNC path on Windows). */\n+\t * or a UNC path on Windows). */\n \tparts = M_list_str_duplicate(path);\n \tfor (i=len-1; i>0; i--) {\n \t\tpart = M_list_str_at(parts, i);\n@@ -536,7 +536,7 @@ M_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)\n \t}\n \n \t/* Hidden. Check if the first character of the last part of the path. Either the file or directory name itself\n- \t * starts with a '.'. */\n+\t * starts with a '.'. */\n \tpath_parts = M_fs_path_componentize_path(path, M_FS_SYSTEM_UNIX);\n \tlen = M_list_str_len(path_parts);\n \tif (len > 0) {\n@@ -601,7 +601,23 @@ char *M_fs_path_tmpdir(M_fs_system_t sys_type)\n \td = M_fs_path_mac_tmpdir();\n #else\n \tconst char *const_temp;\n-\t/* Try Unix env var. */\n+\t/* Unix doens't have a fancy function to get the standard\n+\t * temporary directory an application can use. Instead there\n+\t * is a convoluted set of possible paths that could be used.\n+\t *\n+\t * We're going to go though each one in a priority order and\n+\t * verify if we can read and write the directory. If so then\n+\t * that's the one that will be used. We are fine using access\n+\t * here because it doesn't matter if the path ends up being\n+\t * changed out from underneath us later on. When it's used\n+\t * at that time it will fail. Right now we just want to get\n+\t * a path that can be tried. */\n+\n+\t/* Try Unix env vars.\n+\t *\n+\t * This is not ideal but a valid way to set the temporary directory\n+\t * for a user. Per Single Unix Specification 4 and probably other things.\n+\t */\n #  ifdef HAVE_SECURE_GETENV\n \tconst_temp = secure_getenv(\""TMPDIR\"");\n #  else""}","M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress_cb_t cb, M_uint32 progress_flags)
{
	char                   *norm_path;
	char                   *join_path;
	M_fs_dir_entries_t     *entries;
	const M_fs_dir_entry_t *entry;
	M_fs_info_t            *info;
	M_fs_progress_t        *progress            = NULL;
	M_fs_dir_walk_filter_t  filter              = M_FS_DIR_WALK_FILTER_ALL|M_FS_DIR_WALK_FILTER_RECURSE;
	M_fs_type_t             type;
	/* The result that will be returned by this function. */
	M_fs_error_t            res;
	/* The result of the delete itself. */
	M_fs_error_t            res2;
	size_t                  len;
	size_t                  i;
	M_uint64                total_size          = 0;
	M_uint64                total_size_progress = 0;
	M_uint64                entry_size;

	/* Normalize the path we are going to delete so we have a valid path to pass around. */
	res = M_fs_path_norm(&norm_path, path, M_FS_PATH_NORM_HOME, M_FS_SYSTEM_AUTO);
	if (res != M_FS_ERROR_SUCCESS) {
		M_free(norm_path);
		return res;
	}

	/* We need the info to determine if the path is valid and because we need the type. */
	res = M_fs_info(&info, norm_path, M_FS_PATH_INFO_FLAGS_BASIC);
	if (res != M_FS_ERROR_SUCCESS) {
		M_free(norm_path);
		return res;
	}

	/* We must know the type because there are different functions for deleting a file and deleting a directory. */
	type = M_fs_info_get_type(info);
	if (type == M_FS_TYPE_UNKNOWN) {
		M_fs_info_destroy(info);
		M_free(norm_path);
		return M_FS_ERROR_GENERIC;
	}

	/* Create a list of entries to store all the places we need to delete. */
 	entries = M_fs_dir_entries_create();
 
 	/* Recursive directory deletion isn't intuitive. We have to generate a list of files and delete the list.
	 * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior
 	 * is undefined in Posix and HFS is known to skip files if the directory contents is modifies as the
 	 * directory is being walked. */
 	if (type == M_FS_TYPE_DIR && remove_children) {
		/* We need to read the basic info if the we need to report the size totals to the cb. */
		if (cb && progress_flags & (M_FS_PROGRESS_SIZE_TOTAL|M_FS_PROGRESS_SIZE_CUR)) {
			filter |= M_FS_DIR_WALK_FILTER_READ_INFO_BASIC;
		}
		M_fs_dir_entries_merge(&entries, M_fs_dir_walk_entries(norm_path, NULL, filter));
 	}
 
 	/* Add the original path to the list of entries. This may be the only entry in the list. We need to add
	 * it after a potential walk because we can't delete a directory that isn't empty.
 	 * Note: 
 	 *   - The info will be owned by the entry and destroyed when it is destroyed. 
 	 *   - The basic info param doesn't get the info in this case. it's set so the info is stored in the entry. */
	M_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));

 	len = M_fs_dir_entries_len(entries);
 	if (cb) {
 		/* Create the progress. The same progress will be used for the entire operation. It will be updated with
		 * new info as necessary. */
 		progress = M_fs_progress_create();
 
 		/* Get the total size of all files to be deleted if using the progress cb and size totals is set. */
		if (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {
			for (i=0; i<len; i++) {
				entry       = M_fs_dir_entries_at(entries, i);
				entry_size  = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));
				total_size += entry_size;
			}
			/* Change the progress total size to reflect all entries. */
			M_fs_progress_set_size_total(progress, total_size);
		}
		/* Change the progress count to reflect the count. */
		if (progress_flags & M_FS_PROGRESS_COUNT) {
			M_fs_progress_set_count_total(progress, len);
		}
	}

	/* Assume success. Set error if there is an error. */
	res = M_FS_ERROR_SUCCESS;
	/* Loop though all entries and delete. */
	for (i=0; i<len; i++) {
		entry     = M_fs_dir_entries_at(entries, i);
		join_path = M_fs_path_join(norm_path, M_fs_dir_entry_get_name(entry), M_FS_SYSTEM_AUTO);
		/* Call the appropriate delete function. */
		if (M_fs_dir_entry_get_type(entry) == M_FS_TYPE_DIR) {
			res2 = M_fs_delete_dir(join_path);
		} else {
			res2 = M_fs_delete_file(join_path);
		}
		/* Set the return result to denote there was an error. The real error will be sent via the
		 * progress callback for the entry. */
		if (res2 != M_FS_ERROR_SUCCESS) {
			res = M_FS_ERROR_GENERIC;
		}
		/* Set the progress data for the entry. */
		if (cb) {
			entry_size           = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));
			total_size_progress += entry_size;

			M_fs_progress_set_path(progress, join_path);
			M_fs_progress_set_type(progress, M_fs_dir_entry_get_type(entry));
			M_fs_progress_set_result(progress, res2);
			if (progress_flags & M_FS_PROGRESS_COUNT) {
				M_fs_progress_set_count(progress, i+1);
			}
			if (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {
				M_fs_progress_set_size_total_progess(progress, total_size_progress);
			}
			if (progress_flags & M_FS_PROGRESS_SIZE_CUR) {
				M_fs_progress_set_size_current(progress, entry_size);
				M_fs_progress_set_size_current_progress(progress, entry_size);
			}
		}
		M_free(join_path);
		/* Call the callback and stop processing if requested. */
		if (cb && !cb(progress)) {
			res = M_FS_ERROR_CANCELED;
			break;
		}
	}

	M_fs_dir_entries_destroy(entries);
	M_fs_progress_destroy(progress);
	M_free(norm_path);
	return res;
}
","M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress_cb_t cb, M_uint32 progress_flags)
{
	char                   *norm_path;
	char                   *join_path;
	M_fs_dir_entries_t     *entries;
	const M_fs_dir_entry_t *entry;
	M_fs_info_t            *info;
	M_fs_progress_t        *progress            = NULL;
	M_fs_dir_walk_filter_t  filter              = M_FS_DIR_WALK_FILTER_ALL|M_FS_DIR_WALK_FILTER_RECURSE;
	M_fs_type_t             type;
	/* The result that will be returned by this function. */
	M_fs_error_t            res;
	/* The result of the delete itself. */
	M_fs_error_t            res2;
	size_t                  len;
	size_t                  i;
	M_uint64                total_size          = 0;
	M_uint64                total_size_progress = 0;
	M_uint64                entry_size;

	/* Normalize the path we are going to delete so we have a valid path to pass around. */
	res = M_fs_path_norm(&norm_path, path, M_FS_PATH_NORM_HOME, M_FS_SYSTEM_AUTO);
	if (res != M_FS_ERROR_SUCCESS) {
		M_free(norm_path);
		return res;
	}

	/* We need the info to determine if the path is valid and because we need the type. */
	res = M_fs_info(&info, norm_path, M_FS_PATH_INFO_FLAGS_BASIC);
	if (res != M_FS_ERROR_SUCCESS) {
		M_free(norm_path);
		return res;
	}

	/* We must know the type because there are different functions for deleting a file and deleting a directory. */
	type = M_fs_info_get_type(info);
	if (type == M_FS_TYPE_UNKNOWN) {
		M_fs_info_destroy(info);
		M_free(norm_path);
		return M_FS_ERROR_GENERIC;
	}

	/* Create a list of entries to store all the places we need to delete. */
 	entries = M_fs_dir_entries_create();
 
 	/* Recursive directory deletion isn't intuitive. We have to generate a list of files and delete the list.
 	 * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior
 	 * is undefined in Posix and HFS is known to skip files if the directory contents is modifies as the
 	 * directory is being walked. */
 	if (type == M_FS_TYPE_DIR && remove_children) {
		/* We need to read the basic info if the we need to report the size totals to the cb. */
		if (cb && progress_flags & (M_FS_PROGRESS_SIZE_TOTAL|M_FS_PROGRESS_SIZE_CUR)) {
			filter |= M_FS_DIR_WALK_FILTER_READ_INFO_BASIC;
		}
		M_fs_dir_entries_merge(&entries, M_fs_dir_walk_entries(norm_path, NULL, filter));
 	}
 
 	/* Add the original path to the list of entries. This may be the only entry in the list. We need to add
 	 * it after a potential walk because we can't delete a directory that isn't empty.
 	 * Note: 
 	 *   - The info will be owned by the entry and destroyed when it is destroyed. 
 	 *   - The basic info param doesn't get the info in this case. it's set so the info is stored in the entry. */
	M_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));

 	len = M_fs_dir_entries_len(entries);
 	if (cb) {
 		/* Create the progress. The same progress will be used for the entire operation. It will be updated with
 		 * new info as necessary. */
 		progress = M_fs_progress_create();
 
 		/* Get the total size of all files to be deleted if using the progress cb and size totals is set. */
		if (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {
			for (i=0; i<len; i++) {
				entry       = M_fs_dir_entries_at(entries, i);
				entry_size  = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));
				total_size += entry_size;
			}
			/* Change the progress total size to reflect all entries. */
			M_fs_progress_set_size_total(progress, total_size);
		}
		/* Change the progress count to reflect the count. */
		if (progress_flags & M_FS_PROGRESS_COUNT) {
			M_fs_progress_set_count_total(progress, len);
		}
	}

	/* Assume success. Set error if there is an error. */
	res = M_FS_ERROR_SUCCESS;
	/* Loop though all entries and delete. */
	for (i=0; i<len; i++) {
		entry     = M_fs_dir_entries_at(entries, i);
		join_path = M_fs_path_join(norm_path, M_fs_dir_entry_get_name(entry), M_FS_SYSTEM_AUTO);
		/* Call the appropriate delete function. */
		if (M_fs_dir_entry_get_type(entry) == M_FS_TYPE_DIR) {
			res2 = M_fs_delete_dir(join_path);
		} else {
			res2 = M_fs_delete_file(join_path);
		}
		/* Set the return result to denote there was an error. The real error will be sent via the
		 * progress callback for the entry. */
		if (res2 != M_FS_ERROR_SUCCESS) {
			res = M_FS_ERROR_GENERIC;
		}
		/* Set the progress data for the entry. */
		if (cb) {
			entry_size           = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));
			total_size_progress += entry_size;

			M_fs_progress_set_path(progress, join_path);
			M_fs_progress_set_type(progress, M_fs_dir_entry_get_type(entry));
			M_fs_progress_set_result(progress, res2);
			if (progress_flags & M_FS_PROGRESS_COUNT) {
				M_fs_progress_set_count(progress, i+1);
			}
			if (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {
				M_fs_progress_set_size_total_progess(progress, total_size_progress);
			}
			if (progress_flags & M_FS_PROGRESS_SIZE_CUR) {
				M_fs_progress_set_size_current(progress, entry_size);
				M_fs_progress_set_size_current_progress(progress, entry_size);
			}
		}
		M_free(join_path);
		/* Call the callback and stop processing if requested. */
		if (cb && !cb(progress)) {
			res = M_FS_ERROR_CANCELED;
			break;
		}
	}

	M_fs_dir_entries_destroy(entries);
	M_fs_progress_destroy(progress);
	M_free(norm_path);
	return res;
}
",C,"	 * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior
	 * it after a potential walk because we can't delete a directory that isn't empty.
		 * new info as necessary. */
"," 	 * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior
 	 * it after a potential walk because we can't delete a directory that isn't empty.
 		 * new info as necessary. */
",,"@@ -101,6 +101,15 @@ static M_bool M_fs_isfileintodir(const char *p1, const char *p2, char **new_p2)
 	return M_TRUE;
 }
 
+/* Used by copy and move to determine if we can write to the given path
+ * based on a file already existing there or not.
+ *
+ * access is used to determine existence because we don't want to overwrite
+ * if there already is a file. This is not guaranteed because if there is
+ * a race condition where a file is created after this check it will be
+ * overwritten. Not much we can do about that. It shouldn't pose a security
+ * issue since this is more of a request than a requirement.
+ */
 static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uint32 mode)
 {
 	M_fs_info_t  *info = NULL;
@@ -129,8 +138,7 @@ static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uin
 
 	if (type != M_FS_TYPE_DIR) {
 		/* File exists at path. */
-		if (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS)
-		{
+		if (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {
 			ret = M_FALSE;
 			goto done;
 		}
@@ -209,19 +217,6 @@ static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M
 	size_t         offset;
 	M_fs_error_t   res;
 
-	/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it
- 	 * to new file. */
-	if (M_fs_perms_can_access(path_new, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {
-		/* Try to delete the file since we'll be overwrite it. This is so when we create the file we create it without
- 		 * any permissions and to ensure that anything that has the file already open won't be able to read the new
-		 * contents we're writing to the file or be able to change the perms. There is an unavoidable race condition
-		 * between deleting and creating the file where someone could create the file and have access. However,
-		 * depending on the OS they may have access even if the file is created with no perms... */
-		res = M_fs_delete(path_new, M_FALSE, NULL, M_FS_PROGRESS_NOEXTRA);
-		if (res != M_FS_ERROR_SUCCESS) {
-			return res;
-		}
-	}
 	/* Open the old file */
 	res = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);
 	if (res != M_FS_ERROR_SUCCESS) {
@@ -236,6 +231,9 @@ static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M
 		}
 		perms = M_fs_info_get_perms(info);
 	}
+
+	/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it
+	 * to new file. */
 	res = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);
 	M_fs_info_destroy(info);
 	if (res != M_FS_ERROR_SUCCESS) {
@@ -333,7 +331,7 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode
 	}
 
 	/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path
- 	 * existing to rename because any check we perform may not be true when rename is called. */
+	 * existing to rename because any check we perform may not be true when rename is called. */
 	res = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);
 	if (res != M_FS_ERROR_SUCCESS) {
 		M_free(norm_path_new);
@@ -351,7 +349,7 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode
 		return res;
 	}
 
- 	/* There is a race condition where the path could not exist but be created between the exists check and calling
+	/* There is a race condition where the path could not exist but be created between the exists check and calling
 	 * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this
 	 * situation won't cause an error. */
 	if (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {
@@ -399,15 +397,15 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode
 			res = M_fs_delete(norm_path_old, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 		} else {
 			/* Failure - Delete the new files that were copied but only if we are not overwriting. We don't
- 			 * want to remove any existing files (especially if the dest is a dir). */
+			 * want to remove any existing files (especially if the dest is a dir). */
 			if (!(mode & M_FS_FILE_MODE_OVERWRITE)) {
 				M_fs_delete(norm_path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 			}
 			res = M_FS_ERROR_GENERIC;
 		}
 	} else {
 		/* Call the cb with the result of the move whether it was a success for fail. We call the cb only if the
- 		 * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */
+		 * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */
 		if (cb) {
 			M_fs_progress_set_result(progress, res);
 			if (!cb(progress)) {
@@ -465,7 +463,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 	}
 
 	/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path
- 	 * existing to rename because any check we perform may not be true when rename is called. */
+	 * existing to rename because any check we perform may not be true when rename is called. */
 	res = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);
 	if (res != M_FS_ERROR_SUCCESS) {
 		M_free(norm_path_new);
@@ -485,7 +483,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 
 	type = M_fs_info_get_type(info);
 
- 	/* There is a race condition where the path could not exist but be created between the exists check and calling
+	/* There is a race condition where the path could not exist but be created between the exists check and calling
 	 * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this
 	 * situation won't cause an error. */
 	if (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {
@@ -497,7 +495,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 
 	entries = M_fs_dir_entries_create();
 	/* No need to destroy info  because it's now owned by entries and will be destroyed when entries is destroyed.
- 	 * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is
+	 * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is
 	 * stored in the entry. */
 	M_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path_new, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));
 	if (type == M_FS_TYPE_DIR) {
@@ -523,7 +521,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 
 			type = M_fs_dir_entry_get_type(entry);
 			/* The total isn't the total number of files but the total number of operations. 
- 			 * Making dirs and symlinks is one operation and copying a file will be split into
+			 * Making dirs and symlinks is one operation and copying a file will be split into
 			 * multiple operations. Copying uses the M_FS_BUF_SIZE to read and write in
 			 * chunks. We determine how many chunks will be needed to read the entire file and
 			 * use that for the number of operations for the file. */
@@ -600,7 +598,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 	}
 
 	/* Delete the file(s) if it could not be copied properly, but only if we are not overwriting.
- 	 * If we're overwriting then there could be other files in that location (especially if it's a dir). */
+	 * If we're overwriting then there could be other files in that location (especially if it's a dir). */
 	if (res != M_FS_ERROR_SUCCESS && !(mode & M_FS_FILE_MODE_OVERWRITE)) {
 		M_fs_delete(path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 	}
@@ -659,7 +657,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress
 	entries = M_fs_dir_entries_create();
 
 	/* Recursive directory deletion isn't intuitive. We have to generate a list of files and delete the list.
- 	 * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior
+	 * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior
 	 * is undefined in Posix and HFS is known to skip files if the directory contents is modifies as the
 	 * directory is being walked. */
 	if (type == M_FS_TYPE_DIR && remove_children) {
@@ -671,7 +669,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress
 	}
 
 	/* Add the original path to the list of entries. This may be the only entry in the list. We need to add
- 	 * it after a potential walk because we can't delete a directory that isn't empty.
+	 * it after a potential walk because we can't delete a directory that isn't empty.
 	 * Note: 
 	 *   - The info will be owned by the entry and destroyed when it is destroyed. 
 	 *   - The basic info param doesn't get the info in this case. it's set so the info is stored in the entry. */
@@ -680,7 +678,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress
 	len = M_fs_dir_entries_len(entries);
 	if (cb) {
 		/* Create the progress. The same progress will be used for the entire operation. It will be updated with
- 		 * new info as necessary. */
+		 * new info as necessary. */
 		progress = M_fs_progress_create();
 
 		/* Get the total size of all files to be deleted if using the progress cb and size totals is set. */",mstdlib,db124b8f607dd0a40a9aef2d4d468fad433522a7,f82091aa7497f952e3183019ae73611c26ccb0b1,1,"M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress_cb_t cb, M_uint32 progress_flags)
{
	char                   *norm_path;
	char                   *join_path;
	M_fs_dir_entries_t     *entries;
	const M_fs_dir_entry_t *entry;
	M_fs_info_t            *info;
	M_fs_progress_t        *progress            = NULL;
	M_fs_dir_walk_filter_t  filter              = M_FS_DIR_WALK_FILTER_ALL|M_FS_DIR_WALK_FILTER_RECURSE;
	M_fs_type_t             type;
	/* The result that will be returned by this function. */
	M_fs_error_t            res;
	/* The result of the delete itself. */
	M_fs_error_t            res2;
	size_t                  len;
	size_t                  i;
	M_uint64                total_size          = 0;
	M_uint64                total_size_progress = 0;
	M_uint64                entry_size;

	/* Normalize the path we are going to delete so we have a valid path to pass around. */
	res = M_fs_path_norm(&norm_path, path, M_FS_PATH_NORM_HOME, M_FS_SYSTEM_AUTO);
	if (res != M_FS_ERROR_SUCCESS) {
		M_free(norm_path);
		return res;
	}

	/* We need the info to determine if the path is valid and because we need the type. */
	res = M_fs_info(&info, norm_path, M_FS_PATH_INFO_FLAGS_BASIC);
	if (res != M_FS_ERROR_SUCCESS) {
		M_free(norm_path);
		return res;
	}

	/* We must know the type because there are different functions for deleting a file and deleting a directory. */
	type = M_fs_info_get_type(info);
	if (type == M_FS_TYPE_UNKNOWN) {
		M_fs_info_destroy(info);
		M_free(norm_path);
		return M_FS_ERROR_GENERIC;
	}

	/* Create a list of entries to store all the places we need to delete. */
 	entries = M_fs_dir_entries_create();
 
 	/* Recursive directory deletion isn't intuitive. We have to generate a list of files and delete the list.
//flaw_line_below:
 	 * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior
//fix_flaw_line_below:
//	 * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior
 	 * is undefined in Posix and HFS is known to skip files if the directory contents is modifies as the
 	 * directory is being walked. */
 	if (type == M_FS_TYPE_DIR && remove_children) {
		/* We need to read the basic info if the we need to report the size totals to the cb. */
		if (cb && progress_flags & (M_FS_PROGRESS_SIZE_TOTAL|M_FS_PROGRESS_SIZE_CUR)) {
			filter |= M_FS_DIR_WALK_FILTER_READ_INFO_BASIC;
		}
		M_fs_dir_entries_merge(&entries, M_fs_dir_walk_entries(norm_path, NULL, filter));
 	}
 
 	/* Add the original path to the list of entries. This may be the only entry in the list. We need to add
//flaw_line_below:
 	 * it after a potential walk because we can't delete a directory that isn't empty.
//fix_flaw_line_below:
//	 * it after a potential walk because we can't delete a directory that isn't empty.
 	 * Note: 
 	 *   - The info will be owned by the entry and destroyed when it is destroyed. 
 	 *   - The basic info param doesn't get the info in this case. it's set so the info is stored in the entry. */
	M_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));

 	len = M_fs_dir_entries_len(entries);
 	if (cb) {
 		/* Create the progress. The same progress will be used for the entire operation. It will be updated with
//flaw_line_below:
 		 * new info as necessary. */
//fix_flaw_line_below:
//		 * new info as necessary. */
 		progress = M_fs_progress_create();
 
 		/* Get the total size of all files to be deleted if using the progress cb and size totals is set. */
		if (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {
			for (i=0; i<len; i++) {
				entry       = M_fs_dir_entries_at(entries, i);
				entry_size  = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));
				total_size += entry_size;
			}
			/* Change the progress total size to reflect all entries. */
			M_fs_progress_set_size_total(progress, total_size);
		}
		/* Change the progress count to reflect the count. */
		if (progress_flags & M_FS_PROGRESS_COUNT) {
			M_fs_progress_set_count_total(progress, len);
		}
	}

	/* Assume success. Set error if there is an error. */
	res = M_FS_ERROR_SUCCESS;
	/* Loop though all entries and delete. */
	for (i=0; i<len; i++) {
		entry     = M_fs_dir_entries_at(entries, i);
		join_path = M_fs_path_join(norm_path, M_fs_dir_entry_get_name(entry), M_FS_SYSTEM_AUTO);
		/* Call the appropriate delete function. */
		if (M_fs_dir_entry_get_type(entry) == M_FS_TYPE_DIR) {
			res2 = M_fs_delete_dir(join_path);
		} else {
			res2 = M_fs_delete_file(join_path);
		}
		/* Set the return result to denote there was an error. The real error will be sent via the
		 * progress callback for the entry. */
		if (res2 != M_FS_ERROR_SUCCESS) {
			res = M_FS_ERROR_GENERIC;
		}
		/* Set the progress data for the entry. */
		if (cb) {
			entry_size           = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));
			total_size_progress += entry_size;

			M_fs_progress_set_path(progress, join_path);
			M_fs_progress_set_type(progress, M_fs_dir_entry_get_type(entry));
			M_fs_progress_set_result(progress, res2);
			if (progress_flags & M_FS_PROGRESS_COUNT) {
				M_fs_progress_set_count(progress, i+1);
			}
			if (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {
				M_fs_progress_set_size_total_progess(progress, total_size_progress);
			}
			if (progress_flags & M_FS_PROGRESS_SIZE_CUR) {
				M_fs_progress_set_size_current(progress, entry_size);
				M_fs_progress_set_size_current_progress(progress, entry_size);
			}
		}
		M_free(join_path);
		/* Call the callback and stop processing if requested. */
		if (cb && !cb(progress)) {
			res = M_FS_ERROR_CANCELED;
			break;
		}
	}

	M_fs_dir_entries_destroy(entries);
	M_fs_progress_destroy(progress);
	M_free(norm_path);
	return res;
}
"
4580,182316,,Remote,Not required,Partial,CVE-2018-14043,https://www.cvedetails.com/cve/CVE-2018-14043/,CWE-732,Low,Partial,Partial,,2018-07-13,7.5,"mstdlib (aka the M Standard Library for C) 1.2.0 has incorrect file access control in situations where M_fs_perms_can_access attempts to delete an existing file (that lacks public read/write access) during a copy operation, related to fs/m_fs.c and fs/m_fs_path.c. An attacker could create the file and then would have access to the data.",2019-10-02,,4,https://github.com/Monetra/mstdlib/commit/db124b8f607dd0a40a9aef2d4d468fad433522a7,db124b8f607dd0a40a9aef2d4d468fad433522a7,fs: Don't try to delete the file when copying. It could cause a security issue if the file exists and doesn't allow other's to read/write. delete could allow someone to create the file and have access to the data.,4,base/fs/m_fs.c,"{""sha"": ""57f2a313bd3b217f64fd91d2d4a81272ac148734"", ""filename"": ""base/fs/m_fs.c"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 27, ""changes"": 52, ""blob_url"": ""https://github.com/Monetra/mstdlib/blob/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs.c"", ""raw_url"": ""https://github.com/Monetra/mstdlib/raw/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs.c"", ""contents_url"": ""https://api.github.com/repos/Monetra/mstdlib/contents/base/fs/m_fs.c?ref=db124b8f607dd0a40a9aef2d4d468fad433522a7"", ""patch"": ""@@ -101,6 +101,15 @@ static M_bool M_fs_isfileintodir(const char *p1, const char *p2, char **new_p2)\n \treturn M_TRUE;\n }\n \n+/* Used by copy and move to determine if we can write to the given path\n+ * based on a file already existing there or not.\n+ *\n+ * access is used to determine existence because we don't want to overwrite\n+ * if there already is a file. This is not guaranteed because if there is\n+ * a race condition where a file is created after this check it will be\n+ * overwritten. Not much we can do about that. It shouldn't pose a security\n+ * issue since this is more of a request than a requirement.\n+ */\n static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uint32 mode)\n {\n \tM_fs_info_t  *info = NULL;\n@@ -129,8 +138,7 @@ static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uin\n \n \tif (type != M_FS_TYPE_DIR) {\n \t\t/* File exists at path. */\n-\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS)\n-\t\t{\n+\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n \t\t\tret = M_FALSE;\n \t\t\tgoto done;\n \t\t}\n@@ -209,19 +217,6 @@ static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M\n \tsize_t         offset;\n \tM_fs_error_t   res;\n \n-\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it\n- \t * to new file. */\n-\tif (M_fs_perms_can_access(path_new, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n-\t\t/* Try to delete the file since we'll be overwrite it. This is so when we create the file we create it without\n- \t\t * any permissions and to ensure that anything that has the file already open won't be able to read the new\n-\t\t * contents we're writing to the file or be able to change the perms. There is an unavoidable race condition\n-\t\t * between deleting and creating the file where someone could create the file and have access. However,\n-\t\t * depending on the OS they may have access even if the file is created with no perms... */\n-\t\tres = M_fs_delete(path_new, M_FALSE, NULL, M_FS_PROGRESS_NOEXTRA);\n-\t\tif (res != M_FS_ERROR_SUCCESS) {\n-\t\t\treturn res;\n-\t\t}\n-\t}\n \t/* Open the old file */\n \tres = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);\n \tif (res != M_FS_ERROR_SUCCESS) {\n@@ -236,6 +231,9 @@ static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M\n \t\t}\n \t\tperms = M_fs_info_get_perms(info);\n \t}\n+\n+\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it\n+\t * to new file. */\n \tres = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);\n \tM_fs_info_destroy(info);\n \tif (res != M_FS_ERROR_SUCCESS) {\n@@ -333,7 +331,7 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode\n \t}\n \n \t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n- \t * existing to rename because any check we perform may not be true when rename is called. */\n+\t * existing to rename because any check we perform may not be true when rename is called. */\n \tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n \tif (res != M_FS_ERROR_SUCCESS) {\n \t\tM_free(norm_path_new);\n@@ -351,7 +349,7 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode\n \t\treturn res;\n \t}\n \n- \t/* There is a race condition where the path could not exist but be created between the exists check and calling\n+\t/* There is a race condition where the path could not exist but be created between the exists check and calling\n \t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n \t * situation won't cause an error. */\n \tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n@@ -399,15 +397,15 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode\n \t\t\tres = M_fs_delete(norm_path_old, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t\t} else {\n \t\t\t/* Failure - Delete the new files that were copied but only if we are not overwriting. We don't\n- \t\t\t * want to remove any existing files (especially if the dest is a dir). */\n+\t\t\t * want to remove any existing files (especially if the dest is a dir). */\n \t\t\tif (!(mode & M_FS_FILE_MODE_OVERWRITE)) {\n \t\t\t\tM_fs_delete(norm_path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t\t\t}\n \t\t\tres = M_FS_ERROR_GENERIC;\n \t\t}\n \t} else {\n \t\t/* Call the cb with the result of the move whether it was a success for fail. We call the cb only if the\n- \t\t * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */\n+\t\t * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */\n \t\tif (cb) {\n \t\t\tM_fs_progress_set_result(progress, res);\n \t\t\tif (!cb(progress)) {\n@@ -465,7 +463,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \t}\n \n \t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n- \t * existing to rename because any check we perform may not be true when rename is called. */\n+\t * existing to rename because any check we perform may not be true when rename is called. */\n \tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n \tif (res != M_FS_ERROR_SUCCESS) {\n \t\tM_free(norm_path_new);\n@@ -485,7 +483,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \n \ttype = M_fs_info_get_type(info);\n \n- \t/* There is a race condition where the path could not exist but be created between the exists check and calling\n+\t/* There is a race condition where the path could not exist but be created between the exists check and calling\n \t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n \t * situation won't cause an error. */\n \tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n@@ -497,7 +495,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \n \tentries = M_fs_dir_entries_create();\n \t/* No need to destroy info  because it's now owned by entries and will be destroyed when entries is destroyed.\n- \t * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is\n+\t * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is\n \t * stored in the entry. */\n \tM_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path_new, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));\n \tif (type == M_FS_TYPE_DIR) {\n@@ -523,7 +521,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \n \t\t\ttype = M_fs_dir_entry_get_type(entry);\n \t\t\t/* The total isn't the total number of files but the total number of operations. \n- \t\t\t * Making dirs and symlinks is one operation and copying a file will be split into\n+\t\t\t * Making dirs and symlinks is one operation and copying a file will be split into\n \t\t\t * multiple operations. Copying uses the M_FS_BUF_SIZE to read and write in\n \t\t\t * chunks. We determine how many chunks will be needed to read the entire file and\n \t\t\t * use that for the number of operations for the file. */\n@@ -600,7 +598,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \t}\n \n \t/* Delete the file(s) if it could not be copied properly, but only if we are not overwriting.\n- \t * If we're overwriting then there could be other files in that location (especially if it's a dir). */\n+\t * If we're overwriting then there could be other files in that location (especially if it's a dir). */\n \tif (res != M_FS_ERROR_SUCCESS && !(mode & M_FS_FILE_MODE_OVERWRITE)) {\n \t\tM_fs_delete(path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t}\n@@ -659,7 +657,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress\n \tentries = M_fs_dir_entries_create();\n \n \t/* Recursive directory deletion isn't intuitive. We have to generate a list of files and delete the list.\n- \t * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior\n+\t * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior\n \t * is undefined in Posix and HFS is known to skip files if the directory contents is modifies as the\n \t * directory is being walked. */\n \tif (type == M_FS_TYPE_DIR && remove_children) {\n@@ -671,7 +669,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress\n \t}\n \n \t/* Add the original path to the list of entries. This may be the only entry in the list. We need to add\n- \t * it after a potential walk because we can't delete a directory that isn't empty.\n+\t * it after a potential walk because we can't delete a directory that isn't empty.\n \t * Note: \n \t *   - The info will be owned by the entry and destroyed when it is destroyed. \n \t *   - The basic info param doesn't get the info in this case. it's set so the info is stored in the entry. */\n@@ -680,7 +678,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress\n \tlen = M_fs_dir_entries_len(entries);\n \tif (cb) {\n \t\t/* Create the progress. The same progress will be used for the entire operation. It will be updated with\n- \t\t * new info as necessary. */\n+\t\t * new info as necessary. */\n \t\tprogress = M_fs_progress_create();\n \n \t\t/* Get the total size of all files to be deleted if using the progress cb and size totals is set. */""}<_**next**_>{""sha"": ""952fe45f15c30f70e88bdb4293c37ea72992c9bc"", ""filename"": ""base/fs/m_fs_path.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 3, ""changes"": 22, ""blob_url"": ""https://github.com/Monetra/mstdlib/blob/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs_path.c"", ""raw_url"": ""https://github.com/Monetra/mstdlib/raw/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs_path.c"", ""contents_url"": ""https://api.github.com/repos/Monetra/mstdlib/contents/base/fs/m_fs_path.c?ref=db124b8f607dd0a40a9aef2d4d468fad433522a7"", ""patch"": ""@@ -254,7 +254,7 @@ char *M_fs_path_join_parts(const M_list_str_t *path, M_fs_system_t sys_type)\n \tsys_type = M_fs_path_get_system_type(sys_type);\n \n \t/* Remove any empty parts (except for the first part which denotes an abs path on Unix\n- \t * or a UNC path on Windows). */\n+\t * or a UNC path on Windows). */\n \tparts = M_list_str_duplicate(path);\n \tfor (i=len-1; i>0; i--) {\n \t\tpart = M_list_str_at(parts, i);\n@@ -536,7 +536,7 @@ M_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)\n \t}\n \n \t/* Hidden. Check if the first character of the last part of the path. Either the file or directory name itself\n- \t * starts with a '.'. */\n+\t * starts with a '.'. */\n \tpath_parts = M_fs_path_componentize_path(path, M_FS_SYSTEM_UNIX);\n \tlen = M_list_str_len(path_parts);\n \tif (len > 0) {\n@@ -601,7 +601,23 @@ char *M_fs_path_tmpdir(M_fs_system_t sys_type)\n \td = M_fs_path_mac_tmpdir();\n #else\n \tconst char *const_temp;\n-\t/* Try Unix env var. */\n+\t/* Unix doens't have a fancy function to get the standard\n+\t * temporary directory an application can use. Instead there\n+\t * is a convoluted set of possible paths that could be used.\n+\t *\n+\t * We're going to go though each one in a priority order and\n+\t * verify if we can read and write the directory. If so then\n+\t * that's the one that will be used. We are fine using access\n+\t * here because it doesn't matter if the path ends up being\n+\t * changed out from underneath us later on. When it's used\n+\t * at that time it will fail. Right now we just want to get\n+\t * a path that can be tried. */\n+\n+\t/* Try Unix env vars.\n+\t *\n+\t * This is not ideal but a valid way to set the temporary directory\n+\t * for a user. Per Single Unix Specification 4 and probably other things.\n+\t */\n #  ifdef HAVE_SECURE_GETENV\n \tconst_temp = secure_getenv(\""TMPDIR\"");\n #  else""}","M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode, M_fs_progress_cb_t cb, M_uint32 progress_flags)
{
	char            *norm_path_old;
	char            *norm_path_new;
	char            *resolve_path;
	M_fs_info_t     *info;
	M_fs_progress_t *progress      = NULL;
	M_uint64         entry_size;
	M_fs_error_t     res;

	if (path_old == NULL || *path_old == '\0' || path_new == NULL || *path_new == '\0') {
		return M_FS_ERROR_INVALID;
	}

	/* It's okay if new path doesn't exist. */
	res = M_fs_path_norm(&norm_path_new, path_new, M_FS_PATH_NORM_RESDIR, M_FS_SYSTEM_AUTO);
	if (res != M_FS_ERROR_SUCCESS) {
		M_free(norm_path_new);
		return res;
	}

	/* If a path is a file and the destination is a directory the file should be moved 
	 * into the directory. E.g. /file.txt -> /dir = /dir/file.txt */
	if (M_fs_isfileintodir(path_old, path_new, &norm_path_old)) {
		M_free(norm_path_new);
		res = M_fs_move(path_old, norm_path_old, mode, cb, progress_flags);
		M_free(norm_path_old);
		return res;
 	}
 
 	/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path
	 * existing to rename because any check we perform may not be true when rename is called. */
 	res = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);
 	if (res != M_FS_ERROR_SUCCESS) {
 		M_free(norm_path_new);
		M_free(norm_path_old);
		return res;
	}

	progress = M_fs_progress_create();

	res = M_fs_info(&info, path_old, (mode & M_FS_FILE_MODE_PRESERVE_PERMS)?M_FS_PATH_INFO_FLAGS_NONE:M_FS_PATH_INFO_FLAGS_BASIC);
	if (res != M_FS_ERROR_SUCCESS) {
		M_fs_progress_destroy(progress);
		M_free(norm_path_new);
		M_free(norm_path_old);
 		return res;
 	}
 
	/* There is a race condition where the path could not exist but be created between the exists check and calling
 	 * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this
 	 * situation won't cause an error. */
 	if (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {
		M_fs_progress_destroy(progress);
		M_free(norm_path_new);
		M_free(norm_path_old);
		return M_FS_ERROR_FILE_EXISTS;
	}

	if (cb) {
		entry_size = M_fs_info_get_size(info);

		M_fs_progress_set_path(progress, norm_path_new);
		M_fs_progress_set_type(progress, M_fs_info_get_type(info));
		if (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {
			M_fs_progress_set_size_total(progress, entry_size);
			M_fs_progress_set_size_total_progess(progress, entry_size);
		}
		if (progress_flags & M_FS_PROGRESS_SIZE_CUR) {
			M_fs_progress_set_size_current(progress, entry_size);
			M_fs_progress_set_size_current_progress(progress, entry_size);
		}
		/* Change the progress count to reflect the count. */
		if (progress_flags & M_FS_PROGRESS_COUNT) {
			M_fs_progress_set_count_total(progress, 1);
			M_fs_progress_set_count(progress, 1);
		}
	}

	/* Move the file. */
	if (M_fs_info_get_type(info) == M_FS_TYPE_SYMLINK) {
		res = M_fs_path_readlink(&resolve_path, norm_path_old);
		if (res == M_FS_ERROR_SUCCESS) {
			res = M_fs_symlink(norm_path_new, resolve_path);
		}
		M_free(resolve_path);
	} else {
		res = M_fs_move_file(norm_path_old, norm_path_new);
	}
	/* Failure was because we're crossing mount points. */
	if (res == M_FS_ERROR_NOT_SAMEDEV) {
		/* Can't rename so copy and delete. */
		if (M_fs_copy(norm_path_old, norm_path_new, mode, cb, progress_flags) == M_FS_ERROR_SUCCESS) {
			/* Success - Delete the original files since this is a move. */
 			res = M_fs_delete(norm_path_old, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 		} else {
 			/* Failure - Delete the new files that were copied but only if we are not overwriting. We don't
			 * want to remove any existing files (especially if the dest is a dir). */
 			if (!(mode & M_FS_FILE_MODE_OVERWRITE)) {
 				M_fs_delete(norm_path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 			}
 			res = M_FS_ERROR_GENERIC;
 		}
 	} else {
 		/* Call the cb with the result of the move whether it was a success for fail. We call the cb only if the
		 * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */
 		if (cb) {
 			M_fs_progress_set_result(progress, res);
 			if (!cb(progress)) {
				res = M_FS_ERROR_CANCELED;
			}
		}
	}

	M_fs_info_destroy(info);
	M_fs_progress_destroy(progress);
	M_free(norm_path_new);
	M_free(norm_path_old);

	return res;
}
","M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode, M_fs_progress_cb_t cb, M_uint32 progress_flags)
{
	char            *norm_path_old;
	char            *norm_path_new;
	char            *resolve_path;
	M_fs_info_t     *info;
	M_fs_progress_t *progress      = NULL;
	M_uint64         entry_size;
	M_fs_error_t     res;

	if (path_old == NULL || *path_old == '\0' || path_new == NULL || *path_new == '\0') {
		return M_FS_ERROR_INVALID;
	}

	/* It's okay if new path doesn't exist. */
	res = M_fs_path_norm(&norm_path_new, path_new, M_FS_PATH_NORM_RESDIR, M_FS_SYSTEM_AUTO);
	if (res != M_FS_ERROR_SUCCESS) {
		M_free(norm_path_new);
		return res;
	}

	/* If a path is a file and the destination is a directory the file should be moved 
	 * into the directory. E.g. /file.txt -> /dir = /dir/file.txt */
	if (M_fs_isfileintodir(path_old, path_new, &norm_path_old)) {
		M_free(norm_path_new);
		res = M_fs_move(path_old, norm_path_old, mode, cb, progress_flags);
		M_free(norm_path_old);
		return res;
 	}
 
 	/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path
 	 * existing to rename because any check we perform may not be true when rename is called. */
 	res = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);
 	if (res != M_FS_ERROR_SUCCESS) {
 		M_free(norm_path_new);
		M_free(norm_path_old);
		return res;
	}

	progress = M_fs_progress_create();

	res = M_fs_info(&info, path_old, (mode & M_FS_FILE_MODE_PRESERVE_PERMS)?M_FS_PATH_INFO_FLAGS_NONE:M_FS_PATH_INFO_FLAGS_BASIC);
	if (res != M_FS_ERROR_SUCCESS) {
		M_fs_progress_destroy(progress);
		M_free(norm_path_new);
		M_free(norm_path_old);
 		return res;
 	}
 
 	/* There is a race condition where the path could not exist but be created between the exists check and calling
 	 * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this
 	 * situation won't cause an error. */
 	if (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {
		M_fs_progress_destroy(progress);
		M_free(norm_path_new);
		M_free(norm_path_old);
		return M_FS_ERROR_FILE_EXISTS;
	}

	if (cb) {
		entry_size = M_fs_info_get_size(info);

		M_fs_progress_set_path(progress, norm_path_new);
		M_fs_progress_set_type(progress, M_fs_info_get_type(info));
		if (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {
			M_fs_progress_set_size_total(progress, entry_size);
			M_fs_progress_set_size_total_progess(progress, entry_size);
		}
		if (progress_flags & M_FS_PROGRESS_SIZE_CUR) {
			M_fs_progress_set_size_current(progress, entry_size);
			M_fs_progress_set_size_current_progress(progress, entry_size);
		}
		/* Change the progress count to reflect the count. */
		if (progress_flags & M_FS_PROGRESS_COUNT) {
			M_fs_progress_set_count_total(progress, 1);
			M_fs_progress_set_count(progress, 1);
		}
	}

	/* Move the file. */
	if (M_fs_info_get_type(info) == M_FS_TYPE_SYMLINK) {
		res = M_fs_path_readlink(&resolve_path, norm_path_old);
		if (res == M_FS_ERROR_SUCCESS) {
			res = M_fs_symlink(norm_path_new, resolve_path);
		}
		M_free(resolve_path);
	} else {
		res = M_fs_move_file(norm_path_old, norm_path_new);
	}
	/* Failure was because we're crossing mount points. */
	if (res == M_FS_ERROR_NOT_SAMEDEV) {
		/* Can't rename so copy and delete. */
		if (M_fs_copy(norm_path_old, norm_path_new, mode, cb, progress_flags) == M_FS_ERROR_SUCCESS) {
			/* Success - Delete the original files since this is a move. */
 			res = M_fs_delete(norm_path_old, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 		} else {
 			/* Failure - Delete the new files that were copied but only if we are not overwriting. We don't
 			 * want to remove any existing files (especially if the dest is a dir). */
 			if (!(mode & M_FS_FILE_MODE_OVERWRITE)) {
 				M_fs_delete(norm_path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 			}
 			res = M_FS_ERROR_GENERIC;
 		}
 	} else {
 		/* Call the cb with the result of the move whether it was a success for fail. We call the cb only if the
 		 * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */
 		if (cb) {
 			M_fs_progress_set_result(progress, res);
 			if (!cb(progress)) {
				res = M_FS_ERROR_CANCELED;
			}
		}
	}

	M_fs_info_destroy(info);
	M_fs_progress_destroy(progress);
	M_free(norm_path_new);
	M_free(norm_path_old);

	return res;
}
",C,"	 * existing to rename because any check we perform may not be true when rename is called. */
	/* There is a race condition where the path could not exist but be created between the exists check and calling
			 * want to remove any existing files (especially if the dest is a dir). */
		 * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */
"," 	 * existing to rename because any check we perform may not be true when rename is called. */
 	/* There is a race condition where the path could not exist but be created between the exists check and calling
 			 * want to remove any existing files (especially if the dest is a dir). */
 		 * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */
",,"@@ -101,6 +101,15 @@ static M_bool M_fs_isfileintodir(const char *p1, const char *p2, char **new_p2)
 	return M_TRUE;
 }
 
+/* Used by copy and move to determine if we can write to the given path
+ * based on a file already existing there or not.
+ *
+ * access is used to determine existence because we don't want to overwrite
+ * if there already is a file. This is not guaranteed because if there is
+ * a race condition where a file is created after this check it will be
+ * overwritten. Not much we can do about that. It shouldn't pose a security
+ * issue since this is more of a request than a requirement.
+ */
 static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uint32 mode)
 {
 	M_fs_info_t  *info = NULL;
@@ -129,8 +138,7 @@ static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uin
 
 	if (type != M_FS_TYPE_DIR) {
 		/* File exists at path. */
-		if (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS)
-		{
+		if (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {
 			ret = M_FALSE;
 			goto done;
 		}
@@ -209,19 +217,6 @@ static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M
 	size_t         offset;
 	M_fs_error_t   res;
 
-	/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it
- 	 * to new file. */
-	if (M_fs_perms_can_access(path_new, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {
-		/* Try to delete the file since we'll be overwrite it. This is so when we create the file we create it without
- 		 * any permissions and to ensure that anything that has the file already open won't be able to read the new
-		 * contents we're writing to the file or be able to change the perms. There is an unavoidable race condition
-		 * between deleting and creating the file where someone could create the file and have access. However,
-		 * depending on the OS they may have access even if the file is created with no perms... */
-		res = M_fs_delete(path_new, M_FALSE, NULL, M_FS_PROGRESS_NOEXTRA);
-		if (res != M_FS_ERROR_SUCCESS) {
-			return res;
-		}
-	}
 	/* Open the old file */
 	res = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);
 	if (res != M_FS_ERROR_SUCCESS) {
@@ -236,6 +231,9 @@ static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M
 		}
 		perms = M_fs_info_get_perms(info);
 	}
+
+	/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it
+	 * to new file. */
 	res = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);
 	M_fs_info_destroy(info);
 	if (res != M_FS_ERROR_SUCCESS) {
@@ -333,7 +331,7 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode
 	}
 
 	/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path
- 	 * existing to rename because any check we perform may not be true when rename is called. */
+	 * existing to rename because any check we perform may not be true when rename is called. */
 	res = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);
 	if (res != M_FS_ERROR_SUCCESS) {
 		M_free(norm_path_new);
@@ -351,7 +349,7 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode
 		return res;
 	}
 
- 	/* There is a race condition where the path could not exist but be created between the exists check and calling
+	/* There is a race condition where the path could not exist but be created between the exists check and calling
 	 * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this
 	 * situation won't cause an error. */
 	if (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {
@@ -399,15 +397,15 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode
 			res = M_fs_delete(norm_path_old, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 		} else {
 			/* Failure - Delete the new files that were copied but only if we are not overwriting. We don't
- 			 * want to remove any existing files (especially if the dest is a dir). */
+			 * want to remove any existing files (especially if the dest is a dir). */
 			if (!(mode & M_FS_FILE_MODE_OVERWRITE)) {
 				M_fs_delete(norm_path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 			}
 			res = M_FS_ERROR_GENERIC;
 		}
 	} else {
 		/* Call the cb with the result of the move whether it was a success for fail. We call the cb only if the
- 		 * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */
+		 * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */
 		if (cb) {
 			M_fs_progress_set_result(progress, res);
 			if (!cb(progress)) {
@@ -465,7 +463,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 	}
 
 	/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path
- 	 * existing to rename because any check we perform may not be true when rename is called. */
+	 * existing to rename because any check we perform may not be true when rename is called. */
 	res = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);
 	if (res != M_FS_ERROR_SUCCESS) {
 		M_free(norm_path_new);
@@ -485,7 +483,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 
 	type = M_fs_info_get_type(info);
 
- 	/* There is a race condition where the path could not exist but be created between the exists check and calling
+	/* There is a race condition where the path could not exist but be created between the exists check and calling
 	 * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this
 	 * situation won't cause an error. */
 	if (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {
@@ -497,7 +495,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 
 	entries = M_fs_dir_entries_create();
 	/* No need to destroy info  because it's now owned by entries and will be destroyed when entries is destroyed.
- 	 * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is
+	 * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is
 	 * stored in the entry. */
 	M_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path_new, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));
 	if (type == M_FS_TYPE_DIR) {
@@ -523,7 +521,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 
 			type = M_fs_dir_entry_get_type(entry);
 			/* The total isn't the total number of files but the total number of operations. 
- 			 * Making dirs and symlinks is one operation and copying a file will be split into
+			 * Making dirs and symlinks is one operation and copying a file will be split into
 			 * multiple operations. Copying uses the M_FS_BUF_SIZE to read and write in
 			 * chunks. We determine how many chunks will be needed to read the entire file and
 			 * use that for the number of operations for the file. */
@@ -600,7 +598,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 	}
 
 	/* Delete the file(s) if it could not be copied properly, but only if we are not overwriting.
- 	 * If we're overwriting then there could be other files in that location (especially if it's a dir). */
+	 * If we're overwriting then there could be other files in that location (especially if it's a dir). */
 	if (res != M_FS_ERROR_SUCCESS && !(mode & M_FS_FILE_MODE_OVERWRITE)) {
 		M_fs_delete(path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 	}
@@ -659,7 +657,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress
 	entries = M_fs_dir_entries_create();
 
 	/* Recursive directory deletion isn't intuitive. We have to generate a list of files and delete the list.
- 	 * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior
+	 * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior
 	 * is undefined in Posix and HFS is known to skip files if the directory contents is modifies as the
 	 * directory is being walked. */
 	if (type == M_FS_TYPE_DIR && remove_children) {
@@ -671,7 +669,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress
 	}
 
 	/* Add the original path to the list of entries. This may be the only entry in the list. We need to add
- 	 * it after a potential walk because we can't delete a directory that isn't empty.
+	 * it after a potential walk because we can't delete a directory that isn't empty.
 	 * Note: 
 	 *   - The info will be owned by the entry and destroyed when it is destroyed. 
 	 *   - The basic info param doesn't get the info in this case. it's set so the info is stored in the entry. */
@@ -680,7 +678,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress
 	len = M_fs_dir_entries_len(entries);
 	if (cb) {
 		/* Create the progress. The same progress will be used for the entire operation. It will be updated with
- 		 * new info as necessary. */
+		 * new info as necessary. */
 		progress = M_fs_progress_create();
 
 		/* Get the total size of all files to be deleted if using the progress cb and size totals is set. */",mstdlib,db124b8f607dd0a40a9aef2d4d468fad433522a7,f82091aa7497f952e3183019ae73611c26ccb0b1,1,"M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode, M_fs_progress_cb_t cb, M_uint32 progress_flags)
{
	char            *norm_path_old;
	char            *norm_path_new;
	char            *resolve_path;
	M_fs_info_t     *info;
	M_fs_progress_t *progress      = NULL;
	M_uint64         entry_size;
	M_fs_error_t     res;

	if (path_old == NULL || *path_old == '\0' || path_new == NULL || *path_new == '\0') {
		return M_FS_ERROR_INVALID;
	}

	/* It's okay if new path doesn't exist. */
	res = M_fs_path_norm(&norm_path_new, path_new, M_FS_PATH_NORM_RESDIR, M_FS_SYSTEM_AUTO);
	if (res != M_FS_ERROR_SUCCESS) {
		M_free(norm_path_new);
		return res;
	}

	/* If a path is a file and the destination is a directory the file should be moved 
	 * into the directory. E.g. /file.txt -> /dir = /dir/file.txt */
	if (M_fs_isfileintodir(path_old, path_new, &norm_path_old)) {
		M_free(norm_path_new);
		res = M_fs_move(path_old, norm_path_old, mode, cb, progress_flags);
		M_free(norm_path_old);
		return res;
 	}
 
 	/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path
//flaw_line_below:
 	 * existing to rename because any check we perform may not be true when rename is called. */
//fix_flaw_line_below:
//	 * existing to rename because any check we perform may not be true when rename is called. */
 	res = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);
 	if (res != M_FS_ERROR_SUCCESS) {
 		M_free(norm_path_new);
		M_free(norm_path_old);
		return res;
	}

	progress = M_fs_progress_create();

	res = M_fs_info(&info, path_old, (mode & M_FS_FILE_MODE_PRESERVE_PERMS)?M_FS_PATH_INFO_FLAGS_NONE:M_FS_PATH_INFO_FLAGS_BASIC);
	if (res != M_FS_ERROR_SUCCESS) {
		M_fs_progress_destroy(progress);
		M_free(norm_path_new);
		M_free(norm_path_old);
 		return res;
 	}
 
//flaw_line_below:
 	/* There is a race condition where the path could not exist but be created between the exists check and calling
//fix_flaw_line_below:
//	/* There is a race condition where the path could not exist but be created between the exists check and calling
 	 * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this
 	 * situation won't cause an error. */
 	if (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {
		M_fs_progress_destroy(progress);
		M_free(norm_path_new);
		M_free(norm_path_old);
		return M_FS_ERROR_FILE_EXISTS;
	}

	if (cb) {
		entry_size = M_fs_info_get_size(info);

		M_fs_progress_set_path(progress, norm_path_new);
		M_fs_progress_set_type(progress, M_fs_info_get_type(info));
		if (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {
			M_fs_progress_set_size_total(progress, entry_size);
			M_fs_progress_set_size_total_progess(progress, entry_size);
		}
		if (progress_flags & M_FS_PROGRESS_SIZE_CUR) {
			M_fs_progress_set_size_current(progress, entry_size);
			M_fs_progress_set_size_current_progress(progress, entry_size);
		}
		/* Change the progress count to reflect the count. */
		if (progress_flags & M_FS_PROGRESS_COUNT) {
			M_fs_progress_set_count_total(progress, 1);
			M_fs_progress_set_count(progress, 1);
		}
	}

	/* Move the file. */
	if (M_fs_info_get_type(info) == M_FS_TYPE_SYMLINK) {
		res = M_fs_path_readlink(&resolve_path, norm_path_old);
		if (res == M_FS_ERROR_SUCCESS) {
			res = M_fs_symlink(norm_path_new, resolve_path);
		}
		M_free(resolve_path);
	} else {
		res = M_fs_move_file(norm_path_old, norm_path_new);
	}
	/* Failure was because we're crossing mount points. */
	if (res == M_FS_ERROR_NOT_SAMEDEV) {
		/* Can't rename so copy and delete. */
		if (M_fs_copy(norm_path_old, norm_path_new, mode, cb, progress_flags) == M_FS_ERROR_SUCCESS) {
			/* Success - Delete the original files since this is a move. */
 			res = M_fs_delete(norm_path_old, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 		} else {
 			/* Failure - Delete the new files that were copied but only if we are not overwriting. We don't
//flaw_line_below:
 			 * want to remove any existing files (especially if the dest is a dir). */
//fix_flaw_line_below:
//			 * want to remove any existing files (especially if the dest is a dir). */
 			if (!(mode & M_FS_FILE_MODE_OVERWRITE)) {
 				M_fs_delete(norm_path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 			}
 			res = M_FS_ERROR_GENERIC;
 		}
 	} else {
 		/* Call the cb with the result of the move whether it was a success for fail. We call the cb only if the
//flaw_line_below:
 		 * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */
//fix_flaw_line_below:
//		 * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */
 		if (cb) {
 			M_fs_progress_set_result(progress, res);
 			if (!cb(progress)) {
				res = M_FS_ERROR_CANCELED;
			}
		}
	}

	M_fs_info_destroy(info);
	M_fs_progress_destroy(progress);
	M_free(norm_path_new);
	M_free(norm_path_old);

	return res;
}
"
4581,182317,,Remote,Not required,Partial,CVE-2018-14043,https://www.cvedetails.com/cve/CVE-2018-14043/,CWE-732,Low,Partial,Partial,,2018-07-13,7.5,"mstdlib (aka the M Standard Library for C) 1.2.0 has incorrect file access control in situations where M_fs_perms_can_access attempts to delete an existing file (that lacks public read/write access) during a copy operation, related to fs/m_fs.c and fs/m_fs_path.c. An attacker could create the file and then would have access to the data.",2019-10-02,,1,https://github.com/Monetra/mstdlib/commit/db124b8f607dd0a40a9aef2d4d468fad433522a7,db124b8f607dd0a40a9aef2d4d468fad433522a7,fs: Don't try to delete the file when copying. It could cause a security issue if the file exists and doesn't allow other's to read/write. delete could allow someone to create the file and have access to the data.,1,base/fs/m_fs_path.c,"{""sha"": ""57f2a313bd3b217f64fd91d2d4a81272ac148734"", ""filename"": ""base/fs/m_fs.c"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 27, ""changes"": 52, ""blob_url"": ""https://github.com/Monetra/mstdlib/blob/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs.c"", ""raw_url"": ""https://github.com/Monetra/mstdlib/raw/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs.c"", ""contents_url"": ""https://api.github.com/repos/Monetra/mstdlib/contents/base/fs/m_fs.c?ref=db124b8f607dd0a40a9aef2d4d468fad433522a7"", ""patch"": ""@@ -101,6 +101,15 @@ static M_bool M_fs_isfileintodir(const char *p1, const char *p2, char **new_p2)\n \treturn M_TRUE;\n }\n \n+/* Used by copy and move to determine if we can write to the given path\n+ * based on a file already existing there or not.\n+ *\n+ * access is used to determine existence because we don't want to overwrite\n+ * if there already is a file. This is not guaranteed because if there is\n+ * a race condition where a file is created after this check it will be\n+ * overwritten. Not much we can do about that. It shouldn't pose a security\n+ * issue since this is more of a request than a requirement.\n+ */\n static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uint32 mode)\n {\n \tM_fs_info_t  *info = NULL;\n@@ -129,8 +138,7 @@ static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uin\n \n \tif (type != M_FS_TYPE_DIR) {\n \t\t/* File exists at path. */\n-\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS)\n-\t\t{\n+\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n \t\t\tret = M_FALSE;\n \t\t\tgoto done;\n \t\t}\n@@ -209,19 +217,6 @@ static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M\n \tsize_t         offset;\n \tM_fs_error_t   res;\n \n-\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it\n- \t * to new file. */\n-\tif (M_fs_perms_can_access(path_new, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n-\t\t/* Try to delete the file since we'll be overwrite it. This is so when we create the file we create it without\n- \t\t * any permissions and to ensure that anything that has the file already open won't be able to read the new\n-\t\t * contents we're writing to the file or be able to change the perms. There is an unavoidable race condition\n-\t\t * between deleting and creating the file where someone could create the file and have access. However,\n-\t\t * depending on the OS they may have access even if the file is created with no perms... */\n-\t\tres = M_fs_delete(path_new, M_FALSE, NULL, M_FS_PROGRESS_NOEXTRA);\n-\t\tif (res != M_FS_ERROR_SUCCESS) {\n-\t\t\treturn res;\n-\t\t}\n-\t}\n \t/* Open the old file */\n \tres = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);\n \tif (res != M_FS_ERROR_SUCCESS) {\n@@ -236,6 +231,9 @@ static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M\n \t\t}\n \t\tperms = M_fs_info_get_perms(info);\n \t}\n+\n+\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it\n+\t * to new file. */\n \tres = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);\n \tM_fs_info_destroy(info);\n \tif (res != M_FS_ERROR_SUCCESS) {\n@@ -333,7 +331,7 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode\n \t}\n \n \t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n- \t * existing to rename because any check we perform may not be true when rename is called. */\n+\t * existing to rename because any check we perform may not be true when rename is called. */\n \tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n \tif (res != M_FS_ERROR_SUCCESS) {\n \t\tM_free(norm_path_new);\n@@ -351,7 +349,7 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode\n \t\treturn res;\n \t}\n \n- \t/* There is a race condition where the path could not exist but be created between the exists check and calling\n+\t/* There is a race condition where the path could not exist but be created between the exists check and calling\n \t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n \t * situation won't cause an error. */\n \tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n@@ -399,15 +397,15 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode\n \t\t\tres = M_fs_delete(norm_path_old, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t\t} else {\n \t\t\t/* Failure - Delete the new files that were copied but only if we are not overwriting. We don't\n- \t\t\t * want to remove any existing files (especially if the dest is a dir). */\n+\t\t\t * want to remove any existing files (especially if the dest is a dir). */\n \t\t\tif (!(mode & M_FS_FILE_MODE_OVERWRITE)) {\n \t\t\t\tM_fs_delete(norm_path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t\t\t}\n \t\t\tres = M_FS_ERROR_GENERIC;\n \t\t}\n \t} else {\n \t\t/* Call the cb with the result of the move whether it was a success for fail. We call the cb only if the\n- \t\t * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */\n+\t\t * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */\n \t\tif (cb) {\n \t\t\tM_fs_progress_set_result(progress, res);\n \t\t\tif (!cb(progress)) {\n@@ -465,7 +463,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \t}\n \n \t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n- \t * existing to rename because any check we perform may not be true when rename is called. */\n+\t * existing to rename because any check we perform may not be true when rename is called. */\n \tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n \tif (res != M_FS_ERROR_SUCCESS) {\n \t\tM_free(norm_path_new);\n@@ -485,7 +483,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \n \ttype = M_fs_info_get_type(info);\n \n- \t/* There is a race condition where the path could not exist but be created between the exists check and calling\n+\t/* There is a race condition where the path could not exist but be created between the exists check and calling\n \t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n \t * situation won't cause an error. */\n \tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n@@ -497,7 +495,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \n \tentries = M_fs_dir_entries_create();\n \t/* No need to destroy info  because it's now owned by entries and will be destroyed when entries is destroyed.\n- \t * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is\n+\t * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is\n \t * stored in the entry. */\n \tM_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path_new, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));\n \tif (type == M_FS_TYPE_DIR) {\n@@ -523,7 +521,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \n \t\t\ttype = M_fs_dir_entry_get_type(entry);\n \t\t\t/* The total isn't the total number of files but the total number of operations. \n- \t\t\t * Making dirs and symlinks is one operation and copying a file will be split into\n+\t\t\t * Making dirs and symlinks is one operation and copying a file will be split into\n \t\t\t * multiple operations. Copying uses the M_FS_BUF_SIZE to read and write in\n \t\t\t * chunks. We determine how many chunks will be needed to read the entire file and\n \t\t\t * use that for the number of operations for the file. */\n@@ -600,7 +598,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \t}\n \n \t/* Delete the file(s) if it could not be copied properly, but only if we are not overwriting.\n- \t * If we're overwriting then there could be other files in that location (especially if it's a dir). */\n+\t * If we're overwriting then there could be other files in that location (especially if it's a dir). */\n \tif (res != M_FS_ERROR_SUCCESS && !(mode & M_FS_FILE_MODE_OVERWRITE)) {\n \t\tM_fs_delete(path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t}\n@@ -659,7 +657,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress\n \tentries = M_fs_dir_entries_create();\n \n \t/* Recursive directory deletion isn't intuitive. We have to generate a list of files and delete the list.\n- \t * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior\n+\t * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior\n \t * is undefined in Posix and HFS is known to skip files if the directory contents is modifies as the\n \t * directory is being walked. */\n \tif (type == M_FS_TYPE_DIR && remove_children) {\n@@ -671,7 +669,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress\n \t}\n \n \t/* Add the original path to the list of entries. This may be the only entry in the list. We need to add\n- \t * it after a potential walk because we can't delete a directory that isn't empty.\n+\t * it after a potential walk because we can't delete a directory that isn't empty.\n \t * Note: \n \t *   - The info will be owned by the entry and destroyed when it is destroyed. \n \t *   - The basic info param doesn't get the info in this case. it's set so the info is stored in the entry. */\n@@ -680,7 +678,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress\n \tlen = M_fs_dir_entries_len(entries);\n \tif (cb) {\n \t\t/* Create the progress. The same progress will be used for the entire operation. It will be updated with\n- \t\t * new info as necessary. */\n+\t\t * new info as necessary. */\n \t\tprogress = M_fs_progress_create();\n \n \t\t/* Get the total size of all files to be deleted if using the progress cb and size totals is set. */""}<_**next**_>{""sha"": ""952fe45f15c30f70e88bdb4293c37ea72992c9bc"", ""filename"": ""base/fs/m_fs_path.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 3, ""changes"": 22, ""blob_url"": ""https://github.com/Monetra/mstdlib/blob/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs_path.c"", ""raw_url"": ""https://github.com/Monetra/mstdlib/raw/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs_path.c"", ""contents_url"": ""https://api.github.com/repos/Monetra/mstdlib/contents/base/fs/m_fs_path.c?ref=db124b8f607dd0a40a9aef2d4d468fad433522a7"", ""patch"": ""@@ -254,7 +254,7 @@ char *M_fs_path_join_parts(const M_list_str_t *path, M_fs_system_t sys_type)\n \tsys_type = M_fs_path_get_system_type(sys_type);\n \n \t/* Remove any empty parts (except for the first part which denotes an abs path on Unix\n- \t * or a UNC path on Windows). */\n+\t * or a UNC path on Windows). */\n \tparts = M_list_str_duplicate(path);\n \tfor (i=len-1; i>0; i--) {\n \t\tpart = M_list_str_at(parts, i);\n@@ -536,7 +536,7 @@ M_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)\n \t}\n \n \t/* Hidden. Check if the first character of the last part of the path. Either the file or directory name itself\n- \t * starts with a '.'. */\n+\t * starts with a '.'. */\n \tpath_parts = M_fs_path_componentize_path(path, M_FS_SYSTEM_UNIX);\n \tlen = M_list_str_len(path_parts);\n \tif (len > 0) {\n@@ -601,7 +601,23 @@ char *M_fs_path_tmpdir(M_fs_system_t sys_type)\n \td = M_fs_path_mac_tmpdir();\n #else\n \tconst char *const_temp;\n-\t/* Try Unix env var. */\n+\t/* Unix doens't have a fancy function to get the standard\n+\t * temporary directory an application can use. Instead there\n+\t * is a convoluted set of possible paths that could be used.\n+\t *\n+\t * We're going to go though each one in a priority order and\n+\t * verify if we can read and write the directory. If so then\n+\t * that's the one that will be used. We are fine using access\n+\t * here because it doesn't matter if the path ends up being\n+\t * changed out from underneath us later on. When it's used\n+\t * at that time it will fail. Right now we just want to get\n+\t * a path that can be tried. */\n+\n+\t/* Try Unix env vars.\n+\t *\n+\t * This is not ideal but a valid way to set the temporary directory\n+\t * for a user. Per Single Unix Specification 4 and probably other things.\n+\t */\n #  ifdef HAVE_SECURE_GETENV\n \tconst_temp = secure_getenv(\""TMPDIR\"");\n #  else""}","M_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)
{
	M_list_str_t *path_parts;
	size_t        len;
	M_bool        ret        = M_FALSE;

	(void)info;

	if (path == NULL || *path == '\0') {
		return M_FALSE;
 	}
 
 	/* Hidden. Check if the first character of the last part of the path. Either the file or directory name itself
	 * starts with a '.'. */
 	path_parts = M_fs_path_componentize_path(path, M_FS_SYSTEM_UNIX);
 	len = M_list_str_len(path_parts);
 	if (len > 0) {
		if (*M_list_str_at(path_parts, len-1) == '.') {
			ret = M_TRUE;
		}
	}
	M_list_str_destroy(path_parts);

	return ret;
}
","M_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)
{
	M_list_str_t *path_parts;
	size_t        len;
	M_bool        ret        = M_FALSE;

	(void)info;

	if (path == NULL || *path == '\0') {
		return M_FALSE;
 	}
 
 	/* Hidden. Check if the first character of the last part of the path. Either the file or directory name itself
 	 * starts with a '.'. */
 	path_parts = M_fs_path_componentize_path(path, M_FS_SYSTEM_UNIX);
 	len = M_list_str_len(path_parts);
 	if (len > 0) {
		if (*M_list_str_at(path_parts, len-1) == '.') {
			ret = M_TRUE;
		}
	}
	M_list_str_destroy(path_parts);

	return ret;
}
",C,"	 * starts with a '.'. */
"," 	 * starts with a '.'. */
",,"@@ -254,7 +254,7 @@ char *M_fs_path_join_parts(const M_list_str_t *path, M_fs_system_t sys_type)
 	sys_type = M_fs_path_get_system_type(sys_type);
 
 	/* Remove any empty parts (except for the first part which denotes an abs path on Unix
- 	 * or a UNC path on Windows). */
+	 * or a UNC path on Windows). */
 	parts = M_list_str_duplicate(path);
 	for (i=len-1; i>0; i--) {
 		part = M_list_str_at(parts, i);
@@ -536,7 +536,7 @@ M_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)
 	}
 
 	/* Hidden. Check if the first character of the last part of the path. Either the file or directory name itself
- 	 * starts with a '.'. */
+	 * starts with a '.'. */
 	path_parts = M_fs_path_componentize_path(path, M_FS_SYSTEM_UNIX);
 	len = M_list_str_len(path_parts);
 	if (len > 0) {
@@ -601,7 +601,23 @@ char *M_fs_path_tmpdir(M_fs_system_t sys_type)
 	d = M_fs_path_mac_tmpdir();
 #else
 	const char *const_temp;
-	/* Try Unix env var. */
+	/* Unix doens't have a fancy function to get the standard
+	 * temporary directory an application can use. Instead there
+	 * is a convoluted set of possible paths that could be used.
+	 *
+	 * We're going to go though each one in a priority order and
+	 * verify if we can read and write the directory. If so then
+	 * that's the one that will be used. We are fine using access
+	 * here because it doesn't matter if the path ends up being
+	 * changed out from underneath us later on. When it's used
+	 * at that time it will fail. Right now we just want to get
+	 * a path that can be tried. */
+
+	/* Try Unix env vars.
+	 *
+	 * This is not ideal but a valid way to set the temporary directory
+	 * for a user. Per Single Unix Specification 4 and probably other things.
+	 */
 #  ifdef HAVE_SECURE_GETENV
 	const_temp = secure_getenv(""TMPDIR"");
 #  else",mstdlib,db124b8f607dd0a40a9aef2d4d468fad433522a7,f82091aa7497f952e3183019ae73611c26ccb0b1,1,"M_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)
{
	M_list_str_t *path_parts;
	size_t        len;
	M_bool        ret        = M_FALSE;

	(void)info;

	if (path == NULL || *path == '\0') {
		return M_FALSE;
 	}
 
 	/* Hidden. Check if the first character of the last part of the path. Either the file or directory name itself
//flaw_line_below:
 	 * starts with a '.'. */
//fix_flaw_line_below:
//	 * starts with a '.'. */
 	path_parts = M_fs_path_componentize_path(path, M_FS_SYSTEM_UNIX);
 	len = M_list_str_len(path_parts);
 	if (len > 0) {
		if (*M_list_str_at(path_parts, len-1) == '.') {
			ret = M_TRUE;
		}
	}
	M_list_str_destroy(path_parts);

	return ret;
}
"
4582,182318,,Remote,Not required,Partial,CVE-2018-14043,https://www.cvedetails.com/cve/CVE-2018-14043/,CWE-732,Low,Partial,Partial,,2018-07-13,7.5,"mstdlib (aka the M Standard Library for C) 1.2.0 has incorrect file access control in situations where M_fs_perms_can_access attempts to delete an existing file (that lacks public read/write access) during a copy operation, related to fs/m_fs.c and fs/m_fs_path.c. An attacker could create the file and then would have access to the data.",2019-10-02,,1,https://github.com/Monetra/mstdlib/commit/db124b8f607dd0a40a9aef2d4d468fad433522a7,db124b8f607dd0a40a9aef2d4d468fad433522a7,fs: Don't try to delete the file when copying. It could cause a security issue if the file exists and doesn't allow other's to read/write. delete could allow someone to create the file and have access to the data.,1,base/fs/m_fs_path.c,"{""sha"": ""57f2a313bd3b217f64fd91d2d4a81272ac148734"", ""filename"": ""base/fs/m_fs.c"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 27, ""changes"": 52, ""blob_url"": ""https://github.com/Monetra/mstdlib/blob/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs.c"", ""raw_url"": ""https://github.com/Monetra/mstdlib/raw/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs.c"", ""contents_url"": ""https://api.github.com/repos/Monetra/mstdlib/contents/base/fs/m_fs.c?ref=db124b8f607dd0a40a9aef2d4d468fad433522a7"", ""patch"": ""@@ -101,6 +101,15 @@ static M_bool M_fs_isfileintodir(const char *p1, const char *p2, char **new_p2)\n \treturn M_TRUE;\n }\n \n+/* Used by copy and move to determine if we can write to the given path\n+ * based on a file already existing there or not.\n+ *\n+ * access is used to determine existence because we don't want to overwrite\n+ * if there already is a file. This is not guaranteed because if there is\n+ * a race condition where a file is created after this check it will be\n+ * overwritten. Not much we can do about that. It shouldn't pose a security\n+ * issue since this is more of a request than a requirement.\n+ */\n static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uint32 mode)\n {\n \tM_fs_info_t  *info = NULL;\n@@ -129,8 +138,7 @@ static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uin\n \n \tif (type != M_FS_TYPE_DIR) {\n \t\t/* File exists at path. */\n-\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS)\n-\t\t{\n+\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n \t\t\tret = M_FALSE;\n \t\t\tgoto done;\n \t\t}\n@@ -209,19 +217,6 @@ static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M\n \tsize_t         offset;\n \tM_fs_error_t   res;\n \n-\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it\n- \t * to new file. */\n-\tif (M_fs_perms_can_access(path_new, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n-\t\t/* Try to delete the file since we'll be overwrite it. This is so when we create the file we create it without\n- \t\t * any permissions and to ensure that anything that has the file already open won't be able to read the new\n-\t\t * contents we're writing to the file or be able to change the perms. There is an unavoidable race condition\n-\t\t * between deleting and creating the file where someone could create the file and have access. However,\n-\t\t * depending on the OS they may have access even if the file is created with no perms... */\n-\t\tres = M_fs_delete(path_new, M_FALSE, NULL, M_FS_PROGRESS_NOEXTRA);\n-\t\tif (res != M_FS_ERROR_SUCCESS) {\n-\t\t\treturn res;\n-\t\t}\n-\t}\n \t/* Open the old file */\n \tres = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);\n \tif (res != M_FS_ERROR_SUCCESS) {\n@@ -236,6 +231,9 @@ static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M\n \t\t}\n \t\tperms = M_fs_info_get_perms(info);\n \t}\n+\n+\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it\n+\t * to new file. */\n \tres = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);\n \tM_fs_info_destroy(info);\n \tif (res != M_FS_ERROR_SUCCESS) {\n@@ -333,7 +331,7 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode\n \t}\n \n \t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n- \t * existing to rename because any check we perform may not be true when rename is called. */\n+\t * existing to rename because any check we perform may not be true when rename is called. */\n \tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n \tif (res != M_FS_ERROR_SUCCESS) {\n \t\tM_free(norm_path_new);\n@@ -351,7 +349,7 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode\n \t\treturn res;\n \t}\n \n- \t/* There is a race condition where the path could not exist but be created between the exists check and calling\n+\t/* There is a race condition where the path could not exist but be created between the exists check and calling\n \t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n \t * situation won't cause an error. */\n \tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n@@ -399,15 +397,15 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode\n \t\t\tres = M_fs_delete(norm_path_old, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t\t} else {\n \t\t\t/* Failure - Delete the new files that were copied but only if we are not overwriting. We don't\n- \t\t\t * want to remove any existing files (especially if the dest is a dir). */\n+\t\t\t * want to remove any existing files (especially if the dest is a dir). */\n \t\t\tif (!(mode & M_FS_FILE_MODE_OVERWRITE)) {\n \t\t\t\tM_fs_delete(norm_path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t\t\t}\n \t\t\tres = M_FS_ERROR_GENERIC;\n \t\t}\n \t} else {\n \t\t/* Call the cb with the result of the move whether it was a success for fail. We call the cb only if the\n- \t\t * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */\n+\t\t * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */\n \t\tif (cb) {\n \t\t\tM_fs_progress_set_result(progress, res);\n \t\t\tif (!cb(progress)) {\n@@ -465,7 +463,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \t}\n \n \t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n- \t * existing to rename because any check we perform may not be true when rename is called. */\n+\t * existing to rename because any check we perform may not be true when rename is called. */\n \tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n \tif (res != M_FS_ERROR_SUCCESS) {\n \t\tM_free(norm_path_new);\n@@ -485,7 +483,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \n \ttype = M_fs_info_get_type(info);\n \n- \t/* There is a race condition where the path could not exist but be created between the exists check and calling\n+\t/* There is a race condition where the path could not exist but be created between the exists check and calling\n \t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n \t * situation won't cause an error. */\n \tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n@@ -497,7 +495,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \n \tentries = M_fs_dir_entries_create();\n \t/* No need to destroy info  because it's now owned by entries and will be destroyed when entries is destroyed.\n- \t * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is\n+\t * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is\n \t * stored in the entry. */\n \tM_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path_new, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));\n \tif (type == M_FS_TYPE_DIR) {\n@@ -523,7 +521,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \n \t\t\ttype = M_fs_dir_entry_get_type(entry);\n \t\t\t/* The total isn't the total number of files but the total number of operations. \n- \t\t\t * Making dirs and symlinks is one operation and copying a file will be split into\n+\t\t\t * Making dirs and symlinks is one operation and copying a file will be split into\n \t\t\t * multiple operations. Copying uses the M_FS_BUF_SIZE to read and write in\n \t\t\t * chunks. We determine how many chunks will be needed to read the entire file and\n \t\t\t * use that for the number of operations for the file. */\n@@ -600,7 +598,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \t}\n \n \t/* Delete the file(s) if it could not be copied properly, but only if we are not overwriting.\n- \t * If we're overwriting then there could be other files in that location (especially if it's a dir). */\n+\t * If we're overwriting then there could be other files in that location (especially if it's a dir). */\n \tif (res != M_FS_ERROR_SUCCESS && !(mode & M_FS_FILE_MODE_OVERWRITE)) {\n \t\tM_fs_delete(path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t}\n@@ -659,7 +657,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress\n \tentries = M_fs_dir_entries_create();\n \n \t/* Recursive directory deletion isn't intuitive. We have to generate a list of files and delete the list.\n- \t * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior\n+\t * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior\n \t * is undefined in Posix and HFS is known to skip files if the directory contents is modifies as the\n \t * directory is being walked. */\n \tif (type == M_FS_TYPE_DIR && remove_children) {\n@@ -671,7 +669,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress\n \t}\n \n \t/* Add the original path to the list of entries. This may be the only entry in the list. We need to add\n- \t * it after a potential walk because we can't delete a directory that isn't empty.\n+\t * it after a potential walk because we can't delete a directory that isn't empty.\n \t * Note: \n \t *   - The info will be owned by the entry and destroyed when it is destroyed. \n \t *   - The basic info param doesn't get the info in this case. it's set so the info is stored in the entry. */\n@@ -680,7 +678,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress\n \tlen = M_fs_dir_entries_len(entries);\n \tif (cb) {\n \t\t/* Create the progress. The same progress will be used for the entire operation. It will be updated with\n- \t\t * new info as necessary. */\n+\t\t * new info as necessary. */\n \t\tprogress = M_fs_progress_create();\n \n \t\t/* Get the total size of all files to be deleted if using the progress cb and size totals is set. */""}<_**next**_>{""sha"": ""952fe45f15c30f70e88bdb4293c37ea72992c9bc"", ""filename"": ""base/fs/m_fs_path.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 3, ""changes"": 22, ""blob_url"": ""https://github.com/Monetra/mstdlib/blob/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs_path.c"", ""raw_url"": ""https://github.com/Monetra/mstdlib/raw/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs_path.c"", ""contents_url"": ""https://api.github.com/repos/Monetra/mstdlib/contents/base/fs/m_fs_path.c?ref=db124b8f607dd0a40a9aef2d4d468fad433522a7"", ""patch"": ""@@ -254,7 +254,7 @@ char *M_fs_path_join_parts(const M_list_str_t *path, M_fs_system_t sys_type)\n \tsys_type = M_fs_path_get_system_type(sys_type);\n \n \t/* Remove any empty parts (except for the first part which denotes an abs path on Unix\n- \t * or a UNC path on Windows). */\n+\t * or a UNC path on Windows). */\n \tparts = M_list_str_duplicate(path);\n \tfor (i=len-1; i>0; i--) {\n \t\tpart = M_list_str_at(parts, i);\n@@ -536,7 +536,7 @@ M_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)\n \t}\n \n \t/* Hidden. Check if the first character of the last part of the path. Either the file or directory name itself\n- \t * starts with a '.'. */\n+\t * starts with a '.'. */\n \tpath_parts = M_fs_path_componentize_path(path, M_FS_SYSTEM_UNIX);\n \tlen = M_list_str_len(path_parts);\n \tif (len > 0) {\n@@ -601,7 +601,23 @@ char *M_fs_path_tmpdir(M_fs_system_t sys_type)\n \td = M_fs_path_mac_tmpdir();\n #else\n \tconst char *const_temp;\n-\t/* Try Unix env var. */\n+\t/* Unix doens't have a fancy function to get the standard\n+\t * temporary directory an application can use. Instead there\n+\t * is a convoluted set of possible paths that could be used.\n+\t *\n+\t * We're going to go though each one in a priority order and\n+\t * verify if we can read and write the directory. If so then\n+\t * that's the one that will be used. We are fine using access\n+\t * here because it doesn't matter if the path ends up being\n+\t * changed out from underneath us later on. When it's used\n+\t * at that time it will fail. Right now we just want to get\n+\t * a path that can be tried. */\n+\n+\t/* Try Unix env vars.\n+\t *\n+\t * This is not ideal but a valid way to set the temporary directory\n+\t * for a user. Per Single Unix Specification 4 and probably other things.\n+\t */\n #  ifdef HAVE_SECURE_GETENV\n \tconst_temp = secure_getenv(\""TMPDIR\"");\n #  else""}","char *M_fs_path_join_parts(const M_list_str_t *path, M_fs_system_t sys_type)
{
	M_list_str_t *parts;
	const char   *part;
	char         *out;
	size_t        len;
	size_t        i;
	size_t        count;

	if (path == NULL) {
		return NULL;
	}
	len = M_list_str_len(path);
	if (len == 0) {
		return NULL;
	}

 	sys_type = M_fs_path_get_system_type(sys_type);
 
 	/* Remove any empty parts (except for the first part which denotes an abs path on Unix
	 * or a UNC path on Windows). */
 	parts = M_list_str_duplicate(path);
 	for (i=len-1; i>0; i--) {
 		part = M_list_str_at(parts, i);
		if (part == NULL || *part == '\0') {
			M_list_str_remove_at(parts, i);
		}
	}

	len = M_list_str_len(parts);

	/* Join puts the sep between items. If there are no items then the sep
	 * won't be written. */
	part = M_list_str_at(parts, 0);
	if (len == 1 && (part == NULL || *part == '\0')) {
		M_list_str_destroy(parts);
		if (sys_type == M_FS_SYSTEM_WINDOWS) {
			return M_strdup(""\\\\"");
		}
		return M_strdup(""/"");
	}

	/* Handle windows abs path because they need two separators. */
	if (sys_type == M_FS_SYSTEM_WINDOWS && len > 0) {
		part  = M_list_str_at(parts, 0);
		/* If we have 1 item we need to add two empties so we get the second separator. */
		count = (len == 1) ? 2 : 1;
		/* If we're dealing with a unc path add the second sep so we get two separators for the UNC base. */
		if (part != NULL && *part == '\0') {
			for (i=0; i<count; i++) {
				M_list_str_insert_at(parts, """", 0);
			}
		} else if (M_fs_path_isabs(part, sys_type) && len == 1) {
			/* We need to add an empty so we get a separator after the drive. */
			M_list_str_insert_at(parts, """", 1);
		}
	}

	out = M_list_str_join(parts, (unsigned char)M_fs_path_get_system_sep(sys_type));
	M_list_str_destroy(parts);
	return out;
}
","char *M_fs_path_join_parts(const M_list_str_t *path, M_fs_system_t sys_type)
{
	M_list_str_t *parts;
	const char   *part;
	char         *out;
	size_t        len;
	size_t        i;
	size_t        count;

	if (path == NULL) {
		return NULL;
	}
	len = M_list_str_len(path);
	if (len == 0) {
		return NULL;
	}

 	sys_type = M_fs_path_get_system_type(sys_type);
 
 	/* Remove any empty parts (except for the first part which denotes an abs path on Unix
 	 * or a UNC path on Windows). */
 	parts = M_list_str_duplicate(path);
 	for (i=len-1; i>0; i--) {
 		part = M_list_str_at(parts, i);
		if (part == NULL || *part == '\0') {
			M_list_str_remove_at(parts, i);
		}
	}

	len = M_list_str_len(parts);

	/* Join puts the sep between items. If there are no items then the sep
	 * won't be written. */
	part = M_list_str_at(parts, 0);
	if (len == 1 && (part == NULL || *part == '\0')) {
		M_list_str_destroy(parts);
		if (sys_type == M_FS_SYSTEM_WINDOWS) {
			return M_strdup(""\\\\"");
		}
		return M_strdup(""/"");
	}

	/* Handle windows abs path because they need two separators. */
	if (sys_type == M_FS_SYSTEM_WINDOWS && len > 0) {
		part  = M_list_str_at(parts, 0);
		/* If we have 1 item we need to add two empties so we get the second separator. */
		count = (len == 1) ? 2 : 1;
		/* If we're dealing with a unc path add the second sep so we get two separators for the UNC base. */
		if (part != NULL && *part == '\0') {
			for (i=0; i<count; i++) {
				M_list_str_insert_at(parts, """", 0);
			}
		} else if (M_fs_path_isabs(part, sys_type) && len == 1) {
			/* We need to add an empty so we get a separator after the drive. */
			M_list_str_insert_at(parts, """", 1);
		}
	}

	out = M_list_str_join(parts, (unsigned char)M_fs_path_get_system_sep(sys_type));
	M_list_str_destroy(parts);
	return out;
}
",C,"	 * or a UNC path on Windows). */
"," 	 * or a UNC path on Windows). */
",,"@@ -254,7 +254,7 @@ char *M_fs_path_join_parts(const M_list_str_t *path, M_fs_system_t sys_type)
 	sys_type = M_fs_path_get_system_type(sys_type);
 
 	/* Remove any empty parts (except for the first part which denotes an abs path on Unix
- 	 * or a UNC path on Windows). */
+	 * or a UNC path on Windows). */
 	parts = M_list_str_duplicate(path);
 	for (i=len-1; i>0; i--) {
 		part = M_list_str_at(parts, i);
@@ -536,7 +536,7 @@ M_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)
 	}
 
 	/* Hidden. Check if the first character of the last part of the path. Either the file or directory name itself
- 	 * starts with a '.'. */
+	 * starts with a '.'. */
 	path_parts = M_fs_path_componentize_path(path, M_FS_SYSTEM_UNIX);
 	len = M_list_str_len(path_parts);
 	if (len > 0) {
@@ -601,7 +601,23 @@ char *M_fs_path_tmpdir(M_fs_system_t sys_type)
 	d = M_fs_path_mac_tmpdir();
 #else
 	const char *const_temp;
-	/* Try Unix env var. */
+	/* Unix doens't have a fancy function to get the standard
+	 * temporary directory an application can use. Instead there
+	 * is a convoluted set of possible paths that could be used.
+	 *
+	 * We're going to go though each one in a priority order and
+	 * verify if we can read and write the directory. If so then
+	 * that's the one that will be used. We are fine using access
+	 * here because it doesn't matter if the path ends up being
+	 * changed out from underneath us later on. When it's used
+	 * at that time it will fail. Right now we just want to get
+	 * a path that can be tried. */
+
+	/* Try Unix env vars.
+	 *
+	 * This is not ideal but a valid way to set the temporary directory
+	 * for a user. Per Single Unix Specification 4 and probably other things.
+	 */
 #  ifdef HAVE_SECURE_GETENV
 	const_temp = secure_getenv(""TMPDIR"");
 #  else",mstdlib,db124b8f607dd0a40a9aef2d4d468fad433522a7,f82091aa7497f952e3183019ae73611c26ccb0b1,1,"char *M_fs_path_join_parts(const M_list_str_t *path, M_fs_system_t sys_type)
{
	M_list_str_t *parts;
	const char   *part;
	char         *out;
	size_t        len;
	size_t        i;
	size_t        count;

	if (path == NULL) {
		return NULL;
	}
	len = M_list_str_len(path);
	if (len == 0) {
		return NULL;
	}

 	sys_type = M_fs_path_get_system_type(sys_type);
 
 	/* Remove any empty parts (except for the first part which denotes an abs path on Unix
//flaw_line_below:
 	 * or a UNC path on Windows). */
//fix_flaw_line_below:
//	 * or a UNC path on Windows). */
 	parts = M_list_str_duplicate(path);
 	for (i=len-1; i>0; i--) {
 		part = M_list_str_at(parts, i);
		if (part == NULL || *part == '\0') {
			M_list_str_remove_at(parts, i);
		}
	}

	len = M_list_str_len(parts);

	/* Join puts the sep between items. If there are no items then the sep
	 * won't be written. */
	part = M_list_str_at(parts, 0);
	if (len == 1 && (part == NULL || *part == '\0')) {
		M_list_str_destroy(parts);
		if (sys_type == M_FS_SYSTEM_WINDOWS) {
			return M_strdup(""\\\\"");
		}
		return M_strdup(""/"");
	}

	/* Handle windows abs path because they need two separators. */
	if (sys_type == M_FS_SYSTEM_WINDOWS && len > 0) {
		part  = M_list_str_at(parts, 0);
		/* If we have 1 item we need to add two empties so we get the second separator. */
		count = (len == 1) ? 2 : 1;
		/* If we're dealing with a unc path add the second sep so we get two separators for the UNC base. */
		if (part != NULL && *part == '\0') {
			for (i=0; i<count; i++) {
				M_list_str_insert_at(parts, """", 0);
			}
		} else if (M_fs_path_isabs(part, sys_type) && len == 1) {
			/* We need to add an empty so we get a separator after the drive. */
			M_list_str_insert_at(parts, """", 1);
		}
	}

	out = M_list_str_join(parts, (unsigned char)M_fs_path_get_system_sep(sys_type));
	M_list_str_destroy(parts);
	return out;
}
"
4583,182319,,Remote,Not required,Partial,CVE-2018-14043,https://www.cvedetails.com/cve/CVE-2018-14043/,CWE-732,Low,Partial,Partial,,2018-07-13,7.5,"mstdlib (aka the M Standard Library for C) 1.2.0 has incorrect file access control in situations where M_fs_perms_can_access attempts to delete an existing file (that lacks public read/write access) during a copy operation, related to fs/m_fs.c and fs/m_fs_path.c. An attacker could create the file and then would have access to the data.",2019-10-02,,17,https://github.com/Monetra/mstdlib/commit/db124b8f607dd0a40a9aef2d4d468fad433522a7,db124b8f607dd0a40a9aef2d4d468fad433522a7,fs: Don't try to delete the file when copying. It could cause a security issue if the file exists and doesn't allow other's to read/write. delete could allow someone to create the file and have access to the data.,1,base/fs/m_fs_path.c,"{""sha"": ""57f2a313bd3b217f64fd91d2d4a81272ac148734"", ""filename"": ""base/fs/m_fs.c"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 27, ""changes"": 52, ""blob_url"": ""https://github.com/Monetra/mstdlib/blob/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs.c"", ""raw_url"": ""https://github.com/Monetra/mstdlib/raw/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs.c"", ""contents_url"": ""https://api.github.com/repos/Monetra/mstdlib/contents/base/fs/m_fs.c?ref=db124b8f607dd0a40a9aef2d4d468fad433522a7"", ""patch"": ""@@ -101,6 +101,15 @@ static M_bool M_fs_isfileintodir(const char *p1, const char *p2, char **new_p2)\n \treturn M_TRUE;\n }\n \n+/* Used by copy and move to determine if we can write to the given path\n+ * based on a file already existing there or not.\n+ *\n+ * access is used to determine existence because we don't want to overwrite\n+ * if there already is a file. This is not guaranteed because if there is\n+ * a race condition where a file is created after this check it will be\n+ * overwritten. Not much we can do about that. It shouldn't pose a security\n+ * issue since this is more of a request than a requirement.\n+ */\n static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uint32 mode)\n {\n \tM_fs_info_t  *info = NULL;\n@@ -129,8 +138,7 @@ static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uin\n \n \tif (type != M_FS_TYPE_DIR) {\n \t\t/* File exists at path. */\n-\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS)\n-\t\t{\n+\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n \t\t\tret = M_FALSE;\n \t\t\tgoto done;\n \t\t}\n@@ -209,19 +217,6 @@ static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M\n \tsize_t         offset;\n \tM_fs_error_t   res;\n \n-\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it\n- \t * to new file. */\n-\tif (M_fs_perms_can_access(path_new, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n-\t\t/* Try to delete the file since we'll be overwrite it. This is so when we create the file we create it without\n- \t\t * any permissions and to ensure that anything that has the file already open won't be able to read the new\n-\t\t * contents we're writing to the file or be able to change the perms. There is an unavoidable race condition\n-\t\t * between deleting and creating the file where someone could create the file and have access. However,\n-\t\t * depending on the OS they may have access even if the file is created with no perms... */\n-\t\tres = M_fs_delete(path_new, M_FALSE, NULL, M_FS_PROGRESS_NOEXTRA);\n-\t\tif (res != M_FS_ERROR_SUCCESS) {\n-\t\t\treturn res;\n-\t\t}\n-\t}\n \t/* Open the old file */\n \tres = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);\n \tif (res != M_FS_ERROR_SUCCESS) {\n@@ -236,6 +231,9 @@ static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M\n \t\t}\n \t\tperms = M_fs_info_get_perms(info);\n \t}\n+\n+\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it\n+\t * to new file. */\n \tres = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);\n \tM_fs_info_destroy(info);\n \tif (res != M_FS_ERROR_SUCCESS) {\n@@ -333,7 +331,7 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode\n \t}\n \n \t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n- \t * existing to rename because any check we perform may not be true when rename is called. */\n+\t * existing to rename because any check we perform may not be true when rename is called. */\n \tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n \tif (res != M_FS_ERROR_SUCCESS) {\n \t\tM_free(norm_path_new);\n@@ -351,7 +349,7 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode\n \t\treturn res;\n \t}\n \n- \t/* There is a race condition where the path could not exist but be created between the exists check and calling\n+\t/* There is a race condition where the path could not exist but be created between the exists check and calling\n \t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n \t * situation won't cause an error. */\n \tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n@@ -399,15 +397,15 @@ M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode\n \t\t\tres = M_fs_delete(norm_path_old, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t\t} else {\n \t\t\t/* Failure - Delete the new files that were copied but only if we are not overwriting. We don't\n- \t\t\t * want to remove any existing files (especially if the dest is a dir). */\n+\t\t\t * want to remove any existing files (especially if the dest is a dir). */\n \t\t\tif (!(mode & M_FS_FILE_MODE_OVERWRITE)) {\n \t\t\t\tM_fs_delete(norm_path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t\t\t}\n \t\t\tres = M_FS_ERROR_GENERIC;\n \t\t}\n \t} else {\n \t\t/* Call the cb with the result of the move whether it was a success for fail. We call the cb only if the\n- \t\t * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */\n+\t\t * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */\n \t\tif (cb) {\n \t\t\tM_fs_progress_set_result(progress, res);\n \t\t\tif (!cb(progress)) {\n@@ -465,7 +463,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \t}\n \n \t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n- \t * existing to rename because any check we perform may not be true when rename is called. */\n+\t * existing to rename because any check we perform may not be true when rename is called. */\n \tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n \tif (res != M_FS_ERROR_SUCCESS) {\n \t\tM_free(norm_path_new);\n@@ -485,7 +483,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \n \ttype = M_fs_info_get_type(info);\n \n- \t/* There is a race condition where the path could not exist but be created between the exists check and calling\n+\t/* There is a race condition where the path could not exist but be created between the exists check and calling\n \t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n \t * situation won't cause an error. */\n \tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n@@ -497,7 +495,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \n \tentries = M_fs_dir_entries_create();\n \t/* No need to destroy info  because it's now owned by entries and will be destroyed when entries is destroyed.\n- \t * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is\n+\t * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is\n \t * stored in the entry. */\n \tM_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path_new, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));\n \tif (type == M_FS_TYPE_DIR) {\n@@ -523,7 +521,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \n \t\t\ttype = M_fs_dir_entry_get_type(entry);\n \t\t\t/* The total isn't the total number of files but the total number of operations. \n- \t\t\t * Making dirs and symlinks is one operation and copying a file will be split into\n+\t\t\t * Making dirs and symlinks is one operation and copying a file will be split into\n \t\t\t * multiple operations. Copying uses the M_FS_BUF_SIZE to read and write in\n \t\t\t * chunks. We determine how many chunks will be needed to read the entire file and\n \t\t\t * use that for the number of operations for the file. */\n@@ -600,7 +598,7 @@ M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode\n \t}\n \n \t/* Delete the file(s) if it could not be copied properly, but only if we are not overwriting.\n- \t * If we're overwriting then there could be other files in that location (especially if it's a dir). */\n+\t * If we're overwriting then there could be other files in that location (especially if it's a dir). */\n \tif (res != M_FS_ERROR_SUCCESS && !(mode & M_FS_FILE_MODE_OVERWRITE)) {\n \t\tM_fs_delete(path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t}\n@@ -659,7 +657,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress\n \tentries = M_fs_dir_entries_create();\n \n \t/* Recursive directory deletion isn't intuitive. We have to generate a list of files and delete the list.\n- \t * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior\n+\t * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior\n \t * is undefined in Posix and HFS is known to skip files if the directory contents is modifies as the\n \t * directory is being walked. */\n \tif (type == M_FS_TYPE_DIR && remove_children) {\n@@ -671,7 +669,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress\n \t}\n \n \t/* Add the original path to the list of entries. This may be the only entry in the list. We need to add\n- \t * it after a potential walk because we can't delete a directory that isn't empty.\n+\t * it after a potential walk because we can't delete a directory that isn't empty.\n \t * Note: \n \t *   - The info will be owned by the entry and destroyed when it is destroyed. \n \t *   - The basic info param doesn't get the info in this case. it's set so the info is stored in the entry. */\n@@ -680,7 +678,7 @@ M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress\n \tlen = M_fs_dir_entries_len(entries);\n \tif (cb) {\n \t\t/* Create the progress. The same progress will be used for the entire operation. It will be updated with\n- \t\t * new info as necessary. */\n+\t\t * new info as necessary. */\n \t\tprogress = M_fs_progress_create();\n \n \t\t/* Get the total size of all files to be deleted if using the progress cb and size totals is set. */""}<_**next**_>{""sha"": ""952fe45f15c30f70e88bdb4293c37ea72992c9bc"", ""filename"": ""base/fs/m_fs_path.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 3, ""changes"": 22, ""blob_url"": ""https://github.com/Monetra/mstdlib/blob/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs_path.c"", ""raw_url"": ""https://github.com/Monetra/mstdlib/raw/db124b8f607dd0a40a9aef2d4d468fad433522a7/base/fs/m_fs_path.c"", ""contents_url"": ""https://api.github.com/repos/Monetra/mstdlib/contents/base/fs/m_fs_path.c?ref=db124b8f607dd0a40a9aef2d4d468fad433522a7"", ""patch"": ""@@ -254,7 +254,7 @@ char *M_fs_path_join_parts(const M_list_str_t *path, M_fs_system_t sys_type)\n \tsys_type = M_fs_path_get_system_type(sys_type);\n \n \t/* Remove any empty parts (except for the first part which denotes an abs path on Unix\n- \t * or a UNC path on Windows). */\n+\t * or a UNC path on Windows). */\n \tparts = M_list_str_duplicate(path);\n \tfor (i=len-1; i>0; i--) {\n \t\tpart = M_list_str_at(parts, i);\n@@ -536,7 +536,7 @@ M_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)\n \t}\n \n \t/* Hidden. Check if the first character of the last part of the path. Either the file or directory name itself\n- \t * starts with a '.'. */\n+\t * starts with a '.'. */\n \tpath_parts = M_fs_path_componentize_path(path, M_FS_SYSTEM_UNIX);\n \tlen = M_list_str_len(path_parts);\n \tif (len > 0) {\n@@ -601,7 +601,23 @@ char *M_fs_path_tmpdir(M_fs_system_t sys_type)\n \td = M_fs_path_mac_tmpdir();\n #else\n \tconst char *const_temp;\n-\t/* Try Unix env var. */\n+\t/* Unix doens't have a fancy function to get the standard\n+\t * temporary directory an application can use. Instead there\n+\t * is a convoluted set of possible paths that could be used.\n+\t *\n+\t * We're going to go though each one in a priority order and\n+\t * verify if we can read and write the directory. If so then\n+\t * that's the one that will be used. We are fine using access\n+\t * here because it doesn't matter if the path ends up being\n+\t * changed out from underneath us later on. When it's used\n+\t * at that time it will fail. Right now we just want to get\n+\t * a path that can be tried. */\n+\n+\t/* Try Unix env vars.\n+\t *\n+\t * This is not ideal but a valid way to set the temporary directory\n+\t * for a user. Per Single Unix Specification 4 and probably other things.\n+\t */\n #  ifdef HAVE_SECURE_GETENV\n \tconst_temp = secure_getenv(\""TMPDIR\"");\n #  else""}","char *M_fs_path_tmpdir(M_fs_system_t sys_type)
{
	char         *d   = NULL;
	char         *out = NULL;
	M_fs_error_t  res;

#ifdef _WIN32
	size_t len = M_fs_path_get_path_max(M_FS_SYSTEM_WINDOWS)+1;
	d = M_malloc_zero(len);
	/* Return is length without NULL. */
	if (GetTempPath((DWORD)len, d) >= len) {
		M_free(d);
		d = NULL;
	}
#elif defined(__APPLE__)
 	d = M_fs_path_mac_tmpdir();
 #else
 	const char *const_temp;
	/* Unix doens't have a fancy function to get the standard
	 * temporary directory an application can use. Instead there
	 * is a convoluted set of possible paths that could be used.
	 *
	 * We're going to go though each one in a priority order and
	 * verify if we can read and write the directory. If so then
	 * that's the one that will be used. We are fine using access
	 * here because it doesn't matter if the path ends up being
	 * changed out from underneath us later on. When it's used
	 * at that time it will fail. Right now we just want to get
	 * a path that can be tried. */

	/* Try Unix env vars.
	 *
	 * This is not ideal but a valid way to set the temporary directory
	 * for a user. Per Single Unix Specification 4 and probably other things.
	 */
 #  ifdef HAVE_SECURE_GETENV
 	const_temp = secure_getenv(""TMPDIR"");
 #  else
	const_temp = getenv(""TMPDIR"");
#  endif
	if (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {
		d = M_strdup(const_temp);
	}
	/* Fallback to some ""standard"" system paths. */
	if (d == NULL) {
		const_temp = ""/tmp"";
		if (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {
			d = M_strdup(const_temp);
		}
	}
	if (d == NULL) {
		const_temp = ""/var/tmp"";
		if (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {
			d = M_strdup(const_temp);
		}
	}
#endif

	if (d != NULL) {
		res = M_fs_path_norm(&out, d, M_FS_PATH_NORM_ABSOLUTE, sys_type);
		if (res != M_FS_ERROR_SUCCESS) {
			out = NULL;
		}
	}
	M_free(d);

	return out;
}
","char *M_fs_path_tmpdir(M_fs_system_t sys_type)
{
	char         *d   = NULL;
	char         *out = NULL;
	M_fs_error_t  res;

#ifdef _WIN32
	size_t len = M_fs_path_get_path_max(M_FS_SYSTEM_WINDOWS)+1;
	d = M_malloc_zero(len);
	/* Return is length without NULL. */
	if (GetTempPath((DWORD)len, d) >= len) {
		M_free(d);
		d = NULL;
	}
#elif defined(__APPLE__)
 	d = M_fs_path_mac_tmpdir();
 #else
 	const char *const_temp;
	/* Try Unix env var. */
 #  ifdef HAVE_SECURE_GETENV
 	const_temp = secure_getenv(""TMPDIR"");
 #  else
	const_temp = getenv(""TMPDIR"");
#  endif
	if (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {
		d = M_strdup(const_temp);
	}
	/* Fallback to some ""standard"" system paths. */
	if (d == NULL) {
		const_temp = ""/tmp"";
		if (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {
			d = M_strdup(const_temp);
		}
	}
	if (d == NULL) {
		const_temp = ""/var/tmp"";
		if (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {
			d = M_strdup(const_temp);
		}
	}
#endif

	if (d != NULL) {
		res = M_fs_path_norm(&out, d, M_FS_PATH_NORM_ABSOLUTE, sys_type);
		if (res != M_FS_ERROR_SUCCESS) {
			out = NULL;
		}
	}
	M_free(d);

	return out;
}
",C,"	/* Unix doens't have a fancy function to get the standard
	 * temporary directory an application can use. Instead there
	 * is a convoluted set of possible paths that could be used.
	 *
	 * We're going to go though each one in a priority order and
	 * verify if we can read and write the directory. If so then
	 * that's the one that will be used. We are fine using access
	 * here because it doesn't matter if the path ends up being
	 * changed out from underneath us later on. When it's used
	 * at that time it will fail. Right now we just want to get
	 * a path that can be tried. */

	/* Try Unix env vars.
	 *
	 * This is not ideal but a valid way to set the temporary directory
	 * for a user. Per Single Unix Specification 4 and probably other things.
	 */
","	/* Try Unix env var. */
",,"@@ -254,7 +254,7 @@ char *M_fs_path_join_parts(const M_list_str_t *path, M_fs_system_t sys_type)
 	sys_type = M_fs_path_get_system_type(sys_type);
 
 	/* Remove any empty parts (except for the first part which denotes an abs path on Unix
- 	 * or a UNC path on Windows). */
+	 * or a UNC path on Windows). */
 	parts = M_list_str_duplicate(path);
 	for (i=len-1; i>0; i--) {
 		part = M_list_str_at(parts, i);
@@ -536,7 +536,7 @@ M_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)
 	}
 
 	/* Hidden. Check if the first character of the last part of the path. Either the file or directory name itself
- 	 * starts with a '.'. */
+	 * starts with a '.'. */
 	path_parts = M_fs_path_componentize_path(path, M_FS_SYSTEM_UNIX);
 	len = M_list_str_len(path_parts);
 	if (len > 0) {
@@ -601,7 +601,23 @@ char *M_fs_path_tmpdir(M_fs_system_t sys_type)
 	d = M_fs_path_mac_tmpdir();
 #else
 	const char *const_temp;
-	/* Try Unix env var. */
+	/* Unix doens't have a fancy function to get the standard
+	 * temporary directory an application can use. Instead there
+	 * is a convoluted set of possible paths that could be used.
+	 *
+	 * We're going to go though each one in a priority order and
+	 * verify if we can read and write the directory. If so then
+	 * that's the one that will be used. We are fine using access
+	 * here because it doesn't matter if the path ends up being
+	 * changed out from underneath us later on. When it's used
+	 * at that time it will fail. Right now we just want to get
+	 * a path that can be tried. */
+
+	/* Try Unix env vars.
+	 *
+	 * This is not ideal but a valid way to set the temporary directory
+	 * for a user. Per Single Unix Specification 4 and probably other things.
+	 */
 #  ifdef HAVE_SECURE_GETENV
 	const_temp = secure_getenv(""TMPDIR"");
 #  else",mstdlib,db124b8f607dd0a40a9aef2d4d468fad433522a7,f82091aa7497f952e3183019ae73611c26ccb0b1,1,"char *M_fs_path_tmpdir(M_fs_system_t sys_type)
{
	char         *d   = NULL;
	char         *out = NULL;
	M_fs_error_t  res;

#ifdef _WIN32
	size_t len = M_fs_path_get_path_max(M_FS_SYSTEM_WINDOWS)+1;
	d = M_malloc_zero(len);
	/* Return is length without NULL. */
	if (GetTempPath((DWORD)len, d) >= len) {
		M_free(d);
		d = NULL;
	}
#elif defined(__APPLE__)
 	d = M_fs_path_mac_tmpdir();
 #else
 	const char *const_temp;
//flaw_line_below:
	/* Try Unix env var. */
//fix_flaw_line_below:
//	/* Unix doens't have a fancy function to get the standard
//fix_flaw_line_below:
//	 * temporary directory an application can use. Instead there
//fix_flaw_line_below:
//	 * is a convoluted set of possible paths that could be used.
//fix_flaw_line_below:
//	 *
//fix_flaw_line_below:
//	 * We're going to go though each one in a priority order and
//fix_flaw_line_below:
//	 * verify if we can read and write the directory. If so then
//fix_flaw_line_below:
//	 * that's the one that will be used. We are fine using access
//fix_flaw_line_below:
//	 * here because it doesn't matter if the path ends up being
//fix_flaw_line_below:
//	 * changed out from underneath us later on. When it's used
//fix_flaw_line_below:
//	 * at that time it will fail. Right now we just want to get
//fix_flaw_line_below:
//	 * a path that can be tried. */
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	/* Try Unix env vars.
//fix_flaw_line_below:
//	 *
//fix_flaw_line_below:
//	 * This is not ideal but a valid way to set the temporary directory
//fix_flaw_line_below:
//	 * for a user. Per Single Unix Specification 4 and probably other things.
//fix_flaw_line_below:
//	 */
 #  ifdef HAVE_SECURE_GETENV
 	const_temp = secure_getenv(""TMPDIR"");
 #  else
	const_temp = getenv(""TMPDIR"");
#  endif
	if (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {
		d = M_strdup(const_temp);
	}
	/* Fallback to some ""standard"" system paths. */
	if (d == NULL) {
		const_temp = ""/tmp"";
		if (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {
			d = M_strdup(const_temp);
		}
	}
	if (d == NULL) {
		const_temp = ""/var/tmp"";
		if (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {
			d = M_strdup(const_temp);
		}
	}
#endif

	if (d != NULL) {
		res = M_fs_path_norm(&out, d, M_FS_PATH_NORM_ABSOLUTE, sys_type);
		if (res != M_FS_ERROR_SUCCESS) {
			out = NULL;
		}
	}
	M_free(d);

	return out;
}
"
8531,186267,,Remote,Not required,,CVE-2017-5118,https://www.cvedetails.com/cve/CVE-2017-5118/,CWE-732,Medium,,Partial,,2017-10-27,4.3,"Blink in Google Chrome prior to 61.0.3163.79 for Mac, Windows, and Linux, and 61.0.3163.81 for Android, failed to correctly propagate CSP restrictions to javascript scheme pages, which allowed a remote attacker to bypass content security policy via a crafted HTML page.",2019-10-02,Bypass ,12,https://github.com/chromium/chromium/commit/0ab2412a104d2f235d7b9fe19d30ef605a410832,0ab2412a104d2f235d7b9fe19d30ef605a410832,"Inherit CSP when we inherit the security origin

This prevents attacks that use main window navigation to get out of the
existing csp constraints such as the related bug

Bug: 747847
Change-Id: I1e57b50da17f65d38088205b0a3c7c49ef2ae4d8
Reviewed-on: https://chromium-review.googlesource.com/592027
Reviewed-by: Mike West <mkwst@chromium.org>
Commit-Queue: Andy Paicu <andypaicu@chromium.org>
Cr-Commit-Position: refs/heads/master@{#492333}",4,third_party/WebKit/Source/core/dom/Document.cpp,"{""sha"": ""21c4fb33ce2d66db750d92a892e3871bd5d9b576"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/javascript-url-navigation-inherits-csp.html"", ""status"": ""added"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/javascript-url-navigation-inherits-csp.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/javascript-url-navigation-inherits-csp.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/javascript-url-navigation-inherits-csp.html?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -0,0 +1,16 @@\n+<!DOCTYPE html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+\n+<script>\n+  var window_url = encodeURIComponent(\""javascript:'<iframe src=/content-security-policy/support/fail.js />'\"");\n+  var report_cookie_name = encodeURIComponent(\""javascript-url-navigation-inherits-csp\"");\n+  window.open(\""support/test_csp_self_window.sub.html?window_url=\"" + window_url + \""&report_cookie_name=\"" + report_cookie_name);\n+  setTimeout(function() {\n+    var s = document.createElement('script');\n+    s.async = true;\n+    s.defer = true;\n+    s.src = \""../support/checkReport.sub.js?reportField=violated-directive&reportValue=frame-src%20%27none%27\"";\n+    document.body.appendChild(s);\n+  }, 2000);\n+</script>""}<_**next**_>{""sha"": ""ab0f8f82e3951a412824d066f670af17377dcec5"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html"", ""status"": ""added"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -0,0 +1,8 @@\n+<!DOCTYPE html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+\n+<script>\n+  var window_url = decodeURIComponent(\""{{GET[window_url]}}\"").replace('&lt;', '<').replace('&gt;', '>');\n+  window.open(window_url, \""_self\"");\n+</script>""}<_**next**_>{""sha"": ""dd418ec7648ba3f5603b0e070460ac171b8bc4d4"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html.sub.headers"", ""status"": ""added"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html.sub.headers"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html.sub.headers"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html.sub.headers?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -0,0 +1,6 @@\n+Expires: Mon, 26 Jul 1997 05:00:00 GMT\n+Cache-Control: no-store, no-cache, must-revalidate\n+Cache-Control: post-check=0, pre-check=0, false\n+Pragma: no-cache\n+Set-Cookie: {{GET[report_cookie_name]}}={{$id:uuid()}}; Path=/content-security-policy/navigation/\n+Content-Security-Policy: default-src 'none'; script-src 'self' 'unsafe-inline'; report-uri  ../../support/report.py?op=put&reportID={{$id}}""}<_**next**_>{""sha"": ""12245ff457031d6ccac563310d652a7fe83c88aa"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-in-iframe-expected.txt"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-in-iframe-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-in-iframe-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-in-iframe-expected.txt?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -1,5 +1,4 @@\n CONSOLE ERROR: The 'allow' directive has been replaced with 'default-src'. Please use that directive instead, as 'allow' has no effect.\n-CONSOLE ERROR: The 'allow' directive has been replaced with 'default-src'. Please use that directive instead, as 'allow' has no effect.\n Loads an iframe (a) which loads an iframe (b) which in turns tries to load an external script. The iframe (a) has a content security policy disabling external scripts. As this policy does not apply to (b), the script should be executed.\n \n ""}<_**next**_>{""sha"": ""c74e6c8893bb027a7928a49ca50a59062dc91319"", ""filename"": ""third_party/WebKit/Source/core/dom/Document.cpp"", ""status"": ""modified"", ""additions"": 21, ""deletions"": 8, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/dom/Document.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/dom/Document.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Document.cpp?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -5839,6 +5839,8 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {\n       AddInsecureNavigationUpgrade(to_upgrade);\n   }\n \n+  ContentSecurityPolicy* policy_to_inherit = nullptr;\n+\n   if (IsSandboxed(kSandboxOrigin)) {\n     cookie_url_ = url_;\n     SetSecurityOrigin(SecurityOrigin::CreateUnique());\n@@ -5854,12 +5856,14 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {\n         GetSecurityOrigin()->SetUniqueOriginIsPotentiallyTrustworthy(true);\n       if (owner->GetSecurityOrigin()->CanLoadLocalResources())\n         GetSecurityOrigin()->GrantLoadLocalResources();\n+      policy_to_inherit = owner->GetContentSecurityPolicy();\n     }\n   } else if (Document* owner = initializer.OwnerDocument()) {\n     cookie_url_ = owner->CookieURL();\n     // We alias the SecurityOrigins to match Firefox, see Bug 15313\n     // https://bugs.webkit.org/show_bug.cgi?id=15313\n     SetSecurityOrigin(owner->GetSecurityOrigin());\n+    policy_to_inherit = owner->GetContentSecurityPolicy();\n   } else {\n     cookie_url_ = url_;\n     SetSecurityOrigin(SecurityOrigin::Create(url_));\n@@ -5891,7 +5895,7 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {\n     SetContentSecurityPolicy(\n         ImportsController()->Master()->GetContentSecurityPolicy());\n   } else {\n-    InitContentSecurityPolicy();\n+    InitContentSecurityPolicy(nullptr, policy_to_inherit);\n   }\n \n   if (GetSecurityOrigin()->HasSuborigin())\n@@ -5926,7 +5930,13 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {\n   SetFeaturePolicy(g_empty_string);\n }\n \n-void Document::InitContentSecurityPolicy(ContentSecurityPolicy* csp) {\n+// the first parameter specifies a policy to use as the document csp meaning\n+// the document will take ownership of the policy\n+// the second parameter specifies a policy to inherit meaning the document\n+// will attempt to copy over the policy\n+void Document::InitContentSecurityPolicy(\n+    ContentSecurityPolicy* csp,\n+    const ContentSecurityPolicy* policy_to_inherit) {\n   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());\n \n   // We inherit the parent/opener's CSP for documents with \""local\"" schemes:\n@@ -5938,24 +5948,27 @@ void Document::InitContentSecurityPolicy(ContentSecurityPolicy* csp) {\n   //\n   // TODO(dcheng): This is similar enough to work we're doing in\n   // 'DocumentLoader::ensureWriter' that it might make sense to combine them.\n-  if (frame_) {\n+  if (policy_to_inherit) {\n+    GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\n+  } else if (frame_) {\n     Frame* inherit_from = frame_->Tree().Parent() ? frame_->Tree().Parent()\n                                                   : frame_->Client()->Opener();\n     if (inherit_from && frame_ != inherit_from) {\n       DCHECK(inherit_from->GetSecurityContext() &&\n              inherit_from->GetSecurityContext()->GetContentSecurityPolicy());\n-      ContentSecurityPolicy* policy_to_inherit =\n+      policy_to_inherit =\n           inherit_from->GetSecurityContext()->GetContentSecurityPolicy();\n       if (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||\n           url_.ProtocolIs(\""blob\"") || url_.ProtocolIs(\""filesystem\"")) {\n         GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\n       }\n-      // Plugin documents inherit their parent/opener's 'plugin-types' directive\n-      // regardless of URL.\n-      if (IsPluginDocument())\n-        GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);\n     }\n   }\n+  // Plugin documents inherit their parent/opener's 'plugin-types' directive\n+  // regardless of URL.\n+  if (policy_to_inherit && IsPluginDocument())\n+    GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);\n+\n   GetContentSecurityPolicy()->BindToExecutionContext(this);\n }\n ""}<_**next**_>{""sha"": ""0667c0c51ea98b13f4266c913e99c34dea484190"", ""filename"": ""third_party/WebKit/Source/core/dom/Document.h"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 1, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/dom/Document.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/dom/Document.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Document.h?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -1037,7 +1037,13 @@ class CORE_EXPORT Document : public ContainerNode,\n   const SVGDocumentExtensions* SvgExtensions();\n   SVGDocumentExtensions& AccessSVGExtensions();\n \n-  void InitContentSecurityPolicy(ContentSecurityPolicy* = nullptr);\n+  // the first parameter specifies a policy to use as the document csp meaning\n+  // the document will take ownership of the policy\n+  // the second parameter specifies a policy to inherit meaning the document\n+  // will attempt to copy over the policy\n+  void InitContentSecurityPolicy(\n+      ContentSecurityPolicy* = nullptr,\n+      const ContentSecurityPolicy* policy_to_inherit = nullptr);\n \n   bool IsSecureTransitionTo(const KURL&) const;\n ""}<_**next**_>{""sha"": ""bd46b9d507b12455c4beae30363baf11e9ef08ec"", ""filename"": ""third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -1818,7 +1818,6 @@ void WebLocalFrameImpl::SetInputEventsScaleForEmulation(\n \n void WebLocalFrameImpl::LoadJavaScriptURL(const KURL& url) {\n   DCHECK(GetFrame());\n-\n   // This is copied from ScriptController::executeScriptIfJavaScriptURL.\n   // Unfortunately, we cannot just use that method since it is private, and\n   // it also doesn't quite behave as we require it to for bookmarklets. The""}<_**next**_>{""sha"": ""a11d1147135855cfaec5c2f0da99aa2b9b233fa3"", ""filename"": ""third_party/WebKit/Source/core/loader/DocumentLoader.cpp"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 3, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/loader/DocumentLoader.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/loader/DocumentLoader.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/loader/DocumentLoader.cpp?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -898,9 +898,12 @@ void DocumentLoader::EndWriting() {\n   writer_.Clear();\n }\n \n-void DocumentLoader::DidInstallNewDocument(Document* document) {\n+void DocumentLoader::DidInstallNewDocument(Document* document,\n+                                           InstallNewDocumentReason reason) {\n   document->SetReadyState(Document::kLoading);\n-  document->InitContentSecurityPolicy(content_security_policy_.Release());\n+  if (content_security_policy_) {\n+    document->InitContentSecurityPolicy(content_security_policy_.Release());\n+  }\n \n   if (history_item_ && IsBackForwardLoadType(load_type_))\n     document->SetStateForNewFormElements(history_item_->GetDocumentState());\n@@ -1116,7 +1119,7 @@ void DocumentLoader::InstallNewDocument(\n   frame_->GetPage()->GetChromeClient().InstallSupplements(*frame_);\n   if (!overriding_url.IsEmpty())\n     document->SetBaseURLOverride(overriding_url);\n-  DidInstallNewDocument(document);\n+  DidInstallNewDocument(document, reason);\n \n   // This must be called before DocumentWriter is created, otherwise HTML parser\n   // will use stale values from HTMLParserOption.""}<_**next**_>{""sha"": ""e5f59fd0c5ce7e5ce4b5a052fc75e6ec845ad9f5"", ""filename"": ""third_party/WebKit/Source/core/loader/DocumentLoader.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/loader/DocumentLoader.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/loader/DocumentLoader.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/loader/DocumentLoader.h?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -244,7 +244,7 @@ class CORE_EXPORT DocumentLoader\n                           InstallNewDocumentReason,\n                           ParserSynchronizationPolicy,\n                           const KURL& overriding_url);\n-  void DidInstallNewDocument(Document*);\n+  void DidInstallNewDocument(Document*, InstallNewDocumentReason);\n   void WillCommitNavigation();\n   void DidCommitNavigation();\n ""}","void Document::InitContentSecurityPolicy(ContentSecurityPolicy* csp) {
//// the first parameter specifies a policy to use as the document csp meaning
//// the document will take ownership of the policy
//// the second parameter specifies a policy to inherit meaning the document
//// will attempt to copy over the policy
void Document::InitContentSecurityPolicy(
    ContentSecurityPolicy* csp,
    const ContentSecurityPolicy* policy_to_inherit) {
   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());
 
  if (policy_to_inherit) {
    GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
  } else if (frame_) {
     Frame* inherit_from = frame_->Tree().Parent() ? frame_->Tree().Parent()
                                                   : frame_->Client()->Opener();
     if (inherit_from && frame_ != inherit_from) {
       DCHECK(inherit_from->GetSecurityContext() &&
              inherit_from->GetSecurityContext()->GetContentSecurityPolicy());
      policy_to_inherit =
           inherit_from->GetSecurityContext()->GetContentSecurityPolicy();
       if (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||
           url_.ProtocolIs(""blob"") || url_.ProtocolIs(""filesystem"")) {
         GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
       }
     }
   }
  // Plugin documents inherit their parent/opener's 'plugin-types' directive
  // regardless of URL.
  if (policy_to_inherit && IsPluginDocument())
    GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);

   GetContentSecurityPolicy()->BindToExecutionContext(this);
 }
","void Document::InitContentSecurityPolicy(ContentSecurityPolicy* csp) {
//// the first parameter specifies a policy to use as the document csp meaning
//// the document will take ownership of the policy
//// the second parameter specifies a policy to inherit meaning the document
//// will attempt to copy over the policy
   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());
 
  if (frame_) {
     Frame* inherit_from = frame_->Tree().Parent() ? frame_->Tree().Parent()
                                                   : frame_->Client()->Opener();
     if (inherit_from && frame_ != inherit_from) {
       DCHECK(inherit_from->GetSecurityContext() &&
              inherit_from->GetSecurityContext()->GetContentSecurityPolicy());
      ContentSecurityPolicy* policy_to_inherit =
           inherit_from->GetSecurityContext()->GetContentSecurityPolicy();
       if (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||
           url_.ProtocolIs(""blob"") || url_.ProtocolIs(""filesystem"")) {
         GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
       }
      if (IsPluginDocument())
        GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);
     }
   }
   GetContentSecurityPolicy()->BindToExecutionContext(this);
 }
",C,"void Document::InitContentSecurityPolicy(
    ContentSecurityPolicy* csp,
    const ContentSecurityPolicy* policy_to_inherit) {
  if (policy_to_inherit) {
    GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
  } else if (frame_) {
      policy_to_inherit =
  // Plugin documents inherit their parent/opener's 'plugin-types' directive
  // regardless of URL.
  if (policy_to_inherit && IsPluginDocument())
    GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);

","  if (frame_) {
      ContentSecurityPolicy* policy_to_inherit =
      if (IsPluginDocument())
        GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);
",,"@@ -5839,6 +5839,8 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {
       AddInsecureNavigationUpgrade(to_upgrade);
   }
 
+  ContentSecurityPolicy* policy_to_inherit = nullptr;
+
   if (IsSandboxed(kSandboxOrigin)) {
     cookie_url_ = url_;
     SetSecurityOrigin(SecurityOrigin::CreateUnique());
@@ -5854,12 +5856,14 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {
         GetSecurityOrigin()->SetUniqueOriginIsPotentiallyTrustworthy(true);
       if (owner->GetSecurityOrigin()->CanLoadLocalResources())
         GetSecurityOrigin()->GrantLoadLocalResources();
+      policy_to_inherit = owner->GetContentSecurityPolicy();
     }
   } else if (Document* owner = initializer.OwnerDocument()) {
     cookie_url_ = owner->CookieURL();
     // We alias the SecurityOrigins to match Firefox, see Bug 15313
     // https://bugs.webkit.org/show_bug.cgi?id=15313
     SetSecurityOrigin(owner->GetSecurityOrigin());
+    policy_to_inherit = owner->GetContentSecurityPolicy();
   } else {
     cookie_url_ = url_;
     SetSecurityOrigin(SecurityOrigin::Create(url_));
@@ -5891,7 +5895,7 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {
     SetContentSecurityPolicy(
         ImportsController()->Master()->GetContentSecurityPolicy());
   } else {
-    InitContentSecurityPolicy();
+    InitContentSecurityPolicy(nullptr, policy_to_inherit);
   }
 
   if (GetSecurityOrigin()->HasSuborigin())
@@ -5926,7 +5930,13 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {
   SetFeaturePolicy(g_empty_string);
 }
 
-void Document::InitContentSecurityPolicy(ContentSecurityPolicy* csp) {
+// the first parameter specifies a policy to use as the document csp meaning
+// the document will take ownership of the policy
+// the second parameter specifies a policy to inherit meaning the document
+// will attempt to copy over the policy
+void Document::InitContentSecurityPolicy(
+    ContentSecurityPolicy* csp,
+    const ContentSecurityPolicy* policy_to_inherit) {
   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());
 
   // We inherit the parent/opener's CSP for documents with ""local"" schemes:
@@ -5938,24 +5948,27 @@ void Document::InitContentSecurityPolicy(ContentSecurityPolicy* csp) {
   //
   // TODO(dcheng): This is similar enough to work we're doing in
   // 'DocumentLoader::ensureWriter' that it might make sense to combine them.
-  if (frame_) {
+  if (policy_to_inherit) {
+    GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
+  } else if (frame_) {
     Frame* inherit_from = frame_->Tree().Parent() ? frame_->Tree().Parent()
                                                   : frame_->Client()->Opener();
     if (inherit_from && frame_ != inherit_from) {
       DCHECK(inherit_from->GetSecurityContext() &&
              inherit_from->GetSecurityContext()->GetContentSecurityPolicy());
-      ContentSecurityPolicy* policy_to_inherit =
+      policy_to_inherit =
           inherit_from->GetSecurityContext()->GetContentSecurityPolicy();
       if (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||
           url_.ProtocolIs(""blob"") || url_.ProtocolIs(""filesystem"")) {
         GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
       }
-      // Plugin documents inherit their parent/opener's 'plugin-types' directive
-      // regardless of URL.
-      if (IsPluginDocument())
-        GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);
     }
   }
+  // Plugin documents inherit their parent/opener's 'plugin-types' directive
+  // regardless of URL.
+  if (policy_to_inherit && IsPluginDocument())
+    GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);
+
   GetContentSecurityPolicy()->BindToExecutionContext(this);
 }
 ",Chrome,0ab2412a104d2f235d7b9fe19d30ef605a410832,fb6b7d43431f6a142d53150d14f441cbf1f3e461,1,"void Document::InitContentSecurityPolicy(ContentSecurityPolicy* csp) {
//fix_flaw_line_below:
//// the first parameter specifies a policy to use as the document csp meaning
//fix_flaw_line_below:
//// the document will take ownership of the policy
//fix_flaw_line_below:
//// the second parameter specifies a policy to inherit meaning the document
//fix_flaw_line_below:
//// will attempt to copy over the policy
//fix_flaw_line_below:
//void Document::InitContentSecurityPolicy(
//fix_flaw_line_below:
//    ContentSecurityPolicy* csp,
//fix_flaw_line_below:
//    const ContentSecurityPolicy* policy_to_inherit) {
   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());
 
   // We inherit the parent/opener's CSP for documents with ""local"" schemes:
  // 'about', 'blob', 'data', and 'filesystem'. We also inherit CSP for
  // documents with empty/invalid URLs because we treat those URLs as
  // 'about:blank' in Blink.
  //
  // https://w3c.github.io/webappsec-csp/#initialize-document-csp
   //
   // TODO(dcheng): This is similar enough to work we're doing in
   // 'DocumentLoader::ensureWriter' that it might make sense to combine them.
//flaw_line_below:
  if (frame_) {
//fix_flaw_line_below:
//  if (policy_to_inherit) {
//fix_flaw_line_below:
//    GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
//fix_flaw_line_below:
//  } else if (frame_) {
     Frame* inherit_from = frame_->Tree().Parent() ? frame_->Tree().Parent()
                                                   : frame_->Client()->Opener();
     if (inherit_from && frame_ != inherit_from) {
       DCHECK(inherit_from->GetSecurityContext() &&
              inherit_from->GetSecurityContext()->GetContentSecurityPolicy());
//flaw_line_below:
      ContentSecurityPolicy* policy_to_inherit =
//fix_flaw_line_below:
//      policy_to_inherit =
           inherit_from->GetSecurityContext()->GetContentSecurityPolicy();
       if (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||
           url_.ProtocolIs(""blob"") || url_.ProtocolIs(""filesystem"")) {
         GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
       }
//flaw_line_below:
      // Plugin documents inherit their parent/opener's 'plugin-types' directive
//flaw_line_below:
      // regardless of URL.
//flaw_line_below:
      if (IsPluginDocument())
//flaw_line_below:
        GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);
     }
   }
//fix_flaw_line_below:
//  // Plugin documents inherit their parent/opener's 'plugin-types' directive
//fix_flaw_line_below:
//  // regardless of URL.
//fix_flaw_line_below:
//  if (policy_to_inherit && IsPluginDocument())
//fix_flaw_line_below:
//    GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);
//fix_flaw_line_below:
//
   GetContentSecurityPolicy()->BindToExecutionContext(this);
 }
"
8532,186268,,Remote,Not required,,CVE-2017-5118,https://www.cvedetails.com/cve/CVE-2017-5118/,CWE-732,Medium,,Partial,,2017-10-27,4.3,"Blink in Google Chrome prior to 61.0.3163.79 for Mac, Windows, and Linux, and 61.0.3163.81 for Android, failed to correctly propagate CSP restrictions to javascript scheme pages, which allowed a remote attacker to bypass content security policy via a crafted HTML page.",2019-10-02,Bypass ,5,https://github.com/chromium/chromium/commit/0ab2412a104d2f235d7b9fe19d30ef605a410832,0ab2412a104d2f235d7b9fe19d30ef605a410832,"Inherit CSP when we inherit the security origin

This prevents attacks that use main window navigation to get out of the
existing csp constraints such as the related bug

Bug: 747847
Change-Id: I1e57b50da17f65d38088205b0a3c7c49ef2ae4d8
Reviewed-on: https://chromium-review.googlesource.com/592027
Reviewed-by: Mike West <mkwst@chromium.org>
Commit-Queue: Andy Paicu <andypaicu@chromium.org>
Cr-Commit-Position: refs/heads/master@{#492333}",1,third_party/WebKit/Source/core/dom/Document.cpp,"{""sha"": ""21c4fb33ce2d66db750d92a892e3871bd5d9b576"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/javascript-url-navigation-inherits-csp.html"", ""status"": ""added"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/javascript-url-navigation-inherits-csp.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/javascript-url-navigation-inherits-csp.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/javascript-url-navigation-inherits-csp.html?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -0,0 +1,16 @@\n+<!DOCTYPE html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+\n+<script>\n+  var window_url = encodeURIComponent(\""javascript:'<iframe src=/content-security-policy/support/fail.js />'\"");\n+  var report_cookie_name = encodeURIComponent(\""javascript-url-navigation-inherits-csp\"");\n+  window.open(\""support/test_csp_self_window.sub.html?window_url=\"" + window_url + \""&report_cookie_name=\"" + report_cookie_name);\n+  setTimeout(function() {\n+    var s = document.createElement('script');\n+    s.async = true;\n+    s.defer = true;\n+    s.src = \""../support/checkReport.sub.js?reportField=violated-directive&reportValue=frame-src%20%27none%27\"";\n+    document.body.appendChild(s);\n+  }, 2000);\n+</script>""}<_**next**_>{""sha"": ""ab0f8f82e3951a412824d066f670af17377dcec5"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html"", ""status"": ""added"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -0,0 +1,8 @@\n+<!DOCTYPE html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+\n+<script>\n+  var window_url = decodeURIComponent(\""{{GET[window_url]}}\"").replace('&lt;', '<').replace('&gt;', '>');\n+  window.open(window_url, \""_self\"");\n+</script>""}<_**next**_>{""sha"": ""dd418ec7648ba3f5603b0e070460ac171b8bc4d4"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html.sub.headers"", ""status"": ""added"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html.sub.headers"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html.sub.headers"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html.sub.headers?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -0,0 +1,6 @@\n+Expires: Mon, 26 Jul 1997 05:00:00 GMT\n+Cache-Control: no-store, no-cache, must-revalidate\n+Cache-Control: post-check=0, pre-check=0, false\n+Pragma: no-cache\n+Set-Cookie: {{GET[report_cookie_name]}}={{$id:uuid()}}; Path=/content-security-policy/navigation/\n+Content-Security-Policy: default-src 'none'; script-src 'self' 'unsafe-inline'; report-uri  ../../support/report.py?op=put&reportID={{$id}}""}<_**next**_>{""sha"": ""12245ff457031d6ccac563310d652a7fe83c88aa"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-in-iframe-expected.txt"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-in-iframe-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-in-iframe-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-in-iframe-expected.txt?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -1,5 +1,4 @@\n CONSOLE ERROR: The 'allow' directive has been replaced with 'default-src'. Please use that directive instead, as 'allow' has no effect.\n-CONSOLE ERROR: The 'allow' directive has been replaced with 'default-src'. Please use that directive instead, as 'allow' has no effect.\n Loads an iframe (a) which loads an iframe (b) which in turns tries to load an external script. The iframe (a) has a content security policy disabling external scripts. As this policy does not apply to (b), the script should be executed.\n \n ""}<_**next**_>{""sha"": ""c74e6c8893bb027a7928a49ca50a59062dc91319"", ""filename"": ""third_party/WebKit/Source/core/dom/Document.cpp"", ""status"": ""modified"", ""additions"": 21, ""deletions"": 8, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/dom/Document.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/dom/Document.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Document.cpp?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -5839,6 +5839,8 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {\n       AddInsecureNavigationUpgrade(to_upgrade);\n   }\n \n+  ContentSecurityPolicy* policy_to_inherit = nullptr;\n+\n   if (IsSandboxed(kSandboxOrigin)) {\n     cookie_url_ = url_;\n     SetSecurityOrigin(SecurityOrigin::CreateUnique());\n@@ -5854,12 +5856,14 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {\n         GetSecurityOrigin()->SetUniqueOriginIsPotentiallyTrustworthy(true);\n       if (owner->GetSecurityOrigin()->CanLoadLocalResources())\n         GetSecurityOrigin()->GrantLoadLocalResources();\n+      policy_to_inherit = owner->GetContentSecurityPolicy();\n     }\n   } else if (Document* owner = initializer.OwnerDocument()) {\n     cookie_url_ = owner->CookieURL();\n     // We alias the SecurityOrigins to match Firefox, see Bug 15313\n     // https://bugs.webkit.org/show_bug.cgi?id=15313\n     SetSecurityOrigin(owner->GetSecurityOrigin());\n+    policy_to_inherit = owner->GetContentSecurityPolicy();\n   } else {\n     cookie_url_ = url_;\n     SetSecurityOrigin(SecurityOrigin::Create(url_));\n@@ -5891,7 +5895,7 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {\n     SetContentSecurityPolicy(\n         ImportsController()->Master()->GetContentSecurityPolicy());\n   } else {\n-    InitContentSecurityPolicy();\n+    InitContentSecurityPolicy(nullptr, policy_to_inherit);\n   }\n \n   if (GetSecurityOrigin()->HasSuborigin())\n@@ -5926,7 +5930,13 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {\n   SetFeaturePolicy(g_empty_string);\n }\n \n-void Document::InitContentSecurityPolicy(ContentSecurityPolicy* csp) {\n+// the first parameter specifies a policy to use as the document csp meaning\n+// the document will take ownership of the policy\n+// the second parameter specifies a policy to inherit meaning the document\n+// will attempt to copy over the policy\n+void Document::InitContentSecurityPolicy(\n+    ContentSecurityPolicy* csp,\n+    const ContentSecurityPolicy* policy_to_inherit) {\n   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());\n \n   // We inherit the parent/opener's CSP for documents with \""local\"" schemes:\n@@ -5938,24 +5948,27 @@ void Document::InitContentSecurityPolicy(ContentSecurityPolicy* csp) {\n   //\n   // TODO(dcheng): This is similar enough to work we're doing in\n   // 'DocumentLoader::ensureWriter' that it might make sense to combine them.\n-  if (frame_) {\n+  if (policy_to_inherit) {\n+    GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\n+  } else if (frame_) {\n     Frame* inherit_from = frame_->Tree().Parent() ? frame_->Tree().Parent()\n                                                   : frame_->Client()->Opener();\n     if (inherit_from && frame_ != inherit_from) {\n       DCHECK(inherit_from->GetSecurityContext() &&\n              inherit_from->GetSecurityContext()->GetContentSecurityPolicy());\n-      ContentSecurityPolicy* policy_to_inherit =\n+      policy_to_inherit =\n           inherit_from->GetSecurityContext()->GetContentSecurityPolicy();\n       if (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||\n           url_.ProtocolIs(\""blob\"") || url_.ProtocolIs(\""filesystem\"")) {\n         GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\n       }\n-      // Plugin documents inherit their parent/opener's 'plugin-types' directive\n-      // regardless of URL.\n-      if (IsPluginDocument())\n-        GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);\n     }\n   }\n+  // Plugin documents inherit their parent/opener's 'plugin-types' directive\n+  // regardless of URL.\n+  if (policy_to_inherit && IsPluginDocument())\n+    GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);\n+\n   GetContentSecurityPolicy()->BindToExecutionContext(this);\n }\n ""}<_**next**_>{""sha"": ""0667c0c51ea98b13f4266c913e99c34dea484190"", ""filename"": ""third_party/WebKit/Source/core/dom/Document.h"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 1, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/dom/Document.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/dom/Document.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Document.h?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -1037,7 +1037,13 @@ class CORE_EXPORT Document : public ContainerNode,\n   const SVGDocumentExtensions* SvgExtensions();\n   SVGDocumentExtensions& AccessSVGExtensions();\n \n-  void InitContentSecurityPolicy(ContentSecurityPolicy* = nullptr);\n+  // the first parameter specifies a policy to use as the document csp meaning\n+  // the document will take ownership of the policy\n+  // the second parameter specifies a policy to inherit meaning the document\n+  // will attempt to copy over the policy\n+  void InitContentSecurityPolicy(\n+      ContentSecurityPolicy* = nullptr,\n+      const ContentSecurityPolicy* policy_to_inherit = nullptr);\n \n   bool IsSecureTransitionTo(const KURL&) const;\n ""}<_**next**_>{""sha"": ""bd46b9d507b12455c4beae30363baf11e9ef08ec"", ""filename"": ""third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -1818,7 +1818,6 @@ void WebLocalFrameImpl::SetInputEventsScaleForEmulation(\n \n void WebLocalFrameImpl::LoadJavaScriptURL(const KURL& url) {\n   DCHECK(GetFrame());\n-\n   // This is copied from ScriptController::executeScriptIfJavaScriptURL.\n   // Unfortunately, we cannot just use that method since it is private, and\n   // it also doesn't quite behave as we require it to for bookmarklets. The""}<_**next**_>{""sha"": ""a11d1147135855cfaec5c2f0da99aa2b9b233fa3"", ""filename"": ""third_party/WebKit/Source/core/loader/DocumentLoader.cpp"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 3, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/loader/DocumentLoader.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/loader/DocumentLoader.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/loader/DocumentLoader.cpp?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -898,9 +898,12 @@ void DocumentLoader::EndWriting() {\n   writer_.Clear();\n }\n \n-void DocumentLoader::DidInstallNewDocument(Document* document) {\n+void DocumentLoader::DidInstallNewDocument(Document* document,\n+                                           InstallNewDocumentReason reason) {\n   document->SetReadyState(Document::kLoading);\n-  document->InitContentSecurityPolicy(content_security_policy_.Release());\n+  if (content_security_policy_) {\n+    document->InitContentSecurityPolicy(content_security_policy_.Release());\n+  }\n \n   if (history_item_ && IsBackForwardLoadType(load_type_))\n     document->SetStateForNewFormElements(history_item_->GetDocumentState());\n@@ -1116,7 +1119,7 @@ void DocumentLoader::InstallNewDocument(\n   frame_->GetPage()->GetChromeClient().InstallSupplements(*frame_);\n   if (!overriding_url.IsEmpty())\n     document->SetBaseURLOverride(overriding_url);\n-  DidInstallNewDocument(document);\n+  DidInstallNewDocument(document, reason);\n \n   // This must be called before DocumentWriter is created, otherwise HTML parser\n   // will use stale values from HTMLParserOption.""}<_**next**_>{""sha"": ""e5f59fd0c5ce7e5ce4b5a052fc75e6ec845ad9f5"", ""filename"": ""third_party/WebKit/Source/core/loader/DocumentLoader.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/loader/DocumentLoader.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/loader/DocumentLoader.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/loader/DocumentLoader.h?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -244,7 +244,7 @@ class CORE_EXPORT DocumentLoader\n                           InstallNewDocumentReason,\n                           ParserSynchronizationPolicy,\n                           const KURL& overriding_url);\n-  void DidInstallNewDocument(Document*);\n+  void DidInstallNewDocument(Document*, InstallNewDocumentReason);\n   void WillCommitNavigation();\n   void DidCommitNavigation();\n ""}","void Document::InitSecurityContext(const DocumentInit& initializer) {
  DCHECK(!GetSecurityOrigin());

  if (!initializer.HasSecurityContext()) {
    cookie_url_ = KURL(kParsedURLString, g_empty_string);
    SetSecurityOrigin(SecurityOrigin::CreateUnique());
    InitContentSecurityPolicy();
    SetFeaturePolicy(g_empty_string);
    return;
  }

  EnforceSandboxFlags(initializer.GetSandboxFlags());
  SetInsecureRequestPolicy(initializer.GetInsecureRequestPolicy());
  if (initializer.InsecureNavigationsToUpgrade()) {
    for (auto to_upgrade : *initializer.InsecureNavigationsToUpgrade())
       AddInsecureNavigationUpgrade(to_upgrade);
   }
 
  ContentSecurityPolicy* policy_to_inherit = nullptr;

   if (IsSandboxed(kSandboxOrigin)) {
     cookie_url_ = url_;
     SetSecurityOrigin(SecurityOrigin::CreateUnique());
    Document* owner = initializer.OwnerDocument();
    if (owner) {
      if (owner->GetSecurityOrigin()->IsPotentiallyTrustworthy())
         GetSecurityOrigin()->SetUniqueOriginIsPotentiallyTrustworthy(true);
       if (owner->GetSecurityOrigin()->CanLoadLocalResources())
         GetSecurityOrigin()->GrantLoadLocalResources();
      policy_to_inherit = owner->GetContentSecurityPolicy();
     }
   } else if (Document* owner = initializer.OwnerDocument()) {
     cookie_url_ = owner->CookieURL();
     SetSecurityOrigin(owner->GetSecurityOrigin());
    policy_to_inherit = owner->GetContentSecurityPolicy();
   } else {
     cookie_url_ = url_;
     SetSecurityOrigin(SecurityOrigin::Create(url_));
  }

  if (initializer.IsHostedInReservedIPRange()) {
    SetAddressSpace(GetSecurityOrigin()->IsLocalhost()
                        ? kWebAddressSpaceLocal
                        : kWebAddressSpacePrivate);
  } else if (GetSecurityOrigin()->IsLocal()) {
    SetAddressSpace(kWebAddressSpaceLocal);
  } else {
    SetAddressSpace(kWebAddressSpacePublic);
  }

  if (ImportsController()) {
     SetContentSecurityPolicy(
         ImportsController()->Master()->GetContentSecurityPolicy());
   } else {
    InitContentSecurityPolicy(nullptr, policy_to_inherit);
   }
 
   if (GetSecurityOrigin()->HasSuborigin())
    EnforceSuborigin(*GetSecurityOrigin()->GetSuborigin());

  if (Settings* settings = initializer.GetSettings()) {
    if (!settings->GetWebSecurityEnabled()) {
      GetSecurityOrigin()->GrantUniversalAccess();
    } else if (GetSecurityOrigin()->IsLocal()) {
      if (settings->GetAllowUniversalAccessFromFileURLs()) {
        GetSecurityOrigin()->GrantUniversalAccess();
      } else if (!settings->GetAllowFileAccessFromFileURLs()) {
        GetSecurityOrigin()->BlockLocalAccessFromLocalOrigin();
      }
    }
  }

  if (GetSecurityOrigin()->IsUnique() &&
      SecurityOrigin::Create(url_)->IsPotentiallyTrustworthy())
    GetSecurityOrigin()->SetUniqueOriginIsPotentiallyTrustworthy(true);

  if (GetSecurityOrigin()->HasSuborigin())
    EnforceSuborigin(*GetSecurityOrigin()->GetSuborigin());

   SetFeaturePolicy(g_empty_string);
 }
","void Document::InitSecurityContext(const DocumentInit& initializer) {
  DCHECK(!GetSecurityOrigin());

  if (!initializer.HasSecurityContext()) {
    cookie_url_ = KURL(kParsedURLString, g_empty_string);
    SetSecurityOrigin(SecurityOrigin::CreateUnique());
    InitContentSecurityPolicy();
    SetFeaturePolicy(g_empty_string);
    return;
  }

  EnforceSandboxFlags(initializer.GetSandboxFlags());
  SetInsecureRequestPolicy(initializer.GetInsecureRequestPolicy());
  if (initializer.InsecureNavigationsToUpgrade()) {
    for (auto to_upgrade : *initializer.InsecureNavigationsToUpgrade())
       AddInsecureNavigationUpgrade(to_upgrade);
   }
 
   if (IsSandboxed(kSandboxOrigin)) {
     cookie_url_ = url_;
     SetSecurityOrigin(SecurityOrigin::CreateUnique());
    Document* owner = initializer.OwnerDocument();
    if (owner) {
      if (owner->GetSecurityOrigin()->IsPotentiallyTrustworthy())
         GetSecurityOrigin()->SetUniqueOriginIsPotentiallyTrustworthy(true);
       if (owner->GetSecurityOrigin()->CanLoadLocalResources())
         GetSecurityOrigin()->GrantLoadLocalResources();
     }
   } else if (Document* owner = initializer.OwnerDocument()) {
     cookie_url_ = owner->CookieURL();
     SetSecurityOrigin(owner->GetSecurityOrigin());
   } else {
     cookie_url_ = url_;
     SetSecurityOrigin(SecurityOrigin::Create(url_));
  }

  if (initializer.IsHostedInReservedIPRange()) {
    SetAddressSpace(GetSecurityOrigin()->IsLocalhost()
                        ? kWebAddressSpaceLocal
                        : kWebAddressSpacePrivate);
  } else if (GetSecurityOrigin()->IsLocal()) {
    SetAddressSpace(kWebAddressSpaceLocal);
  } else {
    SetAddressSpace(kWebAddressSpacePublic);
  }

  if (ImportsController()) {
     SetContentSecurityPolicy(
         ImportsController()->Master()->GetContentSecurityPolicy());
   } else {
    InitContentSecurityPolicy();
   }
 
   if (GetSecurityOrigin()->HasSuborigin())
    EnforceSuborigin(*GetSecurityOrigin()->GetSuborigin());

  if (Settings* settings = initializer.GetSettings()) {
    if (!settings->GetWebSecurityEnabled()) {
      GetSecurityOrigin()->GrantUniversalAccess();
    } else if (GetSecurityOrigin()->IsLocal()) {
      if (settings->GetAllowUniversalAccessFromFileURLs()) {
        GetSecurityOrigin()->GrantUniversalAccess();
      } else if (!settings->GetAllowFileAccessFromFileURLs()) {
        GetSecurityOrigin()->BlockLocalAccessFromLocalOrigin();
      }
    }
  }

  if (GetSecurityOrigin()->IsUnique() &&
      SecurityOrigin::Create(url_)->IsPotentiallyTrustworthy())
    GetSecurityOrigin()->SetUniqueOriginIsPotentiallyTrustworthy(true);

  if (GetSecurityOrigin()->HasSuborigin())
    EnforceSuborigin(*GetSecurityOrigin()->GetSuborigin());

   SetFeaturePolicy(g_empty_string);
 }
",C,"  ContentSecurityPolicy* policy_to_inherit = nullptr;

      policy_to_inherit = owner->GetContentSecurityPolicy();
    policy_to_inherit = owner->GetContentSecurityPolicy();
    InitContentSecurityPolicy(nullptr, policy_to_inherit);
","    InitContentSecurityPolicy();
",,"@@ -5839,6 +5839,8 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {
       AddInsecureNavigationUpgrade(to_upgrade);
   }
 
+  ContentSecurityPolicy* policy_to_inherit = nullptr;
+
   if (IsSandboxed(kSandboxOrigin)) {
     cookie_url_ = url_;
     SetSecurityOrigin(SecurityOrigin::CreateUnique());
@@ -5854,12 +5856,14 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {
         GetSecurityOrigin()->SetUniqueOriginIsPotentiallyTrustworthy(true);
       if (owner->GetSecurityOrigin()->CanLoadLocalResources())
         GetSecurityOrigin()->GrantLoadLocalResources();
+      policy_to_inherit = owner->GetContentSecurityPolicy();
     }
   } else if (Document* owner = initializer.OwnerDocument()) {
     cookie_url_ = owner->CookieURL();
     // We alias the SecurityOrigins to match Firefox, see Bug 15313
     // https://bugs.webkit.org/show_bug.cgi?id=15313
     SetSecurityOrigin(owner->GetSecurityOrigin());
+    policy_to_inherit = owner->GetContentSecurityPolicy();
   } else {
     cookie_url_ = url_;
     SetSecurityOrigin(SecurityOrigin::Create(url_));
@@ -5891,7 +5895,7 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {
     SetContentSecurityPolicy(
         ImportsController()->Master()->GetContentSecurityPolicy());
   } else {
-    InitContentSecurityPolicy();
+    InitContentSecurityPolicy(nullptr, policy_to_inherit);
   }
 
   if (GetSecurityOrigin()->HasSuborigin())
@@ -5926,7 +5930,13 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {
   SetFeaturePolicy(g_empty_string);
 }
 
-void Document::InitContentSecurityPolicy(ContentSecurityPolicy* csp) {
+// the first parameter specifies a policy to use as the document csp meaning
+// the document will take ownership of the policy
+// the second parameter specifies a policy to inherit meaning the document
+// will attempt to copy over the policy
+void Document::InitContentSecurityPolicy(
+    ContentSecurityPolicy* csp,
+    const ContentSecurityPolicy* policy_to_inherit) {
   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());
 
   // We inherit the parent/opener's CSP for documents with ""local"" schemes:
@@ -5938,24 +5948,27 @@ void Document::InitContentSecurityPolicy(ContentSecurityPolicy* csp) {
   //
   // TODO(dcheng): This is similar enough to work we're doing in
   // 'DocumentLoader::ensureWriter' that it might make sense to combine them.
-  if (frame_) {
+  if (policy_to_inherit) {
+    GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
+  } else if (frame_) {
     Frame* inherit_from = frame_->Tree().Parent() ? frame_->Tree().Parent()
                                                   : frame_->Client()->Opener();
     if (inherit_from && frame_ != inherit_from) {
       DCHECK(inherit_from->GetSecurityContext() &&
              inherit_from->GetSecurityContext()->GetContentSecurityPolicy());
-      ContentSecurityPolicy* policy_to_inherit =
+      policy_to_inherit =
           inherit_from->GetSecurityContext()->GetContentSecurityPolicy();
       if (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||
           url_.ProtocolIs(""blob"") || url_.ProtocolIs(""filesystem"")) {
         GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
       }
-      // Plugin documents inherit their parent/opener's 'plugin-types' directive
-      // regardless of URL.
-      if (IsPluginDocument())
-        GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);
     }
   }
+  // Plugin documents inherit their parent/opener's 'plugin-types' directive
+  // regardless of URL.
+  if (policy_to_inherit && IsPluginDocument())
+    GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);
+
   GetContentSecurityPolicy()->BindToExecutionContext(this);
 }
 ",Chrome,0ab2412a104d2f235d7b9fe19d30ef605a410832,fb6b7d43431f6a142d53150d14f441cbf1f3e461,1,"void Document::InitSecurityContext(const DocumentInit& initializer) {
  DCHECK(!GetSecurityOrigin());

  if (!initializer.HasSecurityContext()) {
    // No source for a security context.
    // This can occur via document.implementation.createDocument().
    cookie_url_ = KURL(kParsedURLString, g_empty_string);
    SetSecurityOrigin(SecurityOrigin::CreateUnique());
    InitContentSecurityPolicy();
    SetFeaturePolicy(g_empty_string);
    // Unique security origins cannot have a suborigin
    return;
  }

  // In the common case, create the security context from the currently
  // loading URL with a fresh content security policy.
  EnforceSandboxFlags(initializer.GetSandboxFlags());
  SetInsecureRequestPolicy(initializer.GetInsecureRequestPolicy());
  if (initializer.InsecureNavigationsToUpgrade()) {
    for (auto to_upgrade : *initializer.InsecureNavigationsToUpgrade())
       AddInsecureNavigationUpgrade(to_upgrade);
   }
 
//fix_flaw_line_below:
//  ContentSecurityPolicy* policy_to_inherit = nullptr;
//fix_flaw_line_below:
//
   if (IsSandboxed(kSandboxOrigin)) {
     cookie_url_ = url_;
     SetSecurityOrigin(SecurityOrigin::CreateUnique());
    // If we're supposed to inherit our security origin from our
    // owner, but we're also sandboxed, the only things we inherit are
    // the origin's potential trustworthiness and the ability to
    // load local resources. The latter lets about:blank iframes in
    // file:// URL documents load images and other resources from
    // the file system.
    Document* owner = initializer.OwnerDocument();
    if (owner) {
      if (owner->GetSecurityOrigin()->IsPotentiallyTrustworthy())
         GetSecurityOrigin()->SetUniqueOriginIsPotentiallyTrustworthy(true);
       if (owner->GetSecurityOrigin()->CanLoadLocalResources())
         GetSecurityOrigin()->GrantLoadLocalResources();
//fix_flaw_line_below:
//      policy_to_inherit = owner->GetContentSecurityPolicy();
     }
   } else if (Document* owner = initializer.OwnerDocument()) {
     cookie_url_ = owner->CookieURL();
     // We alias the SecurityOrigins to match Firefox, see Bug 15313
     // https://bugs.webkit.org/show_bug.cgi?id=15313
     SetSecurityOrigin(owner->GetSecurityOrigin());
//fix_flaw_line_below:
//    policy_to_inherit = owner->GetContentSecurityPolicy();
   } else {
     cookie_url_ = url_;
     SetSecurityOrigin(SecurityOrigin::Create(url_));
  }

  // Set the address space before setting up CSP, as the latter may override
  // the former via the 'treat-as-public-address' directive (see
  // https://wicg.github.io/cors-rfc1918/#csp).
  if (initializer.IsHostedInReservedIPRange()) {
    SetAddressSpace(GetSecurityOrigin()->IsLocalhost()
                        ? kWebAddressSpaceLocal
                        : kWebAddressSpacePrivate);
  } else if (GetSecurityOrigin()->IsLocal()) {
    // ""Local"" security origins (like 'file://...') are treated as having
    // a local address space.
    //
    // TODO(mkwst): It's not entirely clear that this is a good idea.
    SetAddressSpace(kWebAddressSpaceLocal);
  } else {
    SetAddressSpace(kWebAddressSpacePublic);
  }

  if (ImportsController()) {
    // If this document is an HTML import, grab a reference to it's master
    // document's Content Security Policy. We don't call
    // 'initContentSecurityPolicy' in this case, as we can't rebind the master
    // document's policy object: its ExecutionContext needs to remain tied to
    // the master document.
     SetContentSecurityPolicy(
         ImportsController()->Master()->GetContentSecurityPolicy());
   } else {
//flaw_line_below:
    InitContentSecurityPolicy();
//fix_flaw_line_below:
//    InitContentSecurityPolicy(nullptr, policy_to_inherit);
   }
 
   if (GetSecurityOrigin()->HasSuborigin())
    EnforceSuborigin(*GetSecurityOrigin()->GetSuborigin());

  if (Settings* settings = initializer.GetSettings()) {
    if (!settings->GetWebSecurityEnabled()) {
      // Web security is turned off. We should let this document access every
      // other document. This is used primary by testing harnesses for web
      // sites.
      GetSecurityOrigin()->GrantUniversalAccess();
    } else if (GetSecurityOrigin()->IsLocal()) {
      if (settings->GetAllowUniversalAccessFromFileURLs()) {
        // Some clients want local URLs to have universal access, but that
        // setting is dangerous for other clients.
        GetSecurityOrigin()->GrantUniversalAccess();
      } else if (!settings->GetAllowFileAccessFromFileURLs()) {
        // Some clients do not want local URLs to have access to other local
        // URLs.
        GetSecurityOrigin()->BlockLocalAccessFromLocalOrigin();
      }
    }
  }

  if (GetSecurityOrigin()->IsUnique() &&
      SecurityOrigin::Create(url_)->IsPotentiallyTrustworthy())
    GetSecurityOrigin()->SetUniqueOriginIsPotentiallyTrustworthy(true);

  if (GetSecurityOrigin()->HasSuborigin())
    EnforceSuborigin(*GetSecurityOrigin()->GetSuborigin());

   SetFeaturePolicy(g_empty_string);
 }
"
8533,186269,,Remote,Not required,,CVE-2017-5118,https://www.cvedetails.com/cve/CVE-2017-5118/,CWE-732,Medium,,Partial,,2017-10-27,4.3,"Blink in Google Chrome prior to 61.0.3163.79 for Mac, Windows, and Linux, and 61.0.3163.81 for Android, failed to correctly propagate CSP restrictions to javascript scheme pages, which allowed a remote attacker to bypass content security policy via a crafted HTML page.",2019-10-02,Bypass ,0,https://github.com/chromium/chromium/commit/0ab2412a104d2f235d7b9fe19d30ef605a410832,0ab2412a104d2f235d7b9fe19d30ef605a410832,"Inherit CSP when we inherit the security origin

This prevents attacks that use main window navigation to get out of the
existing csp constraints such as the related bug

Bug: 747847
Change-Id: I1e57b50da17f65d38088205b0a3c7c49ef2ae4d8
Reviewed-on: https://chromium-review.googlesource.com/592027
Reviewed-by: Mike West <mkwst@chromium.org>
Commit-Queue: Andy Paicu <andypaicu@chromium.org>
Cr-Commit-Position: refs/heads/master@{#492333}",0,third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp,"{""sha"": ""21c4fb33ce2d66db750d92a892e3871bd5d9b576"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/javascript-url-navigation-inherits-csp.html"", ""status"": ""added"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/javascript-url-navigation-inherits-csp.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/javascript-url-navigation-inherits-csp.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/javascript-url-navigation-inherits-csp.html?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -0,0 +1,16 @@\n+<!DOCTYPE html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+\n+<script>\n+  var window_url = encodeURIComponent(\""javascript:'<iframe src=/content-security-policy/support/fail.js />'\"");\n+  var report_cookie_name = encodeURIComponent(\""javascript-url-navigation-inherits-csp\"");\n+  window.open(\""support/test_csp_self_window.sub.html?window_url=\"" + window_url + \""&report_cookie_name=\"" + report_cookie_name);\n+  setTimeout(function() {\n+    var s = document.createElement('script');\n+    s.async = true;\n+    s.defer = true;\n+    s.src = \""../support/checkReport.sub.js?reportField=violated-directive&reportValue=frame-src%20%27none%27\"";\n+    document.body.appendChild(s);\n+  }, 2000);\n+</script>""}<_**next**_>{""sha"": ""ab0f8f82e3951a412824d066f670af17377dcec5"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html"", ""status"": ""added"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -0,0 +1,8 @@\n+<!DOCTYPE html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+\n+<script>\n+  var window_url = decodeURIComponent(\""{{GET[window_url]}}\"").replace('&lt;', '<').replace('&gt;', '>');\n+  window.open(window_url, \""_self\"");\n+</script>""}<_**next**_>{""sha"": ""dd418ec7648ba3f5603b0e070460ac171b8bc4d4"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html.sub.headers"", ""status"": ""added"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html.sub.headers"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html.sub.headers"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html.sub.headers?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -0,0 +1,6 @@\n+Expires: Mon, 26 Jul 1997 05:00:00 GMT\n+Cache-Control: no-store, no-cache, must-revalidate\n+Cache-Control: post-check=0, pre-check=0, false\n+Pragma: no-cache\n+Set-Cookie: {{GET[report_cookie_name]}}={{$id:uuid()}}; Path=/content-security-policy/navigation/\n+Content-Security-Policy: default-src 'none'; script-src 'self' 'unsafe-inline'; report-uri  ../../support/report.py?op=put&reportID={{$id}}""}<_**next**_>{""sha"": ""12245ff457031d6ccac563310d652a7fe83c88aa"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-in-iframe-expected.txt"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-in-iframe-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-in-iframe-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-in-iframe-expected.txt?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -1,5 +1,4 @@\n CONSOLE ERROR: The 'allow' directive has been replaced with 'default-src'. Please use that directive instead, as 'allow' has no effect.\n-CONSOLE ERROR: The 'allow' directive has been replaced with 'default-src'. Please use that directive instead, as 'allow' has no effect.\n Loads an iframe (a) which loads an iframe (b) which in turns tries to load an external script. The iframe (a) has a content security policy disabling external scripts. As this policy does not apply to (b), the script should be executed.\n \n ""}<_**next**_>{""sha"": ""c74e6c8893bb027a7928a49ca50a59062dc91319"", ""filename"": ""third_party/WebKit/Source/core/dom/Document.cpp"", ""status"": ""modified"", ""additions"": 21, ""deletions"": 8, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/dom/Document.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/dom/Document.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Document.cpp?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -5839,6 +5839,8 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {\n       AddInsecureNavigationUpgrade(to_upgrade);\n   }\n \n+  ContentSecurityPolicy* policy_to_inherit = nullptr;\n+\n   if (IsSandboxed(kSandboxOrigin)) {\n     cookie_url_ = url_;\n     SetSecurityOrigin(SecurityOrigin::CreateUnique());\n@@ -5854,12 +5856,14 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {\n         GetSecurityOrigin()->SetUniqueOriginIsPotentiallyTrustworthy(true);\n       if (owner->GetSecurityOrigin()->CanLoadLocalResources())\n         GetSecurityOrigin()->GrantLoadLocalResources();\n+      policy_to_inherit = owner->GetContentSecurityPolicy();\n     }\n   } else if (Document* owner = initializer.OwnerDocument()) {\n     cookie_url_ = owner->CookieURL();\n     // We alias the SecurityOrigins to match Firefox, see Bug 15313\n     // https://bugs.webkit.org/show_bug.cgi?id=15313\n     SetSecurityOrigin(owner->GetSecurityOrigin());\n+    policy_to_inherit = owner->GetContentSecurityPolicy();\n   } else {\n     cookie_url_ = url_;\n     SetSecurityOrigin(SecurityOrigin::Create(url_));\n@@ -5891,7 +5895,7 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {\n     SetContentSecurityPolicy(\n         ImportsController()->Master()->GetContentSecurityPolicy());\n   } else {\n-    InitContentSecurityPolicy();\n+    InitContentSecurityPolicy(nullptr, policy_to_inherit);\n   }\n \n   if (GetSecurityOrigin()->HasSuborigin())\n@@ -5926,7 +5930,13 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {\n   SetFeaturePolicy(g_empty_string);\n }\n \n-void Document::InitContentSecurityPolicy(ContentSecurityPolicy* csp) {\n+// the first parameter specifies a policy to use as the document csp meaning\n+// the document will take ownership of the policy\n+// the second parameter specifies a policy to inherit meaning the document\n+// will attempt to copy over the policy\n+void Document::InitContentSecurityPolicy(\n+    ContentSecurityPolicy* csp,\n+    const ContentSecurityPolicy* policy_to_inherit) {\n   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());\n \n   // We inherit the parent/opener's CSP for documents with \""local\"" schemes:\n@@ -5938,24 +5948,27 @@ void Document::InitContentSecurityPolicy(ContentSecurityPolicy* csp) {\n   //\n   // TODO(dcheng): This is similar enough to work we're doing in\n   // 'DocumentLoader::ensureWriter' that it might make sense to combine them.\n-  if (frame_) {\n+  if (policy_to_inherit) {\n+    GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\n+  } else if (frame_) {\n     Frame* inherit_from = frame_->Tree().Parent() ? frame_->Tree().Parent()\n                                                   : frame_->Client()->Opener();\n     if (inherit_from && frame_ != inherit_from) {\n       DCHECK(inherit_from->GetSecurityContext() &&\n              inherit_from->GetSecurityContext()->GetContentSecurityPolicy());\n-      ContentSecurityPolicy* policy_to_inherit =\n+      policy_to_inherit =\n           inherit_from->GetSecurityContext()->GetContentSecurityPolicy();\n       if (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||\n           url_.ProtocolIs(\""blob\"") || url_.ProtocolIs(\""filesystem\"")) {\n         GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\n       }\n-      // Plugin documents inherit their parent/opener's 'plugin-types' directive\n-      // regardless of URL.\n-      if (IsPluginDocument())\n-        GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);\n     }\n   }\n+  // Plugin documents inherit their parent/opener's 'plugin-types' directive\n+  // regardless of URL.\n+  if (policy_to_inherit && IsPluginDocument())\n+    GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);\n+\n   GetContentSecurityPolicy()->BindToExecutionContext(this);\n }\n ""}<_**next**_>{""sha"": ""0667c0c51ea98b13f4266c913e99c34dea484190"", ""filename"": ""third_party/WebKit/Source/core/dom/Document.h"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 1, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/dom/Document.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/dom/Document.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Document.h?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -1037,7 +1037,13 @@ class CORE_EXPORT Document : public ContainerNode,\n   const SVGDocumentExtensions* SvgExtensions();\n   SVGDocumentExtensions& AccessSVGExtensions();\n \n-  void InitContentSecurityPolicy(ContentSecurityPolicy* = nullptr);\n+  // the first parameter specifies a policy to use as the document csp meaning\n+  // the document will take ownership of the policy\n+  // the second parameter specifies a policy to inherit meaning the document\n+  // will attempt to copy over the policy\n+  void InitContentSecurityPolicy(\n+      ContentSecurityPolicy* = nullptr,\n+      const ContentSecurityPolicy* policy_to_inherit = nullptr);\n \n   bool IsSecureTransitionTo(const KURL&) const;\n ""}<_**next**_>{""sha"": ""bd46b9d507b12455c4beae30363baf11e9ef08ec"", ""filename"": ""third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -1818,7 +1818,6 @@ void WebLocalFrameImpl::SetInputEventsScaleForEmulation(\n \n void WebLocalFrameImpl::LoadJavaScriptURL(const KURL& url) {\n   DCHECK(GetFrame());\n-\n   // This is copied from ScriptController::executeScriptIfJavaScriptURL.\n   // Unfortunately, we cannot just use that method since it is private, and\n   // it also doesn't quite behave as we require it to for bookmarklets. The""}<_**next**_>{""sha"": ""a11d1147135855cfaec5c2f0da99aa2b9b233fa3"", ""filename"": ""third_party/WebKit/Source/core/loader/DocumentLoader.cpp"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 3, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/loader/DocumentLoader.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/loader/DocumentLoader.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/loader/DocumentLoader.cpp?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -898,9 +898,12 @@ void DocumentLoader::EndWriting() {\n   writer_.Clear();\n }\n \n-void DocumentLoader::DidInstallNewDocument(Document* document) {\n+void DocumentLoader::DidInstallNewDocument(Document* document,\n+                                           InstallNewDocumentReason reason) {\n   document->SetReadyState(Document::kLoading);\n-  document->InitContentSecurityPolicy(content_security_policy_.Release());\n+  if (content_security_policy_) {\n+    document->InitContentSecurityPolicy(content_security_policy_.Release());\n+  }\n \n   if (history_item_ && IsBackForwardLoadType(load_type_))\n     document->SetStateForNewFormElements(history_item_->GetDocumentState());\n@@ -1116,7 +1119,7 @@ void DocumentLoader::InstallNewDocument(\n   frame_->GetPage()->GetChromeClient().InstallSupplements(*frame_);\n   if (!overriding_url.IsEmpty())\n     document->SetBaseURLOverride(overriding_url);\n-  DidInstallNewDocument(document);\n+  DidInstallNewDocument(document, reason);\n \n   // This must be called before DocumentWriter is created, otherwise HTML parser\n   // will use stale values from HTMLParserOption.""}<_**next**_>{""sha"": ""e5f59fd0c5ce7e5ce4b5a052fc75e6ec845ad9f5"", ""filename"": ""third_party/WebKit/Source/core/loader/DocumentLoader.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/loader/DocumentLoader.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/loader/DocumentLoader.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/loader/DocumentLoader.h?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -244,7 +244,7 @@ class CORE_EXPORT DocumentLoader\n                           InstallNewDocumentReason,\n                           ParserSynchronizationPolicy,\n                           const KURL& overriding_url);\n-  void DidInstallNewDocument(Document*);\n+  void DidInstallNewDocument(Document*, InstallNewDocumentReason);\n   void WillCommitNavigation();\n   void DidCommitNavigation();\n ""}"," void WebLocalFrameImpl::LoadJavaScriptURL(const KURL& url) {
   DCHECK(GetFrame());

  Document* owner_document = GetFrame()->GetDocument();

  if (!owner_document || !GetFrame()->GetPage())
    return;

  if (SchemeRegistry::ShouldTreatURLSchemeAsNotAllowingJavascriptURLs(
          owner_document->Url().Protocol()))
    return;

  String script = DecodeURLEscapeSequences(
      url.GetString().Substring(strlen(""javascript:"")));
  UserGestureIndicator gesture_indicator(
      UserGestureToken::Create(owner_document, UserGestureToken::kNewGesture));
  v8::HandleScope handle_scope(ToIsolate(GetFrame()));
  v8::Local<v8::Value> result =
      GetFrame()->GetScriptController().ExecuteScriptInMainWorldAndReturnValue(
          ScriptSourceCode(script));
  if (result.IsEmpty() || !result->IsString())
    return;
  String script_result = ToCoreString(v8::Local<v8::String>::Cast(result));
  if (!GetFrame()->GetNavigationScheduler().LocationChangePending()) {
    GetFrame()->Loader().ReplaceDocumentWhileExecutingJavaScriptURL(
        script_result, owner_document);
  }
}
"," void WebLocalFrameImpl::LoadJavaScriptURL(const KURL& url) {
   DCHECK(GetFrame());

  Document* owner_document = GetFrame()->GetDocument();

  if (!owner_document || !GetFrame()->GetPage())
    return;

  if (SchemeRegistry::ShouldTreatURLSchemeAsNotAllowingJavascriptURLs(
          owner_document->Url().Protocol()))
    return;

  String script = DecodeURLEscapeSequences(
      url.GetString().Substring(strlen(""javascript:"")));
  UserGestureIndicator gesture_indicator(
      UserGestureToken::Create(owner_document, UserGestureToken::kNewGesture));
  v8::HandleScope handle_scope(ToIsolate(GetFrame()));
  v8::Local<v8::Value> result =
      GetFrame()->GetScriptController().ExecuteScriptInMainWorldAndReturnValue(
          ScriptSourceCode(script));
  if (result.IsEmpty() || !result->IsString())
    return;
  String script_result = ToCoreString(v8::Local<v8::String>::Cast(result));
  if (!GetFrame()->GetNavigationScheduler().LocationChangePending()) {
    GetFrame()->Loader().ReplaceDocumentWhileExecutingJavaScriptURL(
        script_result, owner_document);
  }
}
",C,,,,"@@ -1818,7 +1818,6 @@ void WebLocalFrameImpl::SetInputEventsScaleForEmulation(
 
 void WebLocalFrameImpl::LoadJavaScriptURL(const KURL& url) {
   DCHECK(GetFrame());
-
   // This is copied from ScriptController::executeScriptIfJavaScriptURL.
   // Unfortunately, we cannot just use that method since it is private, and
   // it also doesn't quite behave as we require it to for bookmarklets. The",Chrome,0ab2412a104d2f235d7b9fe19d30ef605a410832,fb6b7d43431f6a142d53150d14f441cbf1f3e461,1," void WebLocalFrameImpl::LoadJavaScriptURL(const KURL& url) {
   DCHECK(GetFrame());
//flaw_line_below:

   // This is copied from ScriptController::executeScriptIfJavaScriptURL.
   // Unfortunately, we cannot just use that method since it is private, and
   // it also doesn't quite behave as we require it to for bookmarklets. The
  // key difference is that we need to suppress loading the string result
  // from evaluating the JS URL if executing the JS URL resulted in a
  // location change. We also allow a JS URL to be loaded even if scripts on
  // the page are otherwise disabled.

  Document* owner_document = GetFrame()->GetDocument();

  if (!owner_document || !GetFrame()->GetPage())
    return;

  // Protect privileged pages against bookmarklets and other javascript
  // manipulations.
  if (SchemeRegistry::ShouldTreatURLSchemeAsNotAllowingJavascriptURLs(
          owner_document->Url().Protocol()))
    return;

  String script = DecodeURLEscapeSequences(
      url.GetString().Substring(strlen(""javascript:"")));
  UserGestureIndicator gesture_indicator(
      UserGestureToken::Create(owner_document, UserGestureToken::kNewGesture));
  v8::HandleScope handle_scope(ToIsolate(GetFrame()));
  v8::Local<v8::Value> result =
      GetFrame()->GetScriptController().ExecuteScriptInMainWorldAndReturnValue(
          ScriptSourceCode(script));
  if (result.IsEmpty() || !result->IsString())
    return;
  String script_result = ToCoreString(v8::Local<v8::String>::Cast(result));
  if (!GetFrame()->GetNavigationScheduler().LocationChangePending()) {
    GetFrame()->Loader().ReplaceDocumentWhileExecutingJavaScriptURL(
        script_result, owner_document);
  }
}
"
8534,186270,,Remote,Not required,,CVE-2017-5118,https://www.cvedetails.com/cve/CVE-2017-5118/,CWE-732,Medium,,Partial,,2017-10-27,4.3,"Blink in Google Chrome prior to 61.0.3163.79 for Mac, Windows, and Linux, and 61.0.3163.81 for Android, failed to correctly propagate CSP restrictions to javascript scheme pages, which allowed a remote attacker to bypass content security policy via a crafted HTML page.",2019-10-02,Bypass ,5,https://github.com/chromium/chromium/commit/0ab2412a104d2f235d7b9fe19d30ef605a410832,0ab2412a104d2f235d7b9fe19d30ef605a410832,"Inherit CSP when we inherit the security origin

This prevents attacks that use main window navigation to get out of the
existing csp constraints such as the related bug

Bug: 747847
Change-Id: I1e57b50da17f65d38088205b0a3c7c49ef2ae4d8
Reviewed-on: https://chromium-review.googlesource.com/592027
Reviewed-by: Mike West <mkwst@chromium.org>
Commit-Queue: Andy Paicu <andypaicu@chromium.org>
Cr-Commit-Position: refs/heads/master@{#492333}",1,third_party/WebKit/Source/core/loader/DocumentLoader.cpp,"{""sha"": ""21c4fb33ce2d66db750d92a892e3871bd5d9b576"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/javascript-url-navigation-inherits-csp.html"", ""status"": ""added"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/javascript-url-navigation-inherits-csp.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/javascript-url-navigation-inherits-csp.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/javascript-url-navigation-inherits-csp.html?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -0,0 +1,16 @@\n+<!DOCTYPE html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+\n+<script>\n+  var window_url = encodeURIComponent(\""javascript:'<iframe src=/content-security-policy/support/fail.js />'\"");\n+  var report_cookie_name = encodeURIComponent(\""javascript-url-navigation-inherits-csp\"");\n+  window.open(\""support/test_csp_self_window.sub.html?window_url=\"" + window_url + \""&report_cookie_name=\"" + report_cookie_name);\n+  setTimeout(function() {\n+    var s = document.createElement('script');\n+    s.async = true;\n+    s.defer = true;\n+    s.src = \""../support/checkReport.sub.js?reportField=violated-directive&reportValue=frame-src%20%27none%27\"";\n+    document.body.appendChild(s);\n+  }, 2000);\n+</script>""}<_**next**_>{""sha"": ""ab0f8f82e3951a412824d066f670af17377dcec5"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html"", ""status"": ""added"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -0,0 +1,8 @@\n+<!DOCTYPE html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+\n+<script>\n+  var window_url = decodeURIComponent(\""{{GET[window_url]}}\"").replace('&lt;', '<').replace('&gt;', '>');\n+  window.open(window_url, \""_self\"");\n+</script>""}<_**next**_>{""sha"": ""dd418ec7648ba3f5603b0e070460ac171b8bc4d4"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html.sub.headers"", ""status"": ""added"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html.sub.headers"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html.sub.headers"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html.sub.headers?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -0,0 +1,6 @@\n+Expires: Mon, 26 Jul 1997 05:00:00 GMT\n+Cache-Control: no-store, no-cache, must-revalidate\n+Cache-Control: post-check=0, pre-check=0, false\n+Pragma: no-cache\n+Set-Cookie: {{GET[report_cookie_name]}}={{$id:uuid()}}; Path=/content-security-policy/navigation/\n+Content-Security-Policy: default-src 'none'; script-src 'self' 'unsafe-inline'; report-uri  ../../support/report.py?op=put&reportID={{$id}}""}<_**next**_>{""sha"": ""12245ff457031d6ccac563310d652a7fe83c88aa"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-in-iframe-expected.txt"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-in-iframe-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-in-iframe-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-in-iframe-expected.txt?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -1,5 +1,4 @@\n CONSOLE ERROR: The 'allow' directive has been replaced with 'default-src'. Please use that directive instead, as 'allow' has no effect.\n-CONSOLE ERROR: The 'allow' directive has been replaced with 'default-src'. Please use that directive instead, as 'allow' has no effect.\n Loads an iframe (a) which loads an iframe (b) which in turns tries to load an external script. The iframe (a) has a content security policy disabling external scripts. As this policy does not apply to (b), the script should be executed.\n \n ""}<_**next**_>{""sha"": ""c74e6c8893bb027a7928a49ca50a59062dc91319"", ""filename"": ""third_party/WebKit/Source/core/dom/Document.cpp"", ""status"": ""modified"", ""additions"": 21, ""deletions"": 8, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/dom/Document.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/dom/Document.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Document.cpp?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -5839,6 +5839,8 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {\n       AddInsecureNavigationUpgrade(to_upgrade);\n   }\n \n+  ContentSecurityPolicy* policy_to_inherit = nullptr;\n+\n   if (IsSandboxed(kSandboxOrigin)) {\n     cookie_url_ = url_;\n     SetSecurityOrigin(SecurityOrigin::CreateUnique());\n@@ -5854,12 +5856,14 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {\n         GetSecurityOrigin()->SetUniqueOriginIsPotentiallyTrustworthy(true);\n       if (owner->GetSecurityOrigin()->CanLoadLocalResources())\n         GetSecurityOrigin()->GrantLoadLocalResources();\n+      policy_to_inherit = owner->GetContentSecurityPolicy();\n     }\n   } else if (Document* owner = initializer.OwnerDocument()) {\n     cookie_url_ = owner->CookieURL();\n     // We alias the SecurityOrigins to match Firefox, see Bug 15313\n     // https://bugs.webkit.org/show_bug.cgi?id=15313\n     SetSecurityOrigin(owner->GetSecurityOrigin());\n+    policy_to_inherit = owner->GetContentSecurityPolicy();\n   } else {\n     cookie_url_ = url_;\n     SetSecurityOrigin(SecurityOrigin::Create(url_));\n@@ -5891,7 +5895,7 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {\n     SetContentSecurityPolicy(\n         ImportsController()->Master()->GetContentSecurityPolicy());\n   } else {\n-    InitContentSecurityPolicy();\n+    InitContentSecurityPolicy(nullptr, policy_to_inherit);\n   }\n \n   if (GetSecurityOrigin()->HasSuborigin())\n@@ -5926,7 +5930,13 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {\n   SetFeaturePolicy(g_empty_string);\n }\n \n-void Document::InitContentSecurityPolicy(ContentSecurityPolicy* csp) {\n+// the first parameter specifies a policy to use as the document csp meaning\n+// the document will take ownership of the policy\n+// the second parameter specifies a policy to inherit meaning the document\n+// will attempt to copy over the policy\n+void Document::InitContentSecurityPolicy(\n+    ContentSecurityPolicy* csp,\n+    const ContentSecurityPolicy* policy_to_inherit) {\n   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());\n \n   // We inherit the parent/opener's CSP for documents with \""local\"" schemes:\n@@ -5938,24 +5948,27 @@ void Document::InitContentSecurityPolicy(ContentSecurityPolicy* csp) {\n   //\n   // TODO(dcheng): This is similar enough to work we're doing in\n   // 'DocumentLoader::ensureWriter' that it might make sense to combine them.\n-  if (frame_) {\n+  if (policy_to_inherit) {\n+    GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\n+  } else if (frame_) {\n     Frame* inherit_from = frame_->Tree().Parent() ? frame_->Tree().Parent()\n                                                   : frame_->Client()->Opener();\n     if (inherit_from && frame_ != inherit_from) {\n       DCHECK(inherit_from->GetSecurityContext() &&\n              inherit_from->GetSecurityContext()->GetContentSecurityPolicy());\n-      ContentSecurityPolicy* policy_to_inherit =\n+      policy_to_inherit =\n           inherit_from->GetSecurityContext()->GetContentSecurityPolicy();\n       if (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||\n           url_.ProtocolIs(\""blob\"") || url_.ProtocolIs(\""filesystem\"")) {\n         GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\n       }\n-      // Plugin documents inherit their parent/opener's 'plugin-types' directive\n-      // regardless of URL.\n-      if (IsPluginDocument())\n-        GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);\n     }\n   }\n+  // Plugin documents inherit their parent/opener's 'plugin-types' directive\n+  // regardless of URL.\n+  if (policy_to_inherit && IsPluginDocument())\n+    GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);\n+\n   GetContentSecurityPolicy()->BindToExecutionContext(this);\n }\n ""}<_**next**_>{""sha"": ""0667c0c51ea98b13f4266c913e99c34dea484190"", ""filename"": ""third_party/WebKit/Source/core/dom/Document.h"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 1, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/dom/Document.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/dom/Document.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Document.h?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -1037,7 +1037,13 @@ class CORE_EXPORT Document : public ContainerNode,\n   const SVGDocumentExtensions* SvgExtensions();\n   SVGDocumentExtensions& AccessSVGExtensions();\n \n-  void InitContentSecurityPolicy(ContentSecurityPolicy* = nullptr);\n+  // the first parameter specifies a policy to use as the document csp meaning\n+  // the document will take ownership of the policy\n+  // the second parameter specifies a policy to inherit meaning the document\n+  // will attempt to copy over the policy\n+  void InitContentSecurityPolicy(\n+      ContentSecurityPolicy* = nullptr,\n+      const ContentSecurityPolicy* policy_to_inherit = nullptr);\n \n   bool IsSecureTransitionTo(const KURL&) const;\n ""}<_**next**_>{""sha"": ""bd46b9d507b12455c4beae30363baf11e9ef08ec"", ""filename"": ""third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -1818,7 +1818,6 @@ void WebLocalFrameImpl::SetInputEventsScaleForEmulation(\n \n void WebLocalFrameImpl::LoadJavaScriptURL(const KURL& url) {\n   DCHECK(GetFrame());\n-\n   // This is copied from ScriptController::executeScriptIfJavaScriptURL.\n   // Unfortunately, we cannot just use that method since it is private, and\n   // it also doesn't quite behave as we require it to for bookmarklets. The""}<_**next**_>{""sha"": ""a11d1147135855cfaec5c2f0da99aa2b9b233fa3"", ""filename"": ""third_party/WebKit/Source/core/loader/DocumentLoader.cpp"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 3, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/loader/DocumentLoader.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/loader/DocumentLoader.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/loader/DocumentLoader.cpp?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -898,9 +898,12 @@ void DocumentLoader::EndWriting() {\n   writer_.Clear();\n }\n \n-void DocumentLoader::DidInstallNewDocument(Document* document) {\n+void DocumentLoader::DidInstallNewDocument(Document* document,\n+                                           InstallNewDocumentReason reason) {\n   document->SetReadyState(Document::kLoading);\n-  document->InitContentSecurityPolicy(content_security_policy_.Release());\n+  if (content_security_policy_) {\n+    document->InitContentSecurityPolicy(content_security_policy_.Release());\n+  }\n \n   if (history_item_ && IsBackForwardLoadType(load_type_))\n     document->SetStateForNewFormElements(history_item_->GetDocumentState());\n@@ -1116,7 +1119,7 @@ void DocumentLoader::InstallNewDocument(\n   frame_->GetPage()->GetChromeClient().InstallSupplements(*frame_);\n   if (!overriding_url.IsEmpty())\n     document->SetBaseURLOverride(overriding_url);\n-  DidInstallNewDocument(document);\n+  DidInstallNewDocument(document, reason);\n \n   // This must be called before DocumentWriter is created, otherwise HTML parser\n   // will use stale values from HTMLParserOption.""}<_**next**_>{""sha"": ""e5f59fd0c5ce7e5ce4b5a052fc75e6ec845ad9f5"", ""filename"": ""third_party/WebKit/Source/core/loader/DocumentLoader.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/loader/DocumentLoader.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/loader/DocumentLoader.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/loader/DocumentLoader.h?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -244,7 +244,7 @@ class CORE_EXPORT DocumentLoader\n                           InstallNewDocumentReason,\n                           ParserSynchronizationPolicy,\n                           const KURL& overriding_url);\n-  void DidInstallNewDocument(Document*);\n+  void DidInstallNewDocument(Document*, InstallNewDocumentReason);\n   void WillCommitNavigation();\n   void DidCommitNavigation();\n ""}","void DocumentLoader::DidInstallNewDocument(Document* document) {
void DocumentLoader::DidInstallNewDocument(Document* document,
                                           InstallNewDocumentReason reason) {
   document->SetReadyState(Document::kLoading);
  if (content_security_policy_) {
    document->InitContentSecurityPolicy(content_security_policy_.Release());
  }
 
   if (history_item_ && IsBackForwardLoadType(load_type_))
     document->SetStateForNewFormElements(history_item_->GetDocumentState());

  String suborigin_header = response_.HttpHeaderField(HTTPNames::Suborigin);
  if (!suborigin_header.IsNull()) {
    Vector<String> messages;
    Suborigin suborigin;
    if (ParseSuboriginHeader(suborigin_header, &suborigin, messages))
      document->EnforceSuborigin(suborigin);

    for (auto& message : messages) {
      document->AddConsoleMessage(
          ConsoleMessage::Create(kSecurityMessageSource, kErrorMessageLevel,
                                 ""Error with Suborigin header: "" + message));
    }
  }

  document->GetClientHintsPreferences().UpdateFrom(client_hints_preferences_);

  Settings* settings = document->GetSettings();
  fetcher_->SetImagesEnabled(settings->GetImagesEnabled());
  fetcher_->SetAutoLoadImages(settings->GetLoadsImagesAutomatically());

  const AtomicString& dns_prefetch_control =
      response_.HttpHeaderField(HTTPNames::X_DNS_Prefetch_Control);
  if (!dns_prefetch_control.IsEmpty())
    document->ParseDNSPrefetchControlHeader(dns_prefetch_control);

  String header_content_language =
      response_.HttpHeaderField(HTTPNames::Content_Language);
  if (!header_content_language.IsEmpty()) {
    size_t comma_index = header_content_language.find(',');
    header_content_language.Truncate(comma_index);
    header_content_language =
        header_content_language.StripWhiteSpace(IsHTMLSpace<UChar>);
    if (!header_content_language.IsEmpty())
      document->SetContentLanguage(AtomicString(header_content_language));
  }

  OriginTrialContext::AddTokensFromHeader(
      document, response_.HttpHeaderField(HTTPNames::Origin_Trial));
  String referrer_policy_header =
      response_.HttpHeaderField(HTTPNames::Referrer_Policy);
  if (!referrer_policy_header.IsNull()) {
    UseCounter::Count(*document, WebFeature::kReferrerPolicyHeader);
    document->ParseAndSetReferrerPolicy(referrer_policy_header);
  }

  GetLocalFrameClient().DidCreateNewDocument();
}
","void DocumentLoader::DidInstallNewDocument(Document* document) {
   document->SetReadyState(Document::kLoading);
  document->InitContentSecurityPolicy(content_security_policy_.Release());
 
   if (history_item_ && IsBackForwardLoadType(load_type_))
     document->SetStateForNewFormElements(history_item_->GetDocumentState());

  String suborigin_header = response_.HttpHeaderField(HTTPNames::Suborigin);
  if (!suborigin_header.IsNull()) {
    Vector<String> messages;
    Suborigin suborigin;
    if (ParseSuboriginHeader(suborigin_header, &suborigin, messages))
      document->EnforceSuborigin(suborigin);

    for (auto& message : messages) {
      document->AddConsoleMessage(
          ConsoleMessage::Create(kSecurityMessageSource, kErrorMessageLevel,
                                 ""Error with Suborigin header: "" + message));
    }
  }

  document->GetClientHintsPreferences().UpdateFrom(client_hints_preferences_);

  Settings* settings = document->GetSettings();
  fetcher_->SetImagesEnabled(settings->GetImagesEnabled());
  fetcher_->SetAutoLoadImages(settings->GetLoadsImagesAutomatically());

  const AtomicString& dns_prefetch_control =
      response_.HttpHeaderField(HTTPNames::X_DNS_Prefetch_Control);
  if (!dns_prefetch_control.IsEmpty())
    document->ParseDNSPrefetchControlHeader(dns_prefetch_control);

  String header_content_language =
      response_.HttpHeaderField(HTTPNames::Content_Language);
  if (!header_content_language.IsEmpty()) {
    size_t comma_index = header_content_language.find(',');
    header_content_language.Truncate(comma_index);
    header_content_language =
        header_content_language.StripWhiteSpace(IsHTMLSpace<UChar>);
    if (!header_content_language.IsEmpty())
      document->SetContentLanguage(AtomicString(header_content_language));
  }

  OriginTrialContext::AddTokensFromHeader(
      document, response_.HttpHeaderField(HTTPNames::Origin_Trial));
  String referrer_policy_header =
      response_.HttpHeaderField(HTTPNames::Referrer_Policy);
  if (!referrer_policy_header.IsNull()) {
    UseCounter::Count(*document, WebFeature::kReferrerPolicyHeader);
    document->ParseAndSetReferrerPolicy(referrer_policy_header);
  }

  GetLocalFrameClient().DidCreateNewDocument();
}
",C,"void DocumentLoader::DidInstallNewDocument(Document* document,
                                           InstallNewDocumentReason reason) {
  if (content_security_policy_) {
    document->InitContentSecurityPolicy(content_security_policy_.Release());
  }
","  document->InitContentSecurityPolicy(content_security_policy_.Release());
",,"@@ -898,9 +898,12 @@ void DocumentLoader::EndWriting() {
   writer_.Clear();
 }
 
-void DocumentLoader::DidInstallNewDocument(Document* document) {
+void DocumentLoader::DidInstallNewDocument(Document* document,
+                                           InstallNewDocumentReason reason) {
   document->SetReadyState(Document::kLoading);
-  document->InitContentSecurityPolicy(content_security_policy_.Release());
+  if (content_security_policy_) {
+    document->InitContentSecurityPolicy(content_security_policy_.Release());
+  }
 
   if (history_item_ && IsBackForwardLoadType(load_type_))
     document->SetStateForNewFormElements(history_item_->GetDocumentState());
@@ -1116,7 +1119,7 @@ void DocumentLoader::InstallNewDocument(
   frame_->GetPage()->GetChromeClient().InstallSupplements(*frame_);
   if (!overriding_url.IsEmpty())
     document->SetBaseURLOverride(overriding_url);
-  DidInstallNewDocument(document);
+  DidInstallNewDocument(document, reason);
 
   // This must be called before DocumentWriter is created, otherwise HTML parser
   // will use stale values from HTMLParserOption.",Chrome,0ab2412a104d2f235d7b9fe19d30ef605a410832,fb6b7d43431f6a142d53150d14f441cbf1f3e461,1,"void DocumentLoader::DidInstallNewDocument(Document* document) {
//fix_flaw_line_below:
//void DocumentLoader::DidInstallNewDocument(Document* document,
//fix_flaw_line_below:
//                                           InstallNewDocumentReason reason) {
   document->SetReadyState(Document::kLoading);
//flaw_line_below:
  document->InitContentSecurityPolicy(content_security_policy_.Release());
//fix_flaw_line_below:
//  if (content_security_policy_) {
//fix_flaw_line_below:
//    document->InitContentSecurityPolicy(content_security_policy_.Release());
//fix_flaw_line_below:
//  }
 
   if (history_item_ && IsBackForwardLoadType(load_type_))
     document->SetStateForNewFormElements(history_item_->GetDocumentState());

  String suborigin_header = response_.HttpHeaderField(HTTPNames::Suborigin);
  if (!suborigin_header.IsNull()) {
    Vector<String> messages;
    Suborigin suborigin;
    if (ParseSuboriginHeader(suborigin_header, &suborigin, messages))
      document->EnforceSuborigin(suborigin);

    for (auto& message : messages) {
      document->AddConsoleMessage(
          ConsoleMessage::Create(kSecurityMessageSource, kErrorMessageLevel,
                                 ""Error with Suborigin header: "" + message));
    }
  }

  document->GetClientHintsPreferences().UpdateFrom(client_hints_preferences_);

  // TODO(japhet): There's no reason to wait until commit to set these bits.
  Settings* settings = document->GetSettings();
  fetcher_->SetImagesEnabled(settings->GetImagesEnabled());
  fetcher_->SetAutoLoadImages(settings->GetLoadsImagesAutomatically());

  const AtomicString& dns_prefetch_control =
      response_.HttpHeaderField(HTTPNames::X_DNS_Prefetch_Control);
  if (!dns_prefetch_control.IsEmpty())
    document->ParseDNSPrefetchControlHeader(dns_prefetch_control);

  String header_content_language =
      response_.HttpHeaderField(HTTPNames::Content_Language);
  if (!header_content_language.IsEmpty()) {
    size_t comma_index = header_content_language.find(',');
    // kNotFound == -1 == don't truncate
    header_content_language.Truncate(comma_index);
    header_content_language =
        header_content_language.StripWhiteSpace(IsHTMLSpace<UChar>);
    if (!header_content_language.IsEmpty())
      document->SetContentLanguage(AtomicString(header_content_language));
  }

  OriginTrialContext::AddTokensFromHeader(
      document, response_.HttpHeaderField(HTTPNames::Origin_Trial));
  String referrer_policy_header =
      response_.HttpHeaderField(HTTPNames::Referrer_Policy);
  if (!referrer_policy_header.IsNull()) {
    UseCounter::Count(*document, WebFeature::kReferrerPolicyHeader);
    document->ParseAndSetReferrerPolicy(referrer_policy_header);
  }

  GetLocalFrameClient().DidCreateNewDocument();
}
"
8535,186271,,Remote,Not required,,CVE-2017-5118,https://www.cvedetails.com/cve/CVE-2017-5118/,CWE-732,Medium,,Partial,,2017-10-27,4.3,"Blink in Google Chrome prior to 61.0.3163.79 for Mac, Windows, and Linux, and 61.0.3163.81 for Android, failed to correctly propagate CSP restrictions to javascript scheme pages, which allowed a remote attacker to bypass content security policy via a crafted HTML page.",2019-10-02,Bypass ,1,https://github.com/chromium/chromium/commit/0ab2412a104d2f235d7b9fe19d30ef605a410832,0ab2412a104d2f235d7b9fe19d30ef605a410832,"Inherit CSP when we inherit the security origin

This prevents attacks that use main window navigation to get out of the
existing csp constraints such as the related bug

Bug: 747847
Change-Id: I1e57b50da17f65d38088205b0a3c7c49ef2ae4d8
Reviewed-on: https://chromium-review.googlesource.com/592027
Reviewed-by: Mike West <mkwst@chromium.org>
Commit-Queue: Andy Paicu <andypaicu@chromium.org>
Cr-Commit-Position: refs/heads/master@{#492333}",1,third_party/WebKit/Source/core/loader/DocumentLoader.cpp,"{""sha"": ""21c4fb33ce2d66db750d92a892e3871bd5d9b576"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/javascript-url-navigation-inherits-csp.html"", ""status"": ""added"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/javascript-url-navigation-inherits-csp.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/javascript-url-navigation-inherits-csp.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/javascript-url-navigation-inherits-csp.html?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -0,0 +1,16 @@\n+<!DOCTYPE html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+\n+<script>\n+  var window_url = encodeURIComponent(\""javascript:'<iframe src=/content-security-policy/support/fail.js />'\"");\n+  var report_cookie_name = encodeURIComponent(\""javascript-url-navigation-inherits-csp\"");\n+  window.open(\""support/test_csp_self_window.sub.html?window_url=\"" + window_url + \""&report_cookie_name=\"" + report_cookie_name);\n+  setTimeout(function() {\n+    var s = document.createElement('script');\n+    s.async = true;\n+    s.defer = true;\n+    s.src = \""../support/checkReport.sub.js?reportField=violated-directive&reportValue=frame-src%20%27none%27\"";\n+    document.body.appendChild(s);\n+  }, 2000);\n+</script>""}<_**next**_>{""sha"": ""ab0f8f82e3951a412824d066f670af17377dcec5"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html"", ""status"": ""added"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -0,0 +1,8 @@\n+<!DOCTYPE html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+\n+<script>\n+  var window_url = decodeURIComponent(\""{{GET[window_url]}}\"").replace('&lt;', '<').replace('&gt;', '>');\n+  window.open(window_url, \""_self\"");\n+</script>""}<_**next**_>{""sha"": ""dd418ec7648ba3f5603b0e070460ac171b8bc4d4"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html.sub.headers"", ""status"": ""added"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html.sub.headers"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html.sub.headers"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html.sub.headers?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -0,0 +1,6 @@\n+Expires: Mon, 26 Jul 1997 05:00:00 GMT\n+Cache-Control: no-store, no-cache, must-revalidate\n+Cache-Control: post-check=0, pre-check=0, false\n+Pragma: no-cache\n+Set-Cookie: {{GET[report_cookie_name]}}={{$id:uuid()}}; Path=/content-security-policy/navigation/\n+Content-Security-Policy: default-src 'none'; script-src 'self' 'unsafe-inline'; report-uri  ../../support/report.py?op=put&reportID={{$id}}""}<_**next**_>{""sha"": ""12245ff457031d6ccac563310d652a7fe83c88aa"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-in-iframe-expected.txt"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-in-iframe-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-in-iframe-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-in-iframe-expected.txt?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -1,5 +1,4 @@\n CONSOLE ERROR: The 'allow' directive has been replaced with 'default-src'. Please use that directive instead, as 'allow' has no effect.\n-CONSOLE ERROR: The 'allow' directive has been replaced with 'default-src'. Please use that directive instead, as 'allow' has no effect.\n Loads an iframe (a) which loads an iframe (b) which in turns tries to load an external script. The iframe (a) has a content security policy disabling external scripts. As this policy does not apply to (b), the script should be executed.\n \n ""}<_**next**_>{""sha"": ""c74e6c8893bb027a7928a49ca50a59062dc91319"", ""filename"": ""third_party/WebKit/Source/core/dom/Document.cpp"", ""status"": ""modified"", ""additions"": 21, ""deletions"": 8, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/dom/Document.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/dom/Document.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Document.cpp?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -5839,6 +5839,8 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {\n       AddInsecureNavigationUpgrade(to_upgrade);\n   }\n \n+  ContentSecurityPolicy* policy_to_inherit = nullptr;\n+\n   if (IsSandboxed(kSandboxOrigin)) {\n     cookie_url_ = url_;\n     SetSecurityOrigin(SecurityOrigin::CreateUnique());\n@@ -5854,12 +5856,14 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {\n         GetSecurityOrigin()->SetUniqueOriginIsPotentiallyTrustworthy(true);\n       if (owner->GetSecurityOrigin()->CanLoadLocalResources())\n         GetSecurityOrigin()->GrantLoadLocalResources();\n+      policy_to_inherit = owner->GetContentSecurityPolicy();\n     }\n   } else if (Document* owner = initializer.OwnerDocument()) {\n     cookie_url_ = owner->CookieURL();\n     // We alias the SecurityOrigins to match Firefox, see Bug 15313\n     // https://bugs.webkit.org/show_bug.cgi?id=15313\n     SetSecurityOrigin(owner->GetSecurityOrigin());\n+    policy_to_inherit = owner->GetContentSecurityPolicy();\n   } else {\n     cookie_url_ = url_;\n     SetSecurityOrigin(SecurityOrigin::Create(url_));\n@@ -5891,7 +5895,7 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {\n     SetContentSecurityPolicy(\n         ImportsController()->Master()->GetContentSecurityPolicy());\n   } else {\n-    InitContentSecurityPolicy();\n+    InitContentSecurityPolicy(nullptr, policy_to_inherit);\n   }\n \n   if (GetSecurityOrigin()->HasSuborigin())\n@@ -5926,7 +5930,13 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {\n   SetFeaturePolicy(g_empty_string);\n }\n \n-void Document::InitContentSecurityPolicy(ContentSecurityPolicy* csp) {\n+// the first parameter specifies a policy to use as the document csp meaning\n+// the document will take ownership of the policy\n+// the second parameter specifies a policy to inherit meaning the document\n+// will attempt to copy over the policy\n+void Document::InitContentSecurityPolicy(\n+    ContentSecurityPolicy* csp,\n+    const ContentSecurityPolicy* policy_to_inherit) {\n   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());\n \n   // We inherit the parent/opener's CSP for documents with \""local\"" schemes:\n@@ -5938,24 +5948,27 @@ void Document::InitContentSecurityPolicy(ContentSecurityPolicy* csp) {\n   //\n   // TODO(dcheng): This is similar enough to work we're doing in\n   // 'DocumentLoader::ensureWriter' that it might make sense to combine them.\n-  if (frame_) {\n+  if (policy_to_inherit) {\n+    GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\n+  } else if (frame_) {\n     Frame* inherit_from = frame_->Tree().Parent() ? frame_->Tree().Parent()\n                                                   : frame_->Client()->Opener();\n     if (inherit_from && frame_ != inherit_from) {\n       DCHECK(inherit_from->GetSecurityContext() &&\n              inherit_from->GetSecurityContext()->GetContentSecurityPolicy());\n-      ContentSecurityPolicy* policy_to_inherit =\n+      policy_to_inherit =\n           inherit_from->GetSecurityContext()->GetContentSecurityPolicy();\n       if (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||\n           url_.ProtocolIs(\""blob\"") || url_.ProtocolIs(\""filesystem\"")) {\n         GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\n       }\n-      // Plugin documents inherit their parent/opener's 'plugin-types' directive\n-      // regardless of URL.\n-      if (IsPluginDocument())\n-        GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);\n     }\n   }\n+  // Plugin documents inherit their parent/opener's 'plugin-types' directive\n+  // regardless of URL.\n+  if (policy_to_inherit && IsPluginDocument())\n+    GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);\n+\n   GetContentSecurityPolicy()->BindToExecutionContext(this);\n }\n ""}<_**next**_>{""sha"": ""0667c0c51ea98b13f4266c913e99c34dea484190"", ""filename"": ""third_party/WebKit/Source/core/dom/Document.h"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 1, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/dom/Document.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/dom/Document.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Document.h?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -1037,7 +1037,13 @@ class CORE_EXPORT Document : public ContainerNode,\n   const SVGDocumentExtensions* SvgExtensions();\n   SVGDocumentExtensions& AccessSVGExtensions();\n \n-  void InitContentSecurityPolicy(ContentSecurityPolicy* = nullptr);\n+  // the first parameter specifies a policy to use as the document csp meaning\n+  // the document will take ownership of the policy\n+  // the second parameter specifies a policy to inherit meaning the document\n+  // will attempt to copy over the policy\n+  void InitContentSecurityPolicy(\n+      ContentSecurityPolicy* = nullptr,\n+      const ContentSecurityPolicy* policy_to_inherit = nullptr);\n \n   bool IsSecureTransitionTo(const KURL&) const;\n ""}<_**next**_>{""sha"": ""bd46b9d507b12455c4beae30363baf11e9ef08ec"", ""filename"": ""third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -1818,7 +1818,6 @@ void WebLocalFrameImpl::SetInputEventsScaleForEmulation(\n \n void WebLocalFrameImpl::LoadJavaScriptURL(const KURL& url) {\n   DCHECK(GetFrame());\n-\n   // This is copied from ScriptController::executeScriptIfJavaScriptURL.\n   // Unfortunately, we cannot just use that method since it is private, and\n   // it also doesn't quite behave as we require it to for bookmarklets. The""}<_**next**_>{""sha"": ""a11d1147135855cfaec5c2f0da99aa2b9b233fa3"", ""filename"": ""third_party/WebKit/Source/core/loader/DocumentLoader.cpp"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 3, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/loader/DocumentLoader.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/loader/DocumentLoader.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/loader/DocumentLoader.cpp?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -898,9 +898,12 @@ void DocumentLoader::EndWriting() {\n   writer_.Clear();\n }\n \n-void DocumentLoader::DidInstallNewDocument(Document* document) {\n+void DocumentLoader::DidInstallNewDocument(Document* document,\n+                                           InstallNewDocumentReason reason) {\n   document->SetReadyState(Document::kLoading);\n-  document->InitContentSecurityPolicy(content_security_policy_.Release());\n+  if (content_security_policy_) {\n+    document->InitContentSecurityPolicy(content_security_policy_.Release());\n+  }\n \n   if (history_item_ && IsBackForwardLoadType(load_type_))\n     document->SetStateForNewFormElements(history_item_->GetDocumentState());\n@@ -1116,7 +1119,7 @@ void DocumentLoader::InstallNewDocument(\n   frame_->GetPage()->GetChromeClient().InstallSupplements(*frame_);\n   if (!overriding_url.IsEmpty())\n     document->SetBaseURLOverride(overriding_url);\n-  DidInstallNewDocument(document);\n+  DidInstallNewDocument(document, reason);\n \n   // This must be called before DocumentWriter is created, otherwise HTML parser\n   // will use stale values from HTMLParserOption.""}<_**next**_>{""sha"": ""e5f59fd0c5ce7e5ce4b5a052fc75e6ec845ad9f5"", ""filename"": ""third_party/WebKit/Source/core/loader/DocumentLoader.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/loader/DocumentLoader.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/loader/DocumentLoader.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/loader/DocumentLoader.h?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -244,7 +244,7 @@ class CORE_EXPORT DocumentLoader\n                           InstallNewDocumentReason,\n                           ParserSynchronizationPolicy,\n                           const KURL& overriding_url);\n-  void DidInstallNewDocument(Document*);\n+  void DidInstallNewDocument(Document*, InstallNewDocumentReason);\n   void WillCommitNavigation();\n   void DidCommitNavigation();\n ""}","void DocumentLoader::InstallNewDocument(
    const KURL& url,
    Document* owner_document,
    bool should_reuse_default_view,
    const AtomicString& mime_type,
    const AtomicString& encoding,
    InstallNewDocumentReason reason,
    ParserSynchronizationPolicy parsing_policy,
    const KURL& overriding_url) {
  DCHECK(!frame_->GetDocument() || !frame_->GetDocument()->IsActive());
  DCHECK_EQ(frame_->Tree().ChildCount(), 0u);

  if (GetFrameLoader().StateMachine()->IsDisplayingInitialEmptyDocument()) {
    GetFrameLoader().StateMachine()->AdvanceTo(
        FrameLoaderStateMachine::kCommittedFirstRealLoad);
  }

  SecurityOrigin* previous_security_origin = nullptr;
  if (frame_->GetDocument())
    previous_security_origin = frame_->GetDocument()->GetSecurityOrigin();

  if (!should_reuse_default_view)
    frame_->SetDOMWindow(LocalDOMWindow::Create(*frame_));

  bool user_gesture_bit_set = frame_->HasReceivedUserGesture() ||
                              frame_->HasReceivedUserGestureBeforeNavigation();

  if (reason == InstallNewDocumentReason::kNavigation)
    WillCommitNavigation();

  Document* document = frame_->DomWindow()->InstallNewDocument(
      mime_type,
      DocumentInit::Create()
          .WithFrame(frame_)
          .WithURL(url)
          .WithOwnerDocument(owner_document)
          .WithNewRegistrationContext(),
      false);

  if (user_gesture_bit_set) {
    frame_->SetDocumentHasReceivedUserGestureBeforeNavigation(
        ShouldPersistUserGestureValue(previous_security_origin,
                                      document->GetSecurityOrigin()));

    if (frame_->IsMainFrame())
      frame_->ClearDocumentHasReceivedUserGesture();
  }

  if (ShouldClearWindowName(*frame_, previous_security_origin, *document)) {
    frame_->Tree().ExperimentalSetNulledName();
  }

   frame_->GetPage()->GetChromeClient().InstallSupplements(*frame_);
   if (!overriding_url.IsEmpty())
     document->SetBaseURLOverride(overriding_url);
  DidInstallNewDocument(document, reason);
 
  if (reason == InstallNewDocumentReason::kNavigation)
    DidCommitNavigation();

  writer_ =
      DocumentWriter::Create(document, parsing_policy, mime_type, encoding);

  document->SetFeaturePolicy(
      RuntimeEnabledFeatures::FeaturePolicyExperimentalFeaturesEnabled()
          ? response_.HttpHeaderField(HTTPNames::Feature_Policy)
          : g_empty_string);

  GetFrameLoader().DispatchDidClearDocumentOfWindowObject();
}
","void DocumentLoader::InstallNewDocument(
    const KURL& url,
    Document* owner_document,
    bool should_reuse_default_view,
    const AtomicString& mime_type,
    const AtomicString& encoding,
    InstallNewDocumentReason reason,
    ParserSynchronizationPolicy parsing_policy,
    const KURL& overriding_url) {
  DCHECK(!frame_->GetDocument() || !frame_->GetDocument()->IsActive());
  DCHECK_EQ(frame_->Tree().ChildCount(), 0u);

  if (GetFrameLoader().StateMachine()->IsDisplayingInitialEmptyDocument()) {
    GetFrameLoader().StateMachine()->AdvanceTo(
        FrameLoaderStateMachine::kCommittedFirstRealLoad);
  }

  SecurityOrigin* previous_security_origin = nullptr;
  if (frame_->GetDocument())
    previous_security_origin = frame_->GetDocument()->GetSecurityOrigin();

  if (!should_reuse_default_view)
    frame_->SetDOMWindow(LocalDOMWindow::Create(*frame_));

  bool user_gesture_bit_set = frame_->HasReceivedUserGesture() ||
                              frame_->HasReceivedUserGestureBeforeNavigation();

  if (reason == InstallNewDocumentReason::kNavigation)
    WillCommitNavigation();

  Document* document = frame_->DomWindow()->InstallNewDocument(
      mime_type,
      DocumentInit::Create()
          .WithFrame(frame_)
          .WithURL(url)
          .WithOwnerDocument(owner_document)
          .WithNewRegistrationContext(),
      false);

  if (user_gesture_bit_set) {
    frame_->SetDocumentHasReceivedUserGestureBeforeNavigation(
        ShouldPersistUserGestureValue(previous_security_origin,
                                      document->GetSecurityOrigin()));

    if (frame_->IsMainFrame())
      frame_->ClearDocumentHasReceivedUserGesture();
  }

  if (ShouldClearWindowName(*frame_, previous_security_origin, *document)) {
    frame_->Tree().ExperimentalSetNulledName();
  }

   frame_->GetPage()->GetChromeClient().InstallSupplements(*frame_);
   if (!overriding_url.IsEmpty())
     document->SetBaseURLOverride(overriding_url);
  DidInstallNewDocument(document);
 
  if (reason == InstallNewDocumentReason::kNavigation)
    DidCommitNavigation();

  writer_ =
      DocumentWriter::Create(document, parsing_policy, mime_type, encoding);

  document->SetFeaturePolicy(
      RuntimeEnabledFeatures::FeaturePolicyExperimentalFeaturesEnabled()
          ? response_.HttpHeaderField(HTTPNames::Feature_Policy)
          : g_empty_string);

  GetFrameLoader().DispatchDidClearDocumentOfWindowObject();
}
",C,"  DidInstallNewDocument(document, reason);
","  DidInstallNewDocument(document);
",,"@@ -898,9 +898,12 @@ void DocumentLoader::EndWriting() {
   writer_.Clear();
 }
 
-void DocumentLoader::DidInstallNewDocument(Document* document) {
+void DocumentLoader::DidInstallNewDocument(Document* document,
+                                           InstallNewDocumentReason reason) {
   document->SetReadyState(Document::kLoading);
-  document->InitContentSecurityPolicy(content_security_policy_.Release());
+  if (content_security_policy_) {
+    document->InitContentSecurityPolicy(content_security_policy_.Release());
+  }
 
   if (history_item_ && IsBackForwardLoadType(load_type_))
     document->SetStateForNewFormElements(history_item_->GetDocumentState());
@@ -1116,7 +1119,7 @@ void DocumentLoader::InstallNewDocument(
   frame_->GetPage()->GetChromeClient().InstallSupplements(*frame_);
   if (!overriding_url.IsEmpty())
     document->SetBaseURLOverride(overriding_url);
-  DidInstallNewDocument(document);
+  DidInstallNewDocument(document, reason);
 
   // This must be called before DocumentWriter is created, otherwise HTML parser
   // will use stale values from HTMLParserOption.",Chrome,0ab2412a104d2f235d7b9fe19d30ef605a410832,fb6b7d43431f6a142d53150d14f441cbf1f3e461,1,"void DocumentLoader::InstallNewDocument(
    const KURL& url,
    Document* owner_document,
    bool should_reuse_default_view,
    const AtomicString& mime_type,
    const AtomicString& encoding,
    InstallNewDocumentReason reason,
    ParserSynchronizationPolicy parsing_policy,
    const KURL& overriding_url) {
  DCHECK(!frame_->GetDocument() || !frame_->GetDocument()->IsActive());
  DCHECK_EQ(frame_->Tree().ChildCount(), 0u);

  if (GetFrameLoader().StateMachine()->IsDisplayingInitialEmptyDocument()) {
    GetFrameLoader().StateMachine()->AdvanceTo(
        FrameLoaderStateMachine::kCommittedFirstRealLoad);
  }

  SecurityOrigin* previous_security_origin = nullptr;
  if (frame_->GetDocument())
    previous_security_origin = frame_->GetDocument()->GetSecurityOrigin();

  // In some rare cases, we'll re-use a LocalDOMWindow for a new Document. For
  // example, when a script calls window.open(""...""), the browser gives
  // JavaScript a window synchronously but kicks off the load in the window
  // asynchronously. Web sites expect that modifications that they make to the
  // window object synchronously won't be blown away when the network load
  // commits. To make that happen, we ""securely transition"" the existing
  // LocalDOMWindow to the Document that results from the network load. See also
  // Document::IsSecureTransitionTo.
  if (!should_reuse_default_view)
    frame_->SetDOMWindow(LocalDOMWindow::Create(*frame_));

  bool user_gesture_bit_set = frame_->HasReceivedUserGesture() ||
                              frame_->HasReceivedUserGestureBeforeNavigation();

  if (reason == InstallNewDocumentReason::kNavigation)
    WillCommitNavigation();

  Document* document = frame_->DomWindow()->InstallNewDocument(
      mime_type,
      DocumentInit::Create()
          .WithFrame(frame_)
          .WithURL(url)
          .WithOwnerDocument(owner_document)
          .WithNewRegistrationContext(),
      false);

  // Persist the user gesture state between frames.
  if (user_gesture_bit_set) {
    frame_->SetDocumentHasReceivedUserGestureBeforeNavigation(
        ShouldPersistUserGestureValue(previous_security_origin,
                                      document->GetSecurityOrigin()));

    // Clear the user gesture bit that is not persisted.
    // TODO(crbug.com/736415): Clear this bit unconditionally for all frames.
    if (frame_->IsMainFrame())
      frame_->ClearDocumentHasReceivedUserGesture();
  }

  if (ShouldClearWindowName(*frame_, previous_security_origin, *document)) {
    // TODO(andypaicu): experimentalSetNullName will just record the fact
    // that the name would be nulled and if the name is accessed after we will
    // fire a UseCounter. If we decide to move forward with this change, we'd
    // actually clean the name here.
    // frame_->tree().setName(nullAtom);
    frame_->Tree().ExperimentalSetNulledName();
  }

   frame_->GetPage()->GetChromeClient().InstallSupplements(*frame_);
   if (!overriding_url.IsEmpty())
     document->SetBaseURLOverride(overriding_url);
//flaw_line_below:
  DidInstallNewDocument(document);
//fix_flaw_line_below:
//  DidInstallNewDocument(document, reason);
 
   // This must be called before DocumentWriter is created, otherwise HTML parser
   // will use stale values from HTMLParserOption.
  if (reason == InstallNewDocumentReason::kNavigation)
    DidCommitNavigation();

  writer_ =
      DocumentWriter::Create(document, parsing_policy, mime_type, encoding);

  // FeaturePolicy is reset in the browser process on commit, so this needs to
  // be initialized and replicated to the browser process after commit messages
  // are sent in didCommitNavigation().
  // Feature-Policy header is currently disabled while the details of the policy
  // syntax are being worked out. Unless the Feature Policy experimental
  // features flag is enabled, then ignore any header received.
  // TODO(iclelland): Re-enable once the syntax is finalized. (crbug.com/737643)
  document->SetFeaturePolicy(
      RuntimeEnabledFeatures::FeaturePolicyExperimentalFeaturesEnabled()
          ? response_.HttpHeaderField(HTTPNames::Feature_Policy)
          : g_empty_string);

  GetFrameLoader().DispatchDidClearDocumentOfWindowObject();
}
"
8855,186591,,Remote,Not required,,CVE-2018-18349,https://www.cvedetails.com/cve/CVE-2018-18349/,CWE-732,Medium,Partial,,,2018-12-11,4.3,Remote frame navigations was incorrectly permitted to local resources in Blink in Google Chrome prior to 71.0.3578.80 allowed an attacker who convinced a user to install a malicious extension to access files on the local file system via a crafted Chrome Extension.,2019-10-02,,7,https://github.com/chromium/chromium/commit/5f8671e7667b8b133bd3664100012a3906e92d65,5f8671e7667b8b133bd3664100012a3906e92d65,"Add a check for disallowing remote frame navigations to local resources.

Previously, RemoteFrame navigations did not perform any renderer-side
checks and relied solely on the browser-side logic to block disallowed
navigations via mechanisms like FilterURL.  This means that blocked
remote frame navigations were silently navigated to about:blank
without any console error message.

This CL adds a CanDisplay check to the remote navigation path to match
an equivalent check done for local frame navigations.  This way, the
renderer can consistently block disallowed navigations in both cases
and output an error message.

Bug: 894399
Change-Id: I172f68f77c1676f6ca0172d2a6c78f7edc0e3b7a
Reviewed-on: https://chromium-review.googlesource.com/c/1282390
Reviewed-by: Charlie Reis <creis@chromium.org>
Reviewed-by: Nate Chapin <japhet@chromium.org>
Commit-Queue: Alex Moshchuk <alexmos@chromium.org>
Cr-Commit-Position: refs/heads/master@{#601022}",0,third_party/blink/renderer/core/frame/remote_frame.cc,"{""sha"": ""82af60872317fdaf16561c9f9adecb79ce82f610"", ""filename"": ""content/browser/security_exploit_browsertest.cc"", ""status"": ""modified"", ""additions"": 69, ""deletions"": 0, ""changes"": 69, ""blob_url"": ""https://github.com/chromium/chromium/blob/5f8671e7667b8b133bd3664100012a3906e92d65/content/browser/security_exploit_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5f8671e7667b8b133bd3664100012a3906e92d65/content/browser/security_exploit_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/security_exploit_browsertest.cc?ref=5f8671e7667b8b133bd3664100012a3906e92d65"", ""patch"": ""@@ -17,6 +17,7 @@\n #include \""content/browser/dom_storage/session_storage_namespace_impl.h\""\n #include \""content/browser/frame_host/navigator.h\""\n #include \""content/browser/frame_host/render_frame_host_impl.h\""\n+#include \""content/browser/frame_host/render_frame_proxy_host.h\""\n #include \""content/browser/renderer_host/render_process_host_impl.h\""\n #include \""content/browser/renderer_host/render_view_host_factory.h\""\n #include \""content/browser/renderer_host/render_view_host_impl.h\""\n@@ -983,4 +984,72 @@ IN_PROC_BROWSER_TEST_F(SecurityExploitBrowserTest,\n       << \"" body=\"" << body;\n }\n \n+// Verify that when a compromised renderer tries to navigate a remote frame to\n+// a disallowed URL (e.g., file URL), that navigation is blocked.\n+IN_PROC_BROWSER_TEST_F(SecurityExploitBrowserTest,\n+                       BlockIllegalOpenURLFromRemoteFrame) {\n+  // This test is only valid in site-per-process mode, where a cross-site\n+  // iframe will have a proxy in the main frame's process.\n+  if (!AreAllSitesIsolatedForTesting())\n+    return;\n+\n+  GURL main_url(embedded_test_server()->GetURL(\n+      \""a.com\"", \""/cross_site_iframe_factory.html?a(b)\""));\n+  EXPECT_TRUE(NavigateToURL(shell(), main_url));\n+  FrameTreeNode* root = static_cast<WebContentsImpl*>(shell()->web_contents())\n+                            ->GetFrameTree()\n+                            ->root();\n+  FrameTreeNode* child = root->child_at(0);\n+\n+  // Simulate an IPC message where the top frame asks the remote subframe to\n+  // navigate to a file: URL.\n+  GURL file_url(\""file:///\"");\n+  FrameHostMsg_OpenURL_Params params;\n+  params.url = file_url;\n+  params.uses_post = false;\n+  params.disposition = WindowOpenDisposition::CURRENT_TAB;\n+  params.should_replace_current_entry = false;\n+  params.user_gesture = true;\n+  params.is_history_navigation_in_new_child = false;\n+\n+  SiteInstance* a_com_instance = root->current_frame_host()->GetSiteInstance();\n+  RenderFrameProxyHost* proxy =\n+      child->render_manager()->GetRenderFrameProxyHost(a_com_instance);\n+  EXPECT_TRUE(proxy);\n+\n+  {\n+    FrameHostMsg_OpenURL msg(proxy->GetRoutingID(), params);\n+    IPC::IpcSecurityTestUtil::PwnMessageReceived(\n+        proxy->GetProcess()->GetChannel(), msg);\n+  }\n+\n+  // Verify that the malicious navigation was blocked.  Currently, this happens\n+  // by rewriting the target URL to about:blank.\n+  //\n+  // TODO(alexmos): Consider killing the renderer process in this case, since\n+  // this security check is already enforced in the renderer process.\n+  EXPECT_TRUE(WaitForLoadStop(shell()->web_contents()));\n+  EXPECT_EQ(GURL(url::kAboutBlankURL),\n+            child->current_frame_host()->GetLastCommittedURL());\n+\n+  // Navigate to the starting page again to recreate the proxy, then try the\n+  // same malicious navigation with a chrome:// URL.\n+  EXPECT_TRUE(NavigateToURL(shell(), main_url));\n+  child = root->child_at(0);\n+  proxy = child->render_manager()->GetRenderFrameProxyHost(a_com_instance);\n+  EXPECT_TRUE(proxy);\n+\n+  GURL chrome_url(std::string(kChromeUIScheme) + \""://\"" +\n+                  std::string(kChromeUIGpuHost));\n+  params.url = chrome_url;\n+  {\n+    FrameHostMsg_OpenURL msg(proxy->GetRoutingID(), params);\n+    IPC::IpcSecurityTestUtil::PwnMessageReceived(\n+        proxy->GetProcess()->GetChannel(), msg);\n+  }\n+  EXPECT_TRUE(WaitForLoadStop(shell()->web_contents()));\n+  EXPECT_EQ(GURL(url::kAboutBlankURL),\n+            child->current_frame_host()->GetLastCommittedURL());\n+}\n+\n }  // namespace content""}<_**next**_>{""sha"": ""c6aeda6823abeec3c633913d406db6b5437983df"", ""filename"": ""content/browser/site_per_process_browsertest.cc"", ""status"": ""modified"", ""additions"": 41, ""deletions"": 11, ""changes"": 52, ""blob_url"": ""https://github.com/chromium/chromium/blob/5f8671e7667b8b133bd3664100012a3906e92d65/content/browser/site_per_process_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5f8671e7667b8b133bd3664100012a3906e92d65/content/browser/site_per_process_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/site_per_process_browsertest.cc?ref=5f8671e7667b8b133bd3664100012a3906e92d65"", ""patch"": ""@@ -5036,26 +5036,28 @@ IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest, NavigatePopupToIllegalURL) {\n   EXPECT_NE(popup->web_contents()->GetSiteInstance(),\n             shell()->web_contents()->GetSiteInstance());\n \n-  // From the opener, navigate the popup to a file:/// URL.  This should be\n-  // disallowed and result in an about:blank navigation.\n+  ConsoleObserverDelegate console_delegate(\n+      web_contents(), \""Not allowed to load local resource:*\"");\n+  web_contents()->SetDelegate(&console_delegate);\n+\n+  // From the opener, navigate the popup to a file:/// URL.  This should result\n+  // in a console error and stay on the old page.\n   GURL file_url(\""file:///\"");\n   NavigateNamedFrame(shell(), file_url, \""foo\"");\n   EXPECT_TRUE(WaitForLoadStop(popup->web_contents()));\n-  EXPECT_EQ(GURL(url::kAboutBlankURL),\n-            popup->web_contents()->GetLastCommittedURL());\n-\n-  // Navigate popup back to a cross-site URL.\n-  EXPECT_TRUE(NavigateToURLFromRenderer(popup, popup_url));\n-  EXPECT_NE(popup->web_contents()->GetSiteInstance(),\n-            shell()->web_contents()->GetSiteInstance());\n+  EXPECT_EQ(popup_url, popup->web_contents()->GetLastCommittedURL());\n+  EXPECT_TRUE(base::MatchPattern(console_delegate.message(),\n+                                 \""Not allowed to load local resource: file:*\""));\n \n   // Now try the same test with a chrome:// URL.\n   GURL chrome_url(std::string(kChromeUIScheme) + \""://\"" +\n                   std::string(kChromeUIGpuHost));\n   NavigateNamedFrame(shell(), chrome_url, \""foo\"");\n   EXPECT_TRUE(WaitForLoadStop(popup->web_contents()));\n-  EXPECT_EQ(GURL(url::kAboutBlankURL),\n-            popup->web_contents()->GetLastCommittedURL());\n+  EXPECT_EQ(popup_url, popup->web_contents()->GetLastCommittedURL());\n+  EXPECT_TRUE(\n+      base::MatchPattern(console_delegate.message(),\n+                         \""Not allowed to load local resource: chrome:*\""));\n }\n \n // Verify that named frames are discoverable from their opener's ancestors.\n@@ -13519,4 +13521,32 @@ IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest, ProcessSwapOnInnerContents) {\n   EXPECT_NE(a_view, b_view);\n }\n \n+// Check that a web frame can't navigate a remote subframe to a file: URL.  The\n+// frame should stay at the old URL, and the navigation attempt should produce\n+// a console error message.  See https://crbug.com/894399.\n+IN_PROC_BROWSER_TEST_F(SitePerProcessBrowserTest,\n+                       FileURLBlockedWithConsoleErrorInRemoteFrameNavigation) {\n+  GURL main_url(embedded_test_server()->GetURL(\n+      \""a.com\"", \""/cross_site_iframe_factory.html?a(b)\""));\n+  EXPECT_TRUE(NavigateToURL(shell(), main_url));\n+\n+  FrameTreeNode* child = web_contents()->GetFrameTree()->root()->child_at(0);\n+  GURL original_frame_url(child->current_frame_host()->GetLastCommittedURL());\n+  EXPECT_EQ(\""b.com\"", original_frame_url.host());\n+\n+  ConsoleObserverDelegate console_delegate(\n+      web_contents(), \""Not allowed to load local resource: file:*\"");\n+  web_contents()->SetDelegate(&console_delegate);\n+\n+  GURL file_url(\""file:///\"");\n+  EXPECT_TRUE(\n+      ExecJs(web_contents(),\n+             JsReplace(\""document.querySelector('iframe').src = $1\"", file_url)));\n+  console_delegate.Wait();\n+\n+  // The iframe should've stayed at the original URL.\n+  EXPECT_EQ(original_frame_url,\n+            child->current_frame_host()->GetLastCommittedURL());\n+}\n+\n }  // namespace content""}<_**next**_>{""sha"": ""d0f8b72a47f5fda0874c59088644738158f3a185"", ""filename"": ""third_party/blink/renderer/core/frame/remote_frame.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/5f8671e7667b8b133bd3664100012a3906e92d65/third_party/blink/renderer/core/frame/remote_frame.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/5f8671e7667b8b133bd3664100012a3906e92d65/third_party/blink/renderer/core/frame/remote_frame.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/frame/remote_frame.cc?ref=5f8671e7667b8b133bd3664100012a3906e92d65"", ""patch"": ""@@ -13,6 +13,7 @@\n #include \""third_party/blink/renderer/core/frame/remote_frame_client.h\""\n #include \""third_party/blink/renderer/core/frame/remote_frame_view.h\""\n #include \""third_party/blink/renderer/core/html/html_frame_owner_element.h\""\n+#include \""third_party/blink/renderer/core/inspector/console_message.h\""\n #include \""third_party/blink/renderer/core/layout/layout_embedded_content.h\""\n #include \""third_party/blink/renderer/core/loader/frame_load_request.h\""\n #include \""third_party/blink/renderer/core/loader/frame_loader.h\""\n@@ -60,6 +61,13 @@ void RemoteFrame::ScheduleNavigation(Document& origin_document,\n                                      const KURL& url,\n                                      WebFrameLoadType frame_load_type,\n                                      UserGestureStatus user_gesture_status) {\n+  if (!origin_document.GetSecurityOrigin()->CanDisplay(url)) {\n+    origin_document.AddConsoleMessage(ConsoleMessage::Create(\n+        kSecurityMessageSource, kErrorMessageLevel,\n+        \""Not allowed to load local resource: \"" + url.ElidedString()));\n+    return;\n+  }\n+\n   FrameLoadRequest frame_request(&origin_document, ResourceRequest(url));\n   frame_request.GetResourceRequest().SetHasUserGesture(\n       user_gesture_status == UserGestureStatus::kActive);""}","void RemoteFrame::ScheduleNavigation(Document& origin_document,
                                      const KURL& url,
                                      WebFrameLoadType frame_load_type,
                                      UserGestureStatus user_gesture_status) {
  if (!origin_document.GetSecurityOrigin()->CanDisplay(url)) {
    origin_document.AddConsoleMessage(ConsoleMessage::Create(
        kSecurityMessageSource, kErrorMessageLevel,
        ""Not allowed to load local resource: "" + url.ElidedString()));
    return;
  }

   FrameLoadRequest frame_request(&origin_document, ResourceRequest(url));
   frame_request.GetResourceRequest().SetHasUserGesture(
       user_gesture_status == UserGestureStatus::kActive);
  frame_request.GetResourceRequest().SetFrameType(
      IsMainFrame() ? network::mojom::RequestContextFrameType::kTopLevel
                    : network::mojom::RequestContextFrameType::kNested);
  Navigate(frame_request, frame_load_type);
}
","void RemoteFrame::ScheduleNavigation(Document& origin_document,
                                      const KURL& url,
                                      WebFrameLoadType frame_load_type,
                                      UserGestureStatus user_gesture_status) {
   FrameLoadRequest frame_request(&origin_document, ResourceRequest(url));
   frame_request.GetResourceRequest().SetHasUserGesture(
       user_gesture_status == UserGestureStatus::kActive);
  frame_request.GetResourceRequest().SetFrameType(
      IsMainFrame() ? network::mojom::RequestContextFrameType::kTopLevel
                    : network::mojom::RequestContextFrameType::kNested);
  Navigate(frame_request, frame_load_type);
}
",C,"  if (!origin_document.GetSecurityOrigin()->CanDisplay(url)) {
    origin_document.AddConsoleMessage(ConsoleMessage::Create(
        kSecurityMessageSource, kErrorMessageLevel,
        ""Not allowed to load local resource: "" + url.ElidedString()));
    return;
  }

",,,"@@ -13,6 +13,7 @@
 #include ""third_party/blink/renderer/core/frame/remote_frame_client.h""
 #include ""third_party/blink/renderer/core/frame/remote_frame_view.h""
 #include ""third_party/blink/renderer/core/html/html_frame_owner_element.h""
+#include ""third_party/blink/renderer/core/inspector/console_message.h""
 #include ""third_party/blink/renderer/core/layout/layout_embedded_content.h""
 #include ""third_party/blink/renderer/core/loader/frame_load_request.h""
 #include ""third_party/blink/renderer/core/loader/frame_loader.h""
@@ -60,6 +61,13 @@ void RemoteFrame::ScheduleNavigation(Document& origin_document,
                                      const KURL& url,
                                      WebFrameLoadType frame_load_type,
                                      UserGestureStatus user_gesture_status) {
+  if (!origin_document.GetSecurityOrigin()->CanDisplay(url)) {
+    origin_document.AddConsoleMessage(ConsoleMessage::Create(
+        kSecurityMessageSource, kErrorMessageLevel,
+        ""Not allowed to load local resource: "" + url.ElidedString()));
+    return;
+  }
+
   FrameLoadRequest frame_request(&origin_document, ResourceRequest(url));
   frame_request.GetResourceRequest().SetHasUserGesture(
       user_gesture_status == UserGestureStatus::kActive);",Chrome,5f8671e7667b8b133bd3664100012a3906e92d65,f6ac318a5b317fc5dc4d6f98b900ddbc72ade4e3,1,"void RemoteFrame::ScheduleNavigation(Document& origin_document,
                                      const KURL& url,
                                      WebFrameLoadType frame_load_type,
                                      UserGestureStatus user_gesture_status) {
//fix_flaw_line_below:
//  if (!origin_document.GetSecurityOrigin()->CanDisplay(url)) {
//fix_flaw_line_below:
//    origin_document.AddConsoleMessage(ConsoleMessage::Create(
//fix_flaw_line_below:
//        kSecurityMessageSource, kErrorMessageLevel,
//fix_flaw_line_below:
//        ""Not allowed to load local resource: "" + url.ElidedString()));
//fix_flaw_line_below:
//    return;
//fix_flaw_line_below:
//  }
//fix_flaw_line_below:
//
   FrameLoadRequest frame_request(&origin_document, ResourceRequest(url));
   frame_request.GetResourceRequest().SetHasUserGesture(
       user_gesture_status == UserGestureStatus::kActive);
  frame_request.GetResourceRequest().SetFrameType(
      IsMainFrame() ? network::mojom::RequestContextFrameType::kTopLevel
                    : network::mojom::RequestContextFrameType::kNested);
  Navigate(frame_request, frame_load_type);
}
"
8861,186597,,Remote,Not required,,CVE-2018-18352,https://www.cvedetails.com/cve/CVE-2018-18352/,CWE-732,Medium,Partial,,,2018-12-11,4.3,Service works could inappropriately gain access to cross origin audio in Media in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to bypass same origin policy for audio content via a crafted HTML page.,2019-10-02,Bypass ,1,https://github.com/chromium/chromium/commit/a9cbaa7a40e2b2723cfc2f266c42f4980038a949,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,"Simplify ""WouldTaintOrigin"" concept in media/blink

Currently WebMediaPlayer has three predicates:
 - DidGetOpaqueResponseFromServiceWorker
 - HasSingleSecurityOrigin
 - DidPassCORSAccessCheck
. These are used to determine whether the response body is available
for scripts. They are known to be confusing, and actually
MediaElementAudioSourceHandler::WouldTaintOrigin misuses them.

This CL merges the three predicates to one, WouldTaintOrigin, to remove
the confusion. Now the ""response type"" concept is available and we
don't need a custom CORS check, so this CL removes
BaseAudioContext::WouldTaintOrigin. This CL also renames
URLData::has_opaque_data_ and its (direct and indirect) data accessors
to match the spec.

Bug: 849942, 875153
Change-Id: I6acf50169d7445c4ff614e80ac606f79ee577d2a
Reviewed-on: https://chromium-review.googlesource.com/c/1238098
Reviewed-by: Fredrik Hubinette <hubbe@chromium.org>
Reviewed-by: Kinuko Yasuda <kinuko@chromium.org>
Reviewed-by: Raymond Toy <rtoy@chromium.org>
Commit-Queue: Yutaka Hirano <yhirano@chromium.org>
Cr-Commit-Position: refs/heads/master@{#598258}",0,content/renderer/media/stream/webmediaplayer_ms.cc,"{""sha"": ""78ca5e2c3c323cf55e23eacc262e8a197e60b63b"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 11, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -844,21 +844,11 @@ void WebMediaPlayerMS::Paint(cc::PaintCanvas* canvas,\n                         context_3d, context_support);\n }\n \n-bool WebMediaPlayerMS::DidGetOpaqueResponseFromServiceWorker() const {\n+bool WebMediaPlayerMS::WouldTaintOrigin() const {\n   DCHECK(thread_checker_.CalledOnValidThread());\n   return false;\n }\n \n-bool WebMediaPlayerMS::HasSingleSecurityOrigin() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n-bool WebMediaPlayerMS::DidPassCORSAccessCheck() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n double WebMediaPlayerMS::MediaTimeForTimeValue(double timeValue) const {\n   return base::TimeDelta::FromSecondsD(timeValue).InSecondsF();\n }""}<_**next**_>{""sha"": ""8c3595505cb20fa379b861f49b28710c40f3a5f1"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -163,9 +163,7 @@ class CONTENT_EXPORT WebMediaPlayerMS\n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n \n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n ""}<_**next**_>{""sha"": ""d26bc8142d80dc7c64958a9c22170244d6e664dd"", ""filename"": ""content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -76,9 +76,7 @@ class MockWebMediaPlayer : public blink::WebMediaPlayer,\n   }\n \n   bool DidLoadingProgress() override { return true; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double timeValue) const override { return 0.0; }\n   unsigned DecodedFrameCount() const override { return 0; }\n   unsigned DroppedFrameCount() const override { return 0; }""}<_**next**_>{""sha"": ""74ad44546ee34afa79b4a1649710117f8532c5f4"", ""filename"": ""media/blink/multibuffer_data_source.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 19, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -286,23 +286,8 @@ bool MultibufferDataSource::HasSingleOrigin() {\n   return single_origin_;\n }\n \n-bool MultibufferDataSource::DidPassCORSAccessCheck() const {\n-  if (url_data()->cors_mode() == UrlData::CORS_UNSPECIFIED)\n-    return false;\n-\n-  // If init_cb is set, we know initialization is not finished yet.\n-  if (init_cb_)\n-    return false;\n-  if (failed_)\n-    return false;\n-  return true;\n-}\n-\n-bool MultibufferDataSource::DidGetOpaqueResponseViaServiceWorker() const {\n-  return url_data()->has_opaque_data();\n-\n-  // TODO(falken): Do we need to do something about |init_cb_| like\n-  // in DidPassCORSAccessCheck()?\n+bool MultibufferDataSource::IsCorsCrossOrigin() const {\n+  return url_data()->is_cors_cross_origin();\n }\n \n void MultibufferDataSource::MediaPlaybackRateChanged(double playback_rate) {\n@@ -627,8 +612,6 @@ void MultibufferDataSource::StartCallback() {\n     // Progress callback might be called after the start callback,\n     // make sure that we update single_origin_ now.\n     media_log_->SetBooleanProperty(\""single_origin\"", single_origin_);\n-    media_log_->SetBooleanProperty(\""passed_cors_access_check\"",\n-                                   DidPassCORSAccessCheck());\n     media_log_->SetBooleanProperty(\""range_header_supported\"",\n                                    url_data()->range_supported());\n   }""}<_**next**_>{""sha"": ""4da62a5519e33ab6e726406f0acac4995c4ad49f"", ""filename"": ""media/blink/multibuffer_data_source.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 6, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -79,12 +79,9 @@ class MEDIA_BLINK_EXPORT MultibufferDataSource : public DataSource {\n   // Method called on the render thread.\n   bool HasSingleOrigin();\n \n-  // Returns true if the media resource passed a CORS access control check.\n-  bool DidPassCORSAccessCheck() const;\n-\n-  // Returns true if a service worker provided the media resource response,\n-  // and the response was opaque.\n-  bool DidGetOpaqueResponseViaServiceWorker() const;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  // This must be called after the response arrives.\n+  bool IsCorsCrossOrigin() const;\n \n   // Notifies changes in playback state for controlling media buffering\n   // behavior.""}<_**next**_>{""sha"": ""4b9f83e74255bf14d33c3f0c2785c282ecb2bcd7"", ""filename"": ""media/blink/multibuffer_data_source_unittest.cc"", ""status"": ""modified"", ""additions"": 81, ""deletions"": 12, ""changes"": 93, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1493,35 +1493,104 @@ TEST_F(MultibufferDataSourceTest, FileSizeLessThanBlockSize) {\n   Stop();\n }\n \n-TEST_F(MultibufferDataSourceTest, DidPassCORSAccessTest) {\n+TEST_F(MultibufferDataSourceTest, ResponseTypeBasic) {\n   InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n   set_preload(MultibufferDataSource::NONE);\n   WebURLResponse response1 =\n       response_generator_->GeneratePartial206(0, kDataSize - 1);\n-  response1.SetWasFetchedViaServiceWorker(true);\n-  std::vector<blink::WebURL> urlList = {GURL(kHttpDifferentOriginUrl)};\n-  response1.SetURLListViaServiceWorker(urlList);\n-  WebURLResponse response2 =\n-      response_generator_->GeneratePartial206(kDataSize, kDataSize * 2 - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kBasic);\n \n   EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n   EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n   EXPECT_CALL(*this, ReadCallback(kDataSize));\n \n-  EXPECT_FALSE(data_source_->DidPassCORSAccessCheck());\n   Respond(response1);\n   ReceiveData(kDataSize);\n   ReadAt(0);\n   EXPECT_TRUE(loading());\n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n   FinishLoading();\n+}\n \n-  // Verify that if reader_ is null, DidPassCORSAccessCheck still returns true.\n-  data_source_->Stop();\n-  base::RunLoop().RunUntilIdle();\n+TEST_F(MultibufferDataSourceTest, ResponseTypeCors) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kCORS);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeDefault) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kDefault);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaque) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaque);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaqueRedirect) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaqueRedirect);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n }\n \n TEST_F(MultibufferDataSourceTest, EtagTest) {""}<_**next**_>{""sha"": ""89f1c9e70d2cc71646df50026b50d54d471d20c6"", ""filename"": ""media/blink/resource_multibuffer_data_provider.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/resource_multibuffer_data_provider.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -280,6 +280,8 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n   int64_t content_length = response.ExpectedContentLength();\n   bool end_of_file = false;\n   bool do_fail = false;\n+  // We get the response type here because aborting the loader may change it.\n+  const auto response_type = response.GetType();\n   bytes_to_discard_ = 0;\n \n   // We make a strong assumption that when we reach here we have either\n@@ -333,10 +335,9 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n         url_data_->url_index()->TryInsert(destination_url_data);\n   }\n \n-  // This is vital for security! A service worker can respond with a response\n-  // from a different origin, so this response type is needed to detect that.\n-  destination_url_data->set_has_opaque_data(\n-      network::cors::IsCORSCrossOriginResponseType(response.GetType()));\n+  // This is vital for security!\n+  destination_url_data->set_is_cors_cross_origin(\n+      network::cors::IsCORSCrossOriginResponseType(response_type));\n \n   if (destination_url_data != url_data_) {\n     // At this point, we've encountered a redirect, or found a better url data""}<_**next**_>{""sha"": ""3fb63497791a3d2a0ea1e3b12c018f4b2c5fe355"", ""filename"": ""media/blink/url_index.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 7, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -65,7 +65,6 @@ UrlData::UrlData(const GURL& url, CORSMode cors_mode, UrlIndex* url_index)\n       length_(kPositionNotSpecified),\n       range_supported_(false),\n       cacheable_(false),\n-      has_opaque_data_(false),\n       last_used_(),\n       multibuffer_(this, url_index_->block_shift_) {}\n \n@@ -103,9 +102,8 @@ void UrlData::MergeFrom(const scoped_refptr<UrlData>& other) {\n       last_modified_ = other->last_modified_;\n     }\n     bytes_read_from_cache_ += other->bytes_read_from_cache_;\n-    // set_has_opaque_data() will not relax from opaque to non-opaque if already\n-    // opaque.\n-    set_has_opaque_data(other->has_opaque_data_);\n+    // is_cors_corss_origin_ will not relax from true to false.\n+    set_is_cors_cross_origin(other->is_cors_cross_origin_);\n     multibuffer()->MergeFrom(other->multibuffer());\n   }\n }\n@@ -122,10 +120,10 @@ void UrlData::set_length(int64_t length) {\n   }\n }\n \n-void UrlData::set_has_opaque_data(bool has_opaque_data) {\n-  if (has_opaque_data_)\n+void UrlData::set_is_cors_cross_origin(bool is_cors_cross_origin) {\n+  if (is_cors_cross_origin_)\n     return;\n-  has_opaque_data_ = has_opaque_data;\n+  is_cors_cross_origin_ = is_cors_cross_origin;\n }\n \n void UrlData::RedirectTo(const scoped_refptr<UrlData>& url_data) {""}<_**next**_>{""sha"": ""2c15bc7ac0ad4489a0c922f614889e575bd5d863"", ""filename"": ""media/blink/url_index.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -125,7 +125,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // Returns our url_index.\n   UrlIndex* url_index() const { return url_index_; }\n \n-  bool has_opaque_data() const { return has_opaque_data_; }\n+  // This must be called after the response arrives.\n+  bool is_cors_cross_origin() const { return is_cors_cross_origin_; }\n \n   // Notifies the url index that this is currently used.\n   // The url <-> URLData mapping will be eventually be invalidated if\n@@ -145,7 +146,7 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   void set_range_supported();\n   void set_last_modified(base::Time last_modified);\n   void set_etag(const std::string& etag);\n-  void set_has_opaque_data(bool has_opaque_data);\n+  void set_is_cors_cross_origin(bool is_cors_cross_origin);\n \n   // A redirect has occured (or we've found a better UrlData for the same\n   // resource).\n@@ -238,9 +239,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // will not cache this url.\n   bool cacheable_;\n \n-  // True if a service worker intercepted a request for this resource\n-  // and provided an opaque response.\n-  bool has_opaque_data_;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  bool is_cors_cross_origin_ = false;\n \n   // Last time some media time used this resource.\n   // Note that we use base::Time rather than base::TimeTicks because""}<_**next**_>{""sha"": ""cf0857d8c6283758b159609f76da1bafb19cc789"", ""filename"": ""media/blink/webmediaplayer_impl.cc"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 10, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1175,12 +1175,6 @@ void WebMediaPlayerImpl::Paint(cc::PaintCanvas* canvas,\n       context_support);\n }\n \n-bool WebMediaPlayerImpl::DidGetOpaqueResponseFromServiceWorker() const {\n-  if (data_source_)\n-    return data_source_->DidGetOpaqueResponseViaServiceWorker();\n-  return false;\n-}\n-\n bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   if (demuxer_found_hls_) {\n     // HLS manifests might pull segments from a different origin. We can't know\n@@ -1193,10 +1187,15 @@ bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   return true;\n }\n \n-bool WebMediaPlayerImpl::DidPassCORSAccessCheck() const {\n-  if (data_source_)\n-    return data_source_->DidPassCORSAccessCheck();\n-  return false;\n+bool WebMediaPlayerImpl::WouldTaintOrigin() const {\n+  if (!HasSingleSecurityOrigin()) {\n+    // When the resource is redirected to another origin we think it as\n+    // tainted. This is actually not specified, and is under discussion.\n+    // See https://github.com/whatwg/fetch/issues/737.\n+    return true;\n+  }\n+\n+  return data_source_ && data_source_->IsCorsCrossOrigin();\n }\n \n double WebMediaPlayerImpl::MediaTimeForTimeValue(double timeValue) const {""}<_**next**_>{""sha"": ""233e37b4614544e9b2a67b4e5edee775de0f79a6"", ""filename"": ""media/blink/webmediaplayer_impl.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -188,10 +188,7 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n \n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n-\n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n \n@@ -332,6 +329,8 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n   void OnPipelineResumed();\n   void OnDemuxerOpened();\n \n+  bool HasSingleSecurityOrigin() const;\n+\n   // Pipeline::Client overrides.\n   void OnError(PipelineStatus status) override;\n   void OnEnded() override;""}<_**next**_>{""sha"": ""9821759bc7b311672a54387edc7d8c26a11d5e54"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""status"": ""added"", ""additions"": 47, ""deletions"": 0, ""changes"": 47, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -0,0 +1,47 @@\n+<!doctype html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+<script src=\""/common/get-host-info.sub.js\""></script>\n+<script src=\""resources/test-helpers.sub.js?pipe=sub\""></script>\n+<script>\n+promise_test(async (t) => {\n+    const SCOPE = 'resources/empty.html';\n+    const SCRIPT = 'resources/fetch-rewrite-worker.js';\n+    const host_info = get_host_info();\n+    const REMOTE_ORIGIN = host_info.HTTPS_REMOTE_ORIGIN;\n+\n+    const reg = await service_worker_unregister_and_register(t, SCRIPT, SCOPE);\n+    await wait_for_state(t, reg.installing, 'activated');\n+    const frame = await with_iframe(SCOPE);\n+\n+    const doc = frame.contentDocument;\n+    const win = frame.contentWindow;\n+\n+    const context = new win.AudioContext();\n+    try {\n+      context.suspend();\n+      const audio = doc.createElement('audio');\n+      audio.autoplay = true;\n+      const source = context.createMediaElementSource(audio);\n+      const spn = context.createScriptProcessor(16384, 1, 1);\n+      source.connect(spn).connect(context.destination);\n+      const url = `${REMOTE_ORIGIN}/webaudio/resources/sin_440Hz_-6dBFS_1s.wav`;\n+      audio.src = '/test?url=' + encodeURIComponent(url);\n+      doc.body.appendChild(audio);\n+\n+      await new Promise((resolve) => {\n+        audio.addEventListener('playing', resolve);\n+      });\n+      await context.resume();\n+      const event = await new Promise((resolve) => {\n+        spn.addEventListener('audioprocess', resolve);\n+      });\n+      const data = event.inputBuffer.getChannelData(0);\n+      for (const e of data) {\n+        assert_equals(e, 0);\n+      }\n+    } finally {\n+      context.close();\n+    }\n+  }, 'Verify CORS XHR of fetch() in a Service Worker');\n+</script>""}<_**next**_>{""sha"": ""319648dbc16669ab3b3238d8488997b7d3a7c837"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""58697c0661a94d03e4bbe74134a23e71a860f5f6"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""a1e82caf7e2f9d37d785165a4766f42acb28c465"", ""filename"": ""third_party/blink/public/platform/web_media_player.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/public/platform/web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -207,9 +207,10 @@ class WebMediaPlayer {\n \n   virtual bool DidLoadingProgress() = 0;\n \n-  virtual bool DidGetOpaqueResponseFromServiceWorker() const = 0;\n-  virtual bool HasSingleSecurityOrigin() const = 0;\n-  virtual bool DidPassCORSAccessCheck() const = 0;\n+  // Returns true if the response is CORS-cross-origin and so we shouldn't be\n+  // allowing media to play through webaudio.\n+  // This should be called after the response has arrived.\n+  virtual bool WouldTaintOrigin() const = 0;\n \n   virtual double MediaTimeForTimeValue(double time_value) const = 0;\n ""}<_**next**_>{""sha"": ""ad708c861bb80cd8a01217eec51f9fe058af4a33"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 21, ""changes"": 26, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1506,30 +1506,14 @@ bool HTMLMediaElement::IsSafeToLoadURL(const KURL& url,\n \n bool HTMLMediaElement::IsMediaDataCORSSameOrigin(\n     const SecurityOrigin* origin) const {\n-  // If a service worker handled the request, we don't know if the origin in the\n-  // src is the same as the actual response URL so can't rely on URL checks\n-  // alone. So detect an opaque response via\n-  // DidGetOpaqueResponseFromServiceWorker().\n-  if (GetWebMediaPlayer() &&\n-      GetWebMediaPlayer()->DidGetOpaqueResponseFromServiceWorker()) {\n-    return false;\n-  }\n-\n-  // At this point, either a service worker was not used, or it didn't provide\n-  // an opaque response, so continue with the normal checks.\n+  if (!GetWebMediaPlayer())\n+    return true;\n \n-  // HasSingleSecurityOrigin() tells us whether the origin in the src\n-  // is the same as the actual request (i.e. after redirects).\n-  if (!HasSingleSecurityOrigin())\n+  const auto network_state = GetWebMediaPlayer()->GetNetworkState();\n+  if (network_state == WebMediaPlayer::kNetworkStateNetworkError)\n     return false;\n \n-  // DidPassCORSAccessCheck() means it was a successful CORS-enabled fetch (vs.\n-  // non-CORS-enabled or failed). CanReadContent() does CheckAccess() on the\n-  // URL plus allows data sources, to ensure that it is not a URL that requires\n-  // CORS (basically same origin).\n-  return (GetWebMediaPlayer() &&\n-          GetWebMediaPlayer()->DidPassCORSAccessCheck()) ||\n-         origin->CanReadContent(currentSrc());\n+  return !GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n bool HTMLMediaElement::IsInCrossOriginFrame() const {""}<_**next**_>{""sha"": ""f2d50264a53a0a3002725b06b6363091f4e17faa"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -268,11 +268,6 @@ class CORE_EXPORT HTMLMediaElement\n   // of one of them here.\n   using HTMLElement::GetExecutionContext;\n \n-  bool HasSingleSecurityOrigin() const {\n-    return GetWebMediaPlayer() ? GetWebMediaPlayer()->HasSingleSecurityOrigin()\n-                               : true;\n-  }\n-\n   bool IsFullscreen() const;\n   virtual bool UsesOverlayFullscreenVideo() const { return false; }\n ""}<_**next**_>{""sha"": ""8cf3a926979a853d0ba0f48f9def6bc9b4aec36a"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 17, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -958,21 +958,4 @@ void BaseAudioContext::UpdateWorkletGlobalScopeOnRenderingThread() {\n   }\n }\n \n-bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {\n-  // Data URLs don't taint the origin.\n-  if (url.ProtocolIsData()) {\n-    return false;\n-  }\n-\n-  Document* document = GetDocument();\n-  if (document && document->GetSecurityOrigin()) {\n-    // The origin is tainted if and only if we cannot read content from the URL.\n-    return !document->GetSecurityOrigin()->CanRequest(url);\n-  }\n-\n-  // Be conservative and assume it's tainted if it's not a data url and if we\n-  // can't get the security origin of the document.\n-  return true;\n-}\n-\n }  // namespace blink""}<_**next**_>{""sha"": ""ae933f20167fb374b51ff5a869d9381f97b56d4b"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -296,13 +296,6 @@ class MODULES_EXPORT BaseAudioContext\n   // Does nothing when the worklet global scope does not exist.\n   void UpdateWorkletGlobalScopeOnRenderingThread();\n \n-  // Returns true if the URL would taint the origin so that we shouldn't be\n-  // allowing media to played through webaudio.\n-  // TODO(crbug.com/845913): This should really be on an AudioContext.  Move\n-  // this when we move the media stuff from BaseAudioContext to AudioContext, as\n-  // requried by the spec.\n-  bool WouldTaintOrigin(const KURL& url) const;\n-\n  protected:\n   enum ContextType { kRealtimeContext, kOfflineContext };\n ""}<_**next**_>{""sha"": ""d7b07b5fea75809b4e14c8fda74b38a1d48e6b9d"", ""filename"": ""third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 13, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -136,19 +136,7 @@ void MediaElementAudioSourceHandler::SetFormat(size_t number_of_channels,\n }\n \n bool MediaElementAudioSourceHandler::WouldTaintOrigin() {\n-  // If we're cross-origin and allowed access vie CORS, we're not tainted.\n-  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {\n-    return false;\n-  }\n-\n-  // Handles the case where the url is a redirect to another site that we're not\n-  // allowed to access.\n-  if (!MediaElement()->HasSingleSecurityOrigin()) {\n-    return true;\n-  }\n-\n-  // Test to see if the current media URL taint the origin of the audio context?\n-  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());\n+  return MediaElement()->GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n void MediaElementAudioSourceHandler::PrintCORSMessage(const String& message) {""}<_**next**_>{""sha"": ""6e5771836bf84527d922a6c5fc84a3aa5c8c9bce"", ""filename"": ""third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/testing/empty_web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -50,9 +50,7 @@ class EmptyWebMediaPlayer : public WebMediaPlayer {\n   ReadyState GetReadyState() const override { return kReadyStateHaveNothing; }\n   WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override { return false; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double time_value) const override {\n     return time_value;\n   };""}","bool WebMediaPlayerMS::DidGetOpaqueResponseFromServiceWorker() const {
bool WebMediaPlayerMS::WouldTaintOrigin() const {
   DCHECK(thread_checker_.CalledOnValidThread());
   return false;
 }
","bool WebMediaPlayerMS::DidGetOpaqueResponseFromServiceWorker() const {
   DCHECK(thread_checker_.CalledOnValidThread());
   return false;
 }
",C,"bool WebMediaPlayerMS::WouldTaintOrigin() const {
",,,"@@ -844,21 +844,11 @@ void WebMediaPlayerMS::Paint(cc::PaintCanvas* canvas,
                         context_3d, context_support);
 }
 
-bool WebMediaPlayerMS::DidGetOpaqueResponseFromServiceWorker() const {
+bool WebMediaPlayerMS::WouldTaintOrigin() const {
   DCHECK(thread_checker_.CalledOnValidThread());
   return false;
 }
 
-bool WebMediaPlayerMS::HasSingleSecurityOrigin() const {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  return true;
-}
-
-bool WebMediaPlayerMS::DidPassCORSAccessCheck() const {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  return true;
-}
-
 double WebMediaPlayerMS::MediaTimeForTimeValue(double timeValue) const {
   return base::TimeDelta::FromSecondsD(timeValue).InSecondsF();
 }",Chrome,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,50436d878b2e92de4231fda47328a8a4e884ecc3,1,"bool WebMediaPlayerMS::DidGetOpaqueResponseFromServiceWorker() const {
//fix_flaw_line_below:
//bool WebMediaPlayerMS::WouldTaintOrigin() const {
   DCHECK(thread_checker_.CalledOnValidThread());
   return false;
 }
"
8862,186598,,Remote,Not required,,CVE-2018-18352,https://www.cvedetails.com/cve/CVE-2018-18352/,CWE-732,Medium,Partial,,,2018-12-11,4.3,Service works could inappropriately gain access to cross origin audio in Media in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to bypass same origin policy for audio content via a crafted HTML page.,2019-10-02,Bypass ,0,https://github.com/chromium/chromium/commit/a9cbaa7a40e2b2723cfc2f266c42f4980038a949,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,"Simplify ""WouldTaintOrigin"" concept in media/blink

Currently WebMediaPlayer has three predicates:
 - DidGetOpaqueResponseFromServiceWorker
 - HasSingleSecurityOrigin
 - DidPassCORSAccessCheck
. These are used to determine whether the response body is available
for scripts. They are known to be confusing, and actually
MediaElementAudioSourceHandler::WouldTaintOrigin misuses them.

This CL merges the three predicates to one, WouldTaintOrigin, to remove
the confusion. Now the ""response type"" concept is available and we
don't need a custom CORS check, so this CL removes
BaseAudioContext::WouldTaintOrigin. This CL also renames
URLData::has_opaque_data_ and its (direct and indirect) data accessors
to match the spec.

Bug: 849942, 875153
Change-Id: I6acf50169d7445c4ff614e80ac606f79ee577d2a
Reviewed-on: https://chromium-review.googlesource.com/c/1238098
Reviewed-by: Fredrik Hubinette <hubbe@chromium.org>
Reviewed-by: Kinuko Yasuda <kinuko@chromium.org>
Reviewed-by: Raymond Toy <rtoy@chromium.org>
Commit-Queue: Yutaka Hirano <yhirano@chromium.org>
Cr-Commit-Position: refs/heads/master@{#598258}",3,content/renderer/media/stream/webmediaplayer_ms.cc,"{""sha"": ""78ca5e2c3c323cf55e23eacc262e8a197e60b63b"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 11, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -844,21 +844,11 @@ void WebMediaPlayerMS::Paint(cc::PaintCanvas* canvas,\n                         context_3d, context_support);\n }\n \n-bool WebMediaPlayerMS::DidGetOpaqueResponseFromServiceWorker() const {\n+bool WebMediaPlayerMS::WouldTaintOrigin() const {\n   DCHECK(thread_checker_.CalledOnValidThread());\n   return false;\n }\n \n-bool WebMediaPlayerMS::HasSingleSecurityOrigin() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n-bool WebMediaPlayerMS::DidPassCORSAccessCheck() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n double WebMediaPlayerMS::MediaTimeForTimeValue(double timeValue) const {\n   return base::TimeDelta::FromSecondsD(timeValue).InSecondsF();\n }""}<_**next**_>{""sha"": ""8c3595505cb20fa379b861f49b28710c40f3a5f1"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -163,9 +163,7 @@ class CONTENT_EXPORT WebMediaPlayerMS\n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n \n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n ""}<_**next**_>{""sha"": ""d26bc8142d80dc7c64958a9c22170244d6e664dd"", ""filename"": ""content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -76,9 +76,7 @@ class MockWebMediaPlayer : public blink::WebMediaPlayer,\n   }\n \n   bool DidLoadingProgress() override { return true; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double timeValue) const override { return 0.0; }\n   unsigned DecodedFrameCount() const override { return 0; }\n   unsigned DroppedFrameCount() const override { return 0; }""}<_**next**_>{""sha"": ""74ad44546ee34afa79b4a1649710117f8532c5f4"", ""filename"": ""media/blink/multibuffer_data_source.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 19, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -286,23 +286,8 @@ bool MultibufferDataSource::HasSingleOrigin() {\n   return single_origin_;\n }\n \n-bool MultibufferDataSource::DidPassCORSAccessCheck() const {\n-  if (url_data()->cors_mode() == UrlData::CORS_UNSPECIFIED)\n-    return false;\n-\n-  // If init_cb is set, we know initialization is not finished yet.\n-  if (init_cb_)\n-    return false;\n-  if (failed_)\n-    return false;\n-  return true;\n-}\n-\n-bool MultibufferDataSource::DidGetOpaqueResponseViaServiceWorker() const {\n-  return url_data()->has_opaque_data();\n-\n-  // TODO(falken): Do we need to do something about |init_cb_| like\n-  // in DidPassCORSAccessCheck()?\n+bool MultibufferDataSource::IsCorsCrossOrigin() const {\n+  return url_data()->is_cors_cross_origin();\n }\n \n void MultibufferDataSource::MediaPlaybackRateChanged(double playback_rate) {\n@@ -627,8 +612,6 @@ void MultibufferDataSource::StartCallback() {\n     // Progress callback might be called after the start callback,\n     // make sure that we update single_origin_ now.\n     media_log_->SetBooleanProperty(\""single_origin\"", single_origin_);\n-    media_log_->SetBooleanProperty(\""passed_cors_access_check\"",\n-                                   DidPassCORSAccessCheck());\n     media_log_->SetBooleanProperty(\""range_header_supported\"",\n                                    url_data()->range_supported());\n   }""}<_**next**_>{""sha"": ""4da62a5519e33ab6e726406f0acac4995c4ad49f"", ""filename"": ""media/blink/multibuffer_data_source.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 6, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -79,12 +79,9 @@ class MEDIA_BLINK_EXPORT MultibufferDataSource : public DataSource {\n   // Method called on the render thread.\n   bool HasSingleOrigin();\n \n-  // Returns true if the media resource passed a CORS access control check.\n-  bool DidPassCORSAccessCheck() const;\n-\n-  // Returns true if a service worker provided the media resource response,\n-  // and the response was opaque.\n-  bool DidGetOpaqueResponseViaServiceWorker() const;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  // This must be called after the response arrives.\n+  bool IsCorsCrossOrigin() const;\n \n   // Notifies changes in playback state for controlling media buffering\n   // behavior.""}<_**next**_>{""sha"": ""4b9f83e74255bf14d33c3f0c2785c282ecb2bcd7"", ""filename"": ""media/blink/multibuffer_data_source_unittest.cc"", ""status"": ""modified"", ""additions"": 81, ""deletions"": 12, ""changes"": 93, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1493,35 +1493,104 @@ TEST_F(MultibufferDataSourceTest, FileSizeLessThanBlockSize) {\n   Stop();\n }\n \n-TEST_F(MultibufferDataSourceTest, DidPassCORSAccessTest) {\n+TEST_F(MultibufferDataSourceTest, ResponseTypeBasic) {\n   InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n   set_preload(MultibufferDataSource::NONE);\n   WebURLResponse response1 =\n       response_generator_->GeneratePartial206(0, kDataSize - 1);\n-  response1.SetWasFetchedViaServiceWorker(true);\n-  std::vector<blink::WebURL> urlList = {GURL(kHttpDifferentOriginUrl)};\n-  response1.SetURLListViaServiceWorker(urlList);\n-  WebURLResponse response2 =\n-      response_generator_->GeneratePartial206(kDataSize, kDataSize * 2 - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kBasic);\n \n   EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n   EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n   EXPECT_CALL(*this, ReadCallback(kDataSize));\n \n-  EXPECT_FALSE(data_source_->DidPassCORSAccessCheck());\n   Respond(response1);\n   ReceiveData(kDataSize);\n   ReadAt(0);\n   EXPECT_TRUE(loading());\n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n   FinishLoading();\n+}\n \n-  // Verify that if reader_ is null, DidPassCORSAccessCheck still returns true.\n-  data_source_->Stop();\n-  base::RunLoop().RunUntilIdle();\n+TEST_F(MultibufferDataSourceTest, ResponseTypeCors) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kCORS);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeDefault) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kDefault);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaque) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaque);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaqueRedirect) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaqueRedirect);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n }\n \n TEST_F(MultibufferDataSourceTest, EtagTest) {""}<_**next**_>{""sha"": ""89f1c9e70d2cc71646df50026b50d54d471d20c6"", ""filename"": ""media/blink/resource_multibuffer_data_provider.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/resource_multibuffer_data_provider.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -280,6 +280,8 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n   int64_t content_length = response.ExpectedContentLength();\n   bool end_of_file = false;\n   bool do_fail = false;\n+  // We get the response type here because aborting the loader may change it.\n+  const auto response_type = response.GetType();\n   bytes_to_discard_ = 0;\n \n   // We make a strong assumption that when we reach here we have either\n@@ -333,10 +335,9 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n         url_data_->url_index()->TryInsert(destination_url_data);\n   }\n \n-  // This is vital for security! A service worker can respond with a response\n-  // from a different origin, so this response type is needed to detect that.\n-  destination_url_data->set_has_opaque_data(\n-      network::cors::IsCORSCrossOriginResponseType(response.GetType()));\n+  // This is vital for security!\n+  destination_url_data->set_is_cors_cross_origin(\n+      network::cors::IsCORSCrossOriginResponseType(response_type));\n \n   if (destination_url_data != url_data_) {\n     // At this point, we've encountered a redirect, or found a better url data""}<_**next**_>{""sha"": ""3fb63497791a3d2a0ea1e3b12c018f4b2c5fe355"", ""filename"": ""media/blink/url_index.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 7, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -65,7 +65,6 @@ UrlData::UrlData(const GURL& url, CORSMode cors_mode, UrlIndex* url_index)\n       length_(kPositionNotSpecified),\n       range_supported_(false),\n       cacheable_(false),\n-      has_opaque_data_(false),\n       last_used_(),\n       multibuffer_(this, url_index_->block_shift_) {}\n \n@@ -103,9 +102,8 @@ void UrlData::MergeFrom(const scoped_refptr<UrlData>& other) {\n       last_modified_ = other->last_modified_;\n     }\n     bytes_read_from_cache_ += other->bytes_read_from_cache_;\n-    // set_has_opaque_data() will not relax from opaque to non-opaque if already\n-    // opaque.\n-    set_has_opaque_data(other->has_opaque_data_);\n+    // is_cors_corss_origin_ will not relax from true to false.\n+    set_is_cors_cross_origin(other->is_cors_cross_origin_);\n     multibuffer()->MergeFrom(other->multibuffer());\n   }\n }\n@@ -122,10 +120,10 @@ void UrlData::set_length(int64_t length) {\n   }\n }\n \n-void UrlData::set_has_opaque_data(bool has_opaque_data) {\n-  if (has_opaque_data_)\n+void UrlData::set_is_cors_cross_origin(bool is_cors_cross_origin) {\n+  if (is_cors_cross_origin_)\n     return;\n-  has_opaque_data_ = has_opaque_data;\n+  is_cors_cross_origin_ = is_cors_cross_origin;\n }\n \n void UrlData::RedirectTo(const scoped_refptr<UrlData>& url_data) {""}<_**next**_>{""sha"": ""2c15bc7ac0ad4489a0c922f614889e575bd5d863"", ""filename"": ""media/blink/url_index.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -125,7 +125,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // Returns our url_index.\n   UrlIndex* url_index() const { return url_index_; }\n \n-  bool has_opaque_data() const { return has_opaque_data_; }\n+  // This must be called after the response arrives.\n+  bool is_cors_cross_origin() const { return is_cors_cross_origin_; }\n \n   // Notifies the url index that this is currently used.\n   // The url <-> URLData mapping will be eventually be invalidated if\n@@ -145,7 +146,7 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   void set_range_supported();\n   void set_last_modified(base::Time last_modified);\n   void set_etag(const std::string& etag);\n-  void set_has_opaque_data(bool has_opaque_data);\n+  void set_is_cors_cross_origin(bool is_cors_cross_origin);\n \n   // A redirect has occured (or we've found a better UrlData for the same\n   // resource).\n@@ -238,9 +239,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // will not cache this url.\n   bool cacheable_;\n \n-  // True if a service worker intercepted a request for this resource\n-  // and provided an opaque response.\n-  bool has_opaque_data_;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  bool is_cors_cross_origin_ = false;\n \n   // Last time some media time used this resource.\n   // Note that we use base::Time rather than base::TimeTicks because""}<_**next**_>{""sha"": ""cf0857d8c6283758b159609f76da1bafb19cc789"", ""filename"": ""media/blink/webmediaplayer_impl.cc"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 10, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1175,12 +1175,6 @@ void WebMediaPlayerImpl::Paint(cc::PaintCanvas* canvas,\n       context_support);\n }\n \n-bool WebMediaPlayerImpl::DidGetOpaqueResponseFromServiceWorker() const {\n-  if (data_source_)\n-    return data_source_->DidGetOpaqueResponseViaServiceWorker();\n-  return false;\n-}\n-\n bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   if (demuxer_found_hls_) {\n     // HLS manifests might pull segments from a different origin. We can't know\n@@ -1193,10 +1187,15 @@ bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   return true;\n }\n \n-bool WebMediaPlayerImpl::DidPassCORSAccessCheck() const {\n-  if (data_source_)\n-    return data_source_->DidPassCORSAccessCheck();\n-  return false;\n+bool WebMediaPlayerImpl::WouldTaintOrigin() const {\n+  if (!HasSingleSecurityOrigin()) {\n+    // When the resource is redirected to another origin we think it as\n+    // tainted. This is actually not specified, and is under discussion.\n+    // See https://github.com/whatwg/fetch/issues/737.\n+    return true;\n+  }\n+\n+  return data_source_ && data_source_->IsCorsCrossOrigin();\n }\n \n double WebMediaPlayerImpl::MediaTimeForTimeValue(double timeValue) const {""}<_**next**_>{""sha"": ""233e37b4614544e9b2a67b4e5edee775de0f79a6"", ""filename"": ""media/blink/webmediaplayer_impl.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -188,10 +188,7 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n \n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n-\n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n \n@@ -332,6 +329,8 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n   void OnPipelineResumed();\n   void OnDemuxerOpened();\n \n+  bool HasSingleSecurityOrigin() const;\n+\n   // Pipeline::Client overrides.\n   void OnError(PipelineStatus status) override;\n   void OnEnded() override;""}<_**next**_>{""sha"": ""9821759bc7b311672a54387edc7d8c26a11d5e54"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""status"": ""added"", ""additions"": 47, ""deletions"": 0, ""changes"": 47, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -0,0 +1,47 @@\n+<!doctype html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+<script src=\""/common/get-host-info.sub.js\""></script>\n+<script src=\""resources/test-helpers.sub.js?pipe=sub\""></script>\n+<script>\n+promise_test(async (t) => {\n+    const SCOPE = 'resources/empty.html';\n+    const SCRIPT = 'resources/fetch-rewrite-worker.js';\n+    const host_info = get_host_info();\n+    const REMOTE_ORIGIN = host_info.HTTPS_REMOTE_ORIGIN;\n+\n+    const reg = await service_worker_unregister_and_register(t, SCRIPT, SCOPE);\n+    await wait_for_state(t, reg.installing, 'activated');\n+    const frame = await with_iframe(SCOPE);\n+\n+    const doc = frame.contentDocument;\n+    const win = frame.contentWindow;\n+\n+    const context = new win.AudioContext();\n+    try {\n+      context.suspend();\n+      const audio = doc.createElement('audio');\n+      audio.autoplay = true;\n+      const source = context.createMediaElementSource(audio);\n+      const spn = context.createScriptProcessor(16384, 1, 1);\n+      source.connect(spn).connect(context.destination);\n+      const url = `${REMOTE_ORIGIN}/webaudio/resources/sin_440Hz_-6dBFS_1s.wav`;\n+      audio.src = '/test?url=' + encodeURIComponent(url);\n+      doc.body.appendChild(audio);\n+\n+      await new Promise((resolve) => {\n+        audio.addEventListener('playing', resolve);\n+      });\n+      await context.resume();\n+      const event = await new Promise((resolve) => {\n+        spn.addEventListener('audioprocess', resolve);\n+      });\n+      const data = event.inputBuffer.getChannelData(0);\n+      for (const e of data) {\n+        assert_equals(e, 0);\n+      }\n+    } finally {\n+      context.close();\n+    }\n+  }, 'Verify CORS XHR of fetch() in a Service Worker');\n+</script>""}<_**next**_>{""sha"": ""319648dbc16669ab3b3238d8488997b7d3a7c837"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""58697c0661a94d03e4bbe74134a23e71a860f5f6"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""a1e82caf7e2f9d37d785165a4766f42acb28c465"", ""filename"": ""third_party/blink/public/platform/web_media_player.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/public/platform/web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -207,9 +207,10 @@ class WebMediaPlayer {\n \n   virtual bool DidLoadingProgress() = 0;\n \n-  virtual bool DidGetOpaqueResponseFromServiceWorker() const = 0;\n-  virtual bool HasSingleSecurityOrigin() const = 0;\n-  virtual bool DidPassCORSAccessCheck() const = 0;\n+  // Returns true if the response is CORS-cross-origin and so we shouldn't be\n+  // allowing media to play through webaudio.\n+  // This should be called after the response has arrived.\n+  virtual bool WouldTaintOrigin() const = 0;\n \n   virtual double MediaTimeForTimeValue(double time_value) const = 0;\n ""}<_**next**_>{""sha"": ""ad708c861bb80cd8a01217eec51f9fe058af4a33"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 21, ""changes"": 26, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1506,30 +1506,14 @@ bool HTMLMediaElement::IsSafeToLoadURL(const KURL& url,\n \n bool HTMLMediaElement::IsMediaDataCORSSameOrigin(\n     const SecurityOrigin* origin) const {\n-  // If a service worker handled the request, we don't know if the origin in the\n-  // src is the same as the actual response URL so can't rely on URL checks\n-  // alone. So detect an opaque response via\n-  // DidGetOpaqueResponseFromServiceWorker().\n-  if (GetWebMediaPlayer() &&\n-      GetWebMediaPlayer()->DidGetOpaqueResponseFromServiceWorker()) {\n-    return false;\n-  }\n-\n-  // At this point, either a service worker was not used, or it didn't provide\n-  // an opaque response, so continue with the normal checks.\n+  if (!GetWebMediaPlayer())\n+    return true;\n \n-  // HasSingleSecurityOrigin() tells us whether the origin in the src\n-  // is the same as the actual request (i.e. after redirects).\n-  if (!HasSingleSecurityOrigin())\n+  const auto network_state = GetWebMediaPlayer()->GetNetworkState();\n+  if (network_state == WebMediaPlayer::kNetworkStateNetworkError)\n     return false;\n \n-  // DidPassCORSAccessCheck() means it was a successful CORS-enabled fetch (vs.\n-  // non-CORS-enabled or failed). CanReadContent() does CheckAccess() on the\n-  // URL plus allows data sources, to ensure that it is not a URL that requires\n-  // CORS (basically same origin).\n-  return (GetWebMediaPlayer() &&\n-          GetWebMediaPlayer()->DidPassCORSAccessCheck()) ||\n-         origin->CanReadContent(currentSrc());\n+  return !GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n bool HTMLMediaElement::IsInCrossOriginFrame() const {""}<_**next**_>{""sha"": ""f2d50264a53a0a3002725b06b6363091f4e17faa"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -268,11 +268,6 @@ class CORE_EXPORT HTMLMediaElement\n   // of one of them here.\n   using HTMLElement::GetExecutionContext;\n \n-  bool HasSingleSecurityOrigin() const {\n-    return GetWebMediaPlayer() ? GetWebMediaPlayer()->HasSingleSecurityOrigin()\n-                               : true;\n-  }\n-\n   bool IsFullscreen() const;\n   virtual bool UsesOverlayFullscreenVideo() const { return false; }\n ""}<_**next**_>{""sha"": ""8cf3a926979a853d0ba0f48f9def6bc9b4aec36a"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 17, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -958,21 +958,4 @@ void BaseAudioContext::UpdateWorkletGlobalScopeOnRenderingThread() {\n   }\n }\n \n-bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {\n-  // Data URLs don't taint the origin.\n-  if (url.ProtocolIsData()) {\n-    return false;\n-  }\n-\n-  Document* document = GetDocument();\n-  if (document && document->GetSecurityOrigin()) {\n-    // The origin is tainted if and only if we cannot read content from the URL.\n-    return !document->GetSecurityOrigin()->CanRequest(url);\n-  }\n-\n-  // Be conservative and assume it's tainted if it's not a data url and if we\n-  // can't get the security origin of the document.\n-  return true;\n-}\n-\n }  // namespace blink""}<_**next**_>{""sha"": ""ae933f20167fb374b51ff5a869d9381f97b56d4b"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -296,13 +296,6 @@ class MODULES_EXPORT BaseAudioContext\n   // Does nothing when the worklet global scope does not exist.\n   void UpdateWorkletGlobalScopeOnRenderingThread();\n \n-  // Returns true if the URL would taint the origin so that we shouldn't be\n-  // allowing media to played through webaudio.\n-  // TODO(crbug.com/845913): This should really be on an AudioContext.  Move\n-  // this when we move the media stuff from BaseAudioContext to AudioContext, as\n-  // requried by the spec.\n-  bool WouldTaintOrigin(const KURL& url) const;\n-\n  protected:\n   enum ContextType { kRealtimeContext, kOfflineContext };\n ""}<_**next**_>{""sha"": ""d7b07b5fea75809b4e14c8fda74b38a1d48e6b9d"", ""filename"": ""third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 13, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -136,19 +136,7 @@ void MediaElementAudioSourceHandler::SetFormat(size_t number_of_channels,\n }\n \n bool MediaElementAudioSourceHandler::WouldTaintOrigin() {\n-  // If we're cross-origin and allowed access vie CORS, we're not tainted.\n-  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {\n-    return false;\n-  }\n-\n-  // Handles the case where the url is a redirect to another site that we're not\n-  // allowed to access.\n-  if (!MediaElement()->HasSingleSecurityOrigin()) {\n-    return true;\n-  }\n-\n-  // Test to see if the current media URL taint the origin of the audio context?\n-  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());\n+  return MediaElement()->GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n void MediaElementAudioSourceHandler::PrintCORSMessage(const String& message) {""}<_**next**_>{""sha"": ""6e5771836bf84527d922a6c5fc84a3aa5c8c9bce"", ""filename"": ""third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/testing/empty_web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -50,9 +50,7 @@ class EmptyWebMediaPlayer : public WebMediaPlayer {\n   ReadyState GetReadyState() const override { return kReadyStateHaveNothing; }\n   WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override { return false; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double time_value) const override {\n     return time_value;\n   };""}","bool WebMediaPlayerMS::DidPassCORSAccessCheck() const {
","bool WebMediaPlayerMS::DidPassCORSAccessCheck() const {
  DCHECK(thread_checker_.CalledOnValidThread());
  return true;
}
",C,,"  DCHECK(thread_checker_.CalledOnValidThread());
  return true;
}
",,"@@ -844,21 +844,11 @@ void WebMediaPlayerMS::Paint(cc::PaintCanvas* canvas,
                         context_3d, context_support);
 }
 
-bool WebMediaPlayerMS::DidGetOpaqueResponseFromServiceWorker() const {
+bool WebMediaPlayerMS::WouldTaintOrigin() const {
   DCHECK(thread_checker_.CalledOnValidThread());
   return false;
 }
 
-bool WebMediaPlayerMS::HasSingleSecurityOrigin() const {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  return true;
-}
-
-bool WebMediaPlayerMS::DidPassCORSAccessCheck() const {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  return true;
-}
-
 double WebMediaPlayerMS::MediaTimeForTimeValue(double timeValue) const {
   return base::TimeDelta::FromSecondsD(timeValue).InSecondsF();
 }",Chrome,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,50436d878b2e92de4231fda47328a8a4e884ecc3,1,"bool WebMediaPlayerMS::DidPassCORSAccessCheck() const {
//flaw_line_below:
  DCHECK(thread_checker_.CalledOnValidThread());
//flaw_line_below:
  return true;
//flaw_line_below:
}
"
8863,186599,,Remote,Not required,,CVE-2018-18352,https://www.cvedetails.com/cve/CVE-2018-18352/,CWE-732,Medium,Partial,,,2018-12-11,4.3,Service works could inappropriately gain access to cross origin audio in Media in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to bypass same origin policy for audio content via a crafted HTML page.,2019-10-02,Bypass ,0,https://github.com/chromium/chromium/commit/a9cbaa7a40e2b2723cfc2f266c42f4980038a949,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,"Simplify ""WouldTaintOrigin"" concept in media/blink

Currently WebMediaPlayer has three predicates:
 - DidGetOpaqueResponseFromServiceWorker
 - HasSingleSecurityOrigin
 - DidPassCORSAccessCheck
. These are used to determine whether the response body is available
for scripts. They are known to be confusing, and actually
MediaElementAudioSourceHandler::WouldTaintOrigin misuses them.

This CL merges the three predicates to one, WouldTaintOrigin, to remove
the confusion. Now the ""response type"" concept is available and we
don't need a custom CORS check, so this CL removes
BaseAudioContext::WouldTaintOrigin. This CL also renames
URLData::has_opaque_data_ and its (direct and indirect) data accessors
to match the spec.

Bug: 849942, 875153
Change-Id: I6acf50169d7445c4ff614e80ac606f79ee577d2a
Reviewed-on: https://chromium-review.googlesource.com/c/1238098
Reviewed-by: Fredrik Hubinette <hubbe@chromium.org>
Reviewed-by: Kinuko Yasuda <kinuko@chromium.org>
Reviewed-by: Raymond Toy <rtoy@chromium.org>
Commit-Queue: Yutaka Hirano <yhirano@chromium.org>
Cr-Commit-Position: refs/heads/master@{#598258}",3,content/renderer/media/stream/webmediaplayer_ms.cc,"{""sha"": ""78ca5e2c3c323cf55e23eacc262e8a197e60b63b"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 11, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -844,21 +844,11 @@ void WebMediaPlayerMS::Paint(cc::PaintCanvas* canvas,\n                         context_3d, context_support);\n }\n \n-bool WebMediaPlayerMS::DidGetOpaqueResponseFromServiceWorker() const {\n+bool WebMediaPlayerMS::WouldTaintOrigin() const {\n   DCHECK(thread_checker_.CalledOnValidThread());\n   return false;\n }\n \n-bool WebMediaPlayerMS::HasSingleSecurityOrigin() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n-bool WebMediaPlayerMS::DidPassCORSAccessCheck() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n double WebMediaPlayerMS::MediaTimeForTimeValue(double timeValue) const {\n   return base::TimeDelta::FromSecondsD(timeValue).InSecondsF();\n }""}<_**next**_>{""sha"": ""8c3595505cb20fa379b861f49b28710c40f3a5f1"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -163,9 +163,7 @@ class CONTENT_EXPORT WebMediaPlayerMS\n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n \n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n ""}<_**next**_>{""sha"": ""d26bc8142d80dc7c64958a9c22170244d6e664dd"", ""filename"": ""content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -76,9 +76,7 @@ class MockWebMediaPlayer : public blink::WebMediaPlayer,\n   }\n \n   bool DidLoadingProgress() override { return true; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double timeValue) const override { return 0.0; }\n   unsigned DecodedFrameCount() const override { return 0; }\n   unsigned DroppedFrameCount() const override { return 0; }""}<_**next**_>{""sha"": ""74ad44546ee34afa79b4a1649710117f8532c5f4"", ""filename"": ""media/blink/multibuffer_data_source.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 19, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -286,23 +286,8 @@ bool MultibufferDataSource::HasSingleOrigin() {\n   return single_origin_;\n }\n \n-bool MultibufferDataSource::DidPassCORSAccessCheck() const {\n-  if (url_data()->cors_mode() == UrlData::CORS_UNSPECIFIED)\n-    return false;\n-\n-  // If init_cb is set, we know initialization is not finished yet.\n-  if (init_cb_)\n-    return false;\n-  if (failed_)\n-    return false;\n-  return true;\n-}\n-\n-bool MultibufferDataSource::DidGetOpaqueResponseViaServiceWorker() const {\n-  return url_data()->has_opaque_data();\n-\n-  // TODO(falken): Do we need to do something about |init_cb_| like\n-  // in DidPassCORSAccessCheck()?\n+bool MultibufferDataSource::IsCorsCrossOrigin() const {\n+  return url_data()->is_cors_cross_origin();\n }\n \n void MultibufferDataSource::MediaPlaybackRateChanged(double playback_rate) {\n@@ -627,8 +612,6 @@ void MultibufferDataSource::StartCallback() {\n     // Progress callback might be called after the start callback,\n     // make sure that we update single_origin_ now.\n     media_log_->SetBooleanProperty(\""single_origin\"", single_origin_);\n-    media_log_->SetBooleanProperty(\""passed_cors_access_check\"",\n-                                   DidPassCORSAccessCheck());\n     media_log_->SetBooleanProperty(\""range_header_supported\"",\n                                    url_data()->range_supported());\n   }""}<_**next**_>{""sha"": ""4da62a5519e33ab6e726406f0acac4995c4ad49f"", ""filename"": ""media/blink/multibuffer_data_source.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 6, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -79,12 +79,9 @@ class MEDIA_BLINK_EXPORT MultibufferDataSource : public DataSource {\n   // Method called on the render thread.\n   bool HasSingleOrigin();\n \n-  // Returns true if the media resource passed a CORS access control check.\n-  bool DidPassCORSAccessCheck() const;\n-\n-  // Returns true if a service worker provided the media resource response,\n-  // and the response was opaque.\n-  bool DidGetOpaqueResponseViaServiceWorker() const;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  // This must be called after the response arrives.\n+  bool IsCorsCrossOrigin() const;\n \n   // Notifies changes in playback state for controlling media buffering\n   // behavior.""}<_**next**_>{""sha"": ""4b9f83e74255bf14d33c3f0c2785c282ecb2bcd7"", ""filename"": ""media/blink/multibuffer_data_source_unittest.cc"", ""status"": ""modified"", ""additions"": 81, ""deletions"": 12, ""changes"": 93, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1493,35 +1493,104 @@ TEST_F(MultibufferDataSourceTest, FileSizeLessThanBlockSize) {\n   Stop();\n }\n \n-TEST_F(MultibufferDataSourceTest, DidPassCORSAccessTest) {\n+TEST_F(MultibufferDataSourceTest, ResponseTypeBasic) {\n   InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n   set_preload(MultibufferDataSource::NONE);\n   WebURLResponse response1 =\n       response_generator_->GeneratePartial206(0, kDataSize - 1);\n-  response1.SetWasFetchedViaServiceWorker(true);\n-  std::vector<blink::WebURL> urlList = {GURL(kHttpDifferentOriginUrl)};\n-  response1.SetURLListViaServiceWorker(urlList);\n-  WebURLResponse response2 =\n-      response_generator_->GeneratePartial206(kDataSize, kDataSize * 2 - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kBasic);\n \n   EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n   EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n   EXPECT_CALL(*this, ReadCallback(kDataSize));\n \n-  EXPECT_FALSE(data_source_->DidPassCORSAccessCheck());\n   Respond(response1);\n   ReceiveData(kDataSize);\n   ReadAt(0);\n   EXPECT_TRUE(loading());\n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n   FinishLoading();\n+}\n \n-  // Verify that if reader_ is null, DidPassCORSAccessCheck still returns true.\n-  data_source_->Stop();\n-  base::RunLoop().RunUntilIdle();\n+TEST_F(MultibufferDataSourceTest, ResponseTypeCors) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kCORS);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeDefault) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kDefault);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaque) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaque);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaqueRedirect) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaqueRedirect);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n }\n \n TEST_F(MultibufferDataSourceTest, EtagTest) {""}<_**next**_>{""sha"": ""89f1c9e70d2cc71646df50026b50d54d471d20c6"", ""filename"": ""media/blink/resource_multibuffer_data_provider.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/resource_multibuffer_data_provider.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -280,6 +280,8 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n   int64_t content_length = response.ExpectedContentLength();\n   bool end_of_file = false;\n   bool do_fail = false;\n+  // We get the response type here because aborting the loader may change it.\n+  const auto response_type = response.GetType();\n   bytes_to_discard_ = 0;\n \n   // We make a strong assumption that when we reach here we have either\n@@ -333,10 +335,9 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n         url_data_->url_index()->TryInsert(destination_url_data);\n   }\n \n-  // This is vital for security! A service worker can respond with a response\n-  // from a different origin, so this response type is needed to detect that.\n-  destination_url_data->set_has_opaque_data(\n-      network::cors::IsCORSCrossOriginResponseType(response.GetType()));\n+  // This is vital for security!\n+  destination_url_data->set_is_cors_cross_origin(\n+      network::cors::IsCORSCrossOriginResponseType(response_type));\n \n   if (destination_url_data != url_data_) {\n     // At this point, we've encountered a redirect, or found a better url data""}<_**next**_>{""sha"": ""3fb63497791a3d2a0ea1e3b12c018f4b2c5fe355"", ""filename"": ""media/blink/url_index.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 7, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -65,7 +65,6 @@ UrlData::UrlData(const GURL& url, CORSMode cors_mode, UrlIndex* url_index)\n       length_(kPositionNotSpecified),\n       range_supported_(false),\n       cacheable_(false),\n-      has_opaque_data_(false),\n       last_used_(),\n       multibuffer_(this, url_index_->block_shift_) {}\n \n@@ -103,9 +102,8 @@ void UrlData::MergeFrom(const scoped_refptr<UrlData>& other) {\n       last_modified_ = other->last_modified_;\n     }\n     bytes_read_from_cache_ += other->bytes_read_from_cache_;\n-    // set_has_opaque_data() will not relax from opaque to non-opaque if already\n-    // opaque.\n-    set_has_opaque_data(other->has_opaque_data_);\n+    // is_cors_corss_origin_ will not relax from true to false.\n+    set_is_cors_cross_origin(other->is_cors_cross_origin_);\n     multibuffer()->MergeFrom(other->multibuffer());\n   }\n }\n@@ -122,10 +120,10 @@ void UrlData::set_length(int64_t length) {\n   }\n }\n \n-void UrlData::set_has_opaque_data(bool has_opaque_data) {\n-  if (has_opaque_data_)\n+void UrlData::set_is_cors_cross_origin(bool is_cors_cross_origin) {\n+  if (is_cors_cross_origin_)\n     return;\n-  has_opaque_data_ = has_opaque_data;\n+  is_cors_cross_origin_ = is_cors_cross_origin;\n }\n \n void UrlData::RedirectTo(const scoped_refptr<UrlData>& url_data) {""}<_**next**_>{""sha"": ""2c15bc7ac0ad4489a0c922f614889e575bd5d863"", ""filename"": ""media/blink/url_index.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -125,7 +125,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // Returns our url_index.\n   UrlIndex* url_index() const { return url_index_; }\n \n-  bool has_opaque_data() const { return has_opaque_data_; }\n+  // This must be called after the response arrives.\n+  bool is_cors_cross_origin() const { return is_cors_cross_origin_; }\n \n   // Notifies the url index that this is currently used.\n   // The url <-> URLData mapping will be eventually be invalidated if\n@@ -145,7 +146,7 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   void set_range_supported();\n   void set_last_modified(base::Time last_modified);\n   void set_etag(const std::string& etag);\n-  void set_has_opaque_data(bool has_opaque_data);\n+  void set_is_cors_cross_origin(bool is_cors_cross_origin);\n \n   // A redirect has occured (or we've found a better UrlData for the same\n   // resource).\n@@ -238,9 +239,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // will not cache this url.\n   bool cacheable_;\n \n-  // True if a service worker intercepted a request for this resource\n-  // and provided an opaque response.\n-  bool has_opaque_data_;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  bool is_cors_cross_origin_ = false;\n \n   // Last time some media time used this resource.\n   // Note that we use base::Time rather than base::TimeTicks because""}<_**next**_>{""sha"": ""cf0857d8c6283758b159609f76da1bafb19cc789"", ""filename"": ""media/blink/webmediaplayer_impl.cc"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 10, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1175,12 +1175,6 @@ void WebMediaPlayerImpl::Paint(cc::PaintCanvas* canvas,\n       context_support);\n }\n \n-bool WebMediaPlayerImpl::DidGetOpaqueResponseFromServiceWorker() const {\n-  if (data_source_)\n-    return data_source_->DidGetOpaqueResponseViaServiceWorker();\n-  return false;\n-}\n-\n bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   if (demuxer_found_hls_) {\n     // HLS manifests might pull segments from a different origin. We can't know\n@@ -1193,10 +1187,15 @@ bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   return true;\n }\n \n-bool WebMediaPlayerImpl::DidPassCORSAccessCheck() const {\n-  if (data_source_)\n-    return data_source_->DidPassCORSAccessCheck();\n-  return false;\n+bool WebMediaPlayerImpl::WouldTaintOrigin() const {\n+  if (!HasSingleSecurityOrigin()) {\n+    // When the resource is redirected to another origin we think it as\n+    // tainted. This is actually not specified, and is under discussion.\n+    // See https://github.com/whatwg/fetch/issues/737.\n+    return true;\n+  }\n+\n+  return data_source_ && data_source_->IsCorsCrossOrigin();\n }\n \n double WebMediaPlayerImpl::MediaTimeForTimeValue(double timeValue) const {""}<_**next**_>{""sha"": ""233e37b4614544e9b2a67b4e5edee775de0f79a6"", ""filename"": ""media/blink/webmediaplayer_impl.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -188,10 +188,7 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n \n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n-\n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n \n@@ -332,6 +329,8 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n   void OnPipelineResumed();\n   void OnDemuxerOpened();\n \n+  bool HasSingleSecurityOrigin() const;\n+\n   // Pipeline::Client overrides.\n   void OnError(PipelineStatus status) override;\n   void OnEnded() override;""}<_**next**_>{""sha"": ""9821759bc7b311672a54387edc7d8c26a11d5e54"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""status"": ""added"", ""additions"": 47, ""deletions"": 0, ""changes"": 47, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -0,0 +1,47 @@\n+<!doctype html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+<script src=\""/common/get-host-info.sub.js\""></script>\n+<script src=\""resources/test-helpers.sub.js?pipe=sub\""></script>\n+<script>\n+promise_test(async (t) => {\n+    const SCOPE = 'resources/empty.html';\n+    const SCRIPT = 'resources/fetch-rewrite-worker.js';\n+    const host_info = get_host_info();\n+    const REMOTE_ORIGIN = host_info.HTTPS_REMOTE_ORIGIN;\n+\n+    const reg = await service_worker_unregister_and_register(t, SCRIPT, SCOPE);\n+    await wait_for_state(t, reg.installing, 'activated');\n+    const frame = await with_iframe(SCOPE);\n+\n+    const doc = frame.contentDocument;\n+    const win = frame.contentWindow;\n+\n+    const context = new win.AudioContext();\n+    try {\n+      context.suspend();\n+      const audio = doc.createElement('audio');\n+      audio.autoplay = true;\n+      const source = context.createMediaElementSource(audio);\n+      const spn = context.createScriptProcessor(16384, 1, 1);\n+      source.connect(spn).connect(context.destination);\n+      const url = `${REMOTE_ORIGIN}/webaudio/resources/sin_440Hz_-6dBFS_1s.wav`;\n+      audio.src = '/test?url=' + encodeURIComponent(url);\n+      doc.body.appendChild(audio);\n+\n+      await new Promise((resolve) => {\n+        audio.addEventListener('playing', resolve);\n+      });\n+      await context.resume();\n+      const event = await new Promise((resolve) => {\n+        spn.addEventListener('audioprocess', resolve);\n+      });\n+      const data = event.inputBuffer.getChannelData(0);\n+      for (const e of data) {\n+        assert_equals(e, 0);\n+      }\n+    } finally {\n+      context.close();\n+    }\n+  }, 'Verify CORS XHR of fetch() in a Service Worker');\n+</script>""}<_**next**_>{""sha"": ""319648dbc16669ab3b3238d8488997b7d3a7c837"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""58697c0661a94d03e4bbe74134a23e71a860f5f6"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""a1e82caf7e2f9d37d785165a4766f42acb28c465"", ""filename"": ""third_party/blink/public/platform/web_media_player.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/public/platform/web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -207,9 +207,10 @@ class WebMediaPlayer {\n \n   virtual bool DidLoadingProgress() = 0;\n \n-  virtual bool DidGetOpaqueResponseFromServiceWorker() const = 0;\n-  virtual bool HasSingleSecurityOrigin() const = 0;\n-  virtual bool DidPassCORSAccessCheck() const = 0;\n+  // Returns true if the response is CORS-cross-origin and so we shouldn't be\n+  // allowing media to play through webaudio.\n+  // This should be called after the response has arrived.\n+  virtual bool WouldTaintOrigin() const = 0;\n \n   virtual double MediaTimeForTimeValue(double time_value) const = 0;\n ""}<_**next**_>{""sha"": ""ad708c861bb80cd8a01217eec51f9fe058af4a33"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 21, ""changes"": 26, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1506,30 +1506,14 @@ bool HTMLMediaElement::IsSafeToLoadURL(const KURL& url,\n \n bool HTMLMediaElement::IsMediaDataCORSSameOrigin(\n     const SecurityOrigin* origin) const {\n-  // If a service worker handled the request, we don't know if the origin in the\n-  // src is the same as the actual response URL so can't rely on URL checks\n-  // alone. So detect an opaque response via\n-  // DidGetOpaqueResponseFromServiceWorker().\n-  if (GetWebMediaPlayer() &&\n-      GetWebMediaPlayer()->DidGetOpaqueResponseFromServiceWorker()) {\n-    return false;\n-  }\n-\n-  // At this point, either a service worker was not used, or it didn't provide\n-  // an opaque response, so continue with the normal checks.\n+  if (!GetWebMediaPlayer())\n+    return true;\n \n-  // HasSingleSecurityOrigin() tells us whether the origin in the src\n-  // is the same as the actual request (i.e. after redirects).\n-  if (!HasSingleSecurityOrigin())\n+  const auto network_state = GetWebMediaPlayer()->GetNetworkState();\n+  if (network_state == WebMediaPlayer::kNetworkStateNetworkError)\n     return false;\n \n-  // DidPassCORSAccessCheck() means it was a successful CORS-enabled fetch (vs.\n-  // non-CORS-enabled or failed). CanReadContent() does CheckAccess() on the\n-  // URL plus allows data sources, to ensure that it is not a URL that requires\n-  // CORS (basically same origin).\n-  return (GetWebMediaPlayer() &&\n-          GetWebMediaPlayer()->DidPassCORSAccessCheck()) ||\n-         origin->CanReadContent(currentSrc());\n+  return !GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n bool HTMLMediaElement::IsInCrossOriginFrame() const {""}<_**next**_>{""sha"": ""f2d50264a53a0a3002725b06b6363091f4e17faa"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -268,11 +268,6 @@ class CORE_EXPORT HTMLMediaElement\n   // of one of them here.\n   using HTMLElement::GetExecutionContext;\n \n-  bool HasSingleSecurityOrigin() const {\n-    return GetWebMediaPlayer() ? GetWebMediaPlayer()->HasSingleSecurityOrigin()\n-                               : true;\n-  }\n-\n   bool IsFullscreen() const;\n   virtual bool UsesOverlayFullscreenVideo() const { return false; }\n ""}<_**next**_>{""sha"": ""8cf3a926979a853d0ba0f48f9def6bc9b4aec36a"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 17, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -958,21 +958,4 @@ void BaseAudioContext::UpdateWorkletGlobalScopeOnRenderingThread() {\n   }\n }\n \n-bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {\n-  // Data URLs don't taint the origin.\n-  if (url.ProtocolIsData()) {\n-    return false;\n-  }\n-\n-  Document* document = GetDocument();\n-  if (document && document->GetSecurityOrigin()) {\n-    // The origin is tainted if and only if we cannot read content from the URL.\n-    return !document->GetSecurityOrigin()->CanRequest(url);\n-  }\n-\n-  // Be conservative and assume it's tainted if it's not a data url and if we\n-  // can't get the security origin of the document.\n-  return true;\n-}\n-\n }  // namespace blink""}<_**next**_>{""sha"": ""ae933f20167fb374b51ff5a869d9381f97b56d4b"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -296,13 +296,6 @@ class MODULES_EXPORT BaseAudioContext\n   // Does nothing when the worklet global scope does not exist.\n   void UpdateWorkletGlobalScopeOnRenderingThread();\n \n-  // Returns true if the URL would taint the origin so that we shouldn't be\n-  // allowing media to played through webaudio.\n-  // TODO(crbug.com/845913): This should really be on an AudioContext.  Move\n-  // this when we move the media stuff from BaseAudioContext to AudioContext, as\n-  // requried by the spec.\n-  bool WouldTaintOrigin(const KURL& url) const;\n-\n  protected:\n   enum ContextType { kRealtimeContext, kOfflineContext };\n ""}<_**next**_>{""sha"": ""d7b07b5fea75809b4e14c8fda74b38a1d48e6b9d"", ""filename"": ""third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 13, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -136,19 +136,7 @@ void MediaElementAudioSourceHandler::SetFormat(size_t number_of_channels,\n }\n \n bool MediaElementAudioSourceHandler::WouldTaintOrigin() {\n-  // If we're cross-origin and allowed access vie CORS, we're not tainted.\n-  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {\n-    return false;\n-  }\n-\n-  // Handles the case where the url is a redirect to another site that we're not\n-  // allowed to access.\n-  if (!MediaElement()->HasSingleSecurityOrigin()) {\n-    return true;\n-  }\n-\n-  // Test to see if the current media URL taint the origin of the audio context?\n-  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());\n+  return MediaElement()->GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n void MediaElementAudioSourceHandler::PrintCORSMessage(const String& message) {""}<_**next**_>{""sha"": ""6e5771836bf84527d922a6c5fc84a3aa5c8c9bce"", ""filename"": ""third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/testing/empty_web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -50,9 +50,7 @@ class EmptyWebMediaPlayer : public WebMediaPlayer {\n   ReadyState GetReadyState() const override { return kReadyStateHaveNothing; }\n   WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override { return false; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double time_value) const override {\n     return time_value;\n   };""}","bool WebMediaPlayerMS::HasSingleSecurityOrigin() const {
","bool WebMediaPlayerMS::HasSingleSecurityOrigin() const {
  DCHECK(thread_checker_.CalledOnValidThread());
  return true;
}
",C,,"  DCHECK(thread_checker_.CalledOnValidThread());
  return true;
}
",,"@@ -844,21 +844,11 @@ void WebMediaPlayerMS::Paint(cc::PaintCanvas* canvas,
                         context_3d, context_support);
 }
 
-bool WebMediaPlayerMS::DidGetOpaqueResponseFromServiceWorker() const {
+bool WebMediaPlayerMS::WouldTaintOrigin() const {
   DCHECK(thread_checker_.CalledOnValidThread());
   return false;
 }
 
-bool WebMediaPlayerMS::HasSingleSecurityOrigin() const {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  return true;
-}
-
-bool WebMediaPlayerMS::DidPassCORSAccessCheck() const {
-  DCHECK(thread_checker_.CalledOnValidThread());
-  return true;
-}
-
 double WebMediaPlayerMS::MediaTimeForTimeValue(double timeValue) const {
   return base::TimeDelta::FromSecondsD(timeValue).InSecondsF();
 }",Chrome,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,50436d878b2e92de4231fda47328a8a4e884ecc3,1,"bool WebMediaPlayerMS::HasSingleSecurityOrigin() const {
//flaw_line_below:
  DCHECK(thread_checker_.CalledOnValidThread());
//flaw_line_below:
  return true;
//flaw_line_below:
}
"
8864,186600,,Remote,Not required,,CVE-2018-18352,https://www.cvedetails.com/cve/CVE-2018-18352/,CWE-732,Medium,Partial,,,2018-12-11,4.3,Service works could inappropriately gain access to cross origin audio in Media in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to bypass same origin policy for audio content via a crafted HTML page.,2019-10-02,Bypass ,2,https://github.com/chromium/chromium/commit/a9cbaa7a40e2b2723cfc2f266c42f4980038a949,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,"Simplify ""WouldTaintOrigin"" concept in media/blink

Currently WebMediaPlayer has three predicates:
 - DidGetOpaqueResponseFromServiceWorker
 - HasSingleSecurityOrigin
 - DidPassCORSAccessCheck
. These are used to determine whether the response body is available
for scripts. They are known to be confusing, and actually
MediaElementAudioSourceHandler::WouldTaintOrigin misuses them.

This CL merges the three predicates to one, WouldTaintOrigin, to remove
the confusion. Now the ""response type"" concept is available and we
don't need a custom CORS check, so this CL removes
BaseAudioContext::WouldTaintOrigin. This CL also renames
URLData::has_opaque_data_ and its (direct and indirect) data accessors
to match the spec.

Bug: 849942, 875153
Change-Id: I6acf50169d7445c4ff614e80ac606f79ee577d2a
Reviewed-on: https://chromium-review.googlesource.com/c/1238098
Reviewed-by: Fredrik Hubinette <hubbe@chromium.org>
Reviewed-by: Kinuko Yasuda <kinuko@chromium.org>
Reviewed-by: Raymond Toy <rtoy@chromium.org>
Commit-Queue: Yutaka Hirano <yhirano@chromium.org>
Cr-Commit-Position: refs/heads/master@{#598258}",1,media/blink/multibuffer_data_source.cc,"{""sha"": ""78ca5e2c3c323cf55e23eacc262e8a197e60b63b"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 11, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -844,21 +844,11 @@ void WebMediaPlayerMS::Paint(cc::PaintCanvas* canvas,\n                         context_3d, context_support);\n }\n \n-bool WebMediaPlayerMS::DidGetOpaqueResponseFromServiceWorker() const {\n+bool WebMediaPlayerMS::WouldTaintOrigin() const {\n   DCHECK(thread_checker_.CalledOnValidThread());\n   return false;\n }\n \n-bool WebMediaPlayerMS::HasSingleSecurityOrigin() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n-bool WebMediaPlayerMS::DidPassCORSAccessCheck() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n double WebMediaPlayerMS::MediaTimeForTimeValue(double timeValue) const {\n   return base::TimeDelta::FromSecondsD(timeValue).InSecondsF();\n }""}<_**next**_>{""sha"": ""8c3595505cb20fa379b861f49b28710c40f3a5f1"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -163,9 +163,7 @@ class CONTENT_EXPORT WebMediaPlayerMS\n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n \n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n ""}<_**next**_>{""sha"": ""d26bc8142d80dc7c64958a9c22170244d6e664dd"", ""filename"": ""content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -76,9 +76,7 @@ class MockWebMediaPlayer : public blink::WebMediaPlayer,\n   }\n \n   bool DidLoadingProgress() override { return true; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double timeValue) const override { return 0.0; }\n   unsigned DecodedFrameCount() const override { return 0; }\n   unsigned DroppedFrameCount() const override { return 0; }""}<_**next**_>{""sha"": ""74ad44546ee34afa79b4a1649710117f8532c5f4"", ""filename"": ""media/blink/multibuffer_data_source.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 19, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -286,23 +286,8 @@ bool MultibufferDataSource::HasSingleOrigin() {\n   return single_origin_;\n }\n \n-bool MultibufferDataSource::DidPassCORSAccessCheck() const {\n-  if (url_data()->cors_mode() == UrlData::CORS_UNSPECIFIED)\n-    return false;\n-\n-  // If init_cb is set, we know initialization is not finished yet.\n-  if (init_cb_)\n-    return false;\n-  if (failed_)\n-    return false;\n-  return true;\n-}\n-\n-bool MultibufferDataSource::DidGetOpaqueResponseViaServiceWorker() const {\n-  return url_data()->has_opaque_data();\n-\n-  // TODO(falken): Do we need to do something about |init_cb_| like\n-  // in DidPassCORSAccessCheck()?\n+bool MultibufferDataSource::IsCorsCrossOrigin() const {\n+  return url_data()->is_cors_cross_origin();\n }\n \n void MultibufferDataSource::MediaPlaybackRateChanged(double playback_rate) {\n@@ -627,8 +612,6 @@ void MultibufferDataSource::StartCallback() {\n     // Progress callback might be called after the start callback,\n     // make sure that we update single_origin_ now.\n     media_log_->SetBooleanProperty(\""single_origin\"", single_origin_);\n-    media_log_->SetBooleanProperty(\""passed_cors_access_check\"",\n-                                   DidPassCORSAccessCheck());\n     media_log_->SetBooleanProperty(\""range_header_supported\"",\n                                    url_data()->range_supported());\n   }""}<_**next**_>{""sha"": ""4da62a5519e33ab6e726406f0acac4995c4ad49f"", ""filename"": ""media/blink/multibuffer_data_source.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 6, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -79,12 +79,9 @@ class MEDIA_BLINK_EXPORT MultibufferDataSource : public DataSource {\n   // Method called on the render thread.\n   bool HasSingleOrigin();\n \n-  // Returns true if the media resource passed a CORS access control check.\n-  bool DidPassCORSAccessCheck() const;\n-\n-  // Returns true if a service worker provided the media resource response,\n-  // and the response was opaque.\n-  bool DidGetOpaqueResponseViaServiceWorker() const;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  // This must be called after the response arrives.\n+  bool IsCorsCrossOrigin() const;\n \n   // Notifies changes in playback state for controlling media buffering\n   // behavior.""}<_**next**_>{""sha"": ""4b9f83e74255bf14d33c3f0c2785c282ecb2bcd7"", ""filename"": ""media/blink/multibuffer_data_source_unittest.cc"", ""status"": ""modified"", ""additions"": 81, ""deletions"": 12, ""changes"": 93, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1493,35 +1493,104 @@ TEST_F(MultibufferDataSourceTest, FileSizeLessThanBlockSize) {\n   Stop();\n }\n \n-TEST_F(MultibufferDataSourceTest, DidPassCORSAccessTest) {\n+TEST_F(MultibufferDataSourceTest, ResponseTypeBasic) {\n   InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n   set_preload(MultibufferDataSource::NONE);\n   WebURLResponse response1 =\n       response_generator_->GeneratePartial206(0, kDataSize - 1);\n-  response1.SetWasFetchedViaServiceWorker(true);\n-  std::vector<blink::WebURL> urlList = {GURL(kHttpDifferentOriginUrl)};\n-  response1.SetURLListViaServiceWorker(urlList);\n-  WebURLResponse response2 =\n-      response_generator_->GeneratePartial206(kDataSize, kDataSize * 2 - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kBasic);\n \n   EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n   EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n   EXPECT_CALL(*this, ReadCallback(kDataSize));\n \n-  EXPECT_FALSE(data_source_->DidPassCORSAccessCheck());\n   Respond(response1);\n   ReceiveData(kDataSize);\n   ReadAt(0);\n   EXPECT_TRUE(loading());\n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n   FinishLoading();\n+}\n \n-  // Verify that if reader_ is null, DidPassCORSAccessCheck still returns true.\n-  data_source_->Stop();\n-  base::RunLoop().RunUntilIdle();\n+TEST_F(MultibufferDataSourceTest, ResponseTypeCors) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kCORS);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeDefault) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kDefault);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaque) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaque);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaqueRedirect) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaqueRedirect);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n }\n \n TEST_F(MultibufferDataSourceTest, EtagTest) {""}<_**next**_>{""sha"": ""89f1c9e70d2cc71646df50026b50d54d471d20c6"", ""filename"": ""media/blink/resource_multibuffer_data_provider.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/resource_multibuffer_data_provider.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -280,6 +280,8 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n   int64_t content_length = response.ExpectedContentLength();\n   bool end_of_file = false;\n   bool do_fail = false;\n+  // We get the response type here because aborting the loader may change it.\n+  const auto response_type = response.GetType();\n   bytes_to_discard_ = 0;\n \n   // We make a strong assumption that when we reach here we have either\n@@ -333,10 +335,9 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n         url_data_->url_index()->TryInsert(destination_url_data);\n   }\n \n-  // This is vital for security! A service worker can respond with a response\n-  // from a different origin, so this response type is needed to detect that.\n-  destination_url_data->set_has_opaque_data(\n-      network::cors::IsCORSCrossOriginResponseType(response.GetType()));\n+  // This is vital for security!\n+  destination_url_data->set_is_cors_cross_origin(\n+      network::cors::IsCORSCrossOriginResponseType(response_type));\n \n   if (destination_url_data != url_data_) {\n     // At this point, we've encountered a redirect, or found a better url data""}<_**next**_>{""sha"": ""3fb63497791a3d2a0ea1e3b12c018f4b2c5fe355"", ""filename"": ""media/blink/url_index.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 7, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -65,7 +65,6 @@ UrlData::UrlData(const GURL& url, CORSMode cors_mode, UrlIndex* url_index)\n       length_(kPositionNotSpecified),\n       range_supported_(false),\n       cacheable_(false),\n-      has_opaque_data_(false),\n       last_used_(),\n       multibuffer_(this, url_index_->block_shift_) {}\n \n@@ -103,9 +102,8 @@ void UrlData::MergeFrom(const scoped_refptr<UrlData>& other) {\n       last_modified_ = other->last_modified_;\n     }\n     bytes_read_from_cache_ += other->bytes_read_from_cache_;\n-    // set_has_opaque_data() will not relax from opaque to non-opaque if already\n-    // opaque.\n-    set_has_opaque_data(other->has_opaque_data_);\n+    // is_cors_corss_origin_ will not relax from true to false.\n+    set_is_cors_cross_origin(other->is_cors_cross_origin_);\n     multibuffer()->MergeFrom(other->multibuffer());\n   }\n }\n@@ -122,10 +120,10 @@ void UrlData::set_length(int64_t length) {\n   }\n }\n \n-void UrlData::set_has_opaque_data(bool has_opaque_data) {\n-  if (has_opaque_data_)\n+void UrlData::set_is_cors_cross_origin(bool is_cors_cross_origin) {\n+  if (is_cors_cross_origin_)\n     return;\n-  has_opaque_data_ = has_opaque_data;\n+  is_cors_cross_origin_ = is_cors_cross_origin;\n }\n \n void UrlData::RedirectTo(const scoped_refptr<UrlData>& url_data) {""}<_**next**_>{""sha"": ""2c15bc7ac0ad4489a0c922f614889e575bd5d863"", ""filename"": ""media/blink/url_index.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -125,7 +125,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // Returns our url_index.\n   UrlIndex* url_index() const { return url_index_; }\n \n-  bool has_opaque_data() const { return has_opaque_data_; }\n+  // This must be called after the response arrives.\n+  bool is_cors_cross_origin() const { return is_cors_cross_origin_; }\n \n   // Notifies the url index that this is currently used.\n   // The url <-> URLData mapping will be eventually be invalidated if\n@@ -145,7 +146,7 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   void set_range_supported();\n   void set_last_modified(base::Time last_modified);\n   void set_etag(const std::string& etag);\n-  void set_has_opaque_data(bool has_opaque_data);\n+  void set_is_cors_cross_origin(bool is_cors_cross_origin);\n \n   // A redirect has occured (or we've found a better UrlData for the same\n   // resource).\n@@ -238,9 +239,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // will not cache this url.\n   bool cacheable_;\n \n-  // True if a service worker intercepted a request for this resource\n-  // and provided an opaque response.\n-  bool has_opaque_data_;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  bool is_cors_cross_origin_ = false;\n \n   // Last time some media time used this resource.\n   // Note that we use base::Time rather than base::TimeTicks because""}<_**next**_>{""sha"": ""cf0857d8c6283758b159609f76da1bafb19cc789"", ""filename"": ""media/blink/webmediaplayer_impl.cc"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 10, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1175,12 +1175,6 @@ void WebMediaPlayerImpl::Paint(cc::PaintCanvas* canvas,\n       context_support);\n }\n \n-bool WebMediaPlayerImpl::DidGetOpaqueResponseFromServiceWorker() const {\n-  if (data_source_)\n-    return data_source_->DidGetOpaqueResponseViaServiceWorker();\n-  return false;\n-}\n-\n bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   if (demuxer_found_hls_) {\n     // HLS manifests might pull segments from a different origin. We can't know\n@@ -1193,10 +1187,15 @@ bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   return true;\n }\n \n-bool WebMediaPlayerImpl::DidPassCORSAccessCheck() const {\n-  if (data_source_)\n-    return data_source_->DidPassCORSAccessCheck();\n-  return false;\n+bool WebMediaPlayerImpl::WouldTaintOrigin() const {\n+  if (!HasSingleSecurityOrigin()) {\n+    // When the resource is redirected to another origin we think it as\n+    // tainted. This is actually not specified, and is under discussion.\n+    // See https://github.com/whatwg/fetch/issues/737.\n+    return true;\n+  }\n+\n+  return data_source_ && data_source_->IsCorsCrossOrigin();\n }\n \n double WebMediaPlayerImpl::MediaTimeForTimeValue(double timeValue) const {""}<_**next**_>{""sha"": ""233e37b4614544e9b2a67b4e5edee775de0f79a6"", ""filename"": ""media/blink/webmediaplayer_impl.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -188,10 +188,7 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n \n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n-\n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n \n@@ -332,6 +329,8 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n   void OnPipelineResumed();\n   void OnDemuxerOpened();\n \n+  bool HasSingleSecurityOrigin() const;\n+\n   // Pipeline::Client overrides.\n   void OnError(PipelineStatus status) override;\n   void OnEnded() override;""}<_**next**_>{""sha"": ""9821759bc7b311672a54387edc7d8c26a11d5e54"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""status"": ""added"", ""additions"": 47, ""deletions"": 0, ""changes"": 47, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -0,0 +1,47 @@\n+<!doctype html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+<script src=\""/common/get-host-info.sub.js\""></script>\n+<script src=\""resources/test-helpers.sub.js?pipe=sub\""></script>\n+<script>\n+promise_test(async (t) => {\n+    const SCOPE = 'resources/empty.html';\n+    const SCRIPT = 'resources/fetch-rewrite-worker.js';\n+    const host_info = get_host_info();\n+    const REMOTE_ORIGIN = host_info.HTTPS_REMOTE_ORIGIN;\n+\n+    const reg = await service_worker_unregister_and_register(t, SCRIPT, SCOPE);\n+    await wait_for_state(t, reg.installing, 'activated');\n+    const frame = await with_iframe(SCOPE);\n+\n+    const doc = frame.contentDocument;\n+    const win = frame.contentWindow;\n+\n+    const context = new win.AudioContext();\n+    try {\n+      context.suspend();\n+      const audio = doc.createElement('audio');\n+      audio.autoplay = true;\n+      const source = context.createMediaElementSource(audio);\n+      const spn = context.createScriptProcessor(16384, 1, 1);\n+      source.connect(spn).connect(context.destination);\n+      const url = `${REMOTE_ORIGIN}/webaudio/resources/sin_440Hz_-6dBFS_1s.wav`;\n+      audio.src = '/test?url=' + encodeURIComponent(url);\n+      doc.body.appendChild(audio);\n+\n+      await new Promise((resolve) => {\n+        audio.addEventListener('playing', resolve);\n+      });\n+      await context.resume();\n+      const event = await new Promise((resolve) => {\n+        spn.addEventListener('audioprocess', resolve);\n+      });\n+      const data = event.inputBuffer.getChannelData(0);\n+      for (const e of data) {\n+        assert_equals(e, 0);\n+      }\n+    } finally {\n+      context.close();\n+    }\n+  }, 'Verify CORS XHR of fetch() in a Service Worker');\n+</script>""}<_**next**_>{""sha"": ""319648dbc16669ab3b3238d8488997b7d3a7c837"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""58697c0661a94d03e4bbe74134a23e71a860f5f6"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""a1e82caf7e2f9d37d785165a4766f42acb28c465"", ""filename"": ""third_party/blink/public/platform/web_media_player.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/public/platform/web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -207,9 +207,10 @@ class WebMediaPlayer {\n \n   virtual bool DidLoadingProgress() = 0;\n \n-  virtual bool DidGetOpaqueResponseFromServiceWorker() const = 0;\n-  virtual bool HasSingleSecurityOrigin() const = 0;\n-  virtual bool DidPassCORSAccessCheck() const = 0;\n+  // Returns true if the response is CORS-cross-origin and so we shouldn't be\n+  // allowing media to play through webaudio.\n+  // This should be called after the response has arrived.\n+  virtual bool WouldTaintOrigin() const = 0;\n \n   virtual double MediaTimeForTimeValue(double time_value) const = 0;\n ""}<_**next**_>{""sha"": ""ad708c861bb80cd8a01217eec51f9fe058af4a33"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 21, ""changes"": 26, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1506,30 +1506,14 @@ bool HTMLMediaElement::IsSafeToLoadURL(const KURL& url,\n \n bool HTMLMediaElement::IsMediaDataCORSSameOrigin(\n     const SecurityOrigin* origin) const {\n-  // If a service worker handled the request, we don't know if the origin in the\n-  // src is the same as the actual response URL so can't rely on URL checks\n-  // alone. So detect an opaque response via\n-  // DidGetOpaqueResponseFromServiceWorker().\n-  if (GetWebMediaPlayer() &&\n-      GetWebMediaPlayer()->DidGetOpaqueResponseFromServiceWorker()) {\n-    return false;\n-  }\n-\n-  // At this point, either a service worker was not used, or it didn't provide\n-  // an opaque response, so continue with the normal checks.\n+  if (!GetWebMediaPlayer())\n+    return true;\n \n-  // HasSingleSecurityOrigin() tells us whether the origin in the src\n-  // is the same as the actual request (i.e. after redirects).\n-  if (!HasSingleSecurityOrigin())\n+  const auto network_state = GetWebMediaPlayer()->GetNetworkState();\n+  if (network_state == WebMediaPlayer::kNetworkStateNetworkError)\n     return false;\n \n-  // DidPassCORSAccessCheck() means it was a successful CORS-enabled fetch (vs.\n-  // non-CORS-enabled or failed). CanReadContent() does CheckAccess() on the\n-  // URL plus allows data sources, to ensure that it is not a URL that requires\n-  // CORS (basically same origin).\n-  return (GetWebMediaPlayer() &&\n-          GetWebMediaPlayer()->DidPassCORSAccessCheck()) ||\n-         origin->CanReadContent(currentSrc());\n+  return !GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n bool HTMLMediaElement::IsInCrossOriginFrame() const {""}<_**next**_>{""sha"": ""f2d50264a53a0a3002725b06b6363091f4e17faa"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -268,11 +268,6 @@ class CORE_EXPORT HTMLMediaElement\n   // of one of them here.\n   using HTMLElement::GetExecutionContext;\n \n-  bool HasSingleSecurityOrigin() const {\n-    return GetWebMediaPlayer() ? GetWebMediaPlayer()->HasSingleSecurityOrigin()\n-                               : true;\n-  }\n-\n   bool IsFullscreen() const;\n   virtual bool UsesOverlayFullscreenVideo() const { return false; }\n ""}<_**next**_>{""sha"": ""8cf3a926979a853d0ba0f48f9def6bc9b4aec36a"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 17, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -958,21 +958,4 @@ void BaseAudioContext::UpdateWorkletGlobalScopeOnRenderingThread() {\n   }\n }\n \n-bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {\n-  // Data URLs don't taint the origin.\n-  if (url.ProtocolIsData()) {\n-    return false;\n-  }\n-\n-  Document* document = GetDocument();\n-  if (document && document->GetSecurityOrigin()) {\n-    // The origin is tainted if and only if we cannot read content from the URL.\n-    return !document->GetSecurityOrigin()->CanRequest(url);\n-  }\n-\n-  // Be conservative and assume it's tainted if it's not a data url and if we\n-  // can't get the security origin of the document.\n-  return true;\n-}\n-\n }  // namespace blink""}<_**next**_>{""sha"": ""ae933f20167fb374b51ff5a869d9381f97b56d4b"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -296,13 +296,6 @@ class MODULES_EXPORT BaseAudioContext\n   // Does nothing when the worklet global scope does not exist.\n   void UpdateWorkletGlobalScopeOnRenderingThread();\n \n-  // Returns true if the URL would taint the origin so that we shouldn't be\n-  // allowing media to played through webaudio.\n-  // TODO(crbug.com/845913): This should really be on an AudioContext.  Move\n-  // this when we move the media stuff from BaseAudioContext to AudioContext, as\n-  // requried by the spec.\n-  bool WouldTaintOrigin(const KURL& url) const;\n-\n  protected:\n   enum ContextType { kRealtimeContext, kOfflineContext };\n ""}<_**next**_>{""sha"": ""d7b07b5fea75809b4e14c8fda74b38a1d48e6b9d"", ""filename"": ""third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 13, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -136,19 +136,7 @@ void MediaElementAudioSourceHandler::SetFormat(size_t number_of_channels,\n }\n \n bool MediaElementAudioSourceHandler::WouldTaintOrigin() {\n-  // If we're cross-origin and allowed access vie CORS, we're not tainted.\n-  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {\n-    return false;\n-  }\n-\n-  // Handles the case where the url is a redirect to another site that we're not\n-  // allowed to access.\n-  if (!MediaElement()->HasSingleSecurityOrigin()) {\n-    return true;\n-  }\n-\n-  // Test to see if the current media URL taint the origin of the audio context?\n-  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());\n+  return MediaElement()->GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n void MediaElementAudioSourceHandler::PrintCORSMessage(const String& message) {""}<_**next**_>{""sha"": ""6e5771836bf84527d922a6c5fc84a3aa5c8c9bce"", ""filename"": ""third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/testing/empty_web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -50,9 +50,7 @@ class EmptyWebMediaPlayer : public WebMediaPlayer {\n   ReadyState GetReadyState() const override { return kReadyStateHaveNothing; }\n   WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override { return false; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double time_value) const override {\n     return time_value;\n   };""}","bool MultibufferDataSource::DidGetOpaqueResponseViaServiceWorker() const {
bool MultibufferDataSource::IsCorsCrossOrigin() const {
  return url_data()->is_cors_cross_origin();
 }
","bool MultibufferDataSource::DidGetOpaqueResponseViaServiceWorker() const {
  return url_data()->has_opaque_data();
 }
",C,"bool MultibufferDataSource::IsCorsCrossOrigin() const {
  return url_data()->is_cors_cross_origin();
","  return url_data()->has_opaque_data();
",,"@@ -286,23 +286,8 @@ bool MultibufferDataSource::HasSingleOrigin() {
   return single_origin_;
 }
 
-bool MultibufferDataSource::DidPassCORSAccessCheck() const {
-  if (url_data()->cors_mode() == UrlData::CORS_UNSPECIFIED)
-    return false;
-
-  // If init_cb is set, we know initialization is not finished yet.
-  if (init_cb_)
-    return false;
-  if (failed_)
-    return false;
-  return true;
-}
-
-bool MultibufferDataSource::DidGetOpaqueResponseViaServiceWorker() const {
-  return url_data()->has_opaque_data();
-
-  // TODO(falken): Do we need to do something about |init_cb_| like
-  // in DidPassCORSAccessCheck()?
+bool MultibufferDataSource::IsCorsCrossOrigin() const {
+  return url_data()->is_cors_cross_origin();
 }
 
 void MultibufferDataSource::MediaPlaybackRateChanged(double playback_rate) {
@@ -627,8 +612,6 @@ void MultibufferDataSource::StartCallback() {
     // Progress callback might be called after the start callback,
     // make sure that we update single_origin_ now.
     media_log_->SetBooleanProperty(""single_origin"", single_origin_);
-    media_log_->SetBooleanProperty(""passed_cors_access_check"",
-                                   DidPassCORSAccessCheck());
     media_log_->SetBooleanProperty(""range_header_supported"",
                                    url_data()->range_supported());
   }",Chrome,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,50436d878b2e92de4231fda47328a8a4e884ecc3,1,"bool MultibufferDataSource::DidGetOpaqueResponseViaServiceWorker() const {
//flaw_line_below:
  return url_data()->has_opaque_data();
//flaw_line_below:

//flaw_line_below:
  // TODO(falken): Do we need to do something about |init_cb_| like
//flaw_line_below:
  // in DidPassCORSAccessCheck()?
//fix_flaw_line_below:
//bool MultibufferDataSource::IsCorsCrossOrigin() const {
//fix_flaw_line_below:
//  return url_data()->is_cors_cross_origin();
 }
"
8865,186601,,Remote,Not required,,CVE-2018-18352,https://www.cvedetails.com/cve/CVE-2018-18352/,CWE-732,Medium,Partial,,,2018-12-11,4.3,Service works could inappropriately gain access to cross origin audio in Media in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to bypass same origin policy for audio content via a crafted HTML page.,2019-10-02,Bypass ,0,https://github.com/chromium/chromium/commit/a9cbaa7a40e2b2723cfc2f266c42f4980038a949,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,"Simplify ""WouldTaintOrigin"" concept in media/blink

Currently WebMediaPlayer has three predicates:
 - DidGetOpaqueResponseFromServiceWorker
 - HasSingleSecurityOrigin
 - DidPassCORSAccessCheck
. These are used to determine whether the response body is available
for scripts. They are known to be confusing, and actually
MediaElementAudioSourceHandler::WouldTaintOrigin misuses them.

This CL merges the three predicates to one, WouldTaintOrigin, to remove
the confusion. Now the ""response type"" concept is available and we
don't need a custom CORS check, so this CL removes
BaseAudioContext::WouldTaintOrigin. This CL also renames
URLData::has_opaque_data_ and its (direct and indirect) data accessors
to match the spec.

Bug: 849942, 875153
Change-Id: I6acf50169d7445c4ff614e80ac606f79ee577d2a
Reviewed-on: https://chromium-review.googlesource.com/c/1238098
Reviewed-by: Fredrik Hubinette <hubbe@chromium.org>
Reviewed-by: Kinuko Yasuda <kinuko@chromium.org>
Reviewed-by: Raymond Toy <rtoy@chromium.org>
Commit-Queue: Yutaka Hirano <yhirano@chromium.org>
Cr-Commit-Position: refs/heads/master@{#598258}",8,media/blink/multibuffer_data_source.cc,"{""sha"": ""78ca5e2c3c323cf55e23eacc262e8a197e60b63b"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 11, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -844,21 +844,11 @@ void WebMediaPlayerMS::Paint(cc::PaintCanvas* canvas,\n                         context_3d, context_support);\n }\n \n-bool WebMediaPlayerMS::DidGetOpaqueResponseFromServiceWorker() const {\n+bool WebMediaPlayerMS::WouldTaintOrigin() const {\n   DCHECK(thread_checker_.CalledOnValidThread());\n   return false;\n }\n \n-bool WebMediaPlayerMS::HasSingleSecurityOrigin() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n-bool WebMediaPlayerMS::DidPassCORSAccessCheck() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n double WebMediaPlayerMS::MediaTimeForTimeValue(double timeValue) const {\n   return base::TimeDelta::FromSecondsD(timeValue).InSecondsF();\n }""}<_**next**_>{""sha"": ""8c3595505cb20fa379b861f49b28710c40f3a5f1"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -163,9 +163,7 @@ class CONTENT_EXPORT WebMediaPlayerMS\n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n \n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n ""}<_**next**_>{""sha"": ""d26bc8142d80dc7c64958a9c22170244d6e664dd"", ""filename"": ""content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -76,9 +76,7 @@ class MockWebMediaPlayer : public blink::WebMediaPlayer,\n   }\n \n   bool DidLoadingProgress() override { return true; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double timeValue) const override { return 0.0; }\n   unsigned DecodedFrameCount() const override { return 0; }\n   unsigned DroppedFrameCount() const override { return 0; }""}<_**next**_>{""sha"": ""74ad44546ee34afa79b4a1649710117f8532c5f4"", ""filename"": ""media/blink/multibuffer_data_source.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 19, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -286,23 +286,8 @@ bool MultibufferDataSource::HasSingleOrigin() {\n   return single_origin_;\n }\n \n-bool MultibufferDataSource::DidPassCORSAccessCheck() const {\n-  if (url_data()->cors_mode() == UrlData::CORS_UNSPECIFIED)\n-    return false;\n-\n-  // If init_cb is set, we know initialization is not finished yet.\n-  if (init_cb_)\n-    return false;\n-  if (failed_)\n-    return false;\n-  return true;\n-}\n-\n-bool MultibufferDataSource::DidGetOpaqueResponseViaServiceWorker() const {\n-  return url_data()->has_opaque_data();\n-\n-  // TODO(falken): Do we need to do something about |init_cb_| like\n-  // in DidPassCORSAccessCheck()?\n+bool MultibufferDataSource::IsCorsCrossOrigin() const {\n+  return url_data()->is_cors_cross_origin();\n }\n \n void MultibufferDataSource::MediaPlaybackRateChanged(double playback_rate) {\n@@ -627,8 +612,6 @@ void MultibufferDataSource::StartCallback() {\n     // Progress callback might be called after the start callback,\n     // make sure that we update single_origin_ now.\n     media_log_->SetBooleanProperty(\""single_origin\"", single_origin_);\n-    media_log_->SetBooleanProperty(\""passed_cors_access_check\"",\n-                                   DidPassCORSAccessCheck());\n     media_log_->SetBooleanProperty(\""range_header_supported\"",\n                                    url_data()->range_supported());\n   }""}<_**next**_>{""sha"": ""4da62a5519e33ab6e726406f0acac4995c4ad49f"", ""filename"": ""media/blink/multibuffer_data_source.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 6, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -79,12 +79,9 @@ class MEDIA_BLINK_EXPORT MultibufferDataSource : public DataSource {\n   // Method called on the render thread.\n   bool HasSingleOrigin();\n \n-  // Returns true if the media resource passed a CORS access control check.\n-  bool DidPassCORSAccessCheck() const;\n-\n-  // Returns true if a service worker provided the media resource response,\n-  // and the response was opaque.\n-  bool DidGetOpaqueResponseViaServiceWorker() const;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  // This must be called after the response arrives.\n+  bool IsCorsCrossOrigin() const;\n \n   // Notifies changes in playback state for controlling media buffering\n   // behavior.""}<_**next**_>{""sha"": ""4b9f83e74255bf14d33c3f0c2785c282ecb2bcd7"", ""filename"": ""media/blink/multibuffer_data_source_unittest.cc"", ""status"": ""modified"", ""additions"": 81, ""deletions"": 12, ""changes"": 93, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1493,35 +1493,104 @@ TEST_F(MultibufferDataSourceTest, FileSizeLessThanBlockSize) {\n   Stop();\n }\n \n-TEST_F(MultibufferDataSourceTest, DidPassCORSAccessTest) {\n+TEST_F(MultibufferDataSourceTest, ResponseTypeBasic) {\n   InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n   set_preload(MultibufferDataSource::NONE);\n   WebURLResponse response1 =\n       response_generator_->GeneratePartial206(0, kDataSize - 1);\n-  response1.SetWasFetchedViaServiceWorker(true);\n-  std::vector<blink::WebURL> urlList = {GURL(kHttpDifferentOriginUrl)};\n-  response1.SetURLListViaServiceWorker(urlList);\n-  WebURLResponse response2 =\n-      response_generator_->GeneratePartial206(kDataSize, kDataSize * 2 - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kBasic);\n \n   EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n   EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n   EXPECT_CALL(*this, ReadCallback(kDataSize));\n \n-  EXPECT_FALSE(data_source_->DidPassCORSAccessCheck());\n   Respond(response1);\n   ReceiveData(kDataSize);\n   ReadAt(0);\n   EXPECT_TRUE(loading());\n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n   FinishLoading();\n+}\n \n-  // Verify that if reader_ is null, DidPassCORSAccessCheck still returns true.\n-  data_source_->Stop();\n-  base::RunLoop().RunUntilIdle();\n+TEST_F(MultibufferDataSourceTest, ResponseTypeCors) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kCORS);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeDefault) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kDefault);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaque) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaque);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaqueRedirect) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaqueRedirect);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n }\n \n TEST_F(MultibufferDataSourceTest, EtagTest) {""}<_**next**_>{""sha"": ""89f1c9e70d2cc71646df50026b50d54d471d20c6"", ""filename"": ""media/blink/resource_multibuffer_data_provider.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/resource_multibuffer_data_provider.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -280,6 +280,8 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n   int64_t content_length = response.ExpectedContentLength();\n   bool end_of_file = false;\n   bool do_fail = false;\n+  // We get the response type here because aborting the loader may change it.\n+  const auto response_type = response.GetType();\n   bytes_to_discard_ = 0;\n \n   // We make a strong assumption that when we reach here we have either\n@@ -333,10 +335,9 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n         url_data_->url_index()->TryInsert(destination_url_data);\n   }\n \n-  // This is vital for security! A service worker can respond with a response\n-  // from a different origin, so this response type is needed to detect that.\n-  destination_url_data->set_has_opaque_data(\n-      network::cors::IsCORSCrossOriginResponseType(response.GetType()));\n+  // This is vital for security!\n+  destination_url_data->set_is_cors_cross_origin(\n+      network::cors::IsCORSCrossOriginResponseType(response_type));\n \n   if (destination_url_data != url_data_) {\n     // At this point, we've encountered a redirect, or found a better url data""}<_**next**_>{""sha"": ""3fb63497791a3d2a0ea1e3b12c018f4b2c5fe355"", ""filename"": ""media/blink/url_index.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 7, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -65,7 +65,6 @@ UrlData::UrlData(const GURL& url, CORSMode cors_mode, UrlIndex* url_index)\n       length_(kPositionNotSpecified),\n       range_supported_(false),\n       cacheable_(false),\n-      has_opaque_data_(false),\n       last_used_(),\n       multibuffer_(this, url_index_->block_shift_) {}\n \n@@ -103,9 +102,8 @@ void UrlData::MergeFrom(const scoped_refptr<UrlData>& other) {\n       last_modified_ = other->last_modified_;\n     }\n     bytes_read_from_cache_ += other->bytes_read_from_cache_;\n-    // set_has_opaque_data() will not relax from opaque to non-opaque if already\n-    // opaque.\n-    set_has_opaque_data(other->has_opaque_data_);\n+    // is_cors_corss_origin_ will not relax from true to false.\n+    set_is_cors_cross_origin(other->is_cors_cross_origin_);\n     multibuffer()->MergeFrom(other->multibuffer());\n   }\n }\n@@ -122,10 +120,10 @@ void UrlData::set_length(int64_t length) {\n   }\n }\n \n-void UrlData::set_has_opaque_data(bool has_opaque_data) {\n-  if (has_opaque_data_)\n+void UrlData::set_is_cors_cross_origin(bool is_cors_cross_origin) {\n+  if (is_cors_cross_origin_)\n     return;\n-  has_opaque_data_ = has_opaque_data;\n+  is_cors_cross_origin_ = is_cors_cross_origin;\n }\n \n void UrlData::RedirectTo(const scoped_refptr<UrlData>& url_data) {""}<_**next**_>{""sha"": ""2c15bc7ac0ad4489a0c922f614889e575bd5d863"", ""filename"": ""media/blink/url_index.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -125,7 +125,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // Returns our url_index.\n   UrlIndex* url_index() const { return url_index_; }\n \n-  bool has_opaque_data() const { return has_opaque_data_; }\n+  // This must be called after the response arrives.\n+  bool is_cors_cross_origin() const { return is_cors_cross_origin_; }\n \n   // Notifies the url index that this is currently used.\n   // The url <-> URLData mapping will be eventually be invalidated if\n@@ -145,7 +146,7 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   void set_range_supported();\n   void set_last_modified(base::Time last_modified);\n   void set_etag(const std::string& etag);\n-  void set_has_opaque_data(bool has_opaque_data);\n+  void set_is_cors_cross_origin(bool is_cors_cross_origin);\n \n   // A redirect has occured (or we've found a better UrlData for the same\n   // resource).\n@@ -238,9 +239,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // will not cache this url.\n   bool cacheable_;\n \n-  // True if a service worker intercepted a request for this resource\n-  // and provided an opaque response.\n-  bool has_opaque_data_;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  bool is_cors_cross_origin_ = false;\n \n   // Last time some media time used this resource.\n   // Note that we use base::Time rather than base::TimeTicks because""}<_**next**_>{""sha"": ""cf0857d8c6283758b159609f76da1bafb19cc789"", ""filename"": ""media/blink/webmediaplayer_impl.cc"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 10, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1175,12 +1175,6 @@ void WebMediaPlayerImpl::Paint(cc::PaintCanvas* canvas,\n       context_support);\n }\n \n-bool WebMediaPlayerImpl::DidGetOpaqueResponseFromServiceWorker() const {\n-  if (data_source_)\n-    return data_source_->DidGetOpaqueResponseViaServiceWorker();\n-  return false;\n-}\n-\n bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   if (demuxer_found_hls_) {\n     // HLS manifests might pull segments from a different origin. We can't know\n@@ -1193,10 +1187,15 @@ bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   return true;\n }\n \n-bool WebMediaPlayerImpl::DidPassCORSAccessCheck() const {\n-  if (data_source_)\n-    return data_source_->DidPassCORSAccessCheck();\n-  return false;\n+bool WebMediaPlayerImpl::WouldTaintOrigin() const {\n+  if (!HasSingleSecurityOrigin()) {\n+    // When the resource is redirected to another origin we think it as\n+    // tainted. This is actually not specified, and is under discussion.\n+    // See https://github.com/whatwg/fetch/issues/737.\n+    return true;\n+  }\n+\n+  return data_source_ && data_source_->IsCorsCrossOrigin();\n }\n \n double WebMediaPlayerImpl::MediaTimeForTimeValue(double timeValue) const {""}<_**next**_>{""sha"": ""233e37b4614544e9b2a67b4e5edee775de0f79a6"", ""filename"": ""media/blink/webmediaplayer_impl.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -188,10 +188,7 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n \n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n-\n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n \n@@ -332,6 +329,8 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n   void OnPipelineResumed();\n   void OnDemuxerOpened();\n \n+  bool HasSingleSecurityOrigin() const;\n+\n   // Pipeline::Client overrides.\n   void OnError(PipelineStatus status) override;\n   void OnEnded() override;""}<_**next**_>{""sha"": ""9821759bc7b311672a54387edc7d8c26a11d5e54"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""status"": ""added"", ""additions"": 47, ""deletions"": 0, ""changes"": 47, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -0,0 +1,47 @@\n+<!doctype html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+<script src=\""/common/get-host-info.sub.js\""></script>\n+<script src=\""resources/test-helpers.sub.js?pipe=sub\""></script>\n+<script>\n+promise_test(async (t) => {\n+    const SCOPE = 'resources/empty.html';\n+    const SCRIPT = 'resources/fetch-rewrite-worker.js';\n+    const host_info = get_host_info();\n+    const REMOTE_ORIGIN = host_info.HTTPS_REMOTE_ORIGIN;\n+\n+    const reg = await service_worker_unregister_and_register(t, SCRIPT, SCOPE);\n+    await wait_for_state(t, reg.installing, 'activated');\n+    const frame = await with_iframe(SCOPE);\n+\n+    const doc = frame.contentDocument;\n+    const win = frame.contentWindow;\n+\n+    const context = new win.AudioContext();\n+    try {\n+      context.suspend();\n+      const audio = doc.createElement('audio');\n+      audio.autoplay = true;\n+      const source = context.createMediaElementSource(audio);\n+      const spn = context.createScriptProcessor(16384, 1, 1);\n+      source.connect(spn).connect(context.destination);\n+      const url = `${REMOTE_ORIGIN}/webaudio/resources/sin_440Hz_-6dBFS_1s.wav`;\n+      audio.src = '/test?url=' + encodeURIComponent(url);\n+      doc.body.appendChild(audio);\n+\n+      await new Promise((resolve) => {\n+        audio.addEventListener('playing', resolve);\n+      });\n+      await context.resume();\n+      const event = await new Promise((resolve) => {\n+        spn.addEventListener('audioprocess', resolve);\n+      });\n+      const data = event.inputBuffer.getChannelData(0);\n+      for (const e of data) {\n+        assert_equals(e, 0);\n+      }\n+    } finally {\n+      context.close();\n+    }\n+  }, 'Verify CORS XHR of fetch() in a Service Worker');\n+</script>""}<_**next**_>{""sha"": ""319648dbc16669ab3b3238d8488997b7d3a7c837"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""58697c0661a94d03e4bbe74134a23e71a860f5f6"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""a1e82caf7e2f9d37d785165a4766f42acb28c465"", ""filename"": ""third_party/blink/public/platform/web_media_player.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/public/platform/web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -207,9 +207,10 @@ class WebMediaPlayer {\n \n   virtual bool DidLoadingProgress() = 0;\n \n-  virtual bool DidGetOpaqueResponseFromServiceWorker() const = 0;\n-  virtual bool HasSingleSecurityOrigin() const = 0;\n-  virtual bool DidPassCORSAccessCheck() const = 0;\n+  // Returns true if the response is CORS-cross-origin and so we shouldn't be\n+  // allowing media to play through webaudio.\n+  // This should be called after the response has arrived.\n+  virtual bool WouldTaintOrigin() const = 0;\n \n   virtual double MediaTimeForTimeValue(double time_value) const = 0;\n ""}<_**next**_>{""sha"": ""ad708c861bb80cd8a01217eec51f9fe058af4a33"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 21, ""changes"": 26, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1506,30 +1506,14 @@ bool HTMLMediaElement::IsSafeToLoadURL(const KURL& url,\n \n bool HTMLMediaElement::IsMediaDataCORSSameOrigin(\n     const SecurityOrigin* origin) const {\n-  // If a service worker handled the request, we don't know if the origin in the\n-  // src is the same as the actual response URL so can't rely on URL checks\n-  // alone. So detect an opaque response via\n-  // DidGetOpaqueResponseFromServiceWorker().\n-  if (GetWebMediaPlayer() &&\n-      GetWebMediaPlayer()->DidGetOpaqueResponseFromServiceWorker()) {\n-    return false;\n-  }\n-\n-  // At this point, either a service worker was not used, or it didn't provide\n-  // an opaque response, so continue with the normal checks.\n+  if (!GetWebMediaPlayer())\n+    return true;\n \n-  // HasSingleSecurityOrigin() tells us whether the origin in the src\n-  // is the same as the actual request (i.e. after redirects).\n-  if (!HasSingleSecurityOrigin())\n+  const auto network_state = GetWebMediaPlayer()->GetNetworkState();\n+  if (network_state == WebMediaPlayer::kNetworkStateNetworkError)\n     return false;\n \n-  // DidPassCORSAccessCheck() means it was a successful CORS-enabled fetch (vs.\n-  // non-CORS-enabled or failed). CanReadContent() does CheckAccess() on the\n-  // URL plus allows data sources, to ensure that it is not a URL that requires\n-  // CORS (basically same origin).\n-  return (GetWebMediaPlayer() &&\n-          GetWebMediaPlayer()->DidPassCORSAccessCheck()) ||\n-         origin->CanReadContent(currentSrc());\n+  return !GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n bool HTMLMediaElement::IsInCrossOriginFrame() const {""}<_**next**_>{""sha"": ""f2d50264a53a0a3002725b06b6363091f4e17faa"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -268,11 +268,6 @@ class CORE_EXPORT HTMLMediaElement\n   // of one of them here.\n   using HTMLElement::GetExecutionContext;\n \n-  bool HasSingleSecurityOrigin() const {\n-    return GetWebMediaPlayer() ? GetWebMediaPlayer()->HasSingleSecurityOrigin()\n-                               : true;\n-  }\n-\n   bool IsFullscreen() const;\n   virtual bool UsesOverlayFullscreenVideo() const { return false; }\n ""}<_**next**_>{""sha"": ""8cf3a926979a853d0ba0f48f9def6bc9b4aec36a"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 17, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -958,21 +958,4 @@ void BaseAudioContext::UpdateWorkletGlobalScopeOnRenderingThread() {\n   }\n }\n \n-bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {\n-  // Data URLs don't taint the origin.\n-  if (url.ProtocolIsData()) {\n-    return false;\n-  }\n-\n-  Document* document = GetDocument();\n-  if (document && document->GetSecurityOrigin()) {\n-    // The origin is tainted if and only if we cannot read content from the URL.\n-    return !document->GetSecurityOrigin()->CanRequest(url);\n-  }\n-\n-  // Be conservative and assume it's tainted if it's not a data url and if we\n-  // can't get the security origin of the document.\n-  return true;\n-}\n-\n }  // namespace blink""}<_**next**_>{""sha"": ""ae933f20167fb374b51ff5a869d9381f97b56d4b"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -296,13 +296,6 @@ class MODULES_EXPORT BaseAudioContext\n   // Does nothing when the worklet global scope does not exist.\n   void UpdateWorkletGlobalScopeOnRenderingThread();\n \n-  // Returns true if the URL would taint the origin so that we shouldn't be\n-  // allowing media to played through webaudio.\n-  // TODO(crbug.com/845913): This should really be on an AudioContext.  Move\n-  // this when we move the media stuff from BaseAudioContext to AudioContext, as\n-  // requried by the spec.\n-  bool WouldTaintOrigin(const KURL& url) const;\n-\n  protected:\n   enum ContextType { kRealtimeContext, kOfflineContext };\n ""}<_**next**_>{""sha"": ""d7b07b5fea75809b4e14c8fda74b38a1d48e6b9d"", ""filename"": ""third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 13, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -136,19 +136,7 @@ void MediaElementAudioSourceHandler::SetFormat(size_t number_of_channels,\n }\n \n bool MediaElementAudioSourceHandler::WouldTaintOrigin() {\n-  // If we're cross-origin and allowed access vie CORS, we're not tainted.\n-  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {\n-    return false;\n-  }\n-\n-  // Handles the case where the url is a redirect to another site that we're not\n-  // allowed to access.\n-  if (!MediaElement()->HasSingleSecurityOrigin()) {\n-    return true;\n-  }\n-\n-  // Test to see if the current media URL taint the origin of the audio context?\n-  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());\n+  return MediaElement()->GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n void MediaElementAudioSourceHandler::PrintCORSMessage(const String& message) {""}<_**next**_>{""sha"": ""6e5771836bf84527d922a6c5fc84a3aa5c8c9bce"", ""filename"": ""third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/testing/empty_web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -50,9 +50,7 @@ class EmptyWebMediaPlayer : public WebMediaPlayer {\n   ReadyState GetReadyState() const override { return kReadyStateHaveNothing; }\n   WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override { return false; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double time_value) const override {\n     return time_value;\n   };""}","bool MultibufferDataSource::DidPassCORSAccessCheck() const {
","bool MultibufferDataSource::DidPassCORSAccessCheck() const {
  if (url_data()->cors_mode() == UrlData::CORS_UNSPECIFIED)
    return false;
  if (init_cb_)
    return false;
  if (failed_)
    return false;
  return true;
}
",C,,"  if (url_data()->cors_mode() == UrlData::CORS_UNSPECIFIED)
    return false;
  if (init_cb_)
    return false;
  if (failed_)
    return false;
  return true;
}
",,"@@ -286,23 +286,8 @@ bool MultibufferDataSource::HasSingleOrigin() {
   return single_origin_;
 }
 
-bool MultibufferDataSource::DidPassCORSAccessCheck() const {
-  if (url_data()->cors_mode() == UrlData::CORS_UNSPECIFIED)
-    return false;
-
-  // If init_cb is set, we know initialization is not finished yet.
-  if (init_cb_)
-    return false;
-  if (failed_)
-    return false;
-  return true;
-}
-
-bool MultibufferDataSource::DidGetOpaqueResponseViaServiceWorker() const {
-  return url_data()->has_opaque_data();
-
-  // TODO(falken): Do we need to do something about |init_cb_| like
-  // in DidPassCORSAccessCheck()?
+bool MultibufferDataSource::IsCorsCrossOrigin() const {
+  return url_data()->is_cors_cross_origin();
 }
 
 void MultibufferDataSource::MediaPlaybackRateChanged(double playback_rate) {
@@ -627,8 +612,6 @@ void MultibufferDataSource::StartCallback() {
     // Progress callback might be called after the start callback,
     // make sure that we update single_origin_ now.
     media_log_->SetBooleanProperty(""single_origin"", single_origin_);
-    media_log_->SetBooleanProperty(""passed_cors_access_check"",
-                                   DidPassCORSAccessCheck());
     media_log_->SetBooleanProperty(""range_header_supported"",
                                    url_data()->range_supported());
   }",Chrome,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,50436d878b2e92de4231fda47328a8a4e884ecc3,1,"bool MultibufferDataSource::DidPassCORSAccessCheck() const {
//flaw_line_below:
  if (url_data()->cors_mode() == UrlData::CORS_UNSPECIFIED)
//flaw_line_below:
    return false;
//flaw_line_below:

//flaw_line_below:
  // If init_cb is set, we know initialization is not finished yet.
//flaw_line_below:
  if (init_cb_)
//flaw_line_below:
    return false;
//flaw_line_below:
  if (failed_)
//flaw_line_below:
    return false;
//flaw_line_below:
  return true;
//flaw_line_below:
}
"
8866,186602,,Remote,Not required,,CVE-2018-18352,https://www.cvedetails.com/cve/CVE-2018-18352/,CWE-732,Medium,Partial,,,2018-12-11,4.3,Service works could inappropriately gain access to cross origin audio in Media in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to bypass same origin policy for audio content via a crafted HTML page.,2019-10-02,Bypass ,0,https://github.com/chromium/chromium/commit/a9cbaa7a40e2b2723cfc2f266c42f4980038a949,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,"Simplify ""WouldTaintOrigin"" concept in media/blink

Currently WebMediaPlayer has three predicates:
 - DidGetOpaqueResponseFromServiceWorker
 - HasSingleSecurityOrigin
 - DidPassCORSAccessCheck
. These are used to determine whether the response body is available
for scripts. They are known to be confusing, and actually
MediaElementAudioSourceHandler::WouldTaintOrigin misuses them.

This CL merges the three predicates to one, WouldTaintOrigin, to remove
the confusion. Now the ""response type"" concept is available and we
don't need a custom CORS check, so this CL removes
BaseAudioContext::WouldTaintOrigin. This CL also renames
URLData::has_opaque_data_ and its (direct and indirect) data accessors
to match the spec.

Bug: 849942, 875153
Change-Id: I6acf50169d7445c4ff614e80ac606f79ee577d2a
Reviewed-on: https://chromium-review.googlesource.com/c/1238098
Reviewed-by: Fredrik Hubinette <hubbe@chromium.org>
Reviewed-by: Kinuko Yasuda <kinuko@chromium.org>
Reviewed-by: Raymond Toy <rtoy@chromium.org>
Commit-Queue: Yutaka Hirano <yhirano@chromium.org>
Cr-Commit-Position: refs/heads/master@{#598258}",2,media/blink/multibuffer_data_source.cc,"{""sha"": ""78ca5e2c3c323cf55e23eacc262e8a197e60b63b"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 11, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -844,21 +844,11 @@ void WebMediaPlayerMS::Paint(cc::PaintCanvas* canvas,\n                         context_3d, context_support);\n }\n \n-bool WebMediaPlayerMS::DidGetOpaqueResponseFromServiceWorker() const {\n+bool WebMediaPlayerMS::WouldTaintOrigin() const {\n   DCHECK(thread_checker_.CalledOnValidThread());\n   return false;\n }\n \n-bool WebMediaPlayerMS::HasSingleSecurityOrigin() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n-bool WebMediaPlayerMS::DidPassCORSAccessCheck() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n double WebMediaPlayerMS::MediaTimeForTimeValue(double timeValue) const {\n   return base::TimeDelta::FromSecondsD(timeValue).InSecondsF();\n }""}<_**next**_>{""sha"": ""8c3595505cb20fa379b861f49b28710c40f3a5f1"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -163,9 +163,7 @@ class CONTENT_EXPORT WebMediaPlayerMS\n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n \n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n ""}<_**next**_>{""sha"": ""d26bc8142d80dc7c64958a9c22170244d6e664dd"", ""filename"": ""content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -76,9 +76,7 @@ class MockWebMediaPlayer : public blink::WebMediaPlayer,\n   }\n \n   bool DidLoadingProgress() override { return true; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double timeValue) const override { return 0.0; }\n   unsigned DecodedFrameCount() const override { return 0; }\n   unsigned DroppedFrameCount() const override { return 0; }""}<_**next**_>{""sha"": ""74ad44546ee34afa79b4a1649710117f8532c5f4"", ""filename"": ""media/blink/multibuffer_data_source.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 19, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -286,23 +286,8 @@ bool MultibufferDataSource::HasSingleOrigin() {\n   return single_origin_;\n }\n \n-bool MultibufferDataSource::DidPassCORSAccessCheck() const {\n-  if (url_data()->cors_mode() == UrlData::CORS_UNSPECIFIED)\n-    return false;\n-\n-  // If init_cb is set, we know initialization is not finished yet.\n-  if (init_cb_)\n-    return false;\n-  if (failed_)\n-    return false;\n-  return true;\n-}\n-\n-bool MultibufferDataSource::DidGetOpaqueResponseViaServiceWorker() const {\n-  return url_data()->has_opaque_data();\n-\n-  // TODO(falken): Do we need to do something about |init_cb_| like\n-  // in DidPassCORSAccessCheck()?\n+bool MultibufferDataSource::IsCorsCrossOrigin() const {\n+  return url_data()->is_cors_cross_origin();\n }\n \n void MultibufferDataSource::MediaPlaybackRateChanged(double playback_rate) {\n@@ -627,8 +612,6 @@ void MultibufferDataSource::StartCallback() {\n     // Progress callback might be called after the start callback,\n     // make sure that we update single_origin_ now.\n     media_log_->SetBooleanProperty(\""single_origin\"", single_origin_);\n-    media_log_->SetBooleanProperty(\""passed_cors_access_check\"",\n-                                   DidPassCORSAccessCheck());\n     media_log_->SetBooleanProperty(\""range_header_supported\"",\n                                    url_data()->range_supported());\n   }""}<_**next**_>{""sha"": ""4da62a5519e33ab6e726406f0acac4995c4ad49f"", ""filename"": ""media/blink/multibuffer_data_source.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 6, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -79,12 +79,9 @@ class MEDIA_BLINK_EXPORT MultibufferDataSource : public DataSource {\n   // Method called on the render thread.\n   bool HasSingleOrigin();\n \n-  // Returns true if the media resource passed a CORS access control check.\n-  bool DidPassCORSAccessCheck() const;\n-\n-  // Returns true if a service worker provided the media resource response,\n-  // and the response was opaque.\n-  bool DidGetOpaqueResponseViaServiceWorker() const;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  // This must be called after the response arrives.\n+  bool IsCorsCrossOrigin() const;\n \n   // Notifies changes in playback state for controlling media buffering\n   // behavior.""}<_**next**_>{""sha"": ""4b9f83e74255bf14d33c3f0c2785c282ecb2bcd7"", ""filename"": ""media/blink/multibuffer_data_source_unittest.cc"", ""status"": ""modified"", ""additions"": 81, ""deletions"": 12, ""changes"": 93, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1493,35 +1493,104 @@ TEST_F(MultibufferDataSourceTest, FileSizeLessThanBlockSize) {\n   Stop();\n }\n \n-TEST_F(MultibufferDataSourceTest, DidPassCORSAccessTest) {\n+TEST_F(MultibufferDataSourceTest, ResponseTypeBasic) {\n   InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n   set_preload(MultibufferDataSource::NONE);\n   WebURLResponse response1 =\n       response_generator_->GeneratePartial206(0, kDataSize - 1);\n-  response1.SetWasFetchedViaServiceWorker(true);\n-  std::vector<blink::WebURL> urlList = {GURL(kHttpDifferentOriginUrl)};\n-  response1.SetURLListViaServiceWorker(urlList);\n-  WebURLResponse response2 =\n-      response_generator_->GeneratePartial206(kDataSize, kDataSize * 2 - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kBasic);\n \n   EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n   EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n   EXPECT_CALL(*this, ReadCallback(kDataSize));\n \n-  EXPECT_FALSE(data_source_->DidPassCORSAccessCheck());\n   Respond(response1);\n   ReceiveData(kDataSize);\n   ReadAt(0);\n   EXPECT_TRUE(loading());\n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n   FinishLoading();\n+}\n \n-  // Verify that if reader_ is null, DidPassCORSAccessCheck still returns true.\n-  data_source_->Stop();\n-  base::RunLoop().RunUntilIdle();\n+TEST_F(MultibufferDataSourceTest, ResponseTypeCors) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kCORS);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeDefault) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kDefault);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaque) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaque);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaqueRedirect) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaqueRedirect);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n }\n \n TEST_F(MultibufferDataSourceTest, EtagTest) {""}<_**next**_>{""sha"": ""89f1c9e70d2cc71646df50026b50d54d471d20c6"", ""filename"": ""media/blink/resource_multibuffer_data_provider.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/resource_multibuffer_data_provider.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -280,6 +280,8 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n   int64_t content_length = response.ExpectedContentLength();\n   bool end_of_file = false;\n   bool do_fail = false;\n+  // We get the response type here because aborting the loader may change it.\n+  const auto response_type = response.GetType();\n   bytes_to_discard_ = 0;\n \n   // We make a strong assumption that when we reach here we have either\n@@ -333,10 +335,9 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n         url_data_->url_index()->TryInsert(destination_url_data);\n   }\n \n-  // This is vital for security! A service worker can respond with a response\n-  // from a different origin, so this response type is needed to detect that.\n-  destination_url_data->set_has_opaque_data(\n-      network::cors::IsCORSCrossOriginResponseType(response.GetType()));\n+  // This is vital for security!\n+  destination_url_data->set_is_cors_cross_origin(\n+      network::cors::IsCORSCrossOriginResponseType(response_type));\n \n   if (destination_url_data != url_data_) {\n     // At this point, we've encountered a redirect, or found a better url data""}<_**next**_>{""sha"": ""3fb63497791a3d2a0ea1e3b12c018f4b2c5fe355"", ""filename"": ""media/blink/url_index.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 7, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -65,7 +65,6 @@ UrlData::UrlData(const GURL& url, CORSMode cors_mode, UrlIndex* url_index)\n       length_(kPositionNotSpecified),\n       range_supported_(false),\n       cacheable_(false),\n-      has_opaque_data_(false),\n       last_used_(),\n       multibuffer_(this, url_index_->block_shift_) {}\n \n@@ -103,9 +102,8 @@ void UrlData::MergeFrom(const scoped_refptr<UrlData>& other) {\n       last_modified_ = other->last_modified_;\n     }\n     bytes_read_from_cache_ += other->bytes_read_from_cache_;\n-    // set_has_opaque_data() will not relax from opaque to non-opaque if already\n-    // opaque.\n-    set_has_opaque_data(other->has_opaque_data_);\n+    // is_cors_corss_origin_ will not relax from true to false.\n+    set_is_cors_cross_origin(other->is_cors_cross_origin_);\n     multibuffer()->MergeFrom(other->multibuffer());\n   }\n }\n@@ -122,10 +120,10 @@ void UrlData::set_length(int64_t length) {\n   }\n }\n \n-void UrlData::set_has_opaque_data(bool has_opaque_data) {\n-  if (has_opaque_data_)\n+void UrlData::set_is_cors_cross_origin(bool is_cors_cross_origin) {\n+  if (is_cors_cross_origin_)\n     return;\n-  has_opaque_data_ = has_opaque_data;\n+  is_cors_cross_origin_ = is_cors_cross_origin;\n }\n \n void UrlData::RedirectTo(const scoped_refptr<UrlData>& url_data) {""}<_**next**_>{""sha"": ""2c15bc7ac0ad4489a0c922f614889e575bd5d863"", ""filename"": ""media/blink/url_index.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -125,7 +125,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // Returns our url_index.\n   UrlIndex* url_index() const { return url_index_; }\n \n-  bool has_opaque_data() const { return has_opaque_data_; }\n+  // This must be called after the response arrives.\n+  bool is_cors_cross_origin() const { return is_cors_cross_origin_; }\n \n   // Notifies the url index that this is currently used.\n   // The url <-> URLData mapping will be eventually be invalidated if\n@@ -145,7 +146,7 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   void set_range_supported();\n   void set_last_modified(base::Time last_modified);\n   void set_etag(const std::string& etag);\n-  void set_has_opaque_data(bool has_opaque_data);\n+  void set_is_cors_cross_origin(bool is_cors_cross_origin);\n \n   // A redirect has occured (or we've found a better UrlData for the same\n   // resource).\n@@ -238,9 +239,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // will not cache this url.\n   bool cacheable_;\n \n-  // True if a service worker intercepted a request for this resource\n-  // and provided an opaque response.\n-  bool has_opaque_data_;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  bool is_cors_cross_origin_ = false;\n \n   // Last time some media time used this resource.\n   // Note that we use base::Time rather than base::TimeTicks because""}<_**next**_>{""sha"": ""cf0857d8c6283758b159609f76da1bafb19cc789"", ""filename"": ""media/blink/webmediaplayer_impl.cc"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 10, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1175,12 +1175,6 @@ void WebMediaPlayerImpl::Paint(cc::PaintCanvas* canvas,\n       context_support);\n }\n \n-bool WebMediaPlayerImpl::DidGetOpaqueResponseFromServiceWorker() const {\n-  if (data_source_)\n-    return data_source_->DidGetOpaqueResponseViaServiceWorker();\n-  return false;\n-}\n-\n bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   if (demuxer_found_hls_) {\n     // HLS manifests might pull segments from a different origin. We can't know\n@@ -1193,10 +1187,15 @@ bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   return true;\n }\n \n-bool WebMediaPlayerImpl::DidPassCORSAccessCheck() const {\n-  if (data_source_)\n-    return data_source_->DidPassCORSAccessCheck();\n-  return false;\n+bool WebMediaPlayerImpl::WouldTaintOrigin() const {\n+  if (!HasSingleSecurityOrigin()) {\n+    // When the resource is redirected to another origin we think it as\n+    // tainted. This is actually not specified, and is under discussion.\n+    // See https://github.com/whatwg/fetch/issues/737.\n+    return true;\n+  }\n+\n+  return data_source_ && data_source_->IsCorsCrossOrigin();\n }\n \n double WebMediaPlayerImpl::MediaTimeForTimeValue(double timeValue) const {""}<_**next**_>{""sha"": ""233e37b4614544e9b2a67b4e5edee775de0f79a6"", ""filename"": ""media/blink/webmediaplayer_impl.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -188,10 +188,7 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n \n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n-\n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n \n@@ -332,6 +329,8 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n   void OnPipelineResumed();\n   void OnDemuxerOpened();\n \n+  bool HasSingleSecurityOrigin() const;\n+\n   // Pipeline::Client overrides.\n   void OnError(PipelineStatus status) override;\n   void OnEnded() override;""}<_**next**_>{""sha"": ""9821759bc7b311672a54387edc7d8c26a11d5e54"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""status"": ""added"", ""additions"": 47, ""deletions"": 0, ""changes"": 47, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -0,0 +1,47 @@\n+<!doctype html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+<script src=\""/common/get-host-info.sub.js\""></script>\n+<script src=\""resources/test-helpers.sub.js?pipe=sub\""></script>\n+<script>\n+promise_test(async (t) => {\n+    const SCOPE = 'resources/empty.html';\n+    const SCRIPT = 'resources/fetch-rewrite-worker.js';\n+    const host_info = get_host_info();\n+    const REMOTE_ORIGIN = host_info.HTTPS_REMOTE_ORIGIN;\n+\n+    const reg = await service_worker_unregister_and_register(t, SCRIPT, SCOPE);\n+    await wait_for_state(t, reg.installing, 'activated');\n+    const frame = await with_iframe(SCOPE);\n+\n+    const doc = frame.contentDocument;\n+    const win = frame.contentWindow;\n+\n+    const context = new win.AudioContext();\n+    try {\n+      context.suspend();\n+      const audio = doc.createElement('audio');\n+      audio.autoplay = true;\n+      const source = context.createMediaElementSource(audio);\n+      const spn = context.createScriptProcessor(16384, 1, 1);\n+      source.connect(spn).connect(context.destination);\n+      const url = `${REMOTE_ORIGIN}/webaudio/resources/sin_440Hz_-6dBFS_1s.wav`;\n+      audio.src = '/test?url=' + encodeURIComponent(url);\n+      doc.body.appendChild(audio);\n+\n+      await new Promise((resolve) => {\n+        audio.addEventListener('playing', resolve);\n+      });\n+      await context.resume();\n+      const event = await new Promise((resolve) => {\n+        spn.addEventListener('audioprocess', resolve);\n+      });\n+      const data = event.inputBuffer.getChannelData(0);\n+      for (const e of data) {\n+        assert_equals(e, 0);\n+      }\n+    } finally {\n+      context.close();\n+    }\n+  }, 'Verify CORS XHR of fetch() in a Service Worker');\n+</script>""}<_**next**_>{""sha"": ""319648dbc16669ab3b3238d8488997b7d3a7c837"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""58697c0661a94d03e4bbe74134a23e71a860f5f6"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""a1e82caf7e2f9d37d785165a4766f42acb28c465"", ""filename"": ""third_party/blink/public/platform/web_media_player.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/public/platform/web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -207,9 +207,10 @@ class WebMediaPlayer {\n \n   virtual bool DidLoadingProgress() = 0;\n \n-  virtual bool DidGetOpaqueResponseFromServiceWorker() const = 0;\n-  virtual bool HasSingleSecurityOrigin() const = 0;\n-  virtual bool DidPassCORSAccessCheck() const = 0;\n+  // Returns true if the response is CORS-cross-origin and so we shouldn't be\n+  // allowing media to play through webaudio.\n+  // This should be called after the response has arrived.\n+  virtual bool WouldTaintOrigin() const = 0;\n \n   virtual double MediaTimeForTimeValue(double time_value) const = 0;\n ""}<_**next**_>{""sha"": ""ad708c861bb80cd8a01217eec51f9fe058af4a33"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 21, ""changes"": 26, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1506,30 +1506,14 @@ bool HTMLMediaElement::IsSafeToLoadURL(const KURL& url,\n \n bool HTMLMediaElement::IsMediaDataCORSSameOrigin(\n     const SecurityOrigin* origin) const {\n-  // If a service worker handled the request, we don't know if the origin in the\n-  // src is the same as the actual response URL so can't rely on URL checks\n-  // alone. So detect an opaque response via\n-  // DidGetOpaqueResponseFromServiceWorker().\n-  if (GetWebMediaPlayer() &&\n-      GetWebMediaPlayer()->DidGetOpaqueResponseFromServiceWorker()) {\n-    return false;\n-  }\n-\n-  // At this point, either a service worker was not used, or it didn't provide\n-  // an opaque response, so continue with the normal checks.\n+  if (!GetWebMediaPlayer())\n+    return true;\n \n-  // HasSingleSecurityOrigin() tells us whether the origin in the src\n-  // is the same as the actual request (i.e. after redirects).\n-  if (!HasSingleSecurityOrigin())\n+  const auto network_state = GetWebMediaPlayer()->GetNetworkState();\n+  if (network_state == WebMediaPlayer::kNetworkStateNetworkError)\n     return false;\n \n-  // DidPassCORSAccessCheck() means it was a successful CORS-enabled fetch (vs.\n-  // non-CORS-enabled or failed). CanReadContent() does CheckAccess() on the\n-  // URL plus allows data sources, to ensure that it is not a URL that requires\n-  // CORS (basically same origin).\n-  return (GetWebMediaPlayer() &&\n-          GetWebMediaPlayer()->DidPassCORSAccessCheck()) ||\n-         origin->CanReadContent(currentSrc());\n+  return !GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n bool HTMLMediaElement::IsInCrossOriginFrame() const {""}<_**next**_>{""sha"": ""f2d50264a53a0a3002725b06b6363091f4e17faa"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -268,11 +268,6 @@ class CORE_EXPORT HTMLMediaElement\n   // of one of them here.\n   using HTMLElement::GetExecutionContext;\n \n-  bool HasSingleSecurityOrigin() const {\n-    return GetWebMediaPlayer() ? GetWebMediaPlayer()->HasSingleSecurityOrigin()\n-                               : true;\n-  }\n-\n   bool IsFullscreen() const;\n   virtual bool UsesOverlayFullscreenVideo() const { return false; }\n ""}<_**next**_>{""sha"": ""8cf3a926979a853d0ba0f48f9def6bc9b4aec36a"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 17, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -958,21 +958,4 @@ void BaseAudioContext::UpdateWorkletGlobalScopeOnRenderingThread() {\n   }\n }\n \n-bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {\n-  // Data URLs don't taint the origin.\n-  if (url.ProtocolIsData()) {\n-    return false;\n-  }\n-\n-  Document* document = GetDocument();\n-  if (document && document->GetSecurityOrigin()) {\n-    // The origin is tainted if and only if we cannot read content from the URL.\n-    return !document->GetSecurityOrigin()->CanRequest(url);\n-  }\n-\n-  // Be conservative and assume it's tainted if it's not a data url and if we\n-  // can't get the security origin of the document.\n-  return true;\n-}\n-\n }  // namespace blink""}<_**next**_>{""sha"": ""ae933f20167fb374b51ff5a869d9381f97b56d4b"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -296,13 +296,6 @@ class MODULES_EXPORT BaseAudioContext\n   // Does nothing when the worklet global scope does not exist.\n   void UpdateWorkletGlobalScopeOnRenderingThread();\n \n-  // Returns true if the URL would taint the origin so that we shouldn't be\n-  // allowing media to played through webaudio.\n-  // TODO(crbug.com/845913): This should really be on an AudioContext.  Move\n-  // this when we move the media stuff from BaseAudioContext to AudioContext, as\n-  // requried by the spec.\n-  bool WouldTaintOrigin(const KURL& url) const;\n-\n  protected:\n   enum ContextType { kRealtimeContext, kOfflineContext };\n ""}<_**next**_>{""sha"": ""d7b07b5fea75809b4e14c8fda74b38a1d48e6b9d"", ""filename"": ""third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 13, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -136,19 +136,7 @@ void MediaElementAudioSourceHandler::SetFormat(size_t number_of_channels,\n }\n \n bool MediaElementAudioSourceHandler::WouldTaintOrigin() {\n-  // If we're cross-origin and allowed access vie CORS, we're not tainted.\n-  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {\n-    return false;\n-  }\n-\n-  // Handles the case where the url is a redirect to another site that we're not\n-  // allowed to access.\n-  if (!MediaElement()->HasSingleSecurityOrigin()) {\n-    return true;\n-  }\n-\n-  // Test to see if the current media URL taint the origin of the audio context?\n-  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());\n+  return MediaElement()->GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n void MediaElementAudioSourceHandler::PrintCORSMessage(const String& message) {""}<_**next**_>{""sha"": ""6e5771836bf84527d922a6c5fc84a3aa5c8c9bce"", ""filename"": ""third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/testing/empty_web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -50,9 +50,7 @@ class EmptyWebMediaPlayer : public WebMediaPlayer {\n   ReadyState GetReadyState() const override { return kReadyStateHaveNothing; }\n   WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override { return false; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double time_value) const override {\n     return time_value;\n   };""}","void MultibufferDataSource::StartCallback() {
  DCHECK(render_task_runner_->BelongsToCurrentThread());

  if (!init_cb_) {
    SetReader(nullptr);
    return;
  }

  bool success = reader_ && reader_->Available() > 0 && url_data() &&
                 (!assume_fully_buffered() ||
                  url_data()->length() != kPositionNotSpecified);

  if (success) {
    {
      base::AutoLock auto_lock(lock_);
      total_bytes_ = url_data()->length();
    }
    streaming_ =
        !assume_fully_buffered() && (total_bytes_ == kPositionNotSpecified ||
                                     !url_data()->range_supported());

    media_log_->SetDoubleProperty(""total_bytes"",
                                  static_cast<double>(total_bytes_));
    media_log_->SetBooleanProperty(""streaming"", streaming_);
  } else {
    SetReader(nullptr);
  }

  base::AutoLock auto_lock(lock_);
  if (stop_signal_received_)
    return;

  if (success) {
    if (total_bytes_ != kPositionNotSpecified) {
      host_->SetTotalBytes(total_bytes_);
      if (assume_fully_buffered())
        host_->AddBufferedByteRange(0, total_bytes_);
    }

     media_log_->SetBooleanProperty(""single_origin"", single_origin_);
     media_log_->SetBooleanProperty(""range_header_supported"",
                                    url_data()->range_supported());
   }

  render_task_runner_->PostTask(FROM_HERE,
                                base::Bind(std::move(init_cb_), success));

  UpdateBufferSizes();

  UpdateLoadingState_Locked(true);
}
","void MultibufferDataSource::StartCallback() {
  DCHECK(render_task_runner_->BelongsToCurrentThread());

  if (!init_cb_) {
    SetReader(nullptr);
    return;
  }

  bool success = reader_ && reader_->Available() > 0 && url_data() &&
                 (!assume_fully_buffered() ||
                  url_data()->length() != kPositionNotSpecified);

  if (success) {
    {
      base::AutoLock auto_lock(lock_);
      total_bytes_ = url_data()->length();
    }
    streaming_ =
        !assume_fully_buffered() && (total_bytes_ == kPositionNotSpecified ||
                                     !url_data()->range_supported());

    media_log_->SetDoubleProperty(""total_bytes"",
                                  static_cast<double>(total_bytes_));
    media_log_->SetBooleanProperty(""streaming"", streaming_);
  } else {
    SetReader(nullptr);
  }

  base::AutoLock auto_lock(lock_);
  if (stop_signal_received_)
    return;

  if (success) {
    if (total_bytes_ != kPositionNotSpecified) {
      host_->SetTotalBytes(total_bytes_);
      if (assume_fully_buffered())
        host_->AddBufferedByteRange(0, total_bytes_);
    }

     media_log_->SetBooleanProperty(""single_origin"", single_origin_);
    media_log_->SetBooleanProperty(""passed_cors_access_check"",
                                   DidPassCORSAccessCheck());
     media_log_->SetBooleanProperty(""range_header_supported"",
                                    url_data()->range_supported());
   }

  render_task_runner_->PostTask(FROM_HERE,
                                base::Bind(std::move(init_cb_), success));

  UpdateBufferSizes();

  UpdateLoadingState_Locked(true);
}
",C,,"    media_log_->SetBooleanProperty(""passed_cors_access_check"",
                                   DidPassCORSAccessCheck());
",,"@@ -286,23 +286,8 @@ bool MultibufferDataSource::HasSingleOrigin() {
   return single_origin_;
 }
 
-bool MultibufferDataSource::DidPassCORSAccessCheck() const {
-  if (url_data()->cors_mode() == UrlData::CORS_UNSPECIFIED)
-    return false;
-
-  // If init_cb is set, we know initialization is not finished yet.
-  if (init_cb_)
-    return false;
-  if (failed_)
-    return false;
-  return true;
-}
-
-bool MultibufferDataSource::DidGetOpaqueResponseViaServiceWorker() const {
-  return url_data()->has_opaque_data();
-
-  // TODO(falken): Do we need to do something about |init_cb_| like
-  // in DidPassCORSAccessCheck()?
+bool MultibufferDataSource::IsCorsCrossOrigin() const {
+  return url_data()->is_cors_cross_origin();
 }
 
 void MultibufferDataSource::MediaPlaybackRateChanged(double playback_rate) {
@@ -627,8 +612,6 @@ void MultibufferDataSource::StartCallback() {
     // Progress callback might be called after the start callback,
     // make sure that we update single_origin_ now.
     media_log_->SetBooleanProperty(""single_origin"", single_origin_);
-    media_log_->SetBooleanProperty(""passed_cors_access_check"",
-                                   DidPassCORSAccessCheck());
     media_log_->SetBooleanProperty(""range_header_supported"",
                                    url_data()->range_supported());
   }",Chrome,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,50436d878b2e92de4231fda47328a8a4e884ecc3,1,"void MultibufferDataSource::StartCallback() {
  DCHECK(render_task_runner_->BelongsToCurrentThread());

  if (!init_cb_) {
    SetReader(nullptr);
    return;
  }

  // All responses must be successful. Resources that are assumed to be fully
  // buffered must have a known content length.
  bool success = reader_ && reader_->Available() > 0 && url_data() &&
                 (!assume_fully_buffered() ||
                  url_data()->length() != kPositionNotSpecified);

  if (success) {
    {
      base::AutoLock auto_lock(lock_);
      total_bytes_ = url_data()->length();
    }
    streaming_ =
        !assume_fully_buffered() && (total_bytes_ == kPositionNotSpecified ||
                                     !url_data()->range_supported());

    media_log_->SetDoubleProperty(""total_bytes"",
                                  static_cast<double>(total_bytes_));
    media_log_->SetBooleanProperty(""streaming"", streaming_);
  } else {
    SetReader(nullptr);
  }

  // TODO(scherkus): we shouldn't have to lock to signal host(), see
  // http://crbug.com/113712 for details.
  base::AutoLock auto_lock(lock_);
  if (stop_signal_received_)
    return;

  if (success) {
    if (total_bytes_ != kPositionNotSpecified) {
      host_->SetTotalBytes(total_bytes_);
      if (assume_fully_buffered())
        host_->AddBufferedByteRange(0, total_bytes_);
    }

     // Progress callback might be called after the start callback,
     // make sure that we update single_origin_ now.
     media_log_->SetBooleanProperty(""single_origin"", single_origin_);
//flaw_line_below:
    media_log_->SetBooleanProperty(""passed_cors_access_check"",
//flaw_line_below:
                                   DidPassCORSAccessCheck());
     media_log_->SetBooleanProperty(""range_header_supported"",
                                    url_data()->range_supported());
   }

  render_task_runner_->PostTask(FROM_HERE,
                                base::Bind(std::move(init_cb_), success));

  UpdateBufferSizes();

  // Even if data is cached, say that we're loading at this point for
  // compatibility.
  UpdateLoadingState_Locked(true);
}
"
8867,186603,,Remote,Not required,,CVE-2018-18352,https://www.cvedetails.com/cve/CVE-2018-18352/,CWE-732,Medium,Partial,,,2018-12-11,4.3,Service works could inappropriately gain access to cross origin audio in Media in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to bypass same origin policy for audio content via a crafted HTML page.,2019-10-02,Bypass ,5,https://github.com/chromium/chromium/commit/a9cbaa7a40e2b2723cfc2f266c42f4980038a949,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,"Simplify ""WouldTaintOrigin"" concept in media/blink

Currently WebMediaPlayer has three predicates:
 - DidGetOpaqueResponseFromServiceWorker
 - HasSingleSecurityOrigin
 - DidPassCORSAccessCheck
. These are used to determine whether the response body is available
for scripts. They are known to be confusing, and actually
MediaElementAudioSourceHandler::WouldTaintOrigin misuses them.

This CL merges the three predicates to one, WouldTaintOrigin, to remove
the confusion. Now the ""response type"" concept is available and we
don't need a custom CORS check, so this CL removes
BaseAudioContext::WouldTaintOrigin. This CL also renames
URLData::has_opaque_data_ and its (direct and indirect) data accessors
to match the spec.

Bug: 849942, 875153
Change-Id: I6acf50169d7445c4ff614e80ac606f79ee577d2a
Reviewed-on: https://chromium-review.googlesource.com/c/1238098
Reviewed-by: Fredrik Hubinette <hubbe@chromium.org>
Reviewed-by: Kinuko Yasuda <kinuko@chromium.org>
Reviewed-by: Raymond Toy <rtoy@chromium.org>
Commit-Queue: Yutaka Hirano <yhirano@chromium.org>
Cr-Commit-Position: refs/heads/master@{#598258}",2,media/blink/resource_multibuffer_data_provider.cc,"{""sha"": ""78ca5e2c3c323cf55e23eacc262e8a197e60b63b"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 11, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -844,21 +844,11 @@ void WebMediaPlayerMS::Paint(cc::PaintCanvas* canvas,\n                         context_3d, context_support);\n }\n \n-bool WebMediaPlayerMS::DidGetOpaqueResponseFromServiceWorker() const {\n+bool WebMediaPlayerMS::WouldTaintOrigin() const {\n   DCHECK(thread_checker_.CalledOnValidThread());\n   return false;\n }\n \n-bool WebMediaPlayerMS::HasSingleSecurityOrigin() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n-bool WebMediaPlayerMS::DidPassCORSAccessCheck() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n double WebMediaPlayerMS::MediaTimeForTimeValue(double timeValue) const {\n   return base::TimeDelta::FromSecondsD(timeValue).InSecondsF();\n }""}<_**next**_>{""sha"": ""8c3595505cb20fa379b861f49b28710c40f3a5f1"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -163,9 +163,7 @@ class CONTENT_EXPORT WebMediaPlayerMS\n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n \n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n ""}<_**next**_>{""sha"": ""d26bc8142d80dc7c64958a9c22170244d6e664dd"", ""filename"": ""content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -76,9 +76,7 @@ class MockWebMediaPlayer : public blink::WebMediaPlayer,\n   }\n \n   bool DidLoadingProgress() override { return true; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double timeValue) const override { return 0.0; }\n   unsigned DecodedFrameCount() const override { return 0; }\n   unsigned DroppedFrameCount() const override { return 0; }""}<_**next**_>{""sha"": ""74ad44546ee34afa79b4a1649710117f8532c5f4"", ""filename"": ""media/blink/multibuffer_data_source.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 19, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -286,23 +286,8 @@ bool MultibufferDataSource::HasSingleOrigin() {\n   return single_origin_;\n }\n \n-bool MultibufferDataSource::DidPassCORSAccessCheck() const {\n-  if (url_data()->cors_mode() == UrlData::CORS_UNSPECIFIED)\n-    return false;\n-\n-  // If init_cb is set, we know initialization is not finished yet.\n-  if (init_cb_)\n-    return false;\n-  if (failed_)\n-    return false;\n-  return true;\n-}\n-\n-bool MultibufferDataSource::DidGetOpaqueResponseViaServiceWorker() const {\n-  return url_data()->has_opaque_data();\n-\n-  // TODO(falken): Do we need to do something about |init_cb_| like\n-  // in DidPassCORSAccessCheck()?\n+bool MultibufferDataSource::IsCorsCrossOrigin() const {\n+  return url_data()->is_cors_cross_origin();\n }\n \n void MultibufferDataSource::MediaPlaybackRateChanged(double playback_rate) {\n@@ -627,8 +612,6 @@ void MultibufferDataSource::StartCallback() {\n     // Progress callback might be called after the start callback,\n     // make sure that we update single_origin_ now.\n     media_log_->SetBooleanProperty(\""single_origin\"", single_origin_);\n-    media_log_->SetBooleanProperty(\""passed_cors_access_check\"",\n-                                   DidPassCORSAccessCheck());\n     media_log_->SetBooleanProperty(\""range_header_supported\"",\n                                    url_data()->range_supported());\n   }""}<_**next**_>{""sha"": ""4da62a5519e33ab6e726406f0acac4995c4ad49f"", ""filename"": ""media/blink/multibuffer_data_source.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 6, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -79,12 +79,9 @@ class MEDIA_BLINK_EXPORT MultibufferDataSource : public DataSource {\n   // Method called on the render thread.\n   bool HasSingleOrigin();\n \n-  // Returns true if the media resource passed a CORS access control check.\n-  bool DidPassCORSAccessCheck() const;\n-\n-  // Returns true if a service worker provided the media resource response,\n-  // and the response was opaque.\n-  bool DidGetOpaqueResponseViaServiceWorker() const;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  // This must be called after the response arrives.\n+  bool IsCorsCrossOrigin() const;\n \n   // Notifies changes in playback state for controlling media buffering\n   // behavior.""}<_**next**_>{""sha"": ""4b9f83e74255bf14d33c3f0c2785c282ecb2bcd7"", ""filename"": ""media/blink/multibuffer_data_source_unittest.cc"", ""status"": ""modified"", ""additions"": 81, ""deletions"": 12, ""changes"": 93, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1493,35 +1493,104 @@ TEST_F(MultibufferDataSourceTest, FileSizeLessThanBlockSize) {\n   Stop();\n }\n \n-TEST_F(MultibufferDataSourceTest, DidPassCORSAccessTest) {\n+TEST_F(MultibufferDataSourceTest, ResponseTypeBasic) {\n   InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n   set_preload(MultibufferDataSource::NONE);\n   WebURLResponse response1 =\n       response_generator_->GeneratePartial206(0, kDataSize - 1);\n-  response1.SetWasFetchedViaServiceWorker(true);\n-  std::vector<blink::WebURL> urlList = {GURL(kHttpDifferentOriginUrl)};\n-  response1.SetURLListViaServiceWorker(urlList);\n-  WebURLResponse response2 =\n-      response_generator_->GeneratePartial206(kDataSize, kDataSize * 2 - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kBasic);\n \n   EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n   EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n   EXPECT_CALL(*this, ReadCallback(kDataSize));\n \n-  EXPECT_FALSE(data_source_->DidPassCORSAccessCheck());\n   Respond(response1);\n   ReceiveData(kDataSize);\n   ReadAt(0);\n   EXPECT_TRUE(loading());\n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n   FinishLoading();\n+}\n \n-  // Verify that if reader_ is null, DidPassCORSAccessCheck still returns true.\n-  data_source_->Stop();\n-  base::RunLoop().RunUntilIdle();\n+TEST_F(MultibufferDataSourceTest, ResponseTypeCors) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kCORS);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeDefault) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kDefault);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaque) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaque);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaqueRedirect) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaqueRedirect);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n }\n \n TEST_F(MultibufferDataSourceTest, EtagTest) {""}<_**next**_>{""sha"": ""89f1c9e70d2cc71646df50026b50d54d471d20c6"", ""filename"": ""media/blink/resource_multibuffer_data_provider.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/resource_multibuffer_data_provider.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -280,6 +280,8 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n   int64_t content_length = response.ExpectedContentLength();\n   bool end_of_file = false;\n   bool do_fail = false;\n+  // We get the response type here because aborting the loader may change it.\n+  const auto response_type = response.GetType();\n   bytes_to_discard_ = 0;\n \n   // We make a strong assumption that when we reach here we have either\n@@ -333,10 +335,9 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n         url_data_->url_index()->TryInsert(destination_url_data);\n   }\n \n-  // This is vital for security! A service worker can respond with a response\n-  // from a different origin, so this response type is needed to detect that.\n-  destination_url_data->set_has_opaque_data(\n-      network::cors::IsCORSCrossOriginResponseType(response.GetType()));\n+  // This is vital for security!\n+  destination_url_data->set_is_cors_cross_origin(\n+      network::cors::IsCORSCrossOriginResponseType(response_type));\n \n   if (destination_url_data != url_data_) {\n     // At this point, we've encountered a redirect, or found a better url data""}<_**next**_>{""sha"": ""3fb63497791a3d2a0ea1e3b12c018f4b2c5fe355"", ""filename"": ""media/blink/url_index.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 7, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -65,7 +65,6 @@ UrlData::UrlData(const GURL& url, CORSMode cors_mode, UrlIndex* url_index)\n       length_(kPositionNotSpecified),\n       range_supported_(false),\n       cacheable_(false),\n-      has_opaque_data_(false),\n       last_used_(),\n       multibuffer_(this, url_index_->block_shift_) {}\n \n@@ -103,9 +102,8 @@ void UrlData::MergeFrom(const scoped_refptr<UrlData>& other) {\n       last_modified_ = other->last_modified_;\n     }\n     bytes_read_from_cache_ += other->bytes_read_from_cache_;\n-    // set_has_opaque_data() will not relax from opaque to non-opaque if already\n-    // opaque.\n-    set_has_opaque_data(other->has_opaque_data_);\n+    // is_cors_corss_origin_ will not relax from true to false.\n+    set_is_cors_cross_origin(other->is_cors_cross_origin_);\n     multibuffer()->MergeFrom(other->multibuffer());\n   }\n }\n@@ -122,10 +120,10 @@ void UrlData::set_length(int64_t length) {\n   }\n }\n \n-void UrlData::set_has_opaque_data(bool has_opaque_data) {\n-  if (has_opaque_data_)\n+void UrlData::set_is_cors_cross_origin(bool is_cors_cross_origin) {\n+  if (is_cors_cross_origin_)\n     return;\n-  has_opaque_data_ = has_opaque_data;\n+  is_cors_cross_origin_ = is_cors_cross_origin;\n }\n \n void UrlData::RedirectTo(const scoped_refptr<UrlData>& url_data) {""}<_**next**_>{""sha"": ""2c15bc7ac0ad4489a0c922f614889e575bd5d863"", ""filename"": ""media/blink/url_index.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -125,7 +125,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // Returns our url_index.\n   UrlIndex* url_index() const { return url_index_; }\n \n-  bool has_opaque_data() const { return has_opaque_data_; }\n+  // This must be called after the response arrives.\n+  bool is_cors_cross_origin() const { return is_cors_cross_origin_; }\n \n   // Notifies the url index that this is currently used.\n   // The url <-> URLData mapping will be eventually be invalidated if\n@@ -145,7 +146,7 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   void set_range_supported();\n   void set_last_modified(base::Time last_modified);\n   void set_etag(const std::string& etag);\n-  void set_has_opaque_data(bool has_opaque_data);\n+  void set_is_cors_cross_origin(bool is_cors_cross_origin);\n \n   // A redirect has occured (or we've found a better UrlData for the same\n   // resource).\n@@ -238,9 +239,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // will not cache this url.\n   bool cacheable_;\n \n-  // True if a service worker intercepted a request for this resource\n-  // and provided an opaque response.\n-  bool has_opaque_data_;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  bool is_cors_cross_origin_ = false;\n \n   // Last time some media time used this resource.\n   // Note that we use base::Time rather than base::TimeTicks because""}<_**next**_>{""sha"": ""cf0857d8c6283758b159609f76da1bafb19cc789"", ""filename"": ""media/blink/webmediaplayer_impl.cc"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 10, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1175,12 +1175,6 @@ void WebMediaPlayerImpl::Paint(cc::PaintCanvas* canvas,\n       context_support);\n }\n \n-bool WebMediaPlayerImpl::DidGetOpaqueResponseFromServiceWorker() const {\n-  if (data_source_)\n-    return data_source_->DidGetOpaqueResponseViaServiceWorker();\n-  return false;\n-}\n-\n bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   if (demuxer_found_hls_) {\n     // HLS manifests might pull segments from a different origin. We can't know\n@@ -1193,10 +1187,15 @@ bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   return true;\n }\n \n-bool WebMediaPlayerImpl::DidPassCORSAccessCheck() const {\n-  if (data_source_)\n-    return data_source_->DidPassCORSAccessCheck();\n-  return false;\n+bool WebMediaPlayerImpl::WouldTaintOrigin() const {\n+  if (!HasSingleSecurityOrigin()) {\n+    // When the resource is redirected to another origin we think it as\n+    // tainted. This is actually not specified, and is under discussion.\n+    // See https://github.com/whatwg/fetch/issues/737.\n+    return true;\n+  }\n+\n+  return data_source_ && data_source_->IsCorsCrossOrigin();\n }\n \n double WebMediaPlayerImpl::MediaTimeForTimeValue(double timeValue) const {""}<_**next**_>{""sha"": ""233e37b4614544e9b2a67b4e5edee775de0f79a6"", ""filename"": ""media/blink/webmediaplayer_impl.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -188,10 +188,7 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n \n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n-\n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n \n@@ -332,6 +329,8 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n   void OnPipelineResumed();\n   void OnDemuxerOpened();\n \n+  bool HasSingleSecurityOrigin() const;\n+\n   // Pipeline::Client overrides.\n   void OnError(PipelineStatus status) override;\n   void OnEnded() override;""}<_**next**_>{""sha"": ""9821759bc7b311672a54387edc7d8c26a11d5e54"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""status"": ""added"", ""additions"": 47, ""deletions"": 0, ""changes"": 47, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -0,0 +1,47 @@\n+<!doctype html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+<script src=\""/common/get-host-info.sub.js\""></script>\n+<script src=\""resources/test-helpers.sub.js?pipe=sub\""></script>\n+<script>\n+promise_test(async (t) => {\n+    const SCOPE = 'resources/empty.html';\n+    const SCRIPT = 'resources/fetch-rewrite-worker.js';\n+    const host_info = get_host_info();\n+    const REMOTE_ORIGIN = host_info.HTTPS_REMOTE_ORIGIN;\n+\n+    const reg = await service_worker_unregister_and_register(t, SCRIPT, SCOPE);\n+    await wait_for_state(t, reg.installing, 'activated');\n+    const frame = await with_iframe(SCOPE);\n+\n+    const doc = frame.contentDocument;\n+    const win = frame.contentWindow;\n+\n+    const context = new win.AudioContext();\n+    try {\n+      context.suspend();\n+      const audio = doc.createElement('audio');\n+      audio.autoplay = true;\n+      const source = context.createMediaElementSource(audio);\n+      const spn = context.createScriptProcessor(16384, 1, 1);\n+      source.connect(spn).connect(context.destination);\n+      const url = `${REMOTE_ORIGIN}/webaudio/resources/sin_440Hz_-6dBFS_1s.wav`;\n+      audio.src = '/test?url=' + encodeURIComponent(url);\n+      doc.body.appendChild(audio);\n+\n+      await new Promise((resolve) => {\n+        audio.addEventListener('playing', resolve);\n+      });\n+      await context.resume();\n+      const event = await new Promise((resolve) => {\n+        spn.addEventListener('audioprocess', resolve);\n+      });\n+      const data = event.inputBuffer.getChannelData(0);\n+      for (const e of data) {\n+        assert_equals(e, 0);\n+      }\n+    } finally {\n+      context.close();\n+    }\n+  }, 'Verify CORS XHR of fetch() in a Service Worker');\n+</script>""}<_**next**_>{""sha"": ""319648dbc16669ab3b3238d8488997b7d3a7c837"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""58697c0661a94d03e4bbe74134a23e71a860f5f6"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""a1e82caf7e2f9d37d785165a4766f42acb28c465"", ""filename"": ""third_party/blink/public/platform/web_media_player.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/public/platform/web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -207,9 +207,10 @@ class WebMediaPlayer {\n \n   virtual bool DidLoadingProgress() = 0;\n \n-  virtual bool DidGetOpaqueResponseFromServiceWorker() const = 0;\n-  virtual bool HasSingleSecurityOrigin() const = 0;\n-  virtual bool DidPassCORSAccessCheck() const = 0;\n+  // Returns true if the response is CORS-cross-origin and so we shouldn't be\n+  // allowing media to play through webaudio.\n+  // This should be called after the response has arrived.\n+  virtual bool WouldTaintOrigin() const = 0;\n \n   virtual double MediaTimeForTimeValue(double time_value) const = 0;\n ""}<_**next**_>{""sha"": ""ad708c861bb80cd8a01217eec51f9fe058af4a33"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 21, ""changes"": 26, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1506,30 +1506,14 @@ bool HTMLMediaElement::IsSafeToLoadURL(const KURL& url,\n \n bool HTMLMediaElement::IsMediaDataCORSSameOrigin(\n     const SecurityOrigin* origin) const {\n-  // If a service worker handled the request, we don't know if the origin in the\n-  // src is the same as the actual response URL so can't rely on URL checks\n-  // alone. So detect an opaque response via\n-  // DidGetOpaqueResponseFromServiceWorker().\n-  if (GetWebMediaPlayer() &&\n-      GetWebMediaPlayer()->DidGetOpaqueResponseFromServiceWorker()) {\n-    return false;\n-  }\n-\n-  // At this point, either a service worker was not used, or it didn't provide\n-  // an opaque response, so continue with the normal checks.\n+  if (!GetWebMediaPlayer())\n+    return true;\n \n-  // HasSingleSecurityOrigin() tells us whether the origin in the src\n-  // is the same as the actual request (i.e. after redirects).\n-  if (!HasSingleSecurityOrigin())\n+  const auto network_state = GetWebMediaPlayer()->GetNetworkState();\n+  if (network_state == WebMediaPlayer::kNetworkStateNetworkError)\n     return false;\n \n-  // DidPassCORSAccessCheck() means it was a successful CORS-enabled fetch (vs.\n-  // non-CORS-enabled or failed). CanReadContent() does CheckAccess() on the\n-  // URL plus allows data sources, to ensure that it is not a URL that requires\n-  // CORS (basically same origin).\n-  return (GetWebMediaPlayer() &&\n-          GetWebMediaPlayer()->DidPassCORSAccessCheck()) ||\n-         origin->CanReadContent(currentSrc());\n+  return !GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n bool HTMLMediaElement::IsInCrossOriginFrame() const {""}<_**next**_>{""sha"": ""f2d50264a53a0a3002725b06b6363091f4e17faa"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -268,11 +268,6 @@ class CORE_EXPORT HTMLMediaElement\n   // of one of them here.\n   using HTMLElement::GetExecutionContext;\n \n-  bool HasSingleSecurityOrigin() const {\n-    return GetWebMediaPlayer() ? GetWebMediaPlayer()->HasSingleSecurityOrigin()\n-                               : true;\n-  }\n-\n   bool IsFullscreen() const;\n   virtual bool UsesOverlayFullscreenVideo() const { return false; }\n ""}<_**next**_>{""sha"": ""8cf3a926979a853d0ba0f48f9def6bc9b4aec36a"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 17, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -958,21 +958,4 @@ void BaseAudioContext::UpdateWorkletGlobalScopeOnRenderingThread() {\n   }\n }\n \n-bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {\n-  // Data URLs don't taint the origin.\n-  if (url.ProtocolIsData()) {\n-    return false;\n-  }\n-\n-  Document* document = GetDocument();\n-  if (document && document->GetSecurityOrigin()) {\n-    // The origin is tainted if and only if we cannot read content from the URL.\n-    return !document->GetSecurityOrigin()->CanRequest(url);\n-  }\n-\n-  // Be conservative and assume it's tainted if it's not a data url and if we\n-  // can't get the security origin of the document.\n-  return true;\n-}\n-\n }  // namespace blink""}<_**next**_>{""sha"": ""ae933f20167fb374b51ff5a869d9381f97b56d4b"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -296,13 +296,6 @@ class MODULES_EXPORT BaseAudioContext\n   // Does nothing when the worklet global scope does not exist.\n   void UpdateWorkletGlobalScopeOnRenderingThread();\n \n-  // Returns true if the URL would taint the origin so that we shouldn't be\n-  // allowing media to played through webaudio.\n-  // TODO(crbug.com/845913): This should really be on an AudioContext.  Move\n-  // this when we move the media stuff from BaseAudioContext to AudioContext, as\n-  // requried by the spec.\n-  bool WouldTaintOrigin(const KURL& url) const;\n-\n  protected:\n   enum ContextType { kRealtimeContext, kOfflineContext };\n ""}<_**next**_>{""sha"": ""d7b07b5fea75809b4e14c8fda74b38a1d48e6b9d"", ""filename"": ""third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 13, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -136,19 +136,7 @@ void MediaElementAudioSourceHandler::SetFormat(size_t number_of_channels,\n }\n \n bool MediaElementAudioSourceHandler::WouldTaintOrigin() {\n-  // If we're cross-origin and allowed access vie CORS, we're not tainted.\n-  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {\n-    return false;\n-  }\n-\n-  // Handles the case where the url is a redirect to another site that we're not\n-  // allowed to access.\n-  if (!MediaElement()->HasSingleSecurityOrigin()) {\n-    return true;\n-  }\n-\n-  // Test to see if the current media URL taint the origin of the audio context?\n-  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());\n+  return MediaElement()->GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n void MediaElementAudioSourceHandler::PrintCORSMessage(const String& message) {""}<_**next**_>{""sha"": ""6e5771836bf84527d922a6c5fc84a3aa5c8c9bce"", ""filename"": ""third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/testing/empty_web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -50,9 +50,7 @@ class EmptyWebMediaPlayer : public WebMediaPlayer {\n   ReadyState GetReadyState() const override { return kReadyStateHaveNothing; }\n   WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override { return false; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double time_value) const override {\n     return time_value;\n   };""}","void ResourceMultiBufferDataProvider::DidReceiveResponse(
    const WebURLResponse& response) {
#if DCHECK_IS_ON()
  std::string version;
  switch (response.HttpVersion()) {
    case WebURLResponse::kHTTPVersion_0_9:
      version = ""0.9"";
      break;
    case WebURLResponse::kHTTPVersion_1_0:
      version = ""1.0"";
      break;
    case WebURLResponse::kHTTPVersion_1_1:
      version = ""1.1"";
      break;
    case WebURLResponse::kHTTPVersion_2_0:
      version = ""2.1"";
      break;
    case WebURLResponse::kHTTPVersionUnknown:
      version = ""unknown"";
      break;
  }
  DVLOG(1) << ""didReceiveResponse: HTTP/"" << version << "" ""
           << response.HttpStatusCode();
#endif
  DCHECK(active_loader_);

  scoped_refptr<UrlData> destination_url_data(url_data_);

  if (!redirects_to_.is_empty()) {
    destination_url_data =
        url_data_->url_index()->GetByUrl(redirects_to_, cors_mode_);
    redirects_to_ = GURL();
  }

  base::Time last_modified;
  if (base::Time::FromString(
          response.HttpHeaderField(""Last-Modified"").Utf8().data(),
          &last_modified)) {
    destination_url_data->set_last_modified(last_modified);
  }

  destination_url_data->set_etag(
      response.HttpHeaderField(""ETag"").Utf8().data());

  destination_url_data->set_valid_until(base::Time::Now() +
                                        GetCacheValidUntil(response));

  uint32_t reasons = GetReasonsForUncacheability(response);
  destination_url_data->set_cacheable(reasons == 0);
  UMA_HISTOGRAM_BOOLEAN(""Media.CacheUseful"", reasons == 0);
  int shift = 0;
  int max_enum = base::bits::Log2Ceiling(kMaxReason);
  while (reasons) {
    DCHECK_LT(shift, max_enum);  // Sanity check.
    if (reasons & 0x1) {
      UMA_HISTOGRAM_EXACT_LINEAR(""Media.UncacheableReason"", shift,
                                 max_enum);  // PRESUBMIT_IGNORE_UMA_MAX
    }

    reasons >>= 1;
    ++shift;
  }

   int64_t content_length = response.ExpectedContentLength();
   bool end_of_file = false;
   bool do_fail = false;
  // We get the response type here because aborting the loader may change it.
  const auto response_type = response.GetType();
   bytes_to_discard_ = 0;
 
  if (destination_url_data->url().SchemeIsHTTPOrHTTPS()) {
    bool partial_response = (response.HttpStatusCode() == kHttpPartialContent);
    bool ok_response = (response.HttpStatusCode() == kHttpOK);

    std::string accept_ranges =
        response.HttpHeaderField(""Accept-Ranges"").Utf8();
    if (accept_ranges.find(""bytes"") != std::string::npos)
      destination_url_data->set_range_supported();

    if (partial_response &&
        VerifyPartialResponse(response, destination_url_data)) {
      destination_url_data->set_range_supported();
    } else if (ok_response) {
      destination_url_data->set_length(content_length);
      bytes_to_discard_ = byte_pos();
    } else if (response.HttpStatusCode() == kHttpRangeNotSatisfiable) {
      end_of_file = true;
    } else {
      active_loader_.reset();
      do_fail = true;
    }
  } else {
    destination_url_data->set_range_supported();
    if (content_length != kPositionNotSpecified) {
      destination_url_data->set_length(content_length + byte_pos());
    }
  }

  if (!do_fail) {
    destination_url_data =
         url_data_->url_index()->TryInsert(destination_url_data);
   }
 
  // This is vital for security!
  destination_url_data->set_is_cors_cross_origin(
      network::cors::IsCORSCrossOriginResponseType(response_type));
 
   if (destination_url_data != url_data_) {

    scoped_refptr<UrlData> old_url_data(url_data_);
    destination_url_data->Use();

    std::unique_ptr<DataProvider> self(
        url_data_->multibuffer()->RemoveProvider(this));
    url_data_ = destination_url_data.get();
    url_data_->multibuffer()->AddProvider(std::move(self));

    old_url_data->RedirectTo(destination_url_data);
  }

  if (do_fail) {
    destination_url_data->Fail();
    return;  // ""this"" may be deleted now.
  }

  const GURL& original_url = response.WasFetchedViaServiceWorker()
                                 ? response.OriginalURLViaServiceWorker()
                                 : response.Url();
  if (!url_data_->ValidateDataOrigin(original_url.GetOrigin())) {
    active_loader_.reset();
    url_data_->Fail();
    return;  // ""this"" may be deleted now.
  }

  if (end_of_file) {
    fifo_.push_back(DataBuffer::CreateEOSBuffer());
    url_data_->multibuffer()->OnDataProviderEvent(this);
  }
}
","void ResourceMultiBufferDataProvider::DidReceiveResponse(
    const WebURLResponse& response) {
#if DCHECK_IS_ON()
  std::string version;
  switch (response.HttpVersion()) {
    case WebURLResponse::kHTTPVersion_0_9:
      version = ""0.9"";
      break;
    case WebURLResponse::kHTTPVersion_1_0:
      version = ""1.0"";
      break;
    case WebURLResponse::kHTTPVersion_1_1:
      version = ""1.1"";
      break;
    case WebURLResponse::kHTTPVersion_2_0:
      version = ""2.1"";
      break;
    case WebURLResponse::kHTTPVersionUnknown:
      version = ""unknown"";
      break;
  }
  DVLOG(1) << ""didReceiveResponse: HTTP/"" << version << "" ""
           << response.HttpStatusCode();
#endif
  DCHECK(active_loader_);

  scoped_refptr<UrlData> destination_url_data(url_data_);

  if (!redirects_to_.is_empty()) {
    destination_url_data =
        url_data_->url_index()->GetByUrl(redirects_to_, cors_mode_);
    redirects_to_ = GURL();
  }

  base::Time last_modified;
  if (base::Time::FromString(
          response.HttpHeaderField(""Last-Modified"").Utf8().data(),
          &last_modified)) {
    destination_url_data->set_last_modified(last_modified);
  }

  destination_url_data->set_etag(
      response.HttpHeaderField(""ETag"").Utf8().data());

  destination_url_data->set_valid_until(base::Time::Now() +
                                        GetCacheValidUntil(response));

  uint32_t reasons = GetReasonsForUncacheability(response);
  destination_url_data->set_cacheable(reasons == 0);
  UMA_HISTOGRAM_BOOLEAN(""Media.CacheUseful"", reasons == 0);
  int shift = 0;
  int max_enum = base::bits::Log2Ceiling(kMaxReason);
  while (reasons) {
    DCHECK_LT(shift, max_enum);  // Sanity check.
    if (reasons & 0x1) {
      UMA_HISTOGRAM_EXACT_LINEAR(""Media.UncacheableReason"", shift,
                                 max_enum);  // PRESUBMIT_IGNORE_UMA_MAX
    }

    reasons >>= 1;
    ++shift;
  }

   int64_t content_length = response.ExpectedContentLength();
   bool end_of_file = false;
   bool do_fail = false;
   bytes_to_discard_ = 0;
 
  if (destination_url_data->url().SchemeIsHTTPOrHTTPS()) {
    bool partial_response = (response.HttpStatusCode() == kHttpPartialContent);
    bool ok_response = (response.HttpStatusCode() == kHttpOK);

    std::string accept_ranges =
        response.HttpHeaderField(""Accept-Ranges"").Utf8();
    if (accept_ranges.find(""bytes"") != std::string::npos)
      destination_url_data->set_range_supported();

    if (partial_response &&
        VerifyPartialResponse(response, destination_url_data)) {
      destination_url_data->set_range_supported();
    } else if (ok_response) {
      destination_url_data->set_length(content_length);
      bytes_to_discard_ = byte_pos();
    } else if (response.HttpStatusCode() == kHttpRangeNotSatisfiable) {
      end_of_file = true;
    } else {
      active_loader_.reset();
      do_fail = true;
    }
  } else {
    destination_url_data->set_range_supported();
    if (content_length != kPositionNotSpecified) {
      destination_url_data->set_length(content_length + byte_pos());
    }
  }

  if (!do_fail) {
    destination_url_data =
         url_data_->url_index()->TryInsert(destination_url_data);
   }
 
  destination_url_data->set_has_opaque_data(
      network::cors::IsCORSCrossOriginResponseType(response.GetType()));
 
   if (destination_url_data != url_data_) {

    scoped_refptr<UrlData> old_url_data(url_data_);
    destination_url_data->Use();

    std::unique_ptr<DataProvider> self(
        url_data_->multibuffer()->RemoveProvider(this));
    url_data_ = destination_url_data.get();
    url_data_->multibuffer()->AddProvider(std::move(self));

    old_url_data->RedirectTo(destination_url_data);
  }

  if (do_fail) {
    destination_url_data->Fail();
    return;  // ""this"" may be deleted now.
  }

  const GURL& original_url = response.WasFetchedViaServiceWorker()
                                 ? response.OriginalURLViaServiceWorker()
                                 : response.Url();
  if (!url_data_->ValidateDataOrigin(original_url.GetOrigin())) {
    active_loader_.reset();
    url_data_->Fail();
    return;  // ""this"" may be deleted now.
  }

  if (end_of_file) {
    fifo_.push_back(DataBuffer::CreateEOSBuffer());
    url_data_->multibuffer()->OnDataProviderEvent(this);
  }
}
",C,"  // We get the response type here because aborting the loader may change it.
  const auto response_type = response.GetType();
  // This is vital for security!
  destination_url_data->set_is_cors_cross_origin(
      network::cors::IsCORSCrossOriginResponseType(response_type));
","  destination_url_data->set_has_opaque_data(
      network::cors::IsCORSCrossOriginResponseType(response.GetType()));
",,"@@ -280,6 +280,8 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(
   int64_t content_length = response.ExpectedContentLength();
   bool end_of_file = false;
   bool do_fail = false;
+  // We get the response type here because aborting the loader may change it.
+  const auto response_type = response.GetType();
   bytes_to_discard_ = 0;
 
   // We make a strong assumption that when we reach here we have either
@@ -333,10 +335,9 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(
         url_data_->url_index()->TryInsert(destination_url_data);
   }
 
-  // This is vital for security! A service worker can respond with a response
-  // from a different origin, so this response type is needed to detect that.
-  destination_url_data->set_has_opaque_data(
-      network::cors::IsCORSCrossOriginResponseType(response.GetType()));
+  // This is vital for security!
+  destination_url_data->set_is_cors_cross_origin(
+      network::cors::IsCORSCrossOriginResponseType(response_type));
 
   if (destination_url_data != url_data_) {
     // At this point, we've encountered a redirect, or found a better url data",Chrome,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,50436d878b2e92de4231fda47328a8a4e884ecc3,1,"void ResourceMultiBufferDataProvider::DidReceiveResponse(
    const WebURLResponse& response) {
#if DCHECK_IS_ON()
  std::string version;
  switch (response.HttpVersion()) {
    case WebURLResponse::kHTTPVersion_0_9:
      version = ""0.9"";
      break;
    case WebURLResponse::kHTTPVersion_1_0:
      version = ""1.0"";
      break;
    case WebURLResponse::kHTTPVersion_1_1:
      version = ""1.1"";
      break;
    case WebURLResponse::kHTTPVersion_2_0:
      version = ""2.1"";
      break;
    case WebURLResponse::kHTTPVersionUnknown:
      version = ""unknown"";
      break;
  }
  DVLOG(1) << ""didReceiveResponse: HTTP/"" << version << "" ""
           << response.HttpStatusCode();
#endif
  DCHECK(active_loader_);

  scoped_refptr<UrlData> destination_url_data(url_data_);

  if (!redirects_to_.is_empty()) {
    destination_url_data =
        url_data_->url_index()->GetByUrl(redirects_to_, cors_mode_);
    redirects_to_ = GURL();
  }

  base::Time last_modified;
  if (base::Time::FromString(
          response.HttpHeaderField(""Last-Modified"").Utf8().data(),
          &last_modified)) {
    destination_url_data->set_last_modified(last_modified);
  }

  destination_url_data->set_etag(
      response.HttpHeaderField(""ETag"").Utf8().data());

  destination_url_data->set_valid_until(base::Time::Now() +
                                        GetCacheValidUntil(response));

  uint32_t reasons = GetReasonsForUncacheability(response);
  destination_url_data->set_cacheable(reasons == 0);
  UMA_HISTOGRAM_BOOLEAN(""Media.CacheUseful"", reasons == 0);
  int shift = 0;
  int max_enum = base::bits::Log2Ceiling(kMaxReason);
  while (reasons) {
    DCHECK_LT(shift, max_enum);  // Sanity check.
    if (reasons & 0x1) {
      // Note: this uses an exact linear UMA to fake an enum UMA, as the actual
      // enum is a bitmask.
      UMA_HISTOGRAM_EXACT_LINEAR(""Media.UncacheableReason"", shift,
                                 max_enum);  // PRESUBMIT_IGNORE_UMA_MAX
    }

    reasons >>= 1;
    ++shift;
  }

  // Expected content length can be |kPositionNotSpecified|, in that case
  // |content_length_| is not specified and this is a streaming response.
   int64_t content_length = response.ExpectedContentLength();
   bool end_of_file = false;
   bool do_fail = false;
//fix_flaw_line_below:
//  // We get the response type here because aborting the loader may change it.
//fix_flaw_line_below:
//  const auto response_type = response.GetType();
   bytes_to_discard_ = 0;
 
   // We make a strong assumption that when we reach here we have either
  // received a response from HTTP/HTTPS protocol or the request was
  // successful (in particular range request). So we only verify the partial
  // response for HTTP and HTTPS protocol.
  if (destination_url_data->url().SchemeIsHTTPOrHTTPS()) {
    bool partial_response = (response.HttpStatusCode() == kHttpPartialContent);
    bool ok_response = (response.HttpStatusCode() == kHttpOK);

    // Check to see whether the server supports byte ranges.
    std::string accept_ranges =
        response.HttpHeaderField(""Accept-Ranges"").Utf8();
    if (accept_ranges.find(""bytes"") != std::string::npos)
      destination_url_data->set_range_supported();

    // If we have verified the partial response and it is correct.
    // It's also possible for a server to support range requests
    // without advertising ""Accept-Ranges: bytes"".
    if (partial_response &&
        VerifyPartialResponse(response, destination_url_data)) {
      destination_url_data->set_range_supported();
    } else if (ok_response) {
      // We accept a 200 response for a Range:0- request, trusting the
      // Accept-Ranges header, because Apache thinks that's a reasonable thing
      // to return.
      destination_url_data->set_length(content_length);
      bytes_to_discard_ = byte_pos();
    } else if (response.HttpStatusCode() == kHttpRangeNotSatisfiable) {
      // Unsatisfiable range
      // Really, we should never request a range that doesn't exist, but
      // if we do, let's handle it in a sane way.
      // Note, we can't just call OnDataProviderEvent() here, because
      // url_data_ hasn't been updated to the final destination yet.
      end_of_file = true;
    } else {
      active_loader_.reset();
      // Can't call fail until readers have been migrated to the new
      // url data below.
      do_fail = true;
    }
  } else {
    destination_url_data->set_range_supported();
    if (content_length != kPositionNotSpecified) {
      destination_url_data->set_length(content_length + byte_pos());
    }
  }

  if (!do_fail) {
    destination_url_data =
         url_data_->url_index()->TryInsert(destination_url_data);
   }
 
//flaw_line_below:
  // This is vital for security! A service worker can respond with a response
//flaw_line_below:
  // from a different origin, so this response type is needed to detect that.
//flaw_line_below:
  destination_url_data->set_has_opaque_data(
//flaw_line_below:
      network::cors::IsCORSCrossOriginResponseType(response.GetType()));
//fix_flaw_line_below:
//  // This is vital for security!
//fix_flaw_line_below:
//  destination_url_data->set_is_cors_cross_origin(
//fix_flaw_line_below:
//      network::cors::IsCORSCrossOriginResponseType(response_type));
 
   if (destination_url_data != url_data_) {
     // At this point, we've encountered a redirect, or found a better url data
    // instance for the data that we're about to download.

    // First, let's take a ref on the current url data.
    scoped_refptr<UrlData> old_url_data(url_data_);
    destination_url_data->Use();

    // Take ownership of ourselves. (From the multibuffer)
    std::unique_ptr<DataProvider> self(
        url_data_->multibuffer()->RemoveProvider(this));
    url_data_ = destination_url_data.get();
    // Give the ownership to our new owner.
    url_data_->multibuffer()->AddProvider(std::move(self));

    // Call callback to let upstream users know about the transfer.
    // This will merge the data from the two multibuffers and
    // cause clients to start using the new UrlData.
    old_url_data->RedirectTo(destination_url_data);
  }

  if (do_fail) {
    destination_url_data->Fail();
    return;  // ""this"" may be deleted now.
  }

  // This test is vital for security!
  const GURL& original_url = response.WasFetchedViaServiceWorker()
                                 ? response.OriginalURLViaServiceWorker()
                                 : response.Url();
  if (!url_data_->ValidateDataOrigin(original_url.GetOrigin())) {
    active_loader_.reset();
    url_data_->Fail();
    return;  // ""this"" may be deleted now.
  }

  if (end_of_file) {
    fifo_.push_back(DataBuffer::CreateEOSBuffer());
    url_data_->multibuffer()->OnDataProviderEvent(this);
  }
}
"
8868,186604,,Remote,Not required,,CVE-2018-18352,https://www.cvedetails.com/cve/CVE-2018-18352/,CWE-732,Medium,Partial,,,2018-12-11,4.3,Service works could inappropriately gain access to cross origin audio in Media in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to bypass same origin policy for audio content via a crafted HTML page.,2019-10-02,Bypass ,2,https://github.com/chromium/chromium/commit/a9cbaa7a40e2b2723cfc2f266c42f4980038a949,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,"Simplify ""WouldTaintOrigin"" concept in media/blink

Currently WebMediaPlayer has three predicates:
 - DidGetOpaqueResponseFromServiceWorker
 - HasSingleSecurityOrigin
 - DidPassCORSAccessCheck
. These are used to determine whether the response body is available
for scripts. They are known to be confusing, and actually
MediaElementAudioSourceHandler::WouldTaintOrigin misuses them.

This CL merges the three predicates to one, WouldTaintOrigin, to remove
the confusion. Now the ""response type"" concept is available and we
don't need a custom CORS check, so this CL removes
BaseAudioContext::WouldTaintOrigin. This CL also renames
URLData::has_opaque_data_ and its (direct and indirect) data accessors
to match the spec.

Bug: 849942, 875153
Change-Id: I6acf50169d7445c4ff614e80ac606f79ee577d2a
Reviewed-on: https://chromium-review.googlesource.com/c/1238098
Reviewed-by: Fredrik Hubinette <hubbe@chromium.org>
Reviewed-by: Kinuko Yasuda <kinuko@chromium.org>
Reviewed-by: Raymond Toy <rtoy@chromium.org>
Commit-Queue: Yutaka Hirano <yhirano@chromium.org>
Cr-Commit-Position: refs/heads/master@{#598258}",1,media/blink/url_index.cc,"{""sha"": ""78ca5e2c3c323cf55e23eacc262e8a197e60b63b"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 11, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -844,21 +844,11 @@ void WebMediaPlayerMS::Paint(cc::PaintCanvas* canvas,\n                         context_3d, context_support);\n }\n \n-bool WebMediaPlayerMS::DidGetOpaqueResponseFromServiceWorker() const {\n+bool WebMediaPlayerMS::WouldTaintOrigin() const {\n   DCHECK(thread_checker_.CalledOnValidThread());\n   return false;\n }\n \n-bool WebMediaPlayerMS::HasSingleSecurityOrigin() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n-bool WebMediaPlayerMS::DidPassCORSAccessCheck() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n double WebMediaPlayerMS::MediaTimeForTimeValue(double timeValue) const {\n   return base::TimeDelta::FromSecondsD(timeValue).InSecondsF();\n }""}<_**next**_>{""sha"": ""8c3595505cb20fa379b861f49b28710c40f3a5f1"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -163,9 +163,7 @@ class CONTENT_EXPORT WebMediaPlayerMS\n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n \n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n ""}<_**next**_>{""sha"": ""d26bc8142d80dc7c64958a9c22170244d6e664dd"", ""filename"": ""content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -76,9 +76,7 @@ class MockWebMediaPlayer : public blink::WebMediaPlayer,\n   }\n \n   bool DidLoadingProgress() override { return true; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double timeValue) const override { return 0.0; }\n   unsigned DecodedFrameCount() const override { return 0; }\n   unsigned DroppedFrameCount() const override { return 0; }""}<_**next**_>{""sha"": ""74ad44546ee34afa79b4a1649710117f8532c5f4"", ""filename"": ""media/blink/multibuffer_data_source.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 19, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -286,23 +286,8 @@ bool MultibufferDataSource::HasSingleOrigin() {\n   return single_origin_;\n }\n \n-bool MultibufferDataSource::DidPassCORSAccessCheck() const {\n-  if (url_data()->cors_mode() == UrlData::CORS_UNSPECIFIED)\n-    return false;\n-\n-  // If init_cb is set, we know initialization is not finished yet.\n-  if (init_cb_)\n-    return false;\n-  if (failed_)\n-    return false;\n-  return true;\n-}\n-\n-bool MultibufferDataSource::DidGetOpaqueResponseViaServiceWorker() const {\n-  return url_data()->has_opaque_data();\n-\n-  // TODO(falken): Do we need to do something about |init_cb_| like\n-  // in DidPassCORSAccessCheck()?\n+bool MultibufferDataSource::IsCorsCrossOrigin() const {\n+  return url_data()->is_cors_cross_origin();\n }\n \n void MultibufferDataSource::MediaPlaybackRateChanged(double playback_rate) {\n@@ -627,8 +612,6 @@ void MultibufferDataSource::StartCallback() {\n     // Progress callback might be called after the start callback,\n     // make sure that we update single_origin_ now.\n     media_log_->SetBooleanProperty(\""single_origin\"", single_origin_);\n-    media_log_->SetBooleanProperty(\""passed_cors_access_check\"",\n-                                   DidPassCORSAccessCheck());\n     media_log_->SetBooleanProperty(\""range_header_supported\"",\n                                    url_data()->range_supported());\n   }""}<_**next**_>{""sha"": ""4da62a5519e33ab6e726406f0acac4995c4ad49f"", ""filename"": ""media/blink/multibuffer_data_source.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 6, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -79,12 +79,9 @@ class MEDIA_BLINK_EXPORT MultibufferDataSource : public DataSource {\n   // Method called on the render thread.\n   bool HasSingleOrigin();\n \n-  // Returns true if the media resource passed a CORS access control check.\n-  bool DidPassCORSAccessCheck() const;\n-\n-  // Returns true if a service worker provided the media resource response,\n-  // and the response was opaque.\n-  bool DidGetOpaqueResponseViaServiceWorker() const;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  // This must be called after the response arrives.\n+  bool IsCorsCrossOrigin() const;\n \n   // Notifies changes in playback state for controlling media buffering\n   // behavior.""}<_**next**_>{""sha"": ""4b9f83e74255bf14d33c3f0c2785c282ecb2bcd7"", ""filename"": ""media/blink/multibuffer_data_source_unittest.cc"", ""status"": ""modified"", ""additions"": 81, ""deletions"": 12, ""changes"": 93, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1493,35 +1493,104 @@ TEST_F(MultibufferDataSourceTest, FileSizeLessThanBlockSize) {\n   Stop();\n }\n \n-TEST_F(MultibufferDataSourceTest, DidPassCORSAccessTest) {\n+TEST_F(MultibufferDataSourceTest, ResponseTypeBasic) {\n   InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n   set_preload(MultibufferDataSource::NONE);\n   WebURLResponse response1 =\n       response_generator_->GeneratePartial206(0, kDataSize - 1);\n-  response1.SetWasFetchedViaServiceWorker(true);\n-  std::vector<blink::WebURL> urlList = {GURL(kHttpDifferentOriginUrl)};\n-  response1.SetURLListViaServiceWorker(urlList);\n-  WebURLResponse response2 =\n-      response_generator_->GeneratePartial206(kDataSize, kDataSize * 2 - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kBasic);\n \n   EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n   EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n   EXPECT_CALL(*this, ReadCallback(kDataSize));\n \n-  EXPECT_FALSE(data_source_->DidPassCORSAccessCheck());\n   Respond(response1);\n   ReceiveData(kDataSize);\n   ReadAt(0);\n   EXPECT_TRUE(loading());\n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n   FinishLoading();\n+}\n \n-  // Verify that if reader_ is null, DidPassCORSAccessCheck still returns true.\n-  data_source_->Stop();\n-  base::RunLoop().RunUntilIdle();\n+TEST_F(MultibufferDataSourceTest, ResponseTypeCors) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kCORS);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeDefault) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kDefault);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaque) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaque);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaqueRedirect) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaqueRedirect);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n }\n \n TEST_F(MultibufferDataSourceTest, EtagTest) {""}<_**next**_>{""sha"": ""89f1c9e70d2cc71646df50026b50d54d471d20c6"", ""filename"": ""media/blink/resource_multibuffer_data_provider.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/resource_multibuffer_data_provider.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -280,6 +280,8 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n   int64_t content_length = response.ExpectedContentLength();\n   bool end_of_file = false;\n   bool do_fail = false;\n+  // We get the response type here because aborting the loader may change it.\n+  const auto response_type = response.GetType();\n   bytes_to_discard_ = 0;\n \n   // We make a strong assumption that when we reach here we have either\n@@ -333,10 +335,9 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n         url_data_->url_index()->TryInsert(destination_url_data);\n   }\n \n-  // This is vital for security! A service worker can respond with a response\n-  // from a different origin, so this response type is needed to detect that.\n-  destination_url_data->set_has_opaque_data(\n-      network::cors::IsCORSCrossOriginResponseType(response.GetType()));\n+  // This is vital for security!\n+  destination_url_data->set_is_cors_cross_origin(\n+      network::cors::IsCORSCrossOriginResponseType(response_type));\n \n   if (destination_url_data != url_data_) {\n     // At this point, we've encountered a redirect, or found a better url data""}<_**next**_>{""sha"": ""3fb63497791a3d2a0ea1e3b12c018f4b2c5fe355"", ""filename"": ""media/blink/url_index.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 7, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -65,7 +65,6 @@ UrlData::UrlData(const GURL& url, CORSMode cors_mode, UrlIndex* url_index)\n       length_(kPositionNotSpecified),\n       range_supported_(false),\n       cacheable_(false),\n-      has_opaque_data_(false),\n       last_used_(),\n       multibuffer_(this, url_index_->block_shift_) {}\n \n@@ -103,9 +102,8 @@ void UrlData::MergeFrom(const scoped_refptr<UrlData>& other) {\n       last_modified_ = other->last_modified_;\n     }\n     bytes_read_from_cache_ += other->bytes_read_from_cache_;\n-    // set_has_opaque_data() will not relax from opaque to non-opaque if already\n-    // opaque.\n-    set_has_opaque_data(other->has_opaque_data_);\n+    // is_cors_corss_origin_ will not relax from true to false.\n+    set_is_cors_cross_origin(other->is_cors_cross_origin_);\n     multibuffer()->MergeFrom(other->multibuffer());\n   }\n }\n@@ -122,10 +120,10 @@ void UrlData::set_length(int64_t length) {\n   }\n }\n \n-void UrlData::set_has_opaque_data(bool has_opaque_data) {\n-  if (has_opaque_data_)\n+void UrlData::set_is_cors_cross_origin(bool is_cors_cross_origin) {\n+  if (is_cors_cross_origin_)\n     return;\n-  has_opaque_data_ = has_opaque_data;\n+  is_cors_cross_origin_ = is_cors_cross_origin;\n }\n \n void UrlData::RedirectTo(const scoped_refptr<UrlData>& url_data) {""}<_**next**_>{""sha"": ""2c15bc7ac0ad4489a0c922f614889e575bd5d863"", ""filename"": ""media/blink/url_index.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -125,7 +125,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // Returns our url_index.\n   UrlIndex* url_index() const { return url_index_; }\n \n-  bool has_opaque_data() const { return has_opaque_data_; }\n+  // This must be called after the response arrives.\n+  bool is_cors_cross_origin() const { return is_cors_cross_origin_; }\n \n   // Notifies the url index that this is currently used.\n   // The url <-> URLData mapping will be eventually be invalidated if\n@@ -145,7 +146,7 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   void set_range_supported();\n   void set_last_modified(base::Time last_modified);\n   void set_etag(const std::string& etag);\n-  void set_has_opaque_data(bool has_opaque_data);\n+  void set_is_cors_cross_origin(bool is_cors_cross_origin);\n \n   // A redirect has occured (or we've found a better UrlData for the same\n   // resource).\n@@ -238,9 +239,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // will not cache this url.\n   bool cacheable_;\n \n-  // True if a service worker intercepted a request for this resource\n-  // and provided an opaque response.\n-  bool has_opaque_data_;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  bool is_cors_cross_origin_ = false;\n \n   // Last time some media time used this resource.\n   // Note that we use base::Time rather than base::TimeTicks because""}<_**next**_>{""sha"": ""cf0857d8c6283758b159609f76da1bafb19cc789"", ""filename"": ""media/blink/webmediaplayer_impl.cc"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 10, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1175,12 +1175,6 @@ void WebMediaPlayerImpl::Paint(cc::PaintCanvas* canvas,\n       context_support);\n }\n \n-bool WebMediaPlayerImpl::DidGetOpaqueResponseFromServiceWorker() const {\n-  if (data_source_)\n-    return data_source_->DidGetOpaqueResponseViaServiceWorker();\n-  return false;\n-}\n-\n bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   if (demuxer_found_hls_) {\n     // HLS manifests might pull segments from a different origin. We can't know\n@@ -1193,10 +1187,15 @@ bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   return true;\n }\n \n-bool WebMediaPlayerImpl::DidPassCORSAccessCheck() const {\n-  if (data_source_)\n-    return data_source_->DidPassCORSAccessCheck();\n-  return false;\n+bool WebMediaPlayerImpl::WouldTaintOrigin() const {\n+  if (!HasSingleSecurityOrigin()) {\n+    // When the resource is redirected to another origin we think it as\n+    // tainted. This is actually not specified, and is under discussion.\n+    // See https://github.com/whatwg/fetch/issues/737.\n+    return true;\n+  }\n+\n+  return data_source_ && data_source_->IsCorsCrossOrigin();\n }\n \n double WebMediaPlayerImpl::MediaTimeForTimeValue(double timeValue) const {""}<_**next**_>{""sha"": ""233e37b4614544e9b2a67b4e5edee775de0f79a6"", ""filename"": ""media/blink/webmediaplayer_impl.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -188,10 +188,7 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n \n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n-\n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n \n@@ -332,6 +329,8 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n   void OnPipelineResumed();\n   void OnDemuxerOpened();\n \n+  bool HasSingleSecurityOrigin() const;\n+\n   // Pipeline::Client overrides.\n   void OnError(PipelineStatus status) override;\n   void OnEnded() override;""}<_**next**_>{""sha"": ""9821759bc7b311672a54387edc7d8c26a11d5e54"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""status"": ""added"", ""additions"": 47, ""deletions"": 0, ""changes"": 47, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -0,0 +1,47 @@\n+<!doctype html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+<script src=\""/common/get-host-info.sub.js\""></script>\n+<script src=\""resources/test-helpers.sub.js?pipe=sub\""></script>\n+<script>\n+promise_test(async (t) => {\n+    const SCOPE = 'resources/empty.html';\n+    const SCRIPT = 'resources/fetch-rewrite-worker.js';\n+    const host_info = get_host_info();\n+    const REMOTE_ORIGIN = host_info.HTTPS_REMOTE_ORIGIN;\n+\n+    const reg = await service_worker_unregister_and_register(t, SCRIPT, SCOPE);\n+    await wait_for_state(t, reg.installing, 'activated');\n+    const frame = await with_iframe(SCOPE);\n+\n+    const doc = frame.contentDocument;\n+    const win = frame.contentWindow;\n+\n+    const context = new win.AudioContext();\n+    try {\n+      context.suspend();\n+      const audio = doc.createElement('audio');\n+      audio.autoplay = true;\n+      const source = context.createMediaElementSource(audio);\n+      const spn = context.createScriptProcessor(16384, 1, 1);\n+      source.connect(spn).connect(context.destination);\n+      const url = `${REMOTE_ORIGIN}/webaudio/resources/sin_440Hz_-6dBFS_1s.wav`;\n+      audio.src = '/test?url=' + encodeURIComponent(url);\n+      doc.body.appendChild(audio);\n+\n+      await new Promise((resolve) => {\n+        audio.addEventListener('playing', resolve);\n+      });\n+      await context.resume();\n+      const event = await new Promise((resolve) => {\n+        spn.addEventListener('audioprocess', resolve);\n+      });\n+      const data = event.inputBuffer.getChannelData(0);\n+      for (const e of data) {\n+        assert_equals(e, 0);\n+      }\n+    } finally {\n+      context.close();\n+    }\n+  }, 'Verify CORS XHR of fetch() in a Service Worker');\n+</script>""}<_**next**_>{""sha"": ""319648dbc16669ab3b3238d8488997b7d3a7c837"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""58697c0661a94d03e4bbe74134a23e71a860f5f6"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""a1e82caf7e2f9d37d785165a4766f42acb28c465"", ""filename"": ""third_party/blink/public/platform/web_media_player.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/public/platform/web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -207,9 +207,10 @@ class WebMediaPlayer {\n \n   virtual bool DidLoadingProgress() = 0;\n \n-  virtual bool DidGetOpaqueResponseFromServiceWorker() const = 0;\n-  virtual bool HasSingleSecurityOrigin() const = 0;\n-  virtual bool DidPassCORSAccessCheck() const = 0;\n+  // Returns true if the response is CORS-cross-origin and so we shouldn't be\n+  // allowing media to play through webaudio.\n+  // This should be called after the response has arrived.\n+  virtual bool WouldTaintOrigin() const = 0;\n \n   virtual double MediaTimeForTimeValue(double time_value) const = 0;\n ""}<_**next**_>{""sha"": ""ad708c861bb80cd8a01217eec51f9fe058af4a33"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 21, ""changes"": 26, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1506,30 +1506,14 @@ bool HTMLMediaElement::IsSafeToLoadURL(const KURL& url,\n \n bool HTMLMediaElement::IsMediaDataCORSSameOrigin(\n     const SecurityOrigin* origin) const {\n-  // If a service worker handled the request, we don't know if the origin in the\n-  // src is the same as the actual response URL so can't rely on URL checks\n-  // alone. So detect an opaque response via\n-  // DidGetOpaqueResponseFromServiceWorker().\n-  if (GetWebMediaPlayer() &&\n-      GetWebMediaPlayer()->DidGetOpaqueResponseFromServiceWorker()) {\n-    return false;\n-  }\n-\n-  // At this point, either a service worker was not used, or it didn't provide\n-  // an opaque response, so continue with the normal checks.\n+  if (!GetWebMediaPlayer())\n+    return true;\n \n-  // HasSingleSecurityOrigin() tells us whether the origin in the src\n-  // is the same as the actual request (i.e. after redirects).\n-  if (!HasSingleSecurityOrigin())\n+  const auto network_state = GetWebMediaPlayer()->GetNetworkState();\n+  if (network_state == WebMediaPlayer::kNetworkStateNetworkError)\n     return false;\n \n-  // DidPassCORSAccessCheck() means it was a successful CORS-enabled fetch (vs.\n-  // non-CORS-enabled or failed). CanReadContent() does CheckAccess() on the\n-  // URL plus allows data sources, to ensure that it is not a URL that requires\n-  // CORS (basically same origin).\n-  return (GetWebMediaPlayer() &&\n-          GetWebMediaPlayer()->DidPassCORSAccessCheck()) ||\n-         origin->CanReadContent(currentSrc());\n+  return !GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n bool HTMLMediaElement::IsInCrossOriginFrame() const {""}<_**next**_>{""sha"": ""f2d50264a53a0a3002725b06b6363091f4e17faa"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -268,11 +268,6 @@ class CORE_EXPORT HTMLMediaElement\n   // of one of them here.\n   using HTMLElement::GetExecutionContext;\n \n-  bool HasSingleSecurityOrigin() const {\n-    return GetWebMediaPlayer() ? GetWebMediaPlayer()->HasSingleSecurityOrigin()\n-                               : true;\n-  }\n-\n   bool IsFullscreen() const;\n   virtual bool UsesOverlayFullscreenVideo() const { return false; }\n ""}<_**next**_>{""sha"": ""8cf3a926979a853d0ba0f48f9def6bc9b4aec36a"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 17, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -958,21 +958,4 @@ void BaseAudioContext::UpdateWorkletGlobalScopeOnRenderingThread() {\n   }\n }\n \n-bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {\n-  // Data URLs don't taint the origin.\n-  if (url.ProtocolIsData()) {\n-    return false;\n-  }\n-\n-  Document* document = GetDocument();\n-  if (document && document->GetSecurityOrigin()) {\n-    // The origin is tainted if and only if we cannot read content from the URL.\n-    return !document->GetSecurityOrigin()->CanRequest(url);\n-  }\n-\n-  // Be conservative and assume it's tainted if it's not a data url and if we\n-  // can't get the security origin of the document.\n-  return true;\n-}\n-\n }  // namespace blink""}<_**next**_>{""sha"": ""ae933f20167fb374b51ff5a869d9381f97b56d4b"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -296,13 +296,6 @@ class MODULES_EXPORT BaseAudioContext\n   // Does nothing when the worklet global scope does not exist.\n   void UpdateWorkletGlobalScopeOnRenderingThread();\n \n-  // Returns true if the URL would taint the origin so that we shouldn't be\n-  // allowing media to played through webaudio.\n-  // TODO(crbug.com/845913): This should really be on an AudioContext.  Move\n-  // this when we move the media stuff from BaseAudioContext to AudioContext, as\n-  // requried by the spec.\n-  bool WouldTaintOrigin(const KURL& url) const;\n-\n  protected:\n   enum ContextType { kRealtimeContext, kOfflineContext };\n ""}<_**next**_>{""sha"": ""d7b07b5fea75809b4e14c8fda74b38a1d48e6b9d"", ""filename"": ""third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 13, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -136,19 +136,7 @@ void MediaElementAudioSourceHandler::SetFormat(size_t number_of_channels,\n }\n \n bool MediaElementAudioSourceHandler::WouldTaintOrigin() {\n-  // If we're cross-origin and allowed access vie CORS, we're not tainted.\n-  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {\n-    return false;\n-  }\n-\n-  // Handles the case where the url is a redirect to another site that we're not\n-  // allowed to access.\n-  if (!MediaElement()->HasSingleSecurityOrigin()) {\n-    return true;\n-  }\n-\n-  // Test to see if the current media URL taint the origin of the audio context?\n-  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());\n+  return MediaElement()->GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n void MediaElementAudioSourceHandler::PrintCORSMessage(const String& message) {""}<_**next**_>{""sha"": ""6e5771836bf84527d922a6c5fc84a3aa5c8c9bce"", ""filename"": ""third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/testing/empty_web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -50,9 +50,7 @@ class EmptyWebMediaPlayer : public WebMediaPlayer {\n   ReadyState GetReadyState() const override { return kReadyStateHaveNothing; }\n   WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override { return false; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double time_value) const override {\n     return time_value;\n   };""}","void UrlData::MergeFrom(const scoped_refptr<UrlData>& other) {
  if (ValidateDataOrigin(other->data_origin_)) {
    DCHECK(thread_checker_.CalledOnValidThread());
    valid_until_ = std::max(valid_until_, other->valid_until_);
    set_length(other->length_);
    cacheable_ |= other->cacheable_;
    range_supported_ |= other->range_supported_;
    if (last_modified_.is_null()) {
       last_modified_ = other->last_modified_;
     }
     bytes_read_from_cache_ += other->bytes_read_from_cache_;
    // is_cors_corss_origin_ will not relax from true to false.
    set_is_cors_cross_origin(other->is_cors_cross_origin_);
     multibuffer()->MergeFrom(other->multibuffer());
   }
 }
","void UrlData::MergeFrom(const scoped_refptr<UrlData>& other) {
  if (ValidateDataOrigin(other->data_origin_)) {
    DCHECK(thread_checker_.CalledOnValidThread());
    valid_until_ = std::max(valid_until_, other->valid_until_);
    set_length(other->length_);
    cacheable_ |= other->cacheable_;
    range_supported_ |= other->range_supported_;
    if (last_modified_.is_null()) {
       last_modified_ = other->last_modified_;
     }
     bytes_read_from_cache_ += other->bytes_read_from_cache_;
    set_has_opaque_data(other->has_opaque_data_);
     multibuffer()->MergeFrom(other->multibuffer());
   }
 }
",C,"    // is_cors_corss_origin_ will not relax from true to false.
    set_is_cors_cross_origin(other->is_cors_cross_origin_);
","    set_has_opaque_data(other->has_opaque_data_);
",,"@@ -65,7 +65,6 @@ UrlData::UrlData(const GURL& url, CORSMode cors_mode, UrlIndex* url_index)
       length_(kPositionNotSpecified),
       range_supported_(false),
       cacheable_(false),
-      has_opaque_data_(false),
       last_used_(),
       multibuffer_(this, url_index_->block_shift_) {}
 
@@ -103,9 +102,8 @@ void UrlData::MergeFrom(const scoped_refptr<UrlData>& other) {
       last_modified_ = other->last_modified_;
     }
     bytes_read_from_cache_ += other->bytes_read_from_cache_;
-    // set_has_opaque_data() will not relax from opaque to non-opaque if already
-    // opaque.
-    set_has_opaque_data(other->has_opaque_data_);
+    // is_cors_corss_origin_ will not relax from true to false.
+    set_is_cors_cross_origin(other->is_cors_cross_origin_);
     multibuffer()->MergeFrom(other->multibuffer());
   }
 }
@@ -122,10 +120,10 @@ void UrlData::set_length(int64_t length) {
   }
 }
 
-void UrlData::set_has_opaque_data(bool has_opaque_data) {
-  if (has_opaque_data_)
+void UrlData::set_is_cors_cross_origin(bool is_cors_cross_origin) {
+  if (is_cors_cross_origin_)
     return;
-  has_opaque_data_ = has_opaque_data;
+  is_cors_cross_origin_ = is_cors_cross_origin;
 }
 
 void UrlData::RedirectTo(const scoped_refptr<UrlData>& url_data) {",Chrome,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,50436d878b2e92de4231fda47328a8a4e884ecc3,1,"void UrlData::MergeFrom(const scoped_refptr<UrlData>& other) {
  // We're merging from another UrlData that refers to the *same*
  // resource, so when we merge the metadata, we can use the most
  // optimistic values.
  if (ValidateDataOrigin(other->data_origin_)) {
    DCHECK(thread_checker_.CalledOnValidThread());
    valid_until_ = std::max(valid_until_, other->valid_until_);
    // set_length() will not override the length if already known.
    set_length(other->length_);
    cacheable_ |= other->cacheable_;
    range_supported_ |= other->range_supported_;
    if (last_modified_.is_null()) {
       last_modified_ = other->last_modified_;
     }
     bytes_read_from_cache_ += other->bytes_read_from_cache_;
//flaw_line_below:
    // set_has_opaque_data() will not relax from opaque to non-opaque if already
//flaw_line_below:
    // opaque.
//flaw_line_below:
    set_has_opaque_data(other->has_opaque_data_);
//fix_flaw_line_below:
//    // is_cors_corss_origin_ will not relax from true to false.
//fix_flaw_line_below:
//    set_is_cors_cross_origin(other->is_cors_cross_origin_);
     multibuffer()->MergeFrom(other->multibuffer());
   }
 }
"
8869,186605,,Remote,Not required,,CVE-2018-18352,https://www.cvedetails.com/cve/CVE-2018-18352/,CWE-732,Medium,Partial,,,2018-12-11,4.3,Service works could inappropriately gain access to cross origin audio in Media in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to bypass same origin policy for audio content via a crafted HTML page.,2019-10-02,Bypass ,0,https://github.com/chromium/chromium/commit/a9cbaa7a40e2b2723cfc2f266c42f4980038a949,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,"Simplify ""WouldTaintOrigin"" concept in media/blink

Currently WebMediaPlayer has three predicates:
 - DidGetOpaqueResponseFromServiceWorker
 - HasSingleSecurityOrigin
 - DidPassCORSAccessCheck
. These are used to determine whether the response body is available
for scripts. They are known to be confusing, and actually
MediaElementAudioSourceHandler::WouldTaintOrigin misuses them.

This CL merges the three predicates to one, WouldTaintOrigin, to remove
the confusion. Now the ""response type"" concept is available and we
don't need a custom CORS check, so this CL removes
BaseAudioContext::WouldTaintOrigin. This CL also renames
URLData::has_opaque_data_ and its (direct and indirect) data accessors
to match the spec.

Bug: 849942, 875153
Change-Id: I6acf50169d7445c4ff614e80ac606f79ee577d2a
Reviewed-on: https://chromium-review.googlesource.com/c/1238098
Reviewed-by: Fredrik Hubinette <hubbe@chromium.org>
Reviewed-by: Kinuko Yasuda <kinuko@chromium.org>
Reviewed-by: Raymond Toy <rtoy@chromium.org>
Commit-Queue: Yutaka Hirano <yhirano@chromium.org>
Cr-Commit-Position: refs/heads/master@{#598258}",1,media/blink/url_index.cc,"{""sha"": ""78ca5e2c3c323cf55e23eacc262e8a197e60b63b"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 11, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -844,21 +844,11 @@ void WebMediaPlayerMS::Paint(cc::PaintCanvas* canvas,\n                         context_3d, context_support);\n }\n \n-bool WebMediaPlayerMS::DidGetOpaqueResponseFromServiceWorker() const {\n+bool WebMediaPlayerMS::WouldTaintOrigin() const {\n   DCHECK(thread_checker_.CalledOnValidThread());\n   return false;\n }\n \n-bool WebMediaPlayerMS::HasSingleSecurityOrigin() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n-bool WebMediaPlayerMS::DidPassCORSAccessCheck() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n double WebMediaPlayerMS::MediaTimeForTimeValue(double timeValue) const {\n   return base::TimeDelta::FromSecondsD(timeValue).InSecondsF();\n }""}<_**next**_>{""sha"": ""8c3595505cb20fa379b861f49b28710c40f3a5f1"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -163,9 +163,7 @@ class CONTENT_EXPORT WebMediaPlayerMS\n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n \n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n ""}<_**next**_>{""sha"": ""d26bc8142d80dc7c64958a9c22170244d6e664dd"", ""filename"": ""content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -76,9 +76,7 @@ class MockWebMediaPlayer : public blink::WebMediaPlayer,\n   }\n \n   bool DidLoadingProgress() override { return true; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double timeValue) const override { return 0.0; }\n   unsigned DecodedFrameCount() const override { return 0; }\n   unsigned DroppedFrameCount() const override { return 0; }""}<_**next**_>{""sha"": ""74ad44546ee34afa79b4a1649710117f8532c5f4"", ""filename"": ""media/blink/multibuffer_data_source.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 19, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -286,23 +286,8 @@ bool MultibufferDataSource::HasSingleOrigin() {\n   return single_origin_;\n }\n \n-bool MultibufferDataSource::DidPassCORSAccessCheck() const {\n-  if (url_data()->cors_mode() == UrlData::CORS_UNSPECIFIED)\n-    return false;\n-\n-  // If init_cb is set, we know initialization is not finished yet.\n-  if (init_cb_)\n-    return false;\n-  if (failed_)\n-    return false;\n-  return true;\n-}\n-\n-bool MultibufferDataSource::DidGetOpaqueResponseViaServiceWorker() const {\n-  return url_data()->has_opaque_data();\n-\n-  // TODO(falken): Do we need to do something about |init_cb_| like\n-  // in DidPassCORSAccessCheck()?\n+bool MultibufferDataSource::IsCorsCrossOrigin() const {\n+  return url_data()->is_cors_cross_origin();\n }\n \n void MultibufferDataSource::MediaPlaybackRateChanged(double playback_rate) {\n@@ -627,8 +612,6 @@ void MultibufferDataSource::StartCallback() {\n     // Progress callback might be called after the start callback,\n     // make sure that we update single_origin_ now.\n     media_log_->SetBooleanProperty(\""single_origin\"", single_origin_);\n-    media_log_->SetBooleanProperty(\""passed_cors_access_check\"",\n-                                   DidPassCORSAccessCheck());\n     media_log_->SetBooleanProperty(\""range_header_supported\"",\n                                    url_data()->range_supported());\n   }""}<_**next**_>{""sha"": ""4da62a5519e33ab6e726406f0acac4995c4ad49f"", ""filename"": ""media/blink/multibuffer_data_source.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 6, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -79,12 +79,9 @@ class MEDIA_BLINK_EXPORT MultibufferDataSource : public DataSource {\n   // Method called on the render thread.\n   bool HasSingleOrigin();\n \n-  // Returns true if the media resource passed a CORS access control check.\n-  bool DidPassCORSAccessCheck() const;\n-\n-  // Returns true if a service worker provided the media resource response,\n-  // and the response was opaque.\n-  bool DidGetOpaqueResponseViaServiceWorker() const;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  // This must be called after the response arrives.\n+  bool IsCorsCrossOrigin() const;\n \n   // Notifies changes in playback state for controlling media buffering\n   // behavior.""}<_**next**_>{""sha"": ""4b9f83e74255bf14d33c3f0c2785c282ecb2bcd7"", ""filename"": ""media/blink/multibuffer_data_source_unittest.cc"", ""status"": ""modified"", ""additions"": 81, ""deletions"": 12, ""changes"": 93, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1493,35 +1493,104 @@ TEST_F(MultibufferDataSourceTest, FileSizeLessThanBlockSize) {\n   Stop();\n }\n \n-TEST_F(MultibufferDataSourceTest, DidPassCORSAccessTest) {\n+TEST_F(MultibufferDataSourceTest, ResponseTypeBasic) {\n   InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n   set_preload(MultibufferDataSource::NONE);\n   WebURLResponse response1 =\n       response_generator_->GeneratePartial206(0, kDataSize - 1);\n-  response1.SetWasFetchedViaServiceWorker(true);\n-  std::vector<blink::WebURL> urlList = {GURL(kHttpDifferentOriginUrl)};\n-  response1.SetURLListViaServiceWorker(urlList);\n-  WebURLResponse response2 =\n-      response_generator_->GeneratePartial206(kDataSize, kDataSize * 2 - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kBasic);\n \n   EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n   EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n   EXPECT_CALL(*this, ReadCallback(kDataSize));\n \n-  EXPECT_FALSE(data_source_->DidPassCORSAccessCheck());\n   Respond(response1);\n   ReceiveData(kDataSize);\n   ReadAt(0);\n   EXPECT_TRUE(loading());\n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n   FinishLoading();\n+}\n \n-  // Verify that if reader_ is null, DidPassCORSAccessCheck still returns true.\n-  data_source_->Stop();\n-  base::RunLoop().RunUntilIdle();\n+TEST_F(MultibufferDataSourceTest, ResponseTypeCors) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kCORS);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeDefault) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kDefault);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaque) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaque);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaqueRedirect) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaqueRedirect);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n }\n \n TEST_F(MultibufferDataSourceTest, EtagTest) {""}<_**next**_>{""sha"": ""89f1c9e70d2cc71646df50026b50d54d471d20c6"", ""filename"": ""media/blink/resource_multibuffer_data_provider.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/resource_multibuffer_data_provider.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -280,6 +280,8 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n   int64_t content_length = response.ExpectedContentLength();\n   bool end_of_file = false;\n   bool do_fail = false;\n+  // We get the response type here because aborting the loader may change it.\n+  const auto response_type = response.GetType();\n   bytes_to_discard_ = 0;\n \n   // We make a strong assumption that when we reach here we have either\n@@ -333,10 +335,9 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n         url_data_->url_index()->TryInsert(destination_url_data);\n   }\n \n-  // This is vital for security! A service worker can respond with a response\n-  // from a different origin, so this response type is needed to detect that.\n-  destination_url_data->set_has_opaque_data(\n-      network::cors::IsCORSCrossOriginResponseType(response.GetType()));\n+  // This is vital for security!\n+  destination_url_data->set_is_cors_cross_origin(\n+      network::cors::IsCORSCrossOriginResponseType(response_type));\n \n   if (destination_url_data != url_data_) {\n     // At this point, we've encountered a redirect, or found a better url data""}<_**next**_>{""sha"": ""3fb63497791a3d2a0ea1e3b12c018f4b2c5fe355"", ""filename"": ""media/blink/url_index.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 7, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -65,7 +65,6 @@ UrlData::UrlData(const GURL& url, CORSMode cors_mode, UrlIndex* url_index)\n       length_(kPositionNotSpecified),\n       range_supported_(false),\n       cacheable_(false),\n-      has_opaque_data_(false),\n       last_used_(),\n       multibuffer_(this, url_index_->block_shift_) {}\n \n@@ -103,9 +102,8 @@ void UrlData::MergeFrom(const scoped_refptr<UrlData>& other) {\n       last_modified_ = other->last_modified_;\n     }\n     bytes_read_from_cache_ += other->bytes_read_from_cache_;\n-    // set_has_opaque_data() will not relax from opaque to non-opaque if already\n-    // opaque.\n-    set_has_opaque_data(other->has_opaque_data_);\n+    // is_cors_corss_origin_ will not relax from true to false.\n+    set_is_cors_cross_origin(other->is_cors_cross_origin_);\n     multibuffer()->MergeFrom(other->multibuffer());\n   }\n }\n@@ -122,10 +120,10 @@ void UrlData::set_length(int64_t length) {\n   }\n }\n \n-void UrlData::set_has_opaque_data(bool has_opaque_data) {\n-  if (has_opaque_data_)\n+void UrlData::set_is_cors_cross_origin(bool is_cors_cross_origin) {\n+  if (is_cors_cross_origin_)\n     return;\n-  has_opaque_data_ = has_opaque_data;\n+  is_cors_cross_origin_ = is_cors_cross_origin;\n }\n \n void UrlData::RedirectTo(const scoped_refptr<UrlData>& url_data) {""}<_**next**_>{""sha"": ""2c15bc7ac0ad4489a0c922f614889e575bd5d863"", ""filename"": ""media/blink/url_index.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -125,7 +125,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // Returns our url_index.\n   UrlIndex* url_index() const { return url_index_; }\n \n-  bool has_opaque_data() const { return has_opaque_data_; }\n+  // This must be called after the response arrives.\n+  bool is_cors_cross_origin() const { return is_cors_cross_origin_; }\n \n   // Notifies the url index that this is currently used.\n   // The url <-> URLData mapping will be eventually be invalidated if\n@@ -145,7 +146,7 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   void set_range_supported();\n   void set_last_modified(base::Time last_modified);\n   void set_etag(const std::string& etag);\n-  void set_has_opaque_data(bool has_opaque_data);\n+  void set_is_cors_cross_origin(bool is_cors_cross_origin);\n \n   // A redirect has occured (or we've found a better UrlData for the same\n   // resource).\n@@ -238,9 +239,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // will not cache this url.\n   bool cacheable_;\n \n-  // True if a service worker intercepted a request for this resource\n-  // and provided an opaque response.\n-  bool has_opaque_data_;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  bool is_cors_cross_origin_ = false;\n \n   // Last time some media time used this resource.\n   // Note that we use base::Time rather than base::TimeTicks because""}<_**next**_>{""sha"": ""cf0857d8c6283758b159609f76da1bafb19cc789"", ""filename"": ""media/blink/webmediaplayer_impl.cc"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 10, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1175,12 +1175,6 @@ void WebMediaPlayerImpl::Paint(cc::PaintCanvas* canvas,\n       context_support);\n }\n \n-bool WebMediaPlayerImpl::DidGetOpaqueResponseFromServiceWorker() const {\n-  if (data_source_)\n-    return data_source_->DidGetOpaqueResponseViaServiceWorker();\n-  return false;\n-}\n-\n bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   if (demuxer_found_hls_) {\n     // HLS manifests might pull segments from a different origin. We can't know\n@@ -1193,10 +1187,15 @@ bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   return true;\n }\n \n-bool WebMediaPlayerImpl::DidPassCORSAccessCheck() const {\n-  if (data_source_)\n-    return data_source_->DidPassCORSAccessCheck();\n-  return false;\n+bool WebMediaPlayerImpl::WouldTaintOrigin() const {\n+  if (!HasSingleSecurityOrigin()) {\n+    // When the resource is redirected to another origin we think it as\n+    // tainted. This is actually not specified, and is under discussion.\n+    // See https://github.com/whatwg/fetch/issues/737.\n+    return true;\n+  }\n+\n+  return data_source_ && data_source_->IsCorsCrossOrigin();\n }\n \n double WebMediaPlayerImpl::MediaTimeForTimeValue(double timeValue) const {""}<_**next**_>{""sha"": ""233e37b4614544e9b2a67b4e5edee775de0f79a6"", ""filename"": ""media/blink/webmediaplayer_impl.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -188,10 +188,7 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n \n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n-\n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n \n@@ -332,6 +329,8 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n   void OnPipelineResumed();\n   void OnDemuxerOpened();\n \n+  bool HasSingleSecurityOrigin() const;\n+\n   // Pipeline::Client overrides.\n   void OnError(PipelineStatus status) override;\n   void OnEnded() override;""}<_**next**_>{""sha"": ""9821759bc7b311672a54387edc7d8c26a11d5e54"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""status"": ""added"", ""additions"": 47, ""deletions"": 0, ""changes"": 47, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -0,0 +1,47 @@\n+<!doctype html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+<script src=\""/common/get-host-info.sub.js\""></script>\n+<script src=\""resources/test-helpers.sub.js?pipe=sub\""></script>\n+<script>\n+promise_test(async (t) => {\n+    const SCOPE = 'resources/empty.html';\n+    const SCRIPT = 'resources/fetch-rewrite-worker.js';\n+    const host_info = get_host_info();\n+    const REMOTE_ORIGIN = host_info.HTTPS_REMOTE_ORIGIN;\n+\n+    const reg = await service_worker_unregister_and_register(t, SCRIPT, SCOPE);\n+    await wait_for_state(t, reg.installing, 'activated');\n+    const frame = await with_iframe(SCOPE);\n+\n+    const doc = frame.contentDocument;\n+    const win = frame.contentWindow;\n+\n+    const context = new win.AudioContext();\n+    try {\n+      context.suspend();\n+      const audio = doc.createElement('audio');\n+      audio.autoplay = true;\n+      const source = context.createMediaElementSource(audio);\n+      const spn = context.createScriptProcessor(16384, 1, 1);\n+      source.connect(spn).connect(context.destination);\n+      const url = `${REMOTE_ORIGIN}/webaudio/resources/sin_440Hz_-6dBFS_1s.wav`;\n+      audio.src = '/test?url=' + encodeURIComponent(url);\n+      doc.body.appendChild(audio);\n+\n+      await new Promise((resolve) => {\n+        audio.addEventListener('playing', resolve);\n+      });\n+      await context.resume();\n+      const event = await new Promise((resolve) => {\n+        spn.addEventListener('audioprocess', resolve);\n+      });\n+      const data = event.inputBuffer.getChannelData(0);\n+      for (const e of data) {\n+        assert_equals(e, 0);\n+      }\n+    } finally {\n+      context.close();\n+    }\n+  }, 'Verify CORS XHR of fetch() in a Service Worker');\n+</script>""}<_**next**_>{""sha"": ""319648dbc16669ab3b3238d8488997b7d3a7c837"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""58697c0661a94d03e4bbe74134a23e71a860f5f6"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""a1e82caf7e2f9d37d785165a4766f42acb28c465"", ""filename"": ""third_party/blink/public/platform/web_media_player.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/public/platform/web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -207,9 +207,10 @@ class WebMediaPlayer {\n \n   virtual bool DidLoadingProgress() = 0;\n \n-  virtual bool DidGetOpaqueResponseFromServiceWorker() const = 0;\n-  virtual bool HasSingleSecurityOrigin() const = 0;\n-  virtual bool DidPassCORSAccessCheck() const = 0;\n+  // Returns true if the response is CORS-cross-origin and so we shouldn't be\n+  // allowing media to play through webaudio.\n+  // This should be called after the response has arrived.\n+  virtual bool WouldTaintOrigin() const = 0;\n \n   virtual double MediaTimeForTimeValue(double time_value) const = 0;\n ""}<_**next**_>{""sha"": ""ad708c861bb80cd8a01217eec51f9fe058af4a33"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 21, ""changes"": 26, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1506,30 +1506,14 @@ bool HTMLMediaElement::IsSafeToLoadURL(const KURL& url,\n \n bool HTMLMediaElement::IsMediaDataCORSSameOrigin(\n     const SecurityOrigin* origin) const {\n-  // If a service worker handled the request, we don't know if the origin in the\n-  // src is the same as the actual response URL so can't rely on URL checks\n-  // alone. So detect an opaque response via\n-  // DidGetOpaqueResponseFromServiceWorker().\n-  if (GetWebMediaPlayer() &&\n-      GetWebMediaPlayer()->DidGetOpaqueResponseFromServiceWorker()) {\n-    return false;\n-  }\n-\n-  // At this point, either a service worker was not used, or it didn't provide\n-  // an opaque response, so continue with the normal checks.\n+  if (!GetWebMediaPlayer())\n+    return true;\n \n-  // HasSingleSecurityOrigin() tells us whether the origin in the src\n-  // is the same as the actual request (i.e. after redirects).\n-  if (!HasSingleSecurityOrigin())\n+  const auto network_state = GetWebMediaPlayer()->GetNetworkState();\n+  if (network_state == WebMediaPlayer::kNetworkStateNetworkError)\n     return false;\n \n-  // DidPassCORSAccessCheck() means it was a successful CORS-enabled fetch (vs.\n-  // non-CORS-enabled or failed). CanReadContent() does CheckAccess() on the\n-  // URL plus allows data sources, to ensure that it is not a URL that requires\n-  // CORS (basically same origin).\n-  return (GetWebMediaPlayer() &&\n-          GetWebMediaPlayer()->DidPassCORSAccessCheck()) ||\n-         origin->CanReadContent(currentSrc());\n+  return !GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n bool HTMLMediaElement::IsInCrossOriginFrame() const {""}<_**next**_>{""sha"": ""f2d50264a53a0a3002725b06b6363091f4e17faa"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -268,11 +268,6 @@ class CORE_EXPORT HTMLMediaElement\n   // of one of them here.\n   using HTMLElement::GetExecutionContext;\n \n-  bool HasSingleSecurityOrigin() const {\n-    return GetWebMediaPlayer() ? GetWebMediaPlayer()->HasSingleSecurityOrigin()\n-                               : true;\n-  }\n-\n   bool IsFullscreen() const;\n   virtual bool UsesOverlayFullscreenVideo() const { return false; }\n ""}<_**next**_>{""sha"": ""8cf3a926979a853d0ba0f48f9def6bc9b4aec36a"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 17, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -958,21 +958,4 @@ void BaseAudioContext::UpdateWorkletGlobalScopeOnRenderingThread() {\n   }\n }\n \n-bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {\n-  // Data URLs don't taint the origin.\n-  if (url.ProtocolIsData()) {\n-    return false;\n-  }\n-\n-  Document* document = GetDocument();\n-  if (document && document->GetSecurityOrigin()) {\n-    // The origin is tainted if and only if we cannot read content from the URL.\n-    return !document->GetSecurityOrigin()->CanRequest(url);\n-  }\n-\n-  // Be conservative and assume it's tainted if it's not a data url and if we\n-  // can't get the security origin of the document.\n-  return true;\n-}\n-\n }  // namespace blink""}<_**next**_>{""sha"": ""ae933f20167fb374b51ff5a869d9381f97b56d4b"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -296,13 +296,6 @@ class MODULES_EXPORT BaseAudioContext\n   // Does nothing when the worklet global scope does not exist.\n   void UpdateWorkletGlobalScopeOnRenderingThread();\n \n-  // Returns true if the URL would taint the origin so that we shouldn't be\n-  // allowing media to played through webaudio.\n-  // TODO(crbug.com/845913): This should really be on an AudioContext.  Move\n-  // this when we move the media stuff from BaseAudioContext to AudioContext, as\n-  // requried by the spec.\n-  bool WouldTaintOrigin(const KURL& url) const;\n-\n  protected:\n   enum ContextType { kRealtimeContext, kOfflineContext };\n ""}<_**next**_>{""sha"": ""d7b07b5fea75809b4e14c8fda74b38a1d48e6b9d"", ""filename"": ""third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 13, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -136,19 +136,7 @@ void MediaElementAudioSourceHandler::SetFormat(size_t number_of_channels,\n }\n \n bool MediaElementAudioSourceHandler::WouldTaintOrigin() {\n-  // If we're cross-origin and allowed access vie CORS, we're not tainted.\n-  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {\n-    return false;\n-  }\n-\n-  // Handles the case where the url is a redirect to another site that we're not\n-  // allowed to access.\n-  if (!MediaElement()->HasSingleSecurityOrigin()) {\n-    return true;\n-  }\n-\n-  // Test to see if the current media URL taint the origin of the audio context?\n-  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());\n+  return MediaElement()->GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n void MediaElementAudioSourceHandler::PrintCORSMessage(const String& message) {""}<_**next**_>{""sha"": ""6e5771836bf84527d922a6c5fc84a3aa5c8c9bce"", ""filename"": ""third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/testing/empty_web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -50,9 +50,7 @@ class EmptyWebMediaPlayer : public WebMediaPlayer {\n   ReadyState GetReadyState() const override { return kReadyStateHaveNothing; }\n   WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override { return false; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double time_value) const override {\n     return time_value;\n   };""}","UrlData::UrlData(const GURL& url, CORSMode cors_mode, UrlIndex* url_index)
    : url_(url),
      have_data_origin_(false),
      cors_mode_(cors_mode),
      url_index_(url_index),
       length_(kPositionNotSpecified),
       range_supported_(false),
       cacheable_(false),
       last_used_(),
       multibuffer_(this, url_index_->block_shift_) {}
","UrlData::UrlData(const GURL& url, CORSMode cors_mode, UrlIndex* url_index)
    : url_(url),
      have_data_origin_(false),
      cors_mode_(cors_mode),
      url_index_(url_index),
       length_(kPositionNotSpecified),
       range_supported_(false),
       cacheable_(false),
      has_opaque_data_(false),
       last_used_(),
       multibuffer_(this, url_index_->block_shift_) {}
",C,,"      has_opaque_data_(false),
",,"@@ -65,7 +65,6 @@ UrlData::UrlData(const GURL& url, CORSMode cors_mode, UrlIndex* url_index)
       length_(kPositionNotSpecified),
       range_supported_(false),
       cacheable_(false),
-      has_opaque_data_(false),
       last_used_(),
       multibuffer_(this, url_index_->block_shift_) {}
 
@@ -103,9 +102,8 @@ void UrlData::MergeFrom(const scoped_refptr<UrlData>& other) {
       last_modified_ = other->last_modified_;
     }
     bytes_read_from_cache_ += other->bytes_read_from_cache_;
-    // set_has_opaque_data() will not relax from opaque to non-opaque if already
-    // opaque.
-    set_has_opaque_data(other->has_opaque_data_);
+    // is_cors_corss_origin_ will not relax from true to false.
+    set_is_cors_cross_origin(other->is_cors_cross_origin_);
     multibuffer()->MergeFrom(other->multibuffer());
   }
 }
@@ -122,10 +120,10 @@ void UrlData::set_length(int64_t length) {
   }
 }
 
-void UrlData::set_has_opaque_data(bool has_opaque_data) {
-  if (has_opaque_data_)
+void UrlData::set_is_cors_cross_origin(bool is_cors_cross_origin) {
+  if (is_cors_cross_origin_)
     return;
-  has_opaque_data_ = has_opaque_data;
+  is_cors_cross_origin_ = is_cors_cross_origin;
 }
 
 void UrlData::RedirectTo(const scoped_refptr<UrlData>& url_data) {",Chrome,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,50436d878b2e92de4231fda47328a8a4e884ecc3,1,"UrlData::UrlData(const GURL& url, CORSMode cors_mode, UrlIndex* url_index)
    : url_(url),
      have_data_origin_(false),
      cors_mode_(cors_mode),
      url_index_(url_index),
       length_(kPositionNotSpecified),
       range_supported_(false),
       cacheable_(false),
//flaw_line_below:
      has_opaque_data_(false),
       last_used_(),
       multibuffer_(this, url_index_->block_shift_) {}
"
8870,186606,,Remote,Not required,,CVE-2018-18352,https://www.cvedetails.com/cve/CVE-2018-18352/,CWE-732,Medium,Partial,,,2018-12-11,4.3,Service works could inappropriately gain access to cross origin audio in Media in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to bypass same origin policy for audio content via a crafted HTML page.,2019-10-02,Bypass ,3,https://github.com/chromium/chromium/commit/a9cbaa7a40e2b2723cfc2f266c42f4980038a949,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,"Simplify ""WouldTaintOrigin"" concept in media/blink

Currently WebMediaPlayer has three predicates:
 - DidGetOpaqueResponseFromServiceWorker
 - HasSingleSecurityOrigin
 - DidPassCORSAccessCheck
. These are used to determine whether the response body is available
for scripts. They are known to be confusing, and actually
MediaElementAudioSourceHandler::WouldTaintOrigin misuses them.

This CL merges the three predicates to one, WouldTaintOrigin, to remove
the confusion. Now the ""response type"" concept is available and we
don't need a custom CORS check, so this CL removes
BaseAudioContext::WouldTaintOrigin. This CL also renames
URLData::has_opaque_data_ and its (direct and indirect) data accessors
to match the spec.

Bug: 849942, 875153
Change-Id: I6acf50169d7445c4ff614e80ac606f79ee577d2a
Reviewed-on: https://chromium-review.googlesource.com/c/1238098
Reviewed-by: Fredrik Hubinette <hubbe@chromium.org>
Reviewed-by: Kinuko Yasuda <kinuko@chromium.org>
Reviewed-by: Raymond Toy <rtoy@chromium.org>
Commit-Queue: Yutaka Hirano <yhirano@chromium.org>
Cr-Commit-Position: refs/heads/master@{#598258}",2,media/blink/url_index.cc,"{""sha"": ""78ca5e2c3c323cf55e23eacc262e8a197e60b63b"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 11, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -844,21 +844,11 @@ void WebMediaPlayerMS::Paint(cc::PaintCanvas* canvas,\n                         context_3d, context_support);\n }\n \n-bool WebMediaPlayerMS::DidGetOpaqueResponseFromServiceWorker() const {\n+bool WebMediaPlayerMS::WouldTaintOrigin() const {\n   DCHECK(thread_checker_.CalledOnValidThread());\n   return false;\n }\n \n-bool WebMediaPlayerMS::HasSingleSecurityOrigin() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n-bool WebMediaPlayerMS::DidPassCORSAccessCheck() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n double WebMediaPlayerMS::MediaTimeForTimeValue(double timeValue) const {\n   return base::TimeDelta::FromSecondsD(timeValue).InSecondsF();\n }""}<_**next**_>{""sha"": ""8c3595505cb20fa379b861f49b28710c40f3a5f1"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -163,9 +163,7 @@ class CONTENT_EXPORT WebMediaPlayerMS\n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n \n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n ""}<_**next**_>{""sha"": ""d26bc8142d80dc7c64958a9c22170244d6e664dd"", ""filename"": ""content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -76,9 +76,7 @@ class MockWebMediaPlayer : public blink::WebMediaPlayer,\n   }\n \n   bool DidLoadingProgress() override { return true; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double timeValue) const override { return 0.0; }\n   unsigned DecodedFrameCount() const override { return 0; }\n   unsigned DroppedFrameCount() const override { return 0; }""}<_**next**_>{""sha"": ""74ad44546ee34afa79b4a1649710117f8532c5f4"", ""filename"": ""media/blink/multibuffer_data_source.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 19, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -286,23 +286,8 @@ bool MultibufferDataSource::HasSingleOrigin() {\n   return single_origin_;\n }\n \n-bool MultibufferDataSource::DidPassCORSAccessCheck() const {\n-  if (url_data()->cors_mode() == UrlData::CORS_UNSPECIFIED)\n-    return false;\n-\n-  // If init_cb is set, we know initialization is not finished yet.\n-  if (init_cb_)\n-    return false;\n-  if (failed_)\n-    return false;\n-  return true;\n-}\n-\n-bool MultibufferDataSource::DidGetOpaqueResponseViaServiceWorker() const {\n-  return url_data()->has_opaque_data();\n-\n-  // TODO(falken): Do we need to do something about |init_cb_| like\n-  // in DidPassCORSAccessCheck()?\n+bool MultibufferDataSource::IsCorsCrossOrigin() const {\n+  return url_data()->is_cors_cross_origin();\n }\n \n void MultibufferDataSource::MediaPlaybackRateChanged(double playback_rate) {\n@@ -627,8 +612,6 @@ void MultibufferDataSource::StartCallback() {\n     // Progress callback might be called after the start callback,\n     // make sure that we update single_origin_ now.\n     media_log_->SetBooleanProperty(\""single_origin\"", single_origin_);\n-    media_log_->SetBooleanProperty(\""passed_cors_access_check\"",\n-                                   DidPassCORSAccessCheck());\n     media_log_->SetBooleanProperty(\""range_header_supported\"",\n                                    url_data()->range_supported());\n   }""}<_**next**_>{""sha"": ""4da62a5519e33ab6e726406f0acac4995c4ad49f"", ""filename"": ""media/blink/multibuffer_data_source.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 6, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -79,12 +79,9 @@ class MEDIA_BLINK_EXPORT MultibufferDataSource : public DataSource {\n   // Method called on the render thread.\n   bool HasSingleOrigin();\n \n-  // Returns true if the media resource passed a CORS access control check.\n-  bool DidPassCORSAccessCheck() const;\n-\n-  // Returns true if a service worker provided the media resource response,\n-  // and the response was opaque.\n-  bool DidGetOpaqueResponseViaServiceWorker() const;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  // This must be called after the response arrives.\n+  bool IsCorsCrossOrigin() const;\n \n   // Notifies changes in playback state for controlling media buffering\n   // behavior.""}<_**next**_>{""sha"": ""4b9f83e74255bf14d33c3f0c2785c282ecb2bcd7"", ""filename"": ""media/blink/multibuffer_data_source_unittest.cc"", ""status"": ""modified"", ""additions"": 81, ""deletions"": 12, ""changes"": 93, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1493,35 +1493,104 @@ TEST_F(MultibufferDataSourceTest, FileSizeLessThanBlockSize) {\n   Stop();\n }\n \n-TEST_F(MultibufferDataSourceTest, DidPassCORSAccessTest) {\n+TEST_F(MultibufferDataSourceTest, ResponseTypeBasic) {\n   InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n   set_preload(MultibufferDataSource::NONE);\n   WebURLResponse response1 =\n       response_generator_->GeneratePartial206(0, kDataSize - 1);\n-  response1.SetWasFetchedViaServiceWorker(true);\n-  std::vector<blink::WebURL> urlList = {GURL(kHttpDifferentOriginUrl)};\n-  response1.SetURLListViaServiceWorker(urlList);\n-  WebURLResponse response2 =\n-      response_generator_->GeneratePartial206(kDataSize, kDataSize * 2 - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kBasic);\n \n   EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n   EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n   EXPECT_CALL(*this, ReadCallback(kDataSize));\n \n-  EXPECT_FALSE(data_source_->DidPassCORSAccessCheck());\n   Respond(response1);\n   ReceiveData(kDataSize);\n   ReadAt(0);\n   EXPECT_TRUE(loading());\n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n   FinishLoading();\n+}\n \n-  // Verify that if reader_ is null, DidPassCORSAccessCheck still returns true.\n-  data_source_->Stop();\n-  base::RunLoop().RunUntilIdle();\n+TEST_F(MultibufferDataSourceTest, ResponseTypeCors) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kCORS);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeDefault) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kDefault);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaque) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaque);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaqueRedirect) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaqueRedirect);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n }\n \n TEST_F(MultibufferDataSourceTest, EtagTest) {""}<_**next**_>{""sha"": ""89f1c9e70d2cc71646df50026b50d54d471d20c6"", ""filename"": ""media/blink/resource_multibuffer_data_provider.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/resource_multibuffer_data_provider.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -280,6 +280,8 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n   int64_t content_length = response.ExpectedContentLength();\n   bool end_of_file = false;\n   bool do_fail = false;\n+  // We get the response type here because aborting the loader may change it.\n+  const auto response_type = response.GetType();\n   bytes_to_discard_ = 0;\n \n   // We make a strong assumption that when we reach here we have either\n@@ -333,10 +335,9 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n         url_data_->url_index()->TryInsert(destination_url_data);\n   }\n \n-  // This is vital for security! A service worker can respond with a response\n-  // from a different origin, so this response type is needed to detect that.\n-  destination_url_data->set_has_opaque_data(\n-      network::cors::IsCORSCrossOriginResponseType(response.GetType()));\n+  // This is vital for security!\n+  destination_url_data->set_is_cors_cross_origin(\n+      network::cors::IsCORSCrossOriginResponseType(response_type));\n \n   if (destination_url_data != url_data_) {\n     // At this point, we've encountered a redirect, or found a better url data""}<_**next**_>{""sha"": ""3fb63497791a3d2a0ea1e3b12c018f4b2c5fe355"", ""filename"": ""media/blink/url_index.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 7, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -65,7 +65,6 @@ UrlData::UrlData(const GURL& url, CORSMode cors_mode, UrlIndex* url_index)\n       length_(kPositionNotSpecified),\n       range_supported_(false),\n       cacheable_(false),\n-      has_opaque_data_(false),\n       last_used_(),\n       multibuffer_(this, url_index_->block_shift_) {}\n \n@@ -103,9 +102,8 @@ void UrlData::MergeFrom(const scoped_refptr<UrlData>& other) {\n       last_modified_ = other->last_modified_;\n     }\n     bytes_read_from_cache_ += other->bytes_read_from_cache_;\n-    // set_has_opaque_data() will not relax from opaque to non-opaque if already\n-    // opaque.\n-    set_has_opaque_data(other->has_opaque_data_);\n+    // is_cors_corss_origin_ will not relax from true to false.\n+    set_is_cors_cross_origin(other->is_cors_cross_origin_);\n     multibuffer()->MergeFrom(other->multibuffer());\n   }\n }\n@@ -122,10 +120,10 @@ void UrlData::set_length(int64_t length) {\n   }\n }\n \n-void UrlData::set_has_opaque_data(bool has_opaque_data) {\n-  if (has_opaque_data_)\n+void UrlData::set_is_cors_cross_origin(bool is_cors_cross_origin) {\n+  if (is_cors_cross_origin_)\n     return;\n-  has_opaque_data_ = has_opaque_data;\n+  is_cors_cross_origin_ = is_cors_cross_origin;\n }\n \n void UrlData::RedirectTo(const scoped_refptr<UrlData>& url_data) {""}<_**next**_>{""sha"": ""2c15bc7ac0ad4489a0c922f614889e575bd5d863"", ""filename"": ""media/blink/url_index.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -125,7 +125,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // Returns our url_index.\n   UrlIndex* url_index() const { return url_index_; }\n \n-  bool has_opaque_data() const { return has_opaque_data_; }\n+  // This must be called after the response arrives.\n+  bool is_cors_cross_origin() const { return is_cors_cross_origin_; }\n \n   // Notifies the url index that this is currently used.\n   // The url <-> URLData mapping will be eventually be invalidated if\n@@ -145,7 +146,7 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   void set_range_supported();\n   void set_last_modified(base::Time last_modified);\n   void set_etag(const std::string& etag);\n-  void set_has_opaque_data(bool has_opaque_data);\n+  void set_is_cors_cross_origin(bool is_cors_cross_origin);\n \n   // A redirect has occured (or we've found a better UrlData for the same\n   // resource).\n@@ -238,9 +239,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // will not cache this url.\n   bool cacheable_;\n \n-  // True if a service worker intercepted a request for this resource\n-  // and provided an opaque response.\n-  bool has_opaque_data_;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  bool is_cors_cross_origin_ = false;\n \n   // Last time some media time used this resource.\n   // Note that we use base::Time rather than base::TimeTicks because""}<_**next**_>{""sha"": ""cf0857d8c6283758b159609f76da1bafb19cc789"", ""filename"": ""media/blink/webmediaplayer_impl.cc"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 10, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1175,12 +1175,6 @@ void WebMediaPlayerImpl::Paint(cc::PaintCanvas* canvas,\n       context_support);\n }\n \n-bool WebMediaPlayerImpl::DidGetOpaqueResponseFromServiceWorker() const {\n-  if (data_source_)\n-    return data_source_->DidGetOpaqueResponseViaServiceWorker();\n-  return false;\n-}\n-\n bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   if (demuxer_found_hls_) {\n     // HLS manifests might pull segments from a different origin. We can't know\n@@ -1193,10 +1187,15 @@ bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   return true;\n }\n \n-bool WebMediaPlayerImpl::DidPassCORSAccessCheck() const {\n-  if (data_source_)\n-    return data_source_->DidPassCORSAccessCheck();\n-  return false;\n+bool WebMediaPlayerImpl::WouldTaintOrigin() const {\n+  if (!HasSingleSecurityOrigin()) {\n+    // When the resource is redirected to another origin we think it as\n+    // tainted. This is actually not specified, and is under discussion.\n+    // See https://github.com/whatwg/fetch/issues/737.\n+    return true;\n+  }\n+\n+  return data_source_ && data_source_->IsCorsCrossOrigin();\n }\n \n double WebMediaPlayerImpl::MediaTimeForTimeValue(double timeValue) const {""}<_**next**_>{""sha"": ""233e37b4614544e9b2a67b4e5edee775de0f79a6"", ""filename"": ""media/blink/webmediaplayer_impl.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -188,10 +188,7 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n \n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n-\n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n \n@@ -332,6 +329,8 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n   void OnPipelineResumed();\n   void OnDemuxerOpened();\n \n+  bool HasSingleSecurityOrigin() const;\n+\n   // Pipeline::Client overrides.\n   void OnError(PipelineStatus status) override;\n   void OnEnded() override;""}<_**next**_>{""sha"": ""9821759bc7b311672a54387edc7d8c26a11d5e54"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""status"": ""added"", ""additions"": 47, ""deletions"": 0, ""changes"": 47, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -0,0 +1,47 @@\n+<!doctype html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+<script src=\""/common/get-host-info.sub.js\""></script>\n+<script src=\""resources/test-helpers.sub.js?pipe=sub\""></script>\n+<script>\n+promise_test(async (t) => {\n+    const SCOPE = 'resources/empty.html';\n+    const SCRIPT = 'resources/fetch-rewrite-worker.js';\n+    const host_info = get_host_info();\n+    const REMOTE_ORIGIN = host_info.HTTPS_REMOTE_ORIGIN;\n+\n+    const reg = await service_worker_unregister_and_register(t, SCRIPT, SCOPE);\n+    await wait_for_state(t, reg.installing, 'activated');\n+    const frame = await with_iframe(SCOPE);\n+\n+    const doc = frame.contentDocument;\n+    const win = frame.contentWindow;\n+\n+    const context = new win.AudioContext();\n+    try {\n+      context.suspend();\n+      const audio = doc.createElement('audio');\n+      audio.autoplay = true;\n+      const source = context.createMediaElementSource(audio);\n+      const spn = context.createScriptProcessor(16384, 1, 1);\n+      source.connect(spn).connect(context.destination);\n+      const url = `${REMOTE_ORIGIN}/webaudio/resources/sin_440Hz_-6dBFS_1s.wav`;\n+      audio.src = '/test?url=' + encodeURIComponent(url);\n+      doc.body.appendChild(audio);\n+\n+      await new Promise((resolve) => {\n+        audio.addEventListener('playing', resolve);\n+      });\n+      await context.resume();\n+      const event = await new Promise((resolve) => {\n+        spn.addEventListener('audioprocess', resolve);\n+      });\n+      const data = event.inputBuffer.getChannelData(0);\n+      for (const e of data) {\n+        assert_equals(e, 0);\n+      }\n+    } finally {\n+      context.close();\n+    }\n+  }, 'Verify CORS XHR of fetch() in a Service Worker');\n+</script>""}<_**next**_>{""sha"": ""319648dbc16669ab3b3238d8488997b7d3a7c837"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""58697c0661a94d03e4bbe74134a23e71a860f5f6"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""a1e82caf7e2f9d37d785165a4766f42acb28c465"", ""filename"": ""third_party/blink/public/platform/web_media_player.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/public/platform/web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -207,9 +207,10 @@ class WebMediaPlayer {\n \n   virtual bool DidLoadingProgress() = 0;\n \n-  virtual bool DidGetOpaqueResponseFromServiceWorker() const = 0;\n-  virtual bool HasSingleSecurityOrigin() const = 0;\n-  virtual bool DidPassCORSAccessCheck() const = 0;\n+  // Returns true if the response is CORS-cross-origin and so we shouldn't be\n+  // allowing media to play through webaudio.\n+  // This should be called after the response has arrived.\n+  virtual bool WouldTaintOrigin() const = 0;\n \n   virtual double MediaTimeForTimeValue(double time_value) const = 0;\n ""}<_**next**_>{""sha"": ""ad708c861bb80cd8a01217eec51f9fe058af4a33"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 21, ""changes"": 26, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1506,30 +1506,14 @@ bool HTMLMediaElement::IsSafeToLoadURL(const KURL& url,\n \n bool HTMLMediaElement::IsMediaDataCORSSameOrigin(\n     const SecurityOrigin* origin) const {\n-  // If a service worker handled the request, we don't know if the origin in the\n-  // src is the same as the actual response URL so can't rely on URL checks\n-  // alone. So detect an opaque response via\n-  // DidGetOpaqueResponseFromServiceWorker().\n-  if (GetWebMediaPlayer() &&\n-      GetWebMediaPlayer()->DidGetOpaqueResponseFromServiceWorker()) {\n-    return false;\n-  }\n-\n-  // At this point, either a service worker was not used, or it didn't provide\n-  // an opaque response, so continue with the normal checks.\n+  if (!GetWebMediaPlayer())\n+    return true;\n \n-  // HasSingleSecurityOrigin() tells us whether the origin in the src\n-  // is the same as the actual request (i.e. after redirects).\n-  if (!HasSingleSecurityOrigin())\n+  const auto network_state = GetWebMediaPlayer()->GetNetworkState();\n+  if (network_state == WebMediaPlayer::kNetworkStateNetworkError)\n     return false;\n \n-  // DidPassCORSAccessCheck() means it was a successful CORS-enabled fetch (vs.\n-  // non-CORS-enabled or failed). CanReadContent() does CheckAccess() on the\n-  // URL plus allows data sources, to ensure that it is not a URL that requires\n-  // CORS (basically same origin).\n-  return (GetWebMediaPlayer() &&\n-          GetWebMediaPlayer()->DidPassCORSAccessCheck()) ||\n-         origin->CanReadContent(currentSrc());\n+  return !GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n bool HTMLMediaElement::IsInCrossOriginFrame() const {""}<_**next**_>{""sha"": ""f2d50264a53a0a3002725b06b6363091f4e17faa"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -268,11 +268,6 @@ class CORE_EXPORT HTMLMediaElement\n   // of one of them here.\n   using HTMLElement::GetExecutionContext;\n \n-  bool HasSingleSecurityOrigin() const {\n-    return GetWebMediaPlayer() ? GetWebMediaPlayer()->HasSingleSecurityOrigin()\n-                               : true;\n-  }\n-\n   bool IsFullscreen() const;\n   virtual bool UsesOverlayFullscreenVideo() const { return false; }\n ""}<_**next**_>{""sha"": ""8cf3a926979a853d0ba0f48f9def6bc9b4aec36a"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 17, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -958,21 +958,4 @@ void BaseAudioContext::UpdateWorkletGlobalScopeOnRenderingThread() {\n   }\n }\n \n-bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {\n-  // Data URLs don't taint the origin.\n-  if (url.ProtocolIsData()) {\n-    return false;\n-  }\n-\n-  Document* document = GetDocument();\n-  if (document && document->GetSecurityOrigin()) {\n-    // The origin is tainted if and only if we cannot read content from the URL.\n-    return !document->GetSecurityOrigin()->CanRequest(url);\n-  }\n-\n-  // Be conservative and assume it's tainted if it's not a data url and if we\n-  // can't get the security origin of the document.\n-  return true;\n-}\n-\n }  // namespace blink""}<_**next**_>{""sha"": ""ae933f20167fb374b51ff5a869d9381f97b56d4b"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -296,13 +296,6 @@ class MODULES_EXPORT BaseAudioContext\n   // Does nothing when the worklet global scope does not exist.\n   void UpdateWorkletGlobalScopeOnRenderingThread();\n \n-  // Returns true if the URL would taint the origin so that we shouldn't be\n-  // allowing media to played through webaudio.\n-  // TODO(crbug.com/845913): This should really be on an AudioContext.  Move\n-  // this when we move the media stuff from BaseAudioContext to AudioContext, as\n-  // requried by the spec.\n-  bool WouldTaintOrigin(const KURL& url) const;\n-\n  protected:\n   enum ContextType { kRealtimeContext, kOfflineContext };\n ""}<_**next**_>{""sha"": ""d7b07b5fea75809b4e14c8fda74b38a1d48e6b9d"", ""filename"": ""third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 13, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -136,19 +136,7 @@ void MediaElementAudioSourceHandler::SetFormat(size_t number_of_channels,\n }\n \n bool MediaElementAudioSourceHandler::WouldTaintOrigin() {\n-  // If we're cross-origin and allowed access vie CORS, we're not tainted.\n-  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {\n-    return false;\n-  }\n-\n-  // Handles the case where the url is a redirect to another site that we're not\n-  // allowed to access.\n-  if (!MediaElement()->HasSingleSecurityOrigin()) {\n-    return true;\n-  }\n-\n-  // Test to see if the current media URL taint the origin of the audio context?\n-  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());\n+  return MediaElement()->GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n void MediaElementAudioSourceHandler::PrintCORSMessage(const String& message) {""}<_**next**_>{""sha"": ""6e5771836bf84527d922a6c5fc84a3aa5c8c9bce"", ""filename"": ""third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/testing/empty_web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -50,9 +50,7 @@ class EmptyWebMediaPlayer : public WebMediaPlayer {\n   ReadyState GetReadyState() const override { return kReadyStateHaveNothing; }\n   WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override { return false; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double time_value) const override {\n     return time_value;\n   };""}","void UrlData::set_has_opaque_data(bool has_opaque_data) {
void UrlData::set_is_cors_cross_origin(bool is_cors_cross_origin) {
  if (is_cors_cross_origin_)
     return;
  is_cors_cross_origin_ = is_cors_cross_origin;
 }
","void UrlData::set_has_opaque_data(bool has_opaque_data) {
  if (has_opaque_data_)
     return;
  has_opaque_data_ = has_opaque_data;
 }
",C,"void UrlData::set_is_cors_cross_origin(bool is_cors_cross_origin) {
  if (is_cors_cross_origin_)
  is_cors_cross_origin_ = is_cors_cross_origin;
","  if (has_opaque_data_)
  has_opaque_data_ = has_opaque_data;
",,"@@ -65,7 +65,6 @@ UrlData::UrlData(const GURL& url, CORSMode cors_mode, UrlIndex* url_index)
       length_(kPositionNotSpecified),
       range_supported_(false),
       cacheable_(false),
-      has_opaque_data_(false),
       last_used_(),
       multibuffer_(this, url_index_->block_shift_) {}
 
@@ -103,9 +102,8 @@ void UrlData::MergeFrom(const scoped_refptr<UrlData>& other) {
       last_modified_ = other->last_modified_;
     }
     bytes_read_from_cache_ += other->bytes_read_from_cache_;
-    // set_has_opaque_data() will not relax from opaque to non-opaque if already
-    // opaque.
-    set_has_opaque_data(other->has_opaque_data_);
+    // is_cors_corss_origin_ will not relax from true to false.
+    set_is_cors_cross_origin(other->is_cors_cross_origin_);
     multibuffer()->MergeFrom(other->multibuffer());
   }
 }
@@ -122,10 +120,10 @@ void UrlData::set_length(int64_t length) {
   }
 }
 
-void UrlData::set_has_opaque_data(bool has_opaque_data) {
-  if (has_opaque_data_)
+void UrlData::set_is_cors_cross_origin(bool is_cors_cross_origin) {
+  if (is_cors_cross_origin_)
     return;
-  has_opaque_data_ = has_opaque_data;
+  is_cors_cross_origin_ = is_cors_cross_origin;
 }
 
 void UrlData::RedirectTo(const scoped_refptr<UrlData>& url_data) {",Chrome,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,50436d878b2e92de4231fda47328a8a4e884ecc3,1,"void UrlData::set_has_opaque_data(bool has_opaque_data) {
//flaw_line_below:
  if (has_opaque_data_)
//fix_flaw_line_below:
//void UrlData::set_is_cors_cross_origin(bool is_cors_cross_origin) {
//fix_flaw_line_below:
//  if (is_cors_cross_origin_)
     return;
//flaw_line_below:
  has_opaque_data_ = has_opaque_data;
//fix_flaw_line_below:
//  is_cors_cross_origin_ = is_cors_cross_origin;
 }
"
8871,186607,,Remote,Not required,,CVE-2018-18352,https://www.cvedetails.com/cve/CVE-2018-18352/,CWE-732,Medium,Partial,,,2018-12-11,4.3,Service works could inappropriately gain access to cross origin audio in Media in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to bypass same origin policy for audio content via a crafted HTML page.,2019-10-02,Bypass ,0,https://github.com/chromium/chromium/commit/a9cbaa7a40e2b2723cfc2f266c42f4980038a949,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,"Simplify ""WouldTaintOrigin"" concept in media/blink

Currently WebMediaPlayer has three predicates:
 - DidGetOpaqueResponseFromServiceWorker
 - HasSingleSecurityOrigin
 - DidPassCORSAccessCheck
. These are used to determine whether the response body is available
for scripts. They are known to be confusing, and actually
MediaElementAudioSourceHandler::WouldTaintOrigin misuses them.

This CL merges the three predicates to one, WouldTaintOrigin, to remove
the confusion. Now the ""response type"" concept is available and we
don't need a custom CORS check, so this CL removes
BaseAudioContext::WouldTaintOrigin. This CL also renames
URLData::has_opaque_data_ and its (direct and indirect) data accessors
to match the spec.

Bug: 849942, 875153
Change-Id: I6acf50169d7445c4ff614e80ac606f79ee577d2a
Reviewed-on: https://chromium-review.googlesource.com/c/1238098
Reviewed-by: Fredrik Hubinette <hubbe@chromium.org>
Reviewed-by: Kinuko Yasuda <kinuko@chromium.org>
Reviewed-by: Raymond Toy <rtoy@chromium.org>
Commit-Queue: Yutaka Hirano <yhirano@chromium.org>
Cr-Commit-Position: refs/heads/master@{#598258}",4,media/blink/webmediaplayer_impl.cc,"{""sha"": ""78ca5e2c3c323cf55e23eacc262e8a197e60b63b"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 11, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -844,21 +844,11 @@ void WebMediaPlayerMS::Paint(cc::PaintCanvas* canvas,\n                         context_3d, context_support);\n }\n \n-bool WebMediaPlayerMS::DidGetOpaqueResponseFromServiceWorker() const {\n+bool WebMediaPlayerMS::WouldTaintOrigin() const {\n   DCHECK(thread_checker_.CalledOnValidThread());\n   return false;\n }\n \n-bool WebMediaPlayerMS::HasSingleSecurityOrigin() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n-bool WebMediaPlayerMS::DidPassCORSAccessCheck() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n double WebMediaPlayerMS::MediaTimeForTimeValue(double timeValue) const {\n   return base::TimeDelta::FromSecondsD(timeValue).InSecondsF();\n }""}<_**next**_>{""sha"": ""8c3595505cb20fa379b861f49b28710c40f3a5f1"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -163,9 +163,7 @@ class CONTENT_EXPORT WebMediaPlayerMS\n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n \n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n ""}<_**next**_>{""sha"": ""d26bc8142d80dc7c64958a9c22170244d6e664dd"", ""filename"": ""content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -76,9 +76,7 @@ class MockWebMediaPlayer : public blink::WebMediaPlayer,\n   }\n \n   bool DidLoadingProgress() override { return true; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double timeValue) const override { return 0.0; }\n   unsigned DecodedFrameCount() const override { return 0; }\n   unsigned DroppedFrameCount() const override { return 0; }""}<_**next**_>{""sha"": ""74ad44546ee34afa79b4a1649710117f8532c5f4"", ""filename"": ""media/blink/multibuffer_data_source.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 19, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -286,23 +286,8 @@ bool MultibufferDataSource::HasSingleOrigin() {\n   return single_origin_;\n }\n \n-bool MultibufferDataSource::DidPassCORSAccessCheck() const {\n-  if (url_data()->cors_mode() == UrlData::CORS_UNSPECIFIED)\n-    return false;\n-\n-  // If init_cb is set, we know initialization is not finished yet.\n-  if (init_cb_)\n-    return false;\n-  if (failed_)\n-    return false;\n-  return true;\n-}\n-\n-bool MultibufferDataSource::DidGetOpaqueResponseViaServiceWorker() const {\n-  return url_data()->has_opaque_data();\n-\n-  // TODO(falken): Do we need to do something about |init_cb_| like\n-  // in DidPassCORSAccessCheck()?\n+bool MultibufferDataSource::IsCorsCrossOrigin() const {\n+  return url_data()->is_cors_cross_origin();\n }\n \n void MultibufferDataSource::MediaPlaybackRateChanged(double playback_rate) {\n@@ -627,8 +612,6 @@ void MultibufferDataSource::StartCallback() {\n     // Progress callback might be called after the start callback,\n     // make sure that we update single_origin_ now.\n     media_log_->SetBooleanProperty(\""single_origin\"", single_origin_);\n-    media_log_->SetBooleanProperty(\""passed_cors_access_check\"",\n-                                   DidPassCORSAccessCheck());\n     media_log_->SetBooleanProperty(\""range_header_supported\"",\n                                    url_data()->range_supported());\n   }""}<_**next**_>{""sha"": ""4da62a5519e33ab6e726406f0acac4995c4ad49f"", ""filename"": ""media/blink/multibuffer_data_source.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 6, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -79,12 +79,9 @@ class MEDIA_BLINK_EXPORT MultibufferDataSource : public DataSource {\n   // Method called on the render thread.\n   bool HasSingleOrigin();\n \n-  // Returns true if the media resource passed a CORS access control check.\n-  bool DidPassCORSAccessCheck() const;\n-\n-  // Returns true if a service worker provided the media resource response,\n-  // and the response was opaque.\n-  bool DidGetOpaqueResponseViaServiceWorker() const;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  // This must be called after the response arrives.\n+  bool IsCorsCrossOrigin() const;\n \n   // Notifies changes in playback state for controlling media buffering\n   // behavior.""}<_**next**_>{""sha"": ""4b9f83e74255bf14d33c3f0c2785c282ecb2bcd7"", ""filename"": ""media/blink/multibuffer_data_source_unittest.cc"", ""status"": ""modified"", ""additions"": 81, ""deletions"": 12, ""changes"": 93, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1493,35 +1493,104 @@ TEST_F(MultibufferDataSourceTest, FileSizeLessThanBlockSize) {\n   Stop();\n }\n \n-TEST_F(MultibufferDataSourceTest, DidPassCORSAccessTest) {\n+TEST_F(MultibufferDataSourceTest, ResponseTypeBasic) {\n   InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n   set_preload(MultibufferDataSource::NONE);\n   WebURLResponse response1 =\n       response_generator_->GeneratePartial206(0, kDataSize - 1);\n-  response1.SetWasFetchedViaServiceWorker(true);\n-  std::vector<blink::WebURL> urlList = {GURL(kHttpDifferentOriginUrl)};\n-  response1.SetURLListViaServiceWorker(urlList);\n-  WebURLResponse response2 =\n-      response_generator_->GeneratePartial206(kDataSize, kDataSize * 2 - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kBasic);\n \n   EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n   EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n   EXPECT_CALL(*this, ReadCallback(kDataSize));\n \n-  EXPECT_FALSE(data_source_->DidPassCORSAccessCheck());\n   Respond(response1);\n   ReceiveData(kDataSize);\n   ReadAt(0);\n   EXPECT_TRUE(loading());\n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n   FinishLoading();\n+}\n \n-  // Verify that if reader_ is null, DidPassCORSAccessCheck still returns true.\n-  data_source_->Stop();\n-  base::RunLoop().RunUntilIdle();\n+TEST_F(MultibufferDataSourceTest, ResponseTypeCors) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kCORS);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeDefault) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kDefault);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaque) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaque);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaqueRedirect) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaqueRedirect);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n }\n \n TEST_F(MultibufferDataSourceTest, EtagTest) {""}<_**next**_>{""sha"": ""89f1c9e70d2cc71646df50026b50d54d471d20c6"", ""filename"": ""media/blink/resource_multibuffer_data_provider.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/resource_multibuffer_data_provider.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -280,6 +280,8 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n   int64_t content_length = response.ExpectedContentLength();\n   bool end_of_file = false;\n   bool do_fail = false;\n+  // We get the response type here because aborting the loader may change it.\n+  const auto response_type = response.GetType();\n   bytes_to_discard_ = 0;\n \n   // We make a strong assumption that when we reach here we have either\n@@ -333,10 +335,9 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n         url_data_->url_index()->TryInsert(destination_url_data);\n   }\n \n-  // This is vital for security! A service worker can respond with a response\n-  // from a different origin, so this response type is needed to detect that.\n-  destination_url_data->set_has_opaque_data(\n-      network::cors::IsCORSCrossOriginResponseType(response.GetType()));\n+  // This is vital for security!\n+  destination_url_data->set_is_cors_cross_origin(\n+      network::cors::IsCORSCrossOriginResponseType(response_type));\n \n   if (destination_url_data != url_data_) {\n     // At this point, we've encountered a redirect, or found a better url data""}<_**next**_>{""sha"": ""3fb63497791a3d2a0ea1e3b12c018f4b2c5fe355"", ""filename"": ""media/blink/url_index.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 7, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -65,7 +65,6 @@ UrlData::UrlData(const GURL& url, CORSMode cors_mode, UrlIndex* url_index)\n       length_(kPositionNotSpecified),\n       range_supported_(false),\n       cacheable_(false),\n-      has_opaque_data_(false),\n       last_used_(),\n       multibuffer_(this, url_index_->block_shift_) {}\n \n@@ -103,9 +102,8 @@ void UrlData::MergeFrom(const scoped_refptr<UrlData>& other) {\n       last_modified_ = other->last_modified_;\n     }\n     bytes_read_from_cache_ += other->bytes_read_from_cache_;\n-    // set_has_opaque_data() will not relax from opaque to non-opaque if already\n-    // opaque.\n-    set_has_opaque_data(other->has_opaque_data_);\n+    // is_cors_corss_origin_ will not relax from true to false.\n+    set_is_cors_cross_origin(other->is_cors_cross_origin_);\n     multibuffer()->MergeFrom(other->multibuffer());\n   }\n }\n@@ -122,10 +120,10 @@ void UrlData::set_length(int64_t length) {\n   }\n }\n \n-void UrlData::set_has_opaque_data(bool has_opaque_data) {\n-  if (has_opaque_data_)\n+void UrlData::set_is_cors_cross_origin(bool is_cors_cross_origin) {\n+  if (is_cors_cross_origin_)\n     return;\n-  has_opaque_data_ = has_opaque_data;\n+  is_cors_cross_origin_ = is_cors_cross_origin;\n }\n \n void UrlData::RedirectTo(const scoped_refptr<UrlData>& url_data) {""}<_**next**_>{""sha"": ""2c15bc7ac0ad4489a0c922f614889e575bd5d863"", ""filename"": ""media/blink/url_index.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -125,7 +125,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // Returns our url_index.\n   UrlIndex* url_index() const { return url_index_; }\n \n-  bool has_opaque_data() const { return has_opaque_data_; }\n+  // This must be called after the response arrives.\n+  bool is_cors_cross_origin() const { return is_cors_cross_origin_; }\n \n   // Notifies the url index that this is currently used.\n   // The url <-> URLData mapping will be eventually be invalidated if\n@@ -145,7 +146,7 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   void set_range_supported();\n   void set_last_modified(base::Time last_modified);\n   void set_etag(const std::string& etag);\n-  void set_has_opaque_data(bool has_opaque_data);\n+  void set_is_cors_cross_origin(bool is_cors_cross_origin);\n \n   // A redirect has occured (or we've found a better UrlData for the same\n   // resource).\n@@ -238,9 +239,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // will not cache this url.\n   bool cacheable_;\n \n-  // True if a service worker intercepted a request for this resource\n-  // and provided an opaque response.\n-  bool has_opaque_data_;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  bool is_cors_cross_origin_ = false;\n \n   // Last time some media time used this resource.\n   // Note that we use base::Time rather than base::TimeTicks because""}<_**next**_>{""sha"": ""cf0857d8c6283758b159609f76da1bafb19cc789"", ""filename"": ""media/blink/webmediaplayer_impl.cc"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 10, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1175,12 +1175,6 @@ void WebMediaPlayerImpl::Paint(cc::PaintCanvas* canvas,\n       context_support);\n }\n \n-bool WebMediaPlayerImpl::DidGetOpaqueResponseFromServiceWorker() const {\n-  if (data_source_)\n-    return data_source_->DidGetOpaqueResponseViaServiceWorker();\n-  return false;\n-}\n-\n bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   if (demuxer_found_hls_) {\n     // HLS manifests might pull segments from a different origin. We can't know\n@@ -1193,10 +1187,15 @@ bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   return true;\n }\n \n-bool WebMediaPlayerImpl::DidPassCORSAccessCheck() const {\n-  if (data_source_)\n-    return data_source_->DidPassCORSAccessCheck();\n-  return false;\n+bool WebMediaPlayerImpl::WouldTaintOrigin() const {\n+  if (!HasSingleSecurityOrigin()) {\n+    // When the resource is redirected to another origin we think it as\n+    // tainted. This is actually not specified, and is under discussion.\n+    // See https://github.com/whatwg/fetch/issues/737.\n+    return true;\n+  }\n+\n+  return data_source_ && data_source_->IsCorsCrossOrigin();\n }\n \n double WebMediaPlayerImpl::MediaTimeForTimeValue(double timeValue) const {""}<_**next**_>{""sha"": ""233e37b4614544e9b2a67b4e5edee775de0f79a6"", ""filename"": ""media/blink/webmediaplayer_impl.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -188,10 +188,7 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n \n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n-\n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n \n@@ -332,6 +329,8 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n   void OnPipelineResumed();\n   void OnDemuxerOpened();\n \n+  bool HasSingleSecurityOrigin() const;\n+\n   // Pipeline::Client overrides.\n   void OnError(PipelineStatus status) override;\n   void OnEnded() override;""}<_**next**_>{""sha"": ""9821759bc7b311672a54387edc7d8c26a11d5e54"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""status"": ""added"", ""additions"": 47, ""deletions"": 0, ""changes"": 47, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -0,0 +1,47 @@\n+<!doctype html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+<script src=\""/common/get-host-info.sub.js\""></script>\n+<script src=\""resources/test-helpers.sub.js?pipe=sub\""></script>\n+<script>\n+promise_test(async (t) => {\n+    const SCOPE = 'resources/empty.html';\n+    const SCRIPT = 'resources/fetch-rewrite-worker.js';\n+    const host_info = get_host_info();\n+    const REMOTE_ORIGIN = host_info.HTTPS_REMOTE_ORIGIN;\n+\n+    const reg = await service_worker_unregister_and_register(t, SCRIPT, SCOPE);\n+    await wait_for_state(t, reg.installing, 'activated');\n+    const frame = await with_iframe(SCOPE);\n+\n+    const doc = frame.contentDocument;\n+    const win = frame.contentWindow;\n+\n+    const context = new win.AudioContext();\n+    try {\n+      context.suspend();\n+      const audio = doc.createElement('audio');\n+      audio.autoplay = true;\n+      const source = context.createMediaElementSource(audio);\n+      const spn = context.createScriptProcessor(16384, 1, 1);\n+      source.connect(spn).connect(context.destination);\n+      const url = `${REMOTE_ORIGIN}/webaudio/resources/sin_440Hz_-6dBFS_1s.wav`;\n+      audio.src = '/test?url=' + encodeURIComponent(url);\n+      doc.body.appendChild(audio);\n+\n+      await new Promise((resolve) => {\n+        audio.addEventListener('playing', resolve);\n+      });\n+      await context.resume();\n+      const event = await new Promise((resolve) => {\n+        spn.addEventListener('audioprocess', resolve);\n+      });\n+      const data = event.inputBuffer.getChannelData(0);\n+      for (const e of data) {\n+        assert_equals(e, 0);\n+      }\n+    } finally {\n+      context.close();\n+    }\n+  }, 'Verify CORS XHR of fetch() in a Service Worker');\n+</script>""}<_**next**_>{""sha"": ""319648dbc16669ab3b3238d8488997b7d3a7c837"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""58697c0661a94d03e4bbe74134a23e71a860f5f6"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""a1e82caf7e2f9d37d785165a4766f42acb28c465"", ""filename"": ""third_party/blink/public/platform/web_media_player.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/public/platform/web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -207,9 +207,10 @@ class WebMediaPlayer {\n \n   virtual bool DidLoadingProgress() = 0;\n \n-  virtual bool DidGetOpaqueResponseFromServiceWorker() const = 0;\n-  virtual bool HasSingleSecurityOrigin() const = 0;\n-  virtual bool DidPassCORSAccessCheck() const = 0;\n+  // Returns true if the response is CORS-cross-origin and so we shouldn't be\n+  // allowing media to play through webaudio.\n+  // This should be called after the response has arrived.\n+  virtual bool WouldTaintOrigin() const = 0;\n \n   virtual double MediaTimeForTimeValue(double time_value) const = 0;\n ""}<_**next**_>{""sha"": ""ad708c861bb80cd8a01217eec51f9fe058af4a33"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 21, ""changes"": 26, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1506,30 +1506,14 @@ bool HTMLMediaElement::IsSafeToLoadURL(const KURL& url,\n \n bool HTMLMediaElement::IsMediaDataCORSSameOrigin(\n     const SecurityOrigin* origin) const {\n-  // If a service worker handled the request, we don't know if the origin in the\n-  // src is the same as the actual response URL so can't rely on URL checks\n-  // alone. So detect an opaque response via\n-  // DidGetOpaqueResponseFromServiceWorker().\n-  if (GetWebMediaPlayer() &&\n-      GetWebMediaPlayer()->DidGetOpaqueResponseFromServiceWorker()) {\n-    return false;\n-  }\n-\n-  // At this point, either a service worker was not used, or it didn't provide\n-  // an opaque response, so continue with the normal checks.\n+  if (!GetWebMediaPlayer())\n+    return true;\n \n-  // HasSingleSecurityOrigin() tells us whether the origin in the src\n-  // is the same as the actual request (i.e. after redirects).\n-  if (!HasSingleSecurityOrigin())\n+  const auto network_state = GetWebMediaPlayer()->GetNetworkState();\n+  if (network_state == WebMediaPlayer::kNetworkStateNetworkError)\n     return false;\n \n-  // DidPassCORSAccessCheck() means it was a successful CORS-enabled fetch (vs.\n-  // non-CORS-enabled or failed). CanReadContent() does CheckAccess() on the\n-  // URL plus allows data sources, to ensure that it is not a URL that requires\n-  // CORS (basically same origin).\n-  return (GetWebMediaPlayer() &&\n-          GetWebMediaPlayer()->DidPassCORSAccessCheck()) ||\n-         origin->CanReadContent(currentSrc());\n+  return !GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n bool HTMLMediaElement::IsInCrossOriginFrame() const {""}<_**next**_>{""sha"": ""f2d50264a53a0a3002725b06b6363091f4e17faa"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -268,11 +268,6 @@ class CORE_EXPORT HTMLMediaElement\n   // of one of them here.\n   using HTMLElement::GetExecutionContext;\n \n-  bool HasSingleSecurityOrigin() const {\n-    return GetWebMediaPlayer() ? GetWebMediaPlayer()->HasSingleSecurityOrigin()\n-                               : true;\n-  }\n-\n   bool IsFullscreen() const;\n   virtual bool UsesOverlayFullscreenVideo() const { return false; }\n ""}<_**next**_>{""sha"": ""8cf3a926979a853d0ba0f48f9def6bc9b4aec36a"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 17, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -958,21 +958,4 @@ void BaseAudioContext::UpdateWorkletGlobalScopeOnRenderingThread() {\n   }\n }\n \n-bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {\n-  // Data URLs don't taint the origin.\n-  if (url.ProtocolIsData()) {\n-    return false;\n-  }\n-\n-  Document* document = GetDocument();\n-  if (document && document->GetSecurityOrigin()) {\n-    // The origin is tainted if and only if we cannot read content from the URL.\n-    return !document->GetSecurityOrigin()->CanRequest(url);\n-  }\n-\n-  // Be conservative and assume it's tainted if it's not a data url and if we\n-  // can't get the security origin of the document.\n-  return true;\n-}\n-\n }  // namespace blink""}<_**next**_>{""sha"": ""ae933f20167fb374b51ff5a869d9381f97b56d4b"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -296,13 +296,6 @@ class MODULES_EXPORT BaseAudioContext\n   // Does nothing when the worklet global scope does not exist.\n   void UpdateWorkletGlobalScopeOnRenderingThread();\n \n-  // Returns true if the URL would taint the origin so that we shouldn't be\n-  // allowing media to played through webaudio.\n-  // TODO(crbug.com/845913): This should really be on an AudioContext.  Move\n-  // this when we move the media stuff from BaseAudioContext to AudioContext, as\n-  // requried by the spec.\n-  bool WouldTaintOrigin(const KURL& url) const;\n-\n  protected:\n   enum ContextType { kRealtimeContext, kOfflineContext };\n ""}<_**next**_>{""sha"": ""d7b07b5fea75809b4e14c8fda74b38a1d48e6b9d"", ""filename"": ""third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 13, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -136,19 +136,7 @@ void MediaElementAudioSourceHandler::SetFormat(size_t number_of_channels,\n }\n \n bool MediaElementAudioSourceHandler::WouldTaintOrigin() {\n-  // If we're cross-origin and allowed access vie CORS, we're not tainted.\n-  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {\n-    return false;\n-  }\n-\n-  // Handles the case where the url is a redirect to another site that we're not\n-  // allowed to access.\n-  if (!MediaElement()->HasSingleSecurityOrigin()) {\n-    return true;\n-  }\n-\n-  // Test to see if the current media URL taint the origin of the audio context?\n-  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());\n+  return MediaElement()->GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n void MediaElementAudioSourceHandler::PrintCORSMessage(const String& message) {""}<_**next**_>{""sha"": ""6e5771836bf84527d922a6c5fc84a3aa5c8c9bce"", ""filename"": ""third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/testing/empty_web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -50,9 +50,7 @@ class EmptyWebMediaPlayer : public WebMediaPlayer {\n   ReadyState GetReadyState() const override { return kReadyStateHaveNothing; }\n   WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override { return false; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double time_value) const override {\n     return time_value;\n   };""}","bool WebMediaPlayerImpl::DidGetOpaqueResponseFromServiceWorker() const {
","bool WebMediaPlayerImpl::DidGetOpaqueResponseFromServiceWorker() const {
  if (data_source_)
    return data_source_->DidGetOpaqueResponseViaServiceWorker();
  return false;
}
",C,,"  if (data_source_)
    return data_source_->DidGetOpaqueResponseViaServiceWorker();
  return false;
}
",,"@@ -1175,12 +1175,6 @@ void WebMediaPlayerImpl::Paint(cc::PaintCanvas* canvas,
       context_support);
 }
 
-bool WebMediaPlayerImpl::DidGetOpaqueResponseFromServiceWorker() const {
-  if (data_source_)
-    return data_source_->DidGetOpaqueResponseViaServiceWorker();
-  return false;
-}
-
 bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {
   if (demuxer_found_hls_) {
     // HLS manifests might pull segments from a different origin. We can't know
@@ -1193,10 +1187,15 @@ bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {
   return true;
 }
 
-bool WebMediaPlayerImpl::DidPassCORSAccessCheck() const {
-  if (data_source_)
-    return data_source_->DidPassCORSAccessCheck();
-  return false;
+bool WebMediaPlayerImpl::WouldTaintOrigin() const {
+  if (!HasSingleSecurityOrigin()) {
+    // When the resource is redirected to another origin we think it as
+    // tainted. This is actually not specified, and is under discussion.
+    // See https://github.com/whatwg/fetch/issues/737.
+    return true;
+  }
+
+  return data_source_ && data_source_->IsCorsCrossOrigin();
 }
 
 double WebMediaPlayerImpl::MediaTimeForTimeValue(double timeValue) const {",Chrome,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,50436d878b2e92de4231fda47328a8a4e884ecc3,1,"bool WebMediaPlayerImpl::DidGetOpaqueResponseFromServiceWorker() const {
//flaw_line_below:
  if (data_source_)
//flaw_line_below:
    return data_source_->DidGetOpaqueResponseViaServiceWorker();
//flaw_line_below:
  return false;
//flaw_line_below:
}
"
8872,186608,,Remote,Not required,,CVE-2018-18352,https://www.cvedetails.com/cve/CVE-2018-18352/,CWE-732,Medium,Partial,,,2018-12-11,4.3,Service works could inappropriately gain access to cross origin audio in Media in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to bypass same origin policy for audio content via a crafted HTML page.,2019-10-02,Bypass ,9,https://github.com/chromium/chromium/commit/a9cbaa7a40e2b2723cfc2f266c42f4980038a949,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,"Simplify ""WouldTaintOrigin"" concept in media/blink

Currently WebMediaPlayer has three predicates:
 - DidGetOpaqueResponseFromServiceWorker
 - HasSingleSecurityOrigin
 - DidPassCORSAccessCheck
. These are used to determine whether the response body is available
for scripts. They are known to be confusing, and actually
MediaElementAudioSourceHandler::WouldTaintOrigin misuses them.

This CL merges the three predicates to one, WouldTaintOrigin, to remove
the confusion. Now the ""response type"" concept is available and we
don't need a custom CORS check, so this CL removes
BaseAudioContext::WouldTaintOrigin. This CL also renames
URLData::has_opaque_data_ and its (direct and indirect) data accessors
to match the spec.

Bug: 849942, 875153
Change-Id: I6acf50169d7445c4ff614e80ac606f79ee577d2a
Reviewed-on: https://chromium-review.googlesource.com/c/1238098
Reviewed-by: Fredrik Hubinette <hubbe@chromium.org>
Reviewed-by: Kinuko Yasuda <kinuko@chromium.org>
Reviewed-by: Raymond Toy <rtoy@chromium.org>
Commit-Queue: Yutaka Hirano <yhirano@chromium.org>
Cr-Commit-Position: refs/heads/master@{#598258}",3,media/blink/webmediaplayer_impl.cc,"{""sha"": ""78ca5e2c3c323cf55e23eacc262e8a197e60b63b"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 11, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -844,21 +844,11 @@ void WebMediaPlayerMS::Paint(cc::PaintCanvas* canvas,\n                         context_3d, context_support);\n }\n \n-bool WebMediaPlayerMS::DidGetOpaqueResponseFromServiceWorker() const {\n+bool WebMediaPlayerMS::WouldTaintOrigin() const {\n   DCHECK(thread_checker_.CalledOnValidThread());\n   return false;\n }\n \n-bool WebMediaPlayerMS::HasSingleSecurityOrigin() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n-bool WebMediaPlayerMS::DidPassCORSAccessCheck() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n double WebMediaPlayerMS::MediaTimeForTimeValue(double timeValue) const {\n   return base::TimeDelta::FromSecondsD(timeValue).InSecondsF();\n }""}<_**next**_>{""sha"": ""8c3595505cb20fa379b861f49b28710c40f3a5f1"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -163,9 +163,7 @@ class CONTENT_EXPORT WebMediaPlayerMS\n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n \n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n ""}<_**next**_>{""sha"": ""d26bc8142d80dc7c64958a9c22170244d6e664dd"", ""filename"": ""content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -76,9 +76,7 @@ class MockWebMediaPlayer : public blink::WebMediaPlayer,\n   }\n \n   bool DidLoadingProgress() override { return true; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double timeValue) const override { return 0.0; }\n   unsigned DecodedFrameCount() const override { return 0; }\n   unsigned DroppedFrameCount() const override { return 0; }""}<_**next**_>{""sha"": ""74ad44546ee34afa79b4a1649710117f8532c5f4"", ""filename"": ""media/blink/multibuffer_data_source.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 19, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -286,23 +286,8 @@ bool MultibufferDataSource::HasSingleOrigin() {\n   return single_origin_;\n }\n \n-bool MultibufferDataSource::DidPassCORSAccessCheck() const {\n-  if (url_data()->cors_mode() == UrlData::CORS_UNSPECIFIED)\n-    return false;\n-\n-  // If init_cb is set, we know initialization is not finished yet.\n-  if (init_cb_)\n-    return false;\n-  if (failed_)\n-    return false;\n-  return true;\n-}\n-\n-bool MultibufferDataSource::DidGetOpaqueResponseViaServiceWorker() const {\n-  return url_data()->has_opaque_data();\n-\n-  // TODO(falken): Do we need to do something about |init_cb_| like\n-  // in DidPassCORSAccessCheck()?\n+bool MultibufferDataSource::IsCorsCrossOrigin() const {\n+  return url_data()->is_cors_cross_origin();\n }\n \n void MultibufferDataSource::MediaPlaybackRateChanged(double playback_rate) {\n@@ -627,8 +612,6 @@ void MultibufferDataSource::StartCallback() {\n     // Progress callback might be called after the start callback,\n     // make sure that we update single_origin_ now.\n     media_log_->SetBooleanProperty(\""single_origin\"", single_origin_);\n-    media_log_->SetBooleanProperty(\""passed_cors_access_check\"",\n-                                   DidPassCORSAccessCheck());\n     media_log_->SetBooleanProperty(\""range_header_supported\"",\n                                    url_data()->range_supported());\n   }""}<_**next**_>{""sha"": ""4da62a5519e33ab6e726406f0acac4995c4ad49f"", ""filename"": ""media/blink/multibuffer_data_source.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 6, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -79,12 +79,9 @@ class MEDIA_BLINK_EXPORT MultibufferDataSource : public DataSource {\n   // Method called on the render thread.\n   bool HasSingleOrigin();\n \n-  // Returns true if the media resource passed a CORS access control check.\n-  bool DidPassCORSAccessCheck() const;\n-\n-  // Returns true if a service worker provided the media resource response,\n-  // and the response was opaque.\n-  bool DidGetOpaqueResponseViaServiceWorker() const;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  // This must be called after the response arrives.\n+  bool IsCorsCrossOrigin() const;\n \n   // Notifies changes in playback state for controlling media buffering\n   // behavior.""}<_**next**_>{""sha"": ""4b9f83e74255bf14d33c3f0c2785c282ecb2bcd7"", ""filename"": ""media/blink/multibuffer_data_source_unittest.cc"", ""status"": ""modified"", ""additions"": 81, ""deletions"": 12, ""changes"": 93, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1493,35 +1493,104 @@ TEST_F(MultibufferDataSourceTest, FileSizeLessThanBlockSize) {\n   Stop();\n }\n \n-TEST_F(MultibufferDataSourceTest, DidPassCORSAccessTest) {\n+TEST_F(MultibufferDataSourceTest, ResponseTypeBasic) {\n   InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n   set_preload(MultibufferDataSource::NONE);\n   WebURLResponse response1 =\n       response_generator_->GeneratePartial206(0, kDataSize - 1);\n-  response1.SetWasFetchedViaServiceWorker(true);\n-  std::vector<blink::WebURL> urlList = {GURL(kHttpDifferentOriginUrl)};\n-  response1.SetURLListViaServiceWorker(urlList);\n-  WebURLResponse response2 =\n-      response_generator_->GeneratePartial206(kDataSize, kDataSize * 2 - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kBasic);\n \n   EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n   EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n   EXPECT_CALL(*this, ReadCallback(kDataSize));\n \n-  EXPECT_FALSE(data_source_->DidPassCORSAccessCheck());\n   Respond(response1);\n   ReceiveData(kDataSize);\n   ReadAt(0);\n   EXPECT_TRUE(loading());\n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n   FinishLoading();\n+}\n \n-  // Verify that if reader_ is null, DidPassCORSAccessCheck still returns true.\n-  data_source_->Stop();\n-  base::RunLoop().RunUntilIdle();\n+TEST_F(MultibufferDataSourceTest, ResponseTypeCors) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kCORS);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeDefault) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kDefault);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaque) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaque);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaqueRedirect) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaqueRedirect);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n }\n \n TEST_F(MultibufferDataSourceTest, EtagTest) {""}<_**next**_>{""sha"": ""89f1c9e70d2cc71646df50026b50d54d471d20c6"", ""filename"": ""media/blink/resource_multibuffer_data_provider.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/resource_multibuffer_data_provider.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -280,6 +280,8 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n   int64_t content_length = response.ExpectedContentLength();\n   bool end_of_file = false;\n   bool do_fail = false;\n+  // We get the response type here because aborting the loader may change it.\n+  const auto response_type = response.GetType();\n   bytes_to_discard_ = 0;\n \n   // We make a strong assumption that when we reach here we have either\n@@ -333,10 +335,9 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n         url_data_->url_index()->TryInsert(destination_url_data);\n   }\n \n-  // This is vital for security! A service worker can respond with a response\n-  // from a different origin, so this response type is needed to detect that.\n-  destination_url_data->set_has_opaque_data(\n-      network::cors::IsCORSCrossOriginResponseType(response.GetType()));\n+  // This is vital for security!\n+  destination_url_data->set_is_cors_cross_origin(\n+      network::cors::IsCORSCrossOriginResponseType(response_type));\n \n   if (destination_url_data != url_data_) {\n     // At this point, we've encountered a redirect, or found a better url data""}<_**next**_>{""sha"": ""3fb63497791a3d2a0ea1e3b12c018f4b2c5fe355"", ""filename"": ""media/blink/url_index.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 7, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -65,7 +65,6 @@ UrlData::UrlData(const GURL& url, CORSMode cors_mode, UrlIndex* url_index)\n       length_(kPositionNotSpecified),\n       range_supported_(false),\n       cacheable_(false),\n-      has_opaque_data_(false),\n       last_used_(),\n       multibuffer_(this, url_index_->block_shift_) {}\n \n@@ -103,9 +102,8 @@ void UrlData::MergeFrom(const scoped_refptr<UrlData>& other) {\n       last_modified_ = other->last_modified_;\n     }\n     bytes_read_from_cache_ += other->bytes_read_from_cache_;\n-    // set_has_opaque_data() will not relax from opaque to non-opaque if already\n-    // opaque.\n-    set_has_opaque_data(other->has_opaque_data_);\n+    // is_cors_corss_origin_ will not relax from true to false.\n+    set_is_cors_cross_origin(other->is_cors_cross_origin_);\n     multibuffer()->MergeFrom(other->multibuffer());\n   }\n }\n@@ -122,10 +120,10 @@ void UrlData::set_length(int64_t length) {\n   }\n }\n \n-void UrlData::set_has_opaque_data(bool has_opaque_data) {\n-  if (has_opaque_data_)\n+void UrlData::set_is_cors_cross_origin(bool is_cors_cross_origin) {\n+  if (is_cors_cross_origin_)\n     return;\n-  has_opaque_data_ = has_opaque_data;\n+  is_cors_cross_origin_ = is_cors_cross_origin;\n }\n \n void UrlData::RedirectTo(const scoped_refptr<UrlData>& url_data) {""}<_**next**_>{""sha"": ""2c15bc7ac0ad4489a0c922f614889e575bd5d863"", ""filename"": ""media/blink/url_index.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -125,7 +125,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // Returns our url_index.\n   UrlIndex* url_index() const { return url_index_; }\n \n-  bool has_opaque_data() const { return has_opaque_data_; }\n+  // This must be called after the response arrives.\n+  bool is_cors_cross_origin() const { return is_cors_cross_origin_; }\n \n   // Notifies the url index that this is currently used.\n   // The url <-> URLData mapping will be eventually be invalidated if\n@@ -145,7 +146,7 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   void set_range_supported();\n   void set_last_modified(base::Time last_modified);\n   void set_etag(const std::string& etag);\n-  void set_has_opaque_data(bool has_opaque_data);\n+  void set_is_cors_cross_origin(bool is_cors_cross_origin);\n \n   // A redirect has occured (or we've found a better UrlData for the same\n   // resource).\n@@ -238,9 +239,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // will not cache this url.\n   bool cacheable_;\n \n-  // True if a service worker intercepted a request for this resource\n-  // and provided an opaque response.\n-  bool has_opaque_data_;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  bool is_cors_cross_origin_ = false;\n \n   // Last time some media time used this resource.\n   // Note that we use base::Time rather than base::TimeTicks because""}<_**next**_>{""sha"": ""cf0857d8c6283758b159609f76da1bafb19cc789"", ""filename"": ""media/blink/webmediaplayer_impl.cc"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 10, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1175,12 +1175,6 @@ void WebMediaPlayerImpl::Paint(cc::PaintCanvas* canvas,\n       context_support);\n }\n \n-bool WebMediaPlayerImpl::DidGetOpaqueResponseFromServiceWorker() const {\n-  if (data_source_)\n-    return data_source_->DidGetOpaqueResponseViaServiceWorker();\n-  return false;\n-}\n-\n bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   if (demuxer_found_hls_) {\n     // HLS manifests might pull segments from a different origin. We can't know\n@@ -1193,10 +1187,15 @@ bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   return true;\n }\n \n-bool WebMediaPlayerImpl::DidPassCORSAccessCheck() const {\n-  if (data_source_)\n-    return data_source_->DidPassCORSAccessCheck();\n-  return false;\n+bool WebMediaPlayerImpl::WouldTaintOrigin() const {\n+  if (!HasSingleSecurityOrigin()) {\n+    // When the resource is redirected to another origin we think it as\n+    // tainted. This is actually not specified, and is under discussion.\n+    // See https://github.com/whatwg/fetch/issues/737.\n+    return true;\n+  }\n+\n+  return data_source_ && data_source_->IsCorsCrossOrigin();\n }\n \n double WebMediaPlayerImpl::MediaTimeForTimeValue(double timeValue) const {""}<_**next**_>{""sha"": ""233e37b4614544e9b2a67b4e5edee775de0f79a6"", ""filename"": ""media/blink/webmediaplayer_impl.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -188,10 +188,7 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n \n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n-\n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n \n@@ -332,6 +329,8 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n   void OnPipelineResumed();\n   void OnDemuxerOpened();\n \n+  bool HasSingleSecurityOrigin() const;\n+\n   // Pipeline::Client overrides.\n   void OnError(PipelineStatus status) override;\n   void OnEnded() override;""}<_**next**_>{""sha"": ""9821759bc7b311672a54387edc7d8c26a11d5e54"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""status"": ""added"", ""additions"": 47, ""deletions"": 0, ""changes"": 47, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -0,0 +1,47 @@\n+<!doctype html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+<script src=\""/common/get-host-info.sub.js\""></script>\n+<script src=\""resources/test-helpers.sub.js?pipe=sub\""></script>\n+<script>\n+promise_test(async (t) => {\n+    const SCOPE = 'resources/empty.html';\n+    const SCRIPT = 'resources/fetch-rewrite-worker.js';\n+    const host_info = get_host_info();\n+    const REMOTE_ORIGIN = host_info.HTTPS_REMOTE_ORIGIN;\n+\n+    const reg = await service_worker_unregister_and_register(t, SCRIPT, SCOPE);\n+    await wait_for_state(t, reg.installing, 'activated');\n+    const frame = await with_iframe(SCOPE);\n+\n+    const doc = frame.contentDocument;\n+    const win = frame.contentWindow;\n+\n+    const context = new win.AudioContext();\n+    try {\n+      context.suspend();\n+      const audio = doc.createElement('audio');\n+      audio.autoplay = true;\n+      const source = context.createMediaElementSource(audio);\n+      const spn = context.createScriptProcessor(16384, 1, 1);\n+      source.connect(spn).connect(context.destination);\n+      const url = `${REMOTE_ORIGIN}/webaudio/resources/sin_440Hz_-6dBFS_1s.wav`;\n+      audio.src = '/test?url=' + encodeURIComponent(url);\n+      doc.body.appendChild(audio);\n+\n+      await new Promise((resolve) => {\n+        audio.addEventListener('playing', resolve);\n+      });\n+      await context.resume();\n+      const event = await new Promise((resolve) => {\n+        spn.addEventListener('audioprocess', resolve);\n+      });\n+      const data = event.inputBuffer.getChannelData(0);\n+      for (const e of data) {\n+        assert_equals(e, 0);\n+      }\n+    } finally {\n+      context.close();\n+    }\n+  }, 'Verify CORS XHR of fetch() in a Service Worker');\n+</script>""}<_**next**_>{""sha"": ""319648dbc16669ab3b3238d8488997b7d3a7c837"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""58697c0661a94d03e4bbe74134a23e71a860f5f6"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""a1e82caf7e2f9d37d785165a4766f42acb28c465"", ""filename"": ""third_party/blink/public/platform/web_media_player.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/public/platform/web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -207,9 +207,10 @@ class WebMediaPlayer {\n \n   virtual bool DidLoadingProgress() = 0;\n \n-  virtual bool DidGetOpaqueResponseFromServiceWorker() const = 0;\n-  virtual bool HasSingleSecurityOrigin() const = 0;\n-  virtual bool DidPassCORSAccessCheck() const = 0;\n+  // Returns true if the response is CORS-cross-origin and so we shouldn't be\n+  // allowing media to play through webaudio.\n+  // This should be called after the response has arrived.\n+  virtual bool WouldTaintOrigin() const = 0;\n \n   virtual double MediaTimeForTimeValue(double time_value) const = 0;\n ""}<_**next**_>{""sha"": ""ad708c861bb80cd8a01217eec51f9fe058af4a33"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 21, ""changes"": 26, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1506,30 +1506,14 @@ bool HTMLMediaElement::IsSafeToLoadURL(const KURL& url,\n \n bool HTMLMediaElement::IsMediaDataCORSSameOrigin(\n     const SecurityOrigin* origin) const {\n-  // If a service worker handled the request, we don't know if the origin in the\n-  // src is the same as the actual response URL so can't rely on URL checks\n-  // alone. So detect an opaque response via\n-  // DidGetOpaqueResponseFromServiceWorker().\n-  if (GetWebMediaPlayer() &&\n-      GetWebMediaPlayer()->DidGetOpaqueResponseFromServiceWorker()) {\n-    return false;\n-  }\n-\n-  // At this point, either a service worker was not used, or it didn't provide\n-  // an opaque response, so continue with the normal checks.\n+  if (!GetWebMediaPlayer())\n+    return true;\n \n-  // HasSingleSecurityOrigin() tells us whether the origin in the src\n-  // is the same as the actual request (i.e. after redirects).\n-  if (!HasSingleSecurityOrigin())\n+  const auto network_state = GetWebMediaPlayer()->GetNetworkState();\n+  if (network_state == WebMediaPlayer::kNetworkStateNetworkError)\n     return false;\n \n-  // DidPassCORSAccessCheck() means it was a successful CORS-enabled fetch (vs.\n-  // non-CORS-enabled or failed). CanReadContent() does CheckAccess() on the\n-  // URL plus allows data sources, to ensure that it is not a URL that requires\n-  // CORS (basically same origin).\n-  return (GetWebMediaPlayer() &&\n-          GetWebMediaPlayer()->DidPassCORSAccessCheck()) ||\n-         origin->CanReadContent(currentSrc());\n+  return !GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n bool HTMLMediaElement::IsInCrossOriginFrame() const {""}<_**next**_>{""sha"": ""f2d50264a53a0a3002725b06b6363091f4e17faa"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -268,11 +268,6 @@ class CORE_EXPORT HTMLMediaElement\n   // of one of them here.\n   using HTMLElement::GetExecutionContext;\n \n-  bool HasSingleSecurityOrigin() const {\n-    return GetWebMediaPlayer() ? GetWebMediaPlayer()->HasSingleSecurityOrigin()\n-                               : true;\n-  }\n-\n   bool IsFullscreen() const;\n   virtual bool UsesOverlayFullscreenVideo() const { return false; }\n ""}<_**next**_>{""sha"": ""8cf3a926979a853d0ba0f48f9def6bc9b4aec36a"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 17, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -958,21 +958,4 @@ void BaseAudioContext::UpdateWorkletGlobalScopeOnRenderingThread() {\n   }\n }\n \n-bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {\n-  // Data URLs don't taint the origin.\n-  if (url.ProtocolIsData()) {\n-    return false;\n-  }\n-\n-  Document* document = GetDocument();\n-  if (document && document->GetSecurityOrigin()) {\n-    // The origin is tainted if and only if we cannot read content from the URL.\n-    return !document->GetSecurityOrigin()->CanRequest(url);\n-  }\n-\n-  // Be conservative and assume it's tainted if it's not a data url and if we\n-  // can't get the security origin of the document.\n-  return true;\n-}\n-\n }  // namespace blink""}<_**next**_>{""sha"": ""ae933f20167fb374b51ff5a869d9381f97b56d4b"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -296,13 +296,6 @@ class MODULES_EXPORT BaseAudioContext\n   // Does nothing when the worklet global scope does not exist.\n   void UpdateWorkletGlobalScopeOnRenderingThread();\n \n-  // Returns true if the URL would taint the origin so that we shouldn't be\n-  // allowing media to played through webaudio.\n-  // TODO(crbug.com/845913): This should really be on an AudioContext.  Move\n-  // this when we move the media stuff from BaseAudioContext to AudioContext, as\n-  // requried by the spec.\n-  bool WouldTaintOrigin(const KURL& url) const;\n-\n  protected:\n   enum ContextType { kRealtimeContext, kOfflineContext };\n ""}<_**next**_>{""sha"": ""d7b07b5fea75809b4e14c8fda74b38a1d48e6b9d"", ""filename"": ""third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 13, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -136,19 +136,7 @@ void MediaElementAudioSourceHandler::SetFormat(size_t number_of_channels,\n }\n \n bool MediaElementAudioSourceHandler::WouldTaintOrigin() {\n-  // If we're cross-origin and allowed access vie CORS, we're not tainted.\n-  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {\n-    return false;\n-  }\n-\n-  // Handles the case where the url is a redirect to another site that we're not\n-  // allowed to access.\n-  if (!MediaElement()->HasSingleSecurityOrigin()) {\n-    return true;\n-  }\n-\n-  // Test to see if the current media URL taint the origin of the audio context?\n-  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());\n+  return MediaElement()->GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n void MediaElementAudioSourceHandler::PrintCORSMessage(const String& message) {""}<_**next**_>{""sha"": ""6e5771836bf84527d922a6c5fc84a3aa5c8c9bce"", ""filename"": ""third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/testing/empty_web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -50,9 +50,7 @@ class EmptyWebMediaPlayer : public WebMediaPlayer {\n   ReadyState GetReadyState() const override { return kReadyStateHaveNothing; }\n   WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override { return false; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double time_value) const override {\n     return time_value;\n   };""}","bool WebMediaPlayerImpl::DidPassCORSAccessCheck() const {
bool WebMediaPlayerImpl::WouldTaintOrigin() const {
  if (!HasSingleSecurityOrigin()) {
    // When the resource is redirected to another origin we think it as
    // tainted. This is actually not specified, and is under discussion.
    // See https://github.com/whatwg/fetch/issues/737.
    return true;
  }

  return data_source_ && data_source_->IsCorsCrossOrigin();
 }
","bool WebMediaPlayerImpl::DidPassCORSAccessCheck() const {
  if (data_source_)
    return data_source_->DidPassCORSAccessCheck();
  return false;
 }
",C,"bool WebMediaPlayerImpl::WouldTaintOrigin() const {
  if (!HasSingleSecurityOrigin()) {
    // When the resource is redirected to another origin we think it as
    // tainted. This is actually not specified, and is under discussion.
    // See https://github.com/whatwg/fetch/issues/737.
    return true;
  }

  return data_source_ && data_source_->IsCorsCrossOrigin();
","  if (data_source_)
    return data_source_->DidPassCORSAccessCheck();
  return false;
",,"@@ -1175,12 +1175,6 @@ void WebMediaPlayerImpl::Paint(cc::PaintCanvas* canvas,
       context_support);
 }
 
-bool WebMediaPlayerImpl::DidGetOpaqueResponseFromServiceWorker() const {
-  if (data_source_)
-    return data_source_->DidGetOpaqueResponseViaServiceWorker();
-  return false;
-}
-
 bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {
   if (demuxer_found_hls_) {
     // HLS manifests might pull segments from a different origin. We can't know
@@ -1193,10 +1187,15 @@ bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {
   return true;
 }
 
-bool WebMediaPlayerImpl::DidPassCORSAccessCheck() const {
-  if (data_source_)
-    return data_source_->DidPassCORSAccessCheck();
-  return false;
+bool WebMediaPlayerImpl::WouldTaintOrigin() const {
+  if (!HasSingleSecurityOrigin()) {
+    // When the resource is redirected to another origin we think it as
+    // tainted. This is actually not specified, and is under discussion.
+    // See https://github.com/whatwg/fetch/issues/737.
+    return true;
+  }
+
+  return data_source_ && data_source_->IsCorsCrossOrigin();
 }
 
 double WebMediaPlayerImpl::MediaTimeForTimeValue(double timeValue) const {",Chrome,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,50436d878b2e92de4231fda47328a8a4e884ecc3,1,"bool WebMediaPlayerImpl::DidPassCORSAccessCheck() const {
//flaw_line_below:
  if (data_source_)
//flaw_line_below:
    return data_source_->DidPassCORSAccessCheck();
//flaw_line_below:
  return false;
//fix_flaw_line_below:
//bool WebMediaPlayerImpl::WouldTaintOrigin() const {
//fix_flaw_line_below:
//  if (!HasSingleSecurityOrigin()) {
//fix_flaw_line_below:
//    // When the resource is redirected to another origin we think it as
//fix_flaw_line_below:
//    // tainted. This is actually not specified, and is under discussion.
//fix_flaw_line_below:
//    // See https://github.com/whatwg/fetch/issues/737.
//fix_flaw_line_below:
//    return true;
//fix_flaw_line_below:
//  }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  return data_source_ && data_source_->IsCorsCrossOrigin();
 }
"
8873,186609,,Remote,Not required,,CVE-2018-18352,https://www.cvedetails.com/cve/CVE-2018-18352/,CWE-732,Medium,Partial,,,2018-12-11,4.3,Service works could inappropriately gain access to cross origin audio in Media in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to bypass same origin policy for audio content via a crafted HTML page.,2019-10-02,Bypass ,5,https://github.com/chromium/chromium/commit/a9cbaa7a40e2b2723cfc2f266c42f4980038a949,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,"Simplify ""WouldTaintOrigin"" concept in media/blink

Currently WebMediaPlayer has three predicates:
 - DidGetOpaqueResponseFromServiceWorker
 - HasSingleSecurityOrigin
 - DidPassCORSAccessCheck
. These are used to determine whether the response body is available
for scripts. They are known to be confusing, and actually
MediaElementAudioSourceHandler::WouldTaintOrigin misuses them.

This CL merges the three predicates to one, WouldTaintOrigin, to remove
the confusion. Now the ""response type"" concept is available and we
don't need a custom CORS check, so this CL removes
BaseAudioContext::WouldTaintOrigin. This CL also renames
URLData::has_opaque_data_ and its (direct and indirect) data accessors
to match the spec.

Bug: 849942, 875153
Change-Id: I6acf50169d7445c4ff614e80ac606f79ee577d2a
Reviewed-on: https://chromium-review.googlesource.com/c/1238098
Reviewed-by: Fredrik Hubinette <hubbe@chromium.org>
Reviewed-by: Kinuko Yasuda <kinuko@chromium.org>
Reviewed-by: Raymond Toy <rtoy@chromium.org>
Commit-Queue: Yutaka Hirano <yhirano@chromium.org>
Cr-Commit-Position: refs/heads/master@{#598258}",8,third_party/blink/renderer/core/html/media/html_media_element.cc,"{""sha"": ""78ca5e2c3c323cf55e23eacc262e8a197e60b63b"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 11, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -844,21 +844,11 @@ void WebMediaPlayerMS::Paint(cc::PaintCanvas* canvas,\n                         context_3d, context_support);\n }\n \n-bool WebMediaPlayerMS::DidGetOpaqueResponseFromServiceWorker() const {\n+bool WebMediaPlayerMS::WouldTaintOrigin() const {\n   DCHECK(thread_checker_.CalledOnValidThread());\n   return false;\n }\n \n-bool WebMediaPlayerMS::HasSingleSecurityOrigin() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n-bool WebMediaPlayerMS::DidPassCORSAccessCheck() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n double WebMediaPlayerMS::MediaTimeForTimeValue(double timeValue) const {\n   return base::TimeDelta::FromSecondsD(timeValue).InSecondsF();\n }""}<_**next**_>{""sha"": ""8c3595505cb20fa379b861f49b28710c40f3a5f1"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -163,9 +163,7 @@ class CONTENT_EXPORT WebMediaPlayerMS\n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n \n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n ""}<_**next**_>{""sha"": ""d26bc8142d80dc7c64958a9c22170244d6e664dd"", ""filename"": ""content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -76,9 +76,7 @@ class MockWebMediaPlayer : public blink::WebMediaPlayer,\n   }\n \n   bool DidLoadingProgress() override { return true; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double timeValue) const override { return 0.0; }\n   unsigned DecodedFrameCount() const override { return 0; }\n   unsigned DroppedFrameCount() const override { return 0; }""}<_**next**_>{""sha"": ""74ad44546ee34afa79b4a1649710117f8532c5f4"", ""filename"": ""media/blink/multibuffer_data_source.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 19, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -286,23 +286,8 @@ bool MultibufferDataSource::HasSingleOrigin() {\n   return single_origin_;\n }\n \n-bool MultibufferDataSource::DidPassCORSAccessCheck() const {\n-  if (url_data()->cors_mode() == UrlData::CORS_UNSPECIFIED)\n-    return false;\n-\n-  // If init_cb is set, we know initialization is not finished yet.\n-  if (init_cb_)\n-    return false;\n-  if (failed_)\n-    return false;\n-  return true;\n-}\n-\n-bool MultibufferDataSource::DidGetOpaqueResponseViaServiceWorker() const {\n-  return url_data()->has_opaque_data();\n-\n-  // TODO(falken): Do we need to do something about |init_cb_| like\n-  // in DidPassCORSAccessCheck()?\n+bool MultibufferDataSource::IsCorsCrossOrigin() const {\n+  return url_data()->is_cors_cross_origin();\n }\n \n void MultibufferDataSource::MediaPlaybackRateChanged(double playback_rate) {\n@@ -627,8 +612,6 @@ void MultibufferDataSource::StartCallback() {\n     // Progress callback might be called after the start callback,\n     // make sure that we update single_origin_ now.\n     media_log_->SetBooleanProperty(\""single_origin\"", single_origin_);\n-    media_log_->SetBooleanProperty(\""passed_cors_access_check\"",\n-                                   DidPassCORSAccessCheck());\n     media_log_->SetBooleanProperty(\""range_header_supported\"",\n                                    url_data()->range_supported());\n   }""}<_**next**_>{""sha"": ""4da62a5519e33ab6e726406f0acac4995c4ad49f"", ""filename"": ""media/blink/multibuffer_data_source.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 6, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -79,12 +79,9 @@ class MEDIA_BLINK_EXPORT MultibufferDataSource : public DataSource {\n   // Method called on the render thread.\n   bool HasSingleOrigin();\n \n-  // Returns true if the media resource passed a CORS access control check.\n-  bool DidPassCORSAccessCheck() const;\n-\n-  // Returns true if a service worker provided the media resource response,\n-  // and the response was opaque.\n-  bool DidGetOpaqueResponseViaServiceWorker() const;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  // This must be called after the response arrives.\n+  bool IsCorsCrossOrigin() const;\n \n   // Notifies changes in playback state for controlling media buffering\n   // behavior.""}<_**next**_>{""sha"": ""4b9f83e74255bf14d33c3f0c2785c282ecb2bcd7"", ""filename"": ""media/blink/multibuffer_data_source_unittest.cc"", ""status"": ""modified"", ""additions"": 81, ""deletions"": 12, ""changes"": 93, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1493,35 +1493,104 @@ TEST_F(MultibufferDataSourceTest, FileSizeLessThanBlockSize) {\n   Stop();\n }\n \n-TEST_F(MultibufferDataSourceTest, DidPassCORSAccessTest) {\n+TEST_F(MultibufferDataSourceTest, ResponseTypeBasic) {\n   InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n   set_preload(MultibufferDataSource::NONE);\n   WebURLResponse response1 =\n       response_generator_->GeneratePartial206(0, kDataSize - 1);\n-  response1.SetWasFetchedViaServiceWorker(true);\n-  std::vector<blink::WebURL> urlList = {GURL(kHttpDifferentOriginUrl)};\n-  response1.SetURLListViaServiceWorker(urlList);\n-  WebURLResponse response2 =\n-      response_generator_->GeneratePartial206(kDataSize, kDataSize * 2 - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kBasic);\n \n   EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n   EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n   EXPECT_CALL(*this, ReadCallback(kDataSize));\n \n-  EXPECT_FALSE(data_source_->DidPassCORSAccessCheck());\n   Respond(response1);\n   ReceiveData(kDataSize);\n   ReadAt(0);\n   EXPECT_TRUE(loading());\n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n   FinishLoading();\n+}\n \n-  // Verify that if reader_ is null, DidPassCORSAccessCheck still returns true.\n-  data_source_->Stop();\n-  base::RunLoop().RunUntilIdle();\n+TEST_F(MultibufferDataSourceTest, ResponseTypeCors) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kCORS);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeDefault) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kDefault);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaque) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaque);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaqueRedirect) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaqueRedirect);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n }\n \n TEST_F(MultibufferDataSourceTest, EtagTest) {""}<_**next**_>{""sha"": ""89f1c9e70d2cc71646df50026b50d54d471d20c6"", ""filename"": ""media/blink/resource_multibuffer_data_provider.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/resource_multibuffer_data_provider.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -280,6 +280,8 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n   int64_t content_length = response.ExpectedContentLength();\n   bool end_of_file = false;\n   bool do_fail = false;\n+  // We get the response type here because aborting the loader may change it.\n+  const auto response_type = response.GetType();\n   bytes_to_discard_ = 0;\n \n   // We make a strong assumption that when we reach here we have either\n@@ -333,10 +335,9 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n         url_data_->url_index()->TryInsert(destination_url_data);\n   }\n \n-  // This is vital for security! A service worker can respond with a response\n-  // from a different origin, so this response type is needed to detect that.\n-  destination_url_data->set_has_opaque_data(\n-      network::cors::IsCORSCrossOriginResponseType(response.GetType()));\n+  // This is vital for security!\n+  destination_url_data->set_is_cors_cross_origin(\n+      network::cors::IsCORSCrossOriginResponseType(response_type));\n \n   if (destination_url_data != url_data_) {\n     // At this point, we've encountered a redirect, or found a better url data""}<_**next**_>{""sha"": ""3fb63497791a3d2a0ea1e3b12c018f4b2c5fe355"", ""filename"": ""media/blink/url_index.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 7, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -65,7 +65,6 @@ UrlData::UrlData(const GURL& url, CORSMode cors_mode, UrlIndex* url_index)\n       length_(kPositionNotSpecified),\n       range_supported_(false),\n       cacheable_(false),\n-      has_opaque_data_(false),\n       last_used_(),\n       multibuffer_(this, url_index_->block_shift_) {}\n \n@@ -103,9 +102,8 @@ void UrlData::MergeFrom(const scoped_refptr<UrlData>& other) {\n       last_modified_ = other->last_modified_;\n     }\n     bytes_read_from_cache_ += other->bytes_read_from_cache_;\n-    // set_has_opaque_data() will not relax from opaque to non-opaque if already\n-    // opaque.\n-    set_has_opaque_data(other->has_opaque_data_);\n+    // is_cors_corss_origin_ will not relax from true to false.\n+    set_is_cors_cross_origin(other->is_cors_cross_origin_);\n     multibuffer()->MergeFrom(other->multibuffer());\n   }\n }\n@@ -122,10 +120,10 @@ void UrlData::set_length(int64_t length) {\n   }\n }\n \n-void UrlData::set_has_opaque_data(bool has_opaque_data) {\n-  if (has_opaque_data_)\n+void UrlData::set_is_cors_cross_origin(bool is_cors_cross_origin) {\n+  if (is_cors_cross_origin_)\n     return;\n-  has_opaque_data_ = has_opaque_data;\n+  is_cors_cross_origin_ = is_cors_cross_origin;\n }\n \n void UrlData::RedirectTo(const scoped_refptr<UrlData>& url_data) {""}<_**next**_>{""sha"": ""2c15bc7ac0ad4489a0c922f614889e575bd5d863"", ""filename"": ""media/blink/url_index.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -125,7 +125,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // Returns our url_index.\n   UrlIndex* url_index() const { return url_index_; }\n \n-  bool has_opaque_data() const { return has_opaque_data_; }\n+  // This must be called after the response arrives.\n+  bool is_cors_cross_origin() const { return is_cors_cross_origin_; }\n \n   // Notifies the url index that this is currently used.\n   // The url <-> URLData mapping will be eventually be invalidated if\n@@ -145,7 +146,7 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   void set_range_supported();\n   void set_last_modified(base::Time last_modified);\n   void set_etag(const std::string& etag);\n-  void set_has_opaque_data(bool has_opaque_data);\n+  void set_is_cors_cross_origin(bool is_cors_cross_origin);\n \n   // A redirect has occured (or we've found a better UrlData for the same\n   // resource).\n@@ -238,9 +239,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // will not cache this url.\n   bool cacheable_;\n \n-  // True if a service worker intercepted a request for this resource\n-  // and provided an opaque response.\n-  bool has_opaque_data_;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  bool is_cors_cross_origin_ = false;\n \n   // Last time some media time used this resource.\n   // Note that we use base::Time rather than base::TimeTicks because""}<_**next**_>{""sha"": ""cf0857d8c6283758b159609f76da1bafb19cc789"", ""filename"": ""media/blink/webmediaplayer_impl.cc"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 10, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1175,12 +1175,6 @@ void WebMediaPlayerImpl::Paint(cc::PaintCanvas* canvas,\n       context_support);\n }\n \n-bool WebMediaPlayerImpl::DidGetOpaqueResponseFromServiceWorker() const {\n-  if (data_source_)\n-    return data_source_->DidGetOpaqueResponseViaServiceWorker();\n-  return false;\n-}\n-\n bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   if (demuxer_found_hls_) {\n     // HLS manifests might pull segments from a different origin. We can't know\n@@ -1193,10 +1187,15 @@ bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   return true;\n }\n \n-bool WebMediaPlayerImpl::DidPassCORSAccessCheck() const {\n-  if (data_source_)\n-    return data_source_->DidPassCORSAccessCheck();\n-  return false;\n+bool WebMediaPlayerImpl::WouldTaintOrigin() const {\n+  if (!HasSingleSecurityOrigin()) {\n+    // When the resource is redirected to another origin we think it as\n+    // tainted. This is actually not specified, and is under discussion.\n+    // See https://github.com/whatwg/fetch/issues/737.\n+    return true;\n+  }\n+\n+  return data_source_ && data_source_->IsCorsCrossOrigin();\n }\n \n double WebMediaPlayerImpl::MediaTimeForTimeValue(double timeValue) const {""}<_**next**_>{""sha"": ""233e37b4614544e9b2a67b4e5edee775de0f79a6"", ""filename"": ""media/blink/webmediaplayer_impl.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -188,10 +188,7 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n \n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n-\n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n \n@@ -332,6 +329,8 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n   void OnPipelineResumed();\n   void OnDemuxerOpened();\n \n+  bool HasSingleSecurityOrigin() const;\n+\n   // Pipeline::Client overrides.\n   void OnError(PipelineStatus status) override;\n   void OnEnded() override;""}<_**next**_>{""sha"": ""9821759bc7b311672a54387edc7d8c26a11d5e54"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""status"": ""added"", ""additions"": 47, ""deletions"": 0, ""changes"": 47, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -0,0 +1,47 @@\n+<!doctype html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+<script src=\""/common/get-host-info.sub.js\""></script>\n+<script src=\""resources/test-helpers.sub.js?pipe=sub\""></script>\n+<script>\n+promise_test(async (t) => {\n+    const SCOPE = 'resources/empty.html';\n+    const SCRIPT = 'resources/fetch-rewrite-worker.js';\n+    const host_info = get_host_info();\n+    const REMOTE_ORIGIN = host_info.HTTPS_REMOTE_ORIGIN;\n+\n+    const reg = await service_worker_unregister_and_register(t, SCRIPT, SCOPE);\n+    await wait_for_state(t, reg.installing, 'activated');\n+    const frame = await with_iframe(SCOPE);\n+\n+    const doc = frame.contentDocument;\n+    const win = frame.contentWindow;\n+\n+    const context = new win.AudioContext();\n+    try {\n+      context.suspend();\n+      const audio = doc.createElement('audio');\n+      audio.autoplay = true;\n+      const source = context.createMediaElementSource(audio);\n+      const spn = context.createScriptProcessor(16384, 1, 1);\n+      source.connect(spn).connect(context.destination);\n+      const url = `${REMOTE_ORIGIN}/webaudio/resources/sin_440Hz_-6dBFS_1s.wav`;\n+      audio.src = '/test?url=' + encodeURIComponent(url);\n+      doc.body.appendChild(audio);\n+\n+      await new Promise((resolve) => {\n+        audio.addEventListener('playing', resolve);\n+      });\n+      await context.resume();\n+      const event = await new Promise((resolve) => {\n+        spn.addEventListener('audioprocess', resolve);\n+      });\n+      const data = event.inputBuffer.getChannelData(0);\n+      for (const e of data) {\n+        assert_equals(e, 0);\n+      }\n+    } finally {\n+      context.close();\n+    }\n+  }, 'Verify CORS XHR of fetch() in a Service Worker');\n+</script>""}<_**next**_>{""sha"": ""319648dbc16669ab3b3238d8488997b7d3a7c837"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""58697c0661a94d03e4bbe74134a23e71a860f5f6"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""a1e82caf7e2f9d37d785165a4766f42acb28c465"", ""filename"": ""third_party/blink/public/platform/web_media_player.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/public/platform/web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -207,9 +207,10 @@ class WebMediaPlayer {\n \n   virtual bool DidLoadingProgress() = 0;\n \n-  virtual bool DidGetOpaqueResponseFromServiceWorker() const = 0;\n-  virtual bool HasSingleSecurityOrigin() const = 0;\n-  virtual bool DidPassCORSAccessCheck() const = 0;\n+  // Returns true if the response is CORS-cross-origin and so we shouldn't be\n+  // allowing media to play through webaudio.\n+  // This should be called after the response has arrived.\n+  virtual bool WouldTaintOrigin() const = 0;\n \n   virtual double MediaTimeForTimeValue(double time_value) const = 0;\n ""}<_**next**_>{""sha"": ""ad708c861bb80cd8a01217eec51f9fe058af4a33"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 21, ""changes"": 26, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1506,30 +1506,14 @@ bool HTMLMediaElement::IsSafeToLoadURL(const KURL& url,\n \n bool HTMLMediaElement::IsMediaDataCORSSameOrigin(\n     const SecurityOrigin* origin) const {\n-  // If a service worker handled the request, we don't know if the origin in the\n-  // src is the same as the actual response URL so can't rely on URL checks\n-  // alone. So detect an opaque response via\n-  // DidGetOpaqueResponseFromServiceWorker().\n-  if (GetWebMediaPlayer() &&\n-      GetWebMediaPlayer()->DidGetOpaqueResponseFromServiceWorker()) {\n-    return false;\n-  }\n-\n-  // At this point, either a service worker was not used, or it didn't provide\n-  // an opaque response, so continue with the normal checks.\n+  if (!GetWebMediaPlayer())\n+    return true;\n \n-  // HasSingleSecurityOrigin() tells us whether the origin in the src\n-  // is the same as the actual request (i.e. after redirects).\n-  if (!HasSingleSecurityOrigin())\n+  const auto network_state = GetWebMediaPlayer()->GetNetworkState();\n+  if (network_state == WebMediaPlayer::kNetworkStateNetworkError)\n     return false;\n \n-  // DidPassCORSAccessCheck() means it was a successful CORS-enabled fetch (vs.\n-  // non-CORS-enabled or failed). CanReadContent() does CheckAccess() on the\n-  // URL plus allows data sources, to ensure that it is not a URL that requires\n-  // CORS (basically same origin).\n-  return (GetWebMediaPlayer() &&\n-          GetWebMediaPlayer()->DidPassCORSAccessCheck()) ||\n-         origin->CanReadContent(currentSrc());\n+  return !GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n bool HTMLMediaElement::IsInCrossOriginFrame() const {""}<_**next**_>{""sha"": ""f2d50264a53a0a3002725b06b6363091f4e17faa"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -268,11 +268,6 @@ class CORE_EXPORT HTMLMediaElement\n   // of one of them here.\n   using HTMLElement::GetExecutionContext;\n \n-  bool HasSingleSecurityOrigin() const {\n-    return GetWebMediaPlayer() ? GetWebMediaPlayer()->HasSingleSecurityOrigin()\n-                               : true;\n-  }\n-\n   bool IsFullscreen() const;\n   virtual bool UsesOverlayFullscreenVideo() const { return false; }\n ""}<_**next**_>{""sha"": ""8cf3a926979a853d0ba0f48f9def6bc9b4aec36a"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 17, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -958,21 +958,4 @@ void BaseAudioContext::UpdateWorkletGlobalScopeOnRenderingThread() {\n   }\n }\n \n-bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {\n-  // Data URLs don't taint the origin.\n-  if (url.ProtocolIsData()) {\n-    return false;\n-  }\n-\n-  Document* document = GetDocument();\n-  if (document && document->GetSecurityOrigin()) {\n-    // The origin is tainted if and only if we cannot read content from the URL.\n-    return !document->GetSecurityOrigin()->CanRequest(url);\n-  }\n-\n-  // Be conservative and assume it's tainted if it's not a data url and if we\n-  // can't get the security origin of the document.\n-  return true;\n-}\n-\n }  // namespace blink""}<_**next**_>{""sha"": ""ae933f20167fb374b51ff5a869d9381f97b56d4b"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -296,13 +296,6 @@ class MODULES_EXPORT BaseAudioContext\n   // Does nothing when the worklet global scope does not exist.\n   void UpdateWorkletGlobalScopeOnRenderingThread();\n \n-  // Returns true if the URL would taint the origin so that we shouldn't be\n-  // allowing media to played through webaudio.\n-  // TODO(crbug.com/845913): This should really be on an AudioContext.  Move\n-  // this when we move the media stuff from BaseAudioContext to AudioContext, as\n-  // requried by the spec.\n-  bool WouldTaintOrigin(const KURL& url) const;\n-\n  protected:\n   enum ContextType { kRealtimeContext, kOfflineContext };\n ""}<_**next**_>{""sha"": ""d7b07b5fea75809b4e14c8fda74b38a1d48e6b9d"", ""filename"": ""third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 13, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -136,19 +136,7 @@ void MediaElementAudioSourceHandler::SetFormat(size_t number_of_channels,\n }\n \n bool MediaElementAudioSourceHandler::WouldTaintOrigin() {\n-  // If we're cross-origin and allowed access vie CORS, we're not tainted.\n-  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {\n-    return false;\n-  }\n-\n-  // Handles the case where the url is a redirect to another site that we're not\n-  // allowed to access.\n-  if (!MediaElement()->HasSingleSecurityOrigin()) {\n-    return true;\n-  }\n-\n-  // Test to see if the current media URL taint the origin of the audio context?\n-  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());\n+  return MediaElement()->GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n void MediaElementAudioSourceHandler::PrintCORSMessage(const String& message) {""}<_**next**_>{""sha"": ""6e5771836bf84527d922a6c5fc84a3aa5c8c9bce"", ""filename"": ""third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/testing/empty_web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -50,9 +50,7 @@ class EmptyWebMediaPlayer : public WebMediaPlayer {\n   ReadyState GetReadyState() const override { return kReadyStateHaveNothing; }\n   WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override { return false; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double time_value) const override {\n     return time_value;\n   };""}"," bool HTMLMediaElement::IsMediaDataCORSSameOrigin(
     const SecurityOrigin* origin) const {
  if (!GetWebMediaPlayer())
    return true;
 
  const auto network_state = GetWebMediaPlayer()->GetNetworkState();
  if (network_state == WebMediaPlayer::kNetworkStateNetworkError)
     return false;
 
  return !GetWebMediaPlayer()->WouldTaintOrigin();
 }
"," bool HTMLMediaElement::IsMediaDataCORSSameOrigin(
     const SecurityOrigin* origin) const {
  if (GetWebMediaPlayer() &&
      GetWebMediaPlayer()->DidGetOpaqueResponseFromServiceWorker()) {
    return false;
  }
 
  if (!HasSingleSecurityOrigin())
     return false;
 
  return (GetWebMediaPlayer() &&
          GetWebMediaPlayer()->DidPassCORSAccessCheck()) ||
         origin->CanReadContent(currentSrc());
 }
",C,"  if (!GetWebMediaPlayer())
    return true;
  const auto network_state = GetWebMediaPlayer()->GetNetworkState();
  if (network_state == WebMediaPlayer::kNetworkStateNetworkError)
  return !GetWebMediaPlayer()->WouldTaintOrigin();
","  if (GetWebMediaPlayer() &&
      GetWebMediaPlayer()->DidGetOpaqueResponseFromServiceWorker()) {
    return false;
  }
  if (!HasSingleSecurityOrigin())
  return (GetWebMediaPlayer() &&
          GetWebMediaPlayer()->DidPassCORSAccessCheck()) ||
         origin->CanReadContent(currentSrc());
",,"@@ -1506,30 +1506,14 @@ bool HTMLMediaElement::IsSafeToLoadURL(const KURL& url,
 
 bool HTMLMediaElement::IsMediaDataCORSSameOrigin(
     const SecurityOrigin* origin) const {
-  // If a service worker handled the request, we don't know if the origin in the
-  // src is the same as the actual response URL so can't rely on URL checks
-  // alone. So detect an opaque response via
-  // DidGetOpaqueResponseFromServiceWorker().
-  if (GetWebMediaPlayer() &&
-      GetWebMediaPlayer()->DidGetOpaqueResponseFromServiceWorker()) {
-    return false;
-  }
-
-  // At this point, either a service worker was not used, or it didn't provide
-  // an opaque response, so continue with the normal checks.
+  if (!GetWebMediaPlayer())
+    return true;
 
-  // HasSingleSecurityOrigin() tells us whether the origin in the src
-  // is the same as the actual request (i.e. after redirects).
-  if (!HasSingleSecurityOrigin())
+  const auto network_state = GetWebMediaPlayer()->GetNetworkState();
+  if (network_state == WebMediaPlayer::kNetworkStateNetworkError)
     return false;
 
-  // DidPassCORSAccessCheck() means it was a successful CORS-enabled fetch (vs.
-  // non-CORS-enabled or failed). CanReadContent() does CheckAccess() on the
-  // URL plus allows data sources, to ensure that it is not a URL that requires
-  // CORS (basically same origin).
-  return (GetWebMediaPlayer() &&
-          GetWebMediaPlayer()->DidPassCORSAccessCheck()) ||
-         origin->CanReadContent(currentSrc());
+  return !GetWebMediaPlayer()->WouldTaintOrigin();
 }
 
 bool HTMLMediaElement::IsInCrossOriginFrame() const {",Chrome,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,50436d878b2e92de4231fda47328a8a4e884ecc3,1," bool HTMLMediaElement::IsMediaDataCORSSameOrigin(
     const SecurityOrigin* origin) const {
//flaw_line_below:
  // If a service worker handled the request, we don't know if the origin in the
//flaw_line_below:
  // src is the same as the actual response URL so can't rely on URL checks
//flaw_line_below:
  // alone. So detect an opaque response via
//flaw_line_below:
  // DidGetOpaqueResponseFromServiceWorker().
//flaw_line_below:
  if (GetWebMediaPlayer() &&
//flaw_line_below:
      GetWebMediaPlayer()->DidGetOpaqueResponseFromServiceWorker()) {
//flaw_line_below:
    return false;
//flaw_line_below:
  }
//flaw_line_below:

//flaw_line_below:
  // At this point, either a service worker was not used, or it didn't provide
//flaw_line_below:
  // an opaque response, so continue with the normal checks.
//fix_flaw_line_below:
//  if (!GetWebMediaPlayer())
//fix_flaw_line_below:
//    return true;
 
//flaw_line_below:
  // HasSingleSecurityOrigin() tells us whether the origin in the src
//flaw_line_below:
  // is the same as the actual request (i.e. after redirects).
//flaw_line_below:
  if (!HasSingleSecurityOrigin())
//fix_flaw_line_below:
//  const auto network_state = GetWebMediaPlayer()->GetNetworkState();
//fix_flaw_line_below:
//  if (network_state == WebMediaPlayer::kNetworkStateNetworkError)
     return false;
 
//flaw_line_below:
  // DidPassCORSAccessCheck() means it was a successful CORS-enabled fetch (vs.
//flaw_line_below:
  // non-CORS-enabled or failed). CanReadContent() does CheckAccess() on the
//flaw_line_below:
  // URL plus allows data sources, to ensure that it is not a URL that requires
//flaw_line_below:
  // CORS (basically same origin).
//flaw_line_below:
  return (GetWebMediaPlayer() &&
//flaw_line_below:
          GetWebMediaPlayer()->DidPassCORSAccessCheck()) ||
//flaw_line_below:
         origin->CanReadContent(currentSrc());
//fix_flaw_line_below:
//  return !GetWebMediaPlayer()->WouldTaintOrigin();
 }
"
8874,186610,,Remote,Not required,,CVE-2018-18352,https://www.cvedetails.com/cve/CVE-2018-18352/,CWE-732,Medium,Partial,,,2018-12-11,4.3,Service works could inappropriately gain access to cross origin audio in Media in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to bypass same origin policy for audio content via a crafted HTML page.,2019-10-02,Bypass ,0,https://github.com/chromium/chromium/commit/a9cbaa7a40e2b2723cfc2f266c42f4980038a949,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,"Simplify ""WouldTaintOrigin"" concept in media/blink

Currently WebMediaPlayer has three predicates:
 - DidGetOpaqueResponseFromServiceWorker
 - HasSingleSecurityOrigin
 - DidPassCORSAccessCheck
. These are used to determine whether the response body is available
for scripts. They are known to be confusing, and actually
MediaElementAudioSourceHandler::WouldTaintOrigin misuses them.

This CL merges the three predicates to one, WouldTaintOrigin, to remove
the confusion. Now the ""response type"" concept is available and we
don't need a custom CORS check, so this CL removes
BaseAudioContext::WouldTaintOrigin. This CL also renames
URLData::has_opaque_data_ and its (direct and indirect) data accessors
to match the spec.

Bug: 849942, 875153
Change-Id: I6acf50169d7445c4ff614e80ac606f79ee577d2a
Reviewed-on: https://chromium-review.googlesource.com/c/1238098
Reviewed-by: Fredrik Hubinette <hubbe@chromium.org>
Reviewed-by: Kinuko Yasuda <kinuko@chromium.org>
Reviewed-by: Raymond Toy <rtoy@chromium.org>
Commit-Queue: Yutaka Hirano <yhirano@chromium.org>
Cr-Commit-Position: refs/heads/master@{#598258}",9,third_party/blink/renderer/modules/webaudio/base_audio_context.cc,"{""sha"": ""78ca5e2c3c323cf55e23eacc262e8a197e60b63b"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 11, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -844,21 +844,11 @@ void WebMediaPlayerMS::Paint(cc::PaintCanvas* canvas,\n                         context_3d, context_support);\n }\n \n-bool WebMediaPlayerMS::DidGetOpaqueResponseFromServiceWorker() const {\n+bool WebMediaPlayerMS::WouldTaintOrigin() const {\n   DCHECK(thread_checker_.CalledOnValidThread());\n   return false;\n }\n \n-bool WebMediaPlayerMS::HasSingleSecurityOrigin() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n-bool WebMediaPlayerMS::DidPassCORSAccessCheck() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n double WebMediaPlayerMS::MediaTimeForTimeValue(double timeValue) const {\n   return base::TimeDelta::FromSecondsD(timeValue).InSecondsF();\n }""}<_**next**_>{""sha"": ""8c3595505cb20fa379b861f49b28710c40f3a5f1"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -163,9 +163,7 @@ class CONTENT_EXPORT WebMediaPlayerMS\n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n \n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n ""}<_**next**_>{""sha"": ""d26bc8142d80dc7c64958a9c22170244d6e664dd"", ""filename"": ""content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -76,9 +76,7 @@ class MockWebMediaPlayer : public blink::WebMediaPlayer,\n   }\n \n   bool DidLoadingProgress() override { return true; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double timeValue) const override { return 0.0; }\n   unsigned DecodedFrameCount() const override { return 0; }\n   unsigned DroppedFrameCount() const override { return 0; }""}<_**next**_>{""sha"": ""74ad44546ee34afa79b4a1649710117f8532c5f4"", ""filename"": ""media/blink/multibuffer_data_source.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 19, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -286,23 +286,8 @@ bool MultibufferDataSource::HasSingleOrigin() {\n   return single_origin_;\n }\n \n-bool MultibufferDataSource::DidPassCORSAccessCheck() const {\n-  if (url_data()->cors_mode() == UrlData::CORS_UNSPECIFIED)\n-    return false;\n-\n-  // If init_cb is set, we know initialization is not finished yet.\n-  if (init_cb_)\n-    return false;\n-  if (failed_)\n-    return false;\n-  return true;\n-}\n-\n-bool MultibufferDataSource::DidGetOpaqueResponseViaServiceWorker() const {\n-  return url_data()->has_opaque_data();\n-\n-  // TODO(falken): Do we need to do something about |init_cb_| like\n-  // in DidPassCORSAccessCheck()?\n+bool MultibufferDataSource::IsCorsCrossOrigin() const {\n+  return url_data()->is_cors_cross_origin();\n }\n \n void MultibufferDataSource::MediaPlaybackRateChanged(double playback_rate) {\n@@ -627,8 +612,6 @@ void MultibufferDataSource::StartCallback() {\n     // Progress callback might be called after the start callback,\n     // make sure that we update single_origin_ now.\n     media_log_->SetBooleanProperty(\""single_origin\"", single_origin_);\n-    media_log_->SetBooleanProperty(\""passed_cors_access_check\"",\n-                                   DidPassCORSAccessCheck());\n     media_log_->SetBooleanProperty(\""range_header_supported\"",\n                                    url_data()->range_supported());\n   }""}<_**next**_>{""sha"": ""4da62a5519e33ab6e726406f0acac4995c4ad49f"", ""filename"": ""media/blink/multibuffer_data_source.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 6, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -79,12 +79,9 @@ class MEDIA_BLINK_EXPORT MultibufferDataSource : public DataSource {\n   // Method called on the render thread.\n   bool HasSingleOrigin();\n \n-  // Returns true if the media resource passed a CORS access control check.\n-  bool DidPassCORSAccessCheck() const;\n-\n-  // Returns true if a service worker provided the media resource response,\n-  // and the response was opaque.\n-  bool DidGetOpaqueResponseViaServiceWorker() const;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  // This must be called after the response arrives.\n+  bool IsCorsCrossOrigin() const;\n \n   // Notifies changes in playback state for controlling media buffering\n   // behavior.""}<_**next**_>{""sha"": ""4b9f83e74255bf14d33c3f0c2785c282ecb2bcd7"", ""filename"": ""media/blink/multibuffer_data_source_unittest.cc"", ""status"": ""modified"", ""additions"": 81, ""deletions"": 12, ""changes"": 93, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1493,35 +1493,104 @@ TEST_F(MultibufferDataSourceTest, FileSizeLessThanBlockSize) {\n   Stop();\n }\n \n-TEST_F(MultibufferDataSourceTest, DidPassCORSAccessTest) {\n+TEST_F(MultibufferDataSourceTest, ResponseTypeBasic) {\n   InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n   set_preload(MultibufferDataSource::NONE);\n   WebURLResponse response1 =\n       response_generator_->GeneratePartial206(0, kDataSize - 1);\n-  response1.SetWasFetchedViaServiceWorker(true);\n-  std::vector<blink::WebURL> urlList = {GURL(kHttpDifferentOriginUrl)};\n-  response1.SetURLListViaServiceWorker(urlList);\n-  WebURLResponse response2 =\n-      response_generator_->GeneratePartial206(kDataSize, kDataSize * 2 - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kBasic);\n \n   EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n   EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n   EXPECT_CALL(*this, ReadCallback(kDataSize));\n \n-  EXPECT_FALSE(data_source_->DidPassCORSAccessCheck());\n   Respond(response1);\n   ReceiveData(kDataSize);\n   ReadAt(0);\n   EXPECT_TRUE(loading());\n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n   FinishLoading();\n+}\n \n-  // Verify that if reader_ is null, DidPassCORSAccessCheck still returns true.\n-  data_source_->Stop();\n-  base::RunLoop().RunUntilIdle();\n+TEST_F(MultibufferDataSourceTest, ResponseTypeCors) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kCORS);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeDefault) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kDefault);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaque) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaque);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaqueRedirect) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaqueRedirect);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n }\n \n TEST_F(MultibufferDataSourceTest, EtagTest) {""}<_**next**_>{""sha"": ""89f1c9e70d2cc71646df50026b50d54d471d20c6"", ""filename"": ""media/blink/resource_multibuffer_data_provider.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/resource_multibuffer_data_provider.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -280,6 +280,8 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n   int64_t content_length = response.ExpectedContentLength();\n   bool end_of_file = false;\n   bool do_fail = false;\n+  // We get the response type here because aborting the loader may change it.\n+  const auto response_type = response.GetType();\n   bytes_to_discard_ = 0;\n \n   // We make a strong assumption that when we reach here we have either\n@@ -333,10 +335,9 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n         url_data_->url_index()->TryInsert(destination_url_data);\n   }\n \n-  // This is vital for security! A service worker can respond with a response\n-  // from a different origin, so this response type is needed to detect that.\n-  destination_url_data->set_has_opaque_data(\n-      network::cors::IsCORSCrossOriginResponseType(response.GetType()));\n+  // This is vital for security!\n+  destination_url_data->set_is_cors_cross_origin(\n+      network::cors::IsCORSCrossOriginResponseType(response_type));\n \n   if (destination_url_data != url_data_) {\n     // At this point, we've encountered a redirect, or found a better url data""}<_**next**_>{""sha"": ""3fb63497791a3d2a0ea1e3b12c018f4b2c5fe355"", ""filename"": ""media/blink/url_index.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 7, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -65,7 +65,6 @@ UrlData::UrlData(const GURL& url, CORSMode cors_mode, UrlIndex* url_index)\n       length_(kPositionNotSpecified),\n       range_supported_(false),\n       cacheable_(false),\n-      has_opaque_data_(false),\n       last_used_(),\n       multibuffer_(this, url_index_->block_shift_) {}\n \n@@ -103,9 +102,8 @@ void UrlData::MergeFrom(const scoped_refptr<UrlData>& other) {\n       last_modified_ = other->last_modified_;\n     }\n     bytes_read_from_cache_ += other->bytes_read_from_cache_;\n-    // set_has_opaque_data() will not relax from opaque to non-opaque if already\n-    // opaque.\n-    set_has_opaque_data(other->has_opaque_data_);\n+    // is_cors_corss_origin_ will not relax from true to false.\n+    set_is_cors_cross_origin(other->is_cors_cross_origin_);\n     multibuffer()->MergeFrom(other->multibuffer());\n   }\n }\n@@ -122,10 +120,10 @@ void UrlData::set_length(int64_t length) {\n   }\n }\n \n-void UrlData::set_has_opaque_data(bool has_opaque_data) {\n-  if (has_opaque_data_)\n+void UrlData::set_is_cors_cross_origin(bool is_cors_cross_origin) {\n+  if (is_cors_cross_origin_)\n     return;\n-  has_opaque_data_ = has_opaque_data;\n+  is_cors_cross_origin_ = is_cors_cross_origin;\n }\n \n void UrlData::RedirectTo(const scoped_refptr<UrlData>& url_data) {""}<_**next**_>{""sha"": ""2c15bc7ac0ad4489a0c922f614889e575bd5d863"", ""filename"": ""media/blink/url_index.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -125,7 +125,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // Returns our url_index.\n   UrlIndex* url_index() const { return url_index_; }\n \n-  bool has_opaque_data() const { return has_opaque_data_; }\n+  // This must be called after the response arrives.\n+  bool is_cors_cross_origin() const { return is_cors_cross_origin_; }\n \n   // Notifies the url index that this is currently used.\n   // The url <-> URLData mapping will be eventually be invalidated if\n@@ -145,7 +146,7 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   void set_range_supported();\n   void set_last_modified(base::Time last_modified);\n   void set_etag(const std::string& etag);\n-  void set_has_opaque_data(bool has_opaque_data);\n+  void set_is_cors_cross_origin(bool is_cors_cross_origin);\n \n   // A redirect has occured (or we've found a better UrlData for the same\n   // resource).\n@@ -238,9 +239,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // will not cache this url.\n   bool cacheable_;\n \n-  // True if a service worker intercepted a request for this resource\n-  // and provided an opaque response.\n-  bool has_opaque_data_;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  bool is_cors_cross_origin_ = false;\n \n   // Last time some media time used this resource.\n   // Note that we use base::Time rather than base::TimeTicks because""}<_**next**_>{""sha"": ""cf0857d8c6283758b159609f76da1bafb19cc789"", ""filename"": ""media/blink/webmediaplayer_impl.cc"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 10, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1175,12 +1175,6 @@ void WebMediaPlayerImpl::Paint(cc::PaintCanvas* canvas,\n       context_support);\n }\n \n-bool WebMediaPlayerImpl::DidGetOpaqueResponseFromServiceWorker() const {\n-  if (data_source_)\n-    return data_source_->DidGetOpaqueResponseViaServiceWorker();\n-  return false;\n-}\n-\n bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   if (demuxer_found_hls_) {\n     // HLS manifests might pull segments from a different origin. We can't know\n@@ -1193,10 +1187,15 @@ bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   return true;\n }\n \n-bool WebMediaPlayerImpl::DidPassCORSAccessCheck() const {\n-  if (data_source_)\n-    return data_source_->DidPassCORSAccessCheck();\n-  return false;\n+bool WebMediaPlayerImpl::WouldTaintOrigin() const {\n+  if (!HasSingleSecurityOrigin()) {\n+    // When the resource is redirected to another origin we think it as\n+    // tainted. This is actually not specified, and is under discussion.\n+    // See https://github.com/whatwg/fetch/issues/737.\n+    return true;\n+  }\n+\n+  return data_source_ && data_source_->IsCorsCrossOrigin();\n }\n \n double WebMediaPlayerImpl::MediaTimeForTimeValue(double timeValue) const {""}<_**next**_>{""sha"": ""233e37b4614544e9b2a67b4e5edee775de0f79a6"", ""filename"": ""media/blink/webmediaplayer_impl.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -188,10 +188,7 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n \n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n-\n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n \n@@ -332,6 +329,8 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n   void OnPipelineResumed();\n   void OnDemuxerOpened();\n \n+  bool HasSingleSecurityOrigin() const;\n+\n   // Pipeline::Client overrides.\n   void OnError(PipelineStatus status) override;\n   void OnEnded() override;""}<_**next**_>{""sha"": ""9821759bc7b311672a54387edc7d8c26a11d5e54"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""status"": ""added"", ""additions"": 47, ""deletions"": 0, ""changes"": 47, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -0,0 +1,47 @@\n+<!doctype html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+<script src=\""/common/get-host-info.sub.js\""></script>\n+<script src=\""resources/test-helpers.sub.js?pipe=sub\""></script>\n+<script>\n+promise_test(async (t) => {\n+    const SCOPE = 'resources/empty.html';\n+    const SCRIPT = 'resources/fetch-rewrite-worker.js';\n+    const host_info = get_host_info();\n+    const REMOTE_ORIGIN = host_info.HTTPS_REMOTE_ORIGIN;\n+\n+    const reg = await service_worker_unregister_and_register(t, SCRIPT, SCOPE);\n+    await wait_for_state(t, reg.installing, 'activated');\n+    const frame = await with_iframe(SCOPE);\n+\n+    const doc = frame.contentDocument;\n+    const win = frame.contentWindow;\n+\n+    const context = new win.AudioContext();\n+    try {\n+      context.suspend();\n+      const audio = doc.createElement('audio');\n+      audio.autoplay = true;\n+      const source = context.createMediaElementSource(audio);\n+      const spn = context.createScriptProcessor(16384, 1, 1);\n+      source.connect(spn).connect(context.destination);\n+      const url = `${REMOTE_ORIGIN}/webaudio/resources/sin_440Hz_-6dBFS_1s.wav`;\n+      audio.src = '/test?url=' + encodeURIComponent(url);\n+      doc.body.appendChild(audio);\n+\n+      await new Promise((resolve) => {\n+        audio.addEventListener('playing', resolve);\n+      });\n+      await context.resume();\n+      const event = await new Promise((resolve) => {\n+        spn.addEventListener('audioprocess', resolve);\n+      });\n+      const data = event.inputBuffer.getChannelData(0);\n+      for (const e of data) {\n+        assert_equals(e, 0);\n+      }\n+    } finally {\n+      context.close();\n+    }\n+  }, 'Verify CORS XHR of fetch() in a Service Worker');\n+</script>""}<_**next**_>{""sha"": ""319648dbc16669ab3b3238d8488997b7d3a7c837"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""58697c0661a94d03e4bbe74134a23e71a860f5f6"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""a1e82caf7e2f9d37d785165a4766f42acb28c465"", ""filename"": ""third_party/blink/public/platform/web_media_player.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/public/platform/web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -207,9 +207,10 @@ class WebMediaPlayer {\n \n   virtual bool DidLoadingProgress() = 0;\n \n-  virtual bool DidGetOpaqueResponseFromServiceWorker() const = 0;\n-  virtual bool HasSingleSecurityOrigin() const = 0;\n-  virtual bool DidPassCORSAccessCheck() const = 0;\n+  // Returns true if the response is CORS-cross-origin and so we shouldn't be\n+  // allowing media to play through webaudio.\n+  // This should be called after the response has arrived.\n+  virtual bool WouldTaintOrigin() const = 0;\n \n   virtual double MediaTimeForTimeValue(double time_value) const = 0;\n ""}<_**next**_>{""sha"": ""ad708c861bb80cd8a01217eec51f9fe058af4a33"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 21, ""changes"": 26, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1506,30 +1506,14 @@ bool HTMLMediaElement::IsSafeToLoadURL(const KURL& url,\n \n bool HTMLMediaElement::IsMediaDataCORSSameOrigin(\n     const SecurityOrigin* origin) const {\n-  // If a service worker handled the request, we don't know if the origin in the\n-  // src is the same as the actual response URL so can't rely on URL checks\n-  // alone. So detect an opaque response via\n-  // DidGetOpaqueResponseFromServiceWorker().\n-  if (GetWebMediaPlayer() &&\n-      GetWebMediaPlayer()->DidGetOpaqueResponseFromServiceWorker()) {\n-    return false;\n-  }\n-\n-  // At this point, either a service worker was not used, or it didn't provide\n-  // an opaque response, so continue with the normal checks.\n+  if (!GetWebMediaPlayer())\n+    return true;\n \n-  // HasSingleSecurityOrigin() tells us whether the origin in the src\n-  // is the same as the actual request (i.e. after redirects).\n-  if (!HasSingleSecurityOrigin())\n+  const auto network_state = GetWebMediaPlayer()->GetNetworkState();\n+  if (network_state == WebMediaPlayer::kNetworkStateNetworkError)\n     return false;\n \n-  // DidPassCORSAccessCheck() means it was a successful CORS-enabled fetch (vs.\n-  // non-CORS-enabled or failed). CanReadContent() does CheckAccess() on the\n-  // URL plus allows data sources, to ensure that it is not a URL that requires\n-  // CORS (basically same origin).\n-  return (GetWebMediaPlayer() &&\n-          GetWebMediaPlayer()->DidPassCORSAccessCheck()) ||\n-         origin->CanReadContent(currentSrc());\n+  return !GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n bool HTMLMediaElement::IsInCrossOriginFrame() const {""}<_**next**_>{""sha"": ""f2d50264a53a0a3002725b06b6363091f4e17faa"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -268,11 +268,6 @@ class CORE_EXPORT HTMLMediaElement\n   // of one of them here.\n   using HTMLElement::GetExecutionContext;\n \n-  bool HasSingleSecurityOrigin() const {\n-    return GetWebMediaPlayer() ? GetWebMediaPlayer()->HasSingleSecurityOrigin()\n-                               : true;\n-  }\n-\n   bool IsFullscreen() const;\n   virtual bool UsesOverlayFullscreenVideo() const { return false; }\n ""}<_**next**_>{""sha"": ""8cf3a926979a853d0ba0f48f9def6bc9b4aec36a"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 17, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -958,21 +958,4 @@ void BaseAudioContext::UpdateWorkletGlobalScopeOnRenderingThread() {\n   }\n }\n \n-bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {\n-  // Data URLs don't taint the origin.\n-  if (url.ProtocolIsData()) {\n-    return false;\n-  }\n-\n-  Document* document = GetDocument();\n-  if (document && document->GetSecurityOrigin()) {\n-    // The origin is tainted if and only if we cannot read content from the URL.\n-    return !document->GetSecurityOrigin()->CanRequest(url);\n-  }\n-\n-  // Be conservative and assume it's tainted if it's not a data url and if we\n-  // can't get the security origin of the document.\n-  return true;\n-}\n-\n }  // namespace blink""}<_**next**_>{""sha"": ""ae933f20167fb374b51ff5a869d9381f97b56d4b"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -296,13 +296,6 @@ class MODULES_EXPORT BaseAudioContext\n   // Does nothing when the worklet global scope does not exist.\n   void UpdateWorkletGlobalScopeOnRenderingThread();\n \n-  // Returns true if the URL would taint the origin so that we shouldn't be\n-  // allowing media to played through webaudio.\n-  // TODO(crbug.com/845913): This should really be on an AudioContext.  Move\n-  // this when we move the media stuff from BaseAudioContext to AudioContext, as\n-  // requried by the spec.\n-  bool WouldTaintOrigin(const KURL& url) const;\n-\n  protected:\n   enum ContextType { kRealtimeContext, kOfflineContext };\n ""}<_**next**_>{""sha"": ""d7b07b5fea75809b4e14c8fda74b38a1d48e6b9d"", ""filename"": ""third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 13, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -136,19 +136,7 @@ void MediaElementAudioSourceHandler::SetFormat(size_t number_of_channels,\n }\n \n bool MediaElementAudioSourceHandler::WouldTaintOrigin() {\n-  // If we're cross-origin and allowed access vie CORS, we're not tainted.\n-  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {\n-    return false;\n-  }\n-\n-  // Handles the case where the url is a redirect to another site that we're not\n-  // allowed to access.\n-  if (!MediaElement()->HasSingleSecurityOrigin()) {\n-    return true;\n-  }\n-\n-  // Test to see if the current media URL taint the origin of the audio context?\n-  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());\n+  return MediaElement()->GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n void MediaElementAudioSourceHandler::PrintCORSMessage(const String& message) {""}<_**next**_>{""sha"": ""6e5771836bf84527d922a6c5fc84a3aa5c8c9bce"", ""filename"": ""third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/testing/empty_web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -50,9 +50,7 @@ class EmptyWebMediaPlayer : public WebMediaPlayer {\n   ReadyState GetReadyState() const override { return kReadyStateHaveNothing; }\n   WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override { return false; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double time_value) const override {\n     return time_value;\n   };""}","bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {
","bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {
  if (url.ProtocolIsData()) {
    return false;
  }
  Document* document = GetDocument();
  if (document && document->GetSecurityOrigin()) {
    return !document->GetSecurityOrigin()->CanRequest(url);
  }
  return true;
}
",C,,"  if (url.ProtocolIsData()) {
    return false;
  }
  Document* document = GetDocument();
  if (document && document->GetSecurityOrigin()) {
    return !document->GetSecurityOrigin()->CanRequest(url);
  }
  return true;
}
",,"@@ -958,21 +958,4 @@ void BaseAudioContext::UpdateWorkletGlobalScopeOnRenderingThread() {
   }
 }
 
-bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {
-  // Data URLs don't taint the origin.
-  if (url.ProtocolIsData()) {
-    return false;
-  }
-
-  Document* document = GetDocument();
-  if (document && document->GetSecurityOrigin()) {
-    // The origin is tainted if and only if we cannot read content from the URL.
-    return !document->GetSecurityOrigin()->CanRequest(url);
-  }
-
-  // Be conservative and assume it's tainted if it's not a data url and if we
-  // can't get the security origin of the document.
-  return true;
-}
-
 }  // namespace blink",Chrome,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,50436d878b2e92de4231fda47328a8a4e884ecc3,1,"bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {
//flaw_line_below:
  // Data URLs don't taint the origin.
//flaw_line_below:
  if (url.ProtocolIsData()) {
//flaw_line_below:
    return false;
//flaw_line_below:
  }
//flaw_line_below:

//flaw_line_below:
  Document* document = GetDocument();
//flaw_line_below:
  if (document && document->GetSecurityOrigin()) {
//flaw_line_below:
    // The origin is tainted if and only if we cannot read content from the URL.
//flaw_line_below:
    return !document->GetSecurityOrigin()->CanRequest(url);
//flaw_line_below:
  }
//flaw_line_below:

//flaw_line_below:
  // Be conservative and assume it's tainted if it's not a data url and if we
//flaw_line_below:
  // can't get the security origin of the document.
//flaw_line_below:
  return true;
//flaw_line_below:
}
"
8875,186611,,Remote,Not required,,CVE-2018-18352,https://www.cvedetails.com/cve/CVE-2018-18352/,CWE-732,Medium,Partial,,,2018-12-11,4.3,Service works could inappropriately gain access to cross origin audio in Media in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to bypass same origin policy for audio content via a crafted HTML page.,2019-10-02,Bypass ,1,https://github.com/chromium/chromium/commit/a9cbaa7a40e2b2723cfc2f266c42f4980038a949,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,"Simplify ""WouldTaintOrigin"" concept in media/blink

Currently WebMediaPlayer has three predicates:
 - DidGetOpaqueResponseFromServiceWorker
 - HasSingleSecurityOrigin
 - DidPassCORSAccessCheck
. These are used to determine whether the response body is available
for scripts. They are known to be confusing, and actually
MediaElementAudioSourceHandler::WouldTaintOrigin misuses them.

This CL merges the three predicates to one, WouldTaintOrigin, to remove
the confusion. Now the ""response type"" concept is available and we
don't need a custom CORS check, so this CL removes
BaseAudioContext::WouldTaintOrigin. This CL also renames
URLData::has_opaque_data_ and its (direct and indirect) data accessors
to match the spec.

Bug: 849942, 875153
Change-Id: I6acf50169d7445c4ff614e80ac606f79ee577d2a
Reviewed-on: https://chromium-review.googlesource.com/c/1238098
Reviewed-by: Fredrik Hubinette <hubbe@chromium.org>
Reviewed-by: Kinuko Yasuda <kinuko@chromium.org>
Reviewed-by: Raymond Toy <rtoy@chromium.org>
Commit-Queue: Yutaka Hirano <yhirano@chromium.org>
Cr-Commit-Position: refs/heads/master@{#598258}",7,third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc,"{""sha"": ""78ca5e2c3c323cf55e23eacc262e8a197e60b63b"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 11, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -844,21 +844,11 @@ void WebMediaPlayerMS::Paint(cc::PaintCanvas* canvas,\n                         context_3d, context_support);\n }\n \n-bool WebMediaPlayerMS::DidGetOpaqueResponseFromServiceWorker() const {\n+bool WebMediaPlayerMS::WouldTaintOrigin() const {\n   DCHECK(thread_checker_.CalledOnValidThread());\n   return false;\n }\n \n-bool WebMediaPlayerMS::HasSingleSecurityOrigin() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n-bool WebMediaPlayerMS::DidPassCORSAccessCheck() const {\n-  DCHECK(thread_checker_.CalledOnValidThread());\n-  return true;\n-}\n-\n double WebMediaPlayerMS::MediaTimeForTimeValue(double timeValue) const {\n   return base::TimeDelta::FromSecondsD(timeValue).InSecondsF();\n }""}<_**next**_>{""sha"": ""8c3595505cb20fa379b861f49b28710c40f3a5f1"", ""filename"": ""content/renderer/media/stream/webmediaplayer_ms.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media/stream/webmediaplayer_ms.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media/stream/webmediaplayer_ms.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -163,9 +163,7 @@ class CONTENT_EXPORT WebMediaPlayerMS\n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n \n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n ""}<_**next**_>{""sha"": ""d26bc8142d80dc7c64958a9c22170244d6e664dd"", ""filename"": ""content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/media_capture_from_element/html_video_element_capturer_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -76,9 +76,7 @@ class MockWebMediaPlayer : public blink::WebMediaPlayer,\n   }\n \n   bool DidLoadingProgress() override { return true; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double timeValue) const override { return 0.0; }\n   unsigned DecodedFrameCount() const override { return 0; }\n   unsigned DroppedFrameCount() const override { return 0; }""}<_**next**_>{""sha"": ""74ad44546ee34afa79b4a1649710117f8532c5f4"", ""filename"": ""media/blink/multibuffer_data_source.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 19, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -286,23 +286,8 @@ bool MultibufferDataSource::HasSingleOrigin() {\n   return single_origin_;\n }\n \n-bool MultibufferDataSource::DidPassCORSAccessCheck() const {\n-  if (url_data()->cors_mode() == UrlData::CORS_UNSPECIFIED)\n-    return false;\n-\n-  // If init_cb is set, we know initialization is not finished yet.\n-  if (init_cb_)\n-    return false;\n-  if (failed_)\n-    return false;\n-  return true;\n-}\n-\n-bool MultibufferDataSource::DidGetOpaqueResponseViaServiceWorker() const {\n-  return url_data()->has_opaque_data();\n-\n-  // TODO(falken): Do we need to do something about |init_cb_| like\n-  // in DidPassCORSAccessCheck()?\n+bool MultibufferDataSource::IsCorsCrossOrigin() const {\n+  return url_data()->is_cors_cross_origin();\n }\n \n void MultibufferDataSource::MediaPlaybackRateChanged(double playback_rate) {\n@@ -627,8 +612,6 @@ void MultibufferDataSource::StartCallback() {\n     // Progress callback might be called after the start callback,\n     // make sure that we update single_origin_ now.\n     media_log_->SetBooleanProperty(\""single_origin\"", single_origin_);\n-    media_log_->SetBooleanProperty(\""passed_cors_access_check\"",\n-                                   DidPassCORSAccessCheck());\n     media_log_->SetBooleanProperty(\""range_header_supported\"",\n                                    url_data()->range_supported());\n   }""}<_**next**_>{""sha"": ""4da62a5519e33ab6e726406f0acac4995c4ad49f"", ""filename"": ""media/blink/multibuffer_data_source.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 6, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -79,12 +79,9 @@ class MEDIA_BLINK_EXPORT MultibufferDataSource : public DataSource {\n   // Method called on the render thread.\n   bool HasSingleOrigin();\n \n-  // Returns true if the media resource passed a CORS access control check.\n-  bool DidPassCORSAccessCheck() const;\n-\n-  // Returns true if a service worker provided the media resource response,\n-  // and the response was opaque.\n-  bool DidGetOpaqueResponseViaServiceWorker() const;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  // This must be called after the response arrives.\n+  bool IsCorsCrossOrigin() const;\n \n   // Notifies changes in playback state for controlling media buffering\n   // behavior.""}<_**next**_>{""sha"": ""4b9f83e74255bf14d33c3f0c2785c282ecb2bcd7"", ""filename"": ""media/blink/multibuffer_data_source_unittest.cc"", ""status"": ""modified"", ""additions"": 81, ""deletions"": 12, ""changes"": 93, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/multibuffer_data_source_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/multibuffer_data_source_unittest.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1493,35 +1493,104 @@ TEST_F(MultibufferDataSourceTest, FileSizeLessThanBlockSize) {\n   Stop();\n }\n \n-TEST_F(MultibufferDataSourceTest, DidPassCORSAccessTest) {\n+TEST_F(MultibufferDataSourceTest, ResponseTypeBasic) {\n   InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n   set_preload(MultibufferDataSource::NONE);\n   WebURLResponse response1 =\n       response_generator_->GeneratePartial206(0, kDataSize - 1);\n-  response1.SetWasFetchedViaServiceWorker(true);\n-  std::vector<blink::WebURL> urlList = {GURL(kHttpDifferentOriginUrl)};\n-  response1.SetURLListViaServiceWorker(urlList);\n-  WebURLResponse response2 =\n-      response_generator_->GeneratePartial206(kDataSize, kDataSize * 2 - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kBasic);\n \n   EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n   EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n   EXPECT_CALL(*this, ReadCallback(kDataSize));\n \n-  EXPECT_FALSE(data_source_->DidPassCORSAccessCheck());\n   Respond(response1);\n   ReceiveData(kDataSize);\n   ReadAt(0);\n   EXPECT_TRUE(loading());\n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n   FinishLoading();\n+}\n \n-  // Verify that if reader_ is null, DidPassCORSAccessCheck still returns true.\n-  data_source_->Stop();\n-  base::RunLoop().RunUntilIdle();\n+TEST_F(MultibufferDataSourceTest, ResponseTypeCors) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kCORS);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeDefault) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kDefault);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_FALSE(data_source_->IsCorsCrossOrigin());\n \n-  EXPECT_TRUE(data_source_->DidPassCORSAccessCheck());\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaque) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaque);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n+}\n+\n+TEST_F(MultibufferDataSourceTest, ResponseTypeOpaqueRedirect) {\n+  InitializeWithCORS(kHttpUrl, true, UrlData::CORS_ANONYMOUS);\n+  set_preload(MultibufferDataSource::NONE);\n+  WebURLResponse response1 =\n+      response_generator_->GeneratePartial206(0, kDataSize - 1);\n+  response1.SetType(network::mojom::FetchResponseType::kOpaqueRedirect);\n+\n+  EXPECT_CALL(host_, SetTotalBytes(kFileSize));\n+  EXPECT_CALL(host_, AddBufferedByteRange(0, kDataSize));\n+  EXPECT_CALL(*this, ReadCallback(kDataSize));\n+\n+  Respond(response1);\n+  ReceiveData(kDataSize);\n+  ReadAt(0);\n+  EXPECT_TRUE(loading());\n+  EXPECT_TRUE(data_source_->IsCorsCrossOrigin());\n+\n+  FinishLoading();\n }\n \n TEST_F(MultibufferDataSourceTest, EtagTest) {""}<_**next**_>{""sha"": ""89f1c9e70d2cc71646df50026b50d54d471d20c6"", ""filename"": ""media/blink/resource_multibuffer_data_provider.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/resource_multibuffer_data_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/resource_multibuffer_data_provider.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -280,6 +280,8 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n   int64_t content_length = response.ExpectedContentLength();\n   bool end_of_file = false;\n   bool do_fail = false;\n+  // We get the response type here because aborting the loader may change it.\n+  const auto response_type = response.GetType();\n   bytes_to_discard_ = 0;\n \n   // We make a strong assumption that when we reach here we have either\n@@ -333,10 +335,9 @@ void ResourceMultiBufferDataProvider::DidReceiveResponse(\n         url_data_->url_index()->TryInsert(destination_url_data);\n   }\n \n-  // This is vital for security! A service worker can respond with a response\n-  // from a different origin, so this response type is needed to detect that.\n-  destination_url_data->set_has_opaque_data(\n-      network::cors::IsCORSCrossOriginResponseType(response.GetType()));\n+  // This is vital for security!\n+  destination_url_data->set_is_cors_cross_origin(\n+      network::cors::IsCORSCrossOriginResponseType(response_type));\n \n   if (destination_url_data != url_data_) {\n     // At this point, we've encountered a redirect, or found a better url data""}<_**next**_>{""sha"": ""3fb63497791a3d2a0ea1e3b12c018f4b2c5fe355"", ""filename"": ""media/blink/url_index.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 7, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -65,7 +65,6 @@ UrlData::UrlData(const GURL& url, CORSMode cors_mode, UrlIndex* url_index)\n       length_(kPositionNotSpecified),\n       range_supported_(false),\n       cacheable_(false),\n-      has_opaque_data_(false),\n       last_used_(),\n       multibuffer_(this, url_index_->block_shift_) {}\n \n@@ -103,9 +102,8 @@ void UrlData::MergeFrom(const scoped_refptr<UrlData>& other) {\n       last_modified_ = other->last_modified_;\n     }\n     bytes_read_from_cache_ += other->bytes_read_from_cache_;\n-    // set_has_opaque_data() will not relax from opaque to non-opaque if already\n-    // opaque.\n-    set_has_opaque_data(other->has_opaque_data_);\n+    // is_cors_corss_origin_ will not relax from true to false.\n+    set_is_cors_cross_origin(other->is_cors_cross_origin_);\n     multibuffer()->MergeFrom(other->multibuffer());\n   }\n }\n@@ -122,10 +120,10 @@ void UrlData::set_length(int64_t length) {\n   }\n }\n \n-void UrlData::set_has_opaque_data(bool has_opaque_data) {\n-  if (has_opaque_data_)\n+void UrlData::set_is_cors_cross_origin(bool is_cors_cross_origin) {\n+  if (is_cors_cross_origin_)\n     return;\n-  has_opaque_data_ = has_opaque_data;\n+  is_cors_cross_origin_ = is_cors_cross_origin;\n }\n \n void UrlData::RedirectTo(const scoped_refptr<UrlData>& url_data) {""}<_**next**_>{""sha"": ""2c15bc7ac0ad4489a0c922f614889e575bd5d863"", ""filename"": ""media/blink/url_index.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/url_index.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/url_index.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -125,7 +125,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // Returns our url_index.\n   UrlIndex* url_index() const { return url_index_; }\n \n-  bool has_opaque_data() const { return has_opaque_data_; }\n+  // This must be called after the response arrives.\n+  bool is_cors_cross_origin() const { return is_cors_cross_origin_; }\n \n   // Notifies the url index that this is currently used.\n   // The url <-> URLData mapping will be eventually be invalidated if\n@@ -145,7 +146,7 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   void set_range_supported();\n   void set_last_modified(base::Time last_modified);\n   void set_etag(const std::string& etag);\n-  void set_has_opaque_data(bool has_opaque_data);\n+  void set_is_cors_cross_origin(bool is_cors_cross_origin);\n \n   // A redirect has occured (or we've found a better UrlData for the same\n   // resource).\n@@ -238,9 +239,8 @@ class MEDIA_BLINK_EXPORT UrlData : public base::RefCounted<UrlData> {\n   // will not cache this url.\n   bool cacheable_;\n \n-  // True if a service worker intercepted a request for this resource\n-  // and provided an opaque response.\n-  bool has_opaque_data_;\n+  // https://html.spec.whatwg.org/#cors-cross-origin\n+  bool is_cors_cross_origin_ = false;\n \n   // Last time some media time used this resource.\n   // Note that we use base::Time rather than base::TimeTicks because""}<_**next**_>{""sha"": ""cf0857d8c6283758b159609f76da1bafb19cc789"", ""filename"": ""media/blink/webmediaplayer_impl.cc"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 10, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1175,12 +1175,6 @@ void WebMediaPlayerImpl::Paint(cc::PaintCanvas* canvas,\n       context_support);\n }\n \n-bool WebMediaPlayerImpl::DidGetOpaqueResponseFromServiceWorker() const {\n-  if (data_source_)\n-    return data_source_->DidGetOpaqueResponseViaServiceWorker();\n-  return false;\n-}\n-\n bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   if (demuxer_found_hls_) {\n     // HLS manifests might pull segments from a different origin. We can't know\n@@ -1193,10 +1187,15 @@ bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   return true;\n }\n \n-bool WebMediaPlayerImpl::DidPassCORSAccessCheck() const {\n-  if (data_source_)\n-    return data_source_->DidPassCORSAccessCheck();\n-  return false;\n+bool WebMediaPlayerImpl::WouldTaintOrigin() const {\n+  if (!HasSingleSecurityOrigin()) {\n+    // When the resource is redirected to another origin we think it as\n+    // tainted. This is actually not specified, and is under discussion.\n+    // See https://github.com/whatwg/fetch/issues/737.\n+    return true;\n+  }\n+\n+  return data_source_ && data_source_->IsCorsCrossOrigin();\n }\n \n double WebMediaPlayerImpl::MediaTimeForTimeValue(double timeValue) const {""}<_**next**_>{""sha"": ""233e37b4614544e9b2a67b4e5edee775de0f79a6"", ""filename"": ""media/blink/webmediaplayer_impl.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/media/blink/webmediaplayer_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/webmediaplayer_impl.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -188,10 +188,7 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n \n   blink::WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override;\n-\n-  bool DidGetOpaqueResponseFromServiceWorker() const override;\n-  bool HasSingleSecurityOrigin() const override;\n-  bool DidPassCORSAccessCheck() const override;\n+  bool WouldTaintOrigin() const override;\n \n   double MediaTimeForTimeValue(double timeValue) const override;\n \n@@ -332,6 +329,8 @@ class MEDIA_BLINK_EXPORT WebMediaPlayerImpl\n   void OnPipelineResumed();\n   void OnDemuxerOpened();\n \n+  bool HasSingleSecurityOrigin() const;\n+\n   // Pipeline::Client overrides.\n   void OnError(PipelineStatus status) override;\n   void OnEnded() override;""}<_**next**_>{""sha"": ""9821759bc7b311672a54387edc7d8c26a11d5e54"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""status"": ""added"", ""additions"": 47, ""deletions"": 0, ""changes"": 47, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-audio-tainting.https.html?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -0,0 +1,47 @@\n+<!doctype html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+<script src=\""/common/get-host-info.sub.js\""></script>\n+<script src=\""resources/test-helpers.sub.js?pipe=sub\""></script>\n+<script>\n+promise_test(async (t) => {\n+    const SCOPE = 'resources/empty.html';\n+    const SCRIPT = 'resources/fetch-rewrite-worker.js';\n+    const host_info = get_host_info();\n+    const REMOTE_ORIGIN = host_info.HTTPS_REMOTE_ORIGIN;\n+\n+    const reg = await service_worker_unregister_and_register(t, SCRIPT, SCOPE);\n+    await wait_for_state(t, reg.installing, 'activated');\n+    const frame = await with_iframe(SCOPE);\n+\n+    const doc = frame.contentDocument;\n+    const win = frame.contentWindow;\n+\n+    const context = new win.AudioContext();\n+    try {\n+      context.suspend();\n+      const audio = doc.createElement('audio');\n+      audio.autoplay = true;\n+      const source = context.createMediaElementSource(audio);\n+      const spn = context.createScriptProcessor(16384, 1, 1);\n+      source.connect(spn).connect(context.destination);\n+      const url = `${REMOTE_ORIGIN}/webaudio/resources/sin_440Hz_-6dBFS_1s.wav`;\n+      audio.src = '/test?url=' + encodeURIComponent(url);\n+      doc.body.appendChild(audio);\n+\n+      await new Promise((resolve) => {\n+        audio.addEventListener('playing', resolve);\n+      });\n+      await context.resume();\n+      const event = await new Promise((resolve) => {\n+        spn.addEventListener('audioprocess', resolve);\n+      });\n+      const data = event.inputBuffer.getChannelData(0);\n+      for (const e of data) {\n+        assert_equals(e, 0);\n+      }\n+    } finally {\n+      context.close();\n+    }\n+  }, 'Verify CORS XHR of fetch() in a Service Worker');\n+</script>""}<_**next**_>{""sha"": ""319648dbc16669ab3b3238d8488997b7d3a7c837"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video-cache.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&cache=true&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26cache%3Dtrue%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""58697c0661a94d03e4bbe74134a23e71a860f5f6"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/50436d878b2e92de4231fda47328a8a4e884ecc3/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/service-workers/service-worker/fetch-canvas-tainting-video.https-expected.txt?ref=50436d878b2e92de4231fda47328a8a4e884ecc3"", ""patch"": ""@@ -1,43 +0,0 @@\n-This is a testharness.js-based test.\n-PASS initialize global state\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&reject\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ignore\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&Auth&ACAOrigin=https://web-platform.test:8444&ACACredentials=true&ignore\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=same-origin&url=https%3A%2F%2Fweb-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""\"" should be TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""anonymous\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=no-cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be LOAD_ERROR\n-FAIL url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&credentials=same-origin&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""\"" should be NOT_TAINTED assert_equals: expected \""NOT_TAINTED\"" but got \""TAINTED\""\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""anonymous\"" should be NOT_TAINTED\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be LOAD_ERROR\n-PASS url \""https://www1.web-platform.test:8444/service-workers/service-worker/resources/fetch-access-control.py?VIDEO&mode=cors&url=https%3A%2F%2Fwww1.web-platform.test%3A8444%2Fservice-workers%2Fservice-worker%2Fresources%2Ffetch-access-control.py%3FVIDEO%26ACACredentials%3Dtrue%26ACAOrigin%3Dhttps%3A%2F%2Fweb-platform.test%3A8444\"" with crossOrigin \""use-credentials\"" should be NOT_TAINTED\n-PASS restore global state\n-Harness: the test ran to completion.\n-""}<_**next**_>{""sha"": ""a1e82caf7e2f9d37d785165a4766f42acb28c465"", ""filename"": ""third_party/blink/public/platform/web_media_player.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/public/platform/web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/public/platform/web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -207,9 +207,10 @@ class WebMediaPlayer {\n \n   virtual bool DidLoadingProgress() = 0;\n \n-  virtual bool DidGetOpaqueResponseFromServiceWorker() const = 0;\n-  virtual bool HasSingleSecurityOrigin() const = 0;\n-  virtual bool DidPassCORSAccessCheck() const = 0;\n+  // Returns true if the response is CORS-cross-origin and so we shouldn't be\n+  // allowing media to play through webaudio.\n+  // This should be called after the response has arrived.\n+  virtual bool WouldTaintOrigin() const = 0;\n \n   virtual double MediaTimeForTimeValue(double time_value) const = 0;\n ""}<_**next**_>{""sha"": ""ad708c861bb80cd8a01217eec51f9fe058af4a33"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 21, ""changes"": 26, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -1506,30 +1506,14 @@ bool HTMLMediaElement::IsSafeToLoadURL(const KURL& url,\n \n bool HTMLMediaElement::IsMediaDataCORSSameOrigin(\n     const SecurityOrigin* origin) const {\n-  // If a service worker handled the request, we don't know if the origin in the\n-  // src is the same as the actual response URL so can't rely on URL checks\n-  // alone. So detect an opaque response via\n-  // DidGetOpaqueResponseFromServiceWorker().\n-  if (GetWebMediaPlayer() &&\n-      GetWebMediaPlayer()->DidGetOpaqueResponseFromServiceWorker()) {\n-    return false;\n-  }\n-\n-  // At this point, either a service worker was not used, or it didn't provide\n-  // an opaque response, so continue with the normal checks.\n+  if (!GetWebMediaPlayer())\n+    return true;\n \n-  // HasSingleSecurityOrigin() tells us whether the origin in the src\n-  // is the same as the actual request (i.e. after redirects).\n-  if (!HasSingleSecurityOrigin())\n+  const auto network_state = GetWebMediaPlayer()->GetNetworkState();\n+  if (network_state == WebMediaPlayer::kNetworkStateNetworkError)\n     return false;\n \n-  // DidPassCORSAccessCheck() means it was a successful CORS-enabled fetch (vs.\n-  // non-CORS-enabled or failed). CanReadContent() does CheckAccess() on the\n-  // URL plus allows data sources, to ensure that it is not a URL that requires\n-  // CORS (basically same origin).\n-  return (GetWebMediaPlayer() &&\n-          GetWebMediaPlayer()->DidPassCORSAccessCheck()) ||\n-         origin->CanReadContent(currentSrc());\n+  return !GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n bool HTMLMediaElement::IsInCrossOriginFrame() const {""}<_**next**_>{""sha"": ""f2d50264a53a0a3002725b06b6363091f4e17faa"", ""filename"": ""third_party/blink/renderer/core/html/media/html_media_element.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/core/html/media/html_media_element.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/html/media/html_media_element.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -268,11 +268,6 @@ class CORE_EXPORT HTMLMediaElement\n   // of one of them here.\n   using HTMLElement::GetExecutionContext;\n \n-  bool HasSingleSecurityOrigin() const {\n-    return GetWebMediaPlayer() ? GetWebMediaPlayer()->HasSingleSecurityOrigin()\n-                               : true;\n-  }\n-\n   bool IsFullscreen() const;\n   virtual bool UsesOverlayFullscreenVideo() const { return false; }\n ""}<_**next**_>{""sha"": ""8cf3a926979a853d0ba0f48f9def6bc9b4aec36a"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 17, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -958,21 +958,4 @@ void BaseAudioContext::UpdateWorkletGlobalScopeOnRenderingThread() {\n   }\n }\n \n-bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {\n-  // Data URLs don't taint the origin.\n-  if (url.ProtocolIsData()) {\n-    return false;\n-  }\n-\n-  Document* document = GetDocument();\n-  if (document && document->GetSecurityOrigin()) {\n-    // The origin is tainted if and only if we cannot read content from the URL.\n-    return !document->GetSecurityOrigin()->CanRequest(url);\n-  }\n-\n-  // Be conservative and assume it's tainted if it's not a data url and if we\n-  // can't get the security origin of the document.\n-  return true;\n-}\n-\n }  // namespace blink""}<_**next**_>{""sha"": ""ae933f20167fb374b51ff5a869d9381f97b56d4b"", ""filename"": ""third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/base_audio_context.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/base_audio_context.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -296,13 +296,6 @@ class MODULES_EXPORT BaseAudioContext\n   // Does nothing when the worklet global scope does not exist.\n   void UpdateWorkletGlobalScopeOnRenderingThread();\n \n-  // Returns true if the URL would taint the origin so that we shouldn't be\n-  // allowing media to played through webaudio.\n-  // TODO(crbug.com/845913): This should really be on an AudioContext.  Move\n-  // this when we move the media stuff from BaseAudioContext to AudioContext, as\n-  // requried by the spec.\n-  bool WouldTaintOrigin(const KURL& url) const;\n-\n  protected:\n   enum ContextType { kRealtimeContext, kOfflineContext };\n ""}<_**next**_>{""sha"": ""d7b07b5fea75809b4e14c8fda74b38a1d48e6b9d"", ""filename"": ""third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 13, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/modules/webaudio/media_element_audio_source_node.cc?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -136,19 +136,7 @@ void MediaElementAudioSourceHandler::SetFormat(size_t number_of_channels,\n }\n \n bool MediaElementAudioSourceHandler::WouldTaintOrigin() {\n-  // If we're cross-origin and allowed access vie CORS, we're not tainted.\n-  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {\n-    return false;\n-  }\n-\n-  // Handles the case where the url is a redirect to another site that we're not\n-  // allowed to access.\n-  if (!MediaElement()->HasSingleSecurityOrigin()) {\n-    return true;\n-  }\n-\n-  // Test to see if the current media URL taint the origin of the audio context?\n-  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());\n+  return MediaElement()->GetWebMediaPlayer()->WouldTaintOrigin();\n }\n \n void MediaElementAudioSourceHandler::PrintCORSMessage(const String& message) {""}<_**next**_>{""sha"": ""6e5771836bf84527d922a6c5fc84a3aa5c8c9bce"", ""filename"": ""third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a9cbaa7a40e2b2723cfc2f266c42f4980038a949/third_party/blink/renderer/platform/testing/empty_web_media_player.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/testing/empty_web_media_player.h?ref=a9cbaa7a40e2b2723cfc2f266c42f4980038a949"", ""patch"": ""@@ -50,9 +50,7 @@ class EmptyWebMediaPlayer : public WebMediaPlayer {\n   ReadyState GetReadyState() const override { return kReadyStateHaveNothing; }\n   WebString GetErrorMessage() const override;\n   bool DidLoadingProgress() override { return false; }\n-  bool DidGetOpaqueResponseFromServiceWorker() const override { return false; }\n-  bool HasSingleSecurityOrigin() const override { return true; }\n-  bool DidPassCORSAccessCheck() const override { return true; }\n+  bool WouldTaintOrigin() const override { return false; }\n   double MediaTimeForTimeValue(double time_value) const override {\n     return time_value;\n   };""}"," bool MediaElementAudioSourceHandler::WouldTaintOrigin() {
  return MediaElement()->GetWebMediaPlayer()->WouldTaintOrigin();
 }
"," bool MediaElementAudioSourceHandler::WouldTaintOrigin() {
  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {
    return false;
  }
  if (!MediaElement()->HasSingleSecurityOrigin()) {
    return true;
  }
  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());
 }
",C,"  return MediaElement()->GetWebMediaPlayer()->WouldTaintOrigin();
","  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {
    return false;
  }
  if (!MediaElement()->HasSingleSecurityOrigin()) {
    return true;
  }
  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());
",,"@@ -136,19 +136,7 @@ void MediaElementAudioSourceHandler::SetFormat(size_t number_of_channels,
 }
 
 bool MediaElementAudioSourceHandler::WouldTaintOrigin() {
-  // If we're cross-origin and allowed access vie CORS, we're not tainted.
-  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {
-    return false;
-  }
-
-  // Handles the case where the url is a redirect to another site that we're not
-  // allowed to access.
-  if (!MediaElement()->HasSingleSecurityOrigin()) {
-    return true;
-  }
-
-  // Test to see if the current media URL taint the origin of the audio context?
-  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());
+  return MediaElement()->GetWebMediaPlayer()->WouldTaintOrigin();
 }
 
 void MediaElementAudioSourceHandler::PrintCORSMessage(const String& message) {",Chrome,a9cbaa7a40e2b2723cfc2f266c42f4980038a949,50436d878b2e92de4231fda47328a8a4e884ecc3,1," bool MediaElementAudioSourceHandler::WouldTaintOrigin() {
//flaw_line_below:
  // If we're cross-origin and allowed access vie CORS, we're not tainted.
//flaw_line_below:
  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {
//flaw_line_below:
    return false;
//flaw_line_below:
  }
//flaw_line_below:

//flaw_line_below:
  // Handles the case where the url is a redirect to another site that we're not
//flaw_line_below:
  // allowed to access.
//flaw_line_below:
  if (!MediaElement()->HasSingleSecurityOrigin()) {
//flaw_line_below:
    return true;
//flaw_line_below:
  }
//flaw_line_below:

//flaw_line_below:
  // Test to see if the current media URL taint the origin of the audio context?
//flaw_line_below:
  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());
//fix_flaw_line_below:
//  return MediaElement()->GetWebMediaPlayer()->WouldTaintOrigin();
 }
"
8924,186660,,Remote,Not required,,CVE-2018-6040,https://www.cvedetails.com/cve/CVE-2018-6040/,CWE-732,Medium,,Partial,,2018-09-25,4.3,Insufficient policy enforcement in Blink in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to potentially bypass content security policy via a crafted HTML page.,2019-10-02,Bypass ,2,https://github.com/chromium/chromium/commit/209f225b2d51334eaf69ffdf002e25eaa1e0d448,209f225b2d51334eaf69ffdf002e25eaa1e0d448,"Fixed bug where PlzNavigate CSP in a iframe did not get the inherited CSP

When inheriting the CSP from a parent document to a local-scheme CSP,
it does not always get propagated to the PlzNavigate CSP. This means
that PlzNavigate CSP checks (like `frame-src`) would be ran against
a blank policy instead of the proper inherited policy.

Bug: 778658
Change-Id: I61bb0d432e1cea52f199e855624cb7b3078f56a9
Reviewed-on: https://chromium-review.googlesource.com/765969
Commit-Queue: Andy Paicu <andypaicu@chromium.org>
Reviewed-by: Mike West <mkwst@chromium.org>
Cr-Commit-Position: refs/heads/master@{#518245}",1,third_party/WebKit/Source/core/dom/Document.cpp,"{""sha"": ""700349a8a1da3a2c461a70389684c3d2a7f9f96b"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/generic/policy-inherited-correctly-by-plznavigate.html"", ""status"": ""added"", ""additions"": 39, ""deletions"": 0, ""changes"": 39, ""blob_url"": ""https://github.com/chromium/chromium/blob/209f225b2d51334eaf69ffdf002e25eaa1e0d448/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/generic/policy-inherited-correctly-by-plznavigate.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/209f225b2d51334eaf69ffdf002e25eaa1e0d448/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/generic/policy-inherited-correctly-by-plznavigate.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/generic/policy-inherited-correctly-by-plznavigate.html?ref=209f225b2d51334eaf69ffdf002e25eaa1e0d448"", ""patch"": ""@@ -0,0 +1,39 @@\n+<!DOCTYPE HTML>\n+<html>\n+<head>\n+  <!-- This tests a bug that can occur when content layer CSP is not told\n+       about the CSP inherited from the parent document which leads to it not\n+       applying it to content layer CSP checks (such as frame-src with\n+       PlzNavigate on).\n+       Also see crbug.com/778658. -->\n+  <script src='/resources/testharness.js'></script>\n+  <script src='/resources/testharnessreport.js'></script>\n+</head>\n+<body>\n+  <script>\n+    var t = async_test(\""iframe still inherits correct CSP\"");\n+  </script>\n+\n+  <iframe id=\""x\"" srcdoc=\""<a href='about:blank'>123</a>\""></iframe>\n+\n+  <script>\n+    window.onmessage = t.step_func_done(function(e) {\n+      assert_equals(e.data, \""frame-src\"");\n+    });\n+\n+    x = document.getElementById('x');\n+    x.location = \""\"";\n+\n+    // While document.write is deprecated I did not find another way to reproduce\n+    // the original exploit.\n+    x.contentDocument.write(\n+      '<script>window.addEventListener(\""securitypolicyviolation\"", function(e) {' +\n+      '  window.top.postMessage(e.violatedDirective, \""*\"");' +\n+      '});</scr' + 'ipt>' +\n+      '<iframe src=\""../support/fail.html\""></iframe>'\n+    );\n+    x.contentDocument.close();\n+  </script>\n+  <script async defer src='../support/checkReport.sub.js?reportField=violated-directive&reportValue=frame-src%20%27none%27''></script>\n+</body>\n+</html>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""64653e3bf1a1a40e3c88e9b628fa94d5bf22403e"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/generic/policy-inherited-correctly-by-plznavigate.html.sub.headers"", ""status"": ""added"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/209f225b2d51334eaf69ffdf002e25eaa1e0d448/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/generic/policy-inherited-correctly-by-plznavigate.html.sub.headers"", ""raw_url"": ""https://github.com/chromium/chromium/raw/209f225b2d51334eaf69ffdf002e25eaa1e0d448/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/generic/policy-inherited-correctly-by-plznavigate.html.sub.headers"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/generic/policy-inherited-correctly-by-plznavigate.html.sub.headers?ref=209f225b2d51334eaf69ffdf002e25eaa1e0d448"", ""patch"": ""@@ -0,0 +1,5 @@\n+Expires: Mon, 26 Jul 1997 05:00:00 GMT\n+Cache-Control: no-store, no-cache, must-revalidate\n+Pragma: no-cache\n+Set-Cookie: policy-inherited-correctly-by-plznavigate={{$id:uuid()}}; Path=/content-security-policy/generic/\n+Content-Security-Policy: frame-src 'none'; script-src 'self' 'unsafe-inline'; report-uri  ../support/report.py?op=put&reportID={{$id}}\n\\ No newline at end of file""}<_**next**_>{""sha"": ""fedcc31bd3da124cd298e7255467c4854778f04b"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/support/fail.html"", ""status"": ""added"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/209f225b2d51334eaf69ffdf002e25eaa1e0d448/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/support/fail.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/209f225b2d51334eaf69ffdf002e25eaa1e0d448/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/support/fail.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/support/fail.html?ref=209f225b2d51334eaf69ffdf002e25eaa1e0d448"", ""patch"": ""@@ -0,0 +1,3 @@\n+<script>\n+  test(function() { assert_unreached(\""FAIL\"")});\n+</script>\n\\ No newline at end of file""}<_**next**_>{""sha"": ""fb381f19f183c465e5601bf855042e518f477648"", ""filename"": ""third_party/WebKit/Source/core/dom/Document.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/209f225b2d51334eaf69ffdf002e25eaa1e0d448/third_party/WebKit/Source/core/dom/Document.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/209f225b2d51334eaf69ffdf002e25eaa1e0d448/third_party/WebKit/Source/core/dom/Document.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Document.cpp?ref=209f225b2d51334eaf69ffdf002e25eaa1e0d448"", ""patch"": ""@@ -6140,6 +6140,8 @@ void Document::InitContentSecurityPolicy(\n     const ContentSecurityPolicy* policy_to_inherit) {\n   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());\n \n+  GetContentSecurityPolicy()->BindToExecutionContext(this);\n+\n   // We inherit the parent/opener's CSP for documents with \""local\"" schemes:\n   // 'about', 'blob', 'data', and 'filesystem'. We also inherit CSP for\n   // documents with empty/invalid URLs because we treat those URLs as\n@@ -6169,8 +6171,6 @@ void Document::InitContentSecurityPolicy(\n   // regardless of URL.\n   if (policy_to_inherit && IsPluginDocument())\n     GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);\n-\n-  GetContentSecurityPolicy()->BindToExecutionContext(this);\n }\n \n bool Document::IsSecureTransitionTo(const KURL& url) const {""}","void Document::InitContentSecurityPolicy(
    ContentSecurityPolicy* csp,
     const ContentSecurityPolicy* policy_to_inherit) {
   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());
 
  GetContentSecurityPolicy()->BindToExecutionContext(this);

  if (policy_to_inherit) {
    GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
  } else if (frame_) {
    Frame* inherit_from = frame_->Tree().Parent() ? frame_->Tree().Parent()
                                                  : frame_->Client()->Opener();
    if (inherit_from && frame_ != inherit_from) {
      DCHECK(inherit_from->GetSecurityContext() &&
             inherit_from->GetSecurityContext()->GetContentSecurityPolicy());
      policy_to_inherit =
          inherit_from->GetSecurityContext()->GetContentSecurityPolicy();
      if (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||
          url_.ProtocolIs(""blob"") || url_.ProtocolIs(""filesystem"")) {
        GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
      }
    }
  }
   if (policy_to_inherit && IsPluginDocument())
     GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);
 }
","void Document::InitContentSecurityPolicy(
    ContentSecurityPolicy* csp,
     const ContentSecurityPolicy* policy_to_inherit) {
   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());
 
  if (policy_to_inherit) {
    GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
  } else if (frame_) {
    Frame* inherit_from = frame_->Tree().Parent() ? frame_->Tree().Parent()
                                                  : frame_->Client()->Opener();
    if (inherit_from && frame_ != inherit_from) {
      DCHECK(inherit_from->GetSecurityContext() &&
             inherit_from->GetSecurityContext()->GetContentSecurityPolicy());
      policy_to_inherit =
          inherit_from->GetSecurityContext()->GetContentSecurityPolicy();
      if (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||
          url_.ProtocolIs(""blob"") || url_.ProtocolIs(""filesystem"")) {
        GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
      }
    }
  }
   if (policy_to_inherit && IsPluginDocument())
     GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);
  GetContentSecurityPolicy()->BindToExecutionContext(this);
 }
",C,"  GetContentSecurityPolicy()->BindToExecutionContext(this);

","  GetContentSecurityPolicy()->BindToExecutionContext(this);
",,"@@ -6140,6 +6140,8 @@ void Document::InitContentSecurityPolicy(
     const ContentSecurityPolicy* policy_to_inherit) {
   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());
 
+  GetContentSecurityPolicy()->BindToExecutionContext(this);
+
   // We inherit the parent/opener's CSP for documents with ""local"" schemes:
   // 'about', 'blob', 'data', and 'filesystem'. We also inherit CSP for
   // documents with empty/invalid URLs because we treat those URLs as
@@ -6169,8 +6171,6 @@ void Document::InitContentSecurityPolicy(
   // regardless of URL.
   if (policy_to_inherit && IsPluginDocument())
     GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);
-
-  GetContentSecurityPolicy()->BindToExecutionContext(this);
 }
 
 bool Document::IsSecureTransitionTo(const KURL& url) const {",Chrome,209f225b2d51334eaf69ffdf002e25eaa1e0d448,daaa9faed34a50b6d218eb0f4c1f4f9b7de59885,1,"void Document::InitContentSecurityPolicy(
    ContentSecurityPolicy* csp,
     const ContentSecurityPolicy* policy_to_inherit) {
   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());
 
//fix_flaw_line_below:
//  GetContentSecurityPolicy()->BindToExecutionContext(this);
//fix_flaw_line_below:
//
   // We inherit the parent/opener's CSP for documents with ""local"" schemes:
   // 'about', 'blob', 'data', and 'filesystem'. We also inherit CSP for
   // documents with empty/invalid URLs because we treat those URLs as
  // 'about:blank' in Blink.
  //
  // https://w3c.github.io/webappsec-csp/#initialize-document-csp
  //
  // TODO(dcheng): This is similar enough to work we're doing in
  // 'DocumentLoader::ensureWriter' that it might make sense to combine them.
  if (policy_to_inherit) {
    GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
  } else if (frame_) {
    Frame* inherit_from = frame_->Tree().Parent() ? frame_->Tree().Parent()
                                                  : frame_->Client()->Opener();
    if (inherit_from && frame_ != inherit_from) {
      DCHECK(inherit_from->GetSecurityContext() &&
             inherit_from->GetSecurityContext()->GetContentSecurityPolicy());
      policy_to_inherit =
          inherit_from->GetSecurityContext()->GetContentSecurityPolicy();
      if (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||
          url_.ProtocolIs(""blob"") || url_.ProtocolIs(""filesystem"")) {
        GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
      }
    }
  }
  // Plugin documents inherit their parent/opener's 'plugin-types' directive
   // regardless of URL.
   if (policy_to_inherit && IsPluginDocument())
     GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);
//flaw_line_below:

//flaw_line_below:
  GetContentSecurityPolicy()->BindToExecutionContext(this);
 }
"
9059,186795,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,2,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",2,services/device/generic_sensor/fake_platform_sensor_and_provider.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}"," void FakePlatformSensorProvider::CreateSensorInternal(
     mojom::SensorType type,
    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);
   auto sensor =
      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);
   DoCreateSensorInternal(type, std::move(sensor), callback);
 }
"," void FakePlatformSensorProvider::CreateSensorInternal(
     mojom::SensorType type,
    mojo::ScopedSharedBufferMapping mapping,
     const CreateSensorCallback& callback) {
   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);
   auto sensor =
      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);
   DoCreateSensorInternal(type, std::move(sensor), callback);
 }
",C,"    SensorReadingSharedBuffer* reading_buffer,
      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);
","    mojo::ScopedSharedBufferMapping mapping,
      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);
",,"@@ -12,10 +12,11 @@ using ::testing::_;
 
 namespace device {
 
-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,
-                                       mojo::ScopedSharedBufferMapping mapping,
-                                       PlatformSensorProvider* provider)
-    : PlatformSensor(type, std::move(mapping), provider) {
+FakePlatformSensor::FakePlatformSensor(
+    mojom::SensorType type,
+    SensorReadingSharedBuffer* reading_buffer,
+    PlatformSensorProvider* provider)
+    : PlatformSensor(type, reading_buffer, provider) {
   ON_CALL(*this, StartSensor(_))
       .WillByDefault(
           Invoke([this](const PlatformSensorConfiguration& configuration) {
@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {
 
 FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;
 
-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(
+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(
     mojom::SensorType type) {
-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;
+  return CreateSharedBufferIfNeeded()
+             ? GetSensorReadingSharedBufferForType(type)
+             : nullptr;
 }
 
 void FakePlatformSensorProvider::CreateSensorInternal(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);
   auto sensor =
-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);
+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);
   DoCreateSensorInternal(type, std::move(sensor), callback);
 }
 ",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1," void FakePlatformSensorProvider::CreateSensorInternal(
     mojom::SensorType type,
//flaw_line_below:
    mojo::ScopedSharedBufferMapping mapping,
//fix_flaw_line_below:
//    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);
   auto sensor =
//flaw_line_below:
      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);
//fix_flaw_line_below:
//      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);
   DoCreateSensorInternal(type, std::move(sensor), callback);
 }
"
9060,186796,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,5,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",3,services/device/generic_sensor/fake_platform_sensor_and_provider.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}","FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,
FakePlatformSensor::FakePlatformSensor(
    mojom::SensorType type,
    SensorReadingSharedBuffer* reading_buffer,
    PlatformSensorProvider* provider)
    : PlatformSensor(type, reading_buffer, provider) {
   ON_CALL(*this, StartSensor(_))
       .WillByDefault(
           Invoke([this](const PlatformSensorConfiguration& configuration) {
            SensorReading reading;
            if (GetType() == mojom::SensorType::AMBIENT_LIGHT) {
              reading.als.value = configuration.frequency();
              UpdateSharedBufferAndNotifyClients(reading);
            }
            return true;
          }));
}
","FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,
                                       mojo::ScopedSharedBufferMapping mapping,
                                       PlatformSensorProvider* provider)
    : PlatformSensor(type, std::move(mapping), provider) {
   ON_CALL(*this, StartSensor(_))
       .WillByDefault(
           Invoke([this](const PlatformSensorConfiguration& configuration) {
            SensorReading reading;
            if (GetType() == mojom::SensorType::AMBIENT_LIGHT) {
              reading.als.value = configuration.frequency();
              UpdateSharedBufferAndNotifyClients(reading);
            }
            return true;
          }));
}
",C,"FakePlatformSensor::FakePlatformSensor(
    mojom::SensorType type,
    SensorReadingSharedBuffer* reading_buffer,
    PlatformSensorProvider* provider)
    : PlatformSensor(type, reading_buffer, provider) {
","                                       mojo::ScopedSharedBufferMapping mapping,
                                       PlatformSensorProvider* provider)
    : PlatformSensor(type, std::move(mapping), provider) {
",,"@@ -12,10 +12,11 @@ using ::testing::_;
 
 namespace device {
 
-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,
-                                       mojo::ScopedSharedBufferMapping mapping,
-                                       PlatformSensorProvider* provider)
-    : PlatformSensor(type, std::move(mapping), provider) {
+FakePlatformSensor::FakePlatformSensor(
+    mojom::SensorType type,
+    SensorReadingSharedBuffer* reading_buffer,
+    PlatformSensorProvider* provider)
+    : PlatformSensor(type, reading_buffer, provider) {
   ON_CALL(*this, StartSensor(_))
       .WillByDefault(
           Invoke([this](const PlatformSensorConfiguration& configuration) {
@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {
 
 FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;
 
-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(
+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(
     mojom::SensorType type) {
-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;
+  return CreateSharedBufferIfNeeded()
+             ? GetSensorReadingSharedBufferForType(type)
+             : nullptr;
 }
 
 void FakePlatformSensorProvider::CreateSensorInternal(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);
   auto sensor =
-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);
+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);
   DoCreateSensorInternal(type, std::move(sensor), callback);
 }
 ",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1,"FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,
//flaw_line_below:
                                       mojo::ScopedSharedBufferMapping mapping,
//flaw_line_below:
                                       PlatformSensorProvider* provider)
//flaw_line_below:
    : PlatformSensor(type, std::move(mapping), provider) {
//fix_flaw_line_below:
//FakePlatformSensor::FakePlatformSensor(
//fix_flaw_line_below:
//    mojom::SensorType type,
//fix_flaw_line_below:
//    SensorReadingSharedBuffer* reading_buffer,
//fix_flaw_line_below:
//    PlatformSensorProvider* provider)
//fix_flaw_line_below:
//    : PlatformSensor(type, reading_buffer, provider) {
   ON_CALL(*this, StartSensor(_))
       .WillByDefault(
           Invoke([this](const PlatformSensorConfiguration& configuration) {
            SensorReading reading;
            // Only mocking the shared memory update for AMBIENT_LIGHT type is
            // enough.
            if (GetType() == mojom::SensorType::AMBIENT_LIGHT) {
              // Set the shared buffer value as frequency for testing purpose.
              reading.als.value = configuration.frequency();
              UpdateSharedBufferAndNotifyClients(reading);
            }
            return true;
          }));
}
"
9061,186797,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,4,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",1,services/device/generic_sensor/fake_platform_sensor_and_provider.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}","mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(
SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(
     mojom::SensorType type) {
  return CreateSharedBufferIfNeeded()
             ? GetSensorReadingSharedBufferForType(type)
             : nullptr;
 }
","mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(
     mojom::SensorType type) {
  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;
 }
",C,"SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(
  return CreateSharedBufferIfNeeded()
             ? GetSensorReadingSharedBufferForType(type)
             : nullptr;
","  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;
",,"@@ -12,10 +12,11 @@ using ::testing::_;
 
 namespace device {
 
-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,
-                                       mojo::ScopedSharedBufferMapping mapping,
-                                       PlatformSensorProvider* provider)
-    : PlatformSensor(type, std::move(mapping), provider) {
+FakePlatformSensor::FakePlatformSensor(
+    mojom::SensorType type,
+    SensorReadingSharedBuffer* reading_buffer,
+    PlatformSensorProvider* provider)
+    : PlatformSensor(type, reading_buffer, provider) {
   ON_CALL(*this, StartSensor(_))
       .WillByDefault(
           Invoke([this](const PlatformSensorConfiguration& configuration) {
@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {
 
 FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;
 
-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(
+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(
     mojom::SensorType type) {
-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;
+  return CreateSharedBufferIfNeeded()
+             ? GetSensorReadingSharedBufferForType(type)
+             : nullptr;
 }
 
 void FakePlatformSensorProvider::CreateSensorInternal(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);
   auto sensor =
-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);
+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);
   DoCreateSensorInternal(type, std::move(sensor), callback);
 }
 ",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1,"mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(
//fix_flaw_line_below:
//SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(
     mojom::SensorType type) {
//flaw_line_below:
  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;
//fix_flaw_line_below:
//  return CreateSharedBufferIfNeeded()
//fix_flaw_line_below:
//             ? GetSensorReadingSharedBufferForType(type)
//fix_flaw_line_below:
//             : nullptr;
 }
"
9062,186798,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,1,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",3,services/device/generic_sensor/platform_sensor.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}"," bool PlatformSensor::GetLatestReading(SensorReading* result) {
   if (!shared_buffer_reader_) {
     shared_buffer_reader_ =
        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);
   }
 
   return shared_buffer_reader_->GetReading(result);
}
"," bool PlatformSensor::GetLatestReading(SensorReading* result) {
   if (!shared_buffer_reader_) {
    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(
        shared_buffer_mapping_.get());
     shared_buffer_reader_ =
        std::make_unique<SensorReadingSharedBufferReader>(buffer);
   }
 
   return shared_buffer_reader_->GetReading(result);
}
",C,"        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);
","    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(
        shared_buffer_mapping_.get());
        std::make_unique<SensorReadingSharedBufferReader>(buffer);
",,"@@ -16,10 +16,10 @@
 namespace device {
 
 PlatformSensor::PlatformSensor(mojom::SensorType type,
-                               mojo::ScopedSharedBufferMapping mapping,
+                               SensorReadingSharedBuffer* reading_buffer,
                                PlatformSensorProvider* provider)
     : task_runner_(base::ThreadTaskRunnerHandle::Get()),
-      shared_buffer_mapping_(std::move(mapping)),
+      reading_buffer_(reading_buffer),
       type_(type),
       provider_(provider),
       weak_factory_(this) {}
@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {
 
 bool PlatformSensor::GetLatestReading(SensorReading* result) {
   if (!shared_buffer_reader_) {
-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(
-        shared_buffer_mapping_.get());
     shared_buffer_reader_ =
-        std::make_unique<SensorReadingSharedBufferReader>(buffer);
+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);
   }
 
   return shared_buffer_reader_->GetReading(result);
@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(
 }
 
 void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {
-  ReadingBuffer* buffer =
-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());
+  ReadingBuffer* buffer = reading_buffer_;
   auto& seqlock = buffer->seqlock.value();
   seqlock.WriteBegin();
   buffer->reading = reading;",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1," bool PlatformSensor::GetLatestReading(SensorReading* result) {
   if (!shared_buffer_reader_) {
//flaw_line_below:
    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(
//flaw_line_below:
        shared_buffer_mapping_.get());
     shared_buffer_reader_ =
//flaw_line_below:
        std::make_unique<SensorReadingSharedBufferReader>(buffer);
//fix_flaw_line_below:
//        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);
   }
 
   return shared_buffer_reader_->GetReading(result);
}
"
9063,186799,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,2,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",2,services/device/generic_sensor/platform_sensor.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}"," PlatformSensor::PlatformSensor(mojom::SensorType type,
                               SensorReadingSharedBuffer* reading_buffer,
                                PlatformSensorProvider* provider)
     : task_runner_(base::ThreadTaskRunnerHandle::Get()),
      reading_buffer_(reading_buffer),
       type_(type),
       provider_(provider),
       weak_factory_(this) {}
"," PlatformSensor::PlatformSensor(mojom::SensorType type,
                               mojo::ScopedSharedBufferMapping mapping,
                                PlatformSensorProvider* provider)
     : task_runner_(base::ThreadTaskRunnerHandle::Get()),
      shared_buffer_mapping_(std::move(mapping)),
       type_(type),
       provider_(provider),
       weak_factory_(this) {}
",C,"                               SensorReadingSharedBuffer* reading_buffer,
      reading_buffer_(reading_buffer),
","                               mojo::ScopedSharedBufferMapping mapping,
      shared_buffer_mapping_(std::move(mapping)),
",,"@@ -16,10 +16,10 @@
 namespace device {
 
 PlatformSensor::PlatformSensor(mojom::SensorType type,
-                               mojo::ScopedSharedBufferMapping mapping,
+                               SensorReadingSharedBuffer* reading_buffer,
                                PlatformSensorProvider* provider)
     : task_runner_(base::ThreadTaskRunnerHandle::Get()),
-      shared_buffer_mapping_(std::move(mapping)),
+      reading_buffer_(reading_buffer),
       type_(type),
       provider_(provider),
       weak_factory_(this) {}
@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {
 
 bool PlatformSensor::GetLatestReading(SensorReading* result) {
   if (!shared_buffer_reader_) {
-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(
-        shared_buffer_mapping_.get());
     shared_buffer_reader_ =
-        std::make_unique<SensorReadingSharedBufferReader>(buffer);
+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);
   }
 
   return shared_buffer_reader_->GetReading(result);
@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(
 }
 
 void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {
-  ReadingBuffer* buffer =
-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());
+  ReadingBuffer* buffer = reading_buffer_;
   auto& seqlock = buffer->seqlock.value();
   seqlock.WriteBegin();
   buffer->reading = reading;",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1," PlatformSensor::PlatformSensor(mojom::SensorType type,
//flaw_line_below:
                               mojo::ScopedSharedBufferMapping mapping,
//fix_flaw_line_below:
//                               SensorReadingSharedBuffer* reading_buffer,
                                PlatformSensorProvider* provider)
     : task_runner_(base::ThreadTaskRunnerHandle::Get()),
//flaw_line_below:
      shared_buffer_mapping_(std::move(mapping)),
//fix_flaw_line_below:
//      reading_buffer_(reading_buffer),
       type_(type),
       provider_(provider),
       weak_factory_(this) {}
"
9064,186800,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,1,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",2,services/device/generic_sensor/platform_sensor.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}"," void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {
  ReadingBuffer* buffer = reading_buffer_;
   auto& seqlock = buffer->seqlock.value();
   seqlock.WriteBegin();
   buffer->reading = reading;
  seqlock.WriteEnd();
}
"," void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {
  ReadingBuffer* buffer =
      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());
   auto& seqlock = buffer->seqlock.value();
   seqlock.WriteBegin();
   buffer->reading = reading;
  seqlock.WriteEnd();
}
",C,"  ReadingBuffer* buffer = reading_buffer_;
","  ReadingBuffer* buffer =
      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());
",,"@@ -16,10 +16,10 @@
 namespace device {
 
 PlatformSensor::PlatformSensor(mojom::SensorType type,
-                               mojo::ScopedSharedBufferMapping mapping,
+                               SensorReadingSharedBuffer* reading_buffer,
                                PlatformSensorProvider* provider)
     : task_runner_(base::ThreadTaskRunnerHandle::Get()),
-      shared_buffer_mapping_(std::move(mapping)),
+      reading_buffer_(reading_buffer),
       type_(type),
       provider_(provider),
       weak_factory_(this) {}
@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {
 
 bool PlatformSensor::GetLatestReading(SensorReading* result) {
   if (!shared_buffer_reader_) {
-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(
-        shared_buffer_mapping_.get());
     shared_buffer_reader_ =
-        std::make_unique<SensorReadingSharedBufferReader>(buffer);
+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);
   }
 
   return shared_buffer_reader_->GetReading(result);
@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(
 }
 
 void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {
-  ReadingBuffer* buffer =
-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());
+  ReadingBuffer* buffer = reading_buffer_;
   auto& seqlock = buffer->seqlock.value();
   seqlock.WriteBegin();
   buffer->reading = reading;",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1," void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {
//flaw_line_below:
  ReadingBuffer* buffer =
//flaw_line_below:
      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());
//fix_flaw_line_below:
//  ReadingBuffer* buffer = reading_buffer_;
   auto& seqlock = buffer->seqlock.value();
   seqlock.WriteBegin();
   buffer->reading = reading;
  seqlock.WriteEnd();
}
"
9065,186801,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,2,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",2,services/device/generic_sensor/platform_sensor_accelerometer_mac.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}"," PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(
    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider)
    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),
       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}
"," PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(
    mojo::ScopedSharedBufferMapping mapping,
     PlatformSensorProvider* provider)
    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),
       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}
",C,"    SensorReadingSharedBuffer* reading_buffer,
    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),
","    mojo::ScopedSharedBufferMapping mapping,
    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),
",,"@@ -35,9 +35,9 @@ namespace device {
 using mojom::SensorType;
 
 PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider)
-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),
+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),
       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}
 
 PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1," PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(
//flaw_line_below:
    mojo::ScopedSharedBufferMapping mapping,
//fix_flaw_line_below:
//    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider)
//flaw_line_below:
    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),
//fix_flaw_line_below:
//    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),
       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}
"
9066,186802,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,2,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",2,services/device/generic_sensor/platform_sensor_ambient_light_mac.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}"," PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(
    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider)
    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),
       light_sensor_port_(nullptr),
       current_lux_(0.0) {}
"," PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(
    mojo::ScopedSharedBufferMapping mapping,
     PlatformSensorProvider* provider)
    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),
       light_sensor_port_(nullptr),
       current_lux_(0.0) {}
",C,"    SensorReadingSharedBuffer* reading_buffer,
    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),
","    mojo::ScopedSharedBufferMapping mapping,
    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),
",,"@@ -50,9 +50,9 @@ enum LmuFunctionIndex {
 };
 
 PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider)
-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),
+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),
       light_sensor_port_(nullptr),
       current_lux_(0.0) {}
 ",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1," PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(
//flaw_line_below:
    mojo::ScopedSharedBufferMapping mapping,
//fix_flaw_line_below:
//    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider)
//flaw_line_below:
    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),
//fix_flaw_line_below:
//    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),
       light_sensor_port_(nullptr),
       current_lux_(0.0) {}
"
9067,186803,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,2,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",2,services/device/generic_sensor/platform_sensor_android.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}"," PlatformSensorAndroid::PlatformSensorAndroid(
     mojom::SensorType type,
    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider,
     const JavaRef<jobject>& java_sensor)
    : PlatformSensor(type, reading_buffer, provider) {
   JNIEnv* env = AttachCurrentThread();
   j_object_.Reset(java_sensor);
 
  Java_PlatformSensor_initPlatformSensorAndroid(env, j_object_,
                                                reinterpret_cast<jlong>(this));
}
"," PlatformSensorAndroid::PlatformSensorAndroid(
     mojom::SensorType type,
    mojo::ScopedSharedBufferMapping mapping,
     PlatformSensorProvider* provider,
     const JavaRef<jobject>& java_sensor)
    : PlatformSensor(type, std::move(mapping), provider) {
   JNIEnv* env = AttachCurrentThread();
   j_object_.Reset(java_sensor);
 
  Java_PlatformSensor_initPlatformSensorAndroid(env, j_object_,
                                                reinterpret_cast<jlong>(this));
}
",C,"    SensorReadingSharedBuffer* reading_buffer,
    : PlatformSensor(type, reading_buffer, provider) {
","    mojo::ScopedSharedBufferMapping mapping,
    : PlatformSensor(type, std::move(mapping), provider) {
",,"@@ -14,10 +14,10 @@ namespace device {
 
 PlatformSensorAndroid::PlatformSensorAndroid(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider,
     const JavaRef<jobject>& java_sensor)
-    : PlatformSensor(type, std::move(mapping), provider) {
+    : PlatformSensor(type, reading_buffer, provider) {
   JNIEnv* env = AttachCurrentThread();
   j_object_.Reset(java_sensor);
 ",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1," PlatformSensorAndroid::PlatformSensorAndroid(
     mojom::SensorType type,
//flaw_line_below:
    mojo::ScopedSharedBufferMapping mapping,
//fix_flaw_line_below:
//    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider,
     const JavaRef<jobject>& java_sensor)
//flaw_line_below:
    : PlatformSensor(type, std::move(mapping), provider) {
//fix_flaw_line_below:
//    : PlatformSensor(type, reading_buffer, provider) {
   JNIEnv* env = AttachCurrentThread();
   j_object_.Reset(java_sensor);
 
  Java_PlatformSensor_initPlatformSensorAndroid(env, j_object_,
                                                reinterpret_cast<jlong>(this));
}
"
9068,186804,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,2,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",2,services/device/generic_sensor/platform_sensor_fusion.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}"," void PlatformSensorFusion::Create(
    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider,
     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
     const PlatformSensorProviderBase::CreateSensorCallback& callback) {
  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),
                               callback, provider);
 }
"," void PlatformSensorFusion::Create(
    mojo::ScopedSharedBufferMapping mapping,
     PlatformSensorProvider* provider,
     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
     const PlatformSensorProviderBase::CreateSensorCallback& callback) {
  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),
                               callback, provider);
 }
",C,"    SensorReadingSharedBuffer* reading_buffer,
  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),
","    mojo::ScopedSharedBufferMapping mapping,
  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),
",,"@@ -14,11 +14,11 @@ namespace device {
 class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {
  public:
   static void CreateSensorFusion(
-      mojo::ScopedSharedBufferMapping mapping,
+      SensorReadingSharedBuffer* reading_buffer,
       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
       const PlatformSensorProviderBase::CreateSensorCallback& callback,
       PlatformSensorProvider* provider) {
-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),
+    scoped_refptr<Factory> factory(new Factory(reading_buffer,
                                                std::move(fusion_algorithm),
                                                std::move(callback), provider));
     factory->FetchSources();
@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {
  private:
   friend class base::RefCounted<Factory>;
 
-  Factory(mojo::ScopedSharedBufferMapping mapping,
+  Factory(SensorReadingSharedBuffer* reading_buffer,
           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
           const PlatformSensorProviderBase::CreateSensorCallback& callback,
           PlatformSensorProvider* provider)
       : fusion_algorithm_(std::move(fusion_algorithm)),
         result_callback_(std::move(callback)),
-        mapping_(std::move(mapping)),
+        reading_buffer_(reading_buffer),
         provider_(provider) {
     const auto& types = fusion_algorithm_->source_types();
     DCHECK(!types.empty());
     // Make sure there are no dups.
     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());
     DCHECK(result_callback_);
-    DCHECK(mapping_);
+    DCHECK(reading_buffer_);
     DCHECK(provider_);
   }
 
@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {
     sources_map_[type] = std::move(sensor);
     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {
       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(
-          std::move(mapping_), provider_, std::move(fusion_algorithm_),
+          reading_buffer_, provider_, std::move(fusion_algorithm_),
           std::move(sources_map_)));
       std::move(result_callback_).Run(fusion_sensor);
     }
   }
 
   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;
   PlatformSensorProviderBase::CreateSensorCallback result_callback_;
-  mojo::ScopedSharedBufferMapping mapping_;
+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.
   PlatformSensorProvider* provider_;
   PlatformSensorFusion::SourcesMap sources_map_;
 };
 
 // static
 void PlatformSensorFusion::Create(
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider,
     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
     const PlatformSensorProviderBase::CreateSensorCallback& callback) {
-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),
+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),
                               callback, provider);
 }
 
 PlatformSensorFusion::PlatformSensorFusion(
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider,
     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
     PlatformSensorFusion::SourcesMap sources)
-    : PlatformSensor(fusion_algorithm->fused_type(),
-                     std::move(mapping),
-                     provider),
+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),
       fusion_algorithm_(std::move(fusion_algorithm)),
       source_sensors_(std::move(sources)),
       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1," void PlatformSensorFusion::Create(
//flaw_line_below:
    mojo::ScopedSharedBufferMapping mapping,
//fix_flaw_line_below:
//    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider,
     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
     const PlatformSensorProviderBase::CreateSensorCallback& callback) {
//flaw_line_below:
  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),
//fix_flaw_line_below:
//  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),
                               callback, provider);
 }
"
9069,186805,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,2,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",2,services/device/generic_sensor/platform_sensor_fusion.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}","   static void CreateSensorFusion(
      SensorReadingSharedBuffer* reading_buffer,
       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
       const PlatformSensorProviderBase::CreateSensorCallback& callback,
       PlatformSensorProvider* provider) {
    scoped_refptr<Factory> factory(new Factory(reading_buffer,
                                                std::move(fusion_algorithm),
                                                std::move(callback), provider));
     factory->FetchSources();
  }
","   static void CreateSensorFusion(
      mojo::ScopedSharedBufferMapping mapping,
       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
       const PlatformSensorProviderBase::CreateSensorCallback& callback,
       PlatformSensorProvider* provider) {
    scoped_refptr<Factory> factory(new Factory(std::move(mapping),
                                                std::move(fusion_algorithm),
                                                std::move(callback), provider));
     factory->FetchSources();
  }
",C,"      SensorReadingSharedBuffer* reading_buffer,
    scoped_refptr<Factory> factory(new Factory(reading_buffer,
","      mojo::ScopedSharedBufferMapping mapping,
    scoped_refptr<Factory> factory(new Factory(std::move(mapping),
",,"@@ -14,11 +14,11 @@ namespace device {
 class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {
  public:
   static void CreateSensorFusion(
-      mojo::ScopedSharedBufferMapping mapping,
+      SensorReadingSharedBuffer* reading_buffer,
       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
       const PlatformSensorProviderBase::CreateSensorCallback& callback,
       PlatformSensorProvider* provider) {
-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),
+    scoped_refptr<Factory> factory(new Factory(reading_buffer,
                                                std::move(fusion_algorithm),
                                                std::move(callback), provider));
     factory->FetchSources();
@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {
  private:
   friend class base::RefCounted<Factory>;
 
-  Factory(mojo::ScopedSharedBufferMapping mapping,
+  Factory(SensorReadingSharedBuffer* reading_buffer,
           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
           const PlatformSensorProviderBase::CreateSensorCallback& callback,
           PlatformSensorProvider* provider)
       : fusion_algorithm_(std::move(fusion_algorithm)),
         result_callback_(std::move(callback)),
-        mapping_(std::move(mapping)),
+        reading_buffer_(reading_buffer),
         provider_(provider) {
     const auto& types = fusion_algorithm_->source_types();
     DCHECK(!types.empty());
     // Make sure there are no dups.
     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());
     DCHECK(result_callback_);
-    DCHECK(mapping_);
+    DCHECK(reading_buffer_);
     DCHECK(provider_);
   }
 
@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {
     sources_map_[type] = std::move(sensor);
     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {
       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(
-          std::move(mapping_), provider_, std::move(fusion_algorithm_),
+          reading_buffer_, provider_, std::move(fusion_algorithm_),
           std::move(sources_map_)));
       std::move(result_callback_).Run(fusion_sensor);
     }
   }
 
   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;
   PlatformSensorProviderBase::CreateSensorCallback result_callback_;
-  mojo::ScopedSharedBufferMapping mapping_;
+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.
   PlatformSensorProvider* provider_;
   PlatformSensorFusion::SourcesMap sources_map_;
 };
 
 // static
 void PlatformSensorFusion::Create(
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider,
     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
     const PlatformSensorProviderBase::CreateSensorCallback& callback) {
-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),
+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),
                               callback, provider);
 }
 
 PlatformSensorFusion::PlatformSensorFusion(
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider,
     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
     PlatformSensorFusion::SourcesMap sources)
-    : PlatformSensor(fusion_algorithm->fused_type(),
-                     std::move(mapping),
-                     provider),
+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),
       fusion_algorithm_(std::move(fusion_algorithm)),
       source_sensors_(std::move(sources)),
       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1,"   static void CreateSensorFusion(
//flaw_line_below:
      mojo::ScopedSharedBufferMapping mapping,
//fix_flaw_line_below:
//      SensorReadingSharedBuffer* reading_buffer,
       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
       const PlatformSensorProviderBase::CreateSensorCallback& callback,
       PlatformSensorProvider* provider) {
//flaw_line_below:
    scoped_refptr<Factory> factory(new Factory(std::move(mapping),
//fix_flaw_line_below:
//    scoped_refptr<Factory> factory(new Factory(reading_buffer,
                                                std::move(fusion_algorithm),
                                                std::move(callback), provider));
     factory->FetchSources();
  }
"
9070,186806,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,3,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",2,services/device/generic_sensor/platform_sensor_fusion.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}","  Factory(mojo::ScopedSharedBufferMapping mapping,
  Factory(SensorReadingSharedBuffer* reading_buffer,
           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
           const PlatformSensorProviderBase::CreateSensorCallback& callback,
           PlatformSensorProvider* provider)
       : fusion_algorithm_(std::move(fusion_algorithm)),
         result_callback_(std::move(callback)),
        reading_buffer_(reading_buffer),
         provider_(provider) {
     const auto& types = fusion_algorithm_->source_types();
     DCHECK(!types.empty());
     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());
     DCHECK(result_callback_);
    DCHECK(reading_buffer_);
     DCHECK(provider_);
   }
","  Factory(mojo::ScopedSharedBufferMapping mapping,
           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
           const PlatformSensorProviderBase::CreateSensorCallback& callback,
           PlatformSensorProvider* provider)
       : fusion_algorithm_(std::move(fusion_algorithm)),
         result_callback_(std::move(callback)),
        mapping_(std::move(mapping)),
         provider_(provider) {
     const auto& types = fusion_algorithm_->source_types();
     DCHECK(!types.empty());
     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());
     DCHECK(result_callback_);
    DCHECK(mapping_);
     DCHECK(provider_);
   }
",C,"  Factory(SensorReadingSharedBuffer* reading_buffer,
        reading_buffer_(reading_buffer),
    DCHECK(reading_buffer_);
","        mapping_(std::move(mapping)),
    DCHECK(mapping_);
",,"@@ -14,11 +14,11 @@ namespace device {
 class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {
  public:
   static void CreateSensorFusion(
-      mojo::ScopedSharedBufferMapping mapping,
+      SensorReadingSharedBuffer* reading_buffer,
       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
       const PlatformSensorProviderBase::CreateSensorCallback& callback,
       PlatformSensorProvider* provider) {
-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),
+    scoped_refptr<Factory> factory(new Factory(reading_buffer,
                                                std::move(fusion_algorithm),
                                                std::move(callback), provider));
     factory->FetchSources();
@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {
  private:
   friend class base::RefCounted<Factory>;
 
-  Factory(mojo::ScopedSharedBufferMapping mapping,
+  Factory(SensorReadingSharedBuffer* reading_buffer,
           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
           const PlatformSensorProviderBase::CreateSensorCallback& callback,
           PlatformSensorProvider* provider)
       : fusion_algorithm_(std::move(fusion_algorithm)),
         result_callback_(std::move(callback)),
-        mapping_(std::move(mapping)),
+        reading_buffer_(reading_buffer),
         provider_(provider) {
     const auto& types = fusion_algorithm_->source_types();
     DCHECK(!types.empty());
     // Make sure there are no dups.
     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());
     DCHECK(result_callback_);
-    DCHECK(mapping_);
+    DCHECK(reading_buffer_);
     DCHECK(provider_);
   }
 
@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {
     sources_map_[type] = std::move(sensor);
     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {
       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(
-          std::move(mapping_), provider_, std::move(fusion_algorithm_),
+          reading_buffer_, provider_, std::move(fusion_algorithm_),
           std::move(sources_map_)));
       std::move(result_callback_).Run(fusion_sensor);
     }
   }
 
   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;
   PlatformSensorProviderBase::CreateSensorCallback result_callback_;
-  mojo::ScopedSharedBufferMapping mapping_;
+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.
   PlatformSensorProvider* provider_;
   PlatformSensorFusion::SourcesMap sources_map_;
 };
 
 // static
 void PlatformSensorFusion::Create(
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider,
     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
     const PlatformSensorProviderBase::CreateSensorCallback& callback) {
-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),
+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),
                               callback, provider);
 }
 
 PlatformSensorFusion::PlatformSensorFusion(
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider,
     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
     PlatformSensorFusion::SourcesMap sources)
-    : PlatformSensor(fusion_algorithm->fused_type(),
-                     std::move(mapping),
-                     provider),
+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),
       fusion_algorithm_(std::move(fusion_algorithm)),
       source_sensors_(std::move(sources)),
       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1,"  Factory(mojo::ScopedSharedBufferMapping mapping,
//fix_flaw_line_below:
//  Factory(SensorReadingSharedBuffer* reading_buffer,
           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
           const PlatformSensorProviderBase::CreateSensorCallback& callback,
           PlatformSensorProvider* provider)
       : fusion_algorithm_(std::move(fusion_algorithm)),
         result_callback_(std::move(callback)),
//flaw_line_below:
        mapping_(std::move(mapping)),
//fix_flaw_line_below:
//        reading_buffer_(reading_buffer),
         provider_(provider) {
     const auto& types = fusion_algorithm_->source_types();
     DCHECK(!types.empty());
     // Make sure there are no dups.
     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());
     DCHECK(result_callback_);
//flaw_line_below:
    DCHECK(mapping_);
//fix_flaw_line_below:
//    DCHECK(reading_buffer_);
     DCHECK(provider_);
   }
"
9071,186807,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,2,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",4,services/device/generic_sensor/platform_sensor_fusion.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}"," PlatformSensorFusion::PlatformSensorFusion(
    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider,
     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
     PlatformSensorFusion::SourcesMap sources)
    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),
       fusion_algorithm_(std::move(fusion_algorithm)),
       source_sensors_(std::move(sources)),
       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {
  for (const auto& pair : source_sensors_)
    pair.second->AddClient(this);

  fusion_algorithm_->set_fusion_sensor(this);

  if (std::any_of(source_sensors_.begin(), source_sensors_.end(),
                  [](const SourcesMapEntry& pair) {
                    return pair.second->GetReportingMode() ==
                           mojom::ReportingMode::ON_CHANGE;
                  })) {
    reporting_mode_ = mojom::ReportingMode::ON_CHANGE;
  }
}
"," PlatformSensorFusion::PlatformSensorFusion(
    mojo::ScopedSharedBufferMapping mapping,
     PlatformSensorProvider* provider,
     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
     PlatformSensorFusion::SourcesMap sources)
    : PlatformSensor(fusion_algorithm->fused_type(),
                     std::move(mapping),
                     provider),
       fusion_algorithm_(std::move(fusion_algorithm)),
       source_sensors_(std::move(sources)),
       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {
  for (const auto& pair : source_sensors_)
    pair.second->AddClient(this);

  fusion_algorithm_->set_fusion_sensor(this);

  if (std::any_of(source_sensors_.begin(), source_sensors_.end(),
                  [](const SourcesMapEntry& pair) {
                    return pair.second->GetReportingMode() ==
                           mojom::ReportingMode::ON_CHANGE;
                  })) {
    reporting_mode_ = mojom::ReportingMode::ON_CHANGE;
  }
}
",C,"    SensorReadingSharedBuffer* reading_buffer,
    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),
","    mojo::ScopedSharedBufferMapping mapping,
    : PlatformSensor(fusion_algorithm->fused_type(),
                     std::move(mapping),
                     provider),
",,"@@ -14,11 +14,11 @@ namespace device {
 class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {
  public:
   static void CreateSensorFusion(
-      mojo::ScopedSharedBufferMapping mapping,
+      SensorReadingSharedBuffer* reading_buffer,
       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
       const PlatformSensorProviderBase::CreateSensorCallback& callback,
       PlatformSensorProvider* provider) {
-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),
+    scoped_refptr<Factory> factory(new Factory(reading_buffer,
                                                std::move(fusion_algorithm),
                                                std::move(callback), provider));
     factory->FetchSources();
@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {
  private:
   friend class base::RefCounted<Factory>;
 
-  Factory(mojo::ScopedSharedBufferMapping mapping,
+  Factory(SensorReadingSharedBuffer* reading_buffer,
           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
           const PlatformSensorProviderBase::CreateSensorCallback& callback,
           PlatformSensorProvider* provider)
       : fusion_algorithm_(std::move(fusion_algorithm)),
         result_callback_(std::move(callback)),
-        mapping_(std::move(mapping)),
+        reading_buffer_(reading_buffer),
         provider_(provider) {
     const auto& types = fusion_algorithm_->source_types();
     DCHECK(!types.empty());
     // Make sure there are no dups.
     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());
     DCHECK(result_callback_);
-    DCHECK(mapping_);
+    DCHECK(reading_buffer_);
     DCHECK(provider_);
   }
 
@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {
     sources_map_[type] = std::move(sensor);
     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {
       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(
-          std::move(mapping_), provider_, std::move(fusion_algorithm_),
+          reading_buffer_, provider_, std::move(fusion_algorithm_),
           std::move(sources_map_)));
       std::move(result_callback_).Run(fusion_sensor);
     }
   }
 
   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;
   PlatformSensorProviderBase::CreateSensorCallback result_callback_;
-  mojo::ScopedSharedBufferMapping mapping_;
+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.
   PlatformSensorProvider* provider_;
   PlatformSensorFusion::SourcesMap sources_map_;
 };
 
 // static
 void PlatformSensorFusion::Create(
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider,
     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
     const PlatformSensorProviderBase::CreateSensorCallback& callback) {
-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),
+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),
                               callback, provider);
 }
 
 PlatformSensorFusion::PlatformSensorFusion(
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider,
     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
     PlatformSensorFusion::SourcesMap sources)
-    : PlatformSensor(fusion_algorithm->fused_type(),
-                     std::move(mapping),
-                     provider),
+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),
       fusion_algorithm_(std::move(fusion_algorithm)),
       source_sensors_(std::move(sources)),
       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1," PlatformSensorFusion::PlatformSensorFusion(
//flaw_line_below:
    mojo::ScopedSharedBufferMapping mapping,
//fix_flaw_line_below:
//    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider,
     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
     PlatformSensorFusion::SourcesMap sources)
//flaw_line_below:
    : PlatformSensor(fusion_algorithm->fused_type(),
//flaw_line_below:
                     std::move(mapping),
//flaw_line_below:
                     provider),
//fix_flaw_line_below:
//    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),
       fusion_algorithm_(std::move(fusion_algorithm)),
       source_sensors_(std::move(sources)),
       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {
  for (const auto& pair : source_sensors_)
    pair.second->AddClient(this);

  fusion_algorithm_->set_fusion_sensor(this);

  if (std::any_of(source_sensors_.begin(), source_sensors_.end(),
                  [](const SourcesMapEntry& pair) {
                    return pair.second->GetReportingMode() ==
                           mojom::ReportingMode::ON_CHANGE;
                  })) {
    reporting_mode_ = mojom::ReportingMode::ON_CHANGE;
  }
}
"
9072,186808,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,1,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",1,services/device/generic_sensor/platform_sensor_fusion.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}","  void SensorCreated(scoped_refptr<PlatformSensor> sensor) {
    if (!result_callback_) {
      return;
    }

    if (!sensor) {
      std::move(result_callback_).Run(nullptr);
      return;
    }
    mojom::SensorType type = sensor->GetType();
     sources_map_[type] = std::move(sensor);
     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {
       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(
          reading_buffer_, provider_, std::move(fusion_algorithm_),
           std::move(sources_map_)));
       std::move(result_callback_).Run(fusion_sensor);
     }
   }
","  void SensorCreated(scoped_refptr<PlatformSensor> sensor) {
    if (!result_callback_) {
      return;
    }

    if (!sensor) {
      std::move(result_callback_).Run(nullptr);
      return;
    }
    mojom::SensorType type = sensor->GetType();
     sources_map_[type] = std::move(sensor);
     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {
       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(
          std::move(mapping_), provider_, std::move(fusion_algorithm_),
           std::move(sources_map_)));
       std::move(result_callback_).Run(fusion_sensor);
     }
   }
",C,"          reading_buffer_, provider_, std::move(fusion_algorithm_),
","          std::move(mapping_), provider_, std::move(fusion_algorithm_),
",,"@@ -14,11 +14,11 @@ namespace device {
 class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {
  public:
   static void CreateSensorFusion(
-      mojo::ScopedSharedBufferMapping mapping,
+      SensorReadingSharedBuffer* reading_buffer,
       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
       const PlatformSensorProviderBase::CreateSensorCallback& callback,
       PlatformSensorProvider* provider) {
-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),
+    scoped_refptr<Factory> factory(new Factory(reading_buffer,
                                                std::move(fusion_algorithm),
                                                std::move(callback), provider));
     factory->FetchSources();
@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {
  private:
   friend class base::RefCounted<Factory>;
 
-  Factory(mojo::ScopedSharedBufferMapping mapping,
+  Factory(SensorReadingSharedBuffer* reading_buffer,
           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
           const PlatformSensorProviderBase::CreateSensorCallback& callback,
           PlatformSensorProvider* provider)
       : fusion_algorithm_(std::move(fusion_algorithm)),
         result_callback_(std::move(callback)),
-        mapping_(std::move(mapping)),
+        reading_buffer_(reading_buffer),
         provider_(provider) {
     const auto& types = fusion_algorithm_->source_types();
     DCHECK(!types.empty());
     // Make sure there are no dups.
     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());
     DCHECK(result_callback_);
-    DCHECK(mapping_);
+    DCHECK(reading_buffer_);
     DCHECK(provider_);
   }
 
@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {
     sources_map_[type] = std::move(sensor);
     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {
       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(
-          std::move(mapping_), provider_, std::move(fusion_algorithm_),
+          reading_buffer_, provider_, std::move(fusion_algorithm_),
           std::move(sources_map_)));
       std::move(result_callback_).Run(fusion_sensor);
     }
   }
 
   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;
   PlatformSensorProviderBase::CreateSensorCallback result_callback_;
-  mojo::ScopedSharedBufferMapping mapping_;
+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.
   PlatformSensorProvider* provider_;
   PlatformSensorFusion::SourcesMap sources_map_;
 };
 
 // static
 void PlatformSensorFusion::Create(
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider,
     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
     const PlatformSensorProviderBase::CreateSensorCallback& callback) {
-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),
+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),
                               callback, provider);
 }
 
 PlatformSensorFusion::PlatformSensorFusion(
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider,
     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,
     PlatformSensorFusion::SourcesMap sources)
-    : PlatformSensor(fusion_algorithm->fused_type(),
-                     std::move(mapping),
-                     provider),
+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),
       fusion_algorithm_(std::move(fusion_algorithm)),
       source_sensors_(std::move(sources)),
       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1,"  void SensorCreated(scoped_refptr<PlatformSensor> sensor) {
    if (!result_callback_) {
      // It is possible, if this callback has been already called
      // with nullptr (i.e. failed to fetch some of the required
      // source sensors). See the condition below.
      return;
    }

    if (!sensor) {
      std::move(result_callback_).Run(nullptr);
      return;
    }
    mojom::SensorType type = sensor->GetType();
     sources_map_[type] = std::move(sensor);
     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {
       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(
//flaw_line_below:
          std::move(mapping_), provider_, std::move(fusion_algorithm_),
//fix_flaw_line_below:
//          reading_buffer_, provider_, std::move(fusion_algorithm_),
           std::move(sources_map_)));
       std::move(result_callback_).Run(fusion_sensor);
     }
   }
"
9073,186809,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,3,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",2,services/device/generic_sensor/platform_sensor_fusion_unittest.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}","  void CreateFusionSensor(
      std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm) {
    auto callback =
         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,
                    base::Unretained(this));
     SensorType type = fusion_algorithm->fused_type();
    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),
                                 provider_.get(), std::move(fusion_algorithm),
                                 callback);
     EXPECT_TRUE(platform_sensor_fusion_callback_called_);
   }
","  void CreateFusionSensor(
      std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm) {
    auto callback =
         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,
                    base::Unretained(this));
     SensorType type = fusion_algorithm->fused_type();
    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),
                                 std::move(fusion_algorithm), callback);
     EXPECT_TRUE(platform_sensor_fusion_callback_called_);
   }
",C,"    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),
                                 provider_.get(), std::move(fusion_algorithm),
                                 callback);
","    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),
                                 std::move(fusion_algorithm), callback);
",,"@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {
         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,
                    base::Unretained(this));
     SensorType type = fusion_algorithm->fused_type();
-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),
-                                 std::move(fusion_algorithm), callback);
+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),
+                                 provider_.get(), std::move(fusion_algorithm),
+                                 callback);
     EXPECT_TRUE(platform_sensor_fusion_callback_called_);
   }
 ",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1,"  void CreateFusionSensor(
      std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm) {
    auto callback =
         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,
                    base::Unretained(this));
     SensorType type = fusion_algorithm->fused_type();
//flaw_line_below:
    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),
//flaw_line_below:
                                 std::move(fusion_algorithm), callback);
//fix_flaw_line_below:
//    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),
//fix_flaw_line_below:
//                                 provider_.get(), std::move(fusion_algorithm),
//fix_flaw_line_below:
//                                 callback);
     EXPECT_TRUE(platform_sensor_fusion_callback_called_);
   }
"
9074,186810,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,2,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",2,services/device/generic_sensor/platform_sensor_linux.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}"," PlatformSensorLinux::PlatformSensorLinux(
     mojom::SensorType type,
    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider,
     const SensorInfoLinux* sensor_device,
     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)
    : PlatformSensor(type, reading_buffer, provider),
       default_configuration_(
           PlatformSensorConfiguration(sensor_device->device_frequency)),
       reporting_mode_(sensor_device->reporting_mode),
      polling_thread_task_runner_(std::move(polling_thread_task_runner)),
      weak_factory_(this) {
  sensor_reader_ = SensorReader::Create(
      sensor_device, weak_factory_.GetWeakPtr(), task_runner_);
}
"," PlatformSensorLinux::PlatformSensorLinux(
     mojom::SensorType type,
    mojo::ScopedSharedBufferMapping mapping,
     PlatformSensorProvider* provider,
     const SensorInfoLinux* sensor_device,
     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)
    : PlatformSensor(type, std::move(mapping), provider),
       default_configuration_(
           PlatformSensorConfiguration(sensor_device->device_frequency)),
       reporting_mode_(sensor_device->reporting_mode),
      polling_thread_task_runner_(std::move(polling_thread_task_runner)),
      weak_factory_(this) {
  sensor_reader_ = SensorReader::Create(
      sensor_device, weak_factory_.GetWeakPtr(), task_runner_);
}
",C,"    SensorReadingSharedBuffer* reading_buffer,
    : PlatformSensor(type, reading_buffer, provider),
","    mojo::ScopedSharedBufferMapping mapping,
    : PlatformSensor(type, std::move(mapping), provider),
",,"@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {
 
 PlatformSensorLinux::PlatformSensorLinux(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider,
     const SensorInfoLinux* sensor_device,
     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)
-    : PlatformSensor(type, std::move(mapping), provider),
+    : PlatformSensor(type, reading_buffer, provider),
       default_configuration_(
           PlatformSensorConfiguration(sensor_device->device_frequency)),
       reporting_mode_(sensor_device->reporting_mode),",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1," PlatformSensorLinux::PlatformSensorLinux(
     mojom::SensorType type,
//flaw_line_below:
    mojo::ScopedSharedBufferMapping mapping,
//fix_flaw_line_below:
//    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider,
     const SensorInfoLinux* sensor_device,
     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)
//flaw_line_below:
    : PlatformSensor(type, std::move(mapping), provider),
//fix_flaw_line_below:
//    : PlatformSensor(type, reading_buffer, provider),
       default_configuration_(
           PlatformSensorConfiguration(sensor_device->device_frequency)),
       reporting_mode_(sensor_device->reporting_mode),
      polling_thread_task_runner_(std::move(polling_thread_task_runner)),
      weak_factory_(this) {
  sensor_reader_ = SensorReader::Create(
      sensor_device, weak_factory_.GetWeakPtr(), task_runner_);
}
"
9075,186811,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,3,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",3,services/device/generic_sensor/platform_sensor_provider_android.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}"," void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(
     JNIEnv* env,
    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(
           env, j_object_,
          static_cast<jint>(
              mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION)))) {
    auto sensor_fusion_algorithm =
        std::make_unique<OrientationEulerAnglesFusionAlgorithmUsingQuaternion>(
            true /* absolute */);
 
    PlatformSensorFusion::Create(reading_buffer, this,
                                  std::move(sensor_fusion_algorithm), callback);
   } else {
     auto sensor_fusion_algorithm = std::make_unique<
         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();
 
    PlatformSensorFusion::Create(reading_buffer, this,
                                  std::move(sensor_fusion_algorithm), callback);
   }
 }
"," void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(
     JNIEnv* env,
    mojo::ScopedSharedBufferMapping mapping,
     const CreateSensorCallback& callback) {
   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(
           env, j_object_,
          static_cast<jint>(
              mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION)))) {
    auto sensor_fusion_algorithm =
        std::make_unique<OrientationEulerAnglesFusionAlgorithmUsingQuaternion>(
            true /* absolute */);
 
    PlatformSensorFusion::Create(std::move(mapping), this,
                                  std::move(sensor_fusion_algorithm), callback);
   } else {
     auto sensor_fusion_algorithm = std::make_unique<
         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();
 
    PlatformSensorFusion::Create(std::move(mapping), this,
                                  std::move(sensor_fusion_algorithm), callback);
   }
 }
",C,"    SensorReadingSharedBuffer* reading_buffer,
    PlatformSensorFusion::Create(reading_buffer, this,
    PlatformSensorFusion::Create(reading_buffer, this,
","    mojo::ScopedSharedBufferMapping mapping,
    PlatformSensorFusion::Create(std::move(mapping), this,
    PlatformSensorFusion::Create(std::move(mapping), this,
",,"@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {
 
 void PlatformSensorProviderAndroid::CreateSensorInternal(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   JNIEnv* env = AttachCurrentThread();
 
@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(
   // option.
   switch (type) {
     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:
-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),
-                                                 callback);
+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);
       break;
     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:
-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),
-                                                callback);
+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);
       break;
     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:
-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),
-                                                 callback);
+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);
       break;
     default: {
       ScopedJavaLocalRef<jobject> sensor =
@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(
       }
 
       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(
-          type, std::move(mapping), this, sensor);
+          type, reading_buffer, this, sensor);
       callback.Run(concrete_sensor);
       break;
     }
@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(
 //   C: Combination of ACCELEROMETER and MAGNETOMETER
 void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(
     JNIEnv* env,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(
           env, j_object_,
@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(
 
     // If this PlatformSensorFusion object is successfully initialized,
     // |callback| will be run with a reference to this object.
-    PlatformSensorFusion::Create(std::move(mapping), this,
+    PlatformSensorFusion::Create(reading_buffer, this,
                                  std::move(sensor_fusion_algorithm), callback);
   } else {
     auto sensor_fusion_algorithm = std::make_unique<
         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();
 
     // If this PlatformSensorFusion object is successfully initialized,
     // |callback| will be run with a reference to this object.
-    PlatformSensorFusion::Create(std::move(mapping), this,
+    PlatformSensorFusion::Create(reading_buffer, this,
                                  std::move(sensor_fusion_algorithm), callback);
   }
 }
@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(
 //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES
 void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(
     JNIEnv* env,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(
       env, j_object_,
       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));
 
   if (sensor.obj()) {
     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(
-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),
+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,
         this, sensor);
 
     callback.Run(concrete_sensor);
@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(
 
     // If this PlatformSensorFusion object is successfully initialized,
     // |callback| will be run with a reference to this object.
-    PlatformSensorFusion::Create(std::move(mapping), this,
+    PlatformSensorFusion::Create(reading_buffer, this,
                                  std::move(sensor_fusion_algorithm), callback);
   }
 }
@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(
 // (if it uses TYPE_GAME_ROTATION_VECTOR directly).
 void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(
     JNIEnv* env,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(
           env, j_object_,
@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(
 
     // If this PlatformSensorFusion object is successfully initialized,
     // |callback| will be run with a reference to this object.
-    PlatformSensorFusion::Create(std::move(mapping), this,
+    PlatformSensorFusion::Create(reading_buffer, this,
                                  std::move(sensor_fusion_algorithm), callback);
   } else {
     callback.Run(nullptr);",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1," void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(
     JNIEnv* env,
//flaw_line_below:
    mojo::ScopedSharedBufferMapping mapping,
//fix_flaw_line_below:
//    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(
           env, j_object_,
          static_cast<jint>(
              mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION)))) {
    auto sensor_fusion_algorithm =
        std::make_unique<OrientationEulerAnglesFusionAlgorithmUsingQuaternion>(
            true /* absolute */);
 
     // If this PlatformSensorFusion object is successfully initialized,
     // |callback| will be run with a reference to this object.
//flaw_line_below:
    PlatformSensorFusion::Create(std::move(mapping), this,
//fix_flaw_line_below:
//    PlatformSensorFusion::Create(reading_buffer, this,
                                  std::move(sensor_fusion_algorithm), callback);
   } else {
     auto sensor_fusion_algorithm = std::make_unique<
         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();
 
     // If this PlatformSensorFusion object is successfully initialized,
     // |callback| will be run with a reference to this object.
//flaw_line_below:
    PlatformSensorFusion::Create(std::move(mapping), this,
//fix_flaw_line_below:
//    PlatformSensorFusion::Create(reading_buffer, this,
                                  std::move(sensor_fusion_algorithm), callback);
   }
 }
"
9076,186812,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,3,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",3,services/device/generic_sensor/platform_sensor_provider_android.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}"," void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(
     JNIEnv* env,
    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(
       env, j_object_,
       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));
 
   if (sensor.obj()) {
     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(
        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,
         this, sensor);
 
     callback.Run(concrete_sensor);
  } else {
    auto sensor_fusion_algorithm =
        std::make_unique<OrientationQuaternionFusionAlgorithmUsingEulerAngles>(
            true /* absolute */);
 
    PlatformSensorFusion::Create(reading_buffer, this,
                                  std::move(sensor_fusion_algorithm), callback);
   }
 }
"," void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(
     JNIEnv* env,
    mojo::ScopedSharedBufferMapping mapping,
     const CreateSensorCallback& callback) {
   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(
       env, j_object_,
       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));
 
   if (sensor.obj()) {
     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(
        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),
         this, sensor);
 
     callback.Run(concrete_sensor);
  } else {
    auto sensor_fusion_algorithm =
        std::make_unique<OrientationQuaternionFusionAlgorithmUsingEulerAngles>(
            true /* absolute */);
 
    PlatformSensorFusion::Create(std::move(mapping), this,
                                  std::move(sensor_fusion_algorithm), callback);
   }
 }
",C,"    SensorReadingSharedBuffer* reading_buffer,
        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,
    PlatformSensorFusion::Create(reading_buffer, this,
","    mojo::ScopedSharedBufferMapping mapping,
        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),
    PlatformSensorFusion::Create(std::move(mapping), this,
",,"@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {
 
 void PlatformSensorProviderAndroid::CreateSensorInternal(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   JNIEnv* env = AttachCurrentThread();
 
@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(
   // option.
   switch (type) {
     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:
-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),
-                                                 callback);
+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);
       break;
     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:
-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),
-                                                callback);
+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);
       break;
     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:
-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),
-                                                 callback);
+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);
       break;
     default: {
       ScopedJavaLocalRef<jobject> sensor =
@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(
       }
 
       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(
-          type, std::move(mapping), this, sensor);
+          type, reading_buffer, this, sensor);
       callback.Run(concrete_sensor);
       break;
     }
@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(
 //   C: Combination of ACCELEROMETER and MAGNETOMETER
 void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(
     JNIEnv* env,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(
           env, j_object_,
@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(
 
     // If this PlatformSensorFusion object is successfully initialized,
     // |callback| will be run with a reference to this object.
-    PlatformSensorFusion::Create(std::move(mapping), this,
+    PlatformSensorFusion::Create(reading_buffer, this,
                                  std::move(sensor_fusion_algorithm), callback);
   } else {
     auto sensor_fusion_algorithm = std::make_unique<
         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();
 
     // If this PlatformSensorFusion object is successfully initialized,
     // |callback| will be run with a reference to this object.
-    PlatformSensorFusion::Create(std::move(mapping), this,
+    PlatformSensorFusion::Create(reading_buffer, this,
                                  std::move(sensor_fusion_algorithm), callback);
   }
 }
@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(
 //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES
 void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(
     JNIEnv* env,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(
       env, j_object_,
       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));
 
   if (sensor.obj()) {
     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(
-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),
+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,
         this, sensor);
 
     callback.Run(concrete_sensor);
@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(
 
     // If this PlatformSensorFusion object is successfully initialized,
     // |callback| will be run with a reference to this object.
-    PlatformSensorFusion::Create(std::move(mapping), this,
+    PlatformSensorFusion::Create(reading_buffer, this,
                                  std::move(sensor_fusion_algorithm), callback);
   }
 }
@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(
 // (if it uses TYPE_GAME_ROTATION_VECTOR directly).
 void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(
     JNIEnv* env,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(
           env, j_object_,
@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(
 
     // If this PlatformSensorFusion object is successfully initialized,
     // |callback| will be run with a reference to this object.
-    PlatformSensorFusion::Create(std::move(mapping), this,
+    PlatformSensorFusion::Create(reading_buffer, this,
                                  std::move(sensor_fusion_algorithm), callback);
   } else {
     callback.Run(nullptr);",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1," void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(
     JNIEnv* env,
//flaw_line_below:
    mojo::ScopedSharedBufferMapping mapping,
//fix_flaw_line_below:
//    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(
       env, j_object_,
       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));
 
   if (sensor.obj()) {
     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(
//flaw_line_below:
        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),
//fix_flaw_line_below:
//        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,
         this, sensor);
 
     callback.Run(concrete_sensor);
  } else {
    auto sensor_fusion_algorithm =
        std::make_unique<OrientationQuaternionFusionAlgorithmUsingEulerAngles>(
            true /* absolute */);
 
     // If this PlatformSensorFusion object is successfully initialized,
     // |callback| will be run with a reference to this object.
//flaw_line_below:
    PlatformSensorFusion::Create(std::move(mapping), this,
//fix_flaw_line_below:
//    PlatformSensorFusion::Create(reading_buffer, this,
                                  std::move(sensor_fusion_algorithm), callback);
   }
 }
"
9077,186813,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,2,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",2,services/device/generic_sensor/platform_sensor_provider_android.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}"," void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(
     JNIEnv* env,
    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(
           env, j_object_,
          static_cast<jint>(
              mojom::SensorType::RELATIVE_ORIENTATION_QUATERNION)))) {
    auto sensor_fusion_algorithm =
        std::make_unique<OrientationEulerAnglesFusionAlgorithmUsingQuaternion>(
            false /* absolute */);
 
    PlatformSensorFusion::Create(reading_buffer, this,
                                  std::move(sensor_fusion_algorithm), callback);
   } else {
     callback.Run(nullptr);
  }
}
"," void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(
     JNIEnv* env,
    mojo::ScopedSharedBufferMapping mapping,
     const CreateSensorCallback& callback) {
   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(
           env, j_object_,
          static_cast<jint>(
              mojom::SensorType::RELATIVE_ORIENTATION_QUATERNION)))) {
    auto sensor_fusion_algorithm =
        std::make_unique<OrientationEulerAnglesFusionAlgorithmUsingQuaternion>(
            false /* absolute */);
 
    PlatformSensorFusion::Create(std::move(mapping), this,
                                  std::move(sensor_fusion_algorithm), callback);
   } else {
     callback.Run(nullptr);
  }
}
",C,"    SensorReadingSharedBuffer* reading_buffer,
    PlatformSensorFusion::Create(reading_buffer, this,
","    mojo::ScopedSharedBufferMapping mapping,
    PlatformSensorFusion::Create(std::move(mapping), this,
",,"@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {
 
 void PlatformSensorProviderAndroid::CreateSensorInternal(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   JNIEnv* env = AttachCurrentThread();
 
@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(
   // option.
   switch (type) {
     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:
-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),
-                                                 callback);
+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);
       break;
     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:
-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),
-                                                callback);
+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);
       break;
     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:
-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),
-                                                 callback);
+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);
       break;
     default: {
       ScopedJavaLocalRef<jobject> sensor =
@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(
       }
 
       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(
-          type, std::move(mapping), this, sensor);
+          type, reading_buffer, this, sensor);
       callback.Run(concrete_sensor);
       break;
     }
@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(
 //   C: Combination of ACCELEROMETER and MAGNETOMETER
 void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(
     JNIEnv* env,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(
           env, j_object_,
@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(
 
     // If this PlatformSensorFusion object is successfully initialized,
     // |callback| will be run with a reference to this object.
-    PlatformSensorFusion::Create(std::move(mapping), this,
+    PlatformSensorFusion::Create(reading_buffer, this,
                                  std::move(sensor_fusion_algorithm), callback);
   } else {
     auto sensor_fusion_algorithm = std::make_unique<
         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();
 
     // If this PlatformSensorFusion object is successfully initialized,
     // |callback| will be run with a reference to this object.
-    PlatformSensorFusion::Create(std::move(mapping), this,
+    PlatformSensorFusion::Create(reading_buffer, this,
                                  std::move(sensor_fusion_algorithm), callback);
   }
 }
@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(
 //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES
 void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(
     JNIEnv* env,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(
       env, j_object_,
       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));
 
   if (sensor.obj()) {
     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(
-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),
+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,
         this, sensor);
 
     callback.Run(concrete_sensor);
@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(
 
     // If this PlatformSensorFusion object is successfully initialized,
     // |callback| will be run with a reference to this object.
-    PlatformSensorFusion::Create(std::move(mapping), this,
+    PlatformSensorFusion::Create(reading_buffer, this,
                                  std::move(sensor_fusion_algorithm), callback);
   }
 }
@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(
 // (if it uses TYPE_GAME_ROTATION_VECTOR directly).
 void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(
     JNIEnv* env,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(
           env, j_object_,
@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(
 
     // If this PlatformSensorFusion object is successfully initialized,
     // |callback| will be run with a reference to this object.
-    PlatformSensorFusion::Create(std::move(mapping), this,
+    PlatformSensorFusion::Create(reading_buffer, this,
                                  std::move(sensor_fusion_algorithm), callback);
   } else {
     callback.Run(nullptr);",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1," void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(
     JNIEnv* env,
//flaw_line_below:
    mojo::ScopedSharedBufferMapping mapping,
//fix_flaw_line_below:
//    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(
           env, j_object_,
          static_cast<jint>(
              mojom::SensorType::RELATIVE_ORIENTATION_QUATERNION)))) {
    auto sensor_fusion_algorithm =
        std::make_unique<OrientationEulerAnglesFusionAlgorithmUsingQuaternion>(
            false /* absolute */);
 
     // If this PlatformSensorFusion object is successfully initialized,
     // |callback| will be run with a reference to this object.
//flaw_line_below:
    PlatformSensorFusion::Create(std::move(mapping), this,
//fix_flaw_line_below:
//    PlatformSensorFusion::Create(reading_buffer, this,
                                  std::move(sensor_fusion_algorithm), callback);
   } else {
     callback.Run(nullptr);
  }
}
"
9078,186814,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,5,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",8,services/device/generic_sensor/platform_sensor_provider_android.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}"," void PlatformSensorProviderAndroid::CreateSensorInternal(
     mojom::SensorType type,
    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   JNIEnv* env = AttachCurrentThread();
 
   switch (type) {
     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:
      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);
       break;
     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:
      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);
       break;
     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:
      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);
       break;
     default: {
       ScopedJavaLocalRef<jobject> sensor =
          Java_PlatformSensorProvider_createSensor(env, j_object_,
                                                   static_cast<jint>(type));

      if (!sensor.obj()) {
        callback.Run(nullptr);
        return;
       }
 
       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(
          type, reading_buffer, this, sensor);
       callback.Run(concrete_sensor);
       break;
     }
  }
}
"," void PlatformSensorProviderAndroid::CreateSensorInternal(
     mojom::SensorType type,
    mojo::ScopedSharedBufferMapping mapping,
     const CreateSensorCallback& callback) {
   JNIEnv* env = AttachCurrentThread();
 
   switch (type) {
     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:
      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),
                                                 callback);
       break;
     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:
      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),
                                                callback);
       break;
     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:
      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),
                                                 callback);
       break;
     default: {
       ScopedJavaLocalRef<jobject> sensor =
          Java_PlatformSensorProvider_createSensor(env, j_object_,
                                                   static_cast<jint>(type));

      if (!sensor.obj()) {
        callback.Run(nullptr);
        return;
       }
 
       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(
          type, std::move(mapping), this, sensor);
       callback.Run(concrete_sensor);
       break;
     }
  }
}
",C,"    SensorReadingSharedBuffer* reading_buffer,
      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);
      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);
      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);
          type, reading_buffer, this, sensor);
","    mojo::ScopedSharedBufferMapping mapping,
      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),
                                                 callback);
      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),
                                                callback);
      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),
                                                 callback);
          type, std::move(mapping), this, sensor);
",,"@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {
 
 void PlatformSensorProviderAndroid::CreateSensorInternal(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   JNIEnv* env = AttachCurrentThread();
 
@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(
   // option.
   switch (type) {
     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:
-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),
-                                                 callback);
+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);
       break;
     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:
-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),
-                                                callback);
+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);
       break;
     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:
-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),
-                                                 callback);
+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);
       break;
     default: {
       ScopedJavaLocalRef<jobject> sensor =
@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(
       }
 
       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(
-          type, std::move(mapping), this, sensor);
+          type, reading_buffer, this, sensor);
       callback.Run(concrete_sensor);
       break;
     }
@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(
 //   C: Combination of ACCELEROMETER and MAGNETOMETER
 void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(
     JNIEnv* env,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(
           env, j_object_,
@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(
 
     // If this PlatformSensorFusion object is successfully initialized,
     // |callback| will be run with a reference to this object.
-    PlatformSensorFusion::Create(std::move(mapping), this,
+    PlatformSensorFusion::Create(reading_buffer, this,
                                  std::move(sensor_fusion_algorithm), callback);
   } else {
     auto sensor_fusion_algorithm = std::make_unique<
         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();
 
     // If this PlatformSensorFusion object is successfully initialized,
     // |callback| will be run with a reference to this object.
-    PlatformSensorFusion::Create(std::move(mapping), this,
+    PlatformSensorFusion::Create(reading_buffer, this,
                                  std::move(sensor_fusion_algorithm), callback);
   }
 }
@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(
 //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES
 void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(
     JNIEnv* env,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(
       env, j_object_,
       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));
 
   if (sensor.obj()) {
     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(
-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),
+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,
         this, sensor);
 
     callback.Run(concrete_sensor);
@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(
 
     // If this PlatformSensorFusion object is successfully initialized,
     // |callback| will be run with a reference to this object.
-    PlatformSensorFusion::Create(std::move(mapping), this,
+    PlatformSensorFusion::Create(reading_buffer, this,
                                  std::move(sensor_fusion_algorithm), callback);
   }
 }
@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(
 // (if it uses TYPE_GAME_ROTATION_VECTOR directly).
 void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(
     JNIEnv* env,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(
           env, j_object_,
@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(
 
     // If this PlatformSensorFusion object is successfully initialized,
     // |callback| will be run with a reference to this object.
-    PlatformSensorFusion::Create(std::move(mapping), this,
+    PlatformSensorFusion::Create(reading_buffer, this,
                                  std::move(sensor_fusion_algorithm), callback);
   } else {
     callback.Run(nullptr);",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1," void PlatformSensorProviderAndroid::CreateSensorInternal(
     mojom::SensorType type,
//flaw_line_below:
    mojo::ScopedSharedBufferMapping mapping,
//fix_flaw_line_below:
//    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   JNIEnv* env = AttachCurrentThread();
 
  // Some of the sensors may not be available depending on the device and
  // Android version, so the fallback ensures selection of the best possible
   // option.
   switch (type) {
     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:
//flaw_line_below:
      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),
//flaw_line_below:
                                                 callback);
//fix_flaw_line_below:
//      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);
       break;
     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:
//flaw_line_below:
      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),
//flaw_line_below:
                                                callback);
//fix_flaw_line_below:
//      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);
       break;
     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:
//flaw_line_below:
      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),
//flaw_line_below:
                                                 callback);
//fix_flaw_line_below:
//      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);
       break;
     default: {
       ScopedJavaLocalRef<jobject> sensor =
          Java_PlatformSensorProvider_createSensor(env, j_object_,
                                                   static_cast<jint>(type));

      if (!sensor.obj()) {
        callback.Run(nullptr);
        return;
       }
 
       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(
//flaw_line_below:
          type, std::move(mapping), this, sensor);
//fix_flaw_line_below:
//          type, reading_buffer, this, sensor);
       callback.Run(concrete_sensor);
       break;
     }
  }
}
"
9079,186815,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,4,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",3,services/device/generic_sensor/platform_sensor_provider_base.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}","void PlatformSensorProviderBase::CreateSensor(
    mojom::SensorType type,
    const CreateSensorCallback& callback) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);

  if (!CreateSharedBufferIfNeeded()) {
    callback.Run(nullptr);
     return;
   }
 
  SensorReadingSharedBuffer* reading_buffer =
      GetSensorReadingSharedBufferForType(type);
  if (!reading_buffer) {
     callback.Run(nullptr);
     return;
   }

  auto it = requests_map_.find(type);
  if (it != requests_map_.end()) {
    it->second.push_back(callback);
  } else {  // This is the first CreateSensor call.
     requests_map_[type] = CallbackQueue({callback});
 
     CreateSensorInternal(
        type, reading_buffer,
         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,
                    base::Unretained(this), type));
   }
}
","void PlatformSensorProviderBase::CreateSensor(
    mojom::SensorType type,
    const CreateSensorCallback& callback) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);

  if (!CreateSharedBufferIfNeeded()) {
    callback.Run(nullptr);
     return;
   }
 
  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);
  if (!mapping) {
     callback.Run(nullptr);
     return;
   }

  auto it = requests_map_.find(type);
  if (it != requests_map_.end()) {
    it->second.push_back(callback);
  } else {  // This is the first CreateSensor call.
     requests_map_[type] = CallbackQueue({callback});
 
     CreateSensorInternal(
        type, std::move(mapping),
         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,
                    base::Unretained(this), type));
   }
}
",C,"  SensorReadingSharedBuffer* reading_buffer =
      GetSensorReadingSharedBufferForType(type);
  if (!reading_buffer) {
        type, reading_buffer,
","  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);
  if (!mapping) {
        type, std::move(mapping),
",,"@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(
     return;
   }
 
-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);
-  if (!mapping) {
+  SensorReadingSharedBuffer* reading_buffer =
+      GetSensorReadingSharedBufferForType(type);
+  if (!reading_buffer) {
     callback.Run(nullptr);
     return;
   }
@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(
     requests_map_[type] = CallbackQueue({callback});
 
     CreateSensorInternal(
-        type, std::move(mapping),
+        type, reading_buffer,
         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,
                    base::Unretained(this), type));
   }
@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(
 
 bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
-  if (shared_buffer_handle_.is_valid())
+  if (shared_buffer_mapping_.get())
     return true;
 
-  shared_buffer_handle_ =
-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);
-  return shared_buffer_handle_.is_valid();
+  if (!shared_buffer_handle_.is_valid()) {
+    shared_buffer_handle_ =
+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);
+    if (!shared_buffer_handle_.is_valid())
+      return false;
+  }
+
+  // Create a writable mapping for the buffer as soon as possible, that will be
+  // used by all platform sensor implementations that want to update it. Note
+  // that on Android, cloning the shared memory handle readonly (as performed
+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing
+  // future writable mappings to be created (but this one will survive).
+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);
+  return shared_buffer_mapping_.get() != nullptr;
 }
 
 void PlatformSensorProviderBase::FreeResourcesIfNeeded() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (sensor_map_.empty() && requests_map_.empty()) {
     FreeResources();
+    shared_buffer_mapping_.reset();
     shared_buffer_handle_.reset();
   }
 }
@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {
   return request_types;
 }
 
-mojo::ScopedSharedBufferMapping
-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {
-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(
-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));
-  if (mapping)
-    memset(mapping.get(), 0, kReadingBufferSize);
-  return mapping;
+SensorReadingSharedBuffer*
+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(
+    mojom::SensorType type) {
+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());
+  if (!ptr)
+    return nullptr;
+
+  ptr += SensorReadingSharedBuffer::GetOffset(type);
+  memset(ptr, 0, kReadingBufferSize);
+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);
 }
 
 }  // namespace device",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1,"void PlatformSensorProviderBase::CreateSensor(
    mojom::SensorType type,
    const CreateSensorCallback& callback) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);

  if (!CreateSharedBufferIfNeeded()) {
    callback.Run(nullptr);
     return;
   }
 
//flaw_line_below:
  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);
//flaw_line_below:
  if (!mapping) {
//fix_flaw_line_below:
//  SensorReadingSharedBuffer* reading_buffer =
//fix_flaw_line_below:
//      GetSensorReadingSharedBufferForType(type);
//fix_flaw_line_below:
//  if (!reading_buffer) {
     callback.Run(nullptr);
     return;
   }

  auto it = requests_map_.find(type);
  if (it != requests_map_.end()) {
    it->second.push_back(callback);
  } else {  // This is the first CreateSensor call.
     requests_map_[type] = CallbackQueue({callback});
 
     CreateSensorInternal(
//flaw_line_below:
        type, std::move(mapping),
//fix_flaw_line_below:
//        type, reading_buffer,
         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,
                    base::Unretained(this), type));
   }
}
"
9080,186816,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,15,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",4,services/device/generic_sensor/platform_sensor_provider_base.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}"," bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  if (shared_buffer_mapping_.get())
     return true;
 
  if (!shared_buffer_handle_.is_valid()) {
    shared_buffer_handle_ =
        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);
    if (!shared_buffer_handle_.is_valid())
      return false;
  }

  // Create a writable mapping for the buffer as soon as possible, that will be
  // used by all platform sensor implementations that want to update it. Note
  // that on Android, cloning the shared memory handle readonly (as performed
  // by CloneSharedBufferHandle()) will seal the region read-only, preventing
  // future writable mappings to be created (but this one will survive).
  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);
  return shared_buffer_mapping_.get() != nullptr;
 }
"," bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  if (shared_buffer_handle_.is_valid())
     return true;
 
  shared_buffer_handle_ =
      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);
  return shared_buffer_handle_.is_valid();
 }
",C,"  if (shared_buffer_mapping_.get())
  if (!shared_buffer_handle_.is_valid()) {
    shared_buffer_handle_ =
        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);
    if (!shared_buffer_handle_.is_valid())
      return false;
  }

  // Create a writable mapping for the buffer as soon as possible, that will be
  // used by all platform sensor implementations that want to update it. Note
  // that on Android, cloning the shared memory handle readonly (as performed
  // by CloneSharedBufferHandle()) will seal the region read-only, preventing
  // future writable mappings to be created (but this one will survive).
  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);
  return shared_buffer_mapping_.get() != nullptr;
","  if (shared_buffer_handle_.is_valid())
  shared_buffer_handle_ =
      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);
  return shared_buffer_handle_.is_valid();
",,"@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(
     return;
   }
 
-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);
-  if (!mapping) {
+  SensorReadingSharedBuffer* reading_buffer =
+      GetSensorReadingSharedBufferForType(type);
+  if (!reading_buffer) {
     callback.Run(nullptr);
     return;
   }
@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(
     requests_map_[type] = CallbackQueue({callback});
 
     CreateSensorInternal(
-        type, std::move(mapping),
+        type, reading_buffer,
         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,
                    base::Unretained(this), type));
   }
@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(
 
 bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
-  if (shared_buffer_handle_.is_valid())
+  if (shared_buffer_mapping_.get())
     return true;
 
-  shared_buffer_handle_ =
-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);
-  return shared_buffer_handle_.is_valid();
+  if (!shared_buffer_handle_.is_valid()) {
+    shared_buffer_handle_ =
+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);
+    if (!shared_buffer_handle_.is_valid())
+      return false;
+  }
+
+  // Create a writable mapping for the buffer as soon as possible, that will be
+  // used by all platform sensor implementations that want to update it. Note
+  // that on Android, cloning the shared memory handle readonly (as performed
+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing
+  // future writable mappings to be created (but this one will survive).
+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);
+  return shared_buffer_mapping_.get() != nullptr;
 }
 
 void PlatformSensorProviderBase::FreeResourcesIfNeeded() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (sensor_map_.empty() && requests_map_.empty()) {
     FreeResources();
+    shared_buffer_mapping_.reset();
     shared_buffer_handle_.reset();
   }
 }
@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {
   return request_types;
 }
 
-mojo::ScopedSharedBufferMapping
-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {
-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(
-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));
-  if (mapping)
-    memset(mapping.get(), 0, kReadingBufferSize);
-  return mapping;
+SensorReadingSharedBuffer*
+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(
+    mojom::SensorType type) {
+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());
+  if (!ptr)
+    return nullptr;
+
+  ptr += SensorReadingSharedBuffer::GetOffset(type);
+  memset(ptr, 0, kReadingBufferSize);
+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);
 }
 
 }  // namespace device",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1," bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
//flaw_line_below:
  if (shared_buffer_handle_.is_valid())
//fix_flaw_line_below:
//  if (shared_buffer_mapping_.get())
     return true;
 
//flaw_line_below:
  shared_buffer_handle_ =
//flaw_line_below:
      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);
//flaw_line_below:
  return shared_buffer_handle_.is_valid();
//fix_flaw_line_below:
//  if (!shared_buffer_handle_.is_valid()) {
//fix_flaw_line_below:
//    shared_buffer_handle_ =
//fix_flaw_line_below:
//        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);
//fix_flaw_line_below:
//    if (!shared_buffer_handle_.is_valid())
//fix_flaw_line_below:
//      return false;
//fix_flaw_line_below:
//  }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  // Create a writable mapping for the buffer as soon as possible, that will be
//fix_flaw_line_below:
//  // used by all platform sensor implementations that want to update it. Note
//fix_flaw_line_below:
//  // that on Android, cloning the shared memory handle readonly (as performed
//fix_flaw_line_below:
//  // by CloneSharedBufferHandle()) will seal the region read-only, preventing
//fix_flaw_line_below:
//  // future writable mappings to be created (but this one will survive).
//fix_flaw_line_below:
//  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);
//fix_flaw_line_below:
//  return shared_buffer_mapping_.get() != nullptr;
 }
"
9081,186817,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,1,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",0,services/device/generic_sensor/platform_sensor_provider_base.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}"," void PlatformSensorProviderBase::FreeResourcesIfNeeded() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (sensor_map_.empty() && requests_map_.empty()) {
     FreeResources();
    shared_buffer_mapping_.reset();
     shared_buffer_handle_.reset();
   }
 }
"," void PlatformSensorProviderBase::FreeResourcesIfNeeded() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (sensor_map_.empty() && requests_map_.empty()) {
     FreeResources();
     shared_buffer_handle_.reset();
   }
 }
",C,"    shared_buffer_mapping_.reset();
",,,"@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(
     return;
   }
 
-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);
-  if (!mapping) {
+  SensorReadingSharedBuffer* reading_buffer =
+      GetSensorReadingSharedBufferForType(type);
+  if (!reading_buffer) {
     callback.Run(nullptr);
     return;
   }
@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(
     requests_map_[type] = CallbackQueue({callback});
 
     CreateSensorInternal(
-        type, std::move(mapping),
+        type, reading_buffer,
         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,
                    base::Unretained(this), type));
   }
@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(
 
 bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
-  if (shared_buffer_handle_.is_valid())
+  if (shared_buffer_mapping_.get())
     return true;
 
-  shared_buffer_handle_ =
-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);
-  return shared_buffer_handle_.is_valid();
+  if (!shared_buffer_handle_.is_valid()) {
+    shared_buffer_handle_ =
+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);
+    if (!shared_buffer_handle_.is_valid())
+      return false;
+  }
+
+  // Create a writable mapping for the buffer as soon as possible, that will be
+  // used by all platform sensor implementations that want to update it. Note
+  // that on Android, cloning the shared memory handle readonly (as performed
+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing
+  // future writable mappings to be created (but this one will survive).
+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);
+  return shared_buffer_mapping_.get() != nullptr;
 }
 
 void PlatformSensorProviderBase::FreeResourcesIfNeeded() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (sensor_map_.empty() && requests_map_.empty()) {
     FreeResources();
+    shared_buffer_mapping_.reset();
     shared_buffer_handle_.reset();
   }
 }
@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {
   return request_types;
 }
 
-mojo::ScopedSharedBufferMapping
-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {
-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(
-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));
-  if (mapping)
-    memset(mapping.get(), 0, kReadingBufferSize);
-  return mapping;
+SensorReadingSharedBuffer*
+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(
+    mojom::SensorType type) {
+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());
+  if (!ptr)
+    return nullptr;
+
+  ptr += SensorReadingSharedBuffer::GetOffset(type);
+  memset(ptr, 0, kReadingBufferSize);
+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);
 }
 
 }  // namespace device",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1," void PlatformSensorProviderBase::FreeResourcesIfNeeded() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (sensor_map_.empty() && requests_map_.empty()) {
     FreeResources();
//fix_flaw_line_below:
//    shared_buffer_mapping_.reset();
     shared_buffer_handle_.reset();
   }
 }
"
9082,186818,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,10,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",5,services/device/generic_sensor/platform_sensor_provider_base.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}","PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {
SensorReadingSharedBuffer*
PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(
    mojom::SensorType type) {
  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());
  if (!ptr)
    return nullptr;

  ptr += SensorReadingSharedBuffer::GetOffset(type);
  memset(ptr, 0, kReadingBufferSize);
  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);
 }
","PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {
  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(
      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));
  if (mapping)
    memset(mapping.get(), 0, kReadingBufferSize);
  return mapping;
 }
",C,"SensorReadingSharedBuffer*
PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(
    mojom::SensorType type) {
  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());
  if (!ptr)
    return nullptr;

  ptr += SensorReadingSharedBuffer::GetOffset(type);
  memset(ptr, 0, kReadingBufferSize);
  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);
","  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(
      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));
  if (mapping)
    memset(mapping.get(), 0, kReadingBufferSize);
  return mapping;
",,"@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(
     return;
   }
 
-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);
-  if (!mapping) {
+  SensorReadingSharedBuffer* reading_buffer =
+      GetSensorReadingSharedBufferForType(type);
+  if (!reading_buffer) {
     callback.Run(nullptr);
     return;
   }
@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(
     requests_map_[type] = CallbackQueue({callback});
 
     CreateSensorInternal(
-        type, std::move(mapping),
+        type, reading_buffer,
         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,
                    base::Unretained(this), type));
   }
@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(
 
 bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
-  if (shared_buffer_handle_.is_valid())
+  if (shared_buffer_mapping_.get())
     return true;
 
-  shared_buffer_handle_ =
-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);
-  return shared_buffer_handle_.is_valid();
+  if (!shared_buffer_handle_.is_valid()) {
+    shared_buffer_handle_ =
+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);
+    if (!shared_buffer_handle_.is_valid())
+      return false;
+  }
+
+  // Create a writable mapping for the buffer as soon as possible, that will be
+  // used by all platform sensor implementations that want to update it. Note
+  // that on Android, cloning the shared memory handle readonly (as performed
+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing
+  // future writable mappings to be created (but this one will survive).
+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);
+  return shared_buffer_mapping_.get() != nullptr;
 }
 
 void PlatformSensorProviderBase::FreeResourcesIfNeeded() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (sensor_map_.empty() && requests_map_.empty()) {
     FreeResources();
+    shared_buffer_mapping_.reset();
     shared_buffer_handle_.reset();
   }
 }
@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {
   return request_types;
 }
 
-mojo::ScopedSharedBufferMapping
-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {
-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(
-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));
-  if (mapping)
-    memset(mapping.get(), 0, kReadingBufferSize);
-  return mapping;
+SensorReadingSharedBuffer*
+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(
+    mojom::SensorType type) {
+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());
+  if (!ptr)
+    return nullptr;
+
+  ptr += SensorReadingSharedBuffer::GetOffset(type);
+  memset(ptr, 0, kReadingBufferSize);
+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);
 }
 
 }  // namespace device",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1,"PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {
//flaw_line_below:
  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(
//flaw_line_below:
      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));
//flaw_line_below:
  if (mapping)
//flaw_line_below:
    memset(mapping.get(), 0, kReadingBufferSize);
//flaw_line_below:
  return mapping;
//fix_flaw_line_below:
//SensorReadingSharedBuffer*
//fix_flaw_line_below:
//PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(
//fix_flaw_line_below:
//    mojom::SensorType type) {
//fix_flaw_line_below:
//  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());
//fix_flaw_line_below:
//  if (!ptr)
//fix_flaw_line_below:
//    return nullptr;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  ptr += SensorReadingSharedBuffer::GetOffset(type);
//fix_flaw_line_below:
//  memset(ptr, 0, kReadingBufferSize);
//fix_flaw_line_below:
//  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);
 }
"
9083,186819,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,2,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",2,services/device/generic_sensor/platform_sensor_provider_linux.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}"," void PlatformSensorProviderLinux::CreateFusionSensor(
     mojom::SensorType type,
    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   DCHECK(IsFusionSensorType(type));
   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;
  switch (type) {
    case mojom::SensorType::LINEAR_ACCELERATION:
      fusion_algorithm = std::make_unique<
          LinearAccelerationFusionAlgorithmUsingAccelerometer>();
      break;
    case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:
      fusion_algorithm = std::make_unique<
          RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();
      break;
    case mojom::SensorType::RELATIVE_ORIENTATION_QUATERNION:
      fusion_algorithm = std::make_unique<
          OrientationQuaternionFusionAlgorithmUsingEulerAngles>(
          false /* absolute */);
      break;
    default:
      NOTREACHED();
   }
 
   DCHECK(fusion_algorithm);
  PlatformSensorFusion::Create(reading_buffer, this,
                                std::move(fusion_algorithm), callback);
 }
"," void PlatformSensorProviderLinux::CreateFusionSensor(
     mojom::SensorType type,
    mojo::ScopedSharedBufferMapping mapping,
     const CreateSensorCallback& callback) {
   DCHECK(IsFusionSensorType(type));
   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;
  switch (type) {
    case mojom::SensorType::LINEAR_ACCELERATION:
      fusion_algorithm = std::make_unique<
          LinearAccelerationFusionAlgorithmUsingAccelerometer>();
      break;
    case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:
      fusion_algorithm = std::make_unique<
          RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();
      break;
    case mojom::SensorType::RELATIVE_ORIENTATION_QUATERNION:
      fusion_algorithm = std::make_unique<
          OrientationQuaternionFusionAlgorithmUsingEulerAngles>(
          false /* absolute */);
      break;
    default:
      NOTREACHED();
   }
 
   DCHECK(fusion_algorithm);
  PlatformSensorFusion::Create(std::move(mapping), this,
                                std::move(fusion_algorithm), callback);
 }
",C,"    SensorReadingSharedBuffer* reading_buffer,
  PlatformSensorFusion::Create(reading_buffer, this,
","    mojo::ScopedSharedBufferMapping mapping,
  PlatformSensorFusion::Create(std::move(mapping), this,
",,"@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {
 
 void PlatformSensorProviderLinux::CreateSensorInternal(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   if (!sensor_device_manager_)
     sensor_device_manager_.reset(new SensorDeviceManager());
 
   if (IsFusionSensorType(type)) {
     // For sensor fusion the device nodes initialization will happen
     // during fetching the source sensors.
-    CreateFusionSensor(type, std::move(mapping), callback);
+    CreateFusionSensor(type, reading_buffer, callback);
     return;
   }
 
@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(
     return;
   }
 
-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);
+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);
 }
 
 void PlatformSensorProviderLinux::SensorDeviceFound(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const PlatformSensorProviderBase::CreateSensorCallback& callback,
     const SensorInfoLinux* sensor_device) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(
   }
 
   scoped_refptr<PlatformSensorLinux> sensor =
-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,
+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,
                               polling_thread_->task_runner());
   callback.Run(sensor);
 }
@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(
     SensorInfoLinux* sensor_device) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   scoped_refptr<PlatformSensorLinux> sensor;
-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);
-  if (sensor_device && mapping && StartPollingThread()) {
-    sensor =
-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,
-                                polling_thread_->task_runner());
+  SensorReadingSharedBuffer* reading_buffer =
+      GetSensorReadingSharedBufferForType(type);
+  if (sensor_device && reading_buffer && StartPollingThread()) {
+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,
+                                     polling_thread_->task_runner());
   }
   NotifySensorCreated(type, sensor);
 }
@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(
 
 void PlatformSensorProviderLinux::CreateFusionSensor(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   DCHECK(IsFusionSensorType(type));
   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;
@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(
   }
 
   DCHECK(fusion_algorithm);
-  PlatformSensorFusion::Create(std::move(mapping), this,
+  PlatformSensorFusion::Create(reading_buffer, this,
                                std::move(fusion_algorithm), callback);
 }
 ",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1," void PlatformSensorProviderLinux::CreateFusionSensor(
     mojom::SensorType type,
//flaw_line_below:
    mojo::ScopedSharedBufferMapping mapping,
//fix_flaw_line_below:
//    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   DCHECK(IsFusionSensorType(type));
   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;
  switch (type) {
    case mojom::SensorType::LINEAR_ACCELERATION:
      fusion_algorithm = std::make_unique<
          LinearAccelerationFusionAlgorithmUsingAccelerometer>();
      break;
    case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:
      fusion_algorithm = std::make_unique<
          RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();
      break;
    case mojom::SensorType::RELATIVE_ORIENTATION_QUATERNION:
      fusion_algorithm = std::make_unique<
          OrientationQuaternionFusionAlgorithmUsingEulerAngles>(
          false /* absolute */);
      break;
    default:
      NOTREACHED();
   }
 
   DCHECK(fusion_algorithm);
//flaw_line_below:
  PlatformSensorFusion::Create(std::move(mapping), this,
//fix_flaw_line_below:
//  PlatformSensorFusion::Create(reading_buffer, this,
                                std::move(fusion_algorithm), callback);
 }
"
9084,186820,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,5,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",5,services/device/generic_sensor/platform_sensor_provider_linux.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}","void PlatformSensorProviderLinux::CreateSensorAndNotify(
    mojom::SensorType type,
     SensorInfoLinux* sensor_device) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   scoped_refptr<PlatformSensorLinux> sensor;
  SensorReadingSharedBuffer* reading_buffer =
      GetSensorReadingSharedBufferForType(type);
  if (sensor_device && reading_buffer && StartPollingThread()) {
    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,
                                     polling_thread_->task_runner());
   }
   NotifySensorCreated(type, sensor);
 }
","void PlatformSensorProviderLinux::CreateSensorAndNotify(
    mojom::SensorType type,
     SensorInfoLinux* sensor_device) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   scoped_refptr<PlatformSensorLinux> sensor;
  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);
  if (sensor_device && mapping && StartPollingThread()) {
    sensor =
        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,
                                polling_thread_->task_runner());
   }
   NotifySensorCreated(type, sensor);
 }
",C,"  SensorReadingSharedBuffer* reading_buffer =
      GetSensorReadingSharedBufferForType(type);
  if (sensor_device && reading_buffer && StartPollingThread()) {
    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,
                                     polling_thread_->task_runner());
","  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);
  if (sensor_device && mapping && StartPollingThread()) {
    sensor =
        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,
                                polling_thread_->task_runner());
",,"@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {
 
 void PlatformSensorProviderLinux::CreateSensorInternal(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   if (!sensor_device_manager_)
     sensor_device_manager_.reset(new SensorDeviceManager());
 
   if (IsFusionSensorType(type)) {
     // For sensor fusion the device nodes initialization will happen
     // during fetching the source sensors.
-    CreateFusionSensor(type, std::move(mapping), callback);
+    CreateFusionSensor(type, reading_buffer, callback);
     return;
   }
 
@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(
     return;
   }
 
-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);
+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);
 }
 
 void PlatformSensorProviderLinux::SensorDeviceFound(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const PlatformSensorProviderBase::CreateSensorCallback& callback,
     const SensorInfoLinux* sensor_device) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(
   }
 
   scoped_refptr<PlatformSensorLinux> sensor =
-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,
+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,
                               polling_thread_->task_runner());
   callback.Run(sensor);
 }
@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(
     SensorInfoLinux* sensor_device) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   scoped_refptr<PlatformSensorLinux> sensor;
-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);
-  if (sensor_device && mapping && StartPollingThread()) {
-    sensor =
-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,
-                                polling_thread_->task_runner());
+  SensorReadingSharedBuffer* reading_buffer =
+      GetSensorReadingSharedBufferForType(type);
+  if (sensor_device && reading_buffer && StartPollingThread()) {
+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,
+                                     polling_thread_->task_runner());
   }
   NotifySensorCreated(type, sensor);
 }
@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(
 
 void PlatformSensorProviderLinux::CreateFusionSensor(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   DCHECK(IsFusionSensorType(type));
   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;
@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(
   }
 
   DCHECK(fusion_algorithm);
-  PlatformSensorFusion::Create(std::move(mapping), this,
+  PlatformSensorFusion::Create(reading_buffer, this,
                                std::move(fusion_algorithm), callback);
 }
 ",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1,"void PlatformSensorProviderLinux::CreateSensorAndNotify(
    mojom::SensorType type,
     SensorInfoLinux* sensor_device) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   scoped_refptr<PlatformSensorLinux> sensor;
//flaw_line_below:
  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);
//flaw_line_below:
  if (sensor_device && mapping && StartPollingThread()) {
//flaw_line_below:
    sensor =
//flaw_line_below:
        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,
//flaw_line_below:
                                polling_thread_->task_runner());
//fix_flaw_line_below:
//  SensorReadingSharedBuffer* reading_buffer =
//fix_flaw_line_below:
//      GetSensorReadingSharedBufferForType(type);
//fix_flaw_line_below:
//  if (sensor_device && reading_buffer && StartPollingThread()) {
//fix_flaw_line_below:
//    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,
//fix_flaw_line_below:
//                                     polling_thread_->task_runner());
   }
   NotifySensorCreated(type, sensor);
 }
"
9085,186821,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,3,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",3,services/device/generic_sensor/platform_sensor_provider_linux.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}"," void PlatformSensorProviderLinux::CreateSensorInternal(
     mojom::SensorType type,
    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   if (!sensor_device_manager_)
     sensor_device_manager_.reset(new SensorDeviceManager());
 
   if (IsFusionSensorType(type)) {
    CreateFusionSensor(type, reading_buffer, callback);
     return;
   }
 
  if (!sensor_nodes_enumerated_) {
    if (!sensor_nodes_enumeration_started_) {
      sensor_nodes_enumeration_started_ = file_task_runner_->PostTask(
          FROM_HERE,
          base::Bind(&SensorDeviceManager::Start,
                     base::Unretained(sensor_device_manager_.get()), this));
    }
    return;
  }

  SensorInfoLinux* sensor_device = GetSensorDevice(type);
  if (!sensor_device) {
    callback.Run(nullptr);
     return;
   }
 
  SensorDeviceFound(type, reading_buffer, callback, sensor_device);
 }
"," void PlatformSensorProviderLinux::CreateSensorInternal(
     mojom::SensorType type,
    mojo::ScopedSharedBufferMapping mapping,
     const CreateSensorCallback& callback) {
   if (!sensor_device_manager_)
     sensor_device_manager_.reset(new SensorDeviceManager());
 
   if (IsFusionSensorType(type)) {
    CreateFusionSensor(type, std::move(mapping), callback);
     return;
   }
 
  if (!sensor_nodes_enumerated_) {
    if (!sensor_nodes_enumeration_started_) {
      sensor_nodes_enumeration_started_ = file_task_runner_->PostTask(
          FROM_HERE,
          base::Bind(&SensorDeviceManager::Start,
                     base::Unretained(sensor_device_manager_.get()), this));
    }
    return;
  }

  SensorInfoLinux* sensor_device = GetSensorDevice(type);
  if (!sensor_device) {
    callback.Run(nullptr);
     return;
   }
 
  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);
 }
",C,"    SensorReadingSharedBuffer* reading_buffer,
    CreateFusionSensor(type, reading_buffer, callback);
  SensorDeviceFound(type, reading_buffer, callback, sensor_device);
","    mojo::ScopedSharedBufferMapping mapping,
    CreateFusionSensor(type, std::move(mapping), callback);
  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);
",,"@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {
 
 void PlatformSensorProviderLinux::CreateSensorInternal(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   if (!sensor_device_manager_)
     sensor_device_manager_.reset(new SensorDeviceManager());
 
   if (IsFusionSensorType(type)) {
     // For sensor fusion the device nodes initialization will happen
     // during fetching the source sensors.
-    CreateFusionSensor(type, std::move(mapping), callback);
+    CreateFusionSensor(type, reading_buffer, callback);
     return;
   }
 
@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(
     return;
   }
 
-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);
+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);
 }
 
 void PlatformSensorProviderLinux::SensorDeviceFound(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const PlatformSensorProviderBase::CreateSensorCallback& callback,
     const SensorInfoLinux* sensor_device) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(
   }
 
   scoped_refptr<PlatformSensorLinux> sensor =
-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,
+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,
                               polling_thread_->task_runner());
   callback.Run(sensor);
 }
@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(
     SensorInfoLinux* sensor_device) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   scoped_refptr<PlatformSensorLinux> sensor;
-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);
-  if (sensor_device && mapping && StartPollingThread()) {
-    sensor =
-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,
-                                polling_thread_->task_runner());
+  SensorReadingSharedBuffer* reading_buffer =
+      GetSensorReadingSharedBufferForType(type);
+  if (sensor_device && reading_buffer && StartPollingThread()) {
+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,
+                                     polling_thread_->task_runner());
   }
   NotifySensorCreated(type, sensor);
 }
@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(
 
 void PlatformSensorProviderLinux::CreateFusionSensor(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   DCHECK(IsFusionSensorType(type));
   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;
@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(
   }
 
   DCHECK(fusion_algorithm);
-  PlatformSensorFusion::Create(std::move(mapping), this,
+  PlatformSensorFusion::Create(reading_buffer, this,
                                std::move(fusion_algorithm), callback);
 }
 ",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1," void PlatformSensorProviderLinux::CreateSensorInternal(
     mojom::SensorType type,
//flaw_line_below:
    mojo::ScopedSharedBufferMapping mapping,
//fix_flaw_line_below:
//    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   if (!sensor_device_manager_)
     sensor_device_manager_.reset(new SensorDeviceManager());
 
   if (IsFusionSensorType(type)) {
     // For sensor fusion the device nodes initialization will happen
     // during fetching the source sensors.
//flaw_line_below:
    CreateFusionSensor(type, std::move(mapping), callback);
//fix_flaw_line_below:
//    CreateFusionSensor(type, reading_buffer, callback);
     return;
   }
 
  if (!sensor_nodes_enumerated_) {
    if (!sensor_nodes_enumeration_started_) {
      sensor_nodes_enumeration_started_ = file_task_runner_->PostTask(
          FROM_HERE,
          base::Bind(&SensorDeviceManager::Start,
                     base::Unretained(sensor_device_manager_.get()), this));
    }
    return;
  }

  SensorInfoLinux* sensor_device = GetSensorDevice(type);
  if (!sensor_device) {
    callback.Run(nullptr);
     return;
   }
 
//flaw_line_below:
  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);
//fix_flaw_line_below:
//  SensorDeviceFound(type, reading_buffer, callback, sensor_device);
 }
"
9086,186822,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,2,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",2,services/device/generic_sensor/platform_sensor_provider_linux.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}"," void PlatformSensorProviderLinux::SensorDeviceFound(
     mojom::SensorType type,
    SensorReadingSharedBuffer* reading_buffer,
     const PlatformSensorProviderBase::CreateSensorCallback& callback,
     const SensorInfoLinux* sensor_device) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  DCHECK(sensor_device);

  if (!StartPollingThread()) {
    callback.Run(nullptr);
    return;
   }
 
   scoped_refptr<PlatformSensorLinux> sensor =
      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,
                               polling_thread_->task_runner());
   callback.Run(sensor);
 }
"," void PlatformSensorProviderLinux::SensorDeviceFound(
     mojom::SensorType type,
    mojo::ScopedSharedBufferMapping mapping,
     const PlatformSensorProviderBase::CreateSensorCallback& callback,
     const SensorInfoLinux* sensor_device) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  DCHECK(sensor_device);

  if (!StartPollingThread()) {
    callback.Run(nullptr);
    return;
   }
 
   scoped_refptr<PlatformSensorLinux> sensor =
      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,
                               polling_thread_->task_runner());
   callback.Run(sensor);
 }
",C,"    SensorReadingSharedBuffer* reading_buffer,
      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,
","    mojo::ScopedSharedBufferMapping mapping,
      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,
",,"@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {
 
 void PlatformSensorProviderLinux::CreateSensorInternal(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   if (!sensor_device_manager_)
     sensor_device_manager_.reset(new SensorDeviceManager());
 
   if (IsFusionSensorType(type)) {
     // For sensor fusion the device nodes initialization will happen
     // during fetching the source sensors.
-    CreateFusionSensor(type, std::move(mapping), callback);
+    CreateFusionSensor(type, reading_buffer, callback);
     return;
   }
 
@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(
     return;
   }
 
-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);
+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);
 }
 
 void PlatformSensorProviderLinux::SensorDeviceFound(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const PlatformSensorProviderBase::CreateSensorCallback& callback,
     const SensorInfoLinux* sensor_device) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(
   }
 
   scoped_refptr<PlatformSensorLinux> sensor =
-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,
+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,
                               polling_thread_->task_runner());
   callback.Run(sensor);
 }
@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(
     SensorInfoLinux* sensor_device) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   scoped_refptr<PlatformSensorLinux> sensor;
-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);
-  if (sensor_device && mapping && StartPollingThread()) {
-    sensor =
-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,
-                                polling_thread_->task_runner());
+  SensorReadingSharedBuffer* reading_buffer =
+      GetSensorReadingSharedBufferForType(type);
+  if (sensor_device && reading_buffer && StartPollingThread()) {
+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,
+                                     polling_thread_->task_runner());
   }
   NotifySensorCreated(type, sensor);
 }
@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(
 
 void PlatformSensorProviderLinux::CreateFusionSensor(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   DCHECK(IsFusionSensorType(type));
   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;
@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(
   }
 
   DCHECK(fusion_algorithm);
-  PlatformSensorFusion::Create(std::move(mapping), this,
+  PlatformSensorFusion::Create(reading_buffer, this,
                                std::move(fusion_algorithm), callback);
 }
 ",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1," void PlatformSensorProviderLinux::SensorDeviceFound(
     mojom::SensorType type,
//flaw_line_below:
    mojo::ScopedSharedBufferMapping mapping,
//fix_flaw_line_below:
//    SensorReadingSharedBuffer* reading_buffer,
     const PlatformSensorProviderBase::CreateSensorCallback& callback,
     const SensorInfoLinux* sensor_device) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  DCHECK(sensor_device);

  if (!StartPollingThread()) {
    callback.Run(nullptr);
    return;
   }
 
   scoped_refptr<PlatformSensorLinux> sensor =
//flaw_line_below:
      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,
//fix_flaw_line_below:
//      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,
                               polling_thread_->task_runner());
   callback.Run(sensor);
 }
"
9087,186823,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,5,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",5,services/device/generic_sensor/platform_sensor_provider_mac.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}"," void PlatformSensorProviderMac::CreateSensorInternal(
     mojom::SensorType type,
    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   switch (type) {
     case mojom::SensorType::AMBIENT_LIGHT: {
       scoped_refptr<PlatformSensor> sensor =
          new PlatformSensorAmbientLightMac(reading_buffer, this);
       callback.Run(std::move(sensor));
       break;
     }
     case mojom::SensorType::ACCELEROMETER: {
       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(
          reading_buffer, this));
       break;
     }
     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {
       auto fusion_algorithm = std::make_unique<
           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();
      PlatformSensorFusion::Create(reading_buffer, this,
                                    std::move(fusion_algorithm), callback);
       break;
     }
    case mojom::SensorType::RELATIVE_ORIENTATION_QUATERNION: {
      auto orientation_quaternion_fusion_algorithm_using_euler_angles =
          std::make_unique<
              OrientationQuaternionFusionAlgorithmUsingEulerAngles>(
              false /* absolute */);
       PlatformSensorFusion::Create(
          reading_buffer, this,
           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),
           callback);
       break;
    }
    default:
      callback.Run(nullptr);
  }
}
"," void PlatformSensorProviderMac::CreateSensorInternal(
     mojom::SensorType type,
    mojo::ScopedSharedBufferMapping mapping,
     const CreateSensorCallback& callback) {
   switch (type) {
     case mojom::SensorType::AMBIENT_LIGHT: {
       scoped_refptr<PlatformSensor> sensor =
          new PlatformSensorAmbientLightMac(std::move(mapping), this);
       callback.Run(std::move(sensor));
       break;
     }
     case mojom::SensorType::ACCELEROMETER: {
       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(
          std::move(mapping), this));
       break;
     }
     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {
       auto fusion_algorithm = std::make_unique<
           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();
      PlatformSensorFusion::Create(std::move(mapping), this,
                                    std::move(fusion_algorithm), callback);
       break;
     }
    case mojom::SensorType::RELATIVE_ORIENTATION_QUATERNION: {
      auto orientation_quaternion_fusion_algorithm_using_euler_angles =
          std::make_unique<
              OrientationQuaternionFusionAlgorithmUsingEulerAngles>(
              false /* absolute */);
       PlatformSensorFusion::Create(
          std::move(mapping), this,
           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),
           callback);
       break;
    }
    default:
      callback.Run(nullptr);
  }
}
",C,"    SensorReadingSharedBuffer* reading_buffer,
          new PlatformSensorAmbientLightMac(reading_buffer, this);
          reading_buffer, this));
      PlatformSensorFusion::Create(reading_buffer, this,
          reading_buffer, this,
","    mojo::ScopedSharedBufferMapping mapping,
          new PlatformSensorAmbientLightMac(std::move(mapping), this);
          std::move(mapping), this));
      PlatformSensorFusion::Create(std::move(mapping), this,
          std::move(mapping), this,
",,"@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;
 
 void PlatformSensorProviderMac::CreateSensorInternal(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   // Create Sensors here.
   switch (type) {
     case mojom::SensorType::AMBIENT_LIGHT: {
       scoped_refptr<PlatformSensor> sensor =
-          new PlatformSensorAmbientLightMac(std::move(mapping), this);
+          new PlatformSensorAmbientLightMac(reading_buffer, this);
       callback.Run(std::move(sensor));
       break;
     }
     case mojom::SensorType::ACCELEROMETER: {
       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(
-          std::move(mapping), this));
+          reading_buffer, this));
       break;
     }
     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {
       auto fusion_algorithm = std::make_unique<
           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();
       // If this PlatformSensorFusion object is successfully initialized,
       // |callback| will be run with a reference to this object.
-      PlatformSensorFusion::Create(std::move(mapping), this,
+      PlatformSensorFusion::Create(reading_buffer, this,
                                    std::move(fusion_algorithm), callback);
       break;
     }
@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(
       // If this PlatformSensorFusion object is successfully initialized,
       // |callback| will be run with a reference to this object.
       PlatformSensorFusion::Create(
-          std::move(mapping), this,
+          reading_buffer, this,
           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),
           callback);
       break;",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1," void PlatformSensorProviderMac::CreateSensorInternal(
     mojom::SensorType type,
//flaw_line_below:
    mojo::ScopedSharedBufferMapping mapping,
//fix_flaw_line_below:
//    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   // Create Sensors here.
   switch (type) {
     case mojom::SensorType::AMBIENT_LIGHT: {
       scoped_refptr<PlatformSensor> sensor =
//flaw_line_below:
          new PlatformSensorAmbientLightMac(std::move(mapping), this);
//fix_flaw_line_below:
//          new PlatformSensorAmbientLightMac(reading_buffer, this);
       callback.Run(std::move(sensor));
       break;
     }
     case mojom::SensorType::ACCELEROMETER: {
       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(
//flaw_line_below:
          std::move(mapping), this));
//fix_flaw_line_below:
//          reading_buffer, this));
       break;
     }
     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {
       auto fusion_algorithm = std::make_unique<
           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();
       // If this PlatformSensorFusion object is successfully initialized,
       // |callback| will be run with a reference to this object.
//flaw_line_below:
      PlatformSensorFusion::Create(std::move(mapping), this,
//fix_flaw_line_below:
//      PlatformSensorFusion::Create(reading_buffer, this,
                                    std::move(fusion_algorithm), callback);
       break;
     }
    case mojom::SensorType::RELATIVE_ORIENTATION_QUATERNION: {
      auto orientation_quaternion_fusion_algorithm_using_euler_angles =
          std::make_unique<
              OrientationQuaternionFusionAlgorithmUsingEulerAngles>(
              false /* absolute */);
       // If this PlatformSensorFusion object is successfully initialized,
       // |callback| will be run with a reference to this object.
       PlatformSensorFusion::Create(
//flaw_line_below:
          std::move(mapping), this,
//fix_flaw_line_below:
//          reading_buffer, this,
           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),
           callback);
       break;
    }
    default:
      callback.Run(nullptr);
  }
}
"
9088,186824,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,4,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",5,services/device/generic_sensor/platform_sensor_provider_win.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}"," void PlatformSensorProviderWin::CreateSensorInternal(
     mojom::SensorType type,
    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (!StartSensorThread()) {
    callback.Run(nullptr);
    return;
  }

  switch (type) {
    case mojom::SensorType::LINEAR_ACCELERATION: {
      auto linear_acceleration_fusion_algorithm = std::make_unique<
          LinearAccelerationFusionAlgorithmUsingAccelerometer>();
       PlatformSensorFusion::Create(
          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),
          callback);
       break;
     }
 
    default: {
      base::PostTaskAndReplyWithResult(
          sensor_thread_->task_runner().get(), FROM_HERE,
           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,
                      base::Unretained(this), type),
           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,
                     base::Unretained(this), type, reading_buffer, callback));
       break;
     }
   }
}
"," void PlatformSensorProviderWin::CreateSensorInternal(
     mojom::SensorType type,
    mojo::ScopedSharedBufferMapping mapping,
     const CreateSensorCallback& callback) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (!StartSensorThread()) {
    callback.Run(nullptr);
    return;
  }

  switch (type) {
    case mojom::SensorType::LINEAR_ACCELERATION: {
      auto linear_acceleration_fusion_algorithm = std::make_unique<
          LinearAccelerationFusionAlgorithmUsingAccelerometer>();
       PlatformSensorFusion::Create(
          std::move(mapping), this,
          std::move(linear_acceleration_fusion_algorithm), callback);
       break;
     }
 
    default: {
      base::PostTaskAndReplyWithResult(
          sensor_thread_->task_runner().get(), FROM_HERE,
           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,
                      base::Unretained(this), type),
           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,
                     base::Unretained(this), type, base::Passed(&mapping),
                     callback));
       break;
     }
   }
}
",C,"    SensorReadingSharedBuffer* reading_buffer,
          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),
          callback);
                     base::Unretained(this), type, reading_buffer, callback));
","    mojo::ScopedSharedBufferMapping mapping,
          std::move(mapping), this,
          std::move(linear_acceleration_fusion_algorithm), callback);
                     base::Unretained(this), type, base::Passed(&mapping),
                     callback));
",,"@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;
 
 void PlatformSensorProviderWin::CreateSensorInternal(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (!StartSensorThread()) {
@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(
       // If this PlatformSensorFusion object is successfully initialized,
       // |callback| will be run with a reference to this object.
       PlatformSensorFusion::Create(
-          std::move(mapping), this,
-          std::move(linear_acceleration_fusion_algorithm), callback);
+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),
+          callback);
       break;
     }
 
@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(
           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,
                      base::Unretained(this), type),
           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,
-                     base::Unretained(this), type, base::Passed(&mapping),
-                     callback));
+                     base::Unretained(this), type, reading_buffer, callback));
       break;
     }
   }
@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {
 
 void PlatformSensorProviderWin::SensorReaderCreated(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback,
     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(
   }
 
   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(
-      type, std::move(mapping), this, sensor_thread_->task_runner(),
+      type, reading_buffer, this, sensor_thread_->task_runner(),
       std::move(sensor_reader));
   callback.Run(sensor);
 }",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1," void PlatformSensorProviderWin::CreateSensorInternal(
     mojom::SensorType type,
//flaw_line_below:
    mojo::ScopedSharedBufferMapping mapping,
//fix_flaw_line_below:
//    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (!StartSensorThread()) {
    callback.Run(nullptr);
    return;
  }

  switch (type) {
    // Fusion sensor.
    case mojom::SensorType::LINEAR_ACCELERATION: {
      auto linear_acceleration_fusion_algorithm = std::make_unique<
          LinearAccelerationFusionAlgorithmUsingAccelerometer>();
       // If this PlatformSensorFusion object is successfully initialized,
       // |callback| will be run with a reference to this object.
       PlatformSensorFusion::Create(
//flaw_line_below:
          std::move(mapping), this,
//flaw_line_below:
          std::move(linear_acceleration_fusion_algorithm), callback);
//fix_flaw_line_below:
//          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),
//fix_flaw_line_below:
//          callback);
       break;
     }
 
    // Try to create low-level sensors by default.
    default: {
      base::PostTaskAndReplyWithResult(
          sensor_thread_->task_runner().get(), FROM_HERE,
           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,
                      base::Unretained(this), type),
           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,
//flaw_line_below:
                     base::Unretained(this), type, base::Passed(&mapping),
//flaw_line_below:
                     callback));
//fix_flaw_line_below:
//                     base::Unretained(this), type, reading_buffer, callback));
       break;
     }
   }
}
"
9089,186825,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,2,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",2,services/device/generic_sensor/platform_sensor_provider_win.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}"," void PlatformSensorProviderWin::SensorReaderCreated(
     mojom::SensorType type,
    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback,
     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  if (!sensor_reader) {
    callback.Run(nullptr);
    return;
   }
 
   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(
      type, reading_buffer, this, sensor_thread_->task_runner(),
       std::move(sensor_reader));
   callback.Run(sensor);
 }
"," void PlatformSensorProviderWin::SensorReaderCreated(
     mojom::SensorType type,
    mojo::ScopedSharedBufferMapping mapping,
     const CreateSensorCallback& callback,
     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  if (!sensor_reader) {
    callback.Run(nullptr);
    return;
   }
 
   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(
      type, std::move(mapping), this, sensor_thread_->task_runner(),
       std::move(sensor_reader));
   callback.Run(sensor);
 }
",C,"    SensorReadingSharedBuffer* reading_buffer,
      type, reading_buffer, this, sensor_thread_->task_runner(),
","    mojo::ScopedSharedBufferMapping mapping,
      type, std::move(mapping), this, sensor_thread_->task_runner(),
",,"@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;
 
 void PlatformSensorProviderWin::CreateSensorInternal(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (!StartSensorThread()) {
@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(
       // If this PlatformSensorFusion object is successfully initialized,
       // |callback| will be run with a reference to this object.
       PlatformSensorFusion::Create(
-          std::move(mapping), this,
-          std::move(linear_acceleration_fusion_algorithm), callback);
+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),
+          callback);
       break;
     }
 
@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(
           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,
                      base::Unretained(this), type),
           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,
-                     base::Unretained(this), type, base::Passed(&mapping),
-                     callback));
+                     base::Unretained(this), type, reading_buffer, callback));
       break;
     }
   }
@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {
 
 void PlatformSensorProviderWin::SensorReaderCreated(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback,
     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(
   }
 
   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(
-      type, std::move(mapping), this, sensor_thread_->task_runner(),
+      type, reading_buffer, this, sensor_thread_->task_runner(),
       std::move(sensor_reader));
   callback.Run(sensor);
 }",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1," void PlatformSensorProviderWin::SensorReaderCreated(
     mojom::SensorType type,
//flaw_line_below:
    mojo::ScopedSharedBufferMapping mapping,
//fix_flaw_line_below:
//    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback,
     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  if (!sensor_reader) {
    callback.Run(nullptr);
    return;
   }
 
   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(
//flaw_line_below:
      type, std::move(mapping), this, sensor_thread_->task_runner(),
//fix_flaw_line_below:
//      type, reading_buffer, this, sensor_thread_->task_runner(),
       std::move(sensor_reader));
   callback.Run(sensor);
 }
"
9090,186826,,Remote,Not required,Partial,CVE-2018-6057,https://www.cvedetails.com/cve/CVE-2018-6057/,CWE-732,Medium,Partial,Partial,,2018-11-14,6.8,Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.,2019-10-02,Bypass ,2,https://github.com/chromium/chromium/commit/c0c8978849ac57e4ecd613ddc8ff7852a2054734,c0c8978849ac57e4ecd613ddc8ff7852a2054734,"android: Fix sensors in device service.

This patch fixes a bug that prevented more than one sensor data
to be available at once when using the device motion/orientation
API.

The issue was introduced by this other patch [1] which fixed
some security-related issues in the way shared memory region
handles are managed throughout Chromium (more details at
https://crbug.com/789959).

The device services sensor implementation doesnt work
correctly because it assumes it is possible to create a
writable mapping of a given shared memory region at any
time. This assumption is not correct on Android, once an
Ashmem region has been turned read-only, such mappings
are no longer possible.

To fix the implementation, this CL changes the following:

- PlatformSensor used to require moving a
  mojo::ScopedSharedBufferMapping into the newly-created
  instance. Said mapping being owned by and destroyed
  with the PlatformSensor instance.

  With this patch, the constructor instead takes a single
  pointer to the corresponding SensorReadingSharedBuffer,
  i.e. the area in memory where the sensor-specific
  reading data is located, and can be either updated
  or read-from.

  Note that the PlatformSensor does not own the mapping
  anymore.

- PlatformSensorProviderBase holds the *single* writable
  mapping that is used to store all SensorReadingSharedBuffer
  buffers. It is created just after the region itself,
  and thus can be used even after the region's access
  mode has been changed to read-only.

  Addresses within the mapping will be passed to
  PlatformSensor constructors, computed from the
  mapping's base address plus a sensor-specific
  offset.

  The mapping is now owned by the
  PlatformSensorProviderBase instance.

Note that, security-wise, nothing changes, because all
mojo::ScopedSharedBufferMapping before the patch actually
pointed to the same writable-page in memory anyway.

Since unit or integration tests didn't catch the regression
when [1] was submitted, this patch was tested manually by
running a newly-built Chrome apk in the Android emulator
and on a real device running Android O.

[1] https://chromium-review.googlesource.com/c/chromium/src/+/805238

BUG=805146
R=mattcary@chromium.org,alexilin@chromium.org,juncai@chromium.org,reillyg@chromium.org

Change-Id: I7d60a1cad278f48c361d2ece5a90de10eb082b44
Reviewed-on: https://chromium-review.googlesource.com/891180
Commit-Queue: David Turner <digit@chromium.org>
Reviewed-by: Reilly Grant <reillyg@chromium.org>
Reviewed-by: Matthew Cary <mattcary@chromium.org>
Reviewed-by: Alexandr Ilin <alexilin@chromium.org>
Cr-Commit-Position: refs/heads/master@{#532607}",2,services/device/generic_sensor/platform_sensor_win.cc,"{""sha"": ""166f9951490b40417ad7895b76111ddf5977c390"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -12,10 +12,11 @@ using ::testing::_;\n \n namespace device {\n \n-FakePlatformSensor::FakePlatformSensor(mojom::SensorType type,\n-                                       mojo::ScopedSharedBufferMapping mapping,\n-                                       PlatformSensorProvider* provider)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+FakePlatformSensor::FakePlatformSensor(\n+    mojom::SensorType type,\n+    SensorReadingSharedBuffer* reading_buffer,\n+    PlatformSensorProvider* provider)\n+    : PlatformSensor(type, reading_buffer, provider) {\n   ON_CALL(*this, StartSensor(_))\n       .WillByDefault(\n           Invoke([this](const PlatformSensorConfiguration& configuration) {\n@@ -68,18 +69,20 @@ FakePlatformSensorProvider::FakePlatformSensorProvider() {\n \n FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;\n \n-mojo::ScopedSharedBufferMapping FakePlatformSensorProvider::GetMapping(\n+SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(\n     mojom::SensorType type) {\n-  return CreateSharedBufferIfNeeded() ? MapSharedBufferForType(type) : nullptr;\n+  return CreateSharedBufferIfNeeded()\n+             ? GetSensorReadingSharedBufferForType(type)\n+             : nullptr;\n }\n \n void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n-      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n+      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n ""}<_**next**_>{""sha"": ""79cf9cd1fc1564a79cfd009d6fef811b8dadd436"", ""filename"": ""services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/fake_platform_sensor_and_provider.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/fake_platform_sensor_and_provider.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -15,7 +15,7 @@ namespace device {\n class FakePlatformSensor : public PlatformSensor {\n  public:\n   FakePlatformSensor(mojom::SensorType type,\n-                     mojo::ScopedSharedBufferMapping mapping,\n+                     SensorReadingSharedBuffer* reading_buffer,\n                      PlatformSensorProvider* provider);\n \n   // PlatformSensor:\n@@ -51,11 +51,11 @@ class FakePlatformSensorProvider : public PlatformSensorProvider {\n                     scoped_refptr<PlatformSensor>,\n                     const CreateSensorCallback&));\n \n-  mojo::ScopedSharedBufferMapping GetMapping(mojom::SensorType type);\n+  SensorReadingSharedBuffer* GetSensorReadingBuffer(mojom::SensorType type);\n \n  private:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   DISALLOW_COPY_AND_ASSIGN(FakePlatformSensorProvider);""}<_**next**_>{""sha"": ""7bc6b95fba3184593f83214088edba08e215e0e7"", ""filename"": ""services/device/generic_sensor/platform_sensor.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 7, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -16,10 +16,10 @@\n namespace device {\n \n PlatformSensor::PlatformSensor(mojom::SensorType type,\n-                               mojo::ScopedSharedBufferMapping mapping,\n+                               SensorReadingSharedBuffer* reading_buffer,\n                                PlatformSensorProvider* provider)\n     : task_runner_(base::ThreadTaskRunnerHandle::Get()),\n-      shared_buffer_mapping_(std::move(mapping)),\n+      reading_buffer_(reading_buffer),\n       type_(type),\n       provider_(provider),\n       weak_factory_(this) {}\n@@ -103,10 +103,8 @@ void PlatformSensor::RemoveClient(Client* client) {\n \n bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n-    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n-        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n-        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n+        std::make_unique<SensorReadingSharedBufferReader>(reading_buffer_);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n@@ -121,8 +119,7 @@ void PlatformSensor::UpdateSharedBufferAndNotifyClients(\n }\n \n void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n-  ReadingBuffer* buffer =\n-      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n+  ReadingBuffer* buffer = reading_buffer_;\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;""}<_**next**_>{""sha"": ""76aac492cd00e1c6212a1c6ccc0702491781ccfd"", ""filename"": ""services/device/generic_sensor/platform_sensor.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -78,7 +78,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n  protected:\n   virtual ~PlatformSensor();\n   PlatformSensor(mojom::SensorType type,\n-                 mojo::ScopedSharedBufferMapping mapping,\n+                 SensorReadingSharedBuffer* reading_buffer,\n                  PlatformSensorProvider* provider);\n \n   using ReadingBuffer = SensorReadingSharedBuffer;\n@@ -106,7 +106,7 @@ class PlatformSensor : public base::RefCountedThreadSafe<PlatformSensor> {\n \n  private:\n   friend class base::RefCountedThreadSafe<PlatformSensor>;\n-  const mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   std::unique_ptr<SensorReadingSharedBufferReader> shared_buffer_reader_;\n   mojom::SensorType type_;\n   ConfigMap config_map_;""}<_**next**_>{""sha"": ""1d0afc6fc80bdb0c935c4ba25b2b0b6aa52db0e0"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,9 +35,9 @@ namespace device {\n using mojom::SensorType;\n \n PlatformSensorAccelerometerMac::PlatformSensorAccelerometerMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::ACCELEROMETER, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::ACCELEROMETER, reading_buffer, provider),\n       sudden_motion_sensor_(SuddenMotionSensor::Create()) {}\n \n PlatformSensorAccelerometerMac::~PlatformSensorAccelerometerMac() = default;""}<_**next**_>{""sha"": ""8e8dbb03ab687b7ef499cf5e8744a8fc2ce0786b"", ""filename"": ""services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_accelerometer_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_accelerometer_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -23,7 +23,7 @@ class PlatformSensorAccelerometerMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of type ACCELEROMETER, given a buffer |mapping|\n   // where readings will be written.\n-  PlatformSensorAccelerometerMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAccelerometerMac(SensorReadingSharedBuffer* reading_buffer,\n                                  PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""c20fd92073b915cc4b89b98fca81618c5ce2bc0f"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -50,9 +50,9 @@ enum LmuFunctionIndex {\n };\n \n PlatformSensorAmbientLightMac::PlatformSensorAmbientLightMac(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider)\n-    : PlatformSensor(SensorType::AMBIENT_LIGHT, std::move(mapping), provider),\n+    : PlatformSensor(SensorType::AMBIENT_LIGHT, reading_buffer, provider),\n       light_sensor_port_(nullptr),\n       current_lux_(0.0) {}\n ""}<_**next**_>{""sha"": ""012647b41fc69f10f2a00895f4870a4705e1545a"", ""filename"": ""services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_ambient_light_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_ambient_light_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -21,7 +21,7 @@ class PlatformSensorAmbientLightMac : public PlatformSensor {\n  public:\n   // Construct a platform sensor of AMBIENT_LIGHT, given a buffer |mapping|\n   // to write the result back.\n-  PlatformSensorAmbientLightMac(mojo::ScopedSharedBufferMapping mapping,\n+  PlatformSensorAmbientLightMac(SensorReadingSharedBuffer* reading_buffer,\n                                 PlatformSensorProvider* provider);\n \n   mojom::ReportingMode GetReportingMode() override;""}<_**next**_>{""sha"": ""1be0f539a72229b28744d1145db69e32a56c2cb2"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,10 +14,10 @@ namespace device {\n \n PlatformSensorAndroid::PlatformSensorAndroid(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const JavaRef<jobject>& java_sensor)\n-    : PlatformSensor(type, std::move(mapping), provider) {\n+    : PlatformSensor(type, reading_buffer, provider) {\n   JNIEnv* env = AttachCurrentThread();\n   j_object_.Reset(java_sensor);\n ""}<_**next**_>{""sha"": ""7e3dd3d470d79c0d85ffc549e6ca3c91f13beb63"", ""filename"": ""services/device/generic_sensor/platform_sensor_android.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,7 +14,7 @@ namespace device {\n class PlatformSensorAndroid : public PlatformSensor {\n  public:\n   PlatformSensorAndroid(mojom::SensorType type,\n-                        mojo::ScopedSharedBufferMapping mapping,\n+                        SensorReadingSharedBuffer* reading_buffer,\n                         PlatformSensorProvider* provider,\n                         const base::android::JavaRef<jobject>& java_sensor);\n ""}<_**next**_>{""sha"": ""d7168a2b2240aedf261af4de3406fefb398a1647"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 13, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ namespace device {\n class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  public:\n   static void CreateSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       PlatformSensorProvider* provider) {\n-    scoped_refptr<Factory> factory(new Factory(std::move(mapping),\n+    scoped_refptr<Factory> factory(new Factory(reading_buffer,\n                                                std::move(fusion_algorithm),\n                                                std::move(callback), provider));\n     factory->FetchSources();\n@@ -27,20 +27,20 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n  private:\n   friend class base::RefCounted<Factory>;\n \n-  Factory(mojo::ScopedSharedBufferMapping mapping,\n+  Factory(SensorReadingSharedBuffer* reading_buffer,\n           std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n           const PlatformSensorProviderBase::CreateSensorCallback& callback,\n           PlatformSensorProvider* provider)\n       : fusion_algorithm_(std::move(fusion_algorithm)),\n         result_callback_(std::move(callback)),\n-        mapping_(std::move(mapping)),\n+        reading_buffer_(reading_buffer),\n         provider_(provider) {\n     const auto& types = fusion_algorithm_->source_types();\n     DCHECK(!types.empty());\n     // Make sure there are no dups.\n     DCHECK(std::adjacent_find(types.begin(), types.end()) == types.end());\n     DCHECK(result_callback_);\n-    DCHECK(mapping_);\n+    DCHECK(reading_buffer_);\n     DCHECK(provider_);\n   }\n \n@@ -74,37 +74,35 @@ class PlatformSensorFusion::Factory : public base::RefCounted<Factory> {\n     sources_map_[type] = std::move(sensor);\n     if (sources_map_.size() == fusion_algorithm_->source_types().size()) {\n       scoped_refptr<PlatformSensor> fusion_sensor(new PlatformSensorFusion(\n-          std::move(mapping_), provider_, std::move(fusion_algorithm_),\n+          reading_buffer_, provider_, std::move(fusion_algorithm_),\n           std::move(sources_map_)));\n       std::move(result_callback_).Run(fusion_sensor);\n     }\n   }\n \n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm_;\n   PlatformSensorProviderBase::CreateSensorCallback result_callback_;\n-  mojo::ScopedSharedBufferMapping mapping_;\n+  SensorReadingSharedBuffer* reading_buffer_;  // NOTE: Owned by |provider_|.\n   PlatformSensorProvider* provider_;\n   PlatformSensorFusion::SourcesMap sources_map_;\n };\n \n // static\n void PlatformSensorFusion::Create(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback) {\n-  Factory::CreateSensorFusion(std::move(mapping), std::move(fusion_algorithm),\n+  Factory::CreateSensorFusion(reading_buffer, std::move(fusion_algorithm),\n                               callback, provider);\n }\n \n PlatformSensorFusion::PlatformSensorFusion(\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n-    : PlatformSensor(fusion_algorithm->fused_type(),\n-                     std::move(mapping),\n-                     provider),\n+    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {""}<_**next**_>{""sha"": ""0ce3d9fb60fb278559419867111393a51be0232f"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -38,7 +38,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   // |callback| call: it can be either newly created object on success or\n   // nullptr on failure.\n   static void Create(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback);\n@@ -64,7 +64,7 @@ class PlatformSensorFusion : public PlatformSensor,\n   using SourcesMapEntry =\n       std::pair<mojom::SensorType, scoped_refptr<PlatformSensor>>;\n   PlatformSensorFusion(\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n       SourcesMap sources);""}<_**next**_>{""sha"": ""91106d5734dc5e05d71e805ad8f2f6bbabd931f2"", ""filename"": ""services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_fusion_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_fusion_unittest.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -85,8 +85,9 @@ class PlatformSensorFusionTest : public DeviceServiceTestBase {\n         base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,\n                    base::Unretained(this));\n     SensorType type = fusion_algorithm->fused_type();\n-    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),\n-                                 std::move(fusion_algorithm), callback);\n+    PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),\n+                                 provider_.get(), std::move(fusion_algorithm),\n+                                 callback);\n     EXPECT_TRUE(platform_sensor_fusion_callback_called_);\n   }\n ""}<_**next**_>{""sha"": ""19874eae972637d1e3b5d27f783e595350878d7f"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -25,11 +25,11 @@ bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n \n PlatformSensorLinux::PlatformSensorLinux(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     const SensorInfoLinux* sensor_device,\n     scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       default_configuration_(\n           PlatformSensorConfiguration(sensor_device->device_frequency)),\n       reporting_mode_(sensor_device->reporting_mode),""}<_**next**_>{""sha"": ""7d2337ed25fc4c600a111009ce65e93c41b5da0b"", ""filename"": ""services/device/generic_sensor/platform_sensor_linux.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -20,7 +20,7 @@ class PlatformSensorLinux : public PlatformSensor {\n  public:\n   PlatformSensorLinux(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       const SensorInfoLinux* sensor_device,\n       scoped_refptr<base::SingleThreadTaskRunner> polling_thread_task_runner);""}<_**next**_>{""sha"": ""44500357a44195d5a1271eb1b1155017c2689d07"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 16, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ void PlatformSensorProviderAndroid::SetSensorManagerToNullForTesting() {\n \n void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n \n@@ -54,16 +54,13 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n   // option.\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n-      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateAbsoluteOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n-      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n-                                                callback);\n+      CreateAbsoluteOrientationQuaternionSensor(env, reading_buffer, callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n-      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n-                                                 callback);\n+      CreateRelativeOrientationEulerAnglesSensor(env, reading_buffer, callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n@@ -76,7 +73,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n       }\n \n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-          type, std::move(mapping), this, sensor);\n+          type, reading_buffer, this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n@@ -93,7 +90,7 @@ void PlatformSensorProviderAndroid::CreateSensorInternal(\n //   C: Combination of ACCELEROMETER and MAGNETOMETER\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -105,15 +102,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -125,15 +122,15 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n //   B: ABSOLUTE_ORIENTATION_EULER_ANGLES\n void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n-        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n+        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, reading_buffer,\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n@@ -144,7 +141,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n@@ -153,7 +150,7 @@ void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n // (if it uses TYPE_GAME_ROTATION_VECTOR directly).\n void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n     JNIEnv* env,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n@@ -165,7 +162,7 @@ void PlatformSensorProviderAndroid::CreateRelativeOrientationEulerAnglesSensor(\n \n     // If this PlatformSensorFusion object is successfully initialized,\n     // |callback| will be run with a reference to this object.\n-    PlatformSensorFusion::Create(std::move(mapping), this,\n+    PlatformSensorFusion::Create(reading_buffer, this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     callback.Run(nullptr);""}<_**next**_>{""sha"": ""5c4a311af9b93758c46ab567331d8523d68fbf19"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_android.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_android.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_android.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -22,21 +22,21 @@ class PlatformSensorProviderAndroid : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n   void CreateAbsoluteOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateAbsoluteOrientationQuaternionSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n   void CreateRelativeOrientationEulerAnglesSensor(\n       JNIEnv* env,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback);\n \n   // Java object org.chromium.device.sensors.PlatformSensorProvider""}<_**next**_>{""sha"": ""887d84ee79bee2d669c844e987a1e4694c270a06"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.cc"", ""status"": ""modified"", ""additions"": 30, ""deletions"": 14, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -35,8 +35,9 @@ void PlatformSensorProviderBase::CreateSensor(\n     return;\n   }\n \n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (!mapping) {\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (!reading_buffer) {\n     callback.Run(nullptr);\n     return;\n   }\n@@ -48,7 +49,7 @@ void PlatformSensorProviderBase::CreateSensor(\n     requests_map_[type] = CallbackQueue({callback});\n \n     CreateSensorInternal(\n-        type, std::move(mapping),\n+        type, reading_buffer,\n         base::Bind(&PlatformSensorProviderBase::NotifySensorCreated,\n                    base::Unretained(this), type));\n   }\n@@ -66,18 +67,30 @@ scoped_refptr<PlatformSensor> PlatformSensorProviderBase::GetSensor(\n \n bool PlatformSensorProviderBase::CreateSharedBufferIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n-  if (shared_buffer_handle_.is_valid())\n+  if (shared_buffer_mapping_.get())\n     return true;\n \n-  shared_buffer_handle_ =\n-      mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n-  return shared_buffer_handle_.is_valid();\n+  if (!shared_buffer_handle_.is_valid()) {\n+    shared_buffer_handle_ =\n+        mojo::SharedBufferHandle::Create(kSharedBufferSizeInBytes);\n+    if (!shared_buffer_handle_.is_valid())\n+      return false;\n+  }\n+\n+  // Create a writable mapping for the buffer as soon as possible, that will be\n+  // used by all platform sensor implementations that want to update it. Note\n+  // that on Android, cloning the shared memory handle readonly (as performed\n+  // by CloneSharedBufferHandle()) will seal the region read-only, preventing\n+  // future writable mappings to be created (but this one will survive).\n+  shared_buffer_mapping_ = shared_buffer_handle_->Map(kSharedBufferSizeInBytes);\n+  return shared_buffer_mapping_.get() != nullptr;\n }\n \n void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n+    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n@@ -147,13 +160,16 @@ PlatformSensorProviderBase::GetPendingRequestTypes() {\n   return request_types;\n }\n \n-mojo::ScopedSharedBufferMapping\n-PlatformSensorProviderBase::MapSharedBufferForType(mojom::SensorType type) {\n-  mojo::ScopedSharedBufferMapping mapping = shared_buffer_handle_->MapAtOffset(\n-      kReadingBufferSize, SensorReadingSharedBuffer::GetOffset(type));\n-  if (mapping)\n-    memset(mapping.get(), 0, kReadingBufferSize);\n-  return mapping;\n+SensorReadingSharedBuffer*\n+PlatformSensorProviderBase::GetSensorReadingSharedBufferForType(\n+    mojom::SensorType type) {\n+  auto* ptr = static_cast<char*>(shared_buffer_mapping_.get());\n+  if (!ptr)\n+    return nullptr;\n+\n+  ptr += SensorReadingSharedBuffer::GetOffset(type);\n+  memset(ptr, 0, kReadingBufferSize);\n+  return reinterpret_cast<SensorReadingSharedBuffer*>(ptr);\n }\n \n }  // namespace device""}<_**next**_>{""sha"": ""de534d0b7433bc5f263025e517dffc65d99702f0"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_base.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_base.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -45,7 +45,7 @@ class PlatformSensorProviderBase {\n \n   // Method that must be implemented by platform specific classes.\n   virtual void CreateSensorInternal(mojom::SensorType type,\n-                                    mojo::ScopedSharedBufferMapping mapping,\n+                                    SensorReadingSharedBuffer* reading_buffer,\n                                     const CreateSensorCallback& callback) = 0;\n \n   // Implementations might override this method to free resources when there\n@@ -59,7 +59,7 @@ class PlatformSensorProviderBase {\n \n   bool CreateSharedBufferIfNeeded();\n \n-  mojo::ScopedSharedBufferMapping MapSharedBufferForType(\n+  SensorReadingSharedBuffer* GetSensorReadingSharedBufferForType(\n       mojom::SensorType type);\n \n   THREAD_CHECKER(thread_checker_);\n@@ -76,6 +76,7 @@ class PlatformSensorProviderBase {\n   std::map<mojom::SensorType, PlatformSensor*> sensor_map_;\n   std::map<mojom::SensorType, CallbackQueue> requests_map_;\n   mojo::ScopedSharedBufferHandle shared_buffer_handle_;\n+  mojo::ScopedSharedBufferMapping shared_buffer_mapping_;\n \n   DISALLOW_COPY_AND_ASSIGN(PlatformSensorProviderBase);\n };""}<_**next**_>{""sha"": ""4746313891dd3c67b203bdb478bb8798092feb2a"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 12, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -53,15 +53,15 @@ PlatformSensorProviderLinux::~PlatformSensorProviderLinux() {\n \n void PlatformSensorProviderLinux::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   if (!sensor_device_manager_)\n     sensor_device_manager_.reset(new SensorDeviceManager());\n \n   if (IsFusionSensorType(type)) {\n     // For sensor fusion the device nodes initialization will happen\n     // during fetching the source sensors.\n-    CreateFusionSensor(type, std::move(mapping), callback);\n+    CreateFusionSensor(type, reading_buffer, callback);\n     return;\n   }\n \n@@ -81,12 +81,12 @@ void PlatformSensorProviderLinux::CreateSensorInternal(\n     return;\n   }\n \n-  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);\n+  SensorDeviceFound(type, reading_buffer, callback, sensor_device);\n }\n \n void PlatformSensorProviderLinux::SensorDeviceFound(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const PlatformSensorProviderBase::CreateSensorCallback& callback,\n     const SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -98,7 +98,7 @@ void PlatformSensorProviderLinux::SensorDeviceFound(\n   }\n \n   scoped_refptr<PlatformSensorLinux> sensor =\n-      new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n+      new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n                               polling_thread_->task_runner());\n   callback.Run(sensor);\n }\n@@ -201,11 +201,11 @@ void PlatformSensorProviderLinux::CreateSensorAndNotify(\n     SensorInfoLinux* sensor_device) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   scoped_refptr<PlatformSensorLinux> sensor;\n-  mojo::ScopedSharedBufferMapping mapping = MapSharedBufferForType(type);\n-  if (sensor_device && mapping && StartPollingThread()) {\n-    sensor =\n-        new PlatformSensorLinux(type, std::move(mapping), this, sensor_device,\n-                                polling_thread_->task_runner());\n+  SensorReadingSharedBuffer* reading_buffer =\n+      GetSensorReadingSharedBufferForType(type);\n+  if (sensor_device && reading_buffer && StartPollingThread()) {\n+    sensor = new PlatformSensorLinux(type, reading_buffer, this, sensor_device,\n+                                     polling_thread_->task_runner());\n   }\n   NotifySensorCreated(type, sensor);\n }\n@@ -243,7 +243,7 @@ void PlatformSensorProviderLinux::OnDeviceRemoved(\n \n void PlatformSensorProviderLinux::CreateFusionSensor(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK(IsFusionSensorType(type));\n   std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm;\n@@ -266,7 +266,7 @@ void PlatformSensorProviderLinux::CreateFusionSensor(\n   }\n \n   DCHECK(fusion_algorithm);\n-  PlatformSensorFusion::Create(std::move(mapping), this,\n+  PlatformSensorFusion::Create(reading_buffer, this,\n                                std::move(fusion_algorithm), callback);\n }\n ""}<_**next**_>{""sha"": ""e308233d1969988747c102a59fe63e5ccc9fc6e4"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_linux.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_linux.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_linux.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -37,7 +37,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n   ~PlatformSensorProviderLinux() override;\n \n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n   void FreeResources() override;\n@@ -55,7 +55,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n \n   void SensorDeviceFound(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const PlatformSensorProviderBase::CreateSensorCallback& callback,\n       const SensorInfoLinux* sensor_device);\n \n@@ -92,7 +92,7 @@ class PlatformSensorProviderLinux : public PlatformSensorProvider,\n                        const std::string& device_node) override;\n \n   void CreateFusionSensor(mojom::SensorType type,\n-                          mojo::ScopedSharedBufferMapping mapping,\n+                          SensorReadingSharedBuffer* reading_buffer,\n                           const CreateSensorCallback& callback);\n \n   // Set to true when enumeration is ready.""}<_**next**_>{""sha"": ""8cbdbc1f2641be55017a65e898becba6e0e1317b"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,27 +27,27 @@ PlatformSensorProviderMac::~PlatformSensorProviderMac() = default;\n \n void PlatformSensorProviderMac::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   // Create Sensors here.\n   switch (type) {\n     case mojom::SensorType::AMBIENT_LIGHT: {\n       scoped_refptr<PlatformSensor> sensor =\n-          new PlatformSensorAmbientLightMac(std::move(mapping), this);\n+          new PlatformSensorAmbientLightMac(reading_buffer, this);\n       callback.Run(std::move(sensor));\n       break;\n     }\n     case mojom::SensorType::ACCELEROMETER: {\n       callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(\n-          std::move(mapping), this));\n+          reading_buffer, this));\n       break;\n     }\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {\n       auto fusion_algorithm = std::make_unique<\n           RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n-      PlatformSensorFusion::Create(std::move(mapping), this,\n+      PlatformSensorFusion::Create(reading_buffer, this,\n                                    std::move(fusion_algorithm), callback);\n       break;\n     }\n@@ -59,7 +59,7 @@ void PlatformSensorProviderMac::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n+          reading_buffer, this,\n           std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),\n           callback);\n       break;""}<_**next**_>{""sha"": ""79d11b1ff3515ccff3015189f008823378d5adaf"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_mac.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_mac.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_mac.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -18,7 +18,7 @@ class PlatformSensorProviderMac : public PlatformSensorProvider {\n \n  protected:\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:""}<_**next**_>{""sha"": ""15602986141ef7778f2fabc9e9f3e1e7cbb775ac"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -61,7 +61,7 @@ PlatformSensorProviderWin::~PlatformSensorProviderWin() = default;\n \n void PlatformSensorProviderWin::CreateSensorInternal(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (!StartSensorThread()) {\n@@ -77,8 +77,8 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n       // If this PlatformSensorFusion object is successfully initialized,\n       // |callback| will be run with a reference to this object.\n       PlatformSensorFusion::Create(\n-          std::move(mapping), this,\n-          std::move(linear_acceleration_fusion_algorithm), callback);\n+          reading_buffer, this, std::move(linear_acceleration_fusion_algorithm),\n+          callback);\n       break;\n     }\n \n@@ -89,8 +89,7 @@ void PlatformSensorProviderWin::CreateSensorInternal(\n           base::Bind(&PlatformSensorProviderWin::CreateSensorReader,\n                      base::Unretained(this), type),\n           base::Bind(&PlatformSensorProviderWin::SensorReaderCreated,\n-                     base::Unretained(this), type, base::Passed(&mapping),\n-                     callback));\n+                     base::Unretained(this), type, reading_buffer, callback));\n       break;\n     }\n   }\n@@ -119,7 +118,7 @@ void PlatformSensorProviderWin::StopSensorThread() {\n \n void PlatformSensorProviderWin::SensorReaderCreated(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     const CreateSensorCallback& callback,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n@@ -129,7 +128,7 @@ void PlatformSensorProviderWin::SensorReaderCreated(\n   }\n \n   scoped_refptr<PlatformSensor> sensor = new PlatformSensorWin(\n-      type, std::move(mapping), this, sensor_thread_->task_runner(),\n+      type, reading_buffer, this, sensor_thread_->task_runner(),\n       std::move(sensor_reader));\n   callback.Run(sensor);\n }""}<_**next**_>{""sha"": ""6b621b79809930e478cdba649b894f62e9e937c2"", ""filename"": ""services/device/generic_sensor/platform_sensor_provider_win.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_provider_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_provider_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -39,7 +39,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n   // PlatformSensorProvider interface implementation.\n   void FreeResources() override;\n   void CreateSensorInternal(mojom::SensorType type,\n-                            mojo::ScopedSharedBufferMapping mapping,\n+                            SensorReadingSharedBuffer* reading_buffer,\n                             const CreateSensorCallback& callback) override;\n \n  private:\n@@ -52,7 +52,7 @@ class PlatformSensorProviderWin final : public PlatformSensorProvider {\n       mojom::SensorType type);\n   void SensorReaderCreated(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       const CreateSensorCallback& callback,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);\n ""}<_**next**_>{""sha"": ""d1ee11459c5971dfa037d12737c755e3c8d43bc3"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.cc?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;\n \n PlatformSensorWin::PlatformSensorWin(\n     mojom::SensorType type,\n-    mojo::ScopedSharedBufferMapping mapping,\n+    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)\n-    : PlatformSensor(type, std::move(mapping), provider),\n+    : PlatformSensor(type, reading_buffer, provider),\n       sensor_thread_runner_(sensor_thread_runner),\n       sensor_reader_(sensor_reader.release()),\n       weak_factory_(this) {""}<_**next**_>{""sha"": ""bae519df27f7dc1daf51e589b5ed007f6d4ed27c"", ""filename"": ""services/device/generic_sensor/platform_sensor_win.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0c8978849ac57e4ecd613ddc8ff7852a2054734/services/device/generic_sensor/platform_sensor_win.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/services/device/generic_sensor/platform_sensor_win.h?ref=c0c8978849ac57e4ecd613ddc8ff7852a2054734"", ""patch"": ""@@ -27,7 +27,7 @@ class PlatformSensorWin final : public PlatformSensor,\n  public:\n   PlatformSensorWin(\n       mojom::SensorType type,\n-      mojo::ScopedSharedBufferMapping mapping,\n+      SensorReadingSharedBuffer* reading_buffer,\n       PlatformSensorProvider* provider,\n       scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,\n       std::unique_ptr<PlatformSensorReaderWin> sensor_reader);""}"," PlatformSensorWin::PlatformSensorWin(
     mojom::SensorType type,
    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider,
     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,
     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)
    : PlatformSensor(type, reading_buffer, provider),
       sensor_thread_runner_(sensor_thread_runner),
       sensor_reader_(sensor_reader.release()),
       weak_factory_(this) {
  DCHECK(sensor_reader_);
  sensor_reader_->SetClient(this);
}
"," PlatformSensorWin::PlatformSensorWin(
     mojom::SensorType type,
    mojo::ScopedSharedBufferMapping mapping,
     PlatformSensorProvider* provider,
     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,
     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)
    : PlatformSensor(type, std::move(mapping), provider),
       sensor_thread_runner_(sensor_thread_runner),
       sensor_reader_(sensor_reader.release()),
       weak_factory_(this) {
  DCHECK(sensor_reader_);
  sensor_reader_->SetClient(this);
}
",C,"    SensorReadingSharedBuffer* reading_buffer,
    : PlatformSensor(type, reading_buffer, provider),
","    mojo::ScopedSharedBufferMapping mapping,
    : PlatformSensor(type, std::move(mapping), provider),
",,"@@ -14,11 +14,11 @@ constexpr double kDefaultSensorReportingFrequency = 5.0;
 
 PlatformSensorWin::PlatformSensorWin(
     mojom::SensorType type,
-    mojo::ScopedSharedBufferMapping mapping,
+    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider,
     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,
     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)
-    : PlatformSensor(type, std::move(mapping), provider),
+    : PlatformSensor(type, reading_buffer, provider),
       sensor_thread_runner_(sensor_thread_runner),
       sensor_reader_(sensor_reader.release()),
       weak_factory_(this) {",Chrome,c0c8978849ac57e4ecd613ddc8ff7852a2054734,0ac4eda72ee08014ae7b920bff4b38df8fffdcd2,1," PlatformSensorWin::PlatformSensorWin(
     mojom::SensorType type,
//flaw_line_below:
    mojo::ScopedSharedBufferMapping mapping,
//fix_flaw_line_below:
//    SensorReadingSharedBuffer* reading_buffer,
     PlatformSensorProvider* provider,
     scoped_refptr<base::SingleThreadTaskRunner> sensor_thread_runner,
     std::unique_ptr<PlatformSensorReaderWin> sensor_reader)
//flaw_line_below:
    : PlatformSensor(type, std::move(mapping), provider),
//fix_flaw_line_below:
//    : PlatformSensor(type, reading_buffer, provider),
       sensor_thread_runner_(sensor_thread_runner),
       sensor_reader_(sensor_reader.release()),
       weak_factory_(this) {
  DCHECK(sensor_reader_);
  sensor_reader_->SetClient(this);
}
"
