,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix
3729,181465,,Remote,Not required,,CVE-2017-7177,https://www.cvedetails.com/cve/CVE-2017-7177/,CWE-358,Low,,Partial,,2017-03-18,5.0,Suricata before 3.2.1 has an IPv4 defragmentation evasion issue caused by lack of a check for the IP protocol during fragment matching.,2018-12-05,,1,https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8,4a04f814b15762eb446a5ead4d69d021512df6f8,"defrag - take protocol into account during re-assembly

The IP protocol was not being used to match fragments with
their packets allowing a carefully constructed packet
with a different protocol to be matched, allowing re-assembly
to complete, creating a packet that would not be re-assembled
by the destination host.",0,src/defrag-hash.c,"{""sha"": ""736099c58761058109931134cb06744878843604"", ""filename"": ""src/defrag-hash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag-hash.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -92,6 +92,7 @@ static void DefragTrackerInit(DefragTracker *dt, Packet *p)\n         dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);\n         dt->af = AF_INET6;\n     }\n+    dt->proto = IP_GET_IPPROTO(p);\n     dt->vlan_id[0] = p->vlan_id[0];\n     dt->vlan_id[1] = p->vlan_id[1];\n     dt->policy = DefragGetOsPolicy(p);\n@@ -406,6 +407,7 @@ static inline uint32_t DefragHashGetKey(Packet *p)\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->dst)) || \\\n       (CMP_ADDR(&(d1)->src_addr, &(d2)->dst) && \\\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->src))) && \\\n+     (d1)->proto == IP_GET_IPPROTO(p) &&        \\\n      (d1)->id == (id) && \\\n      (d1)->vlan_id[0] == (d2)->vlan_id[0] && \\\n      (d1)->vlan_id[1] == (d2)->vlan_id[1])""}<_**next**_>{""sha"": ""5433ce78607c5e694686de0fd2d93edec264b1bd"", ""filename"": ""src/defrag.c"", ""status"": ""modified"", ""additions"": 102, ""deletions"": 68, ""changes"": 170, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -996,8 +996,8 @@ void DefragDestroy(void)\n  * with some payload of no particular protocol.\n  */\n static Packet *\n-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     int hlen = 20;\n@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n     else\n         ip4h.ip_off = htons(off);\n     ip4h.ip_ttl = ttl;\n-    ip4h.ip_proto = IPPROTO_ICMP;\n+    ip4h.ip_proto = proto;\n \n     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */\n     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */\n@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n         goto error;\n     if (IPV4_GET_IPTTL(p) != ttl)\n         goto error;\n-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)\n+    if (IPV4_GET_IPPROTO(p) != proto)\n         goto error;\n \n     return p;\n@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,\n                           uint16_t prev_hdrextlen);\n \n static Packet *\n-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     uint8_t *pcontent;\n@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n     IPV6_SET_RAW_VER(p->ip6h, 6);\n     /* Fragmentation header. */\n     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));\n-    fh->ip6fh_nxt = IPPROTO_ICMP;\n+    fh->ip6fh_nxt = proto;\n     fh->ip6fh_ident = htonl(id);\n     fh->ip6fh_offlg = htons((off << 3) | mf);\n \n@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)\n     if (dc == NULL)\n         goto end;\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)\n \n     /* Load in 16 packets. */\n     for (i = 0; i < 16; i++) {\n-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);\n+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);\n         if (p == NULL)\n             goto end;\n \n@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)\n \n     /* Build a new packet but push the timestamp out by our timeout.\n      * This should force our previous fragments to be timed out. */\n-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);\n+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);\n     if (p == NULL)\n         goto end;\n \n@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)\n         goto end;\n \n     /* This packet has an offset > 0, more frags set to 0 and no data. */\n-    p = BuildTestPacket(id, 1, 0, 'A', 0);\n+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);\n     if (p == NULL)\n         goto end;\n \n@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)\n \n     /* Create a fragment that would extend past the max allowable size\n      * for an IPv4 packet. */\n-    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);\n     if (p == NULL)\n         goto end;\n \n@@ -2267,10 +2267,10 @@ DefragVlanTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)\n \n     /* Build a packet, its not a fragment but shouldn't matter for\n      * this test. */\n-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);\n     if (p1 == NULL) {\n         goto end;\n     }\n@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)\n     return retval;\n }\n \n+/**\n+ * \\brief Test that fragments that match other than the proto don't\n+ * actually get matched.\n+ */\n+static int DefragTestBadProto(void)\n+{\n+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n+    int id = 12;\n+\n+    DefragInit();\n+\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n+    FAIL_IF_NULL(p1);\n+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);\n+    FAIL_IF_NULL(p2);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n+    FAIL_IF_NULL(p3);\n+\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));\n+\n+    if (p1 != NULL)\n+        SCFree(p1);\n+    if (p2 != NULL)\n+        SCFree(p2);\n+    if (p3 != NULL)\n+        SCFree(p3);\n+\n+    DefragDestroy();\n+    PASS;\n+}\n+\n #endif /* UNITTESTS */\n \n void\n@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)\n     UtRegisterTest(\""DefragTimeoutTest\"", DefragTimeoutTest);\n     UtRegisterTest(\""DefragMfIpv4Test\"", DefragMfIpv4Test);\n     UtRegisterTest(\""DefragMfIpv6Test\"", DefragMfIpv6Test);\n+    UtRegisterTest(\""DefragTestBadProto\"", DefragTestBadProto);\n #endif /* UNITTESTS */\n }\n ""}<_**next**_>{""sha"": ""c3a0c693733a4199ce3ae7d37066e6c549edfcbd"", ""filename"": ""src/defrag.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.h?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -84,6 +84,8 @@ typedef struct DefragTracker_ {\n     uint32_t id; /**< IP ID for this tracker.  32 bits for IPv6, 16\n                   * for IPv4. */\n \n+    uint8_t proto; /**< IP protocol for this tracker. */\n+\n     uint8_t policy; /**< Reassembly policy this tracker will use. */\n \n     uint8_t af; /**< Address family for this tracker, AF_INET or""}","static void DefragTrackerInit(DefragTracker *dt, Packet *p)
{
    /* copy address */
    COPY_ADDRESS(&p->src, &dt->src_addr);
    COPY_ADDRESS(&p->dst, &dt->dst_addr);

    if (PKT_IS_IPV4(p)) {
        dt->id = (int32_t)IPV4_GET_IPID(p);
        dt->af = AF_INET;
    } else {
         dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);
         dt->af = AF_INET6;
     }
    dt->proto = IP_GET_IPPROTO(p);
     dt->vlan_id[0] = p->vlan_id[0];
     dt->vlan_id[1] = p->vlan_id[1];
     dt->policy = DefragGetOsPolicy(p);
    dt->host_timeout = DefragPolicyGetHostTimeout(p);
    dt->remove = 0;
    dt->seen_last = 0;

    TAILQ_INIT(&dt->frags);
    (void) DefragTrackerIncrUsecnt(dt);
}
","static void DefragTrackerInit(DefragTracker *dt, Packet *p)
{
    /* copy address */
    COPY_ADDRESS(&p->src, &dt->src_addr);
    COPY_ADDRESS(&p->dst, &dt->dst_addr);

    if (PKT_IS_IPV4(p)) {
        dt->id = (int32_t)IPV4_GET_IPID(p);
        dt->af = AF_INET;
    } else {
         dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);
         dt->af = AF_INET6;
     }
     dt->vlan_id[0] = p->vlan_id[0];
     dt->vlan_id[1] = p->vlan_id[1];
     dt->policy = DefragGetOsPolicy(p);
    dt->host_timeout = DefragPolicyGetHostTimeout(p);
    dt->remove = 0;
    dt->seen_last = 0;

    TAILQ_INIT(&dt->frags);
    (void) DefragTrackerIncrUsecnt(dt);
}
",C,"    dt->proto = IP_GET_IPPROTO(p);
",,,"@@ -92,6 +92,7 @@ static void DefragTrackerInit(DefragTracker *dt, Packet *p)
         dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);
         dt->af = AF_INET6;
     }
+    dt->proto = IP_GET_IPPROTO(p);
     dt->vlan_id[0] = p->vlan_id[0];
     dt->vlan_id[1] = p->vlan_id[1];
     dt->policy = DefragGetOsPolicy(p);
@@ -406,6 +407,7 @@ static inline uint32_t DefragHashGetKey(Packet *p)
        CMP_ADDR(&(d1)->dst_addr, &(d2)->dst)) || \
       (CMP_ADDR(&(d1)->src_addr, &(d2)->dst) && \
        CMP_ADDR(&(d1)->dst_addr, &(d2)->src))) && \
+     (d1)->proto == IP_GET_IPPROTO(p) &&        \
      (d1)->id == (id) && \
      (d1)->vlan_id[0] == (d2)->vlan_id[0] && \
      (d1)->vlan_id[1] == (d2)->vlan_id[1])",suricata,4a04f814b15762eb446a5ead4d69d021512df6f8,292baf0872abfebf2762e08e613565703595db6c,1,"static void DefragTrackerInit(DefragTracker *dt, Packet *p)
{
    /* copy address */
    COPY_ADDRESS(&p->src, &dt->src_addr);
    COPY_ADDRESS(&p->dst, &dt->dst_addr);

    if (PKT_IS_IPV4(p)) {
        dt->id = (int32_t)IPV4_GET_IPID(p);
        dt->af = AF_INET;
    } else {
         dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);
         dt->af = AF_INET6;
     }
//fix_flaw_line_below:
//    dt->proto = IP_GET_IPPROTO(p);
     dt->vlan_id[0] = p->vlan_id[0];
     dt->vlan_id[1] = p->vlan_id[1];
     dt->policy = DefragGetOsPolicy(p);
    dt->host_timeout = DefragPolicyGetHostTimeout(p);
    dt->remove = 0;
    dt->seen_last = 0;

    TAILQ_INIT(&dt->frags);
    (void) DefragTrackerIncrUsecnt(dt);
}
"
3730,181466,,Remote,Not required,,CVE-2017-7177,https://www.cvedetails.com/cve/CVE-2017-7177/,CWE-358,Low,,Partial,,2017-03-18,5.0,Suricata before 3.2.1 has an IPv4 defragmentation evasion issue caused by lack of a check for the IP protocol during fragment matching.,2018-12-05,,4,https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8,4a04f814b15762eb446a5ead4d69d021512df6f8,"defrag - take protocol into account during re-assembly

The IP protocol was not being used to match fragments with
their packets allowing a carefully constructed packet
with a different protocol to be matched, allowing re-assembly
to complete, creating a packet that would not be re-assembled
by the destination host.",3,src/defrag.c,"{""sha"": ""736099c58761058109931134cb06744878843604"", ""filename"": ""src/defrag-hash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag-hash.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -92,6 +92,7 @@ static void DefragTrackerInit(DefragTracker *dt, Packet *p)\n         dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);\n         dt->af = AF_INET6;\n     }\n+    dt->proto = IP_GET_IPPROTO(p);\n     dt->vlan_id[0] = p->vlan_id[0];\n     dt->vlan_id[1] = p->vlan_id[1];\n     dt->policy = DefragGetOsPolicy(p);\n@@ -406,6 +407,7 @@ static inline uint32_t DefragHashGetKey(Packet *p)\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->dst)) || \\\n       (CMP_ADDR(&(d1)->src_addr, &(d2)->dst) && \\\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->src))) && \\\n+     (d1)->proto == IP_GET_IPPROTO(p) &&        \\\n      (d1)->id == (id) && \\\n      (d1)->vlan_id[0] == (d2)->vlan_id[0] && \\\n      (d1)->vlan_id[1] == (d2)->vlan_id[1])""}<_**next**_>{""sha"": ""5433ce78607c5e694686de0fd2d93edec264b1bd"", ""filename"": ""src/defrag.c"", ""status"": ""modified"", ""additions"": 102, ""deletions"": 68, ""changes"": 170, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -996,8 +996,8 @@ void DefragDestroy(void)\n  * with some payload of no particular protocol.\n  */\n static Packet *\n-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     int hlen = 20;\n@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n     else\n         ip4h.ip_off = htons(off);\n     ip4h.ip_ttl = ttl;\n-    ip4h.ip_proto = IPPROTO_ICMP;\n+    ip4h.ip_proto = proto;\n \n     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */\n     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */\n@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n         goto error;\n     if (IPV4_GET_IPTTL(p) != ttl)\n         goto error;\n-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)\n+    if (IPV4_GET_IPPROTO(p) != proto)\n         goto error;\n \n     return p;\n@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,\n                           uint16_t prev_hdrextlen);\n \n static Packet *\n-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     uint8_t *pcontent;\n@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n     IPV6_SET_RAW_VER(p->ip6h, 6);\n     /* Fragmentation header. */\n     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));\n-    fh->ip6fh_nxt = IPPROTO_ICMP;\n+    fh->ip6fh_nxt = proto;\n     fh->ip6fh_ident = htonl(id);\n     fh->ip6fh_offlg = htons((off << 3) | mf);\n \n@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)\n     if (dc == NULL)\n         goto end;\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)\n \n     /* Load in 16 packets. */\n     for (i = 0; i < 16; i++) {\n-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);\n+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);\n         if (p == NULL)\n             goto end;\n \n@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)\n \n     /* Build a new packet but push the timestamp out by our timeout.\n      * This should force our previous fragments to be timed out. */\n-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);\n+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);\n     if (p == NULL)\n         goto end;\n \n@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)\n         goto end;\n \n     /* This packet has an offset > 0, more frags set to 0 and no data. */\n-    p = BuildTestPacket(id, 1, 0, 'A', 0);\n+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);\n     if (p == NULL)\n         goto end;\n \n@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)\n \n     /* Create a fragment that would extend past the max allowable size\n      * for an IPv4 packet. */\n-    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);\n     if (p == NULL)\n         goto end;\n \n@@ -2267,10 +2267,10 @@ DefragVlanTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)\n \n     /* Build a packet, its not a fragment but shouldn't matter for\n      * this test. */\n-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);\n     if (p1 == NULL) {\n         goto end;\n     }\n@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)\n     return retval;\n }\n \n+/**\n+ * \\brief Test that fragments that match other than the proto don't\n+ * actually get matched.\n+ */\n+static int DefragTestBadProto(void)\n+{\n+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n+    int id = 12;\n+\n+    DefragInit();\n+\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n+    FAIL_IF_NULL(p1);\n+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);\n+    FAIL_IF_NULL(p2);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n+    FAIL_IF_NULL(p3);\n+\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));\n+\n+    if (p1 != NULL)\n+        SCFree(p1);\n+    if (p2 != NULL)\n+        SCFree(p2);\n+    if (p3 != NULL)\n+        SCFree(p3);\n+\n+    DefragDestroy();\n+    PASS;\n+}\n+\n #endif /* UNITTESTS */\n \n void\n@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)\n     UtRegisterTest(\""DefragTimeoutTest\"", DefragTimeoutTest);\n     UtRegisterTest(\""DefragMfIpv4Test\"", DefragMfIpv4Test);\n     UtRegisterTest(\""DefragMfIpv6Test\"", DefragMfIpv6Test);\n+    UtRegisterTest(\""DefragTestBadProto\"", DefragTestBadProto);\n #endif /* UNITTESTS */\n }\n ""}<_**next**_>{""sha"": ""c3a0c693733a4199ce3ae7d37066e6c549edfcbd"", ""filename"": ""src/defrag.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.h?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -84,6 +84,8 @@ typedef struct DefragTracker_ {\n     uint32_t id; /**< IP ID for this tracker.  32 bits for IPv6, 16\n                   * for IPv4. */\n \n+    uint8_t proto; /**< IP protocol for this tracker. */\n+\n     uint8_t policy; /**< Reassembly policy this tracker will use. */\n \n     uint8_t af; /**< Address family for this tracker, AF_INET or""}","BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,
    const char content, int content_len)
 {
     Packet *p = NULL;
     int hlen = 20;
    int ttl = 64;
    uint8_t *pcontent;
    IPV4Hdr ip4h;

    p = SCCalloc(1, sizeof(*p) + default_packet_size);
    if (unlikely(p == NULL))
        return NULL;

    PACKET_INITIALIZE(p);

    gettimeofday(&p->ts, NULL);
    ip4h.ip_verhl = 4 << 4;
    ip4h.ip_verhl |= hlen >> 2;
    ip4h.ip_len = htons(hlen + content_len);
    ip4h.ip_id = htons(id);
    ip4h.ip_off = htons(off);
    if (mf)
        ip4h.ip_off = htons(IP_MF | off);
     else
         ip4h.ip_off = htons(off);
     ip4h.ip_ttl = ttl;
    ip4h.ip_proto = proto;
 
     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */
     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */

    /* copy content_len crap, we need full length */
    PacketCopyData(p, (uint8_t *)&ip4h, sizeof(ip4h));
    p->ip4h = (IPV4Hdr *)GET_PKT_DATA(p);
    SET_IPV4_SRC_ADDR(p, &p->src);
    SET_IPV4_DST_ADDR(p, &p->dst);

    pcontent = SCCalloc(1, content_len);
    if (unlikely(pcontent == NULL))
        return NULL;
    memset(pcontent, content, content_len);
    PacketCopyDataOffset(p, hlen, pcontent, content_len);
    SET_PKT_LEN(p, hlen + content_len);
    SCFree(pcontent);

    p->ip4h->ip_csum = IPV4CalculateChecksum((uint16_t *)GET_PKT_DATA(p), hlen);

    /* Self test. */
    if (IPV4_GET_VER(p) != 4)
        goto error;
    if (IPV4_GET_HLEN(p) != hlen)
        goto error;
    if (IPV4_GET_IPLEN(p) != hlen + content_len)
        goto error;
    if (IPV4_GET_IPID(p) != id)
        goto error;
    if (IPV4_GET_IPOFFSET(p) != off)
        goto error;
    if (IPV4_GET_MF(p) != mf)
         goto error;
     if (IPV4_GET_IPTTL(p) != ttl)
         goto error;
    if (IPV4_GET_IPPROTO(p) != proto)
         goto error;
 
     return p;
error:
    if (p != NULL)
        SCFree(p);
    return NULL;
}
","BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
    int content_len)
 {
     Packet *p = NULL;
     int hlen = 20;
    int ttl = 64;
    uint8_t *pcontent;
    IPV4Hdr ip4h;

    p = SCCalloc(1, sizeof(*p) + default_packet_size);
    if (unlikely(p == NULL))
        return NULL;

    PACKET_INITIALIZE(p);

    gettimeofday(&p->ts, NULL);
    ip4h.ip_verhl = 4 << 4;
    ip4h.ip_verhl |= hlen >> 2;
    ip4h.ip_len = htons(hlen + content_len);
    ip4h.ip_id = htons(id);
    ip4h.ip_off = htons(off);
    if (mf)
        ip4h.ip_off = htons(IP_MF | off);
     else
         ip4h.ip_off = htons(off);
     ip4h.ip_ttl = ttl;
    ip4h.ip_proto = IPPROTO_ICMP;
 
     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */
     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */

    /* copy content_len crap, we need full length */
    PacketCopyData(p, (uint8_t *)&ip4h, sizeof(ip4h));
    p->ip4h = (IPV4Hdr *)GET_PKT_DATA(p);
    SET_IPV4_SRC_ADDR(p, &p->src);
    SET_IPV4_DST_ADDR(p, &p->dst);

    pcontent = SCCalloc(1, content_len);
    if (unlikely(pcontent == NULL))
        return NULL;
    memset(pcontent, content, content_len);
    PacketCopyDataOffset(p, hlen, pcontent, content_len);
    SET_PKT_LEN(p, hlen + content_len);
    SCFree(pcontent);

    p->ip4h->ip_csum = IPV4CalculateChecksum((uint16_t *)GET_PKT_DATA(p), hlen);

    /* Self test. */
    if (IPV4_GET_VER(p) != 4)
        goto error;
    if (IPV4_GET_HLEN(p) != hlen)
        goto error;
    if (IPV4_GET_IPLEN(p) != hlen + content_len)
        goto error;
    if (IPV4_GET_IPID(p) != id)
        goto error;
    if (IPV4_GET_IPOFFSET(p) != off)
        goto error;
    if (IPV4_GET_MF(p) != mf)
         goto error;
     if (IPV4_GET_IPTTL(p) != ttl)
         goto error;
    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)
         goto error;
 
     return p;
error:
    if (p != NULL)
        SCFree(p);
    return NULL;
}
",C,"BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,
    const char content, int content_len)
    ip4h.ip_proto = proto;
    if (IPV4_GET_IPPROTO(p) != proto)
","    int content_len)
    ip4h.ip_proto = IPPROTO_ICMP;
    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)
",,"@@ -996,8 +996,8 @@ void DefragDestroy(void)
  * with some payload of no particular protocol.
  */
 static Packet *
-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
-    int content_len)
+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     int hlen = 20;
@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
     else
         ip4h.ip_off = htons(off);
     ip4h.ip_ttl = ttl;
-    ip4h.ip_proto = IPPROTO_ICMP;
+    ip4h.ip_proto = proto;
 
     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */
     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */
@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
         goto error;
     if (IPV4_GET_IPTTL(p) != ttl)
         goto error;
-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)
+    if (IPV4_GET_IPPROTO(p) != proto)
         goto error;
 
     return p;
@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,
                           uint16_t prev_hdrextlen);
 
 static Packet *
-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
-    int content_len)
+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     uint8_t *pcontent;
@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
     IPV6_SET_RAW_VER(p->ip6h, 6);
     /* Fragmentation header. */
     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));
-    fh->ip6fh_nxt = IPPROTO_ICMP;
+    fh->ip6fh_nxt = proto;
     fh->ip6fh_ident = htonl(id);
     fh->ip6fh_offlg = htons((off << 3) | mf);
 
@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)
     if (dc == NULL)
         goto end;
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)
 
     /* Load in 16 packets. */
     for (i = 0; i < 16; i++) {
-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);
+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);
         if (p == NULL)
             goto end;
 
@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)
 
     /* Build a new packet but push the timestamp out by our timeout.
      * This should force our previous fragments to be timed out. */
-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);
+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);
     if (p == NULL)
         goto end;
 
@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)
         goto end;
 
     /* This packet has an offset > 0, more frags set to 0 and no data. */
-    p = BuildTestPacket(id, 1, 0, 'A', 0);
+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);
     if (p == NULL)
         goto end;
 
@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)
 
     /* Create a fragment that would extend past the max allowable size
      * for an IPv4 packet. */
-    p = BuildTestPacket(1, 8183, 0, 'A', 71);
+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);
     if (p == NULL)
         goto end;
 
@@ -2267,10 +2267,10 @@ DefragVlanTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)
 
     /* Build a packet, its not a fragment but shouldn't matter for
      * this test. */
-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);
     if (p1 == NULL) {
         goto end;
     }
@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)
 
     DefragInit();
 
-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)
 
     DefragInit();
 
-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)
     return retval;
 }
 
+/**
+ * \brief Test that fragments that match other than the proto don't
+ * actually get matched.
+ */
+static int DefragTestBadProto(void)
+{
+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
+    int id = 12;
+
+    DefragInit();
+
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
+    FAIL_IF_NULL(p1);
+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);
+    FAIL_IF_NULL(p2);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
+    FAIL_IF_NULL(p3);
+
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));
+
+    if (p1 != NULL)
+        SCFree(p1);
+    if (p2 != NULL)
+        SCFree(p2);
+    if (p3 != NULL)
+        SCFree(p3);
+
+    DefragDestroy();
+    PASS;
+}
+
 #endif /* UNITTESTS */
 
 void
@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)
     UtRegisterTest(""DefragTimeoutTest"", DefragTimeoutTest);
     UtRegisterTest(""DefragMfIpv4Test"", DefragMfIpv4Test);
     UtRegisterTest(""DefragMfIpv6Test"", DefragMfIpv6Test);
+    UtRegisterTest(""DefragTestBadProto"", DefragTestBadProto);
 #endif /* UNITTESTS */
 }
 ",suricata,4a04f814b15762eb446a5ead4d69d021512df6f8,292baf0872abfebf2762e08e613565703595db6c,1,"BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
//flaw_line_below:
    int content_len)
//fix_flaw_line_below:
//BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,
//fix_flaw_line_below:
//    const char content, int content_len)
 {
     Packet *p = NULL;
     int hlen = 20;
    int ttl = 64;
    uint8_t *pcontent;
    IPV4Hdr ip4h;

    p = SCCalloc(1, sizeof(*p) + default_packet_size);
    if (unlikely(p == NULL))
        return NULL;

    PACKET_INITIALIZE(p);

    gettimeofday(&p->ts, NULL);
    //p->ip4h = (IPV4Hdr *)GET_PKT_DATA(p);
    ip4h.ip_verhl = 4 << 4;
    ip4h.ip_verhl |= hlen >> 2;
    ip4h.ip_len = htons(hlen + content_len);
    ip4h.ip_id = htons(id);
    ip4h.ip_off = htons(off);
    if (mf)
        ip4h.ip_off = htons(IP_MF | off);
     else
         ip4h.ip_off = htons(off);
     ip4h.ip_ttl = ttl;
//flaw_line_below:
    ip4h.ip_proto = IPPROTO_ICMP;
//fix_flaw_line_below:
//    ip4h.ip_proto = proto;
 
     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */
     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */

    /* copy content_len crap, we need full length */
    PacketCopyData(p, (uint8_t *)&ip4h, sizeof(ip4h));
    p->ip4h = (IPV4Hdr *)GET_PKT_DATA(p);
    SET_IPV4_SRC_ADDR(p, &p->src);
    SET_IPV4_DST_ADDR(p, &p->dst);

    pcontent = SCCalloc(1, content_len);
    if (unlikely(pcontent == NULL))
        return NULL;
    memset(pcontent, content, content_len);
    PacketCopyDataOffset(p, hlen, pcontent, content_len);
    SET_PKT_LEN(p, hlen + content_len);
    SCFree(pcontent);

    p->ip4h->ip_csum = IPV4CalculateChecksum((uint16_t *)GET_PKT_DATA(p), hlen);

    /* Self test. */
    if (IPV4_GET_VER(p) != 4)
        goto error;
    if (IPV4_GET_HLEN(p) != hlen)
        goto error;
    if (IPV4_GET_IPLEN(p) != hlen + content_len)
        goto error;
    if (IPV4_GET_IPID(p) != id)
        goto error;
    if (IPV4_GET_IPOFFSET(p) != off)
        goto error;
    if (IPV4_GET_MF(p) != mf)
         goto error;
     if (IPV4_GET_IPTTL(p) != ttl)
         goto error;
//flaw_line_below:
    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)
//fix_flaw_line_below:
//    if (IPV4_GET_IPPROTO(p) != proto)
         goto error;
 
     return p;
error:
    if (p != NULL)
        SCFree(p);
    return NULL;
}
"
3731,181467,,Remote,Not required,,CVE-2017-7177,https://www.cvedetails.com/cve/CVE-2017-7177/,CWE-358,Low,,Partial,,2017-03-18,5.0,Suricata before 3.2.1 has an IPv4 defragmentation evasion issue caused by lack of a check for the IP protocol during fragment matching.,2018-12-05,,17,https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8,4a04f814b15762eb446a5ead4d69d021512df6f8,"defrag - take protocol into account during re-assembly

The IP protocol was not being used to match fragments with
their packets allowing a carefully constructed packet
with a different protocol to be matched, allowing re-assembly
to complete, creating a packet that would not be re-assembled
by the destination host.",17,src/defrag.c,"{""sha"": ""736099c58761058109931134cb06744878843604"", ""filename"": ""src/defrag-hash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag-hash.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -92,6 +92,7 @@ static void DefragTrackerInit(DefragTracker *dt, Packet *p)\n         dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);\n         dt->af = AF_INET6;\n     }\n+    dt->proto = IP_GET_IPPROTO(p);\n     dt->vlan_id[0] = p->vlan_id[0];\n     dt->vlan_id[1] = p->vlan_id[1];\n     dt->policy = DefragGetOsPolicy(p);\n@@ -406,6 +407,7 @@ static inline uint32_t DefragHashGetKey(Packet *p)\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->dst)) || \\\n       (CMP_ADDR(&(d1)->src_addr, &(d2)->dst) && \\\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->src))) && \\\n+     (d1)->proto == IP_GET_IPPROTO(p) &&        \\\n      (d1)->id == (id) && \\\n      (d1)->vlan_id[0] == (d2)->vlan_id[0] && \\\n      (d1)->vlan_id[1] == (d2)->vlan_id[1])""}<_**next**_>{""sha"": ""5433ce78607c5e694686de0fd2d93edec264b1bd"", ""filename"": ""src/defrag.c"", ""status"": ""modified"", ""additions"": 102, ""deletions"": 68, ""changes"": 170, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -996,8 +996,8 @@ void DefragDestroy(void)\n  * with some payload of no particular protocol.\n  */\n static Packet *\n-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     int hlen = 20;\n@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n     else\n         ip4h.ip_off = htons(off);\n     ip4h.ip_ttl = ttl;\n-    ip4h.ip_proto = IPPROTO_ICMP;\n+    ip4h.ip_proto = proto;\n \n     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */\n     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */\n@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n         goto error;\n     if (IPV4_GET_IPTTL(p) != ttl)\n         goto error;\n-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)\n+    if (IPV4_GET_IPPROTO(p) != proto)\n         goto error;\n \n     return p;\n@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,\n                           uint16_t prev_hdrextlen);\n \n static Packet *\n-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     uint8_t *pcontent;\n@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n     IPV6_SET_RAW_VER(p->ip6h, 6);\n     /* Fragmentation header. */\n     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));\n-    fh->ip6fh_nxt = IPPROTO_ICMP;\n+    fh->ip6fh_nxt = proto;\n     fh->ip6fh_ident = htonl(id);\n     fh->ip6fh_offlg = htons((off << 3) | mf);\n \n@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)\n     if (dc == NULL)\n         goto end;\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)\n \n     /* Load in 16 packets. */\n     for (i = 0; i < 16; i++) {\n-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);\n+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);\n         if (p == NULL)\n             goto end;\n \n@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)\n \n     /* Build a new packet but push the timestamp out by our timeout.\n      * This should force our previous fragments to be timed out. */\n-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);\n+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);\n     if (p == NULL)\n         goto end;\n \n@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)\n         goto end;\n \n     /* This packet has an offset > 0, more frags set to 0 and no data. */\n-    p = BuildTestPacket(id, 1, 0, 'A', 0);\n+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);\n     if (p == NULL)\n         goto end;\n \n@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)\n \n     /* Create a fragment that would extend past the max allowable size\n      * for an IPv4 packet. */\n-    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);\n     if (p == NULL)\n         goto end;\n \n@@ -2267,10 +2267,10 @@ DefragVlanTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)\n \n     /* Build a packet, its not a fragment but shouldn't matter for\n      * this test. */\n-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);\n     if (p1 == NULL) {\n         goto end;\n     }\n@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)\n     return retval;\n }\n \n+/**\n+ * \\brief Test that fragments that match other than the proto don't\n+ * actually get matched.\n+ */\n+static int DefragTestBadProto(void)\n+{\n+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n+    int id = 12;\n+\n+    DefragInit();\n+\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n+    FAIL_IF_NULL(p1);\n+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);\n+    FAIL_IF_NULL(p2);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n+    FAIL_IF_NULL(p3);\n+\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));\n+\n+    if (p1 != NULL)\n+        SCFree(p1);\n+    if (p2 != NULL)\n+        SCFree(p2);\n+    if (p3 != NULL)\n+        SCFree(p3);\n+\n+    DefragDestroy();\n+    PASS;\n+}\n+\n #endif /* UNITTESTS */\n \n void\n@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)\n     UtRegisterTest(\""DefragTimeoutTest\"", DefragTimeoutTest);\n     UtRegisterTest(\""DefragMfIpv4Test\"", DefragMfIpv4Test);\n     UtRegisterTest(\""DefragMfIpv6Test\"", DefragMfIpv6Test);\n+    UtRegisterTest(\""DefragTestBadProto\"", DefragTestBadProto);\n #endif /* UNITTESTS */\n }\n ""}<_**next**_>{""sha"": ""c3a0c693733a4199ce3ae7d37066e6c549edfcbd"", ""filename"": ""src/defrag.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.h?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -84,6 +84,8 @@ typedef struct DefragTracker_ {\n     uint32_t id; /**< IP ID for this tracker.  32 bits for IPv6, 16\n                   * for IPv4. */\n \n+    uint8_t proto; /**< IP protocol for this tracker. */\n+\n     uint8_t policy; /**< Reassembly policy this tracker will use. */\n \n     uint8_t af; /**< Address family for this tracker, AF_INET or""}","DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
{
    int i;
    int ret = 0;

    DefragInit();

    /*
     * Build the packets.
     */

    int id = 1;
    Packet *packets[17];
    memset(packets, 0x00, sizeof(packets));

    /*
     * Original fragments.
      */
 
     /* A*24 at 0. */
    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
    /* Send all but the last. */
    for (i = 0; i < 9; i++) {
        Packet *tp = Defrag(NULL, NULL, packets[i], NULL);
        if (tp != NULL) {
            SCFree(tp);
            goto end;
        }
        if (ENGINE_ISSET_EVENT(packets[i], IPV4_FRAG_OVERLAP)) {
            goto end;
        }
    }
    int overlap = 0;
    for (; i < 16; i++) {
        Packet *tp = Defrag(NULL, NULL, packets[i], NULL);
        if (tp != NULL) {
            SCFree(tp);
            goto end;
        }
        if (ENGINE_ISSET_EVENT(packets[i], IPV4_FRAG_OVERLAP)) {
            overlap++;
        }
    }
    if (!overlap) {
        goto end;
    }

    /* And now the last one. */
    Packet *reassembled = Defrag(NULL, NULL, packets[16], NULL);
    if (reassembled == NULL) {
        goto end;
    }

    if (IPV4_GET_HLEN(reassembled) != 20) {
        goto end;
    }
    if (IPV4_GET_IPLEN(reassembled) != 20 + 192) {
        goto end;
    }

    if (memcmp(GET_PKT_DATA(reassembled) + 20, expected, expected_len) != 0) {
        goto end;
    }
    SCFree(reassembled);

    /* Make sure all frags were returned back to the pool. */
    if (defrag_context->frag_pool->outstanding != 0) {
        goto end;
    }

    ret = 1;
end:
    for (i = 0; i < 17; i++) {
        SCFree(packets[i]);
    }
    DefragDestroy();
    return ret;
}
","DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
{
    int i;
    int ret = 0;

    DefragInit();

    /*
     * Build the packets.
     */

    int id = 1;
    Packet *packets[17];
    memset(packets, 0x00, sizeof(packets));

    /*
     * Original fragments.
      */
 
     /* A*24 at 0. */
    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
    /* Send all but the last. */
    for (i = 0; i < 9; i++) {
        Packet *tp = Defrag(NULL, NULL, packets[i], NULL);
        if (tp != NULL) {
            SCFree(tp);
            goto end;
        }
        if (ENGINE_ISSET_EVENT(packets[i], IPV4_FRAG_OVERLAP)) {
            goto end;
        }
    }
    int overlap = 0;
    for (; i < 16; i++) {
        Packet *tp = Defrag(NULL, NULL, packets[i], NULL);
        if (tp != NULL) {
            SCFree(tp);
            goto end;
        }
        if (ENGINE_ISSET_EVENT(packets[i], IPV4_FRAG_OVERLAP)) {
            overlap++;
        }
    }
    if (!overlap) {
        goto end;
    }

    /* And now the last one. */
    Packet *reassembled = Defrag(NULL, NULL, packets[16], NULL);
    if (reassembled == NULL) {
        goto end;
    }

    if (IPV4_GET_HLEN(reassembled) != 20) {
        goto end;
    }
    if (IPV4_GET_IPLEN(reassembled) != 20 + 192) {
        goto end;
    }

    if (memcmp(GET_PKT_DATA(reassembled) + 20, expected, expected_len) != 0) {
        goto end;
    }
    SCFree(reassembled);

    /* Make sure all frags were returned back to the pool. */
    if (defrag_context->frag_pool->outstanding != 0) {
        goto end;
    }

    ret = 1;
end:
    for (i = 0; i < 17; i++) {
        SCFree(packets[i]);
    }
    DefragDestroy();
    return ret;
}
",C,"    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);
    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);
    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);
    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);
    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);
    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);
    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);
    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);
    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);
    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);
    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);
    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);
    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);
    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);
    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);
    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);
    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);
","    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);
    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
",,"@@ -996,8 +996,8 @@ void DefragDestroy(void)
  * with some payload of no particular protocol.
  */
 static Packet *
-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
-    int content_len)
+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     int hlen = 20;
@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
     else
         ip4h.ip_off = htons(off);
     ip4h.ip_ttl = ttl;
-    ip4h.ip_proto = IPPROTO_ICMP;
+    ip4h.ip_proto = proto;
 
     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */
     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */
@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
         goto error;
     if (IPV4_GET_IPTTL(p) != ttl)
         goto error;
-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)
+    if (IPV4_GET_IPPROTO(p) != proto)
         goto error;
 
     return p;
@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,
                           uint16_t prev_hdrextlen);
 
 static Packet *
-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
-    int content_len)
+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     uint8_t *pcontent;
@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
     IPV6_SET_RAW_VER(p->ip6h, 6);
     /* Fragmentation header. */
     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));
-    fh->ip6fh_nxt = IPPROTO_ICMP;
+    fh->ip6fh_nxt = proto;
     fh->ip6fh_ident = htonl(id);
     fh->ip6fh_offlg = htons((off << 3) | mf);
 
@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)
     if (dc == NULL)
         goto end;
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)
 
     /* Load in 16 packets. */
     for (i = 0; i < 16; i++) {
-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);
+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);
         if (p == NULL)
             goto end;
 
@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)
 
     /* Build a new packet but push the timestamp out by our timeout.
      * This should force our previous fragments to be timed out. */
-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);
+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);
     if (p == NULL)
         goto end;
 
@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)
         goto end;
 
     /* This packet has an offset > 0, more frags set to 0 and no data. */
-    p = BuildTestPacket(id, 1, 0, 'A', 0);
+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);
     if (p == NULL)
         goto end;
 
@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)
 
     /* Create a fragment that would extend past the max allowable size
      * for an IPv4 packet. */
-    p = BuildTestPacket(1, 8183, 0, 'A', 71);
+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);
     if (p == NULL)
         goto end;
 
@@ -2267,10 +2267,10 @@ DefragVlanTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)
 
     /* Build a packet, its not a fragment but shouldn't matter for
      * this test. */
-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);
     if (p1 == NULL) {
         goto end;
     }
@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)
 
     DefragInit();
 
-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)
 
     DefragInit();
 
-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)
     return retval;
 }
 
+/**
+ * \brief Test that fragments that match other than the proto don't
+ * actually get matched.
+ */
+static int DefragTestBadProto(void)
+{
+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
+    int id = 12;
+
+    DefragInit();
+
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
+    FAIL_IF_NULL(p1);
+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);
+    FAIL_IF_NULL(p2);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
+    FAIL_IF_NULL(p3);
+
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));
+
+    if (p1 != NULL)
+        SCFree(p1);
+    if (p2 != NULL)
+        SCFree(p2);
+    if (p3 != NULL)
+        SCFree(p3);
+
+    DefragDestroy();
+    PASS;
+}
+
 #endif /* UNITTESTS */
 
 void
@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)
     UtRegisterTest(""DefragTimeoutTest"", DefragTimeoutTest);
     UtRegisterTest(""DefragMfIpv4Test"", DefragMfIpv4Test);
     UtRegisterTest(""DefragMfIpv6Test"", DefragMfIpv6Test);
+    UtRegisterTest(""DefragTestBadProto"", DefragTestBadProto);
 #endif /* UNITTESTS */
 }
 ",suricata,4a04f814b15762eb446a5ead4d69d021512df6f8,292baf0872abfebf2762e08e613565703595db6c,1,"DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
{
    int i;
    int ret = 0;

    DefragInit();

    /*
     * Build the packets.
     */

    int id = 1;
    Packet *packets[17];
    memset(packets, 0x00, sizeof(packets));

    /*
     * Original fragments.
      */
 
     /* A*24 at 0. */
//flaw_line_below:
    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);
//fix_flaw_line_below:
//    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
//flaw_line_below:
    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
//fix_flaw_line_below:
//    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
//flaw_line_below:
    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
//fix_flaw_line_below:
//    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
//flaw_line_below:
    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
//fix_flaw_line_below:
//    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
//flaw_line_below:
    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
//fix_flaw_line_below:
//    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
//flaw_line_below:
    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
//fix_flaw_line_below:
//    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
//flaw_line_below:
    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
//fix_flaw_line_below:
//    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
//flaw_line_below:
    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
//fix_flaw_line_below:
//    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
//flaw_line_below:
    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
//fix_flaw_line_below:
//    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
//flaw_line_below:
    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
//fix_flaw_line_below:
//    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
//flaw_line_below:
    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
//fix_flaw_line_below:
//    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
//flaw_line_below:
    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
//fix_flaw_line_below:
//    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
//flaw_line_below:
    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
//fix_flaw_line_below:
//    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
//flaw_line_below:
    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
//fix_flaw_line_below:
//    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
//flaw_line_below:
    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
//fix_flaw_line_below:
//    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
//flaw_line_below:
    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
//fix_flaw_line_below:
//    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
//flaw_line_below:
    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
//fix_flaw_line_below:
//    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
    /* Send all but the last. */
    for (i = 0; i < 9; i++) {
        Packet *tp = Defrag(NULL, NULL, packets[i], NULL);
        if (tp != NULL) {
            SCFree(tp);
            goto end;
        }
        if (ENGINE_ISSET_EVENT(packets[i], IPV4_FRAG_OVERLAP)) {
            goto end;
        }
    }
    int overlap = 0;
    for (; i < 16; i++) {
        Packet *tp = Defrag(NULL, NULL, packets[i], NULL);
        if (tp != NULL) {
            SCFree(tp);
            goto end;
        }
        if (ENGINE_ISSET_EVENT(packets[i], IPV4_FRAG_OVERLAP)) {
            overlap++;
        }
    }
    if (!overlap) {
        goto end;
    }

    /* And now the last one. */
    Packet *reassembled = Defrag(NULL, NULL, packets[16], NULL);
    if (reassembled == NULL) {
        goto end;
    }

    if (IPV4_GET_HLEN(reassembled) != 20) {
        goto end;
    }
    if (IPV4_GET_IPLEN(reassembled) != 20 + 192) {
        goto end;
    }

    if (memcmp(GET_PKT_DATA(reassembled) + 20, expected, expected_len) != 0) {
        goto end;
    }
    SCFree(reassembled);

    /* Make sure all frags were returned back to the pool. */
    if (defrag_context->frag_pool->outstanding != 0) {
        goto end;
    }

    ret = 1;
end:
    for (i = 0; i < 17; i++) {
        SCFree(packets[i]);
    }
    DefragDestroy();
    return ret;
}
"
3732,181468,,Remote,Not required,,CVE-2017-7177,https://www.cvedetails.com/cve/CVE-2017-7177/,CWE-358,Low,,Partial,,2017-03-18,5.0,Suricata before 3.2.1 has an IPv4 defragmentation evasion issue caused by lack of a check for the IP protocol during fragment matching.,2018-12-05,,1,https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8,4a04f814b15762eb446a5ead4d69d021512df6f8,"defrag - take protocol into account during re-assembly

The IP protocol was not being used to match fragments with
their packets allowing a carefully constructed packet
with a different protocol to be matched, allowing re-assembly
to complete, creating a packet that would not be re-assembled
by the destination host.",1,src/defrag.c,"{""sha"": ""736099c58761058109931134cb06744878843604"", ""filename"": ""src/defrag-hash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag-hash.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -92,6 +92,7 @@ static void DefragTrackerInit(DefragTracker *dt, Packet *p)\n         dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);\n         dt->af = AF_INET6;\n     }\n+    dt->proto = IP_GET_IPPROTO(p);\n     dt->vlan_id[0] = p->vlan_id[0];\n     dt->vlan_id[1] = p->vlan_id[1];\n     dt->policy = DefragGetOsPolicy(p);\n@@ -406,6 +407,7 @@ static inline uint32_t DefragHashGetKey(Packet *p)\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->dst)) || \\\n       (CMP_ADDR(&(d1)->src_addr, &(d2)->dst) && \\\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->src))) && \\\n+     (d1)->proto == IP_GET_IPPROTO(p) &&        \\\n      (d1)->id == (id) && \\\n      (d1)->vlan_id[0] == (d2)->vlan_id[0] && \\\n      (d1)->vlan_id[1] == (d2)->vlan_id[1])""}<_**next**_>{""sha"": ""5433ce78607c5e694686de0fd2d93edec264b1bd"", ""filename"": ""src/defrag.c"", ""status"": ""modified"", ""additions"": 102, ""deletions"": 68, ""changes"": 170, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -996,8 +996,8 @@ void DefragDestroy(void)\n  * with some payload of no particular protocol.\n  */\n static Packet *\n-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     int hlen = 20;\n@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n     else\n         ip4h.ip_off = htons(off);\n     ip4h.ip_ttl = ttl;\n-    ip4h.ip_proto = IPPROTO_ICMP;\n+    ip4h.ip_proto = proto;\n \n     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */\n     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */\n@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n         goto error;\n     if (IPV4_GET_IPTTL(p) != ttl)\n         goto error;\n-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)\n+    if (IPV4_GET_IPPROTO(p) != proto)\n         goto error;\n \n     return p;\n@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,\n                           uint16_t prev_hdrextlen);\n \n static Packet *\n-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     uint8_t *pcontent;\n@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n     IPV6_SET_RAW_VER(p->ip6h, 6);\n     /* Fragmentation header. */\n     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));\n-    fh->ip6fh_nxt = IPPROTO_ICMP;\n+    fh->ip6fh_nxt = proto;\n     fh->ip6fh_ident = htonl(id);\n     fh->ip6fh_offlg = htons((off << 3) | mf);\n \n@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)\n     if (dc == NULL)\n         goto end;\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)\n \n     /* Load in 16 packets. */\n     for (i = 0; i < 16; i++) {\n-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);\n+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);\n         if (p == NULL)\n             goto end;\n \n@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)\n \n     /* Build a new packet but push the timestamp out by our timeout.\n      * This should force our previous fragments to be timed out. */\n-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);\n+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);\n     if (p == NULL)\n         goto end;\n \n@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)\n         goto end;\n \n     /* This packet has an offset > 0, more frags set to 0 and no data. */\n-    p = BuildTestPacket(id, 1, 0, 'A', 0);\n+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);\n     if (p == NULL)\n         goto end;\n \n@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)\n \n     /* Create a fragment that would extend past the max allowable size\n      * for an IPv4 packet. */\n-    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);\n     if (p == NULL)\n         goto end;\n \n@@ -2267,10 +2267,10 @@ DefragVlanTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)\n \n     /* Build a packet, its not a fragment but shouldn't matter for\n      * this test. */\n-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);\n     if (p1 == NULL) {\n         goto end;\n     }\n@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)\n     return retval;\n }\n \n+/**\n+ * \\brief Test that fragments that match other than the proto don't\n+ * actually get matched.\n+ */\n+static int DefragTestBadProto(void)\n+{\n+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n+    int id = 12;\n+\n+    DefragInit();\n+\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n+    FAIL_IF_NULL(p1);\n+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);\n+    FAIL_IF_NULL(p2);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n+    FAIL_IF_NULL(p3);\n+\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));\n+\n+    if (p1 != NULL)\n+        SCFree(p1);\n+    if (p2 != NULL)\n+        SCFree(p2);\n+    if (p3 != NULL)\n+        SCFree(p3);\n+\n+    DefragDestroy();\n+    PASS;\n+}\n+\n #endif /* UNITTESTS */\n \n void\n@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)\n     UtRegisterTest(\""DefragTimeoutTest\"", DefragTimeoutTest);\n     UtRegisterTest(\""DefragMfIpv4Test\"", DefragMfIpv4Test);\n     UtRegisterTest(\""DefragMfIpv6Test\"", DefragMfIpv6Test);\n+    UtRegisterTest(\""DefragTestBadProto\"", DefragTestBadProto);\n #endif /* UNITTESTS */\n }\n ""}<_**next**_>{""sha"": ""c3a0c693733a4199ce3ae7d37066e6c549edfcbd"", ""filename"": ""src/defrag.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.h?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -84,6 +84,8 @@ typedef struct DefragTracker_ {\n     uint32_t id; /**< IP ID for this tracker.  32 bits for IPv6, 16\n                   * for IPv4. */\n \n+    uint8_t proto; /**< IP protocol for this tracker. */\n+\n     uint8_t policy; /**< Reassembly policy this tracker will use. */\n \n     uint8_t af; /**< Address family for this tracker, AF_INET or""}","DefragIPv4NoDataTest(void)
{
    DefragContext *dc = NULL;
    Packet *p = NULL;
    int id = 12;
    int ret = 0;

    DefragInit();

    dc = DefragContextNew();
    if (dc == NULL)
         goto end;
 
     /* This packet has an offset > 0, more frags set to 0 and no data. */
    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);
     if (p == NULL)
         goto end;
 
    /* We do not expect a packet returned. */
    if (Defrag(NULL, NULL, p, NULL) != NULL)
        goto end;

    /* The fragment should have been ignored so no fragments should
     * have been allocated from the pool. */
    if (dc->frag_pool->outstanding != 0)
        return 0;

    ret = 1;
end:
    if (dc != NULL)
        DefragContextDestroy(dc);
    if (p != NULL)
        SCFree(p);

    DefragDestroy();
    return ret;
}
","DefragIPv4NoDataTest(void)
{
    DefragContext *dc = NULL;
    Packet *p = NULL;
    int id = 12;
    int ret = 0;

    DefragInit();

    dc = DefragContextNew();
    if (dc == NULL)
         goto end;
 
     /* This packet has an offset > 0, more frags set to 0 and no data. */
    p = BuildTestPacket(id, 1, 0, 'A', 0);
     if (p == NULL)
         goto end;
 
    /* We do not expect a packet returned. */
    if (Defrag(NULL, NULL, p, NULL) != NULL)
        goto end;

    /* The fragment should have been ignored so no fragments should
     * have been allocated from the pool. */
    if (dc->frag_pool->outstanding != 0)
        return 0;

    ret = 1;
end:
    if (dc != NULL)
        DefragContextDestroy(dc);
    if (p != NULL)
        SCFree(p);

    DefragDestroy();
    return ret;
}
",C,"    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);
","    p = BuildTestPacket(id, 1, 0, 'A', 0);
",,"@@ -996,8 +996,8 @@ void DefragDestroy(void)
  * with some payload of no particular protocol.
  */
 static Packet *
-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
-    int content_len)
+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     int hlen = 20;
@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
     else
         ip4h.ip_off = htons(off);
     ip4h.ip_ttl = ttl;
-    ip4h.ip_proto = IPPROTO_ICMP;
+    ip4h.ip_proto = proto;
 
     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */
     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */
@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
         goto error;
     if (IPV4_GET_IPTTL(p) != ttl)
         goto error;
-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)
+    if (IPV4_GET_IPPROTO(p) != proto)
         goto error;
 
     return p;
@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,
                           uint16_t prev_hdrextlen);
 
 static Packet *
-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
-    int content_len)
+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     uint8_t *pcontent;
@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
     IPV6_SET_RAW_VER(p->ip6h, 6);
     /* Fragmentation header. */
     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));
-    fh->ip6fh_nxt = IPPROTO_ICMP;
+    fh->ip6fh_nxt = proto;
     fh->ip6fh_ident = htonl(id);
     fh->ip6fh_offlg = htons((off << 3) | mf);
 
@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)
     if (dc == NULL)
         goto end;
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)
 
     /* Load in 16 packets. */
     for (i = 0; i < 16; i++) {
-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);
+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);
         if (p == NULL)
             goto end;
 
@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)
 
     /* Build a new packet but push the timestamp out by our timeout.
      * This should force our previous fragments to be timed out. */
-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);
+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);
     if (p == NULL)
         goto end;
 
@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)
         goto end;
 
     /* This packet has an offset > 0, more frags set to 0 and no data. */
-    p = BuildTestPacket(id, 1, 0, 'A', 0);
+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);
     if (p == NULL)
         goto end;
 
@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)
 
     /* Create a fragment that would extend past the max allowable size
      * for an IPv4 packet. */
-    p = BuildTestPacket(1, 8183, 0, 'A', 71);
+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);
     if (p == NULL)
         goto end;
 
@@ -2267,10 +2267,10 @@ DefragVlanTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)
 
     /* Build a packet, its not a fragment but shouldn't matter for
      * this test. */
-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);
     if (p1 == NULL) {
         goto end;
     }
@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)
 
     DefragInit();
 
-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)
 
     DefragInit();
 
-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)
     return retval;
 }
 
+/**
+ * \brief Test that fragments that match other than the proto don't
+ * actually get matched.
+ */
+static int DefragTestBadProto(void)
+{
+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
+    int id = 12;
+
+    DefragInit();
+
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
+    FAIL_IF_NULL(p1);
+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);
+    FAIL_IF_NULL(p2);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
+    FAIL_IF_NULL(p3);
+
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));
+
+    if (p1 != NULL)
+        SCFree(p1);
+    if (p2 != NULL)
+        SCFree(p2);
+    if (p3 != NULL)
+        SCFree(p3);
+
+    DefragDestroy();
+    PASS;
+}
+
 #endif /* UNITTESTS */
 
 void
@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)
     UtRegisterTest(""DefragTimeoutTest"", DefragTimeoutTest);
     UtRegisterTest(""DefragMfIpv4Test"", DefragMfIpv4Test);
     UtRegisterTest(""DefragMfIpv6Test"", DefragMfIpv6Test);
+    UtRegisterTest(""DefragTestBadProto"", DefragTestBadProto);
 #endif /* UNITTESTS */
 }
 ",suricata,4a04f814b15762eb446a5ead4d69d021512df6f8,292baf0872abfebf2762e08e613565703595db6c,1,"DefragIPv4NoDataTest(void)
{
    DefragContext *dc = NULL;
    Packet *p = NULL;
    int id = 12;
    int ret = 0;

    DefragInit();

    dc = DefragContextNew();
    if (dc == NULL)
         goto end;
 
     /* This packet has an offset > 0, more frags set to 0 and no data. */
//flaw_line_below:
    p = BuildTestPacket(id, 1, 0, 'A', 0);
//fix_flaw_line_below:
//    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);
     if (p == NULL)
         goto end;
 
    /* We do not expect a packet returned. */
    if (Defrag(NULL, NULL, p, NULL) != NULL)
        goto end;

    /* The fragment should have been ignored so no fragments should
     * have been allocated from the pool. */
    if (dc->frag_pool->outstanding != 0)
        return 0;

    ret = 1;
end:
    if (dc != NULL)
        DefragContextDestroy(dc);
    if (p != NULL)
        SCFree(p);

    DefragDestroy();
    return ret;
}
"
3733,181469,,Remote,Not required,,CVE-2017-7177,https://www.cvedetails.com/cve/CVE-2017-7177/,CWE-358,Low,,Partial,,2017-03-18,5.0,Suricata before 3.2.1 has an IPv4 defragmentation evasion issue caused by lack of a check for the IP protocol during fragment matching.,2018-12-05,,1,https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8,4a04f814b15762eb446a5ead4d69d021512df6f8,"defrag - take protocol into account during re-assembly

The IP protocol was not being used to match fragments with
their packets allowing a carefully constructed packet
with a different protocol to be matched, allowing re-assembly
to complete, creating a packet that would not be re-assembled
by the destination host.",1,src/defrag.c,"{""sha"": ""736099c58761058109931134cb06744878843604"", ""filename"": ""src/defrag-hash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag-hash.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -92,6 +92,7 @@ static void DefragTrackerInit(DefragTracker *dt, Packet *p)\n         dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);\n         dt->af = AF_INET6;\n     }\n+    dt->proto = IP_GET_IPPROTO(p);\n     dt->vlan_id[0] = p->vlan_id[0];\n     dt->vlan_id[1] = p->vlan_id[1];\n     dt->policy = DefragGetOsPolicy(p);\n@@ -406,6 +407,7 @@ static inline uint32_t DefragHashGetKey(Packet *p)\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->dst)) || \\\n       (CMP_ADDR(&(d1)->src_addr, &(d2)->dst) && \\\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->src))) && \\\n+     (d1)->proto == IP_GET_IPPROTO(p) &&        \\\n      (d1)->id == (id) && \\\n      (d1)->vlan_id[0] == (d2)->vlan_id[0] && \\\n      (d1)->vlan_id[1] == (d2)->vlan_id[1])""}<_**next**_>{""sha"": ""5433ce78607c5e694686de0fd2d93edec264b1bd"", ""filename"": ""src/defrag.c"", ""status"": ""modified"", ""additions"": 102, ""deletions"": 68, ""changes"": 170, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -996,8 +996,8 @@ void DefragDestroy(void)\n  * with some payload of no particular protocol.\n  */\n static Packet *\n-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     int hlen = 20;\n@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n     else\n         ip4h.ip_off = htons(off);\n     ip4h.ip_ttl = ttl;\n-    ip4h.ip_proto = IPPROTO_ICMP;\n+    ip4h.ip_proto = proto;\n \n     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */\n     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */\n@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n         goto error;\n     if (IPV4_GET_IPTTL(p) != ttl)\n         goto error;\n-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)\n+    if (IPV4_GET_IPPROTO(p) != proto)\n         goto error;\n \n     return p;\n@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,\n                           uint16_t prev_hdrextlen);\n \n static Packet *\n-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     uint8_t *pcontent;\n@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n     IPV6_SET_RAW_VER(p->ip6h, 6);\n     /* Fragmentation header. */\n     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));\n-    fh->ip6fh_nxt = IPPROTO_ICMP;\n+    fh->ip6fh_nxt = proto;\n     fh->ip6fh_ident = htonl(id);\n     fh->ip6fh_offlg = htons((off << 3) | mf);\n \n@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)\n     if (dc == NULL)\n         goto end;\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)\n \n     /* Load in 16 packets. */\n     for (i = 0; i < 16; i++) {\n-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);\n+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);\n         if (p == NULL)\n             goto end;\n \n@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)\n \n     /* Build a new packet but push the timestamp out by our timeout.\n      * This should force our previous fragments to be timed out. */\n-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);\n+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);\n     if (p == NULL)\n         goto end;\n \n@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)\n         goto end;\n \n     /* This packet has an offset > 0, more frags set to 0 and no data. */\n-    p = BuildTestPacket(id, 1, 0, 'A', 0);\n+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);\n     if (p == NULL)\n         goto end;\n \n@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)\n \n     /* Create a fragment that would extend past the max allowable size\n      * for an IPv4 packet. */\n-    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);\n     if (p == NULL)\n         goto end;\n \n@@ -2267,10 +2267,10 @@ DefragVlanTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)\n \n     /* Build a packet, its not a fragment but shouldn't matter for\n      * this test. */\n-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);\n     if (p1 == NULL) {\n         goto end;\n     }\n@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)\n     return retval;\n }\n \n+/**\n+ * \\brief Test that fragments that match other than the proto don't\n+ * actually get matched.\n+ */\n+static int DefragTestBadProto(void)\n+{\n+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n+    int id = 12;\n+\n+    DefragInit();\n+\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n+    FAIL_IF_NULL(p1);\n+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);\n+    FAIL_IF_NULL(p2);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n+    FAIL_IF_NULL(p3);\n+\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));\n+\n+    if (p1 != NULL)\n+        SCFree(p1);\n+    if (p2 != NULL)\n+        SCFree(p2);\n+    if (p3 != NULL)\n+        SCFree(p3);\n+\n+    DefragDestroy();\n+    PASS;\n+}\n+\n #endif /* UNITTESTS */\n \n void\n@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)\n     UtRegisterTest(\""DefragTimeoutTest\"", DefragTimeoutTest);\n     UtRegisterTest(\""DefragMfIpv4Test\"", DefragMfIpv4Test);\n     UtRegisterTest(\""DefragMfIpv6Test\"", DefragMfIpv6Test);\n+    UtRegisterTest(\""DefragTestBadProto\"", DefragTestBadProto);\n #endif /* UNITTESTS */\n }\n ""}<_**next**_>{""sha"": ""c3a0c693733a4199ce3ae7d37066e6c549edfcbd"", ""filename"": ""src/defrag.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.h?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -84,6 +84,8 @@ typedef struct DefragTracker_ {\n     uint32_t id; /**< IP ID for this tracker.  32 bits for IPv6, 16\n                   * for IPv4. */\n \n+    uint8_t proto; /**< IP protocol for this tracker. */\n+\n     uint8_t policy; /**< Reassembly policy this tracker will use. */\n \n     uint8_t af; /**< Address family for this tracker, AF_INET or""}","DefragIPv4TooLargeTest(void)
{
    DefragContext *dc = NULL;
    Packet *p = NULL;
    int ret = 0;

    DefragInit();

    dc = DefragContextNew();
    if (dc == NULL)
        goto end;
 
     /* Create a fragment that would extend past the max allowable size
      * for an IPv4 packet. */
    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);
     if (p == NULL)
         goto end;
 
    /* We do not expect a packet returned. */
    if (Defrag(NULL, NULL, p, NULL) != NULL)
        goto end;
    if (!ENGINE_ISSET_EVENT(p, IPV4_FRAG_PKT_TOO_LARGE))
        goto end;

    /* The fragment should have been ignored so no fragments should have
     * been allocated from the pool. */
    if (dc->frag_pool->outstanding != 0)
        return 0;

    ret = 1;
end:
    if (dc != NULL)
        DefragContextDestroy(dc);
    if (p != NULL)
        SCFree(p);

    DefragDestroy();
    return ret;
}
","DefragIPv4TooLargeTest(void)
{
    DefragContext *dc = NULL;
    Packet *p = NULL;
    int ret = 0;

    DefragInit();

    dc = DefragContextNew();
    if (dc == NULL)
        goto end;
 
     /* Create a fragment that would extend past the max allowable size
      * for an IPv4 packet. */
    p = BuildTestPacket(1, 8183, 0, 'A', 71);
     if (p == NULL)
         goto end;
 
    /* We do not expect a packet returned. */
    if (Defrag(NULL, NULL, p, NULL) != NULL)
        goto end;
    if (!ENGINE_ISSET_EVENT(p, IPV4_FRAG_PKT_TOO_LARGE))
        goto end;

    /* The fragment should have been ignored so no fragments should have
     * been allocated from the pool. */
    if (dc->frag_pool->outstanding != 0)
        return 0;

    ret = 1;
end:
    if (dc != NULL)
        DefragContextDestroy(dc);
    if (p != NULL)
        SCFree(p);

    DefragDestroy();
    return ret;
}
",C,"    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);
","    p = BuildTestPacket(1, 8183, 0, 'A', 71);
",,"@@ -996,8 +996,8 @@ void DefragDestroy(void)
  * with some payload of no particular protocol.
  */
 static Packet *
-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
-    int content_len)
+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     int hlen = 20;
@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
     else
         ip4h.ip_off = htons(off);
     ip4h.ip_ttl = ttl;
-    ip4h.ip_proto = IPPROTO_ICMP;
+    ip4h.ip_proto = proto;
 
     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */
     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */
@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
         goto error;
     if (IPV4_GET_IPTTL(p) != ttl)
         goto error;
-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)
+    if (IPV4_GET_IPPROTO(p) != proto)
         goto error;
 
     return p;
@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,
                           uint16_t prev_hdrextlen);
 
 static Packet *
-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
-    int content_len)
+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     uint8_t *pcontent;
@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
     IPV6_SET_RAW_VER(p->ip6h, 6);
     /* Fragmentation header. */
     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));
-    fh->ip6fh_nxt = IPPROTO_ICMP;
+    fh->ip6fh_nxt = proto;
     fh->ip6fh_ident = htonl(id);
     fh->ip6fh_offlg = htons((off << 3) | mf);
 
@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)
     if (dc == NULL)
         goto end;
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)
 
     /* Load in 16 packets. */
     for (i = 0; i < 16; i++) {
-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);
+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);
         if (p == NULL)
             goto end;
 
@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)
 
     /* Build a new packet but push the timestamp out by our timeout.
      * This should force our previous fragments to be timed out. */
-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);
+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);
     if (p == NULL)
         goto end;
 
@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)
         goto end;
 
     /* This packet has an offset > 0, more frags set to 0 and no data. */
-    p = BuildTestPacket(id, 1, 0, 'A', 0);
+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);
     if (p == NULL)
         goto end;
 
@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)
 
     /* Create a fragment that would extend past the max allowable size
      * for an IPv4 packet. */
-    p = BuildTestPacket(1, 8183, 0, 'A', 71);
+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);
     if (p == NULL)
         goto end;
 
@@ -2267,10 +2267,10 @@ DefragVlanTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)
 
     /* Build a packet, its not a fragment but shouldn't matter for
      * this test. */
-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);
     if (p1 == NULL) {
         goto end;
     }
@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)
 
     DefragInit();
 
-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)
 
     DefragInit();
 
-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)
     return retval;
 }
 
+/**
+ * \brief Test that fragments that match other than the proto don't
+ * actually get matched.
+ */
+static int DefragTestBadProto(void)
+{
+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
+    int id = 12;
+
+    DefragInit();
+
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
+    FAIL_IF_NULL(p1);
+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);
+    FAIL_IF_NULL(p2);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
+    FAIL_IF_NULL(p3);
+
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));
+
+    if (p1 != NULL)
+        SCFree(p1);
+    if (p2 != NULL)
+        SCFree(p2);
+    if (p3 != NULL)
+        SCFree(p3);
+
+    DefragDestroy();
+    PASS;
+}
+
 #endif /* UNITTESTS */
 
 void
@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)
     UtRegisterTest(""DefragTimeoutTest"", DefragTimeoutTest);
     UtRegisterTest(""DefragMfIpv4Test"", DefragMfIpv4Test);
     UtRegisterTest(""DefragMfIpv6Test"", DefragMfIpv6Test);
+    UtRegisterTest(""DefragTestBadProto"", DefragTestBadProto);
 #endif /* UNITTESTS */
 }
 ",suricata,4a04f814b15762eb446a5ead4d69d021512df6f8,292baf0872abfebf2762e08e613565703595db6c,1,"DefragIPv4TooLargeTest(void)
{
    DefragContext *dc = NULL;
    Packet *p = NULL;
    int ret = 0;

    DefragInit();

    dc = DefragContextNew();
    if (dc == NULL)
        goto end;
 
     /* Create a fragment that would extend past the max allowable size
      * for an IPv4 packet. */
//flaw_line_below:
    p = BuildTestPacket(1, 8183, 0, 'A', 71);
//fix_flaw_line_below:
//    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);
     if (p == NULL)
         goto end;
 
    /* We do not expect a packet returned. */
    if (Defrag(NULL, NULL, p, NULL) != NULL)
        goto end;
    if (!ENGINE_ISSET_EVENT(p, IPV4_FRAG_PKT_TOO_LARGE))
        goto end;

    /* The fragment should have been ignored so no fragments should have
     * been allocated from the pool. */
    if (dc->frag_pool->outstanding != 0)
        return 0;

    ret = 1;
end:
    if (dc != NULL)
        DefragContextDestroy(dc);
    if (p != NULL)
        SCFree(p);

    DefragDestroy();
    return ret;
}
"
3734,181470,,Remote,Not required,,CVE-2017-7177,https://www.cvedetails.com/cve/CVE-2017-7177/,CWE-358,Low,,Partial,,2017-03-18,5.0,Suricata before 3.2.1 has an IPv4 defragmentation evasion issue caused by lack of a check for the IP protocol during fragment matching.,2018-12-05,,3,https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8,4a04f814b15762eb446a5ead4d69d021512df6f8,"defrag - take protocol into account during re-assembly

The IP protocol was not being used to match fragments with
their packets allowing a carefully constructed packet
with a different protocol to be matched, allowing re-assembly
to complete, creating a packet that would not be re-assembled
by the destination host.",3,src/defrag.c,"{""sha"": ""736099c58761058109931134cb06744878843604"", ""filename"": ""src/defrag-hash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag-hash.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -92,6 +92,7 @@ static void DefragTrackerInit(DefragTracker *dt, Packet *p)\n         dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);\n         dt->af = AF_INET6;\n     }\n+    dt->proto = IP_GET_IPPROTO(p);\n     dt->vlan_id[0] = p->vlan_id[0];\n     dt->vlan_id[1] = p->vlan_id[1];\n     dt->policy = DefragGetOsPolicy(p);\n@@ -406,6 +407,7 @@ static inline uint32_t DefragHashGetKey(Packet *p)\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->dst)) || \\\n       (CMP_ADDR(&(d1)->src_addr, &(d2)->dst) && \\\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->src))) && \\\n+     (d1)->proto == IP_GET_IPPROTO(p) &&        \\\n      (d1)->id == (id) && \\\n      (d1)->vlan_id[0] == (d2)->vlan_id[0] && \\\n      (d1)->vlan_id[1] == (d2)->vlan_id[1])""}<_**next**_>{""sha"": ""5433ce78607c5e694686de0fd2d93edec264b1bd"", ""filename"": ""src/defrag.c"", ""status"": ""modified"", ""additions"": 102, ""deletions"": 68, ""changes"": 170, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -996,8 +996,8 @@ void DefragDestroy(void)\n  * with some payload of no particular protocol.\n  */\n static Packet *\n-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     int hlen = 20;\n@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n     else\n         ip4h.ip_off = htons(off);\n     ip4h.ip_ttl = ttl;\n-    ip4h.ip_proto = IPPROTO_ICMP;\n+    ip4h.ip_proto = proto;\n \n     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */\n     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */\n@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n         goto error;\n     if (IPV4_GET_IPTTL(p) != ttl)\n         goto error;\n-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)\n+    if (IPV4_GET_IPPROTO(p) != proto)\n         goto error;\n \n     return p;\n@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,\n                           uint16_t prev_hdrextlen);\n \n static Packet *\n-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     uint8_t *pcontent;\n@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n     IPV6_SET_RAW_VER(p->ip6h, 6);\n     /* Fragmentation header. */\n     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));\n-    fh->ip6fh_nxt = IPPROTO_ICMP;\n+    fh->ip6fh_nxt = proto;\n     fh->ip6fh_ident = htonl(id);\n     fh->ip6fh_offlg = htons((off << 3) | mf);\n \n@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)\n     if (dc == NULL)\n         goto end;\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)\n \n     /* Load in 16 packets. */\n     for (i = 0; i < 16; i++) {\n-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);\n+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);\n         if (p == NULL)\n             goto end;\n \n@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)\n \n     /* Build a new packet but push the timestamp out by our timeout.\n      * This should force our previous fragments to be timed out. */\n-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);\n+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);\n     if (p == NULL)\n         goto end;\n \n@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)\n         goto end;\n \n     /* This packet has an offset > 0, more frags set to 0 and no data. */\n-    p = BuildTestPacket(id, 1, 0, 'A', 0);\n+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);\n     if (p == NULL)\n         goto end;\n \n@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)\n \n     /* Create a fragment that would extend past the max allowable size\n      * for an IPv4 packet. */\n-    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);\n     if (p == NULL)\n         goto end;\n \n@@ -2267,10 +2267,10 @@ DefragVlanTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)\n \n     /* Build a packet, its not a fragment but shouldn't matter for\n      * this test. */\n-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);\n     if (p1 == NULL) {\n         goto end;\n     }\n@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)\n     return retval;\n }\n \n+/**\n+ * \\brief Test that fragments that match other than the proto don't\n+ * actually get matched.\n+ */\n+static int DefragTestBadProto(void)\n+{\n+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n+    int id = 12;\n+\n+    DefragInit();\n+\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n+    FAIL_IF_NULL(p1);\n+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);\n+    FAIL_IF_NULL(p2);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n+    FAIL_IF_NULL(p3);\n+\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));\n+\n+    if (p1 != NULL)\n+        SCFree(p1);\n+    if (p2 != NULL)\n+        SCFree(p2);\n+    if (p3 != NULL)\n+        SCFree(p3);\n+\n+    DefragDestroy();\n+    PASS;\n+}\n+\n #endif /* UNITTESTS */\n \n void\n@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)\n     UtRegisterTest(\""DefragTimeoutTest\"", DefragTimeoutTest);\n     UtRegisterTest(\""DefragMfIpv4Test\"", DefragMfIpv4Test);\n     UtRegisterTest(\""DefragMfIpv6Test\"", DefragMfIpv6Test);\n+    UtRegisterTest(\""DefragTestBadProto\"", DefragTestBadProto);\n #endif /* UNITTESTS */\n }\n ""}<_**next**_>{""sha"": ""c3a0c693733a4199ce3ae7d37066e6c549edfcbd"", ""filename"": ""src/defrag.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.h?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -84,6 +84,8 @@ typedef struct DefragTracker_ {\n     uint32_t id; /**< IP ID for this tracker.  32 bits for IPv6, 16\n                   * for IPv4. */\n \n+    uint8_t proto; /**< IP protocol for this tracker. */\n+\n     uint8_t policy; /**< Reassembly policy this tracker will use. */\n \n     uint8_t af; /**< Address family for this tracker, AF_INET or""}","DefragInOrderSimpleTest(void)
{
    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
    Packet *reassembled = NULL;
    int id = 12;
    int i;
    int ret = 0;
 
     DefragInit();
 
    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
    if (Defrag(NULL, NULL, p1, NULL) != NULL)
        goto end;
    if (Defrag(NULL, NULL, p2, NULL) != NULL)
        goto end;

    reassembled = Defrag(NULL, NULL, p3, NULL);
    if (reassembled == NULL) {
        goto end;
    }

    if (IPV4_GET_HLEN(reassembled) != 20) {
        goto end;
    }
    if (IPV4_GET_IPLEN(reassembled) != 39) {
        goto end;
    }

    /* 20 bytes in we should find 8 bytes of A. */
    for (i = 20; i < 20 + 8; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'A') {
            goto end;
        }
    }

    /* 28 bytes in we should find 8 bytes of B. */
    for (i = 28; i < 28 + 8; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'B') {
            goto end;
        }
    }

    /* And 36 bytes in we should find 3 bytes of C. */
    for (i = 36; i < 36 + 3; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'C')
            goto end;
    }

    ret = 1;

end:
    if (p1 != NULL)
        SCFree(p1);
    if (p2 != NULL)
        SCFree(p2);
    if (p3 != NULL)
        SCFree(p3);
    if (reassembled != NULL)
        SCFree(reassembled);

    DefragDestroy();
    return ret;
}
","DefragInOrderSimpleTest(void)
{
    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
    Packet *reassembled = NULL;
    int id = 12;
    int i;
    int ret = 0;
 
     DefragInit();
 
    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
    if (Defrag(NULL, NULL, p1, NULL) != NULL)
        goto end;
    if (Defrag(NULL, NULL, p2, NULL) != NULL)
        goto end;

    reassembled = Defrag(NULL, NULL, p3, NULL);
    if (reassembled == NULL) {
        goto end;
    }

    if (IPV4_GET_HLEN(reassembled) != 20) {
        goto end;
    }
    if (IPV4_GET_IPLEN(reassembled) != 39) {
        goto end;
    }

    /* 20 bytes in we should find 8 bytes of A. */
    for (i = 20; i < 20 + 8; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'A') {
            goto end;
        }
    }

    /* 28 bytes in we should find 8 bytes of B. */
    for (i = 28; i < 28 + 8; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'B') {
            goto end;
        }
    }

    /* And 36 bytes in we should find 3 bytes of C. */
    for (i = 36; i < 36 + 3; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'C')
            goto end;
    }

    ret = 1;

end:
    if (p1 != NULL)
        SCFree(p1);
    if (p2 != NULL)
        SCFree(p2);
    if (p3 != NULL)
        SCFree(p3);
    if (reassembled != NULL)
        SCFree(reassembled);

    DefragDestroy();
    return ret;
}
",C,"    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
","    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
",,"@@ -996,8 +996,8 @@ void DefragDestroy(void)
  * with some payload of no particular protocol.
  */
 static Packet *
-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
-    int content_len)
+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     int hlen = 20;
@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
     else
         ip4h.ip_off = htons(off);
     ip4h.ip_ttl = ttl;
-    ip4h.ip_proto = IPPROTO_ICMP;
+    ip4h.ip_proto = proto;
 
     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */
     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */
@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
         goto error;
     if (IPV4_GET_IPTTL(p) != ttl)
         goto error;
-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)
+    if (IPV4_GET_IPPROTO(p) != proto)
         goto error;
 
     return p;
@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,
                           uint16_t prev_hdrextlen);
 
 static Packet *
-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
-    int content_len)
+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     uint8_t *pcontent;
@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
     IPV6_SET_RAW_VER(p->ip6h, 6);
     /* Fragmentation header. */
     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));
-    fh->ip6fh_nxt = IPPROTO_ICMP;
+    fh->ip6fh_nxt = proto;
     fh->ip6fh_ident = htonl(id);
     fh->ip6fh_offlg = htons((off << 3) | mf);
 
@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)
     if (dc == NULL)
         goto end;
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)
 
     /* Load in 16 packets. */
     for (i = 0; i < 16; i++) {
-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);
+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);
         if (p == NULL)
             goto end;
 
@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)
 
     /* Build a new packet but push the timestamp out by our timeout.
      * This should force our previous fragments to be timed out. */
-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);
+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);
     if (p == NULL)
         goto end;
 
@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)
         goto end;
 
     /* This packet has an offset > 0, more frags set to 0 and no data. */
-    p = BuildTestPacket(id, 1, 0, 'A', 0);
+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);
     if (p == NULL)
         goto end;
 
@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)
 
     /* Create a fragment that would extend past the max allowable size
      * for an IPv4 packet. */
-    p = BuildTestPacket(1, 8183, 0, 'A', 71);
+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);
     if (p == NULL)
         goto end;
 
@@ -2267,10 +2267,10 @@ DefragVlanTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)
 
     /* Build a packet, its not a fragment but shouldn't matter for
      * this test. */
-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);
     if (p1 == NULL) {
         goto end;
     }
@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)
 
     DefragInit();
 
-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)
 
     DefragInit();
 
-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)
     return retval;
 }
 
+/**
+ * \brief Test that fragments that match other than the proto don't
+ * actually get matched.
+ */
+static int DefragTestBadProto(void)
+{
+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
+    int id = 12;
+
+    DefragInit();
+
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
+    FAIL_IF_NULL(p1);
+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);
+    FAIL_IF_NULL(p2);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
+    FAIL_IF_NULL(p3);
+
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));
+
+    if (p1 != NULL)
+        SCFree(p1);
+    if (p2 != NULL)
+        SCFree(p2);
+    if (p3 != NULL)
+        SCFree(p3);
+
+    DefragDestroy();
+    PASS;
+}
+
 #endif /* UNITTESTS */
 
 void
@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)
     UtRegisterTest(""DefragTimeoutTest"", DefragTimeoutTest);
     UtRegisterTest(""DefragMfIpv4Test"", DefragMfIpv4Test);
     UtRegisterTest(""DefragMfIpv6Test"", DefragMfIpv6Test);
+    UtRegisterTest(""DefragTestBadProto"", DefragTestBadProto);
 #endif /* UNITTESTS */
 }
 ",suricata,4a04f814b15762eb446a5ead4d69d021512df6f8,292baf0872abfebf2762e08e613565703595db6c,1,"DefragInOrderSimpleTest(void)
{
    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
    Packet *reassembled = NULL;
    int id = 12;
    int i;
    int ret = 0;
 
     DefragInit();
 
//flaw_line_below:
    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
//fix_flaw_line_below:
//    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
//flaw_line_below:
    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
//fix_flaw_line_below:
//    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
//flaw_line_below:
    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
//fix_flaw_line_below:
//    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
    if (Defrag(NULL, NULL, p1, NULL) != NULL)
        goto end;
    if (Defrag(NULL, NULL, p2, NULL) != NULL)
        goto end;

    reassembled = Defrag(NULL, NULL, p3, NULL);
    if (reassembled == NULL) {
        goto end;
    }

    if (IPV4_GET_HLEN(reassembled) != 20) {
        goto end;
    }
    if (IPV4_GET_IPLEN(reassembled) != 39) {
        goto end;
    }

    /* 20 bytes in we should find 8 bytes of A. */
    for (i = 20; i < 20 + 8; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'A') {
            goto end;
        }
    }

    /* 28 bytes in we should find 8 bytes of B. */
    for (i = 28; i < 28 + 8; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'B') {
            goto end;
        }
    }

    /* And 36 bytes in we should find 3 bytes of C. */
    for (i = 36; i < 36 + 3; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'C')
            goto end;
    }

    ret = 1;

end:
    if (p1 != NULL)
        SCFree(p1);
    if (p2 != NULL)
        SCFree(p2);
    if (p3 != NULL)
        SCFree(p3);
    if (reassembled != NULL)
        SCFree(reassembled);

    DefragDestroy();
    return ret;
}
"
3735,181471,,Remote,Not required,,CVE-2017-7177,https://www.cvedetails.com/cve/CVE-2017-7177/,CWE-358,Low,,Partial,,2017-03-18,5.0,Suricata before 3.2.1 has an IPv4 defragmentation evasion issue caused by lack of a check for the IP protocol during fragment matching.,2018-12-05,,3,https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8,4a04f814b15762eb446a5ead4d69d021512df6f8,"defrag - take protocol into account during re-assembly

The IP protocol was not being used to match fragments with
their packets allowing a carefully constructed packet
with a different protocol to be matched, allowing re-assembly
to complete, creating a packet that would not be re-assembled
by the destination host.",3,src/defrag.c,"{""sha"": ""736099c58761058109931134cb06744878843604"", ""filename"": ""src/defrag-hash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag-hash.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -92,6 +92,7 @@ static void DefragTrackerInit(DefragTracker *dt, Packet *p)\n         dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);\n         dt->af = AF_INET6;\n     }\n+    dt->proto = IP_GET_IPPROTO(p);\n     dt->vlan_id[0] = p->vlan_id[0];\n     dt->vlan_id[1] = p->vlan_id[1];\n     dt->policy = DefragGetOsPolicy(p);\n@@ -406,6 +407,7 @@ static inline uint32_t DefragHashGetKey(Packet *p)\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->dst)) || \\\n       (CMP_ADDR(&(d1)->src_addr, &(d2)->dst) && \\\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->src))) && \\\n+     (d1)->proto == IP_GET_IPPROTO(p) &&        \\\n      (d1)->id == (id) && \\\n      (d1)->vlan_id[0] == (d2)->vlan_id[0] && \\\n      (d1)->vlan_id[1] == (d2)->vlan_id[1])""}<_**next**_>{""sha"": ""5433ce78607c5e694686de0fd2d93edec264b1bd"", ""filename"": ""src/defrag.c"", ""status"": ""modified"", ""additions"": 102, ""deletions"": 68, ""changes"": 170, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -996,8 +996,8 @@ void DefragDestroy(void)\n  * with some payload of no particular protocol.\n  */\n static Packet *\n-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     int hlen = 20;\n@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n     else\n         ip4h.ip_off = htons(off);\n     ip4h.ip_ttl = ttl;\n-    ip4h.ip_proto = IPPROTO_ICMP;\n+    ip4h.ip_proto = proto;\n \n     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */\n     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */\n@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n         goto error;\n     if (IPV4_GET_IPTTL(p) != ttl)\n         goto error;\n-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)\n+    if (IPV4_GET_IPPROTO(p) != proto)\n         goto error;\n \n     return p;\n@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,\n                           uint16_t prev_hdrextlen);\n \n static Packet *\n-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     uint8_t *pcontent;\n@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n     IPV6_SET_RAW_VER(p->ip6h, 6);\n     /* Fragmentation header. */\n     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));\n-    fh->ip6fh_nxt = IPPROTO_ICMP;\n+    fh->ip6fh_nxt = proto;\n     fh->ip6fh_ident = htonl(id);\n     fh->ip6fh_offlg = htons((off << 3) | mf);\n \n@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)\n     if (dc == NULL)\n         goto end;\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)\n \n     /* Load in 16 packets. */\n     for (i = 0; i < 16; i++) {\n-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);\n+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);\n         if (p == NULL)\n             goto end;\n \n@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)\n \n     /* Build a new packet but push the timestamp out by our timeout.\n      * This should force our previous fragments to be timed out. */\n-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);\n+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);\n     if (p == NULL)\n         goto end;\n \n@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)\n         goto end;\n \n     /* This packet has an offset > 0, more frags set to 0 and no data. */\n-    p = BuildTestPacket(id, 1, 0, 'A', 0);\n+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);\n     if (p == NULL)\n         goto end;\n \n@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)\n \n     /* Create a fragment that would extend past the max allowable size\n      * for an IPv4 packet. */\n-    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);\n     if (p == NULL)\n         goto end;\n \n@@ -2267,10 +2267,10 @@ DefragVlanTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)\n \n     /* Build a packet, its not a fragment but shouldn't matter for\n      * this test. */\n-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);\n     if (p1 == NULL) {\n         goto end;\n     }\n@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)\n     return retval;\n }\n \n+/**\n+ * \\brief Test that fragments that match other than the proto don't\n+ * actually get matched.\n+ */\n+static int DefragTestBadProto(void)\n+{\n+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n+    int id = 12;\n+\n+    DefragInit();\n+\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n+    FAIL_IF_NULL(p1);\n+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);\n+    FAIL_IF_NULL(p2);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n+    FAIL_IF_NULL(p3);\n+\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));\n+\n+    if (p1 != NULL)\n+        SCFree(p1);\n+    if (p2 != NULL)\n+        SCFree(p2);\n+    if (p3 != NULL)\n+        SCFree(p3);\n+\n+    DefragDestroy();\n+    PASS;\n+}\n+\n #endif /* UNITTESTS */\n \n void\n@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)\n     UtRegisterTest(\""DefragTimeoutTest\"", DefragTimeoutTest);\n     UtRegisterTest(\""DefragMfIpv4Test\"", DefragMfIpv4Test);\n     UtRegisterTest(\""DefragMfIpv6Test\"", DefragMfIpv6Test);\n+    UtRegisterTest(\""DefragTestBadProto\"", DefragTestBadProto);\n #endif /* UNITTESTS */\n }\n ""}<_**next**_>{""sha"": ""c3a0c693733a4199ce3ae7d37066e6c549edfcbd"", ""filename"": ""src/defrag.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.h?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -84,6 +84,8 @@ typedef struct DefragTracker_ {\n     uint32_t id; /**< IP ID for this tracker.  32 bits for IPv6, 16\n                   * for IPv4. */\n \n+    uint8_t proto; /**< IP protocol for this tracker. */\n+\n     uint8_t policy; /**< Reassembly policy this tracker will use. */\n \n     uint8_t af; /**< Address family for this tracker, AF_INET or""}","static int DefragMfIpv4Test(void)
{
    int retval = 0;
    int ip_id = 9;
    Packet *p = NULL;
 
     DefragInit();
 
    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);
    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);
    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }

    p = Defrag(NULL, NULL, p1, NULL);
    if (p != NULL) {
        goto end;
    }

    p = Defrag(NULL, NULL, p2, NULL);
    if (p != NULL) {
        goto end;
    }

    /* This should return a packet as MF=0. */
    p = Defrag(NULL, NULL, p3, NULL);
    if (p == NULL) {
        goto end;
    }

    /* Expected IP length is 20 + 8 + 8 = 36 as only 2 of the
     * fragments should be in the re-assembled packet. */
    if (IPV4_GET_IPLEN(p) != 36) {
        goto end;
    }

    retval = 1;
end:
    if (p1 != NULL) {
        SCFree(p1);
    }
    if (p2 != NULL) {
        SCFree(p2);
    }
    if (p3 != NULL) {
        SCFree(p3);
    }
    if (p != NULL) {
        SCFree(p);
    }
    DefragDestroy();
    return retval;
}
","static int DefragMfIpv4Test(void)
{
    int retval = 0;
    int ip_id = 9;
    Packet *p = NULL;
 
     DefragInit();
 
    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);
    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);
    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }

    p = Defrag(NULL, NULL, p1, NULL);
    if (p != NULL) {
        goto end;
    }

    p = Defrag(NULL, NULL, p2, NULL);
    if (p != NULL) {
        goto end;
    }

    /* This should return a packet as MF=0. */
    p = Defrag(NULL, NULL, p3, NULL);
    if (p == NULL) {
        goto end;
    }

    /* Expected IP length is 20 + 8 + 8 = 36 as only 2 of the
     * fragments should be in the re-assembled packet. */
    if (IPV4_GET_IPLEN(p) != 36) {
        goto end;
    }

    retval = 1;
end:
    if (p1 != NULL) {
        SCFree(p1);
    }
    if (p2 != NULL) {
        SCFree(p2);
    }
    if (p3 != NULL) {
        SCFree(p3);
    }
    if (p != NULL) {
        SCFree(p);
    }
    DefragDestroy();
    return retval;
}
",C,"    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);
    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);
    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);
","    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);
    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);
    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);
",,"@@ -996,8 +996,8 @@ void DefragDestroy(void)
  * with some payload of no particular protocol.
  */
 static Packet *
-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
-    int content_len)
+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     int hlen = 20;
@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
     else
         ip4h.ip_off = htons(off);
     ip4h.ip_ttl = ttl;
-    ip4h.ip_proto = IPPROTO_ICMP;
+    ip4h.ip_proto = proto;
 
     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */
     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */
@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
         goto error;
     if (IPV4_GET_IPTTL(p) != ttl)
         goto error;
-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)
+    if (IPV4_GET_IPPROTO(p) != proto)
         goto error;
 
     return p;
@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,
                           uint16_t prev_hdrextlen);
 
 static Packet *
-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
-    int content_len)
+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     uint8_t *pcontent;
@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
     IPV6_SET_RAW_VER(p->ip6h, 6);
     /* Fragmentation header. */
     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));
-    fh->ip6fh_nxt = IPPROTO_ICMP;
+    fh->ip6fh_nxt = proto;
     fh->ip6fh_ident = htonl(id);
     fh->ip6fh_offlg = htons((off << 3) | mf);
 
@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)
     if (dc == NULL)
         goto end;
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)
 
     /* Load in 16 packets. */
     for (i = 0; i < 16; i++) {
-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);
+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);
         if (p == NULL)
             goto end;
 
@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)
 
     /* Build a new packet but push the timestamp out by our timeout.
      * This should force our previous fragments to be timed out. */
-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);
+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);
     if (p == NULL)
         goto end;
 
@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)
         goto end;
 
     /* This packet has an offset > 0, more frags set to 0 and no data. */
-    p = BuildTestPacket(id, 1, 0, 'A', 0);
+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);
     if (p == NULL)
         goto end;
 
@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)
 
     /* Create a fragment that would extend past the max allowable size
      * for an IPv4 packet. */
-    p = BuildTestPacket(1, 8183, 0, 'A', 71);
+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);
     if (p == NULL)
         goto end;
 
@@ -2267,10 +2267,10 @@ DefragVlanTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)
 
     /* Build a packet, its not a fragment but shouldn't matter for
      * this test. */
-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);
     if (p1 == NULL) {
         goto end;
     }
@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)
 
     DefragInit();
 
-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)
 
     DefragInit();
 
-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)
     return retval;
 }
 
+/**
+ * \brief Test that fragments that match other than the proto don't
+ * actually get matched.
+ */
+static int DefragTestBadProto(void)
+{
+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
+    int id = 12;
+
+    DefragInit();
+
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
+    FAIL_IF_NULL(p1);
+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);
+    FAIL_IF_NULL(p2);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
+    FAIL_IF_NULL(p3);
+
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));
+
+    if (p1 != NULL)
+        SCFree(p1);
+    if (p2 != NULL)
+        SCFree(p2);
+    if (p3 != NULL)
+        SCFree(p3);
+
+    DefragDestroy();
+    PASS;
+}
+
 #endif /* UNITTESTS */
 
 void
@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)
     UtRegisterTest(""DefragTimeoutTest"", DefragTimeoutTest);
     UtRegisterTest(""DefragMfIpv4Test"", DefragMfIpv4Test);
     UtRegisterTest(""DefragMfIpv6Test"", DefragMfIpv6Test);
+    UtRegisterTest(""DefragTestBadProto"", DefragTestBadProto);
 #endif /* UNITTESTS */
 }
 ",suricata,4a04f814b15762eb446a5ead4d69d021512df6f8,292baf0872abfebf2762e08e613565703595db6c,1,"static int DefragMfIpv4Test(void)
{
    int retval = 0;
    int ip_id = 9;
    Packet *p = NULL;
 
     DefragInit();
 
//flaw_line_below:
    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);
//flaw_line_below:
    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);
//flaw_line_below:
    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);
//fix_flaw_line_below:
//    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);
//fix_flaw_line_below:
//    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);
//fix_flaw_line_below:
//    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }

    p = Defrag(NULL, NULL, p1, NULL);
    if (p != NULL) {
        goto end;
    }

    p = Defrag(NULL, NULL, p2, NULL);
    if (p != NULL) {
        goto end;
    }

    /* This should return a packet as MF=0. */
    p = Defrag(NULL, NULL, p3, NULL);
    if (p == NULL) {
        goto end;
    }

    /* Expected IP length is 20 + 8 + 8 = 36 as only 2 of the
     * fragments should be in the re-assembled packet. */
    if (IPV4_GET_IPLEN(p) != 36) {
        goto end;
    }

    retval = 1;
end:
    if (p1 != NULL) {
        SCFree(p1);
    }
    if (p2 != NULL) {
        SCFree(p2);
    }
    if (p3 != NULL) {
        SCFree(p3);
    }
    if (p != NULL) {
        SCFree(p);
    }
    DefragDestroy();
    return retval;
}
"
3736,181472,,Remote,Not required,,CVE-2017-7177,https://www.cvedetails.com/cve/CVE-2017-7177/,CWE-358,Low,,Partial,,2017-03-18,5.0,Suricata before 3.2.1 has an IPv4 defragmentation evasion issue caused by lack of a check for the IP protocol during fragment matching.,2018-12-05,,3,https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8,4a04f814b15762eb446a5ead4d69d021512df6f8,"defrag - take protocol into account during re-assembly

The IP protocol was not being used to match fragments with
their packets allowing a carefully constructed packet
with a different protocol to be matched, allowing re-assembly
to complete, creating a packet that would not be re-assembled
by the destination host.",3,src/defrag.c,"{""sha"": ""736099c58761058109931134cb06744878843604"", ""filename"": ""src/defrag-hash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag-hash.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -92,6 +92,7 @@ static void DefragTrackerInit(DefragTracker *dt, Packet *p)\n         dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);\n         dt->af = AF_INET6;\n     }\n+    dt->proto = IP_GET_IPPROTO(p);\n     dt->vlan_id[0] = p->vlan_id[0];\n     dt->vlan_id[1] = p->vlan_id[1];\n     dt->policy = DefragGetOsPolicy(p);\n@@ -406,6 +407,7 @@ static inline uint32_t DefragHashGetKey(Packet *p)\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->dst)) || \\\n       (CMP_ADDR(&(d1)->src_addr, &(d2)->dst) && \\\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->src))) && \\\n+     (d1)->proto == IP_GET_IPPROTO(p) &&        \\\n      (d1)->id == (id) && \\\n      (d1)->vlan_id[0] == (d2)->vlan_id[0] && \\\n      (d1)->vlan_id[1] == (d2)->vlan_id[1])""}<_**next**_>{""sha"": ""5433ce78607c5e694686de0fd2d93edec264b1bd"", ""filename"": ""src/defrag.c"", ""status"": ""modified"", ""additions"": 102, ""deletions"": 68, ""changes"": 170, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -996,8 +996,8 @@ void DefragDestroy(void)\n  * with some payload of no particular protocol.\n  */\n static Packet *\n-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     int hlen = 20;\n@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n     else\n         ip4h.ip_off = htons(off);\n     ip4h.ip_ttl = ttl;\n-    ip4h.ip_proto = IPPROTO_ICMP;\n+    ip4h.ip_proto = proto;\n \n     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */\n     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */\n@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n         goto error;\n     if (IPV4_GET_IPTTL(p) != ttl)\n         goto error;\n-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)\n+    if (IPV4_GET_IPPROTO(p) != proto)\n         goto error;\n \n     return p;\n@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,\n                           uint16_t prev_hdrextlen);\n \n static Packet *\n-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     uint8_t *pcontent;\n@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n     IPV6_SET_RAW_VER(p->ip6h, 6);\n     /* Fragmentation header. */\n     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));\n-    fh->ip6fh_nxt = IPPROTO_ICMP;\n+    fh->ip6fh_nxt = proto;\n     fh->ip6fh_ident = htonl(id);\n     fh->ip6fh_offlg = htons((off << 3) | mf);\n \n@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)\n     if (dc == NULL)\n         goto end;\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)\n \n     /* Load in 16 packets. */\n     for (i = 0; i < 16; i++) {\n-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);\n+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);\n         if (p == NULL)\n             goto end;\n \n@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)\n \n     /* Build a new packet but push the timestamp out by our timeout.\n      * This should force our previous fragments to be timed out. */\n-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);\n+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);\n     if (p == NULL)\n         goto end;\n \n@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)\n         goto end;\n \n     /* This packet has an offset > 0, more frags set to 0 and no data. */\n-    p = BuildTestPacket(id, 1, 0, 'A', 0);\n+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);\n     if (p == NULL)\n         goto end;\n \n@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)\n \n     /* Create a fragment that would extend past the max allowable size\n      * for an IPv4 packet. */\n-    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);\n     if (p == NULL)\n         goto end;\n \n@@ -2267,10 +2267,10 @@ DefragVlanTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)\n \n     /* Build a packet, its not a fragment but shouldn't matter for\n      * this test. */\n-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);\n     if (p1 == NULL) {\n         goto end;\n     }\n@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)\n     return retval;\n }\n \n+/**\n+ * \\brief Test that fragments that match other than the proto don't\n+ * actually get matched.\n+ */\n+static int DefragTestBadProto(void)\n+{\n+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n+    int id = 12;\n+\n+    DefragInit();\n+\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n+    FAIL_IF_NULL(p1);\n+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);\n+    FAIL_IF_NULL(p2);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n+    FAIL_IF_NULL(p3);\n+\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));\n+\n+    if (p1 != NULL)\n+        SCFree(p1);\n+    if (p2 != NULL)\n+        SCFree(p2);\n+    if (p3 != NULL)\n+        SCFree(p3);\n+\n+    DefragDestroy();\n+    PASS;\n+}\n+\n #endif /* UNITTESTS */\n \n void\n@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)\n     UtRegisterTest(\""DefragTimeoutTest\"", DefragTimeoutTest);\n     UtRegisterTest(\""DefragMfIpv4Test\"", DefragMfIpv4Test);\n     UtRegisterTest(\""DefragMfIpv6Test\"", DefragMfIpv6Test);\n+    UtRegisterTest(\""DefragTestBadProto\"", DefragTestBadProto);\n #endif /* UNITTESTS */\n }\n ""}<_**next**_>{""sha"": ""c3a0c693733a4199ce3ae7d37066e6c549edfcbd"", ""filename"": ""src/defrag.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.h?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -84,6 +84,8 @@ typedef struct DefragTracker_ {\n     uint32_t id; /**< IP ID for this tracker.  32 bits for IPv6, 16\n                   * for IPv4. */\n \n+    uint8_t proto; /**< IP protocol for this tracker. */\n+\n     uint8_t policy; /**< Reassembly policy this tracker will use. */\n \n     uint8_t af; /**< Address family for this tracker, AF_INET or""}","static int DefragMfIpv6Test(void)
{
    int retval = 0;
    int ip_id = 9;
    Packet *p = NULL;
 
     DefragInit();
 
    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);
    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);
    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }

    p = Defrag(NULL, NULL, p1, NULL);
    if (p != NULL) {
        goto end;
    }

    p = Defrag(NULL, NULL, p2, NULL);
    if (p != NULL) {
        goto end;
    }

    /* This should return a packet as MF=0. */
    p = Defrag(NULL, NULL, p3, NULL);
    if (p == NULL) {
        goto end;
    }

    /* For IPv6 the expected length is just the length of the payload
     * of 2 fragments, so 16. */
    if (IPV6_GET_PLEN(p) != 16) {
        goto end;
    }

    retval = 1;
end:
    if (p1 != NULL) {
        SCFree(p1);
    }
    if (p2 != NULL) {
        SCFree(p2);
    }
    if (p3 != NULL) {
        SCFree(p3);
    }
    if (p != NULL) {
        SCFree(p);
    }
    DefragDestroy();
     return retval;
 }
","static int DefragMfIpv6Test(void)
{
    int retval = 0;
    int ip_id = 9;
    Packet *p = NULL;
 
     DefragInit();
 
    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);
    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);
    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }

    p = Defrag(NULL, NULL, p1, NULL);
    if (p != NULL) {
        goto end;
    }

    p = Defrag(NULL, NULL, p2, NULL);
    if (p != NULL) {
        goto end;
    }

    /* This should return a packet as MF=0. */
    p = Defrag(NULL, NULL, p3, NULL);
    if (p == NULL) {
        goto end;
    }

    /* For IPv6 the expected length is just the length of the payload
     * of 2 fragments, so 16. */
    if (IPV6_GET_PLEN(p) != 16) {
        goto end;
    }

    retval = 1;
end:
    if (p1 != NULL) {
        SCFree(p1);
    }
    if (p2 != NULL) {
        SCFree(p2);
    }
    if (p3 != NULL) {
        SCFree(p3);
    }
    if (p != NULL) {
        SCFree(p);
    }
    DefragDestroy();
     return retval;
 }
",C,"    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);
    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);
    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);
","    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);
    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);
    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);
",,"@@ -996,8 +996,8 @@ void DefragDestroy(void)
  * with some payload of no particular protocol.
  */
 static Packet *
-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
-    int content_len)
+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     int hlen = 20;
@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
     else
         ip4h.ip_off = htons(off);
     ip4h.ip_ttl = ttl;
-    ip4h.ip_proto = IPPROTO_ICMP;
+    ip4h.ip_proto = proto;
 
     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */
     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */
@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
         goto error;
     if (IPV4_GET_IPTTL(p) != ttl)
         goto error;
-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)
+    if (IPV4_GET_IPPROTO(p) != proto)
         goto error;
 
     return p;
@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,
                           uint16_t prev_hdrextlen);
 
 static Packet *
-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
-    int content_len)
+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     uint8_t *pcontent;
@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
     IPV6_SET_RAW_VER(p->ip6h, 6);
     /* Fragmentation header. */
     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));
-    fh->ip6fh_nxt = IPPROTO_ICMP;
+    fh->ip6fh_nxt = proto;
     fh->ip6fh_ident = htonl(id);
     fh->ip6fh_offlg = htons((off << 3) | mf);
 
@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)
     if (dc == NULL)
         goto end;
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)
 
     /* Load in 16 packets. */
     for (i = 0; i < 16; i++) {
-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);
+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);
         if (p == NULL)
             goto end;
 
@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)
 
     /* Build a new packet but push the timestamp out by our timeout.
      * This should force our previous fragments to be timed out. */
-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);
+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);
     if (p == NULL)
         goto end;
 
@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)
         goto end;
 
     /* This packet has an offset > 0, more frags set to 0 and no data. */
-    p = BuildTestPacket(id, 1, 0, 'A', 0);
+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);
     if (p == NULL)
         goto end;
 
@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)
 
     /* Create a fragment that would extend past the max allowable size
      * for an IPv4 packet. */
-    p = BuildTestPacket(1, 8183, 0, 'A', 71);
+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);
     if (p == NULL)
         goto end;
 
@@ -2267,10 +2267,10 @@ DefragVlanTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)
 
     /* Build a packet, its not a fragment but shouldn't matter for
      * this test. */
-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);
     if (p1 == NULL) {
         goto end;
     }
@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)
 
     DefragInit();
 
-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)
 
     DefragInit();
 
-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)
     return retval;
 }
 
+/**
+ * \brief Test that fragments that match other than the proto don't
+ * actually get matched.
+ */
+static int DefragTestBadProto(void)
+{
+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
+    int id = 12;
+
+    DefragInit();
+
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
+    FAIL_IF_NULL(p1);
+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);
+    FAIL_IF_NULL(p2);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
+    FAIL_IF_NULL(p3);
+
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));
+
+    if (p1 != NULL)
+        SCFree(p1);
+    if (p2 != NULL)
+        SCFree(p2);
+    if (p3 != NULL)
+        SCFree(p3);
+
+    DefragDestroy();
+    PASS;
+}
+
 #endif /* UNITTESTS */
 
 void
@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)
     UtRegisterTest(""DefragTimeoutTest"", DefragTimeoutTest);
     UtRegisterTest(""DefragMfIpv4Test"", DefragMfIpv4Test);
     UtRegisterTest(""DefragMfIpv6Test"", DefragMfIpv6Test);
+    UtRegisterTest(""DefragTestBadProto"", DefragTestBadProto);
 #endif /* UNITTESTS */
 }
 ",suricata,4a04f814b15762eb446a5ead4d69d021512df6f8,292baf0872abfebf2762e08e613565703595db6c,1,"static int DefragMfIpv6Test(void)
{
    int retval = 0;
    int ip_id = 9;
    Packet *p = NULL;
 
     DefragInit();
 
//flaw_line_below:
    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);
//flaw_line_below:
    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);
//flaw_line_below:
    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);
//fix_flaw_line_below:
//    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);
//fix_flaw_line_below:
//    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);
//fix_flaw_line_below:
//    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }

    p = Defrag(NULL, NULL, p1, NULL);
    if (p != NULL) {
        goto end;
    }

    p = Defrag(NULL, NULL, p2, NULL);
    if (p != NULL) {
        goto end;
    }

    /* This should return a packet as MF=0. */
    p = Defrag(NULL, NULL, p3, NULL);
    if (p == NULL) {
        goto end;
    }

    /* For IPv6 the expected length is just the length of the payload
     * of 2 fragments, so 16. */
    if (IPV6_GET_PLEN(p) != 16) {
        goto end;
    }

    retval = 1;
end:
    if (p1 != NULL) {
        SCFree(p1);
    }
    if (p2 != NULL) {
        SCFree(p2);
    }
    if (p3 != NULL) {
        SCFree(p3);
    }
    if (p != NULL) {
        SCFree(p);
    }
    DefragDestroy();
     return retval;
 }
"
3737,181473,,Remote,Not required,,CVE-2017-7177,https://www.cvedetails.com/cve/CVE-2017-7177/,CWE-358,Low,,Partial,,2017-03-18,5.0,Suricata before 3.2.1 has an IPv4 defragmentation evasion issue caused by lack of a check for the IP protocol during fragment matching.,2018-12-05,,1,https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8,4a04f814b15762eb446a5ead4d69d021512df6f8,"defrag - take protocol into account during re-assembly

The IP protocol was not being used to match fragments with
their packets allowing a carefully constructed packet
with a different protocol to be matched, allowing re-assembly
to complete, creating a packet that would not be re-assembled
by the destination host.",0,src/defrag.c,"{""sha"": ""736099c58761058109931134cb06744878843604"", ""filename"": ""src/defrag-hash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag-hash.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -92,6 +92,7 @@ static void DefragTrackerInit(DefragTracker *dt, Packet *p)\n         dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);\n         dt->af = AF_INET6;\n     }\n+    dt->proto = IP_GET_IPPROTO(p);\n     dt->vlan_id[0] = p->vlan_id[0];\n     dt->vlan_id[1] = p->vlan_id[1];\n     dt->policy = DefragGetOsPolicy(p);\n@@ -406,6 +407,7 @@ static inline uint32_t DefragHashGetKey(Packet *p)\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->dst)) || \\\n       (CMP_ADDR(&(d1)->src_addr, &(d2)->dst) && \\\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->src))) && \\\n+     (d1)->proto == IP_GET_IPPROTO(p) &&        \\\n      (d1)->id == (id) && \\\n      (d1)->vlan_id[0] == (d2)->vlan_id[0] && \\\n      (d1)->vlan_id[1] == (d2)->vlan_id[1])""}<_**next**_>{""sha"": ""5433ce78607c5e694686de0fd2d93edec264b1bd"", ""filename"": ""src/defrag.c"", ""status"": ""modified"", ""additions"": 102, ""deletions"": 68, ""changes"": 170, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -996,8 +996,8 @@ void DefragDestroy(void)\n  * with some payload of no particular protocol.\n  */\n static Packet *\n-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     int hlen = 20;\n@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n     else\n         ip4h.ip_off = htons(off);\n     ip4h.ip_ttl = ttl;\n-    ip4h.ip_proto = IPPROTO_ICMP;\n+    ip4h.ip_proto = proto;\n \n     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */\n     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */\n@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n         goto error;\n     if (IPV4_GET_IPTTL(p) != ttl)\n         goto error;\n-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)\n+    if (IPV4_GET_IPPROTO(p) != proto)\n         goto error;\n \n     return p;\n@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,\n                           uint16_t prev_hdrextlen);\n \n static Packet *\n-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     uint8_t *pcontent;\n@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n     IPV6_SET_RAW_VER(p->ip6h, 6);\n     /* Fragmentation header. */\n     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));\n-    fh->ip6fh_nxt = IPPROTO_ICMP;\n+    fh->ip6fh_nxt = proto;\n     fh->ip6fh_ident = htonl(id);\n     fh->ip6fh_offlg = htons((off << 3) | mf);\n \n@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)\n     if (dc == NULL)\n         goto end;\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)\n \n     /* Load in 16 packets. */\n     for (i = 0; i < 16; i++) {\n-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);\n+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);\n         if (p == NULL)\n             goto end;\n \n@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)\n \n     /* Build a new packet but push the timestamp out by our timeout.\n      * This should force our previous fragments to be timed out. */\n-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);\n+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);\n     if (p == NULL)\n         goto end;\n \n@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)\n         goto end;\n \n     /* This packet has an offset > 0, more frags set to 0 and no data. */\n-    p = BuildTestPacket(id, 1, 0, 'A', 0);\n+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);\n     if (p == NULL)\n         goto end;\n \n@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)\n \n     /* Create a fragment that would extend past the max allowable size\n      * for an IPv4 packet. */\n-    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);\n     if (p == NULL)\n         goto end;\n \n@@ -2267,10 +2267,10 @@ DefragVlanTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)\n \n     /* Build a packet, its not a fragment but shouldn't matter for\n      * this test. */\n-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);\n     if (p1 == NULL) {\n         goto end;\n     }\n@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)\n     return retval;\n }\n \n+/**\n+ * \\brief Test that fragments that match other than the proto don't\n+ * actually get matched.\n+ */\n+static int DefragTestBadProto(void)\n+{\n+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n+    int id = 12;\n+\n+    DefragInit();\n+\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n+    FAIL_IF_NULL(p1);\n+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);\n+    FAIL_IF_NULL(p2);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n+    FAIL_IF_NULL(p3);\n+\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));\n+\n+    if (p1 != NULL)\n+        SCFree(p1);\n+    if (p2 != NULL)\n+        SCFree(p2);\n+    if (p3 != NULL)\n+        SCFree(p3);\n+\n+    DefragDestroy();\n+    PASS;\n+}\n+\n #endif /* UNITTESTS */\n \n void\n@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)\n     UtRegisterTest(\""DefragTimeoutTest\"", DefragTimeoutTest);\n     UtRegisterTest(\""DefragMfIpv4Test\"", DefragMfIpv4Test);\n     UtRegisterTest(\""DefragMfIpv6Test\"", DefragMfIpv6Test);\n+    UtRegisterTest(\""DefragTestBadProto\"", DefragTestBadProto);\n #endif /* UNITTESTS */\n }\n ""}<_**next**_>{""sha"": ""c3a0c693733a4199ce3ae7d37066e6c549edfcbd"", ""filename"": ""src/defrag.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.h?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -84,6 +84,8 @@ typedef struct DefragTracker_ {\n     uint32_t id; /**< IP ID for this tracker.  32 bits for IPv6, 16\n                   * for IPv4. */\n \n+    uint8_t proto; /**< IP protocol for this tracker. */\n+\n     uint8_t policy; /**< Reassembly policy this tracker will use. */\n \n     uint8_t af; /**< Address family for this tracker, AF_INET or""}","DefragRegisterTests(void)
{
#ifdef UNITTESTS
    UtRegisterTest(""DefragInOrderSimpleTest"", DefragInOrderSimpleTest);
    UtRegisterTest(""DefragReverseSimpleTest"", DefragReverseSimpleTest);
    UtRegisterTest(""DefragSturgesNovakBsdTest"", DefragSturgesNovakBsdTest);
    UtRegisterTest(""DefragSturgesNovakLinuxTest"", DefragSturgesNovakLinuxTest);
    UtRegisterTest(""DefragSturgesNovakWindowsTest"",
                   DefragSturgesNovakWindowsTest);
    UtRegisterTest(""DefragSturgesNovakSolarisTest"",
                   DefragSturgesNovakSolarisTest);
    UtRegisterTest(""DefragSturgesNovakFirstTest"", DefragSturgesNovakFirstTest);
    UtRegisterTest(""DefragSturgesNovakLastTest"", DefragSturgesNovakLastTest);

    UtRegisterTest(""DefragIPv4NoDataTest"", DefragIPv4NoDataTest);
    UtRegisterTest(""DefragIPv4TooLargeTest"", DefragIPv4TooLargeTest);

    UtRegisterTest(""IPV6DefragInOrderSimpleTest"", IPV6DefragInOrderSimpleTest);
    UtRegisterTest(""IPV6DefragReverseSimpleTest"", IPV6DefragReverseSimpleTest);
    UtRegisterTest(""IPV6DefragSturgesNovakBsdTest"",
                   IPV6DefragSturgesNovakBsdTest);
    UtRegisterTest(""IPV6DefragSturgesNovakLinuxTest"",
                   IPV6DefragSturgesNovakLinuxTest);
    UtRegisterTest(""IPV6DefragSturgesNovakWindowsTest"",
                   IPV6DefragSturgesNovakWindowsTest);
    UtRegisterTest(""IPV6DefragSturgesNovakSolarisTest"",
                   IPV6DefragSturgesNovakSolarisTest);
    UtRegisterTest(""IPV6DefragSturgesNovakFirstTest"",
                   IPV6DefragSturgesNovakFirstTest);
    UtRegisterTest(""IPV6DefragSturgesNovakLastTest"",
                   IPV6DefragSturgesNovakLastTest);

    UtRegisterTest(""DefragVlanTest"", DefragVlanTest);
    UtRegisterTest(""DefragVlanQinQTest"", DefragVlanQinQTest);
    UtRegisterTest(""DefragTrackerReuseTest"", DefragTrackerReuseTest);
     UtRegisterTest(""DefragTimeoutTest"", DefragTimeoutTest);
     UtRegisterTest(""DefragMfIpv4Test"", DefragMfIpv4Test);
     UtRegisterTest(""DefragMfIpv6Test"", DefragMfIpv6Test);
    UtRegisterTest(""DefragTestBadProto"", DefragTestBadProto);
 #endif /* UNITTESTS */
 }
","DefragRegisterTests(void)
{
#ifdef UNITTESTS
    UtRegisterTest(""DefragInOrderSimpleTest"", DefragInOrderSimpleTest);
    UtRegisterTest(""DefragReverseSimpleTest"", DefragReverseSimpleTest);
    UtRegisterTest(""DefragSturgesNovakBsdTest"", DefragSturgesNovakBsdTest);
    UtRegisterTest(""DefragSturgesNovakLinuxTest"", DefragSturgesNovakLinuxTest);
    UtRegisterTest(""DefragSturgesNovakWindowsTest"",
                   DefragSturgesNovakWindowsTest);
    UtRegisterTest(""DefragSturgesNovakSolarisTest"",
                   DefragSturgesNovakSolarisTest);
    UtRegisterTest(""DefragSturgesNovakFirstTest"", DefragSturgesNovakFirstTest);
    UtRegisterTest(""DefragSturgesNovakLastTest"", DefragSturgesNovakLastTest);

    UtRegisterTest(""DefragIPv4NoDataTest"", DefragIPv4NoDataTest);
    UtRegisterTest(""DefragIPv4TooLargeTest"", DefragIPv4TooLargeTest);

    UtRegisterTest(""IPV6DefragInOrderSimpleTest"", IPV6DefragInOrderSimpleTest);
    UtRegisterTest(""IPV6DefragReverseSimpleTest"", IPV6DefragReverseSimpleTest);
    UtRegisterTest(""IPV6DefragSturgesNovakBsdTest"",
                   IPV6DefragSturgesNovakBsdTest);
    UtRegisterTest(""IPV6DefragSturgesNovakLinuxTest"",
                   IPV6DefragSturgesNovakLinuxTest);
    UtRegisterTest(""IPV6DefragSturgesNovakWindowsTest"",
                   IPV6DefragSturgesNovakWindowsTest);
    UtRegisterTest(""IPV6DefragSturgesNovakSolarisTest"",
                   IPV6DefragSturgesNovakSolarisTest);
    UtRegisterTest(""IPV6DefragSturgesNovakFirstTest"",
                   IPV6DefragSturgesNovakFirstTest);
    UtRegisterTest(""IPV6DefragSturgesNovakLastTest"",
                   IPV6DefragSturgesNovakLastTest);

    UtRegisterTest(""DefragVlanTest"", DefragVlanTest);
    UtRegisterTest(""DefragVlanQinQTest"", DefragVlanQinQTest);
    UtRegisterTest(""DefragTrackerReuseTest"", DefragTrackerReuseTest);
     UtRegisterTest(""DefragTimeoutTest"", DefragTimeoutTest);
     UtRegisterTest(""DefragMfIpv4Test"", DefragMfIpv4Test);
     UtRegisterTest(""DefragMfIpv6Test"", DefragMfIpv6Test);
 #endif /* UNITTESTS */
 }
",C,"    UtRegisterTest(""DefragTestBadProto"", DefragTestBadProto);
",,,"@@ -996,8 +996,8 @@ void DefragDestroy(void)
  * with some payload of no particular protocol.
  */
 static Packet *
-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
-    int content_len)
+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     int hlen = 20;
@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
     else
         ip4h.ip_off = htons(off);
     ip4h.ip_ttl = ttl;
-    ip4h.ip_proto = IPPROTO_ICMP;
+    ip4h.ip_proto = proto;
 
     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */
     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */
@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
         goto error;
     if (IPV4_GET_IPTTL(p) != ttl)
         goto error;
-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)
+    if (IPV4_GET_IPPROTO(p) != proto)
         goto error;
 
     return p;
@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,
                           uint16_t prev_hdrextlen);
 
 static Packet *
-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
-    int content_len)
+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     uint8_t *pcontent;
@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
     IPV6_SET_RAW_VER(p->ip6h, 6);
     /* Fragmentation header. */
     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));
-    fh->ip6fh_nxt = IPPROTO_ICMP;
+    fh->ip6fh_nxt = proto;
     fh->ip6fh_ident = htonl(id);
     fh->ip6fh_offlg = htons((off << 3) | mf);
 
@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)
     if (dc == NULL)
         goto end;
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)
 
     /* Load in 16 packets. */
     for (i = 0; i < 16; i++) {
-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);
+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);
         if (p == NULL)
             goto end;
 
@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)
 
     /* Build a new packet but push the timestamp out by our timeout.
      * This should force our previous fragments to be timed out. */
-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);
+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);
     if (p == NULL)
         goto end;
 
@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)
         goto end;
 
     /* This packet has an offset > 0, more frags set to 0 and no data. */
-    p = BuildTestPacket(id, 1, 0, 'A', 0);
+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);
     if (p == NULL)
         goto end;
 
@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)
 
     /* Create a fragment that would extend past the max allowable size
      * for an IPv4 packet. */
-    p = BuildTestPacket(1, 8183, 0, 'A', 71);
+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);
     if (p == NULL)
         goto end;
 
@@ -2267,10 +2267,10 @@ DefragVlanTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)
 
     /* Build a packet, its not a fragment but shouldn't matter for
      * this test. */
-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);
     if (p1 == NULL) {
         goto end;
     }
@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)
 
     DefragInit();
 
-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)
 
     DefragInit();
 
-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)
     return retval;
 }
 
+/**
+ * \brief Test that fragments that match other than the proto don't
+ * actually get matched.
+ */
+static int DefragTestBadProto(void)
+{
+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
+    int id = 12;
+
+    DefragInit();
+
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
+    FAIL_IF_NULL(p1);
+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);
+    FAIL_IF_NULL(p2);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
+    FAIL_IF_NULL(p3);
+
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));
+
+    if (p1 != NULL)
+        SCFree(p1);
+    if (p2 != NULL)
+        SCFree(p2);
+    if (p3 != NULL)
+        SCFree(p3);
+
+    DefragDestroy();
+    PASS;
+}
+
 #endif /* UNITTESTS */
 
 void
@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)
     UtRegisterTest(""DefragTimeoutTest"", DefragTimeoutTest);
     UtRegisterTest(""DefragMfIpv4Test"", DefragMfIpv4Test);
     UtRegisterTest(""DefragMfIpv6Test"", DefragMfIpv6Test);
+    UtRegisterTest(""DefragTestBadProto"", DefragTestBadProto);
 #endif /* UNITTESTS */
 }
 ",suricata,4a04f814b15762eb446a5ead4d69d021512df6f8,292baf0872abfebf2762e08e613565703595db6c,1,"DefragRegisterTests(void)
{
#ifdef UNITTESTS
    UtRegisterTest(""DefragInOrderSimpleTest"", DefragInOrderSimpleTest);
    UtRegisterTest(""DefragReverseSimpleTest"", DefragReverseSimpleTest);
    UtRegisterTest(""DefragSturgesNovakBsdTest"", DefragSturgesNovakBsdTest);
    UtRegisterTest(""DefragSturgesNovakLinuxTest"", DefragSturgesNovakLinuxTest);
    UtRegisterTest(""DefragSturgesNovakWindowsTest"",
                   DefragSturgesNovakWindowsTest);
    UtRegisterTest(""DefragSturgesNovakSolarisTest"",
                   DefragSturgesNovakSolarisTest);
    UtRegisterTest(""DefragSturgesNovakFirstTest"", DefragSturgesNovakFirstTest);
    UtRegisterTest(""DefragSturgesNovakLastTest"", DefragSturgesNovakLastTest);

    UtRegisterTest(""DefragIPv4NoDataTest"", DefragIPv4NoDataTest);
    UtRegisterTest(""DefragIPv4TooLargeTest"", DefragIPv4TooLargeTest);

    UtRegisterTest(""IPV6DefragInOrderSimpleTest"", IPV6DefragInOrderSimpleTest);
    UtRegisterTest(""IPV6DefragReverseSimpleTest"", IPV6DefragReverseSimpleTest);
    UtRegisterTest(""IPV6DefragSturgesNovakBsdTest"",
                   IPV6DefragSturgesNovakBsdTest);
    UtRegisterTest(""IPV6DefragSturgesNovakLinuxTest"",
                   IPV6DefragSturgesNovakLinuxTest);
    UtRegisterTest(""IPV6DefragSturgesNovakWindowsTest"",
                   IPV6DefragSturgesNovakWindowsTest);
    UtRegisterTest(""IPV6DefragSturgesNovakSolarisTest"",
                   IPV6DefragSturgesNovakSolarisTest);
    UtRegisterTest(""IPV6DefragSturgesNovakFirstTest"",
                   IPV6DefragSturgesNovakFirstTest);
    UtRegisterTest(""IPV6DefragSturgesNovakLastTest"",
                   IPV6DefragSturgesNovakLastTest);

    UtRegisterTest(""DefragVlanTest"", DefragVlanTest);
    UtRegisterTest(""DefragVlanQinQTest"", DefragVlanQinQTest);
    UtRegisterTest(""DefragTrackerReuseTest"", DefragTrackerReuseTest);
     UtRegisterTest(""DefragTimeoutTest"", DefragTimeoutTest);
     UtRegisterTest(""DefragMfIpv4Test"", DefragMfIpv4Test);
     UtRegisterTest(""DefragMfIpv6Test"", DefragMfIpv6Test);
//fix_flaw_line_below:
//    UtRegisterTest(""DefragTestBadProto"", DefragTestBadProto);
 #endif /* UNITTESTS */
 }
"
3738,181474,,Remote,Not required,,CVE-2017-7177,https://www.cvedetails.com/cve/CVE-2017-7177/,CWE-358,Low,,Partial,,2017-03-18,5.0,Suricata before 3.2.1 has an IPv4 defragmentation evasion issue caused by lack of a check for the IP protocol during fragment matching.,2018-12-05,,3,https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8,4a04f814b15762eb446a5ead4d69d021512df6f8,"defrag - take protocol into account during re-assembly

The IP protocol was not being used to match fragments with
their packets allowing a carefully constructed packet
with a different protocol to be matched, allowing re-assembly
to complete, creating a packet that would not be re-assembled
by the destination host.",3,src/defrag.c,"{""sha"": ""736099c58761058109931134cb06744878843604"", ""filename"": ""src/defrag-hash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag-hash.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -92,6 +92,7 @@ static void DefragTrackerInit(DefragTracker *dt, Packet *p)\n         dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);\n         dt->af = AF_INET6;\n     }\n+    dt->proto = IP_GET_IPPROTO(p);\n     dt->vlan_id[0] = p->vlan_id[0];\n     dt->vlan_id[1] = p->vlan_id[1];\n     dt->policy = DefragGetOsPolicy(p);\n@@ -406,6 +407,7 @@ static inline uint32_t DefragHashGetKey(Packet *p)\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->dst)) || \\\n       (CMP_ADDR(&(d1)->src_addr, &(d2)->dst) && \\\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->src))) && \\\n+     (d1)->proto == IP_GET_IPPROTO(p) &&        \\\n      (d1)->id == (id) && \\\n      (d1)->vlan_id[0] == (d2)->vlan_id[0] && \\\n      (d1)->vlan_id[1] == (d2)->vlan_id[1])""}<_**next**_>{""sha"": ""5433ce78607c5e694686de0fd2d93edec264b1bd"", ""filename"": ""src/defrag.c"", ""status"": ""modified"", ""additions"": 102, ""deletions"": 68, ""changes"": 170, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -996,8 +996,8 @@ void DefragDestroy(void)\n  * with some payload of no particular protocol.\n  */\n static Packet *\n-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     int hlen = 20;\n@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n     else\n         ip4h.ip_off = htons(off);\n     ip4h.ip_ttl = ttl;\n-    ip4h.ip_proto = IPPROTO_ICMP;\n+    ip4h.ip_proto = proto;\n \n     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */\n     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */\n@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n         goto error;\n     if (IPV4_GET_IPTTL(p) != ttl)\n         goto error;\n-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)\n+    if (IPV4_GET_IPPROTO(p) != proto)\n         goto error;\n \n     return p;\n@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,\n                           uint16_t prev_hdrextlen);\n \n static Packet *\n-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     uint8_t *pcontent;\n@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n     IPV6_SET_RAW_VER(p->ip6h, 6);\n     /* Fragmentation header. */\n     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));\n-    fh->ip6fh_nxt = IPPROTO_ICMP;\n+    fh->ip6fh_nxt = proto;\n     fh->ip6fh_ident = htonl(id);\n     fh->ip6fh_offlg = htons((off << 3) | mf);\n \n@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)\n     if (dc == NULL)\n         goto end;\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)\n \n     /* Load in 16 packets. */\n     for (i = 0; i < 16; i++) {\n-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);\n+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);\n         if (p == NULL)\n             goto end;\n \n@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)\n \n     /* Build a new packet but push the timestamp out by our timeout.\n      * This should force our previous fragments to be timed out. */\n-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);\n+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);\n     if (p == NULL)\n         goto end;\n \n@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)\n         goto end;\n \n     /* This packet has an offset > 0, more frags set to 0 and no data. */\n-    p = BuildTestPacket(id, 1, 0, 'A', 0);\n+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);\n     if (p == NULL)\n         goto end;\n \n@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)\n \n     /* Create a fragment that would extend past the max allowable size\n      * for an IPv4 packet. */\n-    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);\n     if (p == NULL)\n         goto end;\n \n@@ -2267,10 +2267,10 @@ DefragVlanTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)\n \n     /* Build a packet, its not a fragment but shouldn't matter for\n      * this test. */\n-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);\n     if (p1 == NULL) {\n         goto end;\n     }\n@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)\n     return retval;\n }\n \n+/**\n+ * \\brief Test that fragments that match other than the proto don't\n+ * actually get matched.\n+ */\n+static int DefragTestBadProto(void)\n+{\n+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n+    int id = 12;\n+\n+    DefragInit();\n+\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n+    FAIL_IF_NULL(p1);\n+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);\n+    FAIL_IF_NULL(p2);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n+    FAIL_IF_NULL(p3);\n+\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));\n+\n+    if (p1 != NULL)\n+        SCFree(p1);\n+    if (p2 != NULL)\n+        SCFree(p2);\n+    if (p3 != NULL)\n+        SCFree(p3);\n+\n+    DefragDestroy();\n+    PASS;\n+}\n+\n #endif /* UNITTESTS */\n \n void\n@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)\n     UtRegisterTest(\""DefragTimeoutTest\"", DefragTimeoutTest);\n     UtRegisterTest(\""DefragMfIpv4Test\"", DefragMfIpv4Test);\n     UtRegisterTest(\""DefragMfIpv6Test\"", DefragMfIpv6Test);\n+    UtRegisterTest(\""DefragTestBadProto\"", DefragTestBadProto);\n #endif /* UNITTESTS */\n }\n ""}<_**next**_>{""sha"": ""c3a0c693733a4199ce3ae7d37066e6c549edfcbd"", ""filename"": ""src/defrag.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.h?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -84,6 +84,8 @@ typedef struct DefragTracker_ {\n     uint32_t id; /**< IP ID for this tracker.  32 bits for IPv6, 16\n                   * for IPv4. */\n \n+    uint8_t proto; /**< IP protocol for this tracker. */\n+\n     uint8_t policy; /**< Reassembly policy this tracker will use. */\n \n     uint8_t af; /**< Address family for this tracker, AF_INET or""}","DefragReverseSimpleTest(void)
{
    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
    Packet *reassembled = NULL;
    int id = 12;
    int i;
    int ret = 0;
 
     DefragInit();
 
    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
    if (Defrag(NULL, NULL, p3, NULL) != NULL)
        goto end;
    if (Defrag(NULL, NULL, p2, NULL) != NULL)
        goto end;

    reassembled = Defrag(NULL, NULL, p1, NULL);
    if (reassembled == NULL)
        goto end;

    if (IPV4_GET_HLEN(reassembled) != 20)
        goto end;
    if (IPV4_GET_IPLEN(reassembled) != 39)
        goto end;

    /* 20 bytes in we should find 8 bytes of A. */
    for (i = 20; i < 20 + 8; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'A')
            goto end;
    }

    /* 28 bytes in we should find 8 bytes of B. */
    for (i = 28; i < 28 + 8; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'B')
            goto end;
    }

    /* And 36 bytes in we should find 3 bytes of C. */
    for (i = 36; i < 36 + 3; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'C')
            goto end;
    }

    ret = 1;
end:
    if (p1 != NULL)
        SCFree(p1);
    if (p2 != NULL)
        SCFree(p2);
    if (p3 != NULL)
        SCFree(p3);
    if (reassembled != NULL)
        SCFree(reassembled);

    DefragDestroy();
    return ret;
}
","DefragReverseSimpleTest(void)
{
    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
    Packet *reassembled = NULL;
    int id = 12;
    int i;
    int ret = 0;
 
     DefragInit();
 
    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
    if (Defrag(NULL, NULL, p3, NULL) != NULL)
        goto end;
    if (Defrag(NULL, NULL, p2, NULL) != NULL)
        goto end;

    reassembled = Defrag(NULL, NULL, p1, NULL);
    if (reassembled == NULL)
        goto end;

    if (IPV4_GET_HLEN(reassembled) != 20)
        goto end;
    if (IPV4_GET_IPLEN(reassembled) != 39)
        goto end;

    /* 20 bytes in we should find 8 bytes of A. */
    for (i = 20; i < 20 + 8; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'A')
            goto end;
    }

    /* 28 bytes in we should find 8 bytes of B. */
    for (i = 28; i < 28 + 8; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'B')
            goto end;
    }

    /* And 36 bytes in we should find 3 bytes of C. */
    for (i = 36; i < 36 + 3; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'C')
            goto end;
    }

    ret = 1;
end:
    if (p1 != NULL)
        SCFree(p1);
    if (p2 != NULL)
        SCFree(p2);
    if (p3 != NULL)
        SCFree(p3);
    if (reassembled != NULL)
        SCFree(reassembled);

    DefragDestroy();
    return ret;
}
",C,"    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
","    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
",,"@@ -996,8 +996,8 @@ void DefragDestroy(void)
  * with some payload of no particular protocol.
  */
 static Packet *
-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
-    int content_len)
+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     int hlen = 20;
@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
     else
         ip4h.ip_off = htons(off);
     ip4h.ip_ttl = ttl;
-    ip4h.ip_proto = IPPROTO_ICMP;
+    ip4h.ip_proto = proto;
 
     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */
     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */
@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
         goto error;
     if (IPV4_GET_IPTTL(p) != ttl)
         goto error;
-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)
+    if (IPV4_GET_IPPROTO(p) != proto)
         goto error;
 
     return p;
@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,
                           uint16_t prev_hdrextlen);
 
 static Packet *
-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
-    int content_len)
+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     uint8_t *pcontent;
@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
     IPV6_SET_RAW_VER(p->ip6h, 6);
     /* Fragmentation header. */
     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));
-    fh->ip6fh_nxt = IPPROTO_ICMP;
+    fh->ip6fh_nxt = proto;
     fh->ip6fh_ident = htonl(id);
     fh->ip6fh_offlg = htons((off << 3) | mf);
 
@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)
     if (dc == NULL)
         goto end;
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)
 
     /* Load in 16 packets. */
     for (i = 0; i < 16; i++) {
-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);
+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);
         if (p == NULL)
             goto end;
 
@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)
 
     /* Build a new packet but push the timestamp out by our timeout.
      * This should force our previous fragments to be timed out. */
-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);
+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);
     if (p == NULL)
         goto end;
 
@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)
         goto end;
 
     /* This packet has an offset > 0, more frags set to 0 and no data. */
-    p = BuildTestPacket(id, 1, 0, 'A', 0);
+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);
     if (p == NULL)
         goto end;
 
@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)
 
     /* Create a fragment that would extend past the max allowable size
      * for an IPv4 packet. */
-    p = BuildTestPacket(1, 8183, 0, 'A', 71);
+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);
     if (p == NULL)
         goto end;
 
@@ -2267,10 +2267,10 @@ DefragVlanTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)
 
     /* Build a packet, its not a fragment but shouldn't matter for
      * this test. */
-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);
     if (p1 == NULL) {
         goto end;
     }
@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)
 
     DefragInit();
 
-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)
 
     DefragInit();
 
-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)
     return retval;
 }
 
+/**
+ * \brief Test that fragments that match other than the proto don't
+ * actually get matched.
+ */
+static int DefragTestBadProto(void)
+{
+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
+    int id = 12;
+
+    DefragInit();
+
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
+    FAIL_IF_NULL(p1);
+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);
+    FAIL_IF_NULL(p2);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
+    FAIL_IF_NULL(p3);
+
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));
+
+    if (p1 != NULL)
+        SCFree(p1);
+    if (p2 != NULL)
+        SCFree(p2);
+    if (p3 != NULL)
+        SCFree(p3);
+
+    DefragDestroy();
+    PASS;
+}
+
 #endif /* UNITTESTS */
 
 void
@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)
     UtRegisterTest(""DefragTimeoutTest"", DefragTimeoutTest);
     UtRegisterTest(""DefragMfIpv4Test"", DefragMfIpv4Test);
     UtRegisterTest(""DefragMfIpv6Test"", DefragMfIpv6Test);
+    UtRegisterTest(""DefragTestBadProto"", DefragTestBadProto);
 #endif /* UNITTESTS */
 }
 ",suricata,4a04f814b15762eb446a5ead4d69d021512df6f8,292baf0872abfebf2762e08e613565703595db6c,1,"DefragReverseSimpleTest(void)
{
    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
    Packet *reassembled = NULL;
    int id = 12;
    int i;
    int ret = 0;
 
     DefragInit();
 
//flaw_line_below:
    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
//fix_flaw_line_below:
//    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
//flaw_line_below:
    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
//fix_flaw_line_below:
//    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
//flaw_line_below:
    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
//fix_flaw_line_below:
//    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
    if (Defrag(NULL, NULL, p3, NULL) != NULL)
        goto end;
    if (Defrag(NULL, NULL, p2, NULL) != NULL)
        goto end;

    reassembled = Defrag(NULL, NULL, p1, NULL);
    if (reassembled == NULL)
        goto end;

    if (IPV4_GET_HLEN(reassembled) != 20)
        goto end;
    if (IPV4_GET_IPLEN(reassembled) != 39)
        goto end;

    /* 20 bytes in we should find 8 bytes of A. */
    for (i = 20; i < 20 + 8; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'A')
            goto end;
    }

    /* 28 bytes in we should find 8 bytes of B. */
    for (i = 28; i < 28 + 8; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'B')
            goto end;
    }

    /* And 36 bytes in we should find 3 bytes of C. */
    for (i = 36; i < 36 + 3; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'C')
            goto end;
    }

    ret = 1;
end:
    if (p1 != NULL)
        SCFree(p1);
    if (p2 != NULL)
        SCFree(p2);
    if (p3 != NULL)
        SCFree(p3);
    if (reassembled != NULL)
        SCFree(reassembled);

    DefragDestroy();
    return ret;
}
"
3739,181475,,Remote,Not required,,CVE-2017-7177,https://www.cvedetails.com/cve/CVE-2017-7177/,CWE-358,Low,,Partial,,2017-03-18,5.0,Suricata before 3.2.1 has an IPv4 defragmentation evasion issue caused by lack of a check for the IP protocol during fragment matching.,2018-12-05,,2,https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8,4a04f814b15762eb446a5ead4d69d021512df6f8,"defrag - take protocol into account during re-assembly

The IP protocol was not being used to match fragments with
their packets allowing a carefully constructed packet
with a different protocol to be matched, allowing re-assembly
to complete, creating a packet that would not be re-assembled
by the destination host.",2,src/defrag.c,"{""sha"": ""736099c58761058109931134cb06744878843604"", ""filename"": ""src/defrag-hash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag-hash.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -92,6 +92,7 @@ static void DefragTrackerInit(DefragTracker *dt, Packet *p)\n         dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);\n         dt->af = AF_INET6;\n     }\n+    dt->proto = IP_GET_IPPROTO(p);\n     dt->vlan_id[0] = p->vlan_id[0];\n     dt->vlan_id[1] = p->vlan_id[1];\n     dt->policy = DefragGetOsPolicy(p);\n@@ -406,6 +407,7 @@ static inline uint32_t DefragHashGetKey(Packet *p)\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->dst)) || \\\n       (CMP_ADDR(&(d1)->src_addr, &(d2)->dst) && \\\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->src))) && \\\n+     (d1)->proto == IP_GET_IPPROTO(p) &&        \\\n      (d1)->id == (id) && \\\n      (d1)->vlan_id[0] == (d2)->vlan_id[0] && \\\n      (d1)->vlan_id[1] == (d2)->vlan_id[1])""}<_**next**_>{""sha"": ""5433ce78607c5e694686de0fd2d93edec264b1bd"", ""filename"": ""src/defrag.c"", ""status"": ""modified"", ""additions"": 102, ""deletions"": 68, ""changes"": 170, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -996,8 +996,8 @@ void DefragDestroy(void)\n  * with some payload of no particular protocol.\n  */\n static Packet *\n-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     int hlen = 20;\n@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n     else\n         ip4h.ip_off = htons(off);\n     ip4h.ip_ttl = ttl;\n-    ip4h.ip_proto = IPPROTO_ICMP;\n+    ip4h.ip_proto = proto;\n \n     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */\n     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */\n@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n         goto error;\n     if (IPV4_GET_IPTTL(p) != ttl)\n         goto error;\n-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)\n+    if (IPV4_GET_IPPROTO(p) != proto)\n         goto error;\n \n     return p;\n@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,\n                           uint16_t prev_hdrextlen);\n \n static Packet *\n-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     uint8_t *pcontent;\n@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n     IPV6_SET_RAW_VER(p->ip6h, 6);\n     /* Fragmentation header. */\n     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));\n-    fh->ip6fh_nxt = IPPROTO_ICMP;\n+    fh->ip6fh_nxt = proto;\n     fh->ip6fh_ident = htonl(id);\n     fh->ip6fh_offlg = htons((off << 3) | mf);\n \n@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)\n     if (dc == NULL)\n         goto end;\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)\n \n     /* Load in 16 packets. */\n     for (i = 0; i < 16; i++) {\n-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);\n+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);\n         if (p == NULL)\n             goto end;\n \n@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)\n \n     /* Build a new packet but push the timestamp out by our timeout.\n      * This should force our previous fragments to be timed out. */\n-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);\n+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);\n     if (p == NULL)\n         goto end;\n \n@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)\n         goto end;\n \n     /* This packet has an offset > 0, more frags set to 0 and no data. */\n-    p = BuildTestPacket(id, 1, 0, 'A', 0);\n+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);\n     if (p == NULL)\n         goto end;\n \n@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)\n \n     /* Create a fragment that would extend past the max allowable size\n      * for an IPv4 packet. */\n-    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);\n     if (p == NULL)\n         goto end;\n \n@@ -2267,10 +2267,10 @@ DefragVlanTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)\n \n     /* Build a packet, its not a fragment but shouldn't matter for\n      * this test. */\n-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);\n     if (p1 == NULL) {\n         goto end;\n     }\n@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)\n     return retval;\n }\n \n+/**\n+ * \\brief Test that fragments that match other than the proto don't\n+ * actually get matched.\n+ */\n+static int DefragTestBadProto(void)\n+{\n+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n+    int id = 12;\n+\n+    DefragInit();\n+\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n+    FAIL_IF_NULL(p1);\n+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);\n+    FAIL_IF_NULL(p2);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n+    FAIL_IF_NULL(p3);\n+\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));\n+\n+    if (p1 != NULL)\n+        SCFree(p1);\n+    if (p2 != NULL)\n+        SCFree(p2);\n+    if (p3 != NULL)\n+        SCFree(p3);\n+\n+    DefragDestroy();\n+    PASS;\n+}\n+\n #endif /* UNITTESTS */\n \n void\n@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)\n     UtRegisterTest(\""DefragTimeoutTest\"", DefragTimeoutTest);\n     UtRegisterTest(\""DefragMfIpv4Test\"", DefragMfIpv4Test);\n     UtRegisterTest(\""DefragMfIpv6Test\"", DefragMfIpv6Test);\n+    UtRegisterTest(\""DefragTestBadProto\"", DefragTestBadProto);\n #endif /* UNITTESTS */\n }\n ""}<_**next**_>{""sha"": ""c3a0c693733a4199ce3ae7d37066e6c549edfcbd"", ""filename"": ""src/defrag.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.h?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -84,6 +84,8 @@ typedef struct DefragTracker_ {\n     uint32_t id; /**< IP ID for this tracker.  32 bits for IPv6, 16\n                   * for IPv4. */\n \n+    uint8_t proto; /**< IP protocol for this tracker. */\n+\n     uint8_t policy; /**< Reassembly policy this tracker will use. */\n \n     uint8_t af; /**< Address family for this tracker, AF_INET or""}","DefragTimeoutTest(void)
{
    int i;
    int ret = 0;

    /* Setup a small numberr of trackers. */
    if (ConfSet(""defrag.trackers"", ""16"") != 1) {
        printf(""ConfSet failed: "");
        goto end;
    }

    DefragInit();
 
     /* Load in 16 packets. */
     for (i = 0; i < 16; i++) {
        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);
         if (p == NULL)
             goto end;
 
        Packet *tp = Defrag(NULL, NULL, p, NULL);

        SCFree(p);

        if (tp != NULL) {
            SCFree(tp);
            goto end;
        }
    }
 
     /* Build a new packet but push the timestamp out by our timeout.
      * This should force our previous fragments to be timed out. */
    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);
     if (p == NULL)
         goto end;
 
    p->ts.tv_sec += (defrag_context->timeout + 1);
    Packet *tp = Defrag(NULL, NULL, p, NULL);

    if (tp != NULL) {
        SCFree(tp);
        goto end;
    }

    DefragTracker *tracker = DefragLookupTrackerFromHash(p);
    if (tracker == NULL)
        goto end;

    if (tracker->id != 99)
        goto end;

    SCFree(p);

    ret = 1;
end:
    DefragDestroy();
    return ret;
}
","DefragTimeoutTest(void)
{
    int i;
    int ret = 0;

    /* Setup a small numberr of trackers. */
    if (ConfSet(""defrag.trackers"", ""16"") != 1) {
        printf(""ConfSet failed: "");
        goto end;
    }

    DefragInit();
 
     /* Load in 16 packets. */
     for (i = 0; i < 16; i++) {
        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);
         if (p == NULL)
             goto end;
 
        Packet *tp = Defrag(NULL, NULL, p, NULL);

        SCFree(p);

        if (tp != NULL) {
            SCFree(tp);
            goto end;
        }
    }
 
     /* Build a new packet but push the timestamp out by our timeout.
      * This should force our previous fragments to be timed out. */
    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);
     if (p == NULL)
         goto end;
 
    p->ts.tv_sec += (defrag_context->timeout + 1);
    Packet *tp = Defrag(NULL, NULL, p, NULL);

    if (tp != NULL) {
        SCFree(tp);
        goto end;
    }

    DefragTracker *tracker = DefragLookupTrackerFromHash(p);
    if (tracker == NULL)
        goto end;

    if (tracker->id != 99)
        goto end;

    SCFree(p);

    ret = 1;
end:
    DefragDestroy();
    return ret;
}
",C,"        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);
    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);
","        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);
    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);
",,"@@ -996,8 +996,8 @@ void DefragDestroy(void)
  * with some payload of no particular protocol.
  */
 static Packet *
-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
-    int content_len)
+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     int hlen = 20;
@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
     else
         ip4h.ip_off = htons(off);
     ip4h.ip_ttl = ttl;
-    ip4h.ip_proto = IPPROTO_ICMP;
+    ip4h.ip_proto = proto;
 
     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */
     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */
@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
         goto error;
     if (IPV4_GET_IPTTL(p) != ttl)
         goto error;
-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)
+    if (IPV4_GET_IPPROTO(p) != proto)
         goto error;
 
     return p;
@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,
                           uint16_t prev_hdrextlen);
 
 static Packet *
-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
-    int content_len)
+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     uint8_t *pcontent;
@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
     IPV6_SET_RAW_VER(p->ip6h, 6);
     /* Fragmentation header. */
     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));
-    fh->ip6fh_nxt = IPPROTO_ICMP;
+    fh->ip6fh_nxt = proto;
     fh->ip6fh_ident = htonl(id);
     fh->ip6fh_offlg = htons((off << 3) | mf);
 
@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)
     if (dc == NULL)
         goto end;
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)
 
     /* Load in 16 packets. */
     for (i = 0; i < 16; i++) {
-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);
+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);
         if (p == NULL)
             goto end;
 
@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)
 
     /* Build a new packet but push the timestamp out by our timeout.
      * This should force our previous fragments to be timed out. */
-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);
+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);
     if (p == NULL)
         goto end;
 
@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)
         goto end;
 
     /* This packet has an offset > 0, more frags set to 0 and no data. */
-    p = BuildTestPacket(id, 1, 0, 'A', 0);
+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);
     if (p == NULL)
         goto end;
 
@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)
 
     /* Create a fragment that would extend past the max allowable size
      * for an IPv4 packet. */
-    p = BuildTestPacket(1, 8183, 0, 'A', 71);
+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);
     if (p == NULL)
         goto end;
 
@@ -2267,10 +2267,10 @@ DefragVlanTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)
 
     /* Build a packet, its not a fragment but shouldn't matter for
      * this test. */
-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);
     if (p1 == NULL) {
         goto end;
     }
@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)
 
     DefragInit();
 
-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)
 
     DefragInit();
 
-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)
     return retval;
 }
 
+/**
+ * \brief Test that fragments that match other than the proto don't
+ * actually get matched.
+ */
+static int DefragTestBadProto(void)
+{
+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
+    int id = 12;
+
+    DefragInit();
+
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
+    FAIL_IF_NULL(p1);
+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);
+    FAIL_IF_NULL(p2);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
+    FAIL_IF_NULL(p3);
+
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));
+
+    if (p1 != NULL)
+        SCFree(p1);
+    if (p2 != NULL)
+        SCFree(p2);
+    if (p3 != NULL)
+        SCFree(p3);
+
+    DefragDestroy();
+    PASS;
+}
+
 #endif /* UNITTESTS */
 
 void
@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)
     UtRegisterTest(""DefragTimeoutTest"", DefragTimeoutTest);
     UtRegisterTest(""DefragMfIpv4Test"", DefragMfIpv4Test);
     UtRegisterTest(""DefragMfIpv6Test"", DefragMfIpv6Test);
+    UtRegisterTest(""DefragTestBadProto"", DefragTestBadProto);
 #endif /* UNITTESTS */
 }
 ",suricata,4a04f814b15762eb446a5ead4d69d021512df6f8,292baf0872abfebf2762e08e613565703595db6c,1,"DefragTimeoutTest(void)
{
    int i;
    int ret = 0;

    /* Setup a small numberr of trackers. */
    if (ConfSet(""defrag.trackers"", ""16"") != 1) {
        printf(""ConfSet failed: "");
        goto end;
    }

    DefragInit();
 
     /* Load in 16 packets. */
     for (i = 0; i < 16; i++) {
//flaw_line_below:
        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);
//fix_flaw_line_below:
//        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);
         if (p == NULL)
             goto end;
 
        Packet *tp = Defrag(NULL, NULL, p, NULL);

        SCFree(p);

        if (tp != NULL) {
            SCFree(tp);
            goto end;
        }
    }
 
     /* Build a new packet but push the timestamp out by our timeout.
      * This should force our previous fragments to be timed out. */
//flaw_line_below:
    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);
//fix_flaw_line_below:
//    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);
     if (p == NULL)
         goto end;
 
    p->ts.tv_sec += (defrag_context->timeout + 1);
    Packet *tp = Defrag(NULL, NULL, p, NULL);

    if (tp != NULL) {
        SCFree(tp);
        goto end;
    }

    DefragTracker *tracker = DefragLookupTrackerFromHash(p);
    if (tracker == NULL)
        goto end;

    if (tracker->id != 99)
        goto end;

    SCFree(p);

    ret = 1;
end:
    DefragDestroy();
    return ret;
}
"
3740,181476,,Remote,Not required,,CVE-2017-7177,https://www.cvedetails.com/cve/CVE-2017-7177/,CWE-358,Low,,Partial,,2017-03-18,5.0,Suricata before 3.2.1 has an IPv4 defragmentation evasion issue caused by lack of a check for the IP protocol during fragment matching.,2018-12-05,,1,https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8,4a04f814b15762eb446a5ead4d69d021512df6f8,"defrag - take protocol into account during re-assembly

The IP protocol was not being used to match fragments with
their packets allowing a carefully constructed packet
with a different protocol to be matched, allowing re-assembly
to complete, creating a packet that would not be re-assembled
by the destination host.",1,src/defrag.c,"{""sha"": ""736099c58761058109931134cb06744878843604"", ""filename"": ""src/defrag-hash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag-hash.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -92,6 +92,7 @@ static void DefragTrackerInit(DefragTracker *dt, Packet *p)\n         dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);\n         dt->af = AF_INET6;\n     }\n+    dt->proto = IP_GET_IPPROTO(p);\n     dt->vlan_id[0] = p->vlan_id[0];\n     dt->vlan_id[1] = p->vlan_id[1];\n     dt->policy = DefragGetOsPolicy(p);\n@@ -406,6 +407,7 @@ static inline uint32_t DefragHashGetKey(Packet *p)\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->dst)) || \\\n       (CMP_ADDR(&(d1)->src_addr, &(d2)->dst) && \\\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->src))) && \\\n+     (d1)->proto == IP_GET_IPPROTO(p) &&        \\\n      (d1)->id == (id) && \\\n      (d1)->vlan_id[0] == (d2)->vlan_id[0] && \\\n      (d1)->vlan_id[1] == (d2)->vlan_id[1])""}<_**next**_>{""sha"": ""5433ce78607c5e694686de0fd2d93edec264b1bd"", ""filename"": ""src/defrag.c"", ""status"": ""modified"", ""additions"": 102, ""deletions"": 68, ""changes"": 170, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -996,8 +996,8 @@ void DefragDestroy(void)\n  * with some payload of no particular protocol.\n  */\n static Packet *\n-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     int hlen = 20;\n@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n     else\n         ip4h.ip_off = htons(off);\n     ip4h.ip_ttl = ttl;\n-    ip4h.ip_proto = IPPROTO_ICMP;\n+    ip4h.ip_proto = proto;\n \n     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */\n     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */\n@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n         goto error;\n     if (IPV4_GET_IPTTL(p) != ttl)\n         goto error;\n-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)\n+    if (IPV4_GET_IPPROTO(p) != proto)\n         goto error;\n \n     return p;\n@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,\n                           uint16_t prev_hdrextlen);\n \n static Packet *\n-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     uint8_t *pcontent;\n@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n     IPV6_SET_RAW_VER(p->ip6h, 6);\n     /* Fragmentation header. */\n     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));\n-    fh->ip6fh_nxt = IPPROTO_ICMP;\n+    fh->ip6fh_nxt = proto;\n     fh->ip6fh_ident = htonl(id);\n     fh->ip6fh_offlg = htons((off << 3) | mf);\n \n@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)\n     if (dc == NULL)\n         goto end;\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)\n \n     /* Load in 16 packets. */\n     for (i = 0; i < 16; i++) {\n-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);\n+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);\n         if (p == NULL)\n             goto end;\n \n@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)\n \n     /* Build a new packet but push the timestamp out by our timeout.\n      * This should force our previous fragments to be timed out. */\n-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);\n+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);\n     if (p == NULL)\n         goto end;\n \n@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)\n         goto end;\n \n     /* This packet has an offset > 0, more frags set to 0 and no data. */\n-    p = BuildTestPacket(id, 1, 0, 'A', 0);\n+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);\n     if (p == NULL)\n         goto end;\n \n@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)\n \n     /* Create a fragment that would extend past the max allowable size\n      * for an IPv4 packet. */\n-    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);\n     if (p == NULL)\n         goto end;\n \n@@ -2267,10 +2267,10 @@ DefragVlanTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)\n \n     /* Build a packet, its not a fragment but shouldn't matter for\n      * this test. */\n-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);\n     if (p1 == NULL) {\n         goto end;\n     }\n@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)\n     return retval;\n }\n \n+/**\n+ * \\brief Test that fragments that match other than the proto don't\n+ * actually get matched.\n+ */\n+static int DefragTestBadProto(void)\n+{\n+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n+    int id = 12;\n+\n+    DefragInit();\n+\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n+    FAIL_IF_NULL(p1);\n+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);\n+    FAIL_IF_NULL(p2);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n+    FAIL_IF_NULL(p3);\n+\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));\n+\n+    if (p1 != NULL)\n+        SCFree(p1);\n+    if (p2 != NULL)\n+        SCFree(p2);\n+    if (p3 != NULL)\n+        SCFree(p3);\n+\n+    DefragDestroy();\n+    PASS;\n+}\n+\n #endif /* UNITTESTS */\n \n void\n@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)\n     UtRegisterTest(\""DefragTimeoutTest\"", DefragTimeoutTest);\n     UtRegisterTest(\""DefragMfIpv4Test\"", DefragMfIpv4Test);\n     UtRegisterTest(\""DefragMfIpv6Test\"", DefragMfIpv6Test);\n+    UtRegisterTest(\""DefragTestBadProto\"", DefragTestBadProto);\n #endif /* UNITTESTS */\n }\n ""}<_**next**_>{""sha"": ""c3a0c693733a4199ce3ae7d37066e6c549edfcbd"", ""filename"": ""src/defrag.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.h?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -84,6 +84,8 @@ typedef struct DefragTracker_ {\n     uint32_t id; /**< IP ID for this tracker.  32 bits for IPv6, 16\n                   * for IPv4. */\n \n+    uint8_t proto; /**< IP protocol for this tracker. */\n+\n     uint8_t policy; /**< Reassembly policy this tracker will use. */\n \n     uint8_t af; /**< Address family for this tracker, AF_INET or""}","static int DefragTrackerReuseTest(void)
{
    int ret = 0;
    int id = 1;
    Packet *p1 = NULL;
    DefragTracker *tracker1 = NULL, *tracker2 = NULL;

    DefragInit();
 
     /* Build a packet, its not a fragment but shouldn't matter for
      * this test. */
    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);
     if (p1 == NULL) {
         goto end;
     }

    /* Get a tracker. It shouldn't look like its already in use. */
    tracker1 = DefragGetTracker(NULL, NULL, p1);
    if (tracker1 == NULL) {
        goto end;
    }
    if (tracker1->seen_last) {
        goto end;
    }
    if (tracker1->remove) {
        goto end;
    }
    DefragTrackerRelease(tracker1);

    /* Get a tracker again, it should be the same one. */
    tracker2 = DefragGetTracker(NULL, NULL, p1);
    if (tracker2 == NULL) {
        goto end;
    }
    if (tracker2 != tracker1) {
        goto end;
    }
    DefragTrackerRelease(tracker1);

    /* Now mark the tracker for removal. It should not be returned
     * when we get a tracker for a packet that may have the same
     * attributes. */
    tracker1->remove = 1;

    tracker2 = DefragGetTracker(NULL, NULL, p1);
    if (tracker2 == NULL) {
        goto end;
    }
    if (tracker2 == tracker1) {
        goto end;
    }
    if (tracker2->remove) {
        goto end;
    }

    ret = 1;
end:
    if (p1 != NULL) {
        SCFree(p1);
    }
    DefragDestroy();
    return ret;
}
","static int DefragTrackerReuseTest(void)
{
    int ret = 0;
    int id = 1;
    Packet *p1 = NULL;
    DefragTracker *tracker1 = NULL, *tracker2 = NULL;

    DefragInit();
 
     /* Build a packet, its not a fragment but shouldn't matter for
      * this test. */
    p1 = BuildTestPacket(id, 0, 0, 'A', 8);
     if (p1 == NULL) {
         goto end;
     }

    /* Get a tracker. It shouldn't look like its already in use. */
    tracker1 = DefragGetTracker(NULL, NULL, p1);
    if (tracker1 == NULL) {
        goto end;
    }
    if (tracker1->seen_last) {
        goto end;
    }
    if (tracker1->remove) {
        goto end;
    }
    DefragTrackerRelease(tracker1);

    /* Get a tracker again, it should be the same one. */
    tracker2 = DefragGetTracker(NULL, NULL, p1);
    if (tracker2 == NULL) {
        goto end;
    }
    if (tracker2 != tracker1) {
        goto end;
    }
    DefragTrackerRelease(tracker1);

    /* Now mark the tracker for removal. It should not be returned
     * when we get a tracker for a packet that may have the same
     * attributes. */
    tracker1->remove = 1;

    tracker2 = DefragGetTracker(NULL, NULL, p1);
    if (tracker2 == NULL) {
        goto end;
    }
    if (tracker2 == tracker1) {
        goto end;
    }
    if (tracker2->remove) {
        goto end;
    }

    ret = 1;
end:
    if (p1 != NULL) {
        SCFree(p1);
    }
    DefragDestroy();
    return ret;
}
",C,"    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);
","    p1 = BuildTestPacket(id, 0, 0, 'A', 8);
",,"@@ -996,8 +996,8 @@ void DefragDestroy(void)
  * with some payload of no particular protocol.
  */
 static Packet *
-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
-    int content_len)
+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     int hlen = 20;
@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
     else
         ip4h.ip_off = htons(off);
     ip4h.ip_ttl = ttl;
-    ip4h.ip_proto = IPPROTO_ICMP;
+    ip4h.ip_proto = proto;
 
     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */
     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */
@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
         goto error;
     if (IPV4_GET_IPTTL(p) != ttl)
         goto error;
-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)
+    if (IPV4_GET_IPPROTO(p) != proto)
         goto error;
 
     return p;
@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,
                           uint16_t prev_hdrextlen);
 
 static Packet *
-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
-    int content_len)
+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     uint8_t *pcontent;
@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
     IPV6_SET_RAW_VER(p->ip6h, 6);
     /* Fragmentation header. */
     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));
-    fh->ip6fh_nxt = IPPROTO_ICMP;
+    fh->ip6fh_nxt = proto;
     fh->ip6fh_ident = htonl(id);
     fh->ip6fh_offlg = htons((off << 3) | mf);
 
@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)
     if (dc == NULL)
         goto end;
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)
 
     /* Load in 16 packets. */
     for (i = 0; i < 16; i++) {
-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);
+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);
         if (p == NULL)
             goto end;
 
@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)
 
     /* Build a new packet but push the timestamp out by our timeout.
      * This should force our previous fragments to be timed out. */
-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);
+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);
     if (p == NULL)
         goto end;
 
@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)
         goto end;
 
     /* This packet has an offset > 0, more frags set to 0 and no data. */
-    p = BuildTestPacket(id, 1, 0, 'A', 0);
+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);
     if (p == NULL)
         goto end;
 
@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)
 
     /* Create a fragment that would extend past the max allowable size
      * for an IPv4 packet. */
-    p = BuildTestPacket(1, 8183, 0, 'A', 71);
+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);
     if (p == NULL)
         goto end;
 
@@ -2267,10 +2267,10 @@ DefragVlanTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)
 
     /* Build a packet, its not a fragment but shouldn't matter for
      * this test. */
-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);
     if (p1 == NULL) {
         goto end;
     }
@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)
 
     DefragInit();
 
-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)
 
     DefragInit();
 
-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)
     return retval;
 }
 
+/**
+ * \brief Test that fragments that match other than the proto don't
+ * actually get matched.
+ */
+static int DefragTestBadProto(void)
+{
+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
+    int id = 12;
+
+    DefragInit();
+
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
+    FAIL_IF_NULL(p1);
+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);
+    FAIL_IF_NULL(p2);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
+    FAIL_IF_NULL(p3);
+
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));
+
+    if (p1 != NULL)
+        SCFree(p1);
+    if (p2 != NULL)
+        SCFree(p2);
+    if (p3 != NULL)
+        SCFree(p3);
+
+    DefragDestroy();
+    PASS;
+}
+
 #endif /* UNITTESTS */
 
 void
@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)
     UtRegisterTest(""DefragTimeoutTest"", DefragTimeoutTest);
     UtRegisterTest(""DefragMfIpv4Test"", DefragMfIpv4Test);
     UtRegisterTest(""DefragMfIpv6Test"", DefragMfIpv6Test);
+    UtRegisterTest(""DefragTestBadProto"", DefragTestBadProto);
 #endif /* UNITTESTS */
 }
 ",suricata,4a04f814b15762eb446a5ead4d69d021512df6f8,292baf0872abfebf2762e08e613565703595db6c,1,"static int DefragTrackerReuseTest(void)
{
    int ret = 0;
    int id = 1;
    Packet *p1 = NULL;
    DefragTracker *tracker1 = NULL, *tracker2 = NULL;

    DefragInit();
 
     /* Build a packet, its not a fragment but shouldn't matter for
      * this test. */
//flaw_line_below:
    p1 = BuildTestPacket(id, 0, 0, 'A', 8);
//fix_flaw_line_below:
//    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);
     if (p1 == NULL) {
         goto end;
     }

    /* Get a tracker. It shouldn't look like its already in use. */
    tracker1 = DefragGetTracker(NULL, NULL, p1);
    if (tracker1 == NULL) {
        goto end;
    }
    if (tracker1->seen_last) {
        goto end;
    }
    if (tracker1->remove) {
        goto end;
    }
    DefragTrackerRelease(tracker1);

    /* Get a tracker again, it should be the same one. */
    tracker2 = DefragGetTracker(NULL, NULL, p1);
    if (tracker2 == NULL) {
        goto end;
    }
    if (tracker2 != tracker1) {
        goto end;
    }
    DefragTrackerRelease(tracker1);

    /* Now mark the tracker for removal. It should not be returned
     * when we get a tracker for a packet that may have the same
     * attributes. */
    tracker1->remove = 1;

    tracker2 = DefragGetTracker(NULL, NULL, p1);
    if (tracker2 == NULL) {
        goto end;
    }
    if (tracker2 == tracker1) {
        goto end;
    }
    if (tracker2->remove) {
        goto end;
    }

    ret = 1;
end:
    if (p1 != NULL) {
        SCFree(p1);
    }
    DefragDestroy();
    return ret;
}
"
3741,181477,,Remote,Not required,,CVE-2017-7177,https://www.cvedetails.com/cve/CVE-2017-7177/,CWE-358,Low,,Partial,,2017-03-18,5.0,Suricata before 3.2.1 has an IPv4 defragmentation evasion issue caused by lack of a check for the IP protocol during fragment matching.,2018-12-05,,2,https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8,4a04f814b15762eb446a5ead4d69d021512df6f8,"defrag - take protocol into account during re-assembly

The IP protocol was not being used to match fragments with
their packets allowing a carefully constructed packet
with a different protocol to be matched, allowing re-assembly
to complete, creating a packet that would not be re-assembled
by the destination host.",2,src/defrag.c,"{""sha"": ""736099c58761058109931134cb06744878843604"", ""filename"": ""src/defrag-hash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag-hash.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -92,6 +92,7 @@ static void DefragTrackerInit(DefragTracker *dt, Packet *p)\n         dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);\n         dt->af = AF_INET6;\n     }\n+    dt->proto = IP_GET_IPPROTO(p);\n     dt->vlan_id[0] = p->vlan_id[0];\n     dt->vlan_id[1] = p->vlan_id[1];\n     dt->policy = DefragGetOsPolicy(p);\n@@ -406,6 +407,7 @@ static inline uint32_t DefragHashGetKey(Packet *p)\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->dst)) || \\\n       (CMP_ADDR(&(d1)->src_addr, &(d2)->dst) && \\\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->src))) && \\\n+     (d1)->proto == IP_GET_IPPROTO(p) &&        \\\n      (d1)->id == (id) && \\\n      (d1)->vlan_id[0] == (d2)->vlan_id[0] && \\\n      (d1)->vlan_id[1] == (d2)->vlan_id[1])""}<_**next**_>{""sha"": ""5433ce78607c5e694686de0fd2d93edec264b1bd"", ""filename"": ""src/defrag.c"", ""status"": ""modified"", ""additions"": 102, ""deletions"": 68, ""changes"": 170, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -996,8 +996,8 @@ void DefragDestroy(void)\n  * with some payload of no particular protocol.\n  */\n static Packet *\n-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     int hlen = 20;\n@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n     else\n         ip4h.ip_off = htons(off);\n     ip4h.ip_ttl = ttl;\n-    ip4h.ip_proto = IPPROTO_ICMP;\n+    ip4h.ip_proto = proto;\n \n     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */\n     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */\n@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n         goto error;\n     if (IPV4_GET_IPTTL(p) != ttl)\n         goto error;\n-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)\n+    if (IPV4_GET_IPPROTO(p) != proto)\n         goto error;\n \n     return p;\n@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,\n                           uint16_t prev_hdrextlen);\n \n static Packet *\n-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     uint8_t *pcontent;\n@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n     IPV6_SET_RAW_VER(p->ip6h, 6);\n     /* Fragmentation header. */\n     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));\n-    fh->ip6fh_nxt = IPPROTO_ICMP;\n+    fh->ip6fh_nxt = proto;\n     fh->ip6fh_ident = htonl(id);\n     fh->ip6fh_offlg = htons((off << 3) | mf);\n \n@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)\n     if (dc == NULL)\n         goto end;\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)\n \n     /* Load in 16 packets. */\n     for (i = 0; i < 16; i++) {\n-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);\n+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);\n         if (p == NULL)\n             goto end;\n \n@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)\n \n     /* Build a new packet but push the timestamp out by our timeout.\n      * This should force our previous fragments to be timed out. */\n-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);\n+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);\n     if (p == NULL)\n         goto end;\n \n@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)\n         goto end;\n \n     /* This packet has an offset > 0, more frags set to 0 and no data. */\n-    p = BuildTestPacket(id, 1, 0, 'A', 0);\n+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);\n     if (p == NULL)\n         goto end;\n \n@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)\n \n     /* Create a fragment that would extend past the max allowable size\n      * for an IPv4 packet. */\n-    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);\n     if (p == NULL)\n         goto end;\n \n@@ -2267,10 +2267,10 @@ DefragVlanTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)\n \n     /* Build a packet, its not a fragment but shouldn't matter for\n      * this test. */\n-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);\n     if (p1 == NULL) {\n         goto end;\n     }\n@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)\n     return retval;\n }\n \n+/**\n+ * \\brief Test that fragments that match other than the proto don't\n+ * actually get matched.\n+ */\n+static int DefragTestBadProto(void)\n+{\n+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n+    int id = 12;\n+\n+    DefragInit();\n+\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n+    FAIL_IF_NULL(p1);\n+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);\n+    FAIL_IF_NULL(p2);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n+    FAIL_IF_NULL(p3);\n+\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));\n+\n+    if (p1 != NULL)\n+        SCFree(p1);\n+    if (p2 != NULL)\n+        SCFree(p2);\n+    if (p3 != NULL)\n+        SCFree(p3);\n+\n+    DefragDestroy();\n+    PASS;\n+}\n+\n #endif /* UNITTESTS */\n \n void\n@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)\n     UtRegisterTest(\""DefragTimeoutTest\"", DefragTimeoutTest);\n     UtRegisterTest(\""DefragMfIpv4Test\"", DefragMfIpv4Test);\n     UtRegisterTest(\""DefragMfIpv6Test\"", DefragMfIpv6Test);\n+    UtRegisterTest(\""DefragTestBadProto\"", DefragTestBadProto);\n #endif /* UNITTESTS */\n }\n ""}<_**next**_>{""sha"": ""c3a0c693733a4199ce3ae7d37066e6c549edfcbd"", ""filename"": ""src/defrag.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.h?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -84,6 +84,8 @@ typedef struct DefragTracker_ {\n     uint32_t id; /**< IP ID for this tracker.  32 bits for IPv6, 16\n                   * for IPv4. */\n \n+    uint8_t proto; /**< IP protocol for this tracker. */\n+\n     uint8_t policy; /**< Reassembly policy this tracker will use. */\n \n     uint8_t af; /**< Address family for this tracker, AF_INET or""}","DefragVlanQinQTest(void)
{
    Packet *p1 = NULL, *p2 = NULL, *r = NULL;
    int ret = 0;
 
     DefragInit();
 
    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
    /* With no VLAN IDs set, packets should re-assemble. */
    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)
        goto end;
    if ((r = Defrag(NULL, NULL, p2, NULL)) == NULL)
        goto end;
    SCFree(r);

    /* With mismatched VLANs, packets should not re-assemble. */
    p1->vlan_id[0] = 1;
    p2->vlan_id[0] = 1;
    p1->vlan_id[1] = 1;
    p2->vlan_id[1] = 2;
    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)
        goto end;
    if ((r = Defrag(NULL, NULL, p2, NULL)) != NULL)
        goto end;

    /* Pass. */
    ret = 1;

end:
    if (p1 != NULL)
        SCFree(p1);
    if (p2 != NULL)
        SCFree(p2);
    DefragDestroy();

    return ret;
}
","DefragVlanQinQTest(void)
{
    Packet *p1 = NULL, *p2 = NULL, *r = NULL;
    int ret = 0;
 
     DefragInit();
 
    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
    /* With no VLAN IDs set, packets should re-assemble. */
    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)
        goto end;
    if ((r = Defrag(NULL, NULL, p2, NULL)) == NULL)
        goto end;
    SCFree(r);

    /* With mismatched VLANs, packets should not re-assemble. */
    p1->vlan_id[0] = 1;
    p2->vlan_id[0] = 1;
    p1->vlan_id[1] = 1;
    p2->vlan_id[1] = 2;
    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)
        goto end;
    if ((r = Defrag(NULL, NULL, p2, NULL)) != NULL)
        goto end;

    /* Pass. */
    ret = 1;

end:
    if (p1 != NULL)
        SCFree(p1);
    if (p2 != NULL)
        SCFree(p2);
    DefragDestroy();

    return ret;
}
",C,"    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
","    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
",,"@@ -996,8 +996,8 @@ void DefragDestroy(void)
  * with some payload of no particular protocol.
  */
 static Packet *
-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
-    int content_len)
+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     int hlen = 20;
@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
     else
         ip4h.ip_off = htons(off);
     ip4h.ip_ttl = ttl;
-    ip4h.ip_proto = IPPROTO_ICMP;
+    ip4h.ip_proto = proto;
 
     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */
     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */
@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
         goto error;
     if (IPV4_GET_IPTTL(p) != ttl)
         goto error;
-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)
+    if (IPV4_GET_IPPROTO(p) != proto)
         goto error;
 
     return p;
@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,
                           uint16_t prev_hdrextlen);
 
 static Packet *
-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
-    int content_len)
+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     uint8_t *pcontent;
@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
     IPV6_SET_RAW_VER(p->ip6h, 6);
     /* Fragmentation header. */
     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));
-    fh->ip6fh_nxt = IPPROTO_ICMP;
+    fh->ip6fh_nxt = proto;
     fh->ip6fh_ident = htonl(id);
     fh->ip6fh_offlg = htons((off << 3) | mf);
 
@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)
     if (dc == NULL)
         goto end;
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)
 
     /* Load in 16 packets. */
     for (i = 0; i < 16; i++) {
-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);
+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);
         if (p == NULL)
             goto end;
 
@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)
 
     /* Build a new packet but push the timestamp out by our timeout.
      * This should force our previous fragments to be timed out. */
-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);
+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);
     if (p == NULL)
         goto end;
 
@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)
         goto end;
 
     /* This packet has an offset > 0, more frags set to 0 and no data. */
-    p = BuildTestPacket(id, 1, 0, 'A', 0);
+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);
     if (p == NULL)
         goto end;
 
@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)
 
     /* Create a fragment that would extend past the max allowable size
      * for an IPv4 packet. */
-    p = BuildTestPacket(1, 8183, 0, 'A', 71);
+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);
     if (p == NULL)
         goto end;
 
@@ -2267,10 +2267,10 @@ DefragVlanTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)
 
     /* Build a packet, its not a fragment but shouldn't matter for
      * this test. */
-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);
     if (p1 == NULL) {
         goto end;
     }
@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)
 
     DefragInit();
 
-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)
 
     DefragInit();
 
-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)
     return retval;
 }
 
+/**
+ * \brief Test that fragments that match other than the proto don't
+ * actually get matched.
+ */
+static int DefragTestBadProto(void)
+{
+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
+    int id = 12;
+
+    DefragInit();
+
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
+    FAIL_IF_NULL(p1);
+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);
+    FAIL_IF_NULL(p2);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
+    FAIL_IF_NULL(p3);
+
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));
+
+    if (p1 != NULL)
+        SCFree(p1);
+    if (p2 != NULL)
+        SCFree(p2);
+    if (p3 != NULL)
+        SCFree(p3);
+
+    DefragDestroy();
+    PASS;
+}
+
 #endif /* UNITTESTS */
 
 void
@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)
     UtRegisterTest(""DefragTimeoutTest"", DefragTimeoutTest);
     UtRegisterTest(""DefragMfIpv4Test"", DefragMfIpv4Test);
     UtRegisterTest(""DefragMfIpv6Test"", DefragMfIpv6Test);
+    UtRegisterTest(""DefragTestBadProto"", DefragTestBadProto);
 #endif /* UNITTESTS */
 }
 ",suricata,4a04f814b15762eb446a5ead4d69d021512df6f8,292baf0872abfebf2762e08e613565703595db6c,1,"DefragVlanQinQTest(void)
{
    Packet *p1 = NULL, *p2 = NULL, *r = NULL;
    int ret = 0;
 
     DefragInit();
 
//flaw_line_below:
    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
//fix_flaw_line_below:
//    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
//flaw_line_below:
    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
//fix_flaw_line_below:
//    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
    /* With no VLAN IDs set, packets should re-assemble. */
    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)
        goto end;
    if ((r = Defrag(NULL, NULL, p2, NULL)) == NULL)
        goto end;
    SCFree(r);

    /* With mismatched VLANs, packets should not re-assemble. */
    p1->vlan_id[0] = 1;
    p2->vlan_id[0] = 1;
    p1->vlan_id[1] = 1;
    p2->vlan_id[1] = 2;
    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)
        goto end;
    if ((r = Defrag(NULL, NULL, p2, NULL)) != NULL)
        goto end;

    /* Pass. */
    ret = 1;

end:
    if (p1 != NULL)
        SCFree(p1);
    if (p2 != NULL)
        SCFree(p2);
    DefragDestroy();

    return ret;
}
"
3742,181478,,Remote,Not required,,CVE-2017-7177,https://www.cvedetails.com/cve/CVE-2017-7177/,CWE-358,Low,,Partial,,2017-03-18,5.0,Suricata before 3.2.1 has an IPv4 defragmentation evasion issue caused by lack of a check for the IP protocol during fragment matching.,2018-12-05,,2,https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8,4a04f814b15762eb446a5ead4d69d021512df6f8,"defrag - take protocol into account during re-assembly

The IP protocol was not being used to match fragments with
their packets allowing a carefully constructed packet
with a different protocol to be matched, allowing re-assembly
to complete, creating a packet that would not be re-assembled
by the destination host.",2,src/defrag.c,"{""sha"": ""736099c58761058109931134cb06744878843604"", ""filename"": ""src/defrag-hash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag-hash.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -92,6 +92,7 @@ static void DefragTrackerInit(DefragTracker *dt, Packet *p)\n         dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);\n         dt->af = AF_INET6;\n     }\n+    dt->proto = IP_GET_IPPROTO(p);\n     dt->vlan_id[0] = p->vlan_id[0];\n     dt->vlan_id[1] = p->vlan_id[1];\n     dt->policy = DefragGetOsPolicy(p);\n@@ -406,6 +407,7 @@ static inline uint32_t DefragHashGetKey(Packet *p)\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->dst)) || \\\n       (CMP_ADDR(&(d1)->src_addr, &(d2)->dst) && \\\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->src))) && \\\n+     (d1)->proto == IP_GET_IPPROTO(p) &&        \\\n      (d1)->id == (id) && \\\n      (d1)->vlan_id[0] == (d2)->vlan_id[0] && \\\n      (d1)->vlan_id[1] == (d2)->vlan_id[1])""}<_**next**_>{""sha"": ""5433ce78607c5e694686de0fd2d93edec264b1bd"", ""filename"": ""src/defrag.c"", ""status"": ""modified"", ""additions"": 102, ""deletions"": 68, ""changes"": 170, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -996,8 +996,8 @@ void DefragDestroy(void)\n  * with some payload of no particular protocol.\n  */\n static Packet *\n-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     int hlen = 20;\n@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n     else\n         ip4h.ip_off = htons(off);\n     ip4h.ip_ttl = ttl;\n-    ip4h.ip_proto = IPPROTO_ICMP;\n+    ip4h.ip_proto = proto;\n \n     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */\n     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */\n@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n         goto error;\n     if (IPV4_GET_IPTTL(p) != ttl)\n         goto error;\n-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)\n+    if (IPV4_GET_IPPROTO(p) != proto)\n         goto error;\n \n     return p;\n@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,\n                           uint16_t prev_hdrextlen);\n \n static Packet *\n-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     uint8_t *pcontent;\n@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n     IPV6_SET_RAW_VER(p->ip6h, 6);\n     /* Fragmentation header. */\n     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));\n-    fh->ip6fh_nxt = IPPROTO_ICMP;\n+    fh->ip6fh_nxt = proto;\n     fh->ip6fh_ident = htonl(id);\n     fh->ip6fh_offlg = htons((off << 3) | mf);\n \n@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)\n     if (dc == NULL)\n         goto end;\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)\n \n     /* Load in 16 packets. */\n     for (i = 0; i < 16; i++) {\n-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);\n+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);\n         if (p == NULL)\n             goto end;\n \n@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)\n \n     /* Build a new packet but push the timestamp out by our timeout.\n      * This should force our previous fragments to be timed out. */\n-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);\n+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);\n     if (p == NULL)\n         goto end;\n \n@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)\n         goto end;\n \n     /* This packet has an offset > 0, more frags set to 0 and no data. */\n-    p = BuildTestPacket(id, 1, 0, 'A', 0);\n+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);\n     if (p == NULL)\n         goto end;\n \n@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)\n \n     /* Create a fragment that would extend past the max allowable size\n      * for an IPv4 packet. */\n-    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);\n     if (p == NULL)\n         goto end;\n \n@@ -2267,10 +2267,10 @@ DefragVlanTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)\n \n     /* Build a packet, its not a fragment but shouldn't matter for\n      * this test. */\n-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);\n     if (p1 == NULL) {\n         goto end;\n     }\n@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)\n     return retval;\n }\n \n+/**\n+ * \\brief Test that fragments that match other than the proto don't\n+ * actually get matched.\n+ */\n+static int DefragTestBadProto(void)\n+{\n+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n+    int id = 12;\n+\n+    DefragInit();\n+\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n+    FAIL_IF_NULL(p1);\n+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);\n+    FAIL_IF_NULL(p2);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n+    FAIL_IF_NULL(p3);\n+\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));\n+\n+    if (p1 != NULL)\n+        SCFree(p1);\n+    if (p2 != NULL)\n+        SCFree(p2);\n+    if (p3 != NULL)\n+        SCFree(p3);\n+\n+    DefragDestroy();\n+    PASS;\n+}\n+\n #endif /* UNITTESTS */\n \n void\n@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)\n     UtRegisterTest(\""DefragTimeoutTest\"", DefragTimeoutTest);\n     UtRegisterTest(\""DefragMfIpv4Test\"", DefragMfIpv4Test);\n     UtRegisterTest(\""DefragMfIpv6Test\"", DefragMfIpv6Test);\n+    UtRegisterTest(\""DefragTestBadProto\"", DefragTestBadProto);\n #endif /* UNITTESTS */\n }\n ""}<_**next**_>{""sha"": ""c3a0c693733a4199ce3ae7d37066e6c549edfcbd"", ""filename"": ""src/defrag.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.h?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -84,6 +84,8 @@ typedef struct DefragTracker_ {\n     uint32_t id; /**< IP ID for this tracker.  32 bits for IPv6, 16\n                   * for IPv4. */\n \n+    uint8_t proto; /**< IP protocol for this tracker. */\n+\n     uint8_t policy; /**< Reassembly policy this tracker will use. */\n \n     uint8_t af; /**< Address family for this tracker, AF_INET or""}","DefragVlanTest(void)
{
    Packet *p1 = NULL, *p2 = NULL, *r = NULL;
    int ret = 0;
 
     DefragInit();
 
    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
    /* With no VLAN IDs set, packets should re-assemble. */
    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)
        goto end;
    if ((r = Defrag(NULL, NULL, p2, NULL)) == NULL)
        goto end;
    SCFree(r);

    /* With mismatched VLANs, packets should not re-assemble. */
    p1->vlan_id[0] = 1;
    p2->vlan_id[0] = 2;
    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)
        goto end;
    if ((r = Defrag(NULL, NULL, p2, NULL)) != NULL)
        goto end;

    /* Pass. */
    ret = 1;

end:
    if (p1 != NULL)
        SCFree(p1);
    if (p2 != NULL)
        SCFree(p2);
    DefragDestroy();

    return ret;
}
","DefragVlanTest(void)
{
    Packet *p1 = NULL, *p2 = NULL, *r = NULL;
    int ret = 0;
 
     DefragInit();
 
    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
    /* With no VLAN IDs set, packets should re-assemble. */
    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)
        goto end;
    if ((r = Defrag(NULL, NULL, p2, NULL)) == NULL)
        goto end;
    SCFree(r);

    /* With mismatched VLANs, packets should not re-assemble. */
    p1->vlan_id[0] = 1;
    p2->vlan_id[0] = 2;
    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)
        goto end;
    if ((r = Defrag(NULL, NULL, p2, NULL)) != NULL)
        goto end;

    /* Pass. */
    ret = 1;

end:
    if (p1 != NULL)
        SCFree(p1);
    if (p2 != NULL)
        SCFree(p2);
    DefragDestroy();

    return ret;
}
",C,"    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
","    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
",,"@@ -996,8 +996,8 @@ void DefragDestroy(void)
  * with some payload of no particular protocol.
  */
 static Packet *
-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
-    int content_len)
+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     int hlen = 20;
@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
     else
         ip4h.ip_off = htons(off);
     ip4h.ip_ttl = ttl;
-    ip4h.ip_proto = IPPROTO_ICMP;
+    ip4h.ip_proto = proto;
 
     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */
     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */
@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
         goto error;
     if (IPV4_GET_IPTTL(p) != ttl)
         goto error;
-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)
+    if (IPV4_GET_IPPROTO(p) != proto)
         goto error;
 
     return p;
@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,
                           uint16_t prev_hdrextlen);
 
 static Packet *
-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
-    int content_len)
+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     uint8_t *pcontent;
@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
     IPV6_SET_RAW_VER(p->ip6h, 6);
     /* Fragmentation header. */
     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));
-    fh->ip6fh_nxt = IPPROTO_ICMP;
+    fh->ip6fh_nxt = proto;
     fh->ip6fh_ident = htonl(id);
     fh->ip6fh_offlg = htons((off << 3) | mf);
 
@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)
     if (dc == NULL)
         goto end;
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)
 
     /* Load in 16 packets. */
     for (i = 0; i < 16; i++) {
-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);
+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);
         if (p == NULL)
             goto end;
 
@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)
 
     /* Build a new packet but push the timestamp out by our timeout.
      * This should force our previous fragments to be timed out. */
-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);
+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);
     if (p == NULL)
         goto end;
 
@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)
         goto end;
 
     /* This packet has an offset > 0, more frags set to 0 and no data. */
-    p = BuildTestPacket(id, 1, 0, 'A', 0);
+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);
     if (p == NULL)
         goto end;
 
@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)
 
     /* Create a fragment that would extend past the max allowable size
      * for an IPv4 packet. */
-    p = BuildTestPacket(1, 8183, 0, 'A', 71);
+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);
     if (p == NULL)
         goto end;
 
@@ -2267,10 +2267,10 @@ DefragVlanTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)
 
     /* Build a packet, its not a fragment but shouldn't matter for
      * this test. */
-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);
     if (p1 == NULL) {
         goto end;
     }
@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)
 
     DefragInit();
 
-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)
 
     DefragInit();
 
-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)
     return retval;
 }
 
+/**
+ * \brief Test that fragments that match other than the proto don't
+ * actually get matched.
+ */
+static int DefragTestBadProto(void)
+{
+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
+    int id = 12;
+
+    DefragInit();
+
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
+    FAIL_IF_NULL(p1);
+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);
+    FAIL_IF_NULL(p2);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
+    FAIL_IF_NULL(p3);
+
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));
+
+    if (p1 != NULL)
+        SCFree(p1);
+    if (p2 != NULL)
+        SCFree(p2);
+    if (p3 != NULL)
+        SCFree(p3);
+
+    DefragDestroy();
+    PASS;
+}
+
 #endif /* UNITTESTS */
 
 void
@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)
     UtRegisterTest(""DefragTimeoutTest"", DefragTimeoutTest);
     UtRegisterTest(""DefragMfIpv4Test"", DefragMfIpv4Test);
     UtRegisterTest(""DefragMfIpv6Test"", DefragMfIpv6Test);
+    UtRegisterTest(""DefragTestBadProto"", DefragTestBadProto);
 #endif /* UNITTESTS */
 }
 ",suricata,4a04f814b15762eb446a5ead4d69d021512df6f8,292baf0872abfebf2762e08e613565703595db6c,1,"DefragVlanTest(void)
{
    Packet *p1 = NULL, *p2 = NULL, *r = NULL;
    int ret = 0;
 
     DefragInit();
 
//flaw_line_below:
    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
//fix_flaw_line_below:
//    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
//flaw_line_below:
    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
//fix_flaw_line_below:
//    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
    /* With no VLAN IDs set, packets should re-assemble. */
    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)
        goto end;
    if ((r = Defrag(NULL, NULL, p2, NULL)) == NULL)
        goto end;
    SCFree(r);

    /* With mismatched VLANs, packets should not re-assemble. */
    p1->vlan_id[0] = 1;
    p2->vlan_id[0] = 2;
    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)
        goto end;
    if ((r = Defrag(NULL, NULL, p2, NULL)) != NULL)
        goto end;

    /* Pass. */
    ret = 1;

end:
    if (p1 != NULL)
        SCFree(p1);
    if (p2 != NULL)
        SCFree(p2);
    DefragDestroy();

    return ret;
}
"
3743,181479,,Remote,Not required,,CVE-2017-7177,https://www.cvedetails.com/cve/CVE-2017-7177/,CWE-358,Low,,Partial,,2017-03-18,5.0,Suricata before 3.2.1 has an IPv4 defragmentation evasion issue caused by lack of a check for the IP protocol during fragment matching.,2018-12-05,,3,https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8,4a04f814b15762eb446a5ead4d69d021512df6f8,"defrag - take protocol into account during re-assembly

The IP protocol was not being used to match fragments with
their packets allowing a carefully constructed packet
with a different protocol to be matched, allowing re-assembly
to complete, creating a packet that would not be re-assembled
by the destination host.",2,src/defrag.c,"{""sha"": ""736099c58761058109931134cb06744878843604"", ""filename"": ""src/defrag-hash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag-hash.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -92,6 +92,7 @@ static void DefragTrackerInit(DefragTracker *dt, Packet *p)\n         dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);\n         dt->af = AF_INET6;\n     }\n+    dt->proto = IP_GET_IPPROTO(p);\n     dt->vlan_id[0] = p->vlan_id[0];\n     dt->vlan_id[1] = p->vlan_id[1];\n     dt->policy = DefragGetOsPolicy(p);\n@@ -406,6 +407,7 @@ static inline uint32_t DefragHashGetKey(Packet *p)\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->dst)) || \\\n       (CMP_ADDR(&(d1)->src_addr, &(d2)->dst) && \\\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->src))) && \\\n+     (d1)->proto == IP_GET_IPPROTO(p) &&        \\\n      (d1)->id == (id) && \\\n      (d1)->vlan_id[0] == (d2)->vlan_id[0] && \\\n      (d1)->vlan_id[1] == (d2)->vlan_id[1])""}<_**next**_>{""sha"": ""5433ce78607c5e694686de0fd2d93edec264b1bd"", ""filename"": ""src/defrag.c"", ""status"": ""modified"", ""additions"": 102, ""deletions"": 68, ""changes"": 170, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -996,8 +996,8 @@ void DefragDestroy(void)\n  * with some payload of no particular protocol.\n  */\n static Packet *\n-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     int hlen = 20;\n@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n     else\n         ip4h.ip_off = htons(off);\n     ip4h.ip_ttl = ttl;\n-    ip4h.ip_proto = IPPROTO_ICMP;\n+    ip4h.ip_proto = proto;\n \n     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */\n     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */\n@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n         goto error;\n     if (IPV4_GET_IPTTL(p) != ttl)\n         goto error;\n-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)\n+    if (IPV4_GET_IPPROTO(p) != proto)\n         goto error;\n \n     return p;\n@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,\n                           uint16_t prev_hdrextlen);\n \n static Packet *\n-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     uint8_t *pcontent;\n@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n     IPV6_SET_RAW_VER(p->ip6h, 6);\n     /* Fragmentation header. */\n     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));\n-    fh->ip6fh_nxt = IPPROTO_ICMP;\n+    fh->ip6fh_nxt = proto;\n     fh->ip6fh_ident = htonl(id);\n     fh->ip6fh_offlg = htons((off << 3) | mf);\n \n@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)\n     if (dc == NULL)\n         goto end;\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)\n \n     /* Load in 16 packets. */\n     for (i = 0; i < 16; i++) {\n-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);\n+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);\n         if (p == NULL)\n             goto end;\n \n@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)\n \n     /* Build a new packet but push the timestamp out by our timeout.\n      * This should force our previous fragments to be timed out. */\n-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);\n+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);\n     if (p == NULL)\n         goto end;\n \n@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)\n         goto end;\n \n     /* This packet has an offset > 0, more frags set to 0 and no data. */\n-    p = BuildTestPacket(id, 1, 0, 'A', 0);\n+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);\n     if (p == NULL)\n         goto end;\n \n@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)\n \n     /* Create a fragment that would extend past the max allowable size\n      * for an IPv4 packet. */\n-    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);\n     if (p == NULL)\n         goto end;\n \n@@ -2267,10 +2267,10 @@ DefragVlanTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)\n \n     /* Build a packet, its not a fragment but shouldn't matter for\n      * this test. */\n-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);\n     if (p1 == NULL) {\n         goto end;\n     }\n@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)\n     return retval;\n }\n \n+/**\n+ * \\brief Test that fragments that match other than the proto don't\n+ * actually get matched.\n+ */\n+static int DefragTestBadProto(void)\n+{\n+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n+    int id = 12;\n+\n+    DefragInit();\n+\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n+    FAIL_IF_NULL(p1);\n+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);\n+    FAIL_IF_NULL(p2);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n+    FAIL_IF_NULL(p3);\n+\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));\n+\n+    if (p1 != NULL)\n+        SCFree(p1);\n+    if (p2 != NULL)\n+        SCFree(p2);\n+    if (p3 != NULL)\n+        SCFree(p3);\n+\n+    DefragDestroy();\n+    PASS;\n+}\n+\n #endif /* UNITTESTS */\n \n void\n@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)\n     UtRegisterTest(\""DefragTimeoutTest\"", DefragTimeoutTest);\n     UtRegisterTest(\""DefragMfIpv4Test\"", DefragMfIpv4Test);\n     UtRegisterTest(\""DefragMfIpv6Test\"", DefragMfIpv6Test);\n+    UtRegisterTest(\""DefragTestBadProto\"", DefragTestBadProto);\n #endif /* UNITTESTS */\n }\n ""}<_**next**_>{""sha"": ""c3a0c693733a4199ce3ae7d37066e6c549edfcbd"", ""filename"": ""src/defrag.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.h?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -84,6 +84,8 @@ typedef struct DefragTracker_ {\n     uint32_t id; /**< IP ID for this tracker.  32 bits for IPv6, 16\n                   * for IPv4. */\n \n+    uint8_t proto; /**< IP protocol for this tracker. */\n+\n     uint8_t policy; /**< Reassembly policy this tracker will use. */\n \n     uint8_t af; /**< Address family for this tracker, AF_INET or""}","IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,
    const char content, int content_len)
 {
     Packet *p = NULL;
     uint8_t *pcontent;
    IPV6Hdr ip6h;

    p = SCCalloc(1, sizeof(*p) + default_packet_size);
    if (unlikely(p == NULL))
        return NULL;

    PACKET_INITIALIZE(p);

    gettimeofday(&p->ts, NULL);

    ip6h.s_ip6_nxt = 44;
    ip6h.s_ip6_hlim = 2;

    /* Source and dest address - very bogus addresses. */
    ip6h.s_ip6_src[0] = 0x01010101;
    ip6h.s_ip6_src[1] = 0x01010101;
    ip6h.s_ip6_src[2] = 0x01010101;
    ip6h.s_ip6_src[3] = 0x01010101;
    ip6h.s_ip6_dst[0] = 0x02020202;
    ip6h.s_ip6_dst[1] = 0x02020202;
    ip6h.s_ip6_dst[2] = 0x02020202;
    ip6h.s_ip6_dst[3] = 0x02020202;

    /* copy content_len crap, we need full length */
    PacketCopyData(p, (uint8_t *)&ip6h, sizeof(IPV6Hdr));

    p->ip6h = (IPV6Hdr *)GET_PKT_DATA(p);
     IPV6_SET_RAW_VER(p->ip6h, 6);
     /* Fragmentation header. */
     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));
    fh->ip6fh_nxt = proto;
     fh->ip6fh_ident = htonl(id);
     fh->ip6fh_offlg = htons((off << 3) | mf);
 
    DecodeIPV6FragHeader(p, (uint8_t *)fh, 8, 8 + content_len, 0);

    pcontent = SCCalloc(1, content_len);
    if (unlikely(pcontent == NULL))
        return NULL;
    memset(pcontent, content, content_len);
    PacketCopyDataOffset(p, sizeof(IPV6Hdr) + sizeof(IPV6FragHdr), pcontent, content_len);
    SET_PKT_LEN(p, sizeof(IPV6Hdr) + sizeof(IPV6FragHdr) + content_len);
    SCFree(pcontent);

    p->ip6h->s_ip6_plen = htons(sizeof(IPV6FragHdr) + content_len);

    SET_IPV6_SRC_ADDR(p, &p->src);
    SET_IPV6_DST_ADDR(p, &p->dst);

    /* Self test. */
    if (IPV6_GET_VER(p) != 6)
        goto error;
    if (IPV6_GET_NH(p) != 44)
        goto error;
    if (IPV6_GET_PLEN(p) != sizeof(IPV6FragHdr) + content_len)
        goto error;

    return p;
error:
    fprintf(stderr, ""Error building test packet.\n"");
    if (p != NULL)
        SCFree(p);
    return NULL;
}
","IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
    int content_len)
 {
     Packet *p = NULL;
     uint8_t *pcontent;
    IPV6Hdr ip6h;

    p = SCCalloc(1, sizeof(*p) + default_packet_size);
    if (unlikely(p == NULL))
        return NULL;

    PACKET_INITIALIZE(p);

    gettimeofday(&p->ts, NULL);

    ip6h.s_ip6_nxt = 44;
    ip6h.s_ip6_hlim = 2;

    /* Source and dest address - very bogus addresses. */
    ip6h.s_ip6_src[0] = 0x01010101;
    ip6h.s_ip6_src[1] = 0x01010101;
    ip6h.s_ip6_src[2] = 0x01010101;
    ip6h.s_ip6_src[3] = 0x01010101;
    ip6h.s_ip6_dst[0] = 0x02020202;
    ip6h.s_ip6_dst[1] = 0x02020202;
    ip6h.s_ip6_dst[2] = 0x02020202;
    ip6h.s_ip6_dst[3] = 0x02020202;

    /* copy content_len crap, we need full length */
    PacketCopyData(p, (uint8_t *)&ip6h, sizeof(IPV6Hdr));

    p->ip6h = (IPV6Hdr *)GET_PKT_DATA(p);
     IPV6_SET_RAW_VER(p->ip6h, 6);
     /* Fragmentation header. */
     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));
    fh->ip6fh_nxt = IPPROTO_ICMP;
     fh->ip6fh_ident = htonl(id);
     fh->ip6fh_offlg = htons((off << 3) | mf);
 
    DecodeIPV6FragHeader(p, (uint8_t *)fh, 8, 8 + content_len, 0);

    pcontent = SCCalloc(1, content_len);
    if (unlikely(pcontent == NULL))
        return NULL;
    memset(pcontent, content, content_len);
    PacketCopyDataOffset(p, sizeof(IPV6Hdr) + sizeof(IPV6FragHdr), pcontent, content_len);
    SET_PKT_LEN(p, sizeof(IPV6Hdr) + sizeof(IPV6FragHdr) + content_len);
    SCFree(pcontent);

    p->ip6h->s_ip6_plen = htons(sizeof(IPV6FragHdr) + content_len);

    SET_IPV6_SRC_ADDR(p, &p->src);
    SET_IPV6_DST_ADDR(p, &p->dst);

    /* Self test. */
    if (IPV6_GET_VER(p) != 6)
        goto error;
    if (IPV6_GET_NH(p) != 44)
        goto error;
    if (IPV6_GET_PLEN(p) != sizeof(IPV6FragHdr) + content_len)
        goto error;

    return p;
error:
    fprintf(stderr, ""Error building test packet.\n"");
    if (p != NULL)
        SCFree(p);
    return NULL;
}
",C,"IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,
    const char content, int content_len)
    fh->ip6fh_nxt = proto;
","    int content_len)
    fh->ip6fh_nxt = IPPROTO_ICMP;
",,"@@ -996,8 +996,8 @@ void DefragDestroy(void)
  * with some payload of no particular protocol.
  */
 static Packet *
-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
-    int content_len)
+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     int hlen = 20;
@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
     else
         ip4h.ip_off = htons(off);
     ip4h.ip_ttl = ttl;
-    ip4h.ip_proto = IPPROTO_ICMP;
+    ip4h.ip_proto = proto;
 
     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */
     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */
@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
         goto error;
     if (IPV4_GET_IPTTL(p) != ttl)
         goto error;
-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)
+    if (IPV4_GET_IPPROTO(p) != proto)
         goto error;
 
     return p;
@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,
                           uint16_t prev_hdrextlen);
 
 static Packet *
-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
-    int content_len)
+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     uint8_t *pcontent;
@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
     IPV6_SET_RAW_VER(p->ip6h, 6);
     /* Fragmentation header. */
     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));
-    fh->ip6fh_nxt = IPPROTO_ICMP;
+    fh->ip6fh_nxt = proto;
     fh->ip6fh_ident = htonl(id);
     fh->ip6fh_offlg = htons((off << 3) | mf);
 
@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)
     if (dc == NULL)
         goto end;
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)
 
     /* Load in 16 packets. */
     for (i = 0; i < 16; i++) {
-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);
+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);
         if (p == NULL)
             goto end;
 
@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)
 
     /* Build a new packet but push the timestamp out by our timeout.
      * This should force our previous fragments to be timed out. */
-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);
+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);
     if (p == NULL)
         goto end;
 
@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)
         goto end;
 
     /* This packet has an offset > 0, more frags set to 0 and no data. */
-    p = BuildTestPacket(id, 1, 0, 'A', 0);
+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);
     if (p == NULL)
         goto end;
 
@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)
 
     /* Create a fragment that would extend past the max allowable size
      * for an IPv4 packet. */
-    p = BuildTestPacket(1, 8183, 0, 'A', 71);
+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);
     if (p == NULL)
         goto end;
 
@@ -2267,10 +2267,10 @@ DefragVlanTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)
 
     /* Build a packet, its not a fragment but shouldn't matter for
      * this test. */
-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);
     if (p1 == NULL) {
         goto end;
     }
@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)
 
     DefragInit();
 
-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)
 
     DefragInit();
 
-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)
     return retval;
 }
 
+/**
+ * \brief Test that fragments that match other than the proto don't
+ * actually get matched.
+ */
+static int DefragTestBadProto(void)
+{
+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
+    int id = 12;
+
+    DefragInit();
+
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
+    FAIL_IF_NULL(p1);
+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);
+    FAIL_IF_NULL(p2);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
+    FAIL_IF_NULL(p3);
+
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));
+
+    if (p1 != NULL)
+        SCFree(p1);
+    if (p2 != NULL)
+        SCFree(p2);
+    if (p3 != NULL)
+        SCFree(p3);
+
+    DefragDestroy();
+    PASS;
+}
+
 #endif /* UNITTESTS */
 
 void
@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)
     UtRegisterTest(""DefragTimeoutTest"", DefragTimeoutTest);
     UtRegisterTest(""DefragMfIpv4Test"", DefragMfIpv4Test);
     UtRegisterTest(""DefragMfIpv6Test"", DefragMfIpv6Test);
+    UtRegisterTest(""DefragTestBadProto"", DefragTestBadProto);
 #endif /* UNITTESTS */
 }
 ",suricata,4a04f814b15762eb446a5ead4d69d021512df6f8,292baf0872abfebf2762e08e613565703595db6c,1,"IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
//flaw_line_below:
    int content_len)
//fix_flaw_line_below:
//IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,
//fix_flaw_line_below:
//    const char content, int content_len)
 {
     Packet *p = NULL;
     uint8_t *pcontent;
    IPV6Hdr ip6h;

    p = SCCalloc(1, sizeof(*p) + default_packet_size);
    if (unlikely(p == NULL))
        return NULL;

    PACKET_INITIALIZE(p);

    gettimeofday(&p->ts, NULL);

    ip6h.s_ip6_nxt = 44;
    ip6h.s_ip6_hlim = 2;

    /* Source and dest address - very bogus addresses. */
    ip6h.s_ip6_src[0] = 0x01010101;
    ip6h.s_ip6_src[1] = 0x01010101;
    ip6h.s_ip6_src[2] = 0x01010101;
    ip6h.s_ip6_src[3] = 0x01010101;
    ip6h.s_ip6_dst[0] = 0x02020202;
    ip6h.s_ip6_dst[1] = 0x02020202;
    ip6h.s_ip6_dst[2] = 0x02020202;
    ip6h.s_ip6_dst[3] = 0x02020202;

    /* copy content_len crap, we need full length */
    PacketCopyData(p, (uint8_t *)&ip6h, sizeof(IPV6Hdr));

    p->ip6h = (IPV6Hdr *)GET_PKT_DATA(p);
     IPV6_SET_RAW_VER(p->ip6h, 6);
     /* Fragmentation header. */
     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));
//flaw_line_below:
    fh->ip6fh_nxt = IPPROTO_ICMP;
//fix_flaw_line_below:
//    fh->ip6fh_nxt = proto;
     fh->ip6fh_ident = htonl(id);
     fh->ip6fh_offlg = htons((off << 3) | mf);
 
    DecodeIPV6FragHeader(p, (uint8_t *)fh, 8, 8 + content_len, 0);

    pcontent = SCCalloc(1, content_len);
    if (unlikely(pcontent == NULL))
        return NULL;
    memset(pcontent, content, content_len);
    PacketCopyDataOffset(p, sizeof(IPV6Hdr) + sizeof(IPV6FragHdr), pcontent, content_len);
    SET_PKT_LEN(p, sizeof(IPV6Hdr) + sizeof(IPV6FragHdr) + content_len);
    SCFree(pcontent);

    p->ip6h->s_ip6_plen = htons(sizeof(IPV6FragHdr) + content_len);

    SET_IPV6_SRC_ADDR(p, &p->src);
    SET_IPV6_DST_ADDR(p, &p->dst);

    /* Self test. */
    if (IPV6_GET_VER(p) != 6)
        goto error;
    if (IPV6_GET_NH(p) != 44)
        goto error;
    if (IPV6_GET_PLEN(p) != sizeof(IPV6FragHdr) + content_len)
        goto error;

    return p;
error:
    fprintf(stderr, ""Error building test packet.\n"");
    if (p != NULL)
        SCFree(p);
    return NULL;
}
"
3744,181480,,Remote,Not required,,CVE-2017-7177,https://www.cvedetails.com/cve/CVE-2017-7177/,CWE-358,Low,,Partial,,2017-03-18,5.0,Suricata before 3.2.1 has an IPv4 defragmentation evasion issue caused by lack of a check for the IP protocol during fragment matching.,2018-12-05,,17,https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8,4a04f814b15762eb446a5ead4d69d021512df6f8,"defrag - take protocol into account during re-assembly

The IP protocol was not being used to match fragments with
their packets allowing a carefully constructed packet
with a different protocol to be matched, allowing re-assembly
to complete, creating a packet that would not be re-assembled
by the destination host.",17,src/defrag.c,"{""sha"": ""736099c58761058109931134cb06744878843604"", ""filename"": ""src/defrag-hash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag-hash.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -92,6 +92,7 @@ static void DefragTrackerInit(DefragTracker *dt, Packet *p)\n         dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);\n         dt->af = AF_INET6;\n     }\n+    dt->proto = IP_GET_IPPROTO(p);\n     dt->vlan_id[0] = p->vlan_id[0];\n     dt->vlan_id[1] = p->vlan_id[1];\n     dt->policy = DefragGetOsPolicy(p);\n@@ -406,6 +407,7 @@ static inline uint32_t DefragHashGetKey(Packet *p)\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->dst)) || \\\n       (CMP_ADDR(&(d1)->src_addr, &(d2)->dst) && \\\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->src))) && \\\n+     (d1)->proto == IP_GET_IPPROTO(p) &&        \\\n      (d1)->id == (id) && \\\n      (d1)->vlan_id[0] == (d2)->vlan_id[0] && \\\n      (d1)->vlan_id[1] == (d2)->vlan_id[1])""}<_**next**_>{""sha"": ""5433ce78607c5e694686de0fd2d93edec264b1bd"", ""filename"": ""src/defrag.c"", ""status"": ""modified"", ""additions"": 102, ""deletions"": 68, ""changes"": 170, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -996,8 +996,8 @@ void DefragDestroy(void)\n  * with some payload of no particular protocol.\n  */\n static Packet *\n-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     int hlen = 20;\n@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n     else\n         ip4h.ip_off = htons(off);\n     ip4h.ip_ttl = ttl;\n-    ip4h.ip_proto = IPPROTO_ICMP;\n+    ip4h.ip_proto = proto;\n \n     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */\n     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */\n@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n         goto error;\n     if (IPV4_GET_IPTTL(p) != ttl)\n         goto error;\n-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)\n+    if (IPV4_GET_IPPROTO(p) != proto)\n         goto error;\n \n     return p;\n@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,\n                           uint16_t prev_hdrextlen);\n \n static Packet *\n-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     uint8_t *pcontent;\n@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n     IPV6_SET_RAW_VER(p->ip6h, 6);\n     /* Fragmentation header. */\n     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));\n-    fh->ip6fh_nxt = IPPROTO_ICMP;\n+    fh->ip6fh_nxt = proto;\n     fh->ip6fh_ident = htonl(id);\n     fh->ip6fh_offlg = htons((off << 3) | mf);\n \n@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)\n     if (dc == NULL)\n         goto end;\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)\n \n     /* Load in 16 packets. */\n     for (i = 0; i < 16; i++) {\n-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);\n+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);\n         if (p == NULL)\n             goto end;\n \n@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)\n \n     /* Build a new packet but push the timestamp out by our timeout.\n      * This should force our previous fragments to be timed out. */\n-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);\n+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);\n     if (p == NULL)\n         goto end;\n \n@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)\n         goto end;\n \n     /* This packet has an offset > 0, more frags set to 0 and no data. */\n-    p = BuildTestPacket(id, 1, 0, 'A', 0);\n+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);\n     if (p == NULL)\n         goto end;\n \n@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)\n \n     /* Create a fragment that would extend past the max allowable size\n      * for an IPv4 packet. */\n-    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);\n     if (p == NULL)\n         goto end;\n \n@@ -2267,10 +2267,10 @@ DefragVlanTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)\n \n     /* Build a packet, its not a fragment but shouldn't matter for\n      * this test. */\n-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);\n     if (p1 == NULL) {\n         goto end;\n     }\n@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)\n     return retval;\n }\n \n+/**\n+ * \\brief Test that fragments that match other than the proto don't\n+ * actually get matched.\n+ */\n+static int DefragTestBadProto(void)\n+{\n+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n+    int id = 12;\n+\n+    DefragInit();\n+\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n+    FAIL_IF_NULL(p1);\n+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);\n+    FAIL_IF_NULL(p2);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n+    FAIL_IF_NULL(p3);\n+\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));\n+\n+    if (p1 != NULL)\n+        SCFree(p1);\n+    if (p2 != NULL)\n+        SCFree(p2);\n+    if (p3 != NULL)\n+        SCFree(p3);\n+\n+    DefragDestroy();\n+    PASS;\n+}\n+\n #endif /* UNITTESTS */\n \n void\n@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)\n     UtRegisterTest(\""DefragTimeoutTest\"", DefragTimeoutTest);\n     UtRegisterTest(\""DefragMfIpv4Test\"", DefragMfIpv4Test);\n     UtRegisterTest(\""DefragMfIpv6Test\"", DefragMfIpv6Test);\n+    UtRegisterTest(\""DefragTestBadProto\"", DefragTestBadProto);\n #endif /* UNITTESTS */\n }\n ""}<_**next**_>{""sha"": ""c3a0c693733a4199ce3ae7d37066e6c549edfcbd"", ""filename"": ""src/defrag.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.h?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -84,6 +84,8 @@ typedef struct DefragTracker_ {\n     uint32_t id; /**< IP ID for this tracker.  32 bits for IPv6, 16\n                   * for IPv4. */\n \n+    uint8_t proto; /**< IP protocol for this tracker. */\n+\n     uint8_t policy; /**< Reassembly policy this tracker will use. */\n \n     uint8_t af; /**< Address family for this tracker, AF_INET or""}","IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
{
    int i;
    int ret = 0;

    DefragInit();

    /*
     * Build the packets.
     */

    int id = 1;
    Packet *packets[17];
    memset(packets, 0x00, sizeof(packets));

    /*
     * Original fragments.
      */
 
     /* A*24 at 0. */
    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
    /* Send all but the last. */
    for (i = 0; i < 9; i++) {
        Packet *tp = Defrag(NULL, NULL, packets[i], NULL);
        if (tp != NULL) {
            SCFree(tp);
            goto end;
        }
        if (ENGINE_ISSET_EVENT(packets[i], IPV6_FRAG_OVERLAP)) {
            goto end;
        }
    }
    int overlap = 0;
    for (; i < 16; i++) {
        Packet *tp = Defrag(NULL, NULL, packets[i], NULL);
        if (tp != NULL) {
            SCFree(tp);
            goto end;
        }
        if (ENGINE_ISSET_EVENT(packets[i], IPV6_FRAG_OVERLAP)) {
            overlap++;
        }
    }
    if (!overlap)
        goto end;

    /* And now the last one. */
    Packet *reassembled = Defrag(NULL, NULL, packets[16], NULL);
    if (reassembled == NULL)
        goto end;
    if (memcmp(GET_PKT_DATA(reassembled) + 40, expected, expected_len) != 0)
        goto end;

    if (IPV6_GET_PLEN(reassembled) != 192)
        goto end;

    SCFree(reassembled);

    /* Make sure all frags were returned to the pool. */
    if (defrag_context->frag_pool->outstanding != 0) {
        printf(""defrag_context->frag_pool->outstanding %u: "", defrag_context->frag_pool->outstanding);
        goto end;
    }

    ret = 1;

end:
    for (i = 0; i < 17; i++) {
        SCFree(packets[i]);
    }
    DefragDestroy();
    return ret;
}
","IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
{
    int i;
    int ret = 0;

    DefragInit();

    /*
     * Build the packets.
     */

    int id = 1;
    Packet *packets[17];
    memset(packets, 0x00, sizeof(packets));

    /*
     * Original fragments.
      */
 
     /* A*24 at 0. */
    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
    /* Send all but the last. */
    for (i = 0; i < 9; i++) {
        Packet *tp = Defrag(NULL, NULL, packets[i], NULL);
        if (tp != NULL) {
            SCFree(tp);
            goto end;
        }
        if (ENGINE_ISSET_EVENT(packets[i], IPV6_FRAG_OVERLAP)) {
            goto end;
        }
    }
    int overlap = 0;
    for (; i < 16; i++) {
        Packet *tp = Defrag(NULL, NULL, packets[i], NULL);
        if (tp != NULL) {
            SCFree(tp);
            goto end;
        }
        if (ENGINE_ISSET_EVENT(packets[i], IPV6_FRAG_OVERLAP)) {
            overlap++;
        }
    }
    if (!overlap)
        goto end;

    /* And now the last one. */
    Packet *reassembled = Defrag(NULL, NULL, packets[16], NULL);
    if (reassembled == NULL)
        goto end;
    if (memcmp(GET_PKT_DATA(reassembled) + 40, expected, expected_len) != 0)
        goto end;

    if (IPV6_GET_PLEN(reassembled) != 192)
        goto end;

    SCFree(reassembled);

    /* Make sure all frags were returned to the pool. */
    if (defrag_context->frag_pool->outstanding != 0) {
        printf(""defrag_context->frag_pool->outstanding %u: "", defrag_context->frag_pool->outstanding);
        goto end;
    }

    ret = 1;

end:
    for (i = 0; i < 17; i++) {
        SCFree(packets[i]);
    }
    DefragDestroy();
    return ret;
}
",C,"    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);
    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);
    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);
    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);
    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);
    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);
    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);
    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);
    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);
    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);
    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);
    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);
    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);
    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);
    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);
    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);
    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);
","    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);
    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
",,"@@ -996,8 +996,8 @@ void DefragDestroy(void)
  * with some payload of no particular protocol.
  */
 static Packet *
-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
-    int content_len)
+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     int hlen = 20;
@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
     else
         ip4h.ip_off = htons(off);
     ip4h.ip_ttl = ttl;
-    ip4h.ip_proto = IPPROTO_ICMP;
+    ip4h.ip_proto = proto;
 
     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */
     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */
@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
         goto error;
     if (IPV4_GET_IPTTL(p) != ttl)
         goto error;
-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)
+    if (IPV4_GET_IPPROTO(p) != proto)
         goto error;
 
     return p;
@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,
                           uint16_t prev_hdrextlen);
 
 static Packet *
-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
-    int content_len)
+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     uint8_t *pcontent;
@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
     IPV6_SET_RAW_VER(p->ip6h, 6);
     /* Fragmentation header. */
     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));
-    fh->ip6fh_nxt = IPPROTO_ICMP;
+    fh->ip6fh_nxt = proto;
     fh->ip6fh_ident = htonl(id);
     fh->ip6fh_offlg = htons((off << 3) | mf);
 
@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)
     if (dc == NULL)
         goto end;
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)
 
     /* Load in 16 packets. */
     for (i = 0; i < 16; i++) {
-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);
+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);
         if (p == NULL)
             goto end;
 
@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)
 
     /* Build a new packet but push the timestamp out by our timeout.
      * This should force our previous fragments to be timed out. */
-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);
+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);
     if (p == NULL)
         goto end;
 
@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)
         goto end;
 
     /* This packet has an offset > 0, more frags set to 0 and no data. */
-    p = BuildTestPacket(id, 1, 0, 'A', 0);
+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);
     if (p == NULL)
         goto end;
 
@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)
 
     /* Create a fragment that would extend past the max allowable size
      * for an IPv4 packet. */
-    p = BuildTestPacket(1, 8183, 0, 'A', 71);
+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);
     if (p == NULL)
         goto end;
 
@@ -2267,10 +2267,10 @@ DefragVlanTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)
 
     /* Build a packet, its not a fragment but shouldn't matter for
      * this test. */
-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);
     if (p1 == NULL) {
         goto end;
     }
@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)
 
     DefragInit();
 
-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)
 
     DefragInit();
 
-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)
     return retval;
 }
 
+/**
+ * \brief Test that fragments that match other than the proto don't
+ * actually get matched.
+ */
+static int DefragTestBadProto(void)
+{
+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
+    int id = 12;
+
+    DefragInit();
+
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
+    FAIL_IF_NULL(p1);
+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);
+    FAIL_IF_NULL(p2);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
+    FAIL_IF_NULL(p3);
+
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));
+
+    if (p1 != NULL)
+        SCFree(p1);
+    if (p2 != NULL)
+        SCFree(p2);
+    if (p3 != NULL)
+        SCFree(p3);
+
+    DefragDestroy();
+    PASS;
+}
+
 #endif /* UNITTESTS */
 
 void
@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)
     UtRegisterTest(""DefragTimeoutTest"", DefragTimeoutTest);
     UtRegisterTest(""DefragMfIpv4Test"", DefragMfIpv4Test);
     UtRegisterTest(""DefragMfIpv6Test"", DefragMfIpv6Test);
+    UtRegisterTest(""DefragTestBadProto"", DefragTestBadProto);
 #endif /* UNITTESTS */
 }
 ",suricata,4a04f814b15762eb446a5ead4d69d021512df6f8,292baf0872abfebf2762e08e613565703595db6c,1,"IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
{
    int i;
    int ret = 0;

    DefragInit();

    /*
     * Build the packets.
     */

    int id = 1;
    Packet *packets[17];
    memset(packets, 0x00, sizeof(packets));

    /*
     * Original fragments.
      */
 
     /* A*24 at 0. */
//flaw_line_below:
    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);
//fix_flaw_line_below:
//    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
//flaw_line_below:
    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
//fix_flaw_line_below:
//    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
//flaw_line_below:
    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
//fix_flaw_line_below:
//    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
//flaw_line_below:
    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
//fix_flaw_line_below:
//    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
//flaw_line_below:
    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
//fix_flaw_line_below:
//    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
//flaw_line_below:
    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
//fix_flaw_line_below:
//    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
//flaw_line_below:
    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
//fix_flaw_line_below:
//    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
//flaw_line_below:
    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
//fix_flaw_line_below:
//    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
//flaw_line_below:
    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
//fix_flaw_line_below:
//    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
//flaw_line_below:
    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
//fix_flaw_line_below:
//    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
//flaw_line_below:
    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
//fix_flaw_line_below:
//    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
//flaw_line_below:
    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
//fix_flaw_line_below:
//    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
//flaw_line_below:
    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
//fix_flaw_line_below:
//    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
//flaw_line_below:
    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
//fix_flaw_line_below:
//    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
//flaw_line_below:
    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
//fix_flaw_line_below:
//    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
//flaw_line_below:
    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
//fix_flaw_line_below:
//    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
//flaw_line_below:
    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
//fix_flaw_line_below:
//    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
    /* Send all but the last. */
    for (i = 0; i < 9; i++) {
        Packet *tp = Defrag(NULL, NULL, packets[i], NULL);
        if (tp != NULL) {
            SCFree(tp);
            goto end;
        }
        if (ENGINE_ISSET_EVENT(packets[i], IPV6_FRAG_OVERLAP)) {
            goto end;
        }
    }
    int overlap = 0;
    for (; i < 16; i++) {
        Packet *tp = Defrag(NULL, NULL, packets[i], NULL);
        if (tp != NULL) {
            SCFree(tp);
            goto end;
        }
        if (ENGINE_ISSET_EVENT(packets[i], IPV6_FRAG_OVERLAP)) {
            overlap++;
        }
    }
    if (!overlap)
        goto end;

    /* And now the last one. */
    Packet *reassembled = Defrag(NULL, NULL, packets[16], NULL);
    if (reassembled == NULL)
        goto end;
    if (memcmp(GET_PKT_DATA(reassembled) + 40, expected, expected_len) != 0)
        goto end;

    if (IPV6_GET_PLEN(reassembled) != 192)
        goto end;

    SCFree(reassembled);

    /* Make sure all frags were returned to the pool. */
    if (defrag_context->frag_pool->outstanding != 0) {
        printf(""defrag_context->frag_pool->outstanding %u: "", defrag_context->frag_pool->outstanding);
        goto end;
    }

    ret = 1;

end:
    for (i = 0; i < 17; i++) {
        SCFree(packets[i]);
    }
    DefragDestroy();
    return ret;
}
"
3745,181481,,Remote,Not required,,CVE-2017-7177,https://www.cvedetails.com/cve/CVE-2017-7177/,CWE-358,Low,,Partial,,2017-03-18,5.0,Suricata before 3.2.1 has an IPv4 defragmentation evasion issue caused by lack of a check for the IP protocol during fragment matching.,2018-12-05,,3,https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8,4a04f814b15762eb446a5ead4d69d021512df6f8,"defrag - take protocol into account during re-assembly

The IP protocol was not being used to match fragments with
their packets allowing a carefully constructed packet
with a different protocol to be matched, allowing re-assembly
to complete, creating a packet that would not be re-assembled
by the destination host.",3,src/defrag.c,"{""sha"": ""736099c58761058109931134cb06744878843604"", ""filename"": ""src/defrag-hash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag-hash.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -92,6 +92,7 @@ static void DefragTrackerInit(DefragTracker *dt, Packet *p)\n         dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);\n         dt->af = AF_INET6;\n     }\n+    dt->proto = IP_GET_IPPROTO(p);\n     dt->vlan_id[0] = p->vlan_id[0];\n     dt->vlan_id[1] = p->vlan_id[1];\n     dt->policy = DefragGetOsPolicy(p);\n@@ -406,6 +407,7 @@ static inline uint32_t DefragHashGetKey(Packet *p)\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->dst)) || \\\n       (CMP_ADDR(&(d1)->src_addr, &(d2)->dst) && \\\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->src))) && \\\n+     (d1)->proto == IP_GET_IPPROTO(p) &&        \\\n      (d1)->id == (id) && \\\n      (d1)->vlan_id[0] == (d2)->vlan_id[0] && \\\n      (d1)->vlan_id[1] == (d2)->vlan_id[1])""}<_**next**_>{""sha"": ""5433ce78607c5e694686de0fd2d93edec264b1bd"", ""filename"": ""src/defrag.c"", ""status"": ""modified"", ""additions"": 102, ""deletions"": 68, ""changes"": 170, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -996,8 +996,8 @@ void DefragDestroy(void)\n  * with some payload of no particular protocol.\n  */\n static Packet *\n-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     int hlen = 20;\n@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n     else\n         ip4h.ip_off = htons(off);\n     ip4h.ip_ttl = ttl;\n-    ip4h.ip_proto = IPPROTO_ICMP;\n+    ip4h.ip_proto = proto;\n \n     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */\n     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */\n@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n         goto error;\n     if (IPV4_GET_IPTTL(p) != ttl)\n         goto error;\n-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)\n+    if (IPV4_GET_IPPROTO(p) != proto)\n         goto error;\n \n     return p;\n@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,\n                           uint16_t prev_hdrextlen);\n \n static Packet *\n-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     uint8_t *pcontent;\n@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n     IPV6_SET_RAW_VER(p->ip6h, 6);\n     /* Fragmentation header. */\n     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));\n-    fh->ip6fh_nxt = IPPROTO_ICMP;\n+    fh->ip6fh_nxt = proto;\n     fh->ip6fh_ident = htonl(id);\n     fh->ip6fh_offlg = htons((off << 3) | mf);\n \n@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)\n     if (dc == NULL)\n         goto end;\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)\n \n     /* Load in 16 packets. */\n     for (i = 0; i < 16; i++) {\n-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);\n+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);\n         if (p == NULL)\n             goto end;\n \n@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)\n \n     /* Build a new packet but push the timestamp out by our timeout.\n      * This should force our previous fragments to be timed out. */\n-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);\n+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);\n     if (p == NULL)\n         goto end;\n \n@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)\n         goto end;\n \n     /* This packet has an offset > 0, more frags set to 0 and no data. */\n-    p = BuildTestPacket(id, 1, 0, 'A', 0);\n+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);\n     if (p == NULL)\n         goto end;\n \n@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)\n \n     /* Create a fragment that would extend past the max allowable size\n      * for an IPv4 packet. */\n-    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);\n     if (p == NULL)\n         goto end;\n \n@@ -2267,10 +2267,10 @@ DefragVlanTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)\n \n     /* Build a packet, its not a fragment but shouldn't matter for\n      * this test. */\n-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);\n     if (p1 == NULL) {\n         goto end;\n     }\n@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)\n     return retval;\n }\n \n+/**\n+ * \\brief Test that fragments that match other than the proto don't\n+ * actually get matched.\n+ */\n+static int DefragTestBadProto(void)\n+{\n+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n+    int id = 12;\n+\n+    DefragInit();\n+\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n+    FAIL_IF_NULL(p1);\n+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);\n+    FAIL_IF_NULL(p2);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n+    FAIL_IF_NULL(p3);\n+\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));\n+\n+    if (p1 != NULL)\n+        SCFree(p1);\n+    if (p2 != NULL)\n+        SCFree(p2);\n+    if (p3 != NULL)\n+        SCFree(p3);\n+\n+    DefragDestroy();\n+    PASS;\n+}\n+\n #endif /* UNITTESTS */\n \n void\n@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)\n     UtRegisterTest(\""DefragTimeoutTest\"", DefragTimeoutTest);\n     UtRegisterTest(\""DefragMfIpv4Test\"", DefragMfIpv4Test);\n     UtRegisterTest(\""DefragMfIpv6Test\"", DefragMfIpv6Test);\n+    UtRegisterTest(\""DefragTestBadProto\"", DefragTestBadProto);\n #endif /* UNITTESTS */\n }\n ""}<_**next**_>{""sha"": ""c3a0c693733a4199ce3ae7d37066e6c549edfcbd"", ""filename"": ""src/defrag.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.h?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -84,6 +84,8 @@ typedef struct DefragTracker_ {\n     uint32_t id; /**< IP ID for this tracker.  32 bits for IPv6, 16\n                   * for IPv4. */\n \n+    uint8_t proto; /**< IP protocol for this tracker. */\n+\n     uint8_t policy; /**< Reassembly policy this tracker will use. */\n \n     uint8_t af; /**< Address family for this tracker, AF_INET or""}","IPV6DefragInOrderSimpleTest(void)
{
    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
    Packet *reassembled = NULL;
    int id = 12;
    int i;
    int ret = 0;
 
     DefragInit();
 
    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
    if (Defrag(NULL, NULL, p1, NULL) != NULL)
        goto end;
    if (Defrag(NULL, NULL, p2, NULL) != NULL)
        goto end;
    reassembled = Defrag(NULL, NULL, p3, NULL);
    if (reassembled == NULL)
        goto end;

    if (IPV6_GET_PLEN(reassembled) != 19)
        goto end;

    /* 40 bytes in we should find 8 bytes of A. */
    for (i = 40; i < 40 + 8; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'A')
            goto end;
    }

    /* 28 bytes in we should find 8 bytes of B. */
    for (i = 48; i < 48 + 8; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'B')
            goto end;
    }

    /* And 36 bytes in we should find 3 bytes of C. */
    for (i = 56; i < 56 + 3; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'C')
            goto end;
    }

    ret = 1;
end:
    if (p1 != NULL)
        SCFree(p1);
    if (p2 != NULL)
        SCFree(p2);
    if (p3 != NULL)
        SCFree(p3);
    if (reassembled != NULL)
        SCFree(reassembled);

    DefragDestroy();
    return ret;
}
","IPV6DefragInOrderSimpleTest(void)
{
    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
    Packet *reassembled = NULL;
    int id = 12;
    int i;
    int ret = 0;
 
     DefragInit();
 
    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
    if (Defrag(NULL, NULL, p1, NULL) != NULL)
        goto end;
    if (Defrag(NULL, NULL, p2, NULL) != NULL)
        goto end;
    reassembled = Defrag(NULL, NULL, p3, NULL);
    if (reassembled == NULL)
        goto end;

    if (IPV6_GET_PLEN(reassembled) != 19)
        goto end;

    /* 40 bytes in we should find 8 bytes of A. */
    for (i = 40; i < 40 + 8; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'A')
            goto end;
    }

    /* 28 bytes in we should find 8 bytes of B. */
    for (i = 48; i < 48 + 8; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'B')
            goto end;
    }

    /* And 36 bytes in we should find 3 bytes of C. */
    for (i = 56; i < 56 + 3; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'C')
            goto end;
    }

    ret = 1;
end:
    if (p1 != NULL)
        SCFree(p1);
    if (p2 != NULL)
        SCFree(p2);
    if (p3 != NULL)
        SCFree(p3);
    if (reassembled != NULL)
        SCFree(reassembled);

    DefragDestroy();
    return ret;
}
",C,"    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
","    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
",,"@@ -996,8 +996,8 @@ void DefragDestroy(void)
  * with some payload of no particular protocol.
  */
 static Packet *
-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
-    int content_len)
+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     int hlen = 20;
@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
     else
         ip4h.ip_off = htons(off);
     ip4h.ip_ttl = ttl;
-    ip4h.ip_proto = IPPROTO_ICMP;
+    ip4h.ip_proto = proto;
 
     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */
     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */
@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
         goto error;
     if (IPV4_GET_IPTTL(p) != ttl)
         goto error;
-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)
+    if (IPV4_GET_IPPROTO(p) != proto)
         goto error;
 
     return p;
@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,
                           uint16_t prev_hdrextlen);
 
 static Packet *
-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
-    int content_len)
+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     uint8_t *pcontent;
@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
     IPV6_SET_RAW_VER(p->ip6h, 6);
     /* Fragmentation header. */
     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));
-    fh->ip6fh_nxt = IPPROTO_ICMP;
+    fh->ip6fh_nxt = proto;
     fh->ip6fh_ident = htonl(id);
     fh->ip6fh_offlg = htons((off << 3) | mf);
 
@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)
     if (dc == NULL)
         goto end;
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)
 
     /* Load in 16 packets. */
     for (i = 0; i < 16; i++) {
-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);
+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);
         if (p == NULL)
             goto end;
 
@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)
 
     /* Build a new packet but push the timestamp out by our timeout.
      * This should force our previous fragments to be timed out. */
-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);
+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);
     if (p == NULL)
         goto end;
 
@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)
         goto end;
 
     /* This packet has an offset > 0, more frags set to 0 and no data. */
-    p = BuildTestPacket(id, 1, 0, 'A', 0);
+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);
     if (p == NULL)
         goto end;
 
@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)
 
     /* Create a fragment that would extend past the max allowable size
      * for an IPv4 packet. */
-    p = BuildTestPacket(1, 8183, 0, 'A', 71);
+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);
     if (p == NULL)
         goto end;
 
@@ -2267,10 +2267,10 @@ DefragVlanTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)
 
     /* Build a packet, its not a fragment but shouldn't matter for
      * this test. */
-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);
     if (p1 == NULL) {
         goto end;
     }
@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)
 
     DefragInit();
 
-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)
 
     DefragInit();
 
-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)
     return retval;
 }
 
+/**
+ * \brief Test that fragments that match other than the proto don't
+ * actually get matched.
+ */
+static int DefragTestBadProto(void)
+{
+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
+    int id = 12;
+
+    DefragInit();
+
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
+    FAIL_IF_NULL(p1);
+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);
+    FAIL_IF_NULL(p2);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
+    FAIL_IF_NULL(p3);
+
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));
+
+    if (p1 != NULL)
+        SCFree(p1);
+    if (p2 != NULL)
+        SCFree(p2);
+    if (p3 != NULL)
+        SCFree(p3);
+
+    DefragDestroy();
+    PASS;
+}
+
 #endif /* UNITTESTS */
 
 void
@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)
     UtRegisterTest(""DefragTimeoutTest"", DefragTimeoutTest);
     UtRegisterTest(""DefragMfIpv4Test"", DefragMfIpv4Test);
     UtRegisterTest(""DefragMfIpv6Test"", DefragMfIpv6Test);
+    UtRegisterTest(""DefragTestBadProto"", DefragTestBadProto);
 #endif /* UNITTESTS */
 }
 ",suricata,4a04f814b15762eb446a5ead4d69d021512df6f8,292baf0872abfebf2762e08e613565703595db6c,1,"IPV6DefragInOrderSimpleTest(void)
{
    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
    Packet *reassembled = NULL;
    int id = 12;
    int i;
    int ret = 0;
 
     DefragInit();
 
//flaw_line_below:
    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
//fix_flaw_line_below:
//    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
//flaw_line_below:
    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
//fix_flaw_line_below:
//    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
//flaw_line_below:
    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
//fix_flaw_line_below:
//    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
    if (Defrag(NULL, NULL, p1, NULL) != NULL)
        goto end;
    if (Defrag(NULL, NULL, p2, NULL) != NULL)
        goto end;
    reassembled = Defrag(NULL, NULL, p3, NULL);
    if (reassembled == NULL)
        goto end;

    if (IPV6_GET_PLEN(reassembled) != 19)
        goto end;

    /* 40 bytes in we should find 8 bytes of A. */
    for (i = 40; i < 40 + 8; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'A')
            goto end;
    }

    /* 28 bytes in we should find 8 bytes of B. */
    for (i = 48; i < 48 + 8; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'B')
            goto end;
    }

    /* And 36 bytes in we should find 3 bytes of C. */
    for (i = 56; i < 56 + 3; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'C')
            goto end;
    }

    ret = 1;
end:
    if (p1 != NULL)
        SCFree(p1);
    if (p2 != NULL)
        SCFree(p2);
    if (p3 != NULL)
        SCFree(p3);
    if (reassembled != NULL)
        SCFree(reassembled);

    DefragDestroy();
    return ret;
}
"
3746,181482,,Remote,Not required,,CVE-2017-7177,https://www.cvedetails.com/cve/CVE-2017-7177/,CWE-358,Low,,Partial,,2017-03-18,5.0,Suricata before 3.2.1 has an IPv4 defragmentation evasion issue caused by lack of a check for the IP protocol during fragment matching.,2018-12-05,,3,https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8,4a04f814b15762eb446a5ead4d69d021512df6f8,"defrag - take protocol into account during re-assembly

The IP protocol was not being used to match fragments with
their packets allowing a carefully constructed packet
with a different protocol to be matched, allowing re-assembly
to complete, creating a packet that would not be re-assembled
by the destination host.",3,src/defrag.c,"{""sha"": ""736099c58761058109931134cb06744878843604"", ""filename"": ""src/defrag-hash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag-hash.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag-hash.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -92,6 +92,7 @@ static void DefragTrackerInit(DefragTracker *dt, Packet *p)\n         dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);\n         dt->af = AF_INET6;\n     }\n+    dt->proto = IP_GET_IPPROTO(p);\n     dt->vlan_id[0] = p->vlan_id[0];\n     dt->vlan_id[1] = p->vlan_id[1];\n     dt->policy = DefragGetOsPolicy(p);\n@@ -406,6 +407,7 @@ static inline uint32_t DefragHashGetKey(Packet *p)\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->dst)) || \\\n       (CMP_ADDR(&(d1)->src_addr, &(d2)->dst) && \\\n        CMP_ADDR(&(d1)->dst_addr, &(d2)->src))) && \\\n+     (d1)->proto == IP_GET_IPPROTO(p) &&        \\\n      (d1)->id == (id) && \\\n      (d1)->vlan_id[0] == (d2)->vlan_id[0] && \\\n      (d1)->vlan_id[1] == (d2)->vlan_id[1])""}<_**next**_>{""sha"": ""5433ce78607c5e694686de0fd2d93edec264b1bd"", ""filename"": ""src/defrag.c"", ""status"": ""modified"", ""additions"": 102, ""deletions"": 68, ""changes"": 170, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.c?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -996,8 +996,8 @@ void DefragDestroy(void)\n  * with some payload of no particular protocol.\n  */\n static Packet *\n-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     int hlen = 20;\n@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n     else\n         ip4h.ip_off = htons(off);\n     ip4h.ip_ttl = ttl;\n-    ip4h.ip_proto = IPPROTO_ICMP;\n+    ip4h.ip_proto = proto;\n \n     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */\n     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */\n@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n         goto error;\n     if (IPV4_GET_IPTTL(p) != ttl)\n         goto error;\n-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)\n+    if (IPV4_GET_IPPROTO(p) != proto)\n         goto error;\n \n     return p;\n@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,\n                           uint16_t prev_hdrextlen);\n \n static Packet *\n-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n-    int content_len)\n+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,\n+    const char content, int content_len)\n {\n     Packet *p = NULL;\n     uint8_t *pcontent;\n@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,\n     IPV6_SET_RAW_VER(p->ip6h, 6);\n     /* Fragmentation header. */\n     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));\n-    fh->ip6fh_nxt = IPPROTO_ICMP;\n+    fh->ip6fh_nxt = proto;\n     fh->ip6fh_ident = htonl(id);\n     fh->ip6fh_offlg = htons((off << 3) | mf);\n \n@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)\n \n     DefragInit();\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)\n     if (dc == NULL)\n         goto end;\n \n-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n      */\n \n     /* A*24 at 0. */\n-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);\n+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)\n \n     /* Load in 16 packets. */\n     for (i = 0; i < 16; i++) {\n-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);\n+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);\n         if (p == NULL)\n             goto end;\n \n@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)\n \n     /* Build a new packet but push the timestamp out by our timeout.\n      * This should force our previous fragments to be timed out. */\n-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);\n+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);\n     if (p == NULL)\n         goto end;\n \n@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)\n         goto end;\n \n     /* This packet has an offset > 0, more frags set to 0 and no data. */\n-    p = BuildTestPacket(id, 1, 0, 'A', 0);\n+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);\n     if (p == NULL)\n         goto end;\n \n@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)\n \n     /* Create a fragment that would extend past the max allowable size\n      * for an IPv4 packet. */\n-    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);\n     if (p == NULL)\n         goto end;\n \n@@ -2267,10 +2267,10 @@ DefragVlanTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)\n \n     DefragInit();\n \n-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n \n@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)\n \n     /* Build a packet, its not a fragment but shouldn't matter for\n      * this test. */\n-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);\n     if (p1 == NULL) {\n         goto end;\n     }\n@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)\n \n     DefragInit();\n \n-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);\n-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);\n-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);\n+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);\n+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);\n+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);\n     if (p1 == NULL || p2 == NULL || p3 == NULL) {\n         goto end;\n     }\n@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)\n     return retval;\n }\n \n+/**\n+ * \\brief Test that fragments that match other than the proto don't\n+ * actually get matched.\n+ */\n+static int DefragTestBadProto(void)\n+{\n+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n+    int id = 12;\n+\n+    DefragInit();\n+\n+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n+    FAIL_IF_NULL(p1);\n+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);\n+    FAIL_IF_NULL(p2);\n+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n+    FAIL_IF_NULL(p3);\n+\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));\n+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));\n+\n+    if (p1 != NULL)\n+        SCFree(p1);\n+    if (p2 != NULL)\n+        SCFree(p2);\n+    if (p3 != NULL)\n+        SCFree(p3);\n+\n+    DefragDestroy();\n+    PASS;\n+}\n+\n #endif /* UNITTESTS */\n \n void\n@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)\n     UtRegisterTest(\""DefragTimeoutTest\"", DefragTimeoutTest);\n     UtRegisterTest(\""DefragMfIpv4Test\"", DefragMfIpv4Test);\n     UtRegisterTest(\""DefragMfIpv6Test\"", DefragMfIpv6Test);\n+    UtRegisterTest(\""DefragTestBadProto\"", DefragTestBadProto);\n #endif /* UNITTESTS */\n }\n ""}<_**next**_>{""sha"": ""c3a0c693733a4199ce3ae7d37066e6c549edfcbd"", ""filename"": ""src/defrag.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/OISF/suricata/blob/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""raw_url"": ""https://github.com/OISF/suricata/raw/4a04f814b15762eb446a5ead4d69d021512df6f8/src/defrag.h"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/defrag.h?ref=4a04f814b15762eb446a5ead4d69d021512df6f8"", ""patch"": ""@@ -84,6 +84,8 @@ typedef struct DefragTracker_ {\n     uint32_t id; /**< IP ID for this tracker.  32 bits for IPv6, 16\n                   * for IPv4. */\n \n+    uint8_t proto; /**< IP protocol for this tracker. */\n+\n     uint8_t policy; /**< Reassembly policy this tracker will use. */\n \n     uint8_t af; /**< Address family for this tracker, AF_INET or""}","IPV6DefragReverseSimpleTest(void)
{
    DefragContext *dc = NULL;
    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
    Packet *reassembled = NULL;
    int id = 12;
    int i;
    int ret = 0;

    DefragInit();

    dc = DefragContextNew();
     if (dc == NULL)
         goto end;
 
    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
    if (Defrag(NULL, NULL, p3, NULL) != NULL)
        goto end;
    if (Defrag(NULL, NULL, p2, NULL) != NULL)
        goto end;
    reassembled = Defrag(NULL, NULL, p1, NULL);
    if (reassembled == NULL)
        goto end;

    /* 40 bytes in we should find 8 bytes of A. */
    for (i = 40; i < 40 + 8; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'A')
            goto end;
    }

    /* 28 bytes in we should find 8 bytes of B. */
    for (i = 48; i < 48 + 8; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'B')
            goto end;
    }

    /* And 36 bytes in we should find 3 bytes of C. */
    for (i = 56; i < 56 + 3; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'C')
            goto end;
    }

    ret = 1;
end:
    if (dc != NULL)
        DefragContextDestroy(dc);
    if (p1 != NULL)
        SCFree(p1);
    if (p2 != NULL)
        SCFree(p2);
    if (p3 != NULL)
        SCFree(p3);
    if (reassembled != NULL)
        SCFree(reassembled);

    DefragDestroy();
    return ret;
}
","IPV6DefragReverseSimpleTest(void)
{
    DefragContext *dc = NULL;
    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
    Packet *reassembled = NULL;
    int id = 12;
    int i;
    int ret = 0;

    DefragInit();

    dc = DefragContextNew();
     if (dc == NULL)
         goto end;
 
    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
    if (Defrag(NULL, NULL, p3, NULL) != NULL)
        goto end;
    if (Defrag(NULL, NULL, p2, NULL) != NULL)
        goto end;
    reassembled = Defrag(NULL, NULL, p1, NULL);
    if (reassembled == NULL)
        goto end;

    /* 40 bytes in we should find 8 bytes of A. */
    for (i = 40; i < 40 + 8; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'A')
            goto end;
    }

    /* 28 bytes in we should find 8 bytes of B. */
    for (i = 48; i < 48 + 8; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'B')
            goto end;
    }

    /* And 36 bytes in we should find 3 bytes of C. */
    for (i = 56; i < 56 + 3; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'C')
            goto end;
    }

    ret = 1;
end:
    if (dc != NULL)
        DefragContextDestroy(dc);
    if (p1 != NULL)
        SCFree(p1);
    if (p2 != NULL)
        SCFree(p2);
    if (p3 != NULL)
        SCFree(p3);
    if (reassembled != NULL)
        SCFree(reassembled);

    DefragDestroy();
    return ret;
}
",C,"    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
","    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
",,"@@ -996,8 +996,8 @@ void DefragDestroy(void)
  * with some payload of no particular protocol.
  */
 static Packet *
-BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
-    int content_len)
+BuildTestPacket(uint8_t proto, uint16_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     int hlen = 20;
@@ -1023,7 +1023,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
     else
         ip4h.ip_off = htons(off);
     ip4h.ip_ttl = ttl;
-    ip4h.ip_proto = IPPROTO_ICMP;
+    ip4h.ip_proto = proto;
 
     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */
     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */
@@ -1059,7 +1059,7 @@ BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,
         goto error;
     if (IPV4_GET_IPTTL(p) != ttl)
         goto error;
-    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)
+    if (IPV4_GET_IPPROTO(p) != proto)
         goto error;
 
     return p;
@@ -1074,8 +1074,8 @@ void DecodeIPV6FragHeader(Packet *p, uint8_t *pkt,
                           uint16_t prev_hdrextlen);
 
 static Packet *
-IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
-    int content_len)
+IPV6BuildTestPacket(uint8_t proto, uint32_t id, uint16_t off, int mf,
+    const char content, int content_len)
 {
     Packet *p = NULL;
     uint8_t *pcontent;
@@ -1109,7 +1109,7 @@ IPV6BuildTestPacket(uint32_t id, uint16_t off, int mf, const char content,
     IPV6_SET_RAW_VER(p->ip6h, 6);
     /* Fragmentation header. */
     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));
-    fh->ip6fh_nxt = IPPROTO_ICMP;
+    fh->ip6fh_nxt = proto;
     fh->ip6fh_ident = htonl(id);
     fh->ip6fh_offlg = htons((off << 3) | mf);
 
@@ -1159,13 +1159,13 @@ DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1236,13 +1236,13 @@ DefragReverseSimpleTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1308,13 +1308,13 @@ IPV6DefragInOrderSimpleTest(void)
 
     DefragInit();
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1378,13 +1378,13 @@ IPV6DefragReverseSimpleTest(void)
     if (dc == NULL)
         goto end;
 
-    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
+    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
+    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
-    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
+    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
@@ -1452,59 +1452,59 @@ DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = BuildTestPacket(IPPROTO_ICMP, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = BuildTestPacket(IPPROTO_ICMP, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = BuildTestPacket(IPPROTO_ICMP, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = BuildTestPacket(IPPROTO_ICMP, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = BuildTestPacket(IPPROTO_ICMP, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = BuildTestPacket(IPPROTO_ICMP, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = BuildTestPacket(IPPROTO_ICMP, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = BuildTestPacket(IPPROTO_ICMP, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = BuildTestPacket(IPPROTO_ICMP, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = BuildTestPacket(IPPROTO_ICMP, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = BuildTestPacket(IPPROTO_ICMP, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = BuildTestPacket(IPPROTO_ICMP, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = BuildTestPacket(IPPROTO_ICMP, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -1587,59 +1587,59 @@ IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)
      */
 
     /* A*24 at 0. */
-    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);
+    packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);
 
     /* B*15 at 32. */
-    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);
+    packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);
 
     /* C*24 at 48. */
-    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);
+    packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);
 
     /* D*8 at 80. */
-    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);
+    packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);
 
     /* E*16 at 104. */
-    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);
+    packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);
 
     /* F*24 at 120. */
-    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);
+    packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);
 
     /* G*16 at 144. */
-    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);
+    packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);
 
     /* H*16 at 160. */
-    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);
+    packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);
 
     /* I*8 at 176. */
-    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);
+    packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);
 
     /*
      * Overlapping subsequent fragments.
      */
 
     /* J*32 at 8. */
-    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);
+    packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);
 
     /* K*24 at 48. */
-    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);
+    packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);
 
     /* L*24 at 72. */
-    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);
+    packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);
 
     /* M*24 at 96. */
-    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);
+    packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);
 
     /* N*8 at 128. */
-    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);
+    packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);
 
     /* O*8 at 152. */
-    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);
+    packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);
 
     /* P*8 at 160. */
-    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);
+    packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);
 
     /* Q*16 at 176. */
-    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);
+    packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);
 
     default_policy = policy;
 
@@ -2125,7 +2125,7 @@ DefragTimeoutTest(void)
 
     /* Load in 16 packets. */
     for (i = 0; i < 16; i++) {
-        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);
+        Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);
         if (p == NULL)
             goto end;
 
@@ -2141,7 +2141,7 @@ DefragTimeoutTest(void)
 
     /* Build a new packet but push the timestamp out by our timeout.
      * This should force our previous fragments to be timed out. */
-    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);
+    Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);
     if (p == NULL)
         goto end;
 
@@ -2189,7 +2189,7 @@ DefragIPv4NoDataTest(void)
         goto end;
 
     /* This packet has an offset > 0, more frags set to 0 and no data. */
-    p = BuildTestPacket(id, 1, 0, 'A', 0);
+    p = BuildTestPacket(IPPROTO_ICMP, id, 1, 0, 'A', 0);
     if (p == NULL)
         goto end;
 
@@ -2228,7 +2228,7 @@ DefragIPv4TooLargeTest(void)
 
     /* Create a fragment that would extend past the max allowable size
      * for an IPv4 packet. */
-    p = BuildTestPacket(1, 8183, 0, 'A', 71);
+    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);
     if (p == NULL)
         goto end;
 
@@ -2267,10 +2267,10 @@ DefragVlanTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2313,10 +2313,10 @@ DefragVlanQinQTest(void)
 
     DefragInit();
 
-    p1 = BuildTestPacket(1, 0, 1, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
-    p2 = BuildTestPacket(1, 1, 0, 'B', 8);
+    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
@@ -2361,7 +2361,7 @@ static int DefragTrackerReuseTest(void)
 
     /* Build a packet, its not a fragment but shouldn't matter for
      * this test. */
-    p1 = BuildTestPacket(id, 0, 0, 'A', 8);
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);
     if (p1 == NULL) {
         goto end;
     }
@@ -2431,9 +2431,9 @@ static int DefragMfIpv4Test(void)
 
     DefragInit();
 
-    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2495,9 +2495,9 @@ static int DefragMfIpv6Test(void)
 
     DefragInit();
 
-    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);
-    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);
-    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);
+    Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);
+    Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);
+    Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);
     if (p1 == NULL || p2 == NULL || p3 == NULL) {
         goto end;
     }
@@ -2542,6 +2542,39 @@ static int DefragMfIpv6Test(void)
     return retval;
 }
 
+/**
+ * \brief Test that fragments that match other than the proto don't
+ * actually get matched.
+ */
+static int DefragTestBadProto(void)
+{
+    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
+    int id = 12;
+
+    DefragInit();
+
+    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);
+    FAIL_IF_NULL(p1);
+    p2 = BuildTestPacket(IPPROTO_UDP, id, 1, 1, 'B', 8);
+    FAIL_IF_NULL(p2);
+    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);
+    FAIL_IF_NULL(p3);
+
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p1, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p2, NULL));
+    FAIL_IF_NOT_NULL(Defrag(NULL, NULL, p3, NULL));
+
+    if (p1 != NULL)
+        SCFree(p1);
+    if (p2 != NULL)
+        SCFree(p2);
+    if (p3 != NULL)
+        SCFree(p3);
+
+    DefragDestroy();
+    PASS;
+}
+
 #endif /* UNITTESTS */
 
 void
@@ -2583,6 +2616,7 @@ DefragRegisterTests(void)
     UtRegisterTest(""DefragTimeoutTest"", DefragTimeoutTest);
     UtRegisterTest(""DefragMfIpv4Test"", DefragMfIpv4Test);
     UtRegisterTest(""DefragMfIpv6Test"", DefragMfIpv6Test);
+    UtRegisterTest(""DefragTestBadProto"", DefragTestBadProto);
 #endif /* UNITTESTS */
 }
 ",suricata,4a04f814b15762eb446a5ead4d69d021512df6f8,292baf0872abfebf2762e08e613565703595db6c,1,"IPV6DefragReverseSimpleTest(void)
{
    DefragContext *dc = NULL;
    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
    Packet *reassembled = NULL;
    int id = 12;
    int i;
    int ret = 0;

    DefragInit();

    dc = DefragContextNew();
     if (dc == NULL)
         goto end;
 
//flaw_line_below:
    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
//fix_flaw_line_below:
//    p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
//flaw_line_below:
    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
//fix_flaw_line_below:
//    p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 1, 1, 'B', 8);
     if (p2 == NULL)
         goto end;
//flaw_line_below:
    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
//fix_flaw_line_below:
//    p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 2, 0, 'C', 3);
     if (p3 == NULL)
         goto end;
 
    if (Defrag(NULL, NULL, p3, NULL) != NULL)
        goto end;
    if (Defrag(NULL, NULL, p2, NULL) != NULL)
        goto end;
    reassembled = Defrag(NULL, NULL, p1, NULL);
    if (reassembled == NULL)
        goto end;

    /* 40 bytes in we should find 8 bytes of A. */
    for (i = 40; i < 40 + 8; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'A')
            goto end;
    }

    /* 28 bytes in we should find 8 bytes of B. */
    for (i = 48; i < 48 + 8; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'B')
            goto end;
    }

    /* And 36 bytes in we should find 3 bytes of C. */
    for (i = 56; i < 56 + 3; i++) {
        if (GET_PKT_DATA(reassembled)[i] != 'C')
            goto end;
    }

    ret = 1;
end:
    if (dc != NULL)
        DefragContextDestroy(dc);
    if (p1 != NULL)
        SCFree(p1);
    if (p2 != NULL)
        SCFree(p2);
    if (p3 != NULL)
        SCFree(p3);
    if (reassembled != NULL)
        SCFree(reassembled);

    DefragDestroy();
    return ret;
}
"
3915,181651,,Remote,Not required,Complete,CVE-2016-10229,https://www.cvedetails.com/cve/CVE-2016-10229/,CWE-358,Low,Complete,Complete,,2017-04-04,10.0,udp.c in the Linux kernel before 4.5 allows remote attackers to execute arbitrary code via UDP traffic that triggers an unsafe second checksum calculation during execution of a recv system call with the MSG_PEEK flag.,2017-09-19,Exec Code ,4,https://github.com/torvalds/linux/commit/197c949e7798fbf28cfadc69d9ca0c2abbf93191,197c949e7798fbf28cfadc69d9ca0c2abbf93191,"udp: properly support MSG_PEEK with truncated buffers

Backport of this upstream commit into stable kernels :
89c22d8c3b27 (""net: Fix skb csum races when peeking"")
exposed a bug in udp stack vs MSG_PEEK support, when user provides
a buffer smaller than skb payload.

In this case,
skb_copy_and_csum_datagram_iovec(skb, sizeof(struct udphdr),
                                 msg->msg_iov);
returns -EFAULT.

This bug does not happen in upstream kernels since Al Viro did a great
job to replace this into :
skb_copy_and_csum_datagram_msg(skb, sizeof(struct udphdr), msg);
This variant is safe vs short buffers.

For the time being, instead reverting Herbert Xu patch and add back
skb->ip_summed invalid changes, simply store the result of
udp_lib_checksum_complete() so that we avoid computing the checksum a
second time, and avoid the problematic
skb_copy_and_csum_datagram_iovec() call.

This patch can be applied on recent kernels as it avoids a double
checksumming, then backported to stable kernels as a bug fix.

Signed-off-by: Eric Dumazet <edumazet@google.com>
Acked-by: Herbert Xu <herbert@gondor.apana.org.au>
Signed-off-by: David S. Miller <davem@davemloft.net>",2,net/ipv4/udp.c,"{""sha"": ""ac14ae44390da6ac61205be831f7636ad20ad5a3"", ""filename"": ""net/ipv4/udp.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/197c949e7798fbf28cfadc69d9ca0c2abbf93191/net/ipv4/udp.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/197c949e7798fbf28cfadc69d9ca0c2abbf93191/net/ipv4/udp.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/udp.c?ref=197c949e7798fbf28cfadc69d9ca0c2abbf93191"", ""patch"": ""@@ -1271,6 +1271,7 @@ int udp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int noblock,\n \tint peeked, off = 0;\n \tint err;\n \tint is_udplite = IS_UDPLITE(sk);\n+\tbool checksum_valid = false;\n \tbool slow;\n \n \tif (flags & MSG_ERRQUEUE)\n@@ -1296,11 +1297,12 @@ int udp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int noblock,\n \t */\n \n \tif (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {\n-\t\tif (udp_lib_checksum_complete(skb))\n+\t\tchecksum_valid = !udp_lib_checksum_complete(skb);\n+\t\tif (!checksum_valid)\n \t\t\tgoto csum_copy_err;\n \t}\n \n-\tif (skb_csum_unnecessary(skb))\n+\tif (checksum_valid || skb_csum_unnecessary(skb))\n \t\terr = skb_copy_datagram_msg(skb, sizeof(struct udphdr),\n \t\t\t\t\t    msg, copied);\n \telse {""}<_**next**_>{""sha"": ""00775ee27d86daabb65b8e86bc80959890293d16"", ""filename"": ""net/ipv6/udp.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/197c949e7798fbf28cfadc69d9ca0c2abbf93191/net/ipv6/udp.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/197c949e7798fbf28cfadc69d9ca0c2abbf93191/net/ipv6/udp.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/udp.c?ref=197c949e7798fbf28cfadc69d9ca0c2abbf93191"", ""patch"": ""@@ -402,6 +402,7 @@ int udpv6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n \tint peeked, off = 0;\n \tint err;\n \tint is_udplite = IS_UDPLITE(sk);\n+\tbool checksum_valid = false;\n \tint is_udp4;\n \tbool slow;\n \n@@ -433,11 +434,12 @@ int udpv6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n \t */\n \n \tif (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {\n-\t\tif (udp_lib_checksum_complete(skb))\n+\t\tchecksum_valid = !udp_lib_checksum_complete(skb);\n+\t\tif (!checksum_valid)\n \t\t\tgoto csum_copy_err;\n \t}\n \n-\tif (skb_csum_unnecessary(skb))\n+\tif (checksum_valid || skb_csum_unnecessary(skb))\n \t\terr = skb_copy_datagram_msg(skb, sizeof(struct udphdr),\n \t\t\t\t\t    msg, copied);\n \telse {""}","int udp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int noblock,
		int flags, int *addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	DECLARE_SOCKADDR(struct sockaddr_in *, sin, msg->msg_name);
	struct sk_buff *skb;
	unsigned int ulen, copied;
 	int peeked, off = 0;
 	int err;
 	int is_udplite = IS_UDPLITE(sk);
	bool checksum_valid = false;
 	bool slow;
 
 	if (flags & MSG_ERRQUEUE)
		return ip_recv_error(sk, msg, len, addr_len);

try_again:
	skb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),
				  &peeked, &off, &err);
	if (!skb)
		goto out;

	ulen = skb->len - sizeof(struct udphdr);
	copied = len;
	if (copied > ulen)
		copied = ulen;
	else if (copied < ulen)
		msg->msg_flags |= MSG_TRUNC;

	/*
	 * If checksum is needed at all, try to do it while copying the
	 * data.  If the data is truncated, or if we only want a partial
	 * coverage checksum (UDP-Lite), do it before the copy.
 	 */
 
 	if (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {
		checksum_valid = !udp_lib_checksum_complete(skb);
		if (!checksum_valid)
 			goto csum_copy_err;
 	}
 
	if (checksum_valid || skb_csum_unnecessary(skb))
 		err = skb_copy_datagram_msg(skb, sizeof(struct udphdr),
 					    msg, copied);
 	else {
		err = skb_copy_and_csum_datagram_msg(skb, sizeof(struct udphdr),
						     msg);

		if (err == -EINVAL)
			goto csum_copy_err;
	}

	if (unlikely(err)) {
		trace_kfree_skb(skb, udp_recvmsg);
		if (!peeked) {
			atomic_inc(&sk->sk_drops);
			UDP_INC_STATS_USER(sock_net(sk),
					   UDP_MIB_INERRORS, is_udplite);
		}
		goto out_free;
	}

	if (!peeked)
		UDP_INC_STATS_USER(sock_net(sk),
				UDP_MIB_INDATAGRAMS, is_udplite);

	sock_recv_ts_and_drops(msg, sk, skb);

	/* Copy the address. */
	if (sin) {
		sin->sin_family = AF_INET;
		sin->sin_port = udp_hdr(skb)->source;
		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
		memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
		*addr_len = sizeof(*sin);
	}
	if (inet->cmsg_flags)
		ip_cmsg_recv_offset(msg, skb, sizeof(struct udphdr));

	err = copied;
	if (flags & MSG_TRUNC)
		err = ulen;

out_free:
	skb_free_datagram_locked(sk, skb);
out:
	return err;

csum_copy_err:
	slow = lock_sock_fast(sk);
	if (!skb_kill_datagram(sk, skb, flags)) {
		UDP_INC_STATS_USER(sock_net(sk), UDP_MIB_CSUMERRORS, is_udplite);
		UDP_INC_STATS_USER(sock_net(sk), UDP_MIB_INERRORS, is_udplite);
	}
	unlock_sock_fast(sk, slow);

	/* starting over for a new packet, but check if we need to yield */
	cond_resched();
	msg->msg_flags &= ~MSG_TRUNC;
	goto try_again;
}
","int udp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int noblock,
		int flags, int *addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	DECLARE_SOCKADDR(struct sockaddr_in *, sin, msg->msg_name);
	struct sk_buff *skb;
	unsigned int ulen, copied;
 	int peeked, off = 0;
 	int err;
 	int is_udplite = IS_UDPLITE(sk);
 	bool slow;
 
 	if (flags & MSG_ERRQUEUE)
		return ip_recv_error(sk, msg, len, addr_len);

try_again:
	skb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),
				  &peeked, &off, &err);
	if (!skb)
		goto out;

	ulen = skb->len - sizeof(struct udphdr);
	copied = len;
	if (copied > ulen)
		copied = ulen;
	else if (copied < ulen)
		msg->msg_flags |= MSG_TRUNC;

	/*
	 * If checksum is needed at all, try to do it while copying the
	 * data.  If the data is truncated, or if we only want a partial
	 * coverage checksum (UDP-Lite), do it before the copy.
 	 */
 
 	if (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {
		if (udp_lib_checksum_complete(skb))
 			goto csum_copy_err;
 	}
 
	if (skb_csum_unnecessary(skb))
 		err = skb_copy_datagram_msg(skb, sizeof(struct udphdr),
 					    msg, copied);
 	else {
		err = skb_copy_and_csum_datagram_msg(skb, sizeof(struct udphdr),
						     msg);

		if (err == -EINVAL)
			goto csum_copy_err;
	}

	if (unlikely(err)) {
		trace_kfree_skb(skb, udp_recvmsg);
		if (!peeked) {
			atomic_inc(&sk->sk_drops);
			UDP_INC_STATS_USER(sock_net(sk),
					   UDP_MIB_INERRORS, is_udplite);
		}
		goto out_free;
	}

	if (!peeked)
		UDP_INC_STATS_USER(sock_net(sk),
				UDP_MIB_INDATAGRAMS, is_udplite);

	sock_recv_ts_and_drops(msg, sk, skb);

	/* Copy the address. */
	if (sin) {
		sin->sin_family = AF_INET;
		sin->sin_port = udp_hdr(skb)->source;
		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
		memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
		*addr_len = sizeof(*sin);
	}
	if (inet->cmsg_flags)
		ip_cmsg_recv_offset(msg, skb, sizeof(struct udphdr));

	err = copied;
	if (flags & MSG_TRUNC)
		err = ulen;

out_free:
	skb_free_datagram_locked(sk, skb);
out:
	return err;

csum_copy_err:
	slow = lock_sock_fast(sk);
	if (!skb_kill_datagram(sk, skb, flags)) {
		UDP_INC_STATS_USER(sock_net(sk), UDP_MIB_CSUMERRORS, is_udplite);
		UDP_INC_STATS_USER(sock_net(sk), UDP_MIB_INERRORS, is_udplite);
	}
	unlock_sock_fast(sk, slow);

	/* starting over for a new packet, but check if we need to yield */
	cond_resched();
	msg->msg_flags &= ~MSG_TRUNC;
	goto try_again;
}
",C,"	bool checksum_valid = false;
		checksum_valid = !udp_lib_checksum_complete(skb);
		if (!checksum_valid)
	if (checksum_valid || skb_csum_unnecessary(skb))
","		if (udp_lib_checksum_complete(skb))
	if (skb_csum_unnecessary(skb))
",,"@@ -1271,6 +1271,7 @@ int udp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int noblock,
 	int peeked, off = 0;
 	int err;
 	int is_udplite = IS_UDPLITE(sk);
+	bool checksum_valid = false;
 	bool slow;
 
 	if (flags & MSG_ERRQUEUE)
@@ -1296,11 +1297,12 @@ int udp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int noblock,
 	 */
 
 	if (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {
-		if (udp_lib_checksum_complete(skb))
+		checksum_valid = !udp_lib_checksum_complete(skb);
+		if (!checksum_valid)
 			goto csum_copy_err;
 	}
 
-	if (skb_csum_unnecessary(skb))
+	if (checksum_valid || skb_csum_unnecessary(skb))
 		err = skb_copy_datagram_msg(skb, sizeof(struct udphdr),
 					    msg, copied);
 	else {",linux,197c949e7798fbf28cfadc69d9ca0c2abbf93191,815bc580fe4ebffc35cc837a775f5400f5a607c4,1,"int udp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int noblock,
		int flags, int *addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	DECLARE_SOCKADDR(struct sockaddr_in *, sin, msg->msg_name);
	struct sk_buff *skb;
	unsigned int ulen, copied;
 	int peeked, off = 0;
 	int err;
 	int is_udplite = IS_UDPLITE(sk);
//fix_flaw_line_below:
//	bool checksum_valid = false;
 	bool slow;
 
 	if (flags & MSG_ERRQUEUE)
		return ip_recv_error(sk, msg, len, addr_len);

try_again:
	skb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),
				  &peeked, &off, &err);
	if (!skb)
		goto out;

	ulen = skb->len - sizeof(struct udphdr);
	copied = len;
	if (copied > ulen)
		copied = ulen;
	else if (copied < ulen)
		msg->msg_flags |= MSG_TRUNC;

	/*
	 * If checksum is needed at all, try to do it while copying the
	 * data.  If the data is truncated, or if we only want a partial
	 * coverage checksum (UDP-Lite), do it before the copy.
 	 */
 
 	if (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {
//flaw_line_below:
		if (udp_lib_checksum_complete(skb))
//fix_flaw_line_below:
//		checksum_valid = !udp_lib_checksum_complete(skb);
//fix_flaw_line_below:
//		if (!checksum_valid)
 			goto csum_copy_err;
 	}
 
//flaw_line_below:
	if (skb_csum_unnecessary(skb))
//fix_flaw_line_below:
//	if (checksum_valid || skb_csum_unnecessary(skb))
 		err = skb_copy_datagram_msg(skb, sizeof(struct udphdr),
 					    msg, copied);
 	else {
		err = skb_copy_and_csum_datagram_msg(skb, sizeof(struct udphdr),
						     msg);

		if (err == -EINVAL)
			goto csum_copy_err;
	}

	if (unlikely(err)) {
		trace_kfree_skb(skb, udp_recvmsg);
		if (!peeked) {
			atomic_inc(&sk->sk_drops);
			UDP_INC_STATS_USER(sock_net(sk),
					   UDP_MIB_INERRORS, is_udplite);
		}
		goto out_free;
	}

	if (!peeked)
		UDP_INC_STATS_USER(sock_net(sk),
				UDP_MIB_INDATAGRAMS, is_udplite);

	sock_recv_ts_and_drops(msg, sk, skb);

	/* Copy the address. */
	if (sin) {
		sin->sin_family = AF_INET;
		sin->sin_port = udp_hdr(skb)->source;
		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
		memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
		*addr_len = sizeof(*sin);
	}
	if (inet->cmsg_flags)
		ip_cmsg_recv_offset(msg, skb, sizeof(struct udphdr));

	err = copied;
	if (flags & MSG_TRUNC)
		err = ulen;

out_free:
	skb_free_datagram_locked(sk, skb);
out:
	return err;

csum_copy_err:
	slow = lock_sock_fast(sk);
	if (!skb_kill_datagram(sk, skb, flags)) {
		UDP_INC_STATS_USER(sock_net(sk), UDP_MIB_CSUMERRORS, is_udplite);
		UDP_INC_STATS_USER(sock_net(sk), UDP_MIB_INERRORS, is_udplite);
	}
	unlock_sock_fast(sk, slow);

	/* starting over for a new packet, but check if we need to yield */
	cond_resched();
	msg->msg_flags &= ~MSG_TRUNC;
	goto try_again;
}
"
3916,181652,,Remote,Not required,Complete,CVE-2016-10229,https://www.cvedetails.com/cve/CVE-2016-10229/,CWE-358,Low,Complete,Complete,,2017-04-04,10.0,udp.c in the Linux kernel before 4.5 allows remote attackers to execute arbitrary code via UDP traffic that triggers an unsafe second checksum calculation during execution of a recv system call with the MSG_PEEK flag.,2017-09-19,Exec Code ,4,https://github.com/torvalds/linux/commit/197c949e7798fbf28cfadc69d9ca0c2abbf93191,197c949e7798fbf28cfadc69d9ca0c2abbf93191,"udp: properly support MSG_PEEK with truncated buffers

Backport of this upstream commit into stable kernels :
89c22d8c3b27 (""net: Fix skb csum races when peeking"")
exposed a bug in udp stack vs MSG_PEEK support, when user provides
a buffer smaller than skb payload.

In this case,
skb_copy_and_csum_datagram_iovec(skb, sizeof(struct udphdr),
                                 msg->msg_iov);
returns -EFAULT.

This bug does not happen in upstream kernels since Al Viro did a great
job to replace this into :
skb_copy_and_csum_datagram_msg(skb, sizeof(struct udphdr), msg);
This variant is safe vs short buffers.

For the time being, instead reverting Herbert Xu patch and add back
skb->ip_summed invalid changes, simply store the result of
udp_lib_checksum_complete() so that we avoid computing the checksum a
second time, and avoid the problematic
skb_copy_and_csum_datagram_iovec() call.

This patch can be applied on recent kernels as it avoids a double
checksumming, then backported to stable kernels as a bug fix.

Signed-off-by: Eric Dumazet <edumazet@google.com>
Acked-by: Herbert Xu <herbert@gondor.apana.org.au>
Signed-off-by: David S. Miller <davem@davemloft.net>",2,net/ipv6/udp.c,"{""sha"": ""ac14ae44390da6ac61205be831f7636ad20ad5a3"", ""filename"": ""net/ipv4/udp.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/197c949e7798fbf28cfadc69d9ca0c2abbf93191/net/ipv4/udp.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/197c949e7798fbf28cfadc69d9ca0c2abbf93191/net/ipv4/udp.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/udp.c?ref=197c949e7798fbf28cfadc69d9ca0c2abbf93191"", ""patch"": ""@@ -1271,6 +1271,7 @@ int udp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int noblock,\n \tint peeked, off = 0;\n \tint err;\n \tint is_udplite = IS_UDPLITE(sk);\n+\tbool checksum_valid = false;\n \tbool slow;\n \n \tif (flags & MSG_ERRQUEUE)\n@@ -1296,11 +1297,12 @@ int udp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int noblock,\n \t */\n \n \tif (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {\n-\t\tif (udp_lib_checksum_complete(skb))\n+\t\tchecksum_valid = !udp_lib_checksum_complete(skb);\n+\t\tif (!checksum_valid)\n \t\t\tgoto csum_copy_err;\n \t}\n \n-\tif (skb_csum_unnecessary(skb))\n+\tif (checksum_valid || skb_csum_unnecessary(skb))\n \t\terr = skb_copy_datagram_msg(skb, sizeof(struct udphdr),\n \t\t\t\t\t    msg, copied);\n \telse {""}<_**next**_>{""sha"": ""00775ee27d86daabb65b8e86bc80959890293d16"", ""filename"": ""net/ipv6/udp.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/197c949e7798fbf28cfadc69d9ca0c2abbf93191/net/ipv6/udp.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/197c949e7798fbf28cfadc69d9ca0c2abbf93191/net/ipv6/udp.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/udp.c?ref=197c949e7798fbf28cfadc69d9ca0c2abbf93191"", ""patch"": ""@@ -402,6 +402,7 @@ int udpv6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n \tint peeked, off = 0;\n \tint err;\n \tint is_udplite = IS_UDPLITE(sk);\n+\tbool checksum_valid = false;\n \tint is_udp4;\n \tbool slow;\n \n@@ -433,11 +434,12 @@ int udpv6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n \t */\n \n \tif (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {\n-\t\tif (udp_lib_checksum_complete(skb))\n+\t\tchecksum_valid = !udp_lib_checksum_complete(skb);\n+\t\tif (!checksum_valid)\n \t\t\tgoto csum_copy_err;\n \t}\n \n-\tif (skb_csum_unnecessary(skb))\n+\tif (checksum_valid || skb_csum_unnecessary(skb))\n \t\terr = skb_copy_datagram_msg(skb, sizeof(struct udphdr),\n \t\t\t\t\t    msg, copied);\n \telse {""}","int udpv6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,
		  int noblock, int flags, int *addr_len)
{
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct inet_sock *inet = inet_sk(sk);
	struct sk_buff *skb;
	unsigned int ulen, copied;
 	int peeked, off = 0;
 	int err;
 	int is_udplite = IS_UDPLITE(sk);
	bool checksum_valid = false;
 	int is_udp4;
 	bool slow;
 
	if (flags & MSG_ERRQUEUE)
		return ipv6_recv_error(sk, msg, len, addr_len);

	if (np->rxpmtu && np->rxopt.bits.rxpmtu)
		return ipv6_recv_rxpmtu(sk, msg, len, addr_len);

try_again:
	skb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),
				  &peeked, &off, &err);
	if (!skb)
		goto out;

	ulen = skb->len - sizeof(struct udphdr);
	copied = len;
	if (copied > ulen)
		copied = ulen;
	else if (copied < ulen)
		msg->msg_flags |= MSG_TRUNC;

	is_udp4 = (skb->protocol == htons(ETH_P_IP));

	/*
	 * If checksum is needed at all, try to do it while copying the
	 * data.  If the data is truncated, or if we only want a partial
	 * coverage checksum (UDP-Lite), do it before the copy.
 	 */
 
 	if (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {
		checksum_valid = !udp_lib_checksum_complete(skb);
		if (!checksum_valid)
 			goto csum_copy_err;
 	}
 
	if (checksum_valid || skb_csum_unnecessary(skb))
 		err = skb_copy_datagram_msg(skb, sizeof(struct udphdr),
 					    msg, copied);
 	else {
		err = skb_copy_and_csum_datagram_msg(skb, sizeof(struct udphdr), msg);
		if (err == -EINVAL)
			goto csum_copy_err;
	}
	if (unlikely(err)) {
		trace_kfree_skb(skb, udpv6_recvmsg);
		if (!peeked) {
			atomic_inc(&sk->sk_drops);
			if (is_udp4)
				UDP_INC_STATS_USER(sock_net(sk),
						   UDP_MIB_INERRORS,
						   is_udplite);
			else
				UDP6_INC_STATS_USER(sock_net(sk),
						    UDP_MIB_INERRORS,
						    is_udplite);
		}
		goto out_free;
	}
	if (!peeked) {
		if (is_udp4)
			UDP_INC_STATS_USER(sock_net(sk),
					UDP_MIB_INDATAGRAMS, is_udplite);
		else
			UDP6_INC_STATS_USER(sock_net(sk),
					UDP_MIB_INDATAGRAMS, is_udplite);
	}

	sock_recv_ts_and_drops(msg, sk, skb);

	/* Copy the address. */
	if (msg->msg_name) {
		DECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);
		sin6->sin6_family = AF_INET6;
		sin6->sin6_port = udp_hdr(skb)->source;
		sin6->sin6_flowinfo = 0;

		if (is_udp4) {
			ipv6_addr_set_v4mapped(ip_hdr(skb)->saddr,
					       &sin6->sin6_addr);
			sin6->sin6_scope_id = 0;
		} else {
			sin6->sin6_addr = ipv6_hdr(skb)->saddr;
			sin6->sin6_scope_id =
				ipv6_iface_scope_id(&sin6->sin6_addr,
						    inet6_iif(skb));
		}
		*addr_len = sizeof(*sin6);
	}

	if (np->rxopt.all)
		ip6_datagram_recv_common_ctl(sk, msg, skb);

	if (is_udp4) {
		if (inet->cmsg_flags)
			ip_cmsg_recv(msg, skb);
	} else {
		if (np->rxopt.all)
			ip6_datagram_recv_specific_ctl(sk, msg, skb);
	}

	err = copied;
	if (flags & MSG_TRUNC)
		err = ulen;

out_free:
	skb_free_datagram_locked(sk, skb);
out:
	return err;

csum_copy_err:
	slow = lock_sock_fast(sk);
	if (!skb_kill_datagram(sk, skb, flags)) {
		if (is_udp4) {
			UDP_INC_STATS_USER(sock_net(sk),
					UDP_MIB_CSUMERRORS, is_udplite);
			UDP_INC_STATS_USER(sock_net(sk),
					UDP_MIB_INERRORS, is_udplite);
		} else {
			UDP6_INC_STATS_USER(sock_net(sk),
					UDP_MIB_CSUMERRORS, is_udplite);
			UDP6_INC_STATS_USER(sock_net(sk),
					UDP_MIB_INERRORS, is_udplite);
		}
	}
	unlock_sock_fast(sk, slow);

	/* starting over for a new packet, but check if we need to yield */
	cond_resched();
	msg->msg_flags &= ~MSG_TRUNC;
	goto try_again;
}
","int udpv6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,
		  int noblock, int flags, int *addr_len)
{
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct inet_sock *inet = inet_sk(sk);
	struct sk_buff *skb;
	unsigned int ulen, copied;
 	int peeked, off = 0;
 	int err;
 	int is_udplite = IS_UDPLITE(sk);
 	int is_udp4;
 	bool slow;
 
	if (flags & MSG_ERRQUEUE)
		return ipv6_recv_error(sk, msg, len, addr_len);

	if (np->rxpmtu && np->rxopt.bits.rxpmtu)
		return ipv6_recv_rxpmtu(sk, msg, len, addr_len);

try_again:
	skb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),
				  &peeked, &off, &err);
	if (!skb)
		goto out;

	ulen = skb->len - sizeof(struct udphdr);
	copied = len;
	if (copied > ulen)
		copied = ulen;
	else if (copied < ulen)
		msg->msg_flags |= MSG_TRUNC;

	is_udp4 = (skb->protocol == htons(ETH_P_IP));

	/*
	 * If checksum is needed at all, try to do it while copying the
	 * data.  If the data is truncated, or if we only want a partial
	 * coverage checksum (UDP-Lite), do it before the copy.
 	 */
 
 	if (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {
		if (udp_lib_checksum_complete(skb))
 			goto csum_copy_err;
 	}
 
	if (skb_csum_unnecessary(skb))
 		err = skb_copy_datagram_msg(skb, sizeof(struct udphdr),
 					    msg, copied);
 	else {
		err = skb_copy_and_csum_datagram_msg(skb, sizeof(struct udphdr), msg);
		if (err == -EINVAL)
			goto csum_copy_err;
	}
	if (unlikely(err)) {
		trace_kfree_skb(skb, udpv6_recvmsg);
		if (!peeked) {
			atomic_inc(&sk->sk_drops);
			if (is_udp4)
				UDP_INC_STATS_USER(sock_net(sk),
						   UDP_MIB_INERRORS,
						   is_udplite);
			else
				UDP6_INC_STATS_USER(sock_net(sk),
						    UDP_MIB_INERRORS,
						    is_udplite);
		}
		goto out_free;
	}
	if (!peeked) {
		if (is_udp4)
			UDP_INC_STATS_USER(sock_net(sk),
					UDP_MIB_INDATAGRAMS, is_udplite);
		else
			UDP6_INC_STATS_USER(sock_net(sk),
					UDP_MIB_INDATAGRAMS, is_udplite);
	}

	sock_recv_ts_and_drops(msg, sk, skb);

	/* Copy the address. */
	if (msg->msg_name) {
		DECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);
		sin6->sin6_family = AF_INET6;
		sin6->sin6_port = udp_hdr(skb)->source;
		sin6->sin6_flowinfo = 0;

		if (is_udp4) {
			ipv6_addr_set_v4mapped(ip_hdr(skb)->saddr,
					       &sin6->sin6_addr);
			sin6->sin6_scope_id = 0;
		} else {
			sin6->sin6_addr = ipv6_hdr(skb)->saddr;
			sin6->sin6_scope_id =
				ipv6_iface_scope_id(&sin6->sin6_addr,
						    inet6_iif(skb));
		}
		*addr_len = sizeof(*sin6);
	}

	if (np->rxopt.all)
		ip6_datagram_recv_common_ctl(sk, msg, skb);

	if (is_udp4) {
		if (inet->cmsg_flags)
			ip_cmsg_recv(msg, skb);
	} else {
		if (np->rxopt.all)
			ip6_datagram_recv_specific_ctl(sk, msg, skb);
	}

	err = copied;
	if (flags & MSG_TRUNC)
		err = ulen;

out_free:
	skb_free_datagram_locked(sk, skb);
out:
	return err;

csum_copy_err:
	slow = lock_sock_fast(sk);
	if (!skb_kill_datagram(sk, skb, flags)) {
		if (is_udp4) {
			UDP_INC_STATS_USER(sock_net(sk),
					UDP_MIB_CSUMERRORS, is_udplite);
			UDP_INC_STATS_USER(sock_net(sk),
					UDP_MIB_INERRORS, is_udplite);
		} else {
			UDP6_INC_STATS_USER(sock_net(sk),
					UDP_MIB_CSUMERRORS, is_udplite);
			UDP6_INC_STATS_USER(sock_net(sk),
					UDP_MIB_INERRORS, is_udplite);
		}
	}
	unlock_sock_fast(sk, slow);

	/* starting over for a new packet, but check if we need to yield */
	cond_resched();
	msg->msg_flags &= ~MSG_TRUNC;
	goto try_again;
}
",C,"	bool checksum_valid = false;
		checksum_valid = !udp_lib_checksum_complete(skb);
		if (!checksum_valid)
	if (checksum_valid || skb_csum_unnecessary(skb))
","		if (udp_lib_checksum_complete(skb))
	if (skb_csum_unnecessary(skb))
",,"@@ -402,6 +402,7 @@ int udpv6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,
 	int peeked, off = 0;
 	int err;
 	int is_udplite = IS_UDPLITE(sk);
+	bool checksum_valid = false;
 	int is_udp4;
 	bool slow;
 
@@ -433,11 +434,12 @@ int udpv6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,
 	 */
 
 	if (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {
-		if (udp_lib_checksum_complete(skb))
+		checksum_valid = !udp_lib_checksum_complete(skb);
+		if (!checksum_valid)
 			goto csum_copy_err;
 	}
 
-	if (skb_csum_unnecessary(skb))
+	if (checksum_valid || skb_csum_unnecessary(skb))
 		err = skb_copy_datagram_msg(skb, sizeof(struct udphdr),
 					    msg, copied);
 	else {",linux,197c949e7798fbf28cfadc69d9ca0c2abbf93191,815bc580fe4ebffc35cc837a775f5400f5a607c4,1,"int udpv6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,
		  int noblock, int flags, int *addr_len)
{
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct inet_sock *inet = inet_sk(sk);
	struct sk_buff *skb;
	unsigned int ulen, copied;
 	int peeked, off = 0;
 	int err;
 	int is_udplite = IS_UDPLITE(sk);
//fix_flaw_line_below:
//	bool checksum_valid = false;
 	int is_udp4;
 	bool slow;
 
	if (flags & MSG_ERRQUEUE)
		return ipv6_recv_error(sk, msg, len, addr_len);

	if (np->rxpmtu && np->rxopt.bits.rxpmtu)
		return ipv6_recv_rxpmtu(sk, msg, len, addr_len);

try_again:
	skb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),
				  &peeked, &off, &err);
	if (!skb)
		goto out;

	ulen = skb->len - sizeof(struct udphdr);
	copied = len;
	if (copied > ulen)
		copied = ulen;
	else if (copied < ulen)
		msg->msg_flags |= MSG_TRUNC;

	is_udp4 = (skb->protocol == htons(ETH_P_IP));

	/*
	 * If checksum is needed at all, try to do it while copying the
	 * data.  If the data is truncated, or if we only want a partial
	 * coverage checksum (UDP-Lite), do it before the copy.
 	 */
 
 	if (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {
//flaw_line_below:
		if (udp_lib_checksum_complete(skb))
//fix_flaw_line_below:
//		checksum_valid = !udp_lib_checksum_complete(skb);
//fix_flaw_line_below:
//		if (!checksum_valid)
 			goto csum_copy_err;
 	}
 
//flaw_line_below:
	if (skb_csum_unnecessary(skb))
//fix_flaw_line_below:
//	if (checksum_valid || skb_csum_unnecessary(skb))
 		err = skb_copy_datagram_msg(skb, sizeof(struct udphdr),
 					    msg, copied);
 	else {
		err = skb_copy_and_csum_datagram_msg(skb, sizeof(struct udphdr), msg);
		if (err == -EINVAL)
			goto csum_copy_err;
	}
	if (unlikely(err)) {
		trace_kfree_skb(skb, udpv6_recvmsg);
		if (!peeked) {
			atomic_inc(&sk->sk_drops);
			if (is_udp4)
				UDP_INC_STATS_USER(sock_net(sk),
						   UDP_MIB_INERRORS,
						   is_udplite);
			else
				UDP6_INC_STATS_USER(sock_net(sk),
						    UDP_MIB_INERRORS,
						    is_udplite);
		}
		goto out_free;
	}
	if (!peeked) {
		if (is_udp4)
			UDP_INC_STATS_USER(sock_net(sk),
					UDP_MIB_INDATAGRAMS, is_udplite);
		else
			UDP6_INC_STATS_USER(sock_net(sk),
					UDP_MIB_INDATAGRAMS, is_udplite);
	}

	sock_recv_ts_and_drops(msg, sk, skb);

	/* Copy the address. */
	if (msg->msg_name) {
		DECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);
		sin6->sin6_family = AF_INET6;
		sin6->sin6_port = udp_hdr(skb)->source;
		sin6->sin6_flowinfo = 0;

		if (is_udp4) {
			ipv6_addr_set_v4mapped(ip_hdr(skb)->saddr,
					       &sin6->sin6_addr);
			sin6->sin6_scope_id = 0;
		} else {
			sin6->sin6_addr = ipv6_hdr(skb)->saddr;
			sin6->sin6_scope_id =
				ipv6_iface_scope_id(&sin6->sin6_addr,
						    inet6_iif(skb));
		}
		*addr_len = sizeof(*sin6);
	}

	if (np->rxopt.all)
		ip6_datagram_recv_common_ctl(sk, msg, skb);

	if (is_udp4) {
		if (inet->cmsg_flags)
			ip_cmsg_recv(msg, skb);
	} else {
		if (np->rxopt.all)
			ip6_datagram_recv_specific_ctl(sk, msg, skb);
	}

	err = copied;
	if (flags & MSG_TRUNC)
		err = ulen;

out_free:
	skb_free_datagram_locked(sk, skb);
out:
	return err;

csum_copy_err:
	slow = lock_sock_fast(sk);
	if (!skb_kill_datagram(sk, skb, flags)) {
		if (is_udp4) {
			UDP_INC_STATS_USER(sock_net(sk),
					UDP_MIB_CSUMERRORS, is_udplite);
			UDP_INC_STATS_USER(sock_net(sk),
					UDP_MIB_INERRORS, is_udplite);
		} else {
			UDP6_INC_STATS_USER(sock_net(sk),
					UDP_MIB_CSUMERRORS, is_udplite);
			UDP6_INC_STATS_USER(sock_net(sk),
					UDP_MIB_INERRORS, is_udplite);
		}
	}
	unlock_sock_fast(sk, slow);

	/* starting over for a new packet, but check if we need to yield */
	cond_resched();
	msg->msg_flags &= ~MSG_TRUNC;
	goto try_again;
}
"
