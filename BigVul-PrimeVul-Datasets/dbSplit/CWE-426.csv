,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix
4099,181835,,Remote,Not required,Partial,CVE-2016-10009,https://www.cvedetails.com/cve/CVE-2016-10009/,CWE-426,Low,Partial,Partial,,2017-01-04,7.5,Untrusted search path vulnerability in ssh-agent.c in ssh-agent in OpenSSH before 7.4 allows remote attackers to execute arbitrary local PKCS#11 modules by leveraging control over a forwarded agent-socket.,2018-09-11,,10,https://github.com/openbsd/src/commit/9476ce1dd37d3c3218d5640b74c34c65e5f4efe5,9476ce1dd37d3c3218d5640b74c34c65e5f4efe5,"add a whitelist of paths from which ssh-agent will load (via
ssh-pkcs11-helper) a PKCS#11 module; ok markus@",2,usr.bin/ssh/ssh-agent.c,"{""sha"": ""372adbe7c7f52203b16da700601ed979ff58da2d"", ""filename"": ""usr.bin/ssh/ssh-agent.1"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 2, ""changes"": 17, ""blob_url"": ""https://github.com/openbsd/src/blob/9476ce1dd37d3c3218d5640b74c34c65e5f4efe5/usr.bin/ssh/ssh-agent.1"", ""raw_url"": ""https://github.com/openbsd/src/raw/9476ce1dd37d3c3218d5640b74c34c65e5f4efe5/usr.bin/ssh/ssh-agent.1"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/ssh-agent.1?ref=9476ce1dd37d3c3218d5640b74c34c65e5f4efe5"", ""patch"": ""@@ -1,4 +1,4 @@\n-.\\\"" $OpenBSD: ssh-agent.1,v 1.62 2015/11/15 23:54:15 jmc Exp $\n+.\\\"" $OpenBSD: ssh-agent.1,v 1.63 2016/11/30 03:07:37 djm Exp $\n .\\\""\n .\\\"" Author: Tatu Ylonen <ylo@cs.hut.fi>\n .\\\"" Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n@@ -34,7 +34,7 @@\n .\\\"" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n .\\\"" THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n .\\\""\n-.Dd $Mdocdate: November 15 2015 $\n+.Dd $Mdocdate: November 30 2016 $\n .Dt SSH-AGENT 1\n .Os\n .Sh NAME\n@@ -47,6 +47,7 @@\n .Op Fl a Ar bind_address\n .Op Fl E Ar fingerprint_hash\n .Op Fl t Ar life\n+.Op Fl P Ar pkcs11_whitelist\n .Op Ar command Op Ar arg ...\n .Nm ssh-agent\n .Op Fl c | s\n@@ -121,6 +122,18 @@ The default is\n Kill the current agent (given by the\n .Ev SSH_AGENT_PID\n environment variable).\n+.It Fl P\n+Specify a pattern-list of acceptable paths for PKCS#11 shared libraries\n+that may be added using the\n+.Fl s\n+option to\n+.Xr ssh-add 1 .\n+The default is to allow loading PKCS#11 libraries from\n+.Dq /usr/lib/*,/usr/local/lib/* .\n+PKCS#11 libraries that do not match the whitelist will be refused.\n+See PATTERNS in\n+.Xr ssh_config 5\n+for a description of pattern-list syntax.\n .It Fl s\n Generate Bourne shell commands on\n .Dv stdout .""}<_**next**_>{""sha"": ""4a91f36d3ffa45013f276417161e6dc5d63e9363"", ""filename"": ""usr.bin/ssh/ssh-agent.c"", ""status"": ""modified"", ""additions"": 35, ""deletions"": 8, ""changes"": 43, ""blob_url"": ""https://github.com/openbsd/src/blob/9476ce1dd37d3c3218d5640b74c34c65e5f4efe5/usr.bin/ssh/ssh-agent.c"", ""raw_url"": ""https://github.com/openbsd/src/raw/9476ce1dd37d3c3218d5640b74c34c65e5f4efe5/usr.bin/ssh/ssh-agent.c"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/ssh-agent.c?ref=9476ce1dd37d3c3218d5640b74c34c65e5f4efe5"", ""patch"": ""@@ -1,4 +1,4 @@\n-/* $OpenBSD: ssh-agent.c,v 1.214 2016/09/12 01:22:38 deraadt Exp $ */\n+/* $OpenBSD: ssh-agent.c,v 1.215 2016/11/30 03:07:37 djm Exp $ */\n /*\n  * Author: Tatu Ylonen <ylo@cs.hut.fi>\n  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n@@ -69,11 +69,16 @@\n #include \""misc.h\""\n #include \""digest.h\""\n #include \""ssherr.h\""\n+#include \""match.h\""\n \n #ifdef ENABLE_PKCS11\n #include \""ssh-pkcs11.h\""\n #endif\n \n+#ifndef DEFAULT_PKCS11_WHITELIST\n+# define DEFAULT_PKCS11_WHITELIST \""/usr/lib/*,/usr/local/lib/*\""\n+#endif\n+\n typedef enum {\n \tAUTH_UNUSED,\n \tAUTH_SOCKET,\n@@ -121,6 +126,9 @@ pid_t cleanup_pid = 0;\n char socket_name[PATH_MAX];\n char socket_dir[PATH_MAX];\n \n+/* PKCS#11 path whitelist */\n+static char *pkcs11_whitelist;\n+\n /* locking */\n #define LOCK_SIZE\t32\n #define LOCK_SALT_SIZE\t16\n@@ -724,7 +732,7 @@ no_identities(SocketEntry *e, u_int type)\n static void\n process_add_smartcard_key(SocketEntry *e)\n {\n-\tchar *provider = NULL, *pin;\n+\tchar *provider = NULL, *pin, canonical_provider[PATH_MAX];\n \tint r, i, version, count = 0, success = 0, confirm = 0;\n \tu_int seconds;\n \ttime_t death = 0;\n@@ -756,19 +764,30 @@ process_add_smartcard_key(SocketEntry *e)\n \t\t\tgoto send;\n \t\t}\n \t}\n+\tif (realpath(provider, canonical_provider) == NULL) {\n+\t\tverbose(\""failed PKCS#11 add of \\\""%.100s\\\"": realpath: %s\"",\n+\t\t    provider, strerror(errno));\n+\t\tgoto send;\n+\t}\n+\tif (match_pattern_list(canonical_provider, pkcs11_whitelist, 0) != 1) {\n+\t\tverbose(\""refusing PKCS#11 add of \\\""%.100s\\\"": \""\n+\t\t    \""provider not whitelisted\"", canonical_provider);\n+\t\tgoto send;\n+\t}\n+\tdebug(\""%s: add %.100s\"", __func__, canonical_provider);\n \tif (lifetime && !death)\n \t\tdeath = monotime() + lifetime;\n \n-\tcount = pkcs11_add_provider(provider, pin, &keys);\n+\tcount = pkcs11_add_provider(canonical_provider, pin, &keys);\n \tfor (i = 0; i < count; i++) {\n \t\tk = keys[i];\n \t\tversion = k->type == KEY_RSA1 ? 1 : 2;\n \t\ttab = idtab_lookup(version);\n \t\tif (lookup_identity(k, version) == NULL) {\n \t\t\tid = xcalloc(1, sizeof(Identity));\n \t\t\tid->key = k;\n-\t\t\tid->provider = xstrdup(provider);\n-\t\t\tid->comment = xstrdup(provider); /* XXX */\n+\t\t\tid->provider = xstrdup(canonical_provider);\n+\t\t\tid->comment = xstrdup(canonical_provider); /* XXX */\n \t\t\tid->death = death;\n \t\t\tid->confirm = confirm;\n \t\t\tTAILQ_INSERT_TAIL(&tab->idlist, id, next);\n@@ -1157,7 +1176,7 @@ usage(void)\n {\n \tfprintf(stderr,\n \t    \""usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\""\n-\t    \""                 [-t life] [command [arg ...]]\\n\""\n+\t    \""                 [-P pkcs11_whitelist] [-t life] [command [arg ...]]\\n\""\n \t    \""       ssh-agent [-c | -s] -k\\n\"");\n \texit(1);\n }\n@@ -1191,7 +1210,7 @@ main(int ac, char **av)\n \tOpenSSL_add_all_algorithms();\n #endif\n \n-\twhile ((ch = getopt(ac, av, \""cDdksE:a:t:\"")) != -1) {\n+\twhile ((ch = getopt(ac, av, \""cDdksE:a:P:t:\"")) != -1) {\n \t\tswitch (ch) {\n \t\tcase 'E':\n \t\t\tfingerprint_hash = ssh_digest_alg_by_name(optarg);\n@@ -1206,6 +1225,11 @@ main(int ac, char **av)\n \t\tcase 'k':\n \t\t\tk_flag++;\n \t\t\tbreak;\n+\t\tcase 'P':\n+\t\t\tif (pkcs11_whitelist != NULL)\n+\t\t\t\tfatal(\""-P option already specified\"");\n+\t\t\tpkcs11_whitelist = xstrdup(optarg);\n+\t\t\tbreak;\n \t\tcase 's':\n \t\t\tif (c_flag)\n \t\t\t\tusage();\n@@ -1240,6 +1264,9 @@ main(int ac, char **av)\n \tif (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))\n \t\tusage();\n \n+\tif (pkcs11_whitelist == NULL)\n+\t\tpkcs11_whitelist = xstrdup(DEFAULT_PKCS11_WHITELIST);\n+\n \tif (ac == 0 && !c_flag && !s_flag) {\n \t\tshell = getenv(\""SHELL\"");\n \t\tif (shell != NULL && (len = strlen(shell)) > 2 &&\n@@ -1385,7 +1412,7 @@ main(int ac, char **av)\n \tsignal(SIGTERM, cleanup_handler);\n \tnalloc = 0;\n \n-\tif (pledge(\""stdio cpath unix id proc exec\"", NULL) == -1)\n+\tif (pledge(\""stdio rpath cpath unix id proc exec\"", NULL) == -1)\n \t\tfatal(\""%s: pledge: %s\"", __progname, strerror(errno));\n \n \twhile (1) {""}","main(int ac, char **av)
{
	int c_flag = 0, d_flag = 0, D_flag = 0, k_flag = 0, s_flag = 0;
	int sock, fd, ch, result, saved_errno;
	u_int nalloc;
	char *shell, *format, *pidstr, *agentsocket = NULL;
	fd_set *readsetp = NULL, *writesetp = NULL;
	struct rlimit rlim;
	extern int optind;
	extern char *optarg;
	pid_t pid;
	char pidstrbuf[1 + 3 * sizeof pid];
	struct timeval *tvp = NULL;
	size_t len;
	mode_t prev_mask;

	ssh_malloc_init();	/* must be called before any mallocs */
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

	/* drop */
	setegid(getgid());
	setgid(getgid());

#ifdef WITH_OPENSSL
 	OpenSSL_add_all_algorithms();
 #endif
 
	while ((ch = getopt(ac, av, ""cDdksE:a:P:t:"")) != -1) {
 		switch (ch) {
 		case 'E':
 			fingerprint_hash = ssh_digest_alg_by_name(optarg);
			if (fingerprint_hash == -1)
				fatal(""Invalid hash algorithm \""%s\"""", optarg);
			break;
		case 'c':
			if (s_flag)
				usage();
			c_flag++;
			break;
 		case 'k':
 			k_flag++;
 			break;
		case 'P':
			if (pkcs11_whitelist != NULL)
				fatal(""-P option already specified"");
			pkcs11_whitelist = xstrdup(optarg);
			break;
 		case 's':
 			if (c_flag)
 				usage();
			s_flag++;
			break;
		case 'd':
			if (d_flag || D_flag)
				usage();
			d_flag++;
			break;
		case 'D':
			if (d_flag || D_flag)
				usage();
			D_flag++;
			break;
		case 'a':
			agentsocket = optarg;
			break;
		case 't':
			if ((lifetime = convtime(optarg)) == -1) {
				fprintf(stderr, ""Invalid lifetime\n"");
				usage();
			}
			break;
		default:
			usage();
		}
	}
	ac -= optind;
	av += optind;

 	if (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))
 		usage();
 
	if (pkcs11_whitelist == NULL)
		pkcs11_whitelist = xstrdup(DEFAULT_PKCS11_WHITELIST);

 	if (ac == 0 && !c_flag && !s_flag) {
 		shell = getenv(""SHELL"");
 		if (shell != NULL && (len = strlen(shell)) > 2 &&
		    strncmp(shell + len - 3, ""csh"", 3) == 0)
			c_flag = 1;
	}
	if (k_flag) {
		const char *errstr = NULL;

		pidstr = getenv(SSH_AGENTPID_ENV_NAME);
		if (pidstr == NULL) {
			fprintf(stderr, ""%s not set, cannot kill agent\n"",
			    SSH_AGENTPID_ENV_NAME);
			exit(1);
		}
		pid = (int)strtonum(pidstr, 2, INT_MAX, &errstr);
		if (errstr) {
			fprintf(stderr,
			    ""%s=\""%s\"", which is not a good PID: %s\n"",
			    SSH_AGENTPID_ENV_NAME, pidstr, errstr);
			exit(1);
		}
		if (kill(pid, SIGTERM) == -1) {
			perror(""kill"");
			exit(1);
		}
		format = c_flag ? ""unsetenv %s;\n"" : ""unset %s;\n"";
		printf(format, SSH_AUTHSOCKET_ENV_NAME);
		printf(format, SSH_AGENTPID_ENV_NAME);
		printf(""echo Agent pid %ld killed;\n"", (long)pid);
		exit(0);
	}
	parent_pid = getpid();

	if (agentsocket == NULL) {
		/* Create private directory for agent socket */
		mktemp_proto(socket_dir, sizeof(socket_dir));
		if (mkdtemp(socket_dir) == NULL) {
			perror(""mkdtemp: private socket dir"");
			exit(1);
		}
		snprintf(socket_name, sizeof socket_name, ""%s/agent.%ld"", socket_dir,
		    (long)parent_pid);
	} else {
		/* Try to use specified agent socket */
		socket_dir[0] = '\0';
		strlcpy(socket_name, agentsocket, sizeof socket_name);
	}

	/*
	 * Create socket early so it will exist before command gets run from
	 * the parent.
	 */
	prev_mask = umask(0177);
	sock = unix_listener(socket_name, SSH_LISTEN_BACKLOG, 0);
	if (sock < 0) {
		/* XXX - unix_listener() calls error() not perror() */
		*socket_name = '\0'; /* Don't unlink any existing file */
		cleanup_exit(1);
	}
	umask(prev_mask);

	/*
	 * Fork, and have the parent execute the command, if any, or present
	 * the socket data.  The child continues as the authentication agent.
	 */
	if (D_flag || d_flag) {
		log_init(__progname,
		    d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO,
		    SYSLOG_FACILITY_AUTH, 1);
		format = c_flag ? ""setenv %s %s;\n"" : ""%s=%s; export %s;\n"";
		printf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,
		    SSH_AUTHSOCKET_ENV_NAME);
		printf(""echo Agent pid %ld;\n"", (long)parent_pid);
		fflush(stdout);
		goto skip;
	}
	pid = fork();
	if (pid == -1) {
		perror(""fork"");
		cleanup_exit(1);
	}
	if (pid != 0) {		/* Parent - execute the given command. */
		close(sock);
		snprintf(pidstrbuf, sizeof pidstrbuf, ""%ld"", (long)pid);
		if (ac == 0) {
			format = c_flag ? ""setenv %s %s;\n"" : ""%s=%s; export %s;\n"";
			printf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,
			    SSH_AUTHSOCKET_ENV_NAME);
			printf(format, SSH_AGENTPID_ENV_NAME, pidstrbuf,
			    SSH_AGENTPID_ENV_NAME);
			printf(""echo Agent pid %ld;\n"", (long)pid);
			exit(0);
		}
		if (setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1) == -1 ||
		    setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1) == -1) {
			perror(""setenv"");
			exit(1);
		}
		execvp(av[0], av);
		perror(av[0]);
		exit(1);
	}
	/* child */
	log_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);

	if (setsid() == -1) {
		error(""setsid: %s"", strerror(errno));
		cleanup_exit(1);
	}

	(void)chdir(""/"");
	if ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {
		/* XXX might close listen socket */
		(void)dup2(fd, STDIN_FILENO);
		(void)dup2(fd, STDOUT_FILENO);
		(void)dup2(fd, STDERR_FILENO);
		if (fd > 2)
			close(fd);
	}

	/* deny core dumps, since memory contains unencrypted private keys */
	rlim.rlim_cur = rlim.rlim_max = 0;
	if (setrlimit(RLIMIT_CORE, &rlim) < 0) {
		error(""setrlimit RLIMIT_CORE: %s"", strerror(errno));
		cleanup_exit(1);
	}

skip:

	cleanup_pid = getpid();

#ifdef ENABLE_PKCS11
	pkcs11_init(0);
#endif
	new_socket(AUTH_SOCKET, sock);
	if (ac > 0)
		parent_alive_interval = 10;
	idtab_init();
	signal(SIGPIPE, SIG_IGN);
	signal(SIGINT, (d_flag | D_flag) ? cleanup_handler : SIG_IGN);
	signal(SIGHUP, cleanup_handler);
 	signal(SIGTERM, cleanup_handler);
 	nalloc = 0;
 
	if (pledge(""stdio rpath cpath unix id proc exec"", NULL) == -1)
 		fatal(""%s: pledge: %s"", __progname, strerror(errno));
 
 	while (1) {
		prepare_select(&readsetp, &writesetp, &max_fd, &nalloc, &tvp);
		result = select(max_fd + 1, readsetp, writesetp, NULL, tvp);
		saved_errno = errno;
		if (parent_alive_interval != 0)
			check_parent_exists();
		(void) reaper();	/* remove expired keys */
		if (result < 0) {
			if (saved_errno == EINTR)
				continue;
			fatal(""select: %s"", strerror(saved_errno));
		} else if (result > 0)
			after_select(readsetp, writesetp);
	}
	/* NOTREACHED */
}
","main(int ac, char **av)
{
	int c_flag = 0, d_flag = 0, D_flag = 0, k_flag = 0, s_flag = 0;
	int sock, fd, ch, result, saved_errno;
	u_int nalloc;
	char *shell, *format, *pidstr, *agentsocket = NULL;
	fd_set *readsetp = NULL, *writesetp = NULL;
	struct rlimit rlim;
	extern int optind;
	extern char *optarg;
	pid_t pid;
	char pidstrbuf[1 + 3 * sizeof pid];
	struct timeval *tvp = NULL;
	size_t len;
	mode_t prev_mask;

	ssh_malloc_init();	/* must be called before any mallocs */
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

	/* drop */
	setegid(getgid());
	setgid(getgid());

#ifdef WITH_OPENSSL
 	OpenSSL_add_all_algorithms();
 #endif
 
	while ((ch = getopt(ac, av, ""cDdksE:a:t:"")) != -1) {
 		switch (ch) {
 		case 'E':
 			fingerprint_hash = ssh_digest_alg_by_name(optarg);
			if (fingerprint_hash == -1)
				fatal(""Invalid hash algorithm \""%s\"""", optarg);
			break;
		case 'c':
			if (s_flag)
				usage();
			c_flag++;
			break;
 		case 'k':
 			k_flag++;
 			break;
 		case 's':
 			if (c_flag)
 				usage();
			s_flag++;
			break;
		case 'd':
			if (d_flag || D_flag)
				usage();
			d_flag++;
			break;
		case 'D':
			if (d_flag || D_flag)
				usage();
			D_flag++;
			break;
		case 'a':
			agentsocket = optarg;
			break;
		case 't':
			if ((lifetime = convtime(optarg)) == -1) {
				fprintf(stderr, ""Invalid lifetime\n"");
				usage();
			}
			break;
		default:
			usage();
		}
	}
	ac -= optind;
	av += optind;

 	if (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))
 		usage();
 
 	if (ac == 0 && !c_flag && !s_flag) {
 		shell = getenv(""SHELL"");
 		if (shell != NULL && (len = strlen(shell)) > 2 &&
		    strncmp(shell + len - 3, ""csh"", 3) == 0)
			c_flag = 1;
	}
	if (k_flag) {
		const char *errstr = NULL;

		pidstr = getenv(SSH_AGENTPID_ENV_NAME);
		if (pidstr == NULL) {
			fprintf(stderr, ""%s not set, cannot kill agent\n"",
			    SSH_AGENTPID_ENV_NAME);
			exit(1);
		}
		pid = (int)strtonum(pidstr, 2, INT_MAX, &errstr);
		if (errstr) {
			fprintf(stderr,
			    ""%s=\""%s\"", which is not a good PID: %s\n"",
			    SSH_AGENTPID_ENV_NAME, pidstr, errstr);
			exit(1);
		}
		if (kill(pid, SIGTERM) == -1) {
			perror(""kill"");
			exit(1);
		}
		format = c_flag ? ""unsetenv %s;\n"" : ""unset %s;\n"";
		printf(format, SSH_AUTHSOCKET_ENV_NAME);
		printf(format, SSH_AGENTPID_ENV_NAME);
		printf(""echo Agent pid %ld killed;\n"", (long)pid);
		exit(0);
	}
	parent_pid = getpid();

	if (agentsocket == NULL) {
		/* Create private directory for agent socket */
		mktemp_proto(socket_dir, sizeof(socket_dir));
		if (mkdtemp(socket_dir) == NULL) {
			perror(""mkdtemp: private socket dir"");
			exit(1);
		}
		snprintf(socket_name, sizeof socket_name, ""%s/agent.%ld"", socket_dir,
		    (long)parent_pid);
	} else {
		/* Try to use specified agent socket */
		socket_dir[0] = '\0';
		strlcpy(socket_name, agentsocket, sizeof socket_name);
	}

	/*
	 * Create socket early so it will exist before command gets run from
	 * the parent.
	 */
	prev_mask = umask(0177);
	sock = unix_listener(socket_name, SSH_LISTEN_BACKLOG, 0);
	if (sock < 0) {
		/* XXX - unix_listener() calls error() not perror() */
		*socket_name = '\0'; /* Don't unlink any existing file */
		cleanup_exit(1);
	}
	umask(prev_mask);

	/*
	 * Fork, and have the parent execute the command, if any, or present
	 * the socket data.  The child continues as the authentication agent.
	 */
	if (D_flag || d_flag) {
		log_init(__progname,
		    d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO,
		    SYSLOG_FACILITY_AUTH, 1);
		format = c_flag ? ""setenv %s %s;\n"" : ""%s=%s; export %s;\n"";
		printf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,
		    SSH_AUTHSOCKET_ENV_NAME);
		printf(""echo Agent pid %ld;\n"", (long)parent_pid);
		fflush(stdout);
		goto skip;
	}
	pid = fork();
	if (pid == -1) {
		perror(""fork"");
		cleanup_exit(1);
	}
	if (pid != 0) {		/* Parent - execute the given command. */
		close(sock);
		snprintf(pidstrbuf, sizeof pidstrbuf, ""%ld"", (long)pid);
		if (ac == 0) {
			format = c_flag ? ""setenv %s %s;\n"" : ""%s=%s; export %s;\n"";
			printf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,
			    SSH_AUTHSOCKET_ENV_NAME);
			printf(format, SSH_AGENTPID_ENV_NAME, pidstrbuf,
			    SSH_AGENTPID_ENV_NAME);
			printf(""echo Agent pid %ld;\n"", (long)pid);
			exit(0);
		}
		if (setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1) == -1 ||
		    setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1) == -1) {
			perror(""setenv"");
			exit(1);
		}
		execvp(av[0], av);
		perror(av[0]);
		exit(1);
	}
	/* child */
	log_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);

	if (setsid() == -1) {
		error(""setsid: %s"", strerror(errno));
		cleanup_exit(1);
	}

	(void)chdir(""/"");
	if ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {
		/* XXX might close listen socket */
		(void)dup2(fd, STDIN_FILENO);
		(void)dup2(fd, STDOUT_FILENO);
		(void)dup2(fd, STDERR_FILENO);
		if (fd > 2)
			close(fd);
	}

	/* deny core dumps, since memory contains unencrypted private keys */
	rlim.rlim_cur = rlim.rlim_max = 0;
	if (setrlimit(RLIMIT_CORE, &rlim) < 0) {
		error(""setrlimit RLIMIT_CORE: %s"", strerror(errno));
		cleanup_exit(1);
	}

skip:

	cleanup_pid = getpid();

#ifdef ENABLE_PKCS11
	pkcs11_init(0);
#endif
	new_socket(AUTH_SOCKET, sock);
	if (ac > 0)
		parent_alive_interval = 10;
	idtab_init();
	signal(SIGPIPE, SIG_IGN);
	signal(SIGINT, (d_flag | D_flag) ? cleanup_handler : SIG_IGN);
	signal(SIGHUP, cleanup_handler);
 	signal(SIGTERM, cleanup_handler);
 	nalloc = 0;
 
	if (pledge(""stdio cpath unix id proc exec"", NULL) == -1)
 		fatal(""%s: pledge: %s"", __progname, strerror(errno));
 
 	while (1) {
		prepare_select(&readsetp, &writesetp, &max_fd, &nalloc, &tvp);
		result = select(max_fd + 1, readsetp, writesetp, NULL, tvp);
		saved_errno = errno;
		if (parent_alive_interval != 0)
			check_parent_exists();
		(void) reaper();	/* remove expired keys */
		if (result < 0) {
			if (saved_errno == EINTR)
				continue;
			fatal(""select: %s"", strerror(saved_errno));
		} else if (result > 0)
			after_select(readsetp, writesetp);
	}
	/* NOTREACHED */
}
",C,"	while ((ch = getopt(ac, av, ""cDdksE:a:P:t:"")) != -1) {
		case 'P':
			if (pkcs11_whitelist != NULL)
				fatal(""-P option already specified"");
			pkcs11_whitelist = xstrdup(optarg);
			break;
	if (pkcs11_whitelist == NULL)
		pkcs11_whitelist = xstrdup(DEFAULT_PKCS11_WHITELIST);

	if (pledge(""stdio rpath cpath unix id proc exec"", NULL) == -1)
","	while ((ch = getopt(ac, av, ""cDdksE:a:t:"")) != -1) {
	if (pledge(""stdio cpath unix id proc exec"", NULL) == -1)
",,"@@ -1,4 +1,4 @@
-/* $OpenBSD: ssh-agent.c,v 1.214 2016/09/12 01:22:38 deraadt Exp $ */
+/* $OpenBSD: ssh-agent.c,v 1.215 2016/11/30 03:07:37 djm Exp $ */
 /*
  * Author: Tatu Ylonen <ylo@cs.hut.fi>
  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
@@ -69,11 +69,16 @@
 #include ""misc.h""
 #include ""digest.h""
 #include ""ssherr.h""
+#include ""match.h""
 
 #ifdef ENABLE_PKCS11
 #include ""ssh-pkcs11.h""
 #endif
 
+#ifndef DEFAULT_PKCS11_WHITELIST
+# define DEFAULT_PKCS11_WHITELIST ""/usr/lib/*,/usr/local/lib/*""
+#endif
+
 typedef enum {
 	AUTH_UNUSED,
 	AUTH_SOCKET,
@@ -121,6 +126,9 @@ pid_t cleanup_pid = 0;
 char socket_name[PATH_MAX];
 char socket_dir[PATH_MAX];
 
+/* PKCS#11 path whitelist */
+static char *pkcs11_whitelist;
+
 /* locking */
 #define LOCK_SIZE	32
 #define LOCK_SALT_SIZE	16
@@ -724,7 +732,7 @@ no_identities(SocketEntry *e, u_int type)
 static void
 process_add_smartcard_key(SocketEntry *e)
 {
-	char *provider = NULL, *pin;
+	char *provider = NULL, *pin, canonical_provider[PATH_MAX];
 	int r, i, version, count = 0, success = 0, confirm = 0;
 	u_int seconds;
 	time_t death = 0;
@@ -756,19 +764,30 @@ process_add_smartcard_key(SocketEntry *e)
 			goto send;
 		}
 	}
+	if (realpath(provider, canonical_provider) == NULL) {
+		verbose(""failed PKCS#11 add of \""%.100s\"": realpath: %s"",
+		    provider, strerror(errno));
+		goto send;
+	}
+	if (match_pattern_list(canonical_provider, pkcs11_whitelist, 0) != 1) {
+		verbose(""refusing PKCS#11 add of \""%.100s\"": ""
+		    ""provider not whitelisted"", canonical_provider);
+		goto send;
+	}
+	debug(""%s: add %.100s"", __func__, canonical_provider);
 	if (lifetime && !death)
 		death = monotime() + lifetime;
 
-	count = pkcs11_add_provider(provider, pin, &keys);
+	count = pkcs11_add_provider(canonical_provider, pin, &keys);
 	for (i = 0; i < count; i++) {
 		k = keys[i];
 		version = k->type == KEY_RSA1 ? 1 : 2;
 		tab = idtab_lookup(version);
 		if (lookup_identity(k, version) == NULL) {
 			id = xcalloc(1, sizeof(Identity));
 			id->key = k;
-			id->provider = xstrdup(provider);
-			id->comment = xstrdup(provider); /* XXX */
+			id->provider = xstrdup(canonical_provider);
+			id->comment = xstrdup(canonical_provider); /* XXX */
 			id->death = death;
 			id->confirm = confirm;
 			TAILQ_INSERT_TAIL(&tab->idlist, id, next);
@@ -1157,7 +1176,7 @@ usage(void)
 {
 	fprintf(stderr,
 	    ""usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\n""
-	    ""                 [-t life] [command [arg ...]]\n""
+	    ""                 [-P pkcs11_whitelist] [-t life] [command [arg ...]]\n""
 	    ""       ssh-agent [-c | -s] -k\n"");
 	exit(1);
 }
@@ -1191,7 +1210,7 @@ main(int ac, char **av)
 	OpenSSL_add_all_algorithms();
 #endif
 
-	while ((ch = getopt(ac, av, ""cDdksE:a:t:"")) != -1) {
+	while ((ch = getopt(ac, av, ""cDdksE:a:P:t:"")) != -1) {
 		switch (ch) {
 		case 'E':
 			fingerprint_hash = ssh_digest_alg_by_name(optarg);
@@ -1206,6 +1225,11 @@ main(int ac, char **av)
 		case 'k':
 			k_flag++;
 			break;
+		case 'P':
+			if (pkcs11_whitelist != NULL)
+				fatal(""-P option already specified"");
+			pkcs11_whitelist = xstrdup(optarg);
+			break;
 		case 's':
 			if (c_flag)
 				usage();
@@ -1240,6 +1264,9 @@ main(int ac, char **av)
 	if (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))
 		usage();
 
+	if (pkcs11_whitelist == NULL)
+		pkcs11_whitelist = xstrdup(DEFAULT_PKCS11_WHITELIST);
+
 	if (ac == 0 && !c_flag && !s_flag) {
 		shell = getenv(""SHELL"");
 		if (shell != NULL && (len = strlen(shell)) > 2 &&
@@ -1385,7 +1412,7 @@ main(int ac, char **av)
 	signal(SIGTERM, cleanup_handler);
 	nalloc = 0;
 
-	if (pledge(""stdio cpath unix id proc exec"", NULL) == -1)
+	if (pledge(""stdio rpath cpath unix id proc exec"", NULL) == -1)
 		fatal(""%s: pledge: %s"", __progname, strerror(errno));
 
 	while (1) {",src,9476ce1dd37d3c3218d5640b74c34c65e5f4efe5,5eecd4ed02a939575543e46dd71909c863e43419,1,"main(int ac, char **av)
{
	int c_flag = 0, d_flag = 0, D_flag = 0, k_flag = 0, s_flag = 0;
	int sock, fd, ch, result, saved_errno;
	u_int nalloc;
	char *shell, *format, *pidstr, *agentsocket = NULL;
	fd_set *readsetp = NULL, *writesetp = NULL;
	struct rlimit rlim;
	extern int optind;
	extern char *optarg;
	pid_t pid;
	char pidstrbuf[1 + 3 * sizeof pid];
	struct timeval *tvp = NULL;
	size_t len;
	mode_t prev_mask;

	ssh_malloc_init();	/* must be called before any mallocs */
	/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
	sanitise_stdfd();

	/* drop */
	setegid(getgid());
	setgid(getgid());

#ifdef WITH_OPENSSL
 	OpenSSL_add_all_algorithms();
 #endif
 
//flaw_line_below:
	while ((ch = getopt(ac, av, ""cDdksE:a:t:"")) != -1) {
//fix_flaw_line_below:
//	while ((ch = getopt(ac, av, ""cDdksE:a:P:t:"")) != -1) {
 		switch (ch) {
 		case 'E':
 			fingerprint_hash = ssh_digest_alg_by_name(optarg);
			if (fingerprint_hash == -1)
				fatal(""Invalid hash algorithm \""%s\"""", optarg);
			break;
		case 'c':
			if (s_flag)
				usage();
			c_flag++;
			break;
 		case 'k':
 			k_flag++;
 			break;
//fix_flaw_line_below:
//		case 'P':
//fix_flaw_line_below:
//			if (pkcs11_whitelist != NULL)
//fix_flaw_line_below:
//				fatal(""-P option already specified"");
//fix_flaw_line_below:
//			pkcs11_whitelist = xstrdup(optarg);
//fix_flaw_line_below:
//			break;
 		case 's':
 			if (c_flag)
 				usage();
			s_flag++;
			break;
		case 'd':
			if (d_flag || D_flag)
				usage();
			d_flag++;
			break;
		case 'D':
			if (d_flag || D_flag)
				usage();
			D_flag++;
			break;
		case 'a':
			agentsocket = optarg;
			break;
		case 't':
			if ((lifetime = convtime(optarg)) == -1) {
				fprintf(stderr, ""Invalid lifetime\n"");
				usage();
			}
			break;
		default:
			usage();
		}
	}
	ac -= optind;
	av += optind;

 	if (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))
 		usage();
 
//fix_flaw_line_below:
//	if (pkcs11_whitelist == NULL)
//fix_flaw_line_below:
//		pkcs11_whitelist = xstrdup(DEFAULT_PKCS11_WHITELIST);
//fix_flaw_line_below:
//
 	if (ac == 0 && !c_flag && !s_flag) {
 		shell = getenv(""SHELL"");
 		if (shell != NULL && (len = strlen(shell)) > 2 &&
		    strncmp(shell + len - 3, ""csh"", 3) == 0)
			c_flag = 1;
	}
	if (k_flag) {
		const char *errstr = NULL;

		pidstr = getenv(SSH_AGENTPID_ENV_NAME);
		if (pidstr == NULL) {
			fprintf(stderr, ""%s not set, cannot kill agent\n"",
			    SSH_AGENTPID_ENV_NAME);
			exit(1);
		}
		pid = (int)strtonum(pidstr, 2, INT_MAX, &errstr);
		if (errstr) {
			fprintf(stderr,
			    ""%s=\""%s\"", which is not a good PID: %s\n"",
			    SSH_AGENTPID_ENV_NAME, pidstr, errstr);
			exit(1);
		}
		if (kill(pid, SIGTERM) == -1) {
			perror(""kill"");
			exit(1);
		}
		format = c_flag ? ""unsetenv %s;\n"" : ""unset %s;\n"";
		printf(format, SSH_AUTHSOCKET_ENV_NAME);
		printf(format, SSH_AGENTPID_ENV_NAME);
		printf(""echo Agent pid %ld killed;\n"", (long)pid);
		exit(0);
	}
	parent_pid = getpid();

	if (agentsocket == NULL) {
		/* Create private directory for agent socket */
		mktemp_proto(socket_dir, sizeof(socket_dir));
		if (mkdtemp(socket_dir) == NULL) {
			perror(""mkdtemp: private socket dir"");
			exit(1);
		}
		snprintf(socket_name, sizeof socket_name, ""%s/agent.%ld"", socket_dir,
		    (long)parent_pid);
	} else {
		/* Try to use specified agent socket */
		socket_dir[0] = '\0';
		strlcpy(socket_name, agentsocket, sizeof socket_name);
	}

	/*
	 * Create socket early so it will exist before command gets run from
	 * the parent.
	 */
	prev_mask = umask(0177);
	sock = unix_listener(socket_name, SSH_LISTEN_BACKLOG, 0);
	if (sock < 0) {
		/* XXX - unix_listener() calls error() not perror() */
		*socket_name = '\0'; /* Don't unlink any existing file */
		cleanup_exit(1);
	}
	umask(prev_mask);

	/*
	 * Fork, and have the parent execute the command, if any, or present
	 * the socket data.  The child continues as the authentication agent.
	 */
	if (D_flag || d_flag) {
		log_init(__progname,
		    d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO,
		    SYSLOG_FACILITY_AUTH, 1);
		format = c_flag ? ""setenv %s %s;\n"" : ""%s=%s; export %s;\n"";
		printf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,
		    SSH_AUTHSOCKET_ENV_NAME);
		printf(""echo Agent pid %ld;\n"", (long)parent_pid);
		fflush(stdout);
		goto skip;
	}
	pid = fork();
	if (pid == -1) {
		perror(""fork"");
		cleanup_exit(1);
	}
	if (pid != 0) {		/* Parent - execute the given command. */
		close(sock);
		snprintf(pidstrbuf, sizeof pidstrbuf, ""%ld"", (long)pid);
		if (ac == 0) {
			format = c_flag ? ""setenv %s %s;\n"" : ""%s=%s; export %s;\n"";
			printf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,
			    SSH_AUTHSOCKET_ENV_NAME);
			printf(format, SSH_AGENTPID_ENV_NAME, pidstrbuf,
			    SSH_AGENTPID_ENV_NAME);
			printf(""echo Agent pid %ld;\n"", (long)pid);
			exit(0);
		}
		if (setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1) == -1 ||
		    setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1) == -1) {
			perror(""setenv"");
			exit(1);
		}
		execvp(av[0], av);
		perror(av[0]);
		exit(1);
	}
	/* child */
	log_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);

	if (setsid() == -1) {
		error(""setsid: %s"", strerror(errno));
		cleanup_exit(1);
	}

	(void)chdir(""/"");
	if ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {
		/* XXX might close listen socket */
		(void)dup2(fd, STDIN_FILENO);
		(void)dup2(fd, STDOUT_FILENO);
		(void)dup2(fd, STDERR_FILENO);
		if (fd > 2)
			close(fd);
	}

	/* deny core dumps, since memory contains unencrypted private keys */
	rlim.rlim_cur = rlim.rlim_max = 0;
	if (setrlimit(RLIMIT_CORE, &rlim) < 0) {
		error(""setrlimit RLIMIT_CORE: %s"", strerror(errno));
		cleanup_exit(1);
	}

skip:

	cleanup_pid = getpid();

#ifdef ENABLE_PKCS11
	pkcs11_init(0);
#endif
	new_socket(AUTH_SOCKET, sock);
	if (ac > 0)
		parent_alive_interval = 10;
	idtab_init();
	signal(SIGPIPE, SIG_IGN);
	signal(SIGINT, (d_flag | D_flag) ? cleanup_handler : SIG_IGN);
	signal(SIGHUP, cleanup_handler);
 	signal(SIGTERM, cleanup_handler);
 	nalloc = 0;
 
//flaw_line_below:
	if (pledge(""stdio cpath unix id proc exec"", NULL) == -1)
//fix_flaw_line_below:
//	if (pledge(""stdio rpath cpath unix id proc exec"", NULL) == -1)
 		fatal(""%s: pledge: %s"", __progname, strerror(errno));
 
 	while (1) {
		prepare_select(&readsetp, &writesetp, &max_fd, &nalloc, &tvp);
		result = select(max_fd + 1, readsetp, writesetp, NULL, tvp);
		saved_errno = errno;
		if (parent_alive_interval != 0)
			check_parent_exists();
		(void) reaper();	/* remove expired keys */
		if (result < 0) {
			if (saved_errno == EINTR)
				continue;
			fatal(""select: %s"", strerror(saved_errno));
		} else if (result > 0)
			after_select(readsetp, writesetp);
	}
	/* NOTREACHED */
}
"
4100,181836,,Remote,Not required,Partial,CVE-2016-10009,https://www.cvedetails.com/cve/CVE-2016-10009/,CWE-426,Low,Partial,Partial,,2017-01-04,7.5,Untrusted search path vulnerability in ssh-agent.c in ssh-agent in OpenSSH before 7.4 allows remote attackers to execute arbitrary local PKCS#11 modules by leveraging control over a forwarded agent-socket.,2018-09-11,,15,https://github.com/openbsd/src/commit/9476ce1dd37d3c3218d5640b74c34c65e5f4efe5,9476ce1dd37d3c3218d5640b74c34c65e5f4efe5,"add a whitelist of paths from which ssh-agent will load (via
ssh-pkcs11-helper) a PKCS#11 module; ok markus@",4,usr.bin/ssh/ssh-agent.c,"{""sha"": ""372adbe7c7f52203b16da700601ed979ff58da2d"", ""filename"": ""usr.bin/ssh/ssh-agent.1"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 2, ""changes"": 17, ""blob_url"": ""https://github.com/openbsd/src/blob/9476ce1dd37d3c3218d5640b74c34c65e5f4efe5/usr.bin/ssh/ssh-agent.1"", ""raw_url"": ""https://github.com/openbsd/src/raw/9476ce1dd37d3c3218d5640b74c34c65e5f4efe5/usr.bin/ssh/ssh-agent.1"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/ssh-agent.1?ref=9476ce1dd37d3c3218d5640b74c34c65e5f4efe5"", ""patch"": ""@@ -1,4 +1,4 @@\n-.\\\"" $OpenBSD: ssh-agent.1,v 1.62 2015/11/15 23:54:15 jmc Exp $\n+.\\\"" $OpenBSD: ssh-agent.1,v 1.63 2016/11/30 03:07:37 djm Exp $\n .\\\""\n .\\\"" Author: Tatu Ylonen <ylo@cs.hut.fi>\n .\\\"" Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n@@ -34,7 +34,7 @@\n .\\\"" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n .\\\"" THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n .\\\""\n-.Dd $Mdocdate: November 15 2015 $\n+.Dd $Mdocdate: November 30 2016 $\n .Dt SSH-AGENT 1\n .Os\n .Sh NAME\n@@ -47,6 +47,7 @@\n .Op Fl a Ar bind_address\n .Op Fl E Ar fingerprint_hash\n .Op Fl t Ar life\n+.Op Fl P Ar pkcs11_whitelist\n .Op Ar command Op Ar arg ...\n .Nm ssh-agent\n .Op Fl c | s\n@@ -121,6 +122,18 @@ The default is\n Kill the current agent (given by the\n .Ev SSH_AGENT_PID\n environment variable).\n+.It Fl P\n+Specify a pattern-list of acceptable paths for PKCS#11 shared libraries\n+that may be added using the\n+.Fl s\n+option to\n+.Xr ssh-add 1 .\n+The default is to allow loading PKCS#11 libraries from\n+.Dq /usr/lib/*,/usr/local/lib/* .\n+PKCS#11 libraries that do not match the whitelist will be refused.\n+See PATTERNS in\n+.Xr ssh_config 5\n+for a description of pattern-list syntax.\n .It Fl s\n Generate Bourne shell commands on\n .Dv stdout .""}<_**next**_>{""sha"": ""4a91f36d3ffa45013f276417161e6dc5d63e9363"", ""filename"": ""usr.bin/ssh/ssh-agent.c"", ""status"": ""modified"", ""additions"": 35, ""deletions"": 8, ""changes"": 43, ""blob_url"": ""https://github.com/openbsd/src/blob/9476ce1dd37d3c3218d5640b74c34c65e5f4efe5/usr.bin/ssh/ssh-agent.c"", ""raw_url"": ""https://github.com/openbsd/src/raw/9476ce1dd37d3c3218d5640b74c34c65e5f4efe5/usr.bin/ssh/ssh-agent.c"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/ssh-agent.c?ref=9476ce1dd37d3c3218d5640b74c34c65e5f4efe5"", ""patch"": ""@@ -1,4 +1,4 @@\n-/* $OpenBSD: ssh-agent.c,v 1.214 2016/09/12 01:22:38 deraadt Exp $ */\n+/* $OpenBSD: ssh-agent.c,v 1.215 2016/11/30 03:07:37 djm Exp $ */\n /*\n  * Author: Tatu Ylonen <ylo@cs.hut.fi>\n  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n@@ -69,11 +69,16 @@\n #include \""misc.h\""\n #include \""digest.h\""\n #include \""ssherr.h\""\n+#include \""match.h\""\n \n #ifdef ENABLE_PKCS11\n #include \""ssh-pkcs11.h\""\n #endif\n \n+#ifndef DEFAULT_PKCS11_WHITELIST\n+# define DEFAULT_PKCS11_WHITELIST \""/usr/lib/*,/usr/local/lib/*\""\n+#endif\n+\n typedef enum {\n \tAUTH_UNUSED,\n \tAUTH_SOCKET,\n@@ -121,6 +126,9 @@ pid_t cleanup_pid = 0;\n char socket_name[PATH_MAX];\n char socket_dir[PATH_MAX];\n \n+/* PKCS#11 path whitelist */\n+static char *pkcs11_whitelist;\n+\n /* locking */\n #define LOCK_SIZE\t32\n #define LOCK_SALT_SIZE\t16\n@@ -724,7 +732,7 @@ no_identities(SocketEntry *e, u_int type)\n static void\n process_add_smartcard_key(SocketEntry *e)\n {\n-\tchar *provider = NULL, *pin;\n+\tchar *provider = NULL, *pin, canonical_provider[PATH_MAX];\n \tint r, i, version, count = 0, success = 0, confirm = 0;\n \tu_int seconds;\n \ttime_t death = 0;\n@@ -756,19 +764,30 @@ process_add_smartcard_key(SocketEntry *e)\n \t\t\tgoto send;\n \t\t}\n \t}\n+\tif (realpath(provider, canonical_provider) == NULL) {\n+\t\tverbose(\""failed PKCS#11 add of \\\""%.100s\\\"": realpath: %s\"",\n+\t\t    provider, strerror(errno));\n+\t\tgoto send;\n+\t}\n+\tif (match_pattern_list(canonical_provider, pkcs11_whitelist, 0) != 1) {\n+\t\tverbose(\""refusing PKCS#11 add of \\\""%.100s\\\"": \""\n+\t\t    \""provider not whitelisted\"", canonical_provider);\n+\t\tgoto send;\n+\t}\n+\tdebug(\""%s: add %.100s\"", __func__, canonical_provider);\n \tif (lifetime && !death)\n \t\tdeath = monotime() + lifetime;\n \n-\tcount = pkcs11_add_provider(provider, pin, &keys);\n+\tcount = pkcs11_add_provider(canonical_provider, pin, &keys);\n \tfor (i = 0; i < count; i++) {\n \t\tk = keys[i];\n \t\tversion = k->type == KEY_RSA1 ? 1 : 2;\n \t\ttab = idtab_lookup(version);\n \t\tif (lookup_identity(k, version) == NULL) {\n \t\t\tid = xcalloc(1, sizeof(Identity));\n \t\t\tid->key = k;\n-\t\t\tid->provider = xstrdup(provider);\n-\t\t\tid->comment = xstrdup(provider); /* XXX */\n+\t\t\tid->provider = xstrdup(canonical_provider);\n+\t\t\tid->comment = xstrdup(canonical_provider); /* XXX */\n \t\t\tid->death = death;\n \t\t\tid->confirm = confirm;\n \t\t\tTAILQ_INSERT_TAIL(&tab->idlist, id, next);\n@@ -1157,7 +1176,7 @@ usage(void)\n {\n \tfprintf(stderr,\n \t    \""usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\""\n-\t    \""                 [-t life] [command [arg ...]]\\n\""\n+\t    \""                 [-P pkcs11_whitelist] [-t life] [command [arg ...]]\\n\""\n \t    \""       ssh-agent [-c | -s] -k\\n\"");\n \texit(1);\n }\n@@ -1191,7 +1210,7 @@ main(int ac, char **av)\n \tOpenSSL_add_all_algorithms();\n #endif\n \n-\twhile ((ch = getopt(ac, av, \""cDdksE:a:t:\"")) != -1) {\n+\twhile ((ch = getopt(ac, av, \""cDdksE:a:P:t:\"")) != -1) {\n \t\tswitch (ch) {\n \t\tcase 'E':\n \t\t\tfingerprint_hash = ssh_digest_alg_by_name(optarg);\n@@ -1206,6 +1225,11 @@ main(int ac, char **av)\n \t\tcase 'k':\n \t\t\tk_flag++;\n \t\t\tbreak;\n+\t\tcase 'P':\n+\t\t\tif (pkcs11_whitelist != NULL)\n+\t\t\t\tfatal(\""-P option already specified\"");\n+\t\t\tpkcs11_whitelist = xstrdup(optarg);\n+\t\t\tbreak;\n \t\tcase 's':\n \t\t\tif (c_flag)\n \t\t\t\tusage();\n@@ -1240,6 +1264,9 @@ main(int ac, char **av)\n \tif (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))\n \t\tusage();\n \n+\tif (pkcs11_whitelist == NULL)\n+\t\tpkcs11_whitelist = xstrdup(DEFAULT_PKCS11_WHITELIST);\n+\n \tif (ac == 0 && !c_flag && !s_flag) {\n \t\tshell = getenv(\""SHELL\"");\n \t\tif (shell != NULL && (len = strlen(shell)) > 2 &&\n@@ -1385,7 +1412,7 @@ main(int ac, char **av)\n \tsignal(SIGTERM, cleanup_handler);\n \tnalloc = 0;\n \n-\tif (pledge(\""stdio cpath unix id proc exec\"", NULL) == -1)\n+\tif (pledge(\""stdio rpath cpath unix id proc exec\"", NULL) == -1)\n \t\tfatal(\""%s: pledge: %s\"", __progname, strerror(errno));\n \n \twhile (1) {""}"," process_add_smartcard_key(SocketEntry *e)
 {
	char *provider = NULL, *pin, canonical_provider[PATH_MAX];
 	int r, i, version, count = 0, success = 0, confirm = 0;
 	u_int seconds;
 	time_t death = 0;
	u_char type;
	struct sshkey **keys = NULL, *k;
	Identity *id;
	Idtab *tab;

	if ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||
	    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0)
		fatal(""%s: buffer error: %s"", __func__, ssh_err(r));

	while (sshbuf_len(e->request)) {
		if ((r = sshbuf_get_u8(e->request, &type)) != 0)
			fatal(""%s: buffer error: %s"", __func__, ssh_err(r));
		switch (type) {
		case SSH_AGENT_CONSTRAIN_LIFETIME:
			if ((r = sshbuf_get_u32(e->request, &seconds)) != 0)
				fatal(""%s: buffer error: %s"",
				    __func__, ssh_err(r));
			death = monotime() + seconds;
			break;
		case SSH_AGENT_CONSTRAIN_CONFIRM:
			confirm = 1;
			break;
		default:
			error(""process_add_smartcard_key: ""
			    ""Unknown constraint type %d"", type);
 			goto send;
 		}
 	}
	if (realpath(provider, canonical_provider) == NULL) {
		verbose(""failed PKCS#11 add of \""%.100s\"": realpath: %s"",
		    provider, strerror(errno));
		goto send;
	}
	if (match_pattern_list(canonical_provider, pkcs11_whitelist, 0) != 1) {
		verbose(""refusing PKCS#11 add of \""%.100s\"": ""
		    ""provider not whitelisted"", canonical_provider);
		goto send;
	}
	debug(""%s: add %.100s"", __func__, canonical_provider);
 	if (lifetime && !death)
 		death = monotime() + lifetime;
 
	count = pkcs11_add_provider(canonical_provider, pin, &keys);
 	for (i = 0; i < count; i++) {
 		k = keys[i];
 		version = k->type == KEY_RSA1 ? 1 : 2;
 		tab = idtab_lookup(version);
 		if (lookup_identity(k, version) == NULL) {
 			id = xcalloc(1, sizeof(Identity));
 			id->key = k;
			id->provider = xstrdup(canonical_provider);
			id->comment = xstrdup(canonical_provider); /* XXX */
 			id->death = death;
 			id->confirm = confirm;
 			TAILQ_INSERT_TAIL(&tab->idlist, id, next);
			tab->nentries++;
			success = 1;
		} else {
			sshkey_free(k);
		}
		keys[i] = NULL;
	}
send:
	free(pin);
	free(provider);
	free(keys);
	send_status(e, success);
}
"," process_add_smartcard_key(SocketEntry *e)
 {
	char *provider = NULL, *pin;
 	int r, i, version, count = 0, success = 0, confirm = 0;
 	u_int seconds;
 	time_t death = 0;
	u_char type;
	struct sshkey **keys = NULL, *k;
	Identity *id;
	Idtab *tab;

	if ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||
	    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0)
		fatal(""%s: buffer error: %s"", __func__, ssh_err(r));

	while (sshbuf_len(e->request)) {
		if ((r = sshbuf_get_u8(e->request, &type)) != 0)
			fatal(""%s: buffer error: %s"", __func__, ssh_err(r));
		switch (type) {
		case SSH_AGENT_CONSTRAIN_LIFETIME:
			if ((r = sshbuf_get_u32(e->request, &seconds)) != 0)
				fatal(""%s: buffer error: %s"",
				    __func__, ssh_err(r));
			death = monotime() + seconds;
			break;
		case SSH_AGENT_CONSTRAIN_CONFIRM:
			confirm = 1;
			break;
		default:
			error(""process_add_smartcard_key: ""
			    ""Unknown constraint type %d"", type);
 			goto send;
 		}
 	}
 	if (lifetime && !death)
 		death = monotime() + lifetime;
 
	count = pkcs11_add_provider(provider, pin, &keys);
 	for (i = 0; i < count; i++) {
 		k = keys[i];
 		version = k->type == KEY_RSA1 ? 1 : 2;
 		tab = idtab_lookup(version);
 		if (lookup_identity(k, version) == NULL) {
 			id = xcalloc(1, sizeof(Identity));
 			id->key = k;
			id->provider = xstrdup(provider);
			id->comment = xstrdup(provider); /* XXX */
 			id->death = death;
 			id->confirm = confirm;
 			TAILQ_INSERT_TAIL(&tab->idlist, id, next);
			tab->nentries++;
			success = 1;
		} else {
			sshkey_free(k);
		}
		keys[i] = NULL;
	}
send:
	free(pin);
	free(provider);
	free(keys);
	send_status(e, success);
}
",C,"	char *provider = NULL, *pin, canonical_provider[PATH_MAX];
	if (realpath(provider, canonical_provider) == NULL) {
		verbose(""failed PKCS#11 add of \""%.100s\"": realpath: %s"",
		    provider, strerror(errno));
		goto send;
	}
	if (match_pattern_list(canonical_provider, pkcs11_whitelist, 0) != 1) {
		verbose(""refusing PKCS#11 add of \""%.100s\"": ""
		    ""provider not whitelisted"", canonical_provider);
		goto send;
	}
	debug(""%s: add %.100s"", __func__, canonical_provider);
	count = pkcs11_add_provider(canonical_provider, pin, &keys);
			id->provider = xstrdup(canonical_provider);
			id->comment = xstrdup(canonical_provider); /* XXX */
","	char *provider = NULL, *pin;
	count = pkcs11_add_provider(provider, pin, &keys);
			id->provider = xstrdup(provider);
			id->comment = xstrdup(provider); /* XXX */
",,"@@ -1,4 +1,4 @@
-/* $OpenBSD: ssh-agent.c,v 1.214 2016/09/12 01:22:38 deraadt Exp $ */
+/* $OpenBSD: ssh-agent.c,v 1.215 2016/11/30 03:07:37 djm Exp $ */
 /*
  * Author: Tatu Ylonen <ylo@cs.hut.fi>
  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
@@ -69,11 +69,16 @@
 #include ""misc.h""
 #include ""digest.h""
 #include ""ssherr.h""
+#include ""match.h""
 
 #ifdef ENABLE_PKCS11
 #include ""ssh-pkcs11.h""
 #endif
 
+#ifndef DEFAULT_PKCS11_WHITELIST
+# define DEFAULT_PKCS11_WHITELIST ""/usr/lib/*,/usr/local/lib/*""
+#endif
+
 typedef enum {
 	AUTH_UNUSED,
 	AUTH_SOCKET,
@@ -121,6 +126,9 @@ pid_t cleanup_pid = 0;
 char socket_name[PATH_MAX];
 char socket_dir[PATH_MAX];
 
+/* PKCS#11 path whitelist */
+static char *pkcs11_whitelist;
+
 /* locking */
 #define LOCK_SIZE	32
 #define LOCK_SALT_SIZE	16
@@ -724,7 +732,7 @@ no_identities(SocketEntry *e, u_int type)
 static void
 process_add_smartcard_key(SocketEntry *e)
 {
-	char *provider = NULL, *pin;
+	char *provider = NULL, *pin, canonical_provider[PATH_MAX];
 	int r, i, version, count = 0, success = 0, confirm = 0;
 	u_int seconds;
 	time_t death = 0;
@@ -756,19 +764,30 @@ process_add_smartcard_key(SocketEntry *e)
 			goto send;
 		}
 	}
+	if (realpath(provider, canonical_provider) == NULL) {
+		verbose(""failed PKCS#11 add of \""%.100s\"": realpath: %s"",
+		    provider, strerror(errno));
+		goto send;
+	}
+	if (match_pattern_list(canonical_provider, pkcs11_whitelist, 0) != 1) {
+		verbose(""refusing PKCS#11 add of \""%.100s\"": ""
+		    ""provider not whitelisted"", canonical_provider);
+		goto send;
+	}
+	debug(""%s: add %.100s"", __func__, canonical_provider);
 	if (lifetime && !death)
 		death = monotime() + lifetime;
 
-	count = pkcs11_add_provider(provider, pin, &keys);
+	count = pkcs11_add_provider(canonical_provider, pin, &keys);
 	for (i = 0; i < count; i++) {
 		k = keys[i];
 		version = k->type == KEY_RSA1 ? 1 : 2;
 		tab = idtab_lookup(version);
 		if (lookup_identity(k, version) == NULL) {
 			id = xcalloc(1, sizeof(Identity));
 			id->key = k;
-			id->provider = xstrdup(provider);
-			id->comment = xstrdup(provider); /* XXX */
+			id->provider = xstrdup(canonical_provider);
+			id->comment = xstrdup(canonical_provider); /* XXX */
 			id->death = death;
 			id->confirm = confirm;
 			TAILQ_INSERT_TAIL(&tab->idlist, id, next);
@@ -1157,7 +1176,7 @@ usage(void)
 {
 	fprintf(stderr,
 	    ""usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\n""
-	    ""                 [-t life] [command [arg ...]]\n""
+	    ""                 [-P pkcs11_whitelist] [-t life] [command [arg ...]]\n""
 	    ""       ssh-agent [-c | -s] -k\n"");
 	exit(1);
 }
@@ -1191,7 +1210,7 @@ main(int ac, char **av)
 	OpenSSL_add_all_algorithms();
 #endif
 
-	while ((ch = getopt(ac, av, ""cDdksE:a:t:"")) != -1) {
+	while ((ch = getopt(ac, av, ""cDdksE:a:P:t:"")) != -1) {
 		switch (ch) {
 		case 'E':
 			fingerprint_hash = ssh_digest_alg_by_name(optarg);
@@ -1206,6 +1225,11 @@ main(int ac, char **av)
 		case 'k':
 			k_flag++;
 			break;
+		case 'P':
+			if (pkcs11_whitelist != NULL)
+				fatal(""-P option already specified"");
+			pkcs11_whitelist = xstrdup(optarg);
+			break;
 		case 's':
 			if (c_flag)
 				usage();
@@ -1240,6 +1264,9 @@ main(int ac, char **av)
 	if (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))
 		usage();
 
+	if (pkcs11_whitelist == NULL)
+		pkcs11_whitelist = xstrdup(DEFAULT_PKCS11_WHITELIST);
+
 	if (ac == 0 && !c_flag && !s_flag) {
 		shell = getenv(""SHELL"");
 		if (shell != NULL && (len = strlen(shell)) > 2 &&
@@ -1385,7 +1412,7 @@ main(int ac, char **av)
 	signal(SIGTERM, cleanup_handler);
 	nalloc = 0;
 
-	if (pledge(""stdio cpath unix id proc exec"", NULL) == -1)
+	if (pledge(""stdio rpath cpath unix id proc exec"", NULL) == -1)
 		fatal(""%s: pledge: %s"", __progname, strerror(errno));
 
 	while (1) {",src,9476ce1dd37d3c3218d5640b74c34c65e5f4efe5,5eecd4ed02a939575543e46dd71909c863e43419,1," process_add_smartcard_key(SocketEntry *e)
 {
//flaw_line_below:
	char *provider = NULL, *pin;
//fix_flaw_line_below:
//	char *provider = NULL, *pin, canonical_provider[PATH_MAX];
 	int r, i, version, count = 0, success = 0, confirm = 0;
 	u_int seconds;
 	time_t death = 0;
	u_char type;
	struct sshkey **keys = NULL, *k;
	Identity *id;
	Idtab *tab;

	if ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||
	    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0)
		fatal(""%s: buffer error: %s"", __func__, ssh_err(r));

	while (sshbuf_len(e->request)) {
		if ((r = sshbuf_get_u8(e->request, &type)) != 0)
			fatal(""%s: buffer error: %s"", __func__, ssh_err(r));
		switch (type) {
		case SSH_AGENT_CONSTRAIN_LIFETIME:
			if ((r = sshbuf_get_u32(e->request, &seconds)) != 0)
				fatal(""%s: buffer error: %s"",
				    __func__, ssh_err(r));
			death = monotime() + seconds;
			break;
		case SSH_AGENT_CONSTRAIN_CONFIRM:
			confirm = 1;
			break;
		default:
			error(""process_add_smartcard_key: ""
			    ""Unknown constraint type %d"", type);
 			goto send;
 		}
 	}
//fix_flaw_line_below:
//	if (realpath(provider, canonical_provider) == NULL) {
//fix_flaw_line_below:
//		verbose(""failed PKCS#11 add of \""%.100s\"": realpath: %s"",
//fix_flaw_line_below:
//		    provider, strerror(errno));
//fix_flaw_line_below:
//		goto send;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//	if (match_pattern_list(canonical_provider, pkcs11_whitelist, 0) != 1) {
//fix_flaw_line_below:
//		verbose(""refusing PKCS#11 add of \""%.100s\"": ""
//fix_flaw_line_below:
//		    ""provider not whitelisted"", canonical_provider);
//fix_flaw_line_below:
//		goto send;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//	debug(""%s: add %.100s"", __func__, canonical_provider);
 	if (lifetime && !death)
 		death = monotime() + lifetime;
 
//flaw_line_below:
	count = pkcs11_add_provider(provider, pin, &keys);
//fix_flaw_line_below:
//	count = pkcs11_add_provider(canonical_provider, pin, &keys);
 	for (i = 0; i < count; i++) {
 		k = keys[i];
 		version = k->type == KEY_RSA1 ? 1 : 2;
 		tab = idtab_lookup(version);
 		if (lookup_identity(k, version) == NULL) {
 			id = xcalloc(1, sizeof(Identity));
 			id->key = k;
//flaw_line_below:
			id->provider = xstrdup(provider);
//flaw_line_below:
			id->comment = xstrdup(provider); /* XXX */
//fix_flaw_line_below:
//			id->provider = xstrdup(canonical_provider);
//fix_flaw_line_below:
//			id->comment = xstrdup(canonical_provider); /* XXX */
 			id->death = death;
 			id->confirm = confirm;
 			TAILQ_INSERT_TAIL(&tab->idlist, id, next);
			tab->nentries++;
			success = 1;
		} else {
			sshkey_free(k);
		}
		keys[i] = NULL;
	}
send:
	free(pin);
	free(provider);
	free(keys);
	send_status(e, success);
}
"
4101,181837,,Remote,Not required,Partial,CVE-2016-10009,https://www.cvedetails.com/cve/CVE-2016-10009/,CWE-426,Low,Partial,Partial,,2017-01-04,7.5,Untrusted search path vulnerability in ssh-agent.c in ssh-agent in OpenSSH before 7.4 allows remote attackers to execute arbitrary local PKCS#11 modules by leveraging control over a forwarded agent-socket.,2018-09-11,,1,https://github.com/openbsd/src/commit/9476ce1dd37d3c3218d5640b74c34c65e5f4efe5,9476ce1dd37d3c3218d5640b74c34c65e5f4efe5,"add a whitelist of paths from which ssh-agent will load (via
ssh-pkcs11-helper) a PKCS#11 module; ok markus@",1,usr.bin/ssh/ssh-agent.c,"{""sha"": ""372adbe7c7f52203b16da700601ed979ff58da2d"", ""filename"": ""usr.bin/ssh/ssh-agent.1"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 2, ""changes"": 17, ""blob_url"": ""https://github.com/openbsd/src/blob/9476ce1dd37d3c3218d5640b74c34c65e5f4efe5/usr.bin/ssh/ssh-agent.1"", ""raw_url"": ""https://github.com/openbsd/src/raw/9476ce1dd37d3c3218d5640b74c34c65e5f4efe5/usr.bin/ssh/ssh-agent.1"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/ssh-agent.1?ref=9476ce1dd37d3c3218d5640b74c34c65e5f4efe5"", ""patch"": ""@@ -1,4 +1,4 @@\n-.\\\"" $OpenBSD: ssh-agent.1,v 1.62 2015/11/15 23:54:15 jmc Exp $\n+.\\\"" $OpenBSD: ssh-agent.1,v 1.63 2016/11/30 03:07:37 djm Exp $\n .\\\""\n .\\\"" Author: Tatu Ylonen <ylo@cs.hut.fi>\n .\\\"" Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n@@ -34,7 +34,7 @@\n .\\\"" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n .\\\"" THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n .\\\""\n-.Dd $Mdocdate: November 15 2015 $\n+.Dd $Mdocdate: November 30 2016 $\n .Dt SSH-AGENT 1\n .Os\n .Sh NAME\n@@ -47,6 +47,7 @@\n .Op Fl a Ar bind_address\n .Op Fl E Ar fingerprint_hash\n .Op Fl t Ar life\n+.Op Fl P Ar pkcs11_whitelist\n .Op Ar command Op Ar arg ...\n .Nm ssh-agent\n .Op Fl c | s\n@@ -121,6 +122,18 @@ The default is\n Kill the current agent (given by the\n .Ev SSH_AGENT_PID\n environment variable).\n+.It Fl P\n+Specify a pattern-list of acceptable paths for PKCS#11 shared libraries\n+that may be added using the\n+.Fl s\n+option to\n+.Xr ssh-add 1 .\n+The default is to allow loading PKCS#11 libraries from\n+.Dq /usr/lib/*,/usr/local/lib/* .\n+PKCS#11 libraries that do not match the whitelist will be refused.\n+See PATTERNS in\n+.Xr ssh_config 5\n+for a description of pattern-list syntax.\n .It Fl s\n Generate Bourne shell commands on\n .Dv stdout .""}<_**next**_>{""sha"": ""4a91f36d3ffa45013f276417161e6dc5d63e9363"", ""filename"": ""usr.bin/ssh/ssh-agent.c"", ""status"": ""modified"", ""additions"": 35, ""deletions"": 8, ""changes"": 43, ""blob_url"": ""https://github.com/openbsd/src/blob/9476ce1dd37d3c3218d5640b74c34c65e5f4efe5/usr.bin/ssh/ssh-agent.c"", ""raw_url"": ""https://github.com/openbsd/src/raw/9476ce1dd37d3c3218d5640b74c34c65e5f4efe5/usr.bin/ssh/ssh-agent.c"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/ssh-agent.c?ref=9476ce1dd37d3c3218d5640b74c34c65e5f4efe5"", ""patch"": ""@@ -1,4 +1,4 @@\n-/* $OpenBSD: ssh-agent.c,v 1.214 2016/09/12 01:22:38 deraadt Exp $ */\n+/* $OpenBSD: ssh-agent.c,v 1.215 2016/11/30 03:07:37 djm Exp $ */\n /*\n  * Author: Tatu Ylonen <ylo@cs.hut.fi>\n  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n@@ -69,11 +69,16 @@\n #include \""misc.h\""\n #include \""digest.h\""\n #include \""ssherr.h\""\n+#include \""match.h\""\n \n #ifdef ENABLE_PKCS11\n #include \""ssh-pkcs11.h\""\n #endif\n \n+#ifndef DEFAULT_PKCS11_WHITELIST\n+# define DEFAULT_PKCS11_WHITELIST \""/usr/lib/*,/usr/local/lib/*\""\n+#endif\n+\n typedef enum {\n \tAUTH_UNUSED,\n \tAUTH_SOCKET,\n@@ -121,6 +126,9 @@ pid_t cleanup_pid = 0;\n char socket_name[PATH_MAX];\n char socket_dir[PATH_MAX];\n \n+/* PKCS#11 path whitelist */\n+static char *pkcs11_whitelist;\n+\n /* locking */\n #define LOCK_SIZE\t32\n #define LOCK_SALT_SIZE\t16\n@@ -724,7 +732,7 @@ no_identities(SocketEntry *e, u_int type)\n static void\n process_add_smartcard_key(SocketEntry *e)\n {\n-\tchar *provider = NULL, *pin;\n+\tchar *provider = NULL, *pin, canonical_provider[PATH_MAX];\n \tint r, i, version, count = 0, success = 0, confirm = 0;\n \tu_int seconds;\n \ttime_t death = 0;\n@@ -756,19 +764,30 @@ process_add_smartcard_key(SocketEntry *e)\n \t\t\tgoto send;\n \t\t}\n \t}\n+\tif (realpath(provider, canonical_provider) == NULL) {\n+\t\tverbose(\""failed PKCS#11 add of \\\""%.100s\\\"": realpath: %s\"",\n+\t\t    provider, strerror(errno));\n+\t\tgoto send;\n+\t}\n+\tif (match_pattern_list(canonical_provider, pkcs11_whitelist, 0) != 1) {\n+\t\tverbose(\""refusing PKCS#11 add of \\\""%.100s\\\"": \""\n+\t\t    \""provider not whitelisted\"", canonical_provider);\n+\t\tgoto send;\n+\t}\n+\tdebug(\""%s: add %.100s\"", __func__, canonical_provider);\n \tif (lifetime && !death)\n \t\tdeath = monotime() + lifetime;\n \n-\tcount = pkcs11_add_provider(provider, pin, &keys);\n+\tcount = pkcs11_add_provider(canonical_provider, pin, &keys);\n \tfor (i = 0; i < count; i++) {\n \t\tk = keys[i];\n \t\tversion = k->type == KEY_RSA1 ? 1 : 2;\n \t\ttab = idtab_lookup(version);\n \t\tif (lookup_identity(k, version) == NULL) {\n \t\t\tid = xcalloc(1, sizeof(Identity));\n \t\t\tid->key = k;\n-\t\t\tid->provider = xstrdup(provider);\n-\t\t\tid->comment = xstrdup(provider); /* XXX */\n+\t\t\tid->provider = xstrdup(canonical_provider);\n+\t\t\tid->comment = xstrdup(canonical_provider); /* XXX */\n \t\t\tid->death = death;\n \t\t\tid->confirm = confirm;\n \t\t\tTAILQ_INSERT_TAIL(&tab->idlist, id, next);\n@@ -1157,7 +1176,7 @@ usage(void)\n {\n \tfprintf(stderr,\n \t    \""usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\""\n-\t    \""                 [-t life] [command [arg ...]]\\n\""\n+\t    \""                 [-P pkcs11_whitelist] [-t life] [command [arg ...]]\\n\""\n \t    \""       ssh-agent [-c | -s] -k\\n\"");\n \texit(1);\n }\n@@ -1191,7 +1210,7 @@ main(int ac, char **av)\n \tOpenSSL_add_all_algorithms();\n #endif\n \n-\twhile ((ch = getopt(ac, av, \""cDdksE:a:t:\"")) != -1) {\n+\twhile ((ch = getopt(ac, av, \""cDdksE:a:P:t:\"")) != -1) {\n \t\tswitch (ch) {\n \t\tcase 'E':\n \t\t\tfingerprint_hash = ssh_digest_alg_by_name(optarg);\n@@ -1206,6 +1225,11 @@ main(int ac, char **av)\n \t\tcase 'k':\n \t\t\tk_flag++;\n \t\t\tbreak;\n+\t\tcase 'P':\n+\t\t\tif (pkcs11_whitelist != NULL)\n+\t\t\t\tfatal(\""-P option already specified\"");\n+\t\t\tpkcs11_whitelist = xstrdup(optarg);\n+\t\t\tbreak;\n \t\tcase 's':\n \t\t\tif (c_flag)\n \t\t\t\tusage();\n@@ -1240,6 +1264,9 @@ main(int ac, char **av)\n \tif (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))\n \t\tusage();\n \n+\tif (pkcs11_whitelist == NULL)\n+\t\tpkcs11_whitelist = xstrdup(DEFAULT_PKCS11_WHITELIST);\n+\n \tif (ac == 0 && !c_flag && !s_flag) {\n \t\tshell = getenv(\""SHELL\"");\n \t\tif (shell != NULL && (len = strlen(shell)) > 2 &&\n@@ -1385,7 +1412,7 @@ main(int ac, char **av)\n \tsignal(SIGTERM, cleanup_handler);\n \tnalloc = 0;\n \n-\tif (pledge(\""stdio cpath unix id proc exec\"", NULL) == -1)\n+\tif (pledge(\""stdio rpath cpath unix id proc exec\"", NULL) == -1)\n \t\tfatal(\""%s: pledge: %s\"", __progname, strerror(errno));\n \n \twhile (1) {""}","usage(void)
 {
 	fprintf(stderr,
 	    ""usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\n""
	    ""                 [-P pkcs11_whitelist] [-t life] [command [arg ...]]\n""
 	    ""       ssh-agent [-c | -s] -k\n"");
 	exit(1);
 }
","usage(void)
 {
 	fprintf(stderr,
 	    ""usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\n""
	    ""                 [-t life] [command [arg ...]]\n""
 	    ""       ssh-agent [-c | -s] -k\n"");
 	exit(1);
 }
",C,"	    ""                 [-P pkcs11_whitelist] [-t life] [command [arg ...]]\n""
","	    ""                 [-t life] [command [arg ...]]\n""
",,"@@ -1,4 +1,4 @@
-/* $OpenBSD: ssh-agent.c,v 1.214 2016/09/12 01:22:38 deraadt Exp $ */
+/* $OpenBSD: ssh-agent.c,v 1.215 2016/11/30 03:07:37 djm Exp $ */
 /*
  * Author: Tatu Ylonen <ylo@cs.hut.fi>
  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
@@ -69,11 +69,16 @@
 #include ""misc.h""
 #include ""digest.h""
 #include ""ssherr.h""
+#include ""match.h""
 
 #ifdef ENABLE_PKCS11
 #include ""ssh-pkcs11.h""
 #endif
 
+#ifndef DEFAULT_PKCS11_WHITELIST
+# define DEFAULT_PKCS11_WHITELIST ""/usr/lib/*,/usr/local/lib/*""
+#endif
+
 typedef enum {
 	AUTH_UNUSED,
 	AUTH_SOCKET,
@@ -121,6 +126,9 @@ pid_t cleanup_pid = 0;
 char socket_name[PATH_MAX];
 char socket_dir[PATH_MAX];
 
+/* PKCS#11 path whitelist */
+static char *pkcs11_whitelist;
+
 /* locking */
 #define LOCK_SIZE	32
 #define LOCK_SALT_SIZE	16
@@ -724,7 +732,7 @@ no_identities(SocketEntry *e, u_int type)
 static void
 process_add_smartcard_key(SocketEntry *e)
 {
-	char *provider = NULL, *pin;
+	char *provider = NULL, *pin, canonical_provider[PATH_MAX];
 	int r, i, version, count = 0, success = 0, confirm = 0;
 	u_int seconds;
 	time_t death = 0;
@@ -756,19 +764,30 @@ process_add_smartcard_key(SocketEntry *e)
 			goto send;
 		}
 	}
+	if (realpath(provider, canonical_provider) == NULL) {
+		verbose(""failed PKCS#11 add of \""%.100s\"": realpath: %s"",
+		    provider, strerror(errno));
+		goto send;
+	}
+	if (match_pattern_list(canonical_provider, pkcs11_whitelist, 0) != 1) {
+		verbose(""refusing PKCS#11 add of \""%.100s\"": ""
+		    ""provider not whitelisted"", canonical_provider);
+		goto send;
+	}
+	debug(""%s: add %.100s"", __func__, canonical_provider);
 	if (lifetime && !death)
 		death = monotime() + lifetime;
 
-	count = pkcs11_add_provider(provider, pin, &keys);
+	count = pkcs11_add_provider(canonical_provider, pin, &keys);
 	for (i = 0; i < count; i++) {
 		k = keys[i];
 		version = k->type == KEY_RSA1 ? 1 : 2;
 		tab = idtab_lookup(version);
 		if (lookup_identity(k, version) == NULL) {
 			id = xcalloc(1, sizeof(Identity));
 			id->key = k;
-			id->provider = xstrdup(provider);
-			id->comment = xstrdup(provider); /* XXX */
+			id->provider = xstrdup(canonical_provider);
+			id->comment = xstrdup(canonical_provider); /* XXX */
 			id->death = death;
 			id->confirm = confirm;
 			TAILQ_INSERT_TAIL(&tab->idlist, id, next);
@@ -1157,7 +1176,7 @@ usage(void)
 {
 	fprintf(stderr,
 	    ""usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\n""
-	    ""                 [-t life] [command [arg ...]]\n""
+	    ""                 [-P pkcs11_whitelist] [-t life] [command [arg ...]]\n""
 	    ""       ssh-agent [-c | -s] -k\n"");
 	exit(1);
 }
@@ -1191,7 +1210,7 @@ main(int ac, char **av)
 	OpenSSL_add_all_algorithms();
 #endif
 
-	while ((ch = getopt(ac, av, ""cDdksE:a:t:"")) != -1) {
+	while ((ch = getopt(ac, av, ""cDdksE:a:P:t:"")) != -1) {
 		switch (ch) {
 		case 'E':
 			fingerprint_hash = ssh_digest_alg_by_name(optarg);
@@ -1206,6 +1225,11 @@ main(int ac, char **av)
 		case 'k':
 			k_flag++;
 			break;
+		case 'P':
+			if (pkcs11_whitelist != NULL)
+				fatal(""-P option already specified"");
+			pkcs11_whitelist = xstrdup(optarg);
+			break;
 		case 's':
 			if (c_flag)
 				usage();
@@ -1240,6 +1264,9 @@ main(int ac, char **av)
 	if (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))
 		usage();
 
+	if (pkcs11_whitelist == NULL)
+		pkcs11_whitelist = xstrdup(DEFAULT_PKCS11_WHITELIST);
+
 	if (ac == 0 && !c_flag && !s_flag) {
 		shell = getenv(""SHELL"");
 		if (shell != NULL && (len = strlen(shell)) > 2 &&
@@ -1385,7 +1412,7 @@ main(int ac, char **av)
 	signal(SIGTERM, cleanup_handler);
 	nalloc = 0;
 
-	if (pledge(""stdio cpath unix id proc exec"", NULL) == -1)
+	if (pledge(""stdio rpath cpath unix id proc exec"", NULL) == -1)
 		fatal(""%s: pledge: %s"", __progname, strerror(errno));
 
 	while (1) {",src,9476ce1dd37d3c3218d5640b74c34c65e5f4efe5,5eecd4ed02a939575543e46dd71909c863e43419,1,"usage(void)
 {
 	fprintf(stderr,
 	    ""usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\n""
//flaw_line_below:
	    ""                 [-t life] [command [arg ...]]\n""
//fix_flaw_line_below:
//	    ""                 [-P pkcs11_whitelist] [-t life] [command [arg ...]]\n""
 	    ""       ssh-agent [-c | -s] -k\n"");
 	exit(1);
 }
"
4320,182056,,Local,Not required,Complete,CVE-2015-3887,https://www.cvedetails.com/cve/CVE-2015-3887/,CWE-426,Low,Complete,Complete,,2017-09-21,7.2,"Untrusted search path vulnerability in ProxyChains-NG before 4.9 allows local users to gain privileges via a Trojan horse libproxychains4.so library in the current working directory, which is referenced in the LD_PRELOAD path.",2017-10-03,+Priv ,4,https://github.com/rofl0r/proxychains-ng/commit/9ab7dbeb3baff67a51d0c5e71465c453be0890b5#diff-803c5170888b8642f2a97e5e9423d399,9ab7dbeb3baff67a51d0c5e71465c453be0890b5#diff-803c5170888b8642f2a97e5e9423d399,"fix for CVE-2015-3887

closes #60",0,src/main.c,"{""sha"": ""a4dac46fe705ab7f1fe2b89342f750b16f951dc4"", ""filename"": ""configure"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 1, ""changes"": 8, ""blob_url"": ""https://github.com/rofl0r/proxychains-ng/blob/9ab7dbeb3baff67a51d0c5e71465c453be0890b5/configure"", ""raw_url"": ""https://github.com/rofl0r/proxychains-ng/raw/9ab7dbeb3baff67a51d0c5e71465c453be0890b5/configure"", ""contents_url"": ""https://api.github.com/repos/rofl0r/proxychains-ng/contents/configure?ref=9ab7dbeb3baff67a51d0c5e71465c453be0890b5"", ""patch"": ""@@ -26,6 +26,9 @@ usage() {\n \techo \""--libdir=/path\t\tdefault: $prefix/lib\""\n \techo \""--includedir=/path\tdefault: $prefix/include\""\n \techo \""--sysconfdir=/path\tdefault: $prefix/etc\""\n+\techo \""--ignore-cve\t\tdefault: no\""\n+\techo \""\tif set to yes ignores CVE-2015-3887 and makes it possible\""\n+\techo \""\tto preload from current dir (insecure)\""\n \tismac && isx86_64 && echo \""--fat-binary : build for both i386 and x86_64 architectures on 64-bit Macs\""\n \techo \""--help : show this text\""\n \texit 1\n@@ -39,7 +42,7 @@ spliteq() {\n }\n \n fat_binary=\n-\n+ignore_cve=no\n parsearg() {\n \tcase \""$1\"" in\n \t--prefix=*) prefix=`spliteq $1`;;\n@@ -48,6 +51,8 @@ parsearg() {\n \t--libdir=*) libdir=`spliteq $1`;;\n \t--includedir=*) includedir=`spliteq $1`;;\n \t--sysconfdir=*) sysconfdir=`spliteq $1`;;\n+\t--ignore-cve) ignore_cve=1;;\n+\t--ignore-cve=*) ignore_cve=`spliteq $1`;;\n \t--fat-binary) fat_binary=1;;\n \t--help) usage;;\n \tesac\n@@ -94,6 +99,7 @@ echo bindir=$bindir>>config.mak\n echo libdir=$libdir>>config.mak\n echo includedir=$includedir>>config.mak\n echo sysconfdir=$sysconfdir>>config.mak\n+[ \""$ignore_cve\"" = \""no\"" ] && echo CPPFLAGS+= -DSUPER_SECURE>>config.mak\n make_cmd=make\n if ismac ; then\n \techo NO_AS_NEEDED=>>config.mak""}<_**next**_>{""sha"": ""36e9eea2ca6aeba8cf3bd4573b69be093bb2f109"", ""filename"": ""src/main.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/rofl0r/proxychains-ng/blob/9ab7dbeb3baff67a51d0c5e71465c453be0890b5/src/main.c"", ""raw_url"": ""https://github.com/rofl0r/proxychains-ng/raw/9ab7dbeb3baff67a51d0c5e71465c453be0890b5/src/main.c"", ""contents_url"": ""https://api.github.com/repos/rofl0r/proxychains-ng/contents/src/main.c?ref=9ab7dbeb3baff67a51d0c5e71465c453be0890b5"", ""patch"": ""@@ -33,7 +33,9 @@ static const char *dll_name = DLL_NAME;\n \n static char own_dir[256];\n static const char *dll_dirs[] = {\n+#ifndef SUPER_SECURE /* CVE-2015-3887 */\n \t\"".\"",\n+#endif\n \town_dir,\n \tLIB_DIR,\n \t\""/lib\"",\n@@ -48,7 +50,11 @@ static void set_own_dir(const char *argv0) {\n \twhile(l && argv0[l - 1] != '/')\n \t\tl--;\n \tif(l == 0)\n+#ifdef SUPER_SECURE\n+\t\tmemcpy(own_dir, \""/dev/null/\"", 2);\n+#else\n \t\tmemcpy(own_dir, \"".\"", 2);\n+#endif\n \telse {\n \t\tmemcpy(own_dir, argv0, l - 1);\n \t\town_dir[l] = 0;""}","static void set_own_dir(const char *argv0) {
	size_t l = strlen(argv0);
 	while(l && argv0[l - 1] != '/')
 		l--;
 	if(l == 0)
#ifdef SUPER_SECURE
		memcpy(own_dir, ""/dev/null/"", 2);
#else
 		memcpy(own_dir, ""."", 2);
#endif
 	else {
 		memcpy(own_dir, argv0, l - 1);
 		own_dir[l] = 0;
	}
}
","static void set_own_dir(const char *argv0) {
	size_t l = strlen(argv0);
 	while(l && argv0[l - 1] != '/')
 		l--;
 	if(l == 0)
 		memcpy(own_dir, ""."", 2);
 	else {
 		memcpy(own_dir, argv0, l - 1);
 		own_dir[l] = 0;
	}
}
",C,"#ifdef SUPER_SECURE
		memcpy(own_dir, ""/dev/null/"", 2);
#else
#endif
",,,"@@ -33,7 +33,9 @@ static const char *dll_name = DLL_NAME;
 
 static char own_dir[256];
 static const char *dll_dirs[] = {
+#ifndef SUPER_SECURE /* CVE-2015-3887 */
 	""."",
+#endif
 	own_dir,
 	LIB_DIR,
 	""/lib"",
@@ -48,7 +50,11 @@ static void set_own_dir(const char *argv0) {
 	while(l && argv0[l - 1] != '/')
 		l--;
 	if(l == 0)
+#ifdef SUPER_SECURE
+		memcpy(own_dir, ""/dev/null/"", 2);
+#else
 		memcpy(own_dir, ""."", 2);
+#endif
 	else {
 		memcpy(own_dir, argv0, l - 1);
 		own_dir[l] = 0;",proxychains-ng,9ab7dbeb3baff67a51d0c5e71465c453be0890b5#diff-803c5170888b8642f2a97e5e9423d399,ba61b48fd75b27a26e9bd31c5a5f07c1037222bf,1,"static void set_own_dir(const char *argv0) {
	size_t l = strlen(argv0);
 	while(l && argv0[l - 1] != '/')
 		l--;
 	if(l == 0)
//fix_flaw_line_below:
//#ifdef SUPER_SECURE
//fix_flaw_line_below:
//		memcpy(own_dir, ""/dev/null/"", 2);
//fix_flaw_line_below:
//#else
 		memcpy(own_dir, ""."", 2);
//fix_flaw_line_below:
//#endif
 	else {
 		memcpy(own_dir, argv0, l - 1);
 		own_dir[l] = 0;
	}
}
"
