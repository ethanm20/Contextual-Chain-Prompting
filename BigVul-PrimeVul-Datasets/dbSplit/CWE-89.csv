,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix
1100,178836,,Remote,Not required,Partial,CVE-2012-0036,https://www.cvedetails.com/cve/CVE-2012-0036/,CWE-89,Low,Partial,Partial,,2012-04-13,7.5,"curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.",2018-01-09,Sql ,1,https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238,75ca568fa1c19de4c5358fed246686de8467c238,"URL sanitize: reject URLs containing bad data

Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a
decoded manner now use the new Curl_urldecode() function to reject URLs
with embedded control codes (anything that is or decodes to a byte value
less than 32).

URLs containing such codes could easily otherwise be used to do harm and
allow users to do unintended actions with otherwise innocent tools and
applications. Like for example using a URL like
pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get
a mail and instead this would delete one.

This flaw is considered a security vulnerability: CVE-2012-0036

Security advisory at: http://curl.haxx.se/docs/adv_20120124.html

Reported by: Dan Fandrich",1,lib/escape.c,"{""sha"": ""0dd5a1d0a687194492b2c38b54007de3e0775530"", ""filename"": ""lib/escape.c"", ""status"": ""modified"", ""additions"": 50, ""deletions"": 13, ""changes"": 63, ""blob_url"": ""https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c"", ""raw_url"": ""https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c"", ""contents_url"": ""https://api.github.com/repos/curl/curl/contents/lib/escape.c?ref=75ca568fa1c19de4c5358fed246686de8467c238"", ""patch"": ""@@ -31,6 +31,7 @@\n #include \""urldata.h\""\n #include \""warnless.h\""\n #include \""non-ascii.h\""\n+#include \""escape.h\""\n \n #define _MPRINTF_REPLACE /* use our functions only */\n #include <curl/mprintf.h>\n@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n   char *testing_ptr = NULL;\n   unsigned char in; /* we need to treat the characters unsigned */\n   size_t newlen = alloc;\n-  int strindex=0;\n+  size_t strindex=0;\n   size_t length;\n   CURLcode res;\n \n@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n }\n \n /*\n- * Unescapes the given URL escaped string of given length. Returns a\n- * pointer to a malloced string with length given in *olen.\n- * If length == 0, the length is assumed to be strlen(string).\n- * If olen == NULL, no output length is stored.\n+ * Curl_urldecode() URL decodes the given string.\n+ *\n+ * Optionally detects control characters (byte codes lower than 32) in the\n+ * data and rejects such data.\n+ *\n+ * Returns a pointer to a malloced string in *ostring with length given in\n+ * *olen. If length == 0, the length is assumed to be strlen(string).\n+ *\n  */\n-char *curl_easy_unescape(CURL *handle, const char *string, int length,\n-                         int *olen)\n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_ctrl)\n {\n-  int alloc = (length?length:(int)strlen(string))+1;\n+  size_t alloc = (length?length:strlen(string))+1;\n   char *ns = malloc(alloc);\n   unsigned char in;\n-  int strindex=0;\n+  size_t strindex=0;\n   unsigned long hex;\n   CURLcode res;\n \n   if(!ns)\n-    return NULL;\n+    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n \n       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n \n-      res = Curl_convert_from_network(handle, &in, 1);\n+      res = Curl_convert_from_network(data, &in, 1);\n       if(res) {\n         /* Curl_convert_from_network calls failf if unsuccessful */\n         free(ns);\n-        return NULL;\n+        return res;\n       }\n \n       string+=2;\n       alloc-=2;\n     }\n+    if(reject_ctrl && (in < 0x20)) {\n+      free(ns);\n+      return CURLE_URL_MALFORMAT;\n+    }\n \n     ns[strindex++] = in;\n     string++;\n@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n   if(olen)\n     /* store output size */\n     *olen = strindex;\n-  return ns;\n+\n+  if(ostring)\n+    /* store output string */\n+    *ostring = ns;\n+\n+  return CURLE_OK;\n+}\n+\n+/*\n+ * Unescapes the given URL escaped string of given length. Returns a\n+ * pointer to a malloced string with length given in *olen.\n+ * If length == 0, the length is assumed to be strlen(string).\n+ * If olen == NULL, no output length is stored.\n+ */\n+char *curl_easy_unescape(CURL *handle, const char *string, int length,\n+                         int *olen)\n+{\n+  char *str = NULL;\n+  size_t inputlen = length;\n+  size_t outputlen;\n+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,\n+                                FALSE);\n+  if(res)\n+    return NULL;\n+  if(olen)\n+    *olen = curlx_uztosi(outputlen);\n+  return str;\n }\n \n /* For operating systems/environments that use different malloc/free""}<_**next**_>{""sha"": ""4c7f84133b6c5677586fa1258c2a09d2ba8fef20"", ""filename"": ""lib/escape.h"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 3, ""changes"": 10, ""blob_url"": ""https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h"", ""raw_url"": ""https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h"", ""contents_url"": ""https://api.github.com/repos/curl/curl/contents/lib/escape.h?ref=75ca568fa1c19de4c5358fed246686de8467c238"", ""patch"": ""@@ -1,5 +1,5 @@\n-#ifndef __ESCAPE_H\n-#define __ESCAPE_H\n+#ifndef HEADER_CURL_ESCAPE_H\n+#define HEADER_CURL_ESCAPE_H\n \n /***************************************************************************\n  *                                  _   _ ____  _\n@@ -8,7 +8,7 @@\n  *                            | (__| |_| |  _ <| |___\n  *                             \\___|\\___/|_| \\_\\_____|\n  *\n- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.\n+ * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al.\n  *\n  * This software is licensed as described in the file COPYING, which\n  * you should have received as part of this distribution. The terms\n@@ -25,5 +25,9 @@\n /* Escape and unescape URL encoding in strings. The functions return a new\n  * allocated string or NULL if an error occurred.  */\n \n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_crlf);\n \n #endif""}<_**next**_>{""sha"": ""c6701417d0449bdf6280cb6f886e397b36198b19"", ""filename"": ""lib/imap.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 6, ""changes"": 7, ""blob_url"": ""https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c"", ""raw_url"": ""https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c"", ""contents_url"": ""https://api.github.com/repos/curl/curl/contents/lib/imap.c?ref=75ca568fa1c19de4c5358fed246686de8467c238"", ""patch"": ""@@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)\n   struct imap_conn *imapc = &conn->proto.imapc;\n   struct SessionHandle *data = conn->data;\n   const char *path = data->state.path;\n-  int len;\n \n   if(!*path)\n     path = \""INBOX\"";\n \n   /* url decode the path and use this mailbox */\n-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n-  if(!imapc->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */""}<_**next**_>{""sha"": ""cc360b8b95e1b8df55d17180f892945578a10c6a"", ""filename"": ""lib/pop3.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 5, ""changes"": 6, ""blob_url"": ""https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c"", ""raw_url"": ""https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c"", ""contents_url"": ""https://api.github.com/repos/curl/curl/contents/lib/pop3.c?ref=75ca568fa1c19de4c5358fed246686de8467c238"", ""patch"": ""@@ -914,11 +914,7 @@ static CURLcode pop3_parse_url_path(struct connectdata *conn)\n   const char *path = data->state.path;\n \n   /* url decode the path and use this mailbox */\n-  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n-  if(!pop3c->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */""}<_**next**_>{""sha"": ""553c697d063edb448bb7ac80c6d9bac5d1d12d8b"", ""filename"": ""lib/smtp.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c"", ""raw_url"": ""https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c"", ""contents_url"": ""https://api.github.com/repos/curl/curl/contents/lib/smtp.c?ref=75ca568fa1c19de4c5358fed246686de8467c238"", ""patch"": ""@@ -1244,7 +1244,6 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   struct SessionHandle *data = conn->data;\n   struct pingpong *pp = &smtpc->pp;\n   const char *path = conn->data->state.path;\n-  int len;\n   char localhost[HOSTNAME_MAX + 1];\n \n   *done = FALSE; /* default to not done yet */\n@@ -1316,9 +1315,9 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   }\n \n   /* url decode the path and use it as domain with EHLO */\n-  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n-  if(!smtpc->domain)\n-    return CURLE_OUT_OF_MEMORY;\n+  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n+  if(result)\n+    return result;\n \n   /* When we connect, we start in the state where we await the server greeting\n    */""}","char *curl_easy_escape(CURL *handle, const char *string, int inlength)
{
  size_t alloc = (inlength?(size_t)inlength:strlen(string))+1;
  char *ns;
   char *testing_ptr = NULL;
   unsigned char in; /* we need to treat the characters unsigned */
   size_t newlen = alloc;
  size_t strindex=0;
   size_t length;
   CURLcode res;
 
  ns = malloc(alloc);
  if(!ns)
    return NULL;

  length = alloc-1;
  while(length--) {
    in = *string;

    if(Curl_isunreserved(in))
      /* just copy this */
      ns[strindex++]=in;
    else {
      /* encode it */
      newlen += 2; /* the size grows with two, since this'll become a %XX */
      if(newlen > alloc) {
        alloc *= 2;
        testing_ptr = realloc(ns, alloc);
        if(!testing_ptr) {
          free( ns );
          return NULL;
        }
        else {
          ns = testing_ptr;
        }
      }

      res = Curl_convert_to_network(handle, &in, 1);
      if(res) {
        /* Curl_convert_to_network calls failf if unsuccessful */
        free(ns);
        return NULL;
      }

      snprintf(&ns[strindex], 4, ""%%%02X"", in);

      strindex+=3;
    }
    string++;
  }
  ns[strindex]=0; /* terminate it */
  return ns;
 }
","char *curl_easy_escape(CURL *handle, const char *string, int inlength)
{
  size_t alloc = (inlength?(size_t)inlength:strlen(string))+1;
  char *ns;
   char *testing_ptr = NULL;
   unsigned char in; /* we need to treat the characters unsigned */
   size_t newlen = alloc;
  int strindex=0;
   size_t length;
   CURLcode res;
 
  ns = malloc(alloc);
  if(!ns)
    return NULL;

  length = alloc-1;
  while(length--) {
    in = *string;

    if(Curl_isunreserved(in))
      /* just copy this */
      ns[strindex++]=in;
    else {
      /* encode it */
      newlen += 2; /* the size grows with two, since this'll become a %XX */
      if(newlen > alloc) {
        alloc *= 2;
        testing_ptr = realloc(ns, alloc);
        if(!testing_ptr) {
          free( ns );
          return NULL;
        }
        else {
          ns = testing_ptr;
        }
      }

      res = Curl_convert_to_network(handle, &in, 1);
      if(res) {
        /* Curl_convert_to_network calls failf if unsuccessful */
        free(ns);
        return NULL;
      }

      snprintf(&ns[strindex], 4, ""%%%02X"", in);

      strindex+=3;
    }
    string++;
  }
  ns[strindex]=0; /* terminate it */
  return ns;
 }
",C,"  size_t strindex=0;
","  int strindex=0;
",,"@@ -31,6 +31,7 @@
 #include ""urldata.h""
 #include ""warnless.h""
 #include ""non-ascii.h""
+#include ""escape.h""
 
 #define _MPRINTF_REPLACE /* use our functions only */
 #include <curl/mprintf.h>
@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)
   char *testing_ptr = NULL;
   unsigned char in; /* we need to treat the characters unsigned */
   size_t newlen = alloc;
-  int strindex=0;
+  size_t strindex=0;
   size_t length;
   CURLcode res;
 
@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)
 }
 
 /*
- * Unescapes the given URL escaped string of given length. Returns a
- * pointer to a malloced string with length given in *olen.
- * If length == 0, the length is assumed to be strlen(string).
- * If olen == NULL, no output length is stored.
+ * Curl_urldecode() URL decodes the given string.
+ *
+ * Optionally detects control characters (byte codes lower than 32) in the
+ * data and rejects such data.
+ *
+ * Returns a pointer to a malloced string in *ostring with length given in
+ * *olen. If length == 0, the length is assumed to be strlen(string).
+ *
  */
-char *curl_easy_unescape(CURL *handle, const char *string, int length,
-                         int *olen)
+CURLcode Curl_urldecode(struct SessionHandle *data,
+                        const char *string, size_t length,
+                        char **ostring, size_t *olen,
+                        bool reject_ctrl)
 {
-  int alloc = (length?length:(int)strlen(string))+1;
+  size_t alloc = (length?length:strlen(string))+1;
   char *ns = malloc(alloc);
   unsigned char in;
-  int strindex=0;
+  size_t strindex=0;
   unsigned long hex;
   CURLcode res;
 
   if(!ns)
-    return NULL;
+    return CURLE_OUT_OF_MEMORY;
 
   while(--alloc > 0) {
     in = *string;
@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,
 
       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */
 
-      res = Curl_convert_from_network(handle, &in, 1);
+      res = Curl_convert_from_network(data, &in, 1);
       if(res) {
         /* Curl_convert_from_network calls failf if unsuccessful */
         free(ns);
-        return NULL;
+        return res;
       }
 
       string+=2;
       alloc-=2;
     }
+    if(reject_ctrl && (in < 0x20)) {
+      free(ns);
+      return CURLE_URL_MALFORMAT;
+    }
 
     ns[strindex++] = in;
     string++;
@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,
   if(olen)
     /* store output size */
     *olen = strindex;
-  return ns;
+
+  if(ostring)
+    /* store output string */
+    *ostring = ns;
+
+  return CURLE_OK;
+}
+
+/*
+ * Unescapes the given URL escaped string of given length. Returns a
+ * pointer to a malloced string with length given in *olen.
+ * If length == 0, the length is assumed to be strlen(string).
+ * If olen == NULL, no output length is stored.
+ */
+char *curl_easy_unescape(CURL *handle, const char *string, int length,
+                         int *olen)
+{
+  char *str = NULL;
+  size_t inputlen = length;
+  size_t outputlen;
+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,
+                                FALSE);
+  if(res)
+    return NULL;
+  if(olen)
+    *olen = curlx_uztosi(outputlen);
+  return str;
 }
 
 /* For operating systems/environments that use different malloc/free",curl,75ca568fa1c19de4c5358fed246686de8467c238,db1a856b4f7cf6ae334fb0656b26a18eea317000,1,"char *curl_easy_escape(CURL *handle, const char *string, int inlength)
{
  size_t alloc = (inlength?(size_t)inlength:strlen(string))+1;
  char *ns;
   char *testing_ptr = NULL;
   unsigned char in; /* we need to treat the characters unsigned */
   size_t newlen = alloc;
//flaw_line_below:
  int strindex=0;
//fix_flaw_line_below:
//  size_t strindex=0;
   size_t length;
   CURLcode res;
 
  ns = malloc(alloc);
  if(!ns)
    return NULL;

  length = alloc-1;
  while(length--) {
    in = *string;

    if(Curl_isunreserved(in))
      /* just copy this */
      ns[strindex++]=in;
    else {
      /* encode it */
      newlen += 2; /* the size grows with two, since this'll become a %XX */
      if(newlen > alloc) {
        alloc *= 2;
        testing_ptr = realloc(ns, alloc);
        if(!testing_ptr) {
          free( ns );
          return NULL;
        }
        else {
          ns = testing_ptr;
        }
      }

      res = Curl_convert_to_network(handle, &in, 1);
      if(res) {
        /* Curl_convert_to_network calls failf if unsuccessful */
        free(ns);
        return NULL;
      }

      snprintf(&ns[strindex], 4, ""%%%02X"", in);

      strindex+=3;
    }
    string++;
  }
  ns[strindex]=0; /* terminate it */
  return ns;
 }
"
1101,178837,,Remote,Not required,Partial,CVE-2012-0036,https://www.cvedetails.com/cve/CVE-2012-0036/,CWE-89,Low,Partial,Partial,,2012-04-13,7.5,"curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.",2018-01-09,Sql ,40,https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238,75ca568fa1c19de4c5358fed246686de8467c238,"URL sanitize: reject URLs containing bad data

Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a
decoded manner now use the new Curl_urldecode() function to reject URLs
with embedded control codes (anything that is or decodes to a byte value
less than 32).

URLs containing such codes could easily otherwise be used to do harm and
allow users to do unintended actions with otherwise innocent tools and
applications. Like for example using a URL like
pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get
a mail and instead this would delete one.

This flaw is considered a security vulnerability: CVE-2012-0036

Security advisory at: http://curl.haxx.se/docs/adv_20120124.html

Reported by: Dan Fandrich",7,lib/escape.c,"{""sha"": ""0dd5a1d0a687194492b2c38b54007de3e0775530"", ""filename"": ""lib/escape.c"", ""status"": ""modified"", ""additions"": 50, ""deletions"": 13, ""changes"": 63, ""blob_url"": ""https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c"", ""raw_url"": ""https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c"", ""contents_url"": ""https://api.github.com/repos/curl/curl/contents/lib/escape.c?ref=75ca568fa1c19de4c5358fed246686de8467c238"", ""patch"": ""@@ -31,6 +31,7 @@\n #include \""urldata.h\""\n #include \""warnless.h\""\n #include \""non-ascii.h\""\n+#include \""escape.h\""\n \n #define _MPRINTF_REPLACE /* use our functions only */\n #include <curl/mprintf.h>\n@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n   char *testing_ptr = NULL;\n   unsigned char in; /* we need to treat the characters unsigned */\n   size_t newlen = alloc;\n-  int strindex=0;\n+  size_t strindex=0;\n   size_t length;\n   CURLcode res;\n \n@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n }\n \n /*\n- * Unescapes the given URL escaped string of given length. Returns a\n- * pointer to a malloced string with length given in *olen.\n- * If length == 0, the length is assumed to be strlen(string).\n- * If olen == NULL, no output length is stored.\n+ * Curl_urldecode() URL decodes the given string.\n+ *\n+ * Optionally detects control characters (byte codes lower than 32) in the\n+ * data and rejects such data.\n+ *\n+ * Returns a pointer to a malloced string in *ostring with length given in\n+ * *olen. If length == 0, the length is assumed to be strlen(string).\n+ *\n  */\n-char *curl_easy_unescape(CURL *handle, const char *string, int length,\n-                         int *olen)\n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_ctrl)\n {\n-  int alloc = (length?length:(int)strlen(string))+1;\n+  size_t alloc = (length?length:strlen(string))+1;\n   char *ns = malloc(alloc);\n   unsigned char in;\n-  int strindex=0;\n+  size_t strindex=0;\n   unsigned long hex;\n   CURLcode res;\n \n   if(!ns)\n-    return NULL;\n+    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n \n       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n \n-      res = Curl_convert_from_network(handle, &in, 1);\n+      res = Curl_convert_from_network(data, &in, 1);\n       if(res) {\n         /* Curl_convert_from_network calls failf if unsuccessful */\n         free(ns);\n-        return NULL;\n+        return res;\n       }\n \n       string+=2;\n       alloc-=2;\n     }\n+    if(reject_ctrl && (in < 0x20)) {\n+      free(ns);\n+      return CURLE_URL_MALFORMAT;\n+    }\n \n     ns[strindex++] = in;\n     string++;\n@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n   if(olen)\n     /* store output size */\n     *olen = strindex;\n-  return ns;\n+\n+  if(ostring)\n+    /* store output string */\n+    *ostring = ns;\n+\n+  return CURLE_OK;\n+}\n+\n+/*\n+ * Unescapes the given URL escaped string of given length. Returns a\n+ * pointer to a malloced string with length given in *olen.\n+ * If length == 0, the length is assumed to be strlen(string).\n+ * If olen == NULL, no output length is stored.\n+ */\n+char *curl_easy_unescape(CURL *handle, const char *string, int length,\n+                         int *olen)\n+{\n+  char *str = NULL;\n+  size_t inputlen = length;\n+  size_t outputlen;\n+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,\n+                                FALSE);\n+  if(res)\n+    return NULL;\n+  if(olen)\n+    *olen = curlx_uztosi(outputlen);\n+  return str;\n }\n \n /* For operating systems/environments that use different malloc/free""}<_**next**_>{""sha"": ""4c7f84133b6c5677586fa1258c2a09d2ba8fef20"", ""filename"": ""lib/escape.h"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 3, ""changes"": 10, ""blob_url"": ""https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h"", ""raw_url"": ""https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h"", ""contents_url"": ""https://api.github.com/repos/curl/curl/contents/lib/escape.h?ref=75ca568fa1c19de4c5358fed246686de8467c238"", ""patch"": ""@@ -1,5 +1,5 @@\n-#ifndef __ESCAPE_H\n-#define __ESCAPE_H\n+#ifndef HEADER_CURL_ESCAPE_H\n+#define HEADER_CURL_ESCAPE_H\n \n /***************************************************************************\n  *                                  _   _ ____  _\n@@ -8,7 +8,7 @@\n  *                            | (__| |_| |  _ <| |___\n  *                             \\___|\\___/|_| \\_\\_____|\n  *\n- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.\n+ * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al.\n  *\n  * This software is licensed as described in the file COPYING, which\n  * you should have received as part of this distribution. The terms\n@@ -25,5 +25,9 @@\n /* Escape and unescape URL encoding in strings. The functions return a new\n  * allocated string or NULL if an error occurred.  */\n \n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_crlf);\n \n #endif""}<_**next**_>{""sha"": ""c6701417d0449bdf6280cb6f886e397b36198b19"", ""filename"": ""lib/imap.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 6, ""changes"": 7, ""blob_url"": ""https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c"", ""raw_url"": ""https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c"", ""contents_url"": ""https://api.github.com/repos/curl/curl/contents/lib/imap.c?ref=75ca568fa1c19de4c5358fed246686de8467c238"", ""patch"": ""@@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)\n   struct imap_conn *imapc = &conn->proto.imapc;\n   struct SessionHandle *data = conn->data;\n   const char *path = data->state.path;\n-  int len;\n \n   if(!*path)\n     path = \""INBOX\"";\n \n   /* url decode the path and use this mailbox */\n-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n-  if(!imapc->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */""}<_**next**_>{""sha"": ""cc360b8b95e1b8df55d17180f892945578a10c6a"", ""filename"": ""lib/pop3.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 5, ""changes"": 6, ""blob_url"": ""https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c"", ""raw_url"": ""https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c"", ""contents_url"": ""https://api.github.com/repos/curl/curl/contents/lib/pop3.c?ref=75ca568fa1c19de4c5358fed246686de8467c238"", ""patch"": ""@@ -914,11 +914,7 @@ static CURLcode pop3_parse_url_path(struct connectdata *conn)\n   const char *path = data->state.path;\n \n   /* url decode the path and use this mailbox */\n-  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n-  if(!pop3c->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */""}<_**next**_>{""sha"": ""553c697d063edb448bb7ac80c6d9bac5d1d12d8b"", ""filename"": ""lib/smtp.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c"", ""raw_url"": ""https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c"", ""contents_url"": ""https://api.github.com/repos/curl/curl/contents/lib/smtp.c?ref=75ca568fa1c19de4c5358fed246686de8467c238"", ""patch"": ""@@ -1244,7 +1244,6 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   struct SessionHandle *data = conn->data;\n   struct pingpong *pp = &smtpc->pp;\n   const char *path = conn->data->state.path;\n-  int len;\n   char localhost[HOSTNAME_MAX + 1];\n \n   *done = FALSE; /* default to not done yet */\n@@ -1316,9 +1315,9 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   }\n \n   /* url decode the path and use it as domain with EHLO */\n-  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n-  if(!smtpc->domain)\n-    return CURLE_OUT_OF_MEMORY;\n+  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n+  if(result)\n+    return result;\n \n   /* When we connect, we start in the state where we await the server greeting\n    */""}","char *curl_easy_unescape(CURL *handle, const char *string, int length,
CURLcode Curl_urldecode(struct SessionHandle *data,
                        const char *string, size_t length,
                        char **ostring, size_t *olen,
                        bool reject_ctrl)
 {
  size_t alloc = (length?length:strlen(string))+1;
   char *ns = malloc(alloc);
   unsigned char in;
  size_t strindex=0;
   unsigned long hex;
   CURLcode res;
 
   if(!ns)
    return CURLE_OUT_OF_MEMORY;
 
   while(--alloc > 0) {
     in = *string;
    if(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {
      /* this is two hexadecimal digits following a '%' */
      char hexstr[3];
      char *ptr;
      hexstr[0] = string[1];
      hexstr[1] = string[2];
      hexstr[2] = 0;

      hex = strtoul(hexstr, &ptr, 16);
 
       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */
 
      res = Curl_convert_from_network(data, &in, 1);
       if(res) {
         /* Curl_convert_from_network calls failf if unsuccessful */
         free(ns);
        return res;
       }
 
       string+=2;
       alloc-=2;
     }
    if(reject_ctrl && (in < 0x20)) {
      free(ns);
      return CURLE_URL_MALFORMAT;
    }
 
     ns[strindex++] = in;
     string++;
  }
  ns[strindex]=0; /* terminate it */

   if(olen)
     /* store output size */
     *olen = strindex;

  if(ostring)
    /* store output string */
    *ostring = ns;

  return CURLE_OK;
}

/*
 * Unescapes the given URL escaped string of given length. Returns a
 * pointer to a malloced string with length given in *olen.
 * If length == 0, the length is assumed to be strlen(string).
 * If olen == NULL, no output length is stored.
 */
char *curl_easy_unescape(CURL *handle, const char *string, int length,
                         int *olen)
{
  char *str = NULL;
  size_t inputlen = length;
  size_t outputlen;
  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,
                                FALSE);
  if(res)
    return NULL;
  if(olen)
    *olen = curlx_uztosi(outputlen);
  return str;
 }
","char *curl_easy_unescape(CURL *handle, const char *string, int length,
                         int *olen)
 {
  int alloc = (length?length:(int)strlen(string))+1;
   char *ns = malloc(alloc);
   unsigned char in;
  int strindex=0;
   unsigned long hex;
   CURLcode res;
 
   if(!ns)
    return NULL;
 
   while(--alloc > 0) {
     in = *string;
    if(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {
      /* this is two hexadecimal digits following a '%' */
      char hexstr[3];
      char *ptr;
      hexstr[0] = string[1];
      hexstr[1] = string[2];
      hexstr[2] = 0;

      hex = strtoul(hexstr, &ptr, 16);
 
       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */
 
      res = Curl_convert_from_network(handle, &in, 1);
       if(res) {
         /* Curl_convert_from_network calls failf if unsuccessful */
         free(ns);
        return NULL;
       }
 
       string+=2;
       alloc-=2;
     }
 
     ns[strindex++] = in;
     string++;
  }
  ns[strindex]=0; /* terminate it */

   if(olen)
     /* store output size */
     *olen = strindex;
  return ns;
 }
",C,"CURLcode Curl_urldecode(struct SessionHandle *data,
                        const char *string, size_t length,
                        char **ostring, size_t *olen,
                        bool reject_ctrl)
  size_t alloc = (length?length:strlen(string))+1;
  size_t strindex=0;
    return CURLE_OUT_OF_MEMORY;
      res = Curl_convert_from_network(data, &in, 1);
        return res;
    if(reject_ctrl && (in < 0x20)) {
      free(ns);
      return CURLE_URL_MALFORMAT;
    }

  if(ostring)
    /* store output string */
    *ostring = ns;

  return CURLE_OK;
}

/*
 * Unescapes the given URL escaped string of given length. Returns a
 * pointer to a malloced string with length given in *olen.
 * If length == 0, the length is assumed to be strlen(string).
 * If olen == NULL, no output length is stored.
 */
char *curl_easy_unescape(CURL *handle, const char *string, int length,
                         int *olen)
{
  char *str = NULL;
  size_t inputlen = length;
  size_t outputlen;
  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,
                                FALSE);
  if(res)
    return NULL;
  if(olen)
    *olen = curlx_uztosi(outputlen);
  return str;
","                         int *olen)
  int alloc = (length?length:(int)strlen(string))+1;
  int strindex=0;
    return NULL;
      res = Curl_convert_from_network(handle, &in, 1);
        return NULL;
  return ns;
",,"@@ -31,6 +31,7 @@
 #include ""urldata.h""
 #include ""warnless.h""
 #include ""non-ascii.h""
+#include ""escape.h""
 
 #define _MPRINTF_REPLACE /* use our functions only */
 #include <curl/mprintf.h>
@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)
   char *testing_ptr = NULL;
   unsigned char in; /* we need to treat the characters unsigned */
   size_t newlen = alloc;
-  int strindex=0;
+  size_t strindex=0;
   size_t length;
   CURLcode res;
 
@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)
 }
 
 /*
- * Unescapes the given URL escaped string of given length. Returns a
- * pointer to a malloced string with length given in *olen.
- * If length == 0, the length is assumed to be strlen(string).
- * If olen == NULL, no output length is stored.
+ * Curl_urldecode() URL decodes the given string.
+ *
+ * Optionally detects control characters (byte codes lower than 32) in the
+ * data and rejects such data.
+ *
+ * Returns a pointer to a malloced string in *ostring with length given in
+ * *olen. If length == 0, the length is assumed to be strlen(string).
+ *
  */
-char *curl_easy_unescape(CURL *handle, const char *string, int length,
-                         int *olen)
+CURLcode Curl_urldecode(struct SessionHandle *data,
+                        const char *string, size_t length,
+                        char **ostring, size_t *olen,
+                        bool reject_ctrl)
 {
-  int alloc = (length?length:(int)strlen(string))+1;
+  size_t alloc = (length?length:strlen(string))+1;
   char *ns = malloc(alloc);
   unsigned char in;
-  int strindex=0;
+  size_t strindex=0;
   unsigned long hex;
   CURLcode res;
 
   if(!ns)
-    return NULL;
+    return CURLE_OUT_OF_MEMORY;
 
   while(--alloc > 0) {
     in = *string;
@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,
 
       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */
 
-      res = Curl_convert_from_network(handle, &in, 1);
+      res = Curl_convert_from_network(data, &in, 1);
       if(res) {
         /* Curl_convert_from_network calls failf if unsuccessful */
         free(ns);
-        return NULL;
+        return res;
       }
 
       string+=2;
       alloc-=2;
     }
+    if(reject_ctrl && (in < 0x20)) {
+      free(ns);
+      return CURLE_URL_MALFORMAT;
+    }
 
     ns[strindex++] = in;
     string++;
@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,
   if(olen)
     /* store output size */
     *olen = strindex;
-  return ns;
+
+  if(ostring)
+    /* store output string */
+    *ostring = ns;
+
+  return CURLE_OK;
+}
+
+/*
+ * Unescapes the given URL escaped string of given length. Returns a
+ * pointer to a malloced string with length given in *olen.
+ * If length == 0, the length is assumed to be strlen(string).
+ * If olen == NULL, no output length is stored.
+ */
+char *curl_easy_unescape(CURL *handle, const char *string, int length,
+                         int *olen)
+{
+  char *str = NULL;
+  size_t inputlen = length;
+  size_t outputlen;
+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,
+                                FALSE);
+  if(res)
+    return NULL;
+  if(olen)
+    *olen = curlx_uztosi(outputlen);
+  return str;
 }
 
 /* For operating systems/environments that use different malloc/free",curl,75ca568fa1c19de4c5358fed246686de8467c238,db1a856b4f7cf6ae334fb0656b26a18eea317000,1,"char *curl_easy_unescape(CURL *handle, const char *string, int length,
//flaw_line_below:
                         int *olen)
//fix_flaw_line_below:
//CURLcode Curl_urldecode(struct SessionHandle *data,
//fix_flaw_line_below:
//                        const char *string, size_t length,
//fix_flaw_line_below:
//                        char **ostring, size_t *olen,
//fix_flaw_line_below:
//                        bool reject_ctrl)
 {
//flaw_line_below:
  int alloc = (length?length:(int)strlen(string))+1;
//fix_flaw_line_below:
//  size_t alloc = (length?length:strlen(string))+1;
   char *ns = malloc(alloc);
   unsigned char in;
//flaw_line_below:
  int strindex=0;
//fix_flaw_line_below:
//  size_t strindex=0;
   unsigned long hex;
   CURLcode res;
 
   if(!ns)
//flaw_line_below:
    return NULL;
//fix_flaw_line_below:
//    return CURLE_OUT_OF_MEMORY;
 
   while(--alloc > 0) {
     in = *string;
    if(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {
      /* this is two hexadecimal digits following a '%' */
      char hexstr[3];
      char *ptr;
      hexstr[0] = string[1];
      hexstr[1] = string[2];
      hexstr[2] = 0;

      hex = strtoul(hexstr, &ptr, 16);
 
       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */
 
//flaw_line_below:
      res = Curl_convert_from_network(handle, &in, 1);
//fix_flaw_line_below:
//      res = Curl_convert_from_network(data, &in, 1);
       if(res) {
         /* Curl_convert_from_network calls failf if unsuccessful */
         free(ns);
//flaw_line_below:
        return NULL;
//fix_flaw_line_below:
//        return res;
       }
 
       string+=2;
       alloc-=2;
     }
//fix_flaw_line_below:
//    if(reject_ctrl && (in < 0x20)) {
//fix_flaw_line_below:
//      free(ns);
//fix_flaw_line_below:
//      return CURLE_URL_MALFORMAT;
//fix_flaw_line_below:
//    }
 
     ns[strindex++] = in;
     string++;
  }
  ns[strindex]=0; /* terminate it */

   if(olen)
     /* store output size */
     *olen = strindex;
//flaw_line_below:
  return ns;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  if(ostring)
//fix_flaw_line_below:
//    /* store output string */
//fix_flaw_line_below:
//    *ostring = ns;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  return CURLE_OK;
//fix_flaw_line_below:
//}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
///*
//fix_flaw_line_below:
// * Unescapes the given URL escaped string of given length. Returns a
//fix_flaw_line_below:
// * pointer to a malloced string with length given in *olen.
//fix_flaw_line_below:
// * If length == 0, the length is assumed to be strlen(string).
//fix_flaw_line_below:
// * If olen == NULL, no output length is stored.
//fix_flaw_line_below:
// */
//fix_flaw_line_below:
//char *curl_easy_unescape(CURL *handle, const char *string, int length,
//fix_flaw_line_below:
//                         int *olen)
//fix_flaw_line_below:
//{
//fix_flaw_line_below:
//  char *str = NULL;
//fix_flaw_line_below:
//  size_t inputlen = length;
//fix_flaw_line_below:
//  size_t outputlen;
//fix_flaw_line_below:
//  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,
//fix_flaw_line_below:
//                                FALSE);
//fix_flaw_line_below:
//  if(res)
//fix_flaw_line_below:
//    return NULL;
//fix_flaw_line_below:
//  if(olen)
//fix_flaw_line_below:
//    *olen = curlx_uztosi(outputlen);
//fix_flaw_line_below:
//  return str;
 }
"
1102,178838,,Remote,Not required,Partial,CVE-2012-0036,https://www.cvedetails.com/cve/CVE-2012-0036/,CWE-89,Low,Partial,Partial,,2012-04-13,7.5,"curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.",2018-01-09,Sql ,1,https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238,75ca568fa1c19de4c5358fed246686de8467c238,"URL sanitize: reject URLs containing bad data

Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a
decoded manner now use the new Curl_urldecode() function to reject URLs
with embedded control codes (anything that is or decodes to a byte value
less than 32).

URLs containing such codes could easily otherwise be used to do harm and
allow users to do unintended actions with otherwise innocent tools and
applications. Like for example using a URL like
pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get
a mail and instead this would delete one.

This flaw is considered a security vulnerability: CVE-2012-0036

Security advisory at: http://curl.haxx.se/docs/adv_20120124.html

Reported by: Dan Fandrich",5,lib/imap.c,"{""sha"": ""0dd5a1d0a687194492b2c38b54007de3e0775530"", ""filename"": ""lib/escape.c"", ""status"": ""modified"", ""additions"": 50, ""deletions"": 13, ""changes"": 63, ""blob_url"": ""https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c"", ""raw_url"": ""https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.c"", ""contents_url"": ""https://api.github.com/repos/curl/curl/contents/lib/escape.c?ref=75ca568fa1c19de4c5358fed246686de8467c238"", ""patch"": ""@@ -31,6 +31,7 @@\n #include \""urldata.h\""\n #include \""warnless.h\""\n #include \""non-ascii.h\""\n+#include \""escape.h\""\n \n #define _MPRINTF_REPLACE /* use our functions only */\n #include <curl/mprintf.h>\n@@ -84,7 +85,7 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n   char *testing_ptr = NULL;\n   unsigned char in; /* we need to treat the characters unsigned */\n   size_t newlen = alloc;\n-  int strindex=0;\n+  size_t strindex=0;\n   size_t length;\n   CURLcode res;\n \n@@ -132,23 +133,29 @@ char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n }\n \n /*\n- * Unescapes the given URL escaped string of given length. Returns a\n- * pointer to a malloced string with length given in *olen.\n- * If length == 0, the length is assumed to be strlen(string).\n- * If olen == NULL, no output length is stored.\n+ * Curl_urldecode() URL decodes the given string.\n+ *\n+ * Optionally detects control characters (byte codes lower than 32) in the\n+ * data and rejects such data.\n+ *\n+ * Returns a pointer to a malloced string in *ostring with length given in\n+ * *olen. If length == 0, the length is assumed to be strlen(string).\n+ *\n  */\n-char *curl_easy_unescape(CURL *handle, const char *string, int length,\n-                         int *olen)\n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_ctrl)\n {\n-  int alloc = (length?length:(int)strlen(string))+1;\n+  size_t alloc = (length?length:strlen(string))+1;\n   char *ns = malloc(alloc);\n   unsigned char in;\n-  int strindex=0;\n+  size_t strindex=0;\n   unsigned long hex;\n   CURLcode res;\n \n   if(!ns)\n-    return NULL;\n+    return CURLE_OUT_OF_MEMORY;\n \n   while(--alloc > 0) {\n     in = *string;\n@@ -164,16 +171,20 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n \n       in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n \n-      res = Curl_convert_from_network(handle, &in, 1);\n+      res = Curl_convert_from_network(data, &in, 1);\n       if(res) {\n         /* Curl_convert_from_network calls failf if unsuccessful */\n         free(ns);\n-        return NULL;\n+        return res;\n       }\n \n       string+=2;\n       alloc-=2;\n     }\n+    if(reject_ctrl && (in < 0x20)) {\n+      free(ns);\n+      return CURLE_URL_MALFORMAT;\n+    }\n \n     ns[strindex++] = in;\n     string++;\n@@ -183,7 +194,33 @@ char *curl_easy_unescape(CURL *handle, const char *string, int length,\n   if(olen)\n     /* store output size */\n     *olen = strindex;\n-  return ns;\n+\n+  if(ostring)\n+    /* store output string */\n+    *ostring = ns;\n+\n+  return CURLE_OK;\n+}\n+\n+/*\n+ * Unescapes the given URL escaped string of given length. Returns a\n+ * pointer to a malloced string with length given in *olen.\n+ * If length == 0, the length is assumed to be strlen(string).\n+ * If olen == NULL, no output length is stored.\n+ */\n+char *curl_easy_unescape(CURL *handle, const char *string, int length,\n+                         int *olen)\n+{\n+  char *str = NULL;\n+  size_t inputlen = length;\n+  size_t outputlen;\n+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,\n+                                FALSE);\n+  if(res)\n+    return NULL;\n+  if(olen)\n+    *olen = curlx_uztosi(outputlen);\n+  return str;\n }\n \n /* For operating systems/environments that use different malloc/free""}<_**next**_>{""sha"": ""4c7f84133b6c5677586fa1258c2a09d2ba8fef20"", ""filename"": ""lib/escape.h"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 3, ""changes"": 10, ""blob_url"": ""https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h"", ""raw_url"": ""https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/escape.h"", ""contents_url"": ""https://api.github.com/repos/curl/curl/contents/lib/escape.h?ref=75ca568fa1c19de4c5358fed246686de8467c238"", ""patch"": ""@@ -1,5 +1,5 @@\n-#ifndef __ESCAPE_H\n-#define __ESCAPE_H\n+#ifndef HEADER_CURL_ESCAPE_H\n+#define HEADER_CURL_ESCAPE_H\n \n /***************************************************************************\n  *                                  _   _ ____  _\n@@ -8,7 +8,7 @@\n  *                            | (__| |_| |  _ <| |___\n  *                             \\___|\\___/|_| \\_\\_____|\n  *\n- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.\n+ * Copyright (C) 1998 - 2011, Daniel Stenberg, <daniel@haxx.se>, et al.\n  *\n  * This software is licensed as described in the file COPYING, which\n  * you should have received as part of this distribution. The terms\n@@ -25,5 +25,9 @@\n /* Escape and unescape URL encoding in strings. The functions return a new\n  * allocated string or NULL if an error occurred.  */\n \n+CURLcode Curl_urldecode(struct SessionHandle *data,\n+                        const char *string, size_t length,\n+                        char **ostring, size_t *olen,\n+                        bool reject_crlf);\n \n #endif""}<_**next**_>{""sha"": ""c6701417d0449bdf6280cb6f886e397b36198b19"", ""filename"": ""lib/imap.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 6, ""changes"": 7, ""blob_url"": ""https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c"", ""raw_url"": ""https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/imap.c"", ""contents_url"": ""https://api.github.com/repos/curl/curl/contents/lib/imap.c?ref=75ca568fa1c19de4c5358fed246686de8467c238"", ""patch"": ""@@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)\n   struct imap_conn *imapc = &conn->proto.imapc;\n   struct SessionHandle *data = conn->data;\n   const char *path = data->state.path;\n-  int len;\n \n   if(!*path)\n     path = \""INBOX\"";\n \n   /* url decode the path and use this mailbox */\n-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n-  if(!imapc->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */""}<_**next**_>{""sha"": ""cc360b8b95e1b8df55d17180f892945578a10c6a"", ""filename"": ""lib/pop3.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 5, ""changes"": 6, ""blob_url"": ""https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c"", ""raw_url"": ""https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/pop3.c"", ""contents_url"": ""https://api.github.com/repos/curl/curl/contents/lib/pop3.c?ref=75ca568fa1c19de4c5358fed246686de8467c238"", ""patch"": ""@@ -914,11 +914,7 @@ static CURLcode pop3_parse_url_path(struct connectdata *conn)\n   const char *path = data->state.path;\n \n   /* url decode the path and use this mailbox */\n-  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n-  if(!pop3c->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n }\n \n /* call this when the DO phase has completed */""}<_**next**_>{""sha"": ""553c697d063edb448bb7ac80c6d9bac5d1d12d8b"", ""filename"": ""lib/smtp.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/curl/curl/blob/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c"", ""raw_url"": ""https://github.com/curl/curl/raw/75ca568fa1c19de4c5358fed246686de8467c238/lib/smtp.c"", ""contents_url"": ""https://api.github.com/repos/curl/curl/contents/lib/smtp.c?ref=75ca568fa1c19de4c5358fed246686de8467c238"", ""patch"": ""@@ -1244,7 +1244,6 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   struct SessionHandle *data = conn->data;\n   struct pingpong *pp = &smtpc->pp;\n   const char *path = conn->data->state.path;\n-  int len;\n   char localhost[HOSTNAME_MAX + 1];\n \n   *done = FALSE; /* default to not done yet */\n@@ -1316,9 +1315,9 @@ static CURLcode smtp_connect(struct connectdata *conn,\n   }\n \n   /* url decode the path and use it as domain with EHLO */\n-  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n-  if(!smtpc->domain)\n-    return CURLE_OUT_OF_MEMORY;\n+  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n+  if(result)\n+    return result;\n \n   /* When we connect, we start in the state where we await the server greeting\n    */""}","static CURLcode imap_parse_url_path(struct connectdata *conn)
{
  /* the imap struct is already inited in imap_connect() */
   struct imap_conn *imapc = &conn->proto.imapc;
   struct SessionHandle *data = conn->data;
   const char *path = data->state.path;
 
   if(!*path)
     path = ""INBOX"";
 
   /* url decode the path and use this mailbox */
  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);
 }
","static CURLcode imap_parse_url_path(struct connectdata *conn)
{
  /* the imap struct is already inited in imap_connect() */
   struct imap_conn *imapc = &conn->proto.imapc;
   struct SessionHandle *data = conn->data;
   const char *path = data->state.path;
  int len;
 
   if(!*path)
     path = ""INBOX"";
 
   /* url decode the path and use this mailbox */
  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);
  if(!imapc->mailbox)
    return CURLE_OUT_OF_MEMORY;
  return CURLE_OK;
 }
",C,"  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);
","  int len;
  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);
  if(!imapc->mailbox)
    return CURLE_OUT_OF_MEMORY;
  return CURLE_OK;
",,"@@ -953,17 +953,12 @@ static CURLcode imap_parse_url_path(struct connectdata *conn)
   struct imap_conn *imapc = &conn->proto.imapc;
   struct SessionHandle *data = conn->data;
   const char *path = data->state.path;
-  int len;
 
   if(!*path)
     path = ""INBOX"";
 
   /* url decode the path and use this mailbox */
-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);
-  if(!imapc->mailbox)
-    return CURLE_OUT_OF_MEMORY;
-
-  return CURLE_OK;
+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);
 }
 
 /* call this when the DO phase has completed */",curl,75ca568fa1c19de4c5358fed246686de8467c238,db1a856b4f7cf6ae334fb0656b26a18eea317000,1,"static CURLcode imap_parse_url_path(struct connectdata *conn)
{
  /* the imap struct is already inited in imap_connect() */
   struct imap_conn *imapc = &conn->proto.imapc;
   struct SessionHandle *data = conn->data;
   const char *path = data->state.path;
//flaw_line_below:
  int len;
 
   if(!*path)
     path = ""INBOX"";
 
   /* url decode the path and use this mailbox */
//flaw_line_below:
  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);
//flaw_line_below:
  if(!imapc->mailbox)
//flaw_line_below:
    return CURLE_OUT_OF_MEMORY;
//flaw_line_below:

//flaw_line_below:
  return CURLE_OK;
//fix_flaw_line_below:
//  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);
 }
"
1961,179697,,Remote,Not required,Partial,CVE-2013-7262,https://www.cvedetails.com/cve/CVE-2013-7262/,CWE-89,Medium,Partial,Partial,,2014-01-05,6.8,"SQL injection vulnerability in the msPostGISLayerSetTimeFilter function in mappostgis.c in MapServer before 6.4.1, when a WMS-Time service is used, allows remote attackers to execute arbitrary SQL commands via a crafted string in a PostGIS TIME filter.",2015-10-08,Exec Code Sql ,5,https://github.com/mapserver/mapserver/commit/3a10f6b829297dae63492a8c63385044bc6953ed,3a10f6b829297dae63492a8c63385044bc6953ed,Fix potential SQL Injection with postgis TIME filters (#4834),0,mappostgis.c,"{""sha"": ""f24d9697a3447c78dc90d6fef84f3ad9bf21d43f"", ""filename"": ""mappostgis.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/mapserver/mapserver/blob/3a10f6b829297dae63492a8c63385044bc6953ed/mappostgis.c"", ""raw_url"": ""https://github.com/mapserver/mapserver/raw/3a10f6b829297dae63492a8c63385044bc6953ed/mappostgis.c"", ""contents_url"": ""https://api.github.com/repos/mapserver/mapserver/contents/mappostgis.c?ref=3a10f6b829297dae63492a8c63385044bc6953ed"", ""patch"": ""@@ -3212,6 +3212,11 @@ int msPostGISLayerSetTimeFilter(layerObj *lp, const char *timestring, const char\n   if (!lp || !timestring || !timefield)\n     return MS_FALSE;\n \n+  if( strchr(timestring,'\\'') || strchr(timestring, '\\\\') ) {\n+     msSetError(MS_MISCERR, \""Invalid time filter.\"", \""msPostGISLayerSetTimeFilter()\"");\n+     return MS_FALSE;\n+  }\n+\n   /* discrete time */\n   if (strstr(timestring, \"",\"") == NULL &&\n       strstr(timestring, \""/\"") == NULL) { /* discrete time */""}","int msPostGISLayerSetTimeFilter(layerObj *lp, const char *timestring, const char *timefield)
{
  char **atimes, **aranges = NULL;
  int numtimes=0,i=0,numranges=0;
  size_t buffer_size = 512;
  char buffer[512], bufferTmp[512];

  buffer[0] = '\0';
  bufferTmp[0] = '\0';

   if (!lp || !timestring || !timefield)
     return MS_FALSE;
 
  if( strchr(timestring,'\'') || strchr(timestring, '\\') ) {
     msSetError(MS_MISCERR, ""Invalid time filter."", ""msPostGISLayerSetTimeFilter()"");
     return MS_FALSE;
  }

   /* discrete time */
   if (strstr(timestring, "","") == NULL &&
       strstr(timestring, ""/"") == NULL) { /* discrete time */
    createPostgresTimeCompareSimple(timefield, timestring, buffer, buffer_size);
  } else {

    /* multiple times, or ranges */
    atimes = msStringSplit (timestring, ',', &numtimes);
    if (atimes == NULL || numtimes < 1)
      return MS_FALSE;

    strlcat(buffer, ""("", buffer_size);
    for(i=0; i<numtimes; i++) {
      if(i!=0) {
        strlcat(buffer, "" OR "", buffer_size);
      }
      strlcat(buffer, ""("", buffer_size);
      aranges = msStringSplit(atimes[i],  '/', &numranges);
      if(!aranges) return MS_FALSE;
      if(numranges == 1) {
        /* we don't have range, just a simple time */
        createPostgresTimeCompareSimple(timefield, atimes[i], bufferTmp, buffer_size);
        strlcat(buffer, bufferTmp, buffer_size);
      } else if(numranges == 2) {
        /* we have a range */
        createPostgresTimeCompareRange(timefield, aranges[0], aranges[1], bufferTmp, buffer_size);
        strlcat(buffer, bufferTmp, buffer_size);
      } else {
        return MS_FALSE;
      }
      msFreeCharArray(aranges, numranges);
      strlcat(buffer, "")"", buffer_size);
    }
    strlcat(buffer, "")"", buffer_size);
    msFreeCharArray(atimes, numtimes);
  }
  if(!*buffer) {
    return MS_FALSE;
  }
  if(lp->filteritem) free(lp->filteritem);
  lp->filteritem = msStrdup(timefield);
  if (&lp->filter) {
    /* if the filter is set and it's a string type, concatenate it with
       the time. If not just free it */
    if (lp->filter.type == MS_EXPRESSION) {
      snprintf(bufferTmp, buffer_size, ""(%s) and %s"", lp->filter.string, buffer);
      loadExpressionString(&lp->filter, bufferTmp);
    } else {
      freeExpression(&lp->filter);
      loadExpressionString(&lp->filter, buffer);
    }
  }


  return MS_TRUE;
}
","int msPostGISLayerSetTimeFilter(layerObj *lp, const char *timestring, const char *timefield)
{
  char **atimes, **aranges = NULL;
  int numtimes=0,i=0,numranges=0;
  size_t buffer_size = 512;
  char buffer[512], bufferTmp[512];

  buffer[0] = '\0';
  bufferTmp[0] = '\0';

   if (!lp || !timestring || !timefield)
     return MS_FALSE;
 
   /* discrete time */
   if (strstr(timestring, "","") == NULL &&
       strstr(timestring, ""/"") == NULL) { /* discrete time */
    createPostgresTimeCompareSimple(timefield, timestring, buffer, buffer_size);
  } else {

    /* multiple times, or ranges */
    atimes = msStringSplit (timestring, ',', &numtimes);
    if (atimes == NULL || numtimes < 1)
      return MS_FALSE;

    strlcat(buffer, ""("", buffer_size);
    for(i=0; i<numtimes; i++) {
      if(i!=0) {
        strlcat(buffer, "" OR "", buffer_size);
      }
      strlcat(buffer, ""("", buffer_size);
      aranges = msStringSplit(atimes[i],  '/', &numranges);
      if(!aranges) return MS_FALSE;
      if(numranges == 1) {
        /* we don't have range, just a simple time */
        createPostgresTimeCompareSimple(timefield, atimes[i], bufferTmp, buffer_size);
        strlcat(buffer, bufferTmp, buffer_size);
      } else if(numranges == 2) {
        /* we have a range */
        createPostgresTimeCompareRange(timefield, aranges[0], aranges[1], bufferTmp, buffer_size);
        strlcat(buffer, bufferTmp, buffer_size);
      } else {
        return MS_FALSE;
      }
      msFreeCharArray(aranges, numranges);
      strlcat(buffer, "")"", buffer_size);
    }
    strlcat(buffer, "")"", buffer_size);
    msFreeCharArray(atimes, numtimes);
  }
  if(!*buffer) {
    return MS_FALSE;
  }
  if(lp->filteritem) free(lp->filteritem);
  lp->filteritem = msStrdup(timefield);
  if (&lp->filter) {
    /* if the filter is set and it's a string type, concatenate it with
       the time. If not just free it */
    if (lp->filter.type == MS_EXPRESSION) {
      snprintf(bufferTmp, buffer_size, ""(%s) and %s"", lp->filter.string, buffer);
      loadExpressionString(&lp->filter, bufferTmp);
    } else {
      freeExpression(&lp->filter);
      loadExpressionString(&lp->filter, buffer);
    }
  }


  return MS_TRUE;
}
",C,"  if( strchr(timestring,'\'') || strchr(timestring, '\\') ) {
     msSetError(MS_MISCERR, ""Invalid time filter."", ""msPostGISLayerSetTimeFilter()"");
     return MS_FALSE;
  }

",,,"@@ -3212,6 +3212,11 @@ int msPostGISLayerSetTimeFilter(layerObj *lp, const char *timestring, const char
   if (!lp || !timestring || !timefield)
     return MS_FALSE;
 
+  if( strchr(timestring,'\'') || strchr(timestring, '\\') ) {
+     msSetError(MS_MISCERR, ""Invalid time filter."", ""msPostGISLayerSetTimeFilter()"");
+     return MS_FALSE;
+  }
+
   /* discrete time */
   if (strstr(timestring, "","") == NULL &&
       strstr(timestring, ""/"") == NULL) { /* discrete time */",mapserver,3a10f6b829297dae63492a8c63385044bc6953ed,e83a0cb57e554884aaf37cbae330602c726d4868,1,"int msPostGISLayerSetTimeFilter(layerObj *lp, const char *timestring, const char *timefield)
{
  char **atimes, **aranges = NULL;
  int numtimes=0,i=0,numranges=0;
  size_t buffer_size = 512;
  char buffer[512], bufferTmp[512];

  buffer[0] = '\0';
  bufferTmp[0] = '\0';

   if (!lp || !timestring || !timefield)
     return MS_FALSE;
 
//fix_flaw_line_below:
//  if( strchr(timestring,'\'') || strchr(timestring, '\\') ) {
//fix_flaw_line_below:
//     msSetError(MS_MISCERR, ""Invalid time filter."", ""msPostGISLayerSetTimeFilter()"");
//fix_flaw_line_below:
//     return MS_FALSE;
//fix_flaw_line_below:
//  }
//fix_flaw_line_below:
//
   /* discrete time */
   if (strstr(timestring, "","") == NULL &&
       strstr(timestring, ""/"") == NULL) { /* discrete time */
    createPostgresTimeCompareSimple(timefield, timestring, buffer, buffer_size);
  } else {

    /* multiple times, or ranges */
    atimes = msStringSplit (timestring, ',', &numtimes);
    if (atimes == NULL || numtimes < 1)
      return MS_FALSE;

    strlcat(buffer, ""("", buffer_size);
    for(i=0; i<numtimes; i++) {
      if(i!=0) {
        strlcat(buffer, "" OR "", buffer_size);
      }
      strlcat(buffer, ""("", buffer_size);
      aranges = msStringSplit(atimes[i],  '/', &numranges);
      if(!aranges) return MS_FALSE;
      if(numranges == 1) {
        /* we don't have range, just a simple time */
        createPostgresTimeCompareSimple(timefield, atimes[i], bufferTmp, buffer_size);
        strlcat(buffer, bufferTmp, buffer_size);
      } else if(numranges == 2) {
        /* we have a range */
        createPostgresTimeCompareRange(timefield, aranges[0], aranges[1], bufferTmp, buffer_size);
        strlcat(buffer, bufferTmp, buffer_size);
      } else {
        return MS_FALSE;
      }
      msFreeCharArray(aranges, numranges);
      strlcat(buffer, "")"", buffer_size);
    }
    strlcat(buffer, "")"", buffer_size);
    msFreeCharArray(atimes, numtimes);
  }
  if(!*buffer) {
    return MS_FALSE;
  }
  if(lp->filteritem) free(lp->filteritem);
  lp->filteritem = msStrdup(timefield);
  if (&lp->filter) {
    /* if the filter is set and it's a string type, concatenate it with
       the time. If not just free it */
    if (lp->filter.type == MS_EXPRESSION) {
      snprintf(bufferTmp, buffer_size, ""(%s) and %s"", lp->filter.string, buffer);
      loadExpressionString(&lp->filter, bufferTmp);
    } else {
      freeExpression(&lp->filter);
      loadExpressionString(&lp->filter, buffer);
    }
  }


  return MS_TRUE;
}
"
5150,182886,,Remote,Not required,Partial,CVE-2019-10664,https://www.cvedetails.com/cve/CVE-2019-10664/,CWE-89,Low,Partial,Partial,,2019-03-31,7.5,Domoticz before 4.10578 allows SQL Injection via the idx parameter in CWebServer::GetFloorplanImage in WebServer.cpp.,2019-05-03,Sql ,1,https://github.com/domoticz/domoticz/commit/ee70db46f81afa582c96b887b73bcd2a86feda00,ee70db46f81afa582c96b887b73bcd2a86feda00,Fixed possible SQL Injection Vulnerability (Thanks to Fabio Carretto!),1,main/WebServer.cpp,"{""sha"": ""ece2155fd2133e0666889f88a3e332ad42917a4b"", ""filename"": ""main/WebServer.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/domoticz/domoticz/blob/ee70db46f81afa582c96b887b73bcd2a86feda00/main/WebServer.cpp"", ""raw_url"": ""https://github.com/domoticz/domoticz/raw/ee70db46f81afa582c96b887b73bcd2a86feda00/main/WebServer.cpp"", ""contents_url"": ""https://api.github.com/repos/domoticz/domoticz/contents/main/WebServer.cpp?ref=ee70db46f81afa582c96b887b73bcd2a86feda00"", ""patch"": ""@@ -10772,7 +10772,7 @@ namespace http {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tstd::vector<std::vector<std::string> > result;\n-\t\t\tresult = m_sql.safe_queryBlob(\""SELECT Image FROM Floorplans WHERE ID=%s\"", idx.c_str());\n+\t\t\tresult = m_sql.safe_queryBlob(\""SELECT Image FROM Floorplans WHERE ID=%d\"", atol(idx.c_str()));\n \t\t\tif (result.empty())\n \t\t\t\treturn;\n \t\t\treply::set_content(&rep, result[0][0].begin(), result[0][0].end());""}","		void CWebServer::GetFloorplanImage(WebEmSession & session, const request& req, reply & rep)
		{
			std::string idx = request::findValue(&req, ""idx"");
			if (idx == """") {
 				return;
 			}
 			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_queryBlob(""SELECT Image FROM Floorplans WHERE ID=%d"", atol(idx.c_str()));
 			if (result.empty())
 				return;
 			reply::set_content(&rep, result[0][0].begin(), result[0][0].end());
			std::string oname = ""floorplan"";
			if (result[0][0].size() > 10)
			{
				if (result[0][0][0] == 'P')
					oname += "".png"";
				else if (result[0][0][0] == -1)
					oname += "".jpg"";
				else if (result[0][0][0] == 'B')
					oname += "".bmp"";
				else if (result[0][0][0] == 'G')
					oname += "".gif"";
			}
			reply::add_header_attachment(&rep, oname);
		}
","		void CWebServer::GetFloorplanImage(WebEmSession & session, const request& req, reply & rep)
		{
			std::string idx = request::findValue(&req, ""idx"");
			if (idx == """") {
 				return;
 			}
 			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_queryBlob(""SELECT Image FROM Floorplans WHERE ID=%s"", idx.c_str());
 			if (result.empty())
 				return;
 			reply::set_content(&rep, result[0][0].begin(), result[0][0].end());
			std::string oname = ""floorplan"";
			if (result[0][0].size() > 10)
			{
				if (result[0][0][0] == 'P')
					oname += "".png"";
				else if (result[0][0][0] == -1)
					oname += "".jpg"";
				else if (result[0][0][0] == 'B')
					oname += "".bmp"";
				else if (result[0][0][0] == 'G')
					oname += "".gif"";
			}
			reply::add_header_attachment(&rep, oname);
		}
",C,"			result = m_sql.safe_queryBlob(""SELECT Image FROM Floorplans WHERE ID=%d"", atol(idx.c_str()));
","			result = m_sql.safe_queryBlob(""SELECT Image FROM Floorplans WHERE ID=%s"", idx.c_str());
",,"@@ -10772,7 +10772,7 @@ namespace http {
 				return;
 			}
 			std::vector<std::vector<std::string> > result;
-			result = m_sql.safe_queryBlob(""SELECT Image FROM Floorplans WHERE ID=%s"", idx.c_str());
+			result = m_sql.safe_queryBlob(""SELECT Image FROM Floorplans WHERE ID=%d"", atol(idx.c_str()));
 			if (result.empty())
 				return;
 			reply::set_content(&rep, result[0][0].begin(), result[0][0].end());",domoticz,ee70db46f81afa582c96b887b73bcd2a86feda00,9c9319ace1f0a76b12bf349d62f455a506d286df,1,"		void CWebServer::GetFloorplanImage(WebEmSession & session, const request& req, reply & rep)
		{
			std::string idx = request::findValue(&req, ""idx"");
			if (idx == """") {
 				return;
 			}
 			std::vector<std::vector<std::string> > result;
//flaw_line_below:
			result = m_sql.safe_queryBlob(""SELECT Image FROM Floorplans WHERE ID=%s"", idx.c_str());
//fix_flaw_line_below:
//			result = m_sql.safe_queryBlob(""SELECT Image FROM Floorplans WHERE ID=%d"", atol(idx.c_str()));
 			if (result.empty())
 				return;
 			reply::set_content(&rep, result[0][0].begin(), result[0][0].end());
			std::string oname = ""floorplan"";
			if (result[0][0].size() > 10)
			{
				if (result[0][0][0] == 'P')
					oname += "".png"";
				else if (result[0][0][0] == -1)
					oname += "".jpg"";
				else if (result[0][0][0] == 'B')
					oname += "".bmp"";
				else if (result[0][0][0] == 'G')
					oname += "".gif"";
			}
			reply::add_header_attachment(&rep, oname);
		}
"
