,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix
3701,181437,,Remote,Not required,,CVE-2017-7524,https://www.cvedetails.com/cve/CVE-2017-7524/,CWE-522,Low,Partial,,,2017-06-27,5.0,tpm2-tools versions before 1.1.1 are vulnerable to a password leak due to transmitting password in plaintext from client to server when generating HMAC.,2019-10-09,,45,https://github.com/01org/tpm2.0-tools/commit/c5d72beaab1cbbbe68271f4bc4b6670d69985157,c5d72beaab1cbbbe68271f4bc4b6670d69985157,"kdfa: use openssl for hmac not tpm

While not reachable in the current code base tools, a potential
security bug lurked in tpm_kdfa().

If using that routine for an hmac authorization, the hmac was
calculated using the tpm. A user of an object wishing to
authenticate via hmac, would expect that the password is never
sent to the tpm. However, since the hmac calculation relies on
password, and is performed by the tpm, the password ends up
being sent in plain text to the tpm.

The fix is to use openssl to generate the hmac on the host.

Fixes: CVE-2017-7524

Signed-off-by: William Roberts <william.c.roberts@intel.com>",9,lib/tpm_kdfa.c,"{""sha"": ""c40c24bd39c2a4407afa23c19b13e5ff1f796df3"", ""filename"": ""Makefile.am"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/tpm2-software/tpm2-tools/blob/c5d72beaab1cbbbe68271f4bc4b6670d69985157/Makefile.am"", ""raw_url"": ""https://github.com/tpm2-software/tpm2-tools/raw/c5d72beaab1cbbbe68271f4bc4b6670d69985157/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/tpm2-software/tpm2-tools/contents/Makefile.am?ref=c5d72beaab1cbbbe68271f4bc4b6670d69985157"", ""patch"": ""@@ -35,10 +35,10 @@ ACLOCAL_AMFLAGS = -I m4\n INCLUDE_DIRS = -I$(srcdir)/src -I$(srcdir)/lib\n LIB_COMMON := lib/libcommon.a\n \n-AM_CFLAGS    := $(INCLUDE_DIRS) $(TPM20_TSS_CFLAGS) $(EXTRA_CFLAGS) $(TCTI_TABRMD_CFLAGS)\n+AM_CFLAGS    := $(INCLUDE_DIRS) $(TPM20_TSS_CFLAGS) $(EXTRA_CFLAGS) $(TCTI_TABRMD_CFLAGS) $(CRYPTO_CFLAGS)\n AM_LDFLAGS   := $(EXTRA_LDFLAGS)\n \n-LDADD = $(LIB_COMMON) $(TPM20_TSS_LIBS) $(TCTI_SOCK_LIBS) $(TCTI_DEV_LIBS) $(TCTI_TABRMD_LIBS)\n+LDADD = $(LIB_COMMON) $(TPM20_TSS_LIBS) $(TCTI_SOCK_LIBS) $(TCTI_DEV_LIBS) $(TCTI_TABRMD_LIBS) $(CRYPTO_LIBS)\n \n sbin_PROGRAMS = \\\n     tools/tpm2_create \\""}<_**next**_>{""sha"": ""8ef3b173b30f5d6af3b7cd7737b75705b5879798"", ""filename"": ""configure.ac"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/tpm2-software/tpm2-tools/blob/c5d72beaab1cbbbe68271f4bc4b6670d69985157/configure.ac"", ""raw_url"": ""https://github.com/tpm2-software/tpm2-tools/raw/c5d72beaab1cbbbe68271f4bc4b6670d69985157/configure.ac"", ""contents_url"": ""https://api.github.com/repos/tpm2-software/tpm2-tools/contents/configure.ac?ref=c5d72beaab1cbbbe68271f4bc4b6670d69985157"", ""patch"": ""@@ -69,7 +69,8 @@ AS_IF(\n     [AC_MSG_ERROR(\n         [no TCTIs: at least one TCTI library must be enabled],\n         [1])])\n-PKG_CHECK_MODULES([CURL],[libcurl libcrypto])\n+PKG_CHECK_MODULES([CRYPTO],[libcrypto])\n+PKG_CHECK_MODULES([CURL],[libcurl])\n AC_ARG_ENABLE([unit],\n             [AS_HELP_STRING([--enable-unit],\n                             [build cmocka unit tests (default is no)])],""}<_**next**_>{""sha"": ""8198c9bbf00ab217e7175c02d9dfeded8f486e8f"", ""filename"": ""lib/tpm_kdfa.c"", ""status"": ""modified"", ""additions"": 66, ""deletions"": 10, ""changes"": 76, ""blob_url"": ""https://github.com/tpm2-software/tpm2-tools/blob/c5d72beaab1cbbbe68271f4bc4b6670d69985157/lib/tpm_kdfa.c"", ""raw_url"": ""https://github.com/tpm2-software/tpm2-tools/raw/c5d72beaab1cbbbe68271f4bc4b6670d69985157/lib/tpm_kdfa.c"", ""contents_url"": ""https://api.github.com/repos/tpm2-software/tpm2-tools/contents/lib/tpm_kdfa.c?ref=c5d72beaab1cbbbe68271f4bc4b6670d69985157"", ""patch"": ""@@ -27,20 +27,40 @@\n \n #include <sapi/tpm20.h>\n \n+ #include <openssl/err.h>\n+#include <openssl/hmac.h>\n+\n #include \""string-bytes.h\""\n #include \""tpm_hmac.h\""\n+#include \""log.h\""\n+\n+static const EVP_MD *tpm_algorithm_to_openssl_digest(TPMI_ALG_HASH algorithm) {\n+\n+    switch(algorithm) {\n+    case TPM_ALG_SHA1:\n+        return EVP_sha1();\n+    case ALG_SHA256_VALUE:\n+        return EVP_sha256();\n+    case TPM_ALG_SHA384:\n+        return EVP_sha384();\n+    case TPM_ALG_SHA512:\n+        return EVP_sha512();\n+    default:\n+        return NULL;\n+    }\n+    /* no return, not possible */\n+}\n \n-TPM_RC tpm_kdfa(TSS2_SYS_CONTEXT *sapi_context, TPMI_ALG_HASH hashAlg,\n+TPM_RC tpm_kdfa(TPMI_ALG_HASH hashAlg,\n         TPM2B *key, char *label, TPM2B *contextU, TPM2B *contextV, UINT16 bits,\n         TPM2B_MAX_BUFFER  *resultKey )\n {\n-    TPM2B_DIGEST tmpResult;\n     TPM2B_DIGEST tpm2bLabel, tpm2bBits, tpm2b_i_2;\n     UINT8 *tpm2bBitsPtr = &tpm2bBits.t.buffer[0];\n     UINT8 *tpm2b_i_2Ptr = &tpm2b_i_2.t.buffer[0];\n     TPM2B_DIGEST *bufferList[8];\n     UINT32 bitsSwizzled, i_Swizzled;\n-    TPM_RC rval;\n+    TPM_RC rval = TPM_RC_SUCCESS;\n     int i, j;\n     UINT16 bytes = bits / 8;\n \n@@ -64,8 +84,24 @@ TPM_RC tpm_kdfa(TSS2_SYS_CONTEXT *sapi_context, TPMI_ALG_HASH hashAlg,\n \n     i = 1;\n \n+    const EVP_MD *md = tpm_algorithm_to_openssl_digest(hashAlg);\n+    if (!md) {\n+        LOG_ERR(\""Algorithm not supported for hmac: %x\"", hashAlg);\n+        return TPM_RC_HASH;\n+    }\n+\n+    HMAC_CTX ctx;\n+    HMAC_CTX_init(&ctx);\n+    int rc = HMAC_Init_ex(&ctx, key->buffer, key->size, md, NULL);\n+    if (!rc) {\n+        LOG_ERR(\""HMAC Init failed: %s\"", ERR_error_string(rc, NULL));\n+        return TPM_RC_MEMORY;\n+    }\n+\n+    // TODO Why is this a loop? It appears to only execute once.\n     while( resultKey->t.size < bytes )\n     {\n+        TPM2B_DIGEST tmpResult;\n         // Inner loop\n \n         i_Swizzled = string_bytes_endian_convert_32( i );\n@@ -77,21 +113,41 @@ TPM_RC tpm_kdfa(TSS2_SYS_CONTEXT *sapi_context, TPMI_ALG_HASH hashAlg,\n         bufferList[j++] = (TPM2B_DIGEST *)contextU;\n         bufferList[j++] = (TPM2B_DIGEST *)contextV;\n         bufferList[j++] = (TPM2B_DIGEST *)&(tpm2bBits.b);\n-        bufferList[j++] = (TPM2B_DIGEST *)0;\n-        rval = tpm_hmac(sapi_context, hashAlg, key, (TPM2B **)&( bufferList[0] ), &tmpResult );\n-        if( rval != TPM_RC_SUCCESS )\n-        {\n-            return( rval );\n+        bufferList[j] = (TPM2B_DIGEST *)0;\n+\n+        int c;\n+        for(c=0; c < j; c++) {\n+            TPM2B_DIGEST *digest = bufferList[c];\n+            int rc =  HMAC_Update(&ctx, digest->b.buffer, digest->b.size);\n+            if (!rc) {\n+                LOG_ERR(\""HMAC Update failed: %s\"", ERR_error_string(rc, NULL));\n+                rval = TPM_RC_MEMORY;\n+                goto err;\n+            }\n+        }\n+\n+        unsigned size = sizeof(tmpResult.t.buffer);\n+        int rc = HMAC_Final(&ctx, tmpResult.t.buffer, &size);\n+        if (!rc) {\n+            LOG_ERR(\""HMAC Final failed: %s\"", ERR_error_string(rc, NULL));\n+            rval = TPM_RC_MEMORY;\n+            goto err;\n         }\n \n+        tmpResult.t.size = size;\n+\n         bool res = string_bytes_concat_buffer(resultKey, &(tmpResult.b));\n         if (!res) {\n-            return TSS2_SYS_RC_BAD_VALUE;\n+            rval = TSS2_SYS_RC_BAD_VALUE;\n+            goto err;\n         }\n     }\n \n     // Truncate the result to the desired size.\n     resultKey->t.size = bytes;\n \n-    return TPM_RC_SUCCESS;\n+err:\n+    HMAC_CTX_cleanup(&ctx);\n+\n+    return rval;\n }""}<_**next**_>{""sha"": ""e26b111ca34a1745123d6bed86363466fa7c17b7"", ""filename"": ""lib/tpm_kdfa.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/tpm2-software/tpm2-tools/blob/c5d72beaab1cbbbe68271f4bc4b6670d69985157/lib/tpm_kdfa.h"", ""raw_url"": ""https://github.com/tpm2-software/tpm2-tools/raw/c5d72beaab1cbbbe68271f4bc4b6670d69985157/lib/tpm_kdfa.h"", ""contents_url"": ""https://api.github.com/repos/tpm2-software/tpm2-tools/contents/lib/tpm_kdfa.h?ref=c5d72beaab1cbbbe68271f4bc4b6670d69985157"", ""patch"": ""@@ -42,7 +42,7 @@\n  * @param resultKey\n  * @return\n  */\n-TPM_RC tpm_kdfa(TSS2_SYS_CONTEXT *sapi_context, TPMI_ALG_HASH hashAlg,\n+TPM_RC tpm_kdfa(TPMI_ALG_HASH hashAlg,\n         TPM2B *key, char *label, TPM2B *contextU, TPM2B *contextV,\n         UINT16 bits, TPM2B_MAX_BUFFER *resultKey );\n ""}<_**next**_>{""sha"": ""f13e7efcc789f985b3bda00b07eaecc8fea3f830"", ""filename"": ""lib/tpm_session.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/tpm2-software/tpm2-tools/blob/c5d72beaab1cbbbe68271f4bc4b6670d69985157/lib/tpm_session.c"", ""raw_url"": ""https://github.com/tpm2-software/tpm2-tools/raw/c5d72beaab1cbbbe68271f4bc4b6670d69985157/lib/tpm_session.c"", ""contents_url"": ""https://api.github.com/repos/tpm2-software/tpm2-tools/contents/lib/tpm_session.c?ref=c5d72beaab1cbbbe68271f4bc4b6670d69985157"", ""patch"": ""@@ -198,7 +198,7 @@ static TPM_RC StartAuthSession(TSS2_SYS_CONTEXT *sapi_context, SESSION *session\n             }\n             else\n             {\n-                rval = tpm_kdfa(sapi_context, session->authHash, &(key.b), label, &( session->nonceNewer.b ),\n+                rval = tpm_kdfa(session->authHash, &(key.b), label, &( session->nonceNewer.b ),\n                         &( session->nonceOlder.b ), bytes * 8, (TPM2B_MAX_BUFFER *)&( session->sessionKey ) );\n             }\n ""}","TPM_RC tpm_kdfa(TSS2_SYS_CONTEXT *sapi_context, TPMI_ALG_HASH hashAlg,
TPM_RC tpm_kdfa(TPMI_ALG_HASH hashAlg,
         TPM2B *key, char *label, TPM2B *contextU, TPM2B *contextV, UINT16 bits,
         TPM2B_MAX_BUFFER  *resultKey )
 {
     TPM2B_DIGEST tpm2bLabel, tpm2bBits, tpm2b_i_2;
     UINT8 *tpm2bBitsPtr = &tpm2bBits.t.buffer[0];
     UINT8 *tpm2b_i_2Ptr = &tpm2b_i_2.t.buffer[0];
     TPM2B_DIGEST *bufferList[8];
     UINT32 bitsSwizzled, i_Swizzled;
    TPM_RC rval = TPM_RC_SUCCESS;
     int i, j;
     UINT16 bytes = bits / 8;
 
    resultKey->t .size = 0;

    tpm2b_i_2.t.size = 4;

    tpm2bBits.t.size = 4;
    bitsSwizzled = string_bytes_endian_convert_32( bits );
    *(UINT32 *)tpm2bBitsPtr = bitsSwizzled;

    for(i = 0; label[i] != 0 ;i++ );

    tpm2bLabel.t.size = i+1;
    for( i = 0; i < tpm2bLabel.t.size; i++ )
    {
        tpm2bLabel.t.buffer[i] = label[i];
    }

    resultKey->t.size = 0;
 
     i = 1;
 
    const EVP_MD *md = tpm_algorithm_to_openssl_digest(hashAlg);
    if (!md) {
        LOG_ERR(""Algorithm not supported for hmac: %x"", hashAlg);
        return TPM_RC_HASH;
    }

    HMAC_CTX ctx;
    HMAC_CTX_init(&ctx);
    int rc = HMAC_Init_ex(&ctx, key->buffer, key->size, md, NULL);
    if (!rc) {
        LOG_ERR(""HMAC Init failed: %s"", ERR_error_string(rc, NULL));
        return TPM_RC_MEMORY;
    }

    // TODO Why is this a loop? It appears to only execute once.
     while( resultKey->t.size < bytes )
     {
        TPM2B_DIGEST tmpResult;
 
         i_Swizzled = string_bytes_endian_convert_32( i );
        *(UINT32 *)tpm2b_i_2Ptr = i_Swizzled;

        j = 0;
        bufferList[j++] = (TPM2B_DIGEST *)&(tpm2b_i_2.b);
        bufferList[j++] = (TPM2B_DIGEST *)&(tpm2bLabel.b);
         bufferList[j++] = (TPM2B_DIGEST *)contextU;
         bufferList[j++] = (TPM2B_DIGEST *)contextV;
         bufferList[j++] = (TPM2B_DIGEST *)&(tpm2bBits.b);
        bufferList[j] = (TPM2B_DIGEST *)0;

        int c;
        for(c=0; c < j; c++) {
            TPM2B_DIGEST *digest = bufferList[c];
            int rc =  HMAC_Update(&ctx, digest->b.buffer, digest->b.size);
            if (!rc) {
                LOG_ERR(""HMAC Update failed: %s"", ERR_error_string(rc, NULL));
                rval = TPM_RC_MEMORY;
                goto err;
            }
        }

        unsigned size = sizeof(tmpResult.t.buffer);
        int rc = HMAC_Final(&ctx, tmpResult.t.buffer, &size);
        if (!rc) {
            LOG_ERR(""HMAC Final failed: %s"", ERR_error_string(rc, NULL));
            rval = TPM_RC_MEMORY;
            goto err;
         }
 
        tmpResult.t.size = size;

         bool res = string_bytes_concat_buffer(resultKey, &(tmpResult.b));
         if (!res) {
            rval = TSS2_SYS_RC_BAD_VALUE;
            goto err;
         }
     }
 
     resultKey->t.size = bytes;
 
err:
    HMAC_CTX_cleanup(&ctx);

    return rval;
 }
","TPM_RC tpm_kdfa(TSS2_SYS_CONTEXT *sapi_context, TPMI_ALG_HASH hashAlg,
         TPM2B *key, char *label, TPM2B *contextU, TPM2B *contextV, UINT16 bits,
         TPM2B_MAX_BUFFER  *resultKey )
 {
    TPM2B_DIGEST tmpResult;
     TPM2B_DIGEST tpm2bLabel, tpm2bBits, tpm2b_i_2;
     UINT8 *tpm2bBitsPtr = &tpm2bBits.t.buffer[0];
     UINT8 *tpm2b_i_2Ptr = &tpm2b_i_2.t.buffer[0];
     TPM2B_DIGEST *bufferList[8];
     UINT32 bitsSwizzled, i_Swizzled;
    TPM_RC rval;
     int i, j;
     UINT16 bytes = bits / 8;
 
    resultKey->t .size = 0;

    tpm2b_i_2.t.size = 4;

    tpm2bBits.t.size = 4;
    bitsSwizzled = string_bytes_endian_convert_32( bits );
    *(UINT32 *)tpm2bBitsPtr = bitsSwizzled;

    for(i = 0; label[i] != 0 ;i++ );

    tpm2bLabel.t.size = i+1;
    for( i = 0; i < tpm2bLabel.t.size; i++ )
    {
        tpm2bLabel.t.buffer[i] = label[i];
    }

    resultKey->t.size = 0;
 
     i = 1;
 
     while( resultKey->t.size < bytes )
     {
 
         i_Swizzled = string_bytes_endian_convert_32( i );
        *(UINT32 *)tpm2b_i_2Ptr = i_Swizzled;

        j = 0;
        bufferList[j++] = (TPM2B_DIGEST *)&(tpm2b_i_2.b);
        bufferList[j++] = (TPM2B_DIGEST *)&(tpm2bLabel.b);
         bufferList[j++] = (TPM2B_DIGEST *)contextU;
         bufferList[j++] = (TPM2B_DIGEST *)contextV;
         bufferList[j++] = (TPM2B_DIGEST *)&(tpm2bBits.b);
        bufferList[j++] = (TPM2B_DIGEST *)0;
        rval = tpm_hmac(sapi_context, hashAlg, key, (TPM2B **)&( bufferList[0] ), &tmpResult );
        if( rval != TPM_RC_SUCCESS )
        {
            return( rval );
         }
 
         bool res = string_bytes_concat_buffer(resultKey, &(tmpResult.b));
         if (!res) {
            return TSS2_SYS_RC_BAD_VALUE;
         }
     }
 
     resultKey->t.size = bytes;
 
    return TPM_RC_SUCCESS;
 }
",C,"TPM_RC tpm_kdfa(TPMI_ALG_HASH hashAlg,
    TPM_RC rval = TPM_RC_SUCCESS;
    const EVP_MD *md = tpm_algorithm_to_openssl_digest(hashAlg);
    if (!md) {
        LOG_ERR(""Algorithm not supported for hmac: %x"", hashAlg);
        return TPM_RC_HASH;
    }

    HMAC_CTX ctx;
    HMAC_CTX_init(&ctx);
    int rc = HMAC_Init_ex(&ctx, key->buffer, key->size, md, NULL);
    if (!rc) {
        LOG_ERR(""HMAC Init failed: %s"", ERR_error_string(rc, NULL));
        return TPM_RC_MEMORY;
    }

    // TODO Why is this a loop? It appears to only execute once.
        TPM2B_DIGEST tmpResult;
        bufferList[j] = (TPM2B_DIGEST *)0;

        int c;
        for(c=0; c < j; c++) {
            TPM2B_DIGEST *digest = bufferList[c];
            int rc =  HMAC_Update(&ctx, digest->b.buffer, digest->b.size);
            if (!rc) {
                LOG_ERR(""HMAC Update failed: %s"", ERR_error_string(rc, NULL));
                rval = TPM_RC_MEMORY;
                goto err;
            }
        }

        unsigned size = sizeof(tmpResult.t.buffer);
        int rc = HMAC_Final(&ctx, tmpResult.t.buffer, &size);
        if (!rc) {
            LOG_ERR(""HMAC Final failed: %s"", ERR_error_string(rc, NULL));
            rval = TPM_RC_MEMORY;
            goto err;
        tmpResult.t.size = size;

            rval = TSS2_SYS_RC_BAD_VALUE;
            goto err;
err:
    HMAC_CTX_cleanup(&ctx);

    return rval;
","    TPM2B_DIGEST tmpResult;
    TPM_RC rval;
        bufferList[j++] = (TPM2B_DIGEST *)0;
        rval = tpm_hmac(sapi_context, hashAlg, key, (TPM2B **)&( bufferList[0] ), &tmpResult );
        if( rval != TPM_RC_SUCCESS )
        {
            return( rval );
            return TSS2_SYS_RC_BAD_VALUE;
    return TPM_RC_SUCCESS;
",,"@@ -27,20 +27,40 @@
 
 #include <sapi/tpm20.h>
 
+ #include <openssl/err.h>
+#include <openssl/hmac.h>
+
 #include ""string-bytes.h""
 #include ""tpm_hmac.h""
+#include ""log.h""
+
+static const EVP_MD *tpm_algorithm_to_openssl_digest(TPMI_ALG_HASH algorithm) {
+
+    switch(algorithm) {
+    case TPM_ALG_SHA1:
+        return EVP_sha1();
+    case ALG_SHA256_VALUE:
+        return EVP_sha256();
+    case TPM_ALG_SHA384:
+        return EVP_sha384();
+    case TPM_ALG_SHA512:
+        return EVP_sha512();
+    default:
+        return NULL;
+    }
+    /* no return, not possible */
+}
 
-TPM_RC tpm_kdfa(TSS2_SYS_CONTEXT *sapi_context, TPMI_ALG_HASH hashAlg,
+TPM_RC tpm_kdfa(TPMI_ALG_HASH hashAlg,
         TPM2B *key, char *label, TPM2B *contextU, TPM2B *contextV, UINT16 bits,
         TPM2B_MAX_BUFFER  *resultKey )
 {
-    TPM2B_DIGEST tmpResult;
     TPM2B_DIGEST tpm2bLabel, tpm2bBits, tpm2b_i_2;
     UINT8 *tpm2bBitsPtr = &tpm2bBits.t.buffer[0];
     UINT8 *tpm2b_i_2Ptr = &tpm2b_i_2.t.buffer[0];
     TPM2B_DIGEST *bufferList[8];
     UINT32 bitsSwizzled, i_Swizzled;
-    TPM_RC rval;
+    TPM_RC rval = TPM_RC_SUCCESS;
     int i, j;
     UINT16 bytes = bits / 8;
 
@@ -64,8 +84,24 @@ TPM_RC tpm_kdfa(TSS2_SYS_CONTEXT *sapi_context, TPMI_ALG_HASH hashAlg,
 
     i = 1;
 
+    const EVP_MD *md = tpm_algorithm_to_openssl_digest(hashAlg);
+    if (!md) {
+        LOG_ERR(""Algorithm not supported for hmac: %x"", hashAlg);
+        return TPM_RC_HASH;
+    }
+
+    HMAC_CTX ctx;
+    HMAC_CTX_init(&ctx);
+    int rc = HMAC_Init_ex(&ctx, key->buffer, key->size, md, NULL);
+    if (!rc) {
+        LOG_ERR(""HMAC Init failed: %s"", ERR_error_string(rc, NULL));
+        return TPM_RC_MEMORY;
+    }
+
+    // TODO Why is this a loop? It appears to only execute once.
     while( resultKey->t.size < bytes )
     {
+        TPM2B_DIGEST tmpResult;
         // Inner loop
 
         i_Swizzled = string_bytes_endian_convert_32( i );
@@ -77,21 +113,41 @@ TPM_RC tpm_kdfa(TSS2_SYS_CONTEXT *sapi_context, TPMI_ALG_HASH hashAlg,
         bufferList[j++] = (TPM2B_DIGEST *)contextU;
         bufferList[j++] = (TPM2B_DIGEST *)contextV;
         bufferList[j++] = (TPM2B_DIGEST *)&(tpm2bBits.b);
-        bufferList[j++] = (TPM2B_DIGEST *)0;
-        rval = tpm_hmac(sapi_context, hashAlg, key, (TPM2B **)&( bufferList[0] ), &tmpResult );
-        if( rval != TPM_RC_SUCCESS )
-        {
-            return( rval );
+        bufferList[j] = (TPM2B_DIGEST *)0;
+
+        int c;
+        for(c=0; c < j; c++) {
+            TPM2B_DIGEST *digest = bufferList[c];
+            int rc =  HMAC_Update(&ctx, digest->b.buffer, digest->b.size);
+            if (!rc) {
+                LOG_ERR(""HMAC Update failed: %s"", ERR_error_string(rc, NULL));
+                rval = TPM_RC_MEMORY;
+                goto err;
+            }
+        }
+
+        unsigned size = sizeof(tmpResult.t.buffer);
+        int rc = HMAC_Final(&ctx, tmpResult.t.buffer, &size);
+        if (!rc) {
+            LOG_ERR(""HMAC Final failed: %s"", ERR_error_string(rc, NULL));
+            rval = TPM_RC_MEMORY;
+            goto err;
         }
 
+        tmpResult.t.size = size;
+
         bool res = string_bytes_concat_buffer(resultKey, &(tmpResult.b));
         if (!res) {
-            return TSS2_SYS_RC_BAD_VALUE;
+            rval = TSS2_SYS_RC_BAD_VALUE;
+            goto err;
         }
     }
 
     // Truncate the result to the desired size.
     resultKey->t.size = bytes;
 
-    return TPM_RC_SUCCESS;
+err:
+    HMAC_CTX_cleanup(&ctx);
+
+    return rval;
 }",tpm2.0-tools,c5d72beaab1cbbbe68271f4bc4b6670d69985157,ada4c20d23d99b4b489c6c793e4132c1d5234b66,1,"TPM_RC tpm_kdfa(TSS2_SYS_CONTEXT *sapi_context, TPMI_ALG_HASH hashAlg,
//fix_flaw_line_below:
//TPM_RC tpm_kdfa(TPMI_ALG_HASH hashAlg,
         TPM2B *key, char *label, TPM2B *contextU, TPM2B *contextV, UINT16 bits,
         TPM2B_MAX_BUFFER  *resultKey )
 {
//flaw_line_below:
    TPM2B_DIGEST tmpResult;
     TPM2B_DIGEST tpm2bLabel, tpm2bBits, tpm2b_i_2;
     UINT8 *tpm2bBitsPtr = &tpm2bBits.t.buffer[0];
     UINT8 *tpm2b_i_2Ptr = &tpm2b_i_2.t.buffer[0];
     TPM2B_DIGEST *bufferList[8];
     UINT32 bitsSwizzled, i_Swizzled;
//flaw_line_below:
    TPM_RC rval;
//fix_flaw_line_below:
//    TPM_RC rval = TPM_RC_SUCCESS;
     int i, j;
     UINT16 bytes = bits / 8;
 
    resultKey->t .size = 0;

    tpm2b_i_2.t.size = 4;

    tpm2bBits.t.size = 4;
    bitsSwizzled = string_bytes_endian_convert_32( bits );
    *(UINT32 *)tpm2bBitsPtr = bitsSwizzled;

    for(i = 0; label[i] != 0 ;i++ );

    tpm2bLabel.t.size = i+1;
    for( i = 0; i < tpm2bLabel.t.size; i++ )
    {
        tpm2bLabel.t.buffer[i] = label[i];
    }

    resultKey->t.size = 0;
 
     i = 1;
 
//fix_flaw_line_below:
//    const EVP_MD *md = tpm_algorithm_to_openssl_digest(hashAlg);
//fix_flaw_line_below:
//    if (!md) {
//fix_flaw_line_below:
//        LOG_ERR(""Algorithm not supported for hmac: %x"", hashAlg);
//fix_flaw_line_below:
//        return TPM_RC_HASH;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    HMAC_CTX ctx;
//fix_flaw_line_below:
//    HMAC_CTX_init(&ctx);
//fix_flaw_line_below:
//    int rc = HMAC_Init_ex(&ctx, key->buffer, key->size, md, NULL);
//fix_flaw_line_below:
//    if (!rc) {
//fix_flaw_line_below:
//        LOG_ERR(""HMAC Init failed: %s"", ERR_error_string(rc, NULL));
//fix_flaw_line_below:
//        return TPM_RC_MEMORY;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    // TODO Why is this a loop? It appears to only execute once.
     while( resultKey->t.size < bytes )
     {
//fix_flaw_line_below:
//        TPM2B_DIGEST tmpResult;
         // Inner loop
 
         i_Swizzled = string_bytes_endian_convert_32( i );
        *(UINT32 *)tpm2b_i_2Ptr = i_Swizzled;

        j = 0;
        bufferList[j++] = (TPM2B_DIGEST *)&(tpm2b_i_2.b);
        bufferList[j++] = (TPM2B_DIGEST *)&(tpm2bLabel.b);
         bufferList[j++] = (TPM2B_DIGEST *)contextU;
         bufferList[j++] = (TPM2B_DIGEST *)contextV;
         bufferList[j++] = (TPM2B_DIGEST *)&(tpm2bBits.b);
//flaw_line_below:
        bufferList[j++] = (TPM2B_DIGEST *)0;
//flaw_line_below:
        rval = tpm_hmac(sapi_context, hashAlg, key, (TPM2B **)&( bufferList[0] ), &tmpResult );
//flaw_line_below:
        if( rval != TPM_RC_SUCCESS )
//flaw_line_below:
        {
//flaw_line_below:
            return( rval );
//fix_flaw_line_below:
//        bufferList[j] = (TPM2B_DIGEST *)0;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        int c;
//fix_flaw_line_below:
//        for(c=0; c < j; c++) {
//fix_flaw_line_below:
//            TPM2B_DIGEST *digest = bufferList[c];
//fix_flaw_line_below:
//            int rc =  HMAC_Update(&ctx, digest->b.buffer, digest->b.size);
//fix_flaw_line_below:
//            if (!rc) {
//fix_flaw_line_below:
//                LOG_ERR(""HMAC Update failed: %s"", ERR_error_string(rc, NULL));
//fix_flaw_line_below:
//                rval = TPM_RC_MEMORY;
//fix_flaw_line_below:
//                goto err;
//fix_flaw_line_below:
//            }
//fix_flaw_line_below:
//        }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        unsigned size = sizeof(tmpResult.t.buffer);
//fix_flaw_line_below:
//        int rc = HMAC_Final(&ctx, tmpResult.t.buffer, &size);
//fix_flaw_line_below:
//        if (!rc) {
//fix_flaw_line_below:
//            LOG_ERR(""HMAC Final failed: %s"", ERR_error_string(rc, NULL));
//fix_flaw_line_below:
//            rval = TPM_RC_MEMORY;
//fix_flaw_line_below:
//            goto err;
         }
 
//fix_flaw_line_below:
//        tmpResult.t.size = size;
//fix_flaw_line_below:
//
         bool res = string_bytes_concat_buffer(resultKey, &(tmpResult.b));
         if (!res) {
//flaw_line_below:
            return TSS2_SYS_RC_BAD_VALUE;
//fix_flaw_line_below:
//            rval = TSS2_SYS_RC_BAD_VALUE;
//fix_flaw_line_below:
//            goto err;
         }
     }
 
     // Truncate the result to the desired size.
     resultKey->t.size = bytes;
 
//flaw_line_below:
    return TPM_RC_SUCCESS;
//fix_flaw_line_below:
//err:
//fix_flaw_line_below:
//    HMAC_CTX_cleanup(&ctx);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    return rval;
 }
"
3702,181438,,Remote,Not required,,CVE-2017-7524,https://www.cvedetails.com/cve/CVE-2017-7524/,CWE-522,Low,Partial,,,2017-06-27,5.0,tpm2-tools versions before 1.1.1 are vulnerable to a password leak due to transmitting password in plaintext from client to server when generating HMAC.,2019-10-09,,1,https://github.com/01org/tpm2.0-tools/commit/c5d72beaab1cbbbe68271f4bc4b6670d69985157,c5d72beaab1cbbbe68271f4bc4b6670d69985157,"kdfa: use openssl for hmac not tpm

While not reachable in the current code base tools, a potential
security bug lurked in tpm_kdfa().

If using that routine for an hmac authorization, the hmac was
calculated using the tpm. A user of an object wishing to
authenticate via hmac, would expect that the password is never
sent to the tpm. However, since the hmac calculation relies on
password, and is performed by the tpm, the password ends up
being sent in plain text to the tpm.

The fix is to use openssl to generate the hmac on the host.

Fixes: CVE-2017-7524

Signed-off-by: William Roberts <william.c.roberts@intel.com>",1,lib/tpm_session.c,"{""sha"": ""c40c24bd39c2a4407afa23c19b13e5ff1f796df3"", ""filename"": ""Makefile.am"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/tpm2-software/tpm2-tools/blob/c5d72beaab1cbbbe68271f4bc4b6670d69985157/Makefile.am"", ""raw_url"": ""https://github.com/tpm2-software/tpm2-tools/raw/c5d72beaab1cbbbe68271f4bc4b6670d69985157/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/tpm2-software/tpm2-tools/contents/Makefile.am?ref=c5d72beaab1cbbbe68271f4bc4b6670d69985157"", ""patch"": ""@@ -35,10 +35,10 @@ ACLOCAL_AMFLAGS = -I m4\n INCLUDE_DIRS = -I$(srcdir)/src -I$(srcdir)/lib\n LIB_COMMON := lib/libcommon.a\n \n-AM_CFLAGS    := $(INCLUDE_DIRS) $(TPM20_TSS_CFLAGS) $(EXTRA_CFLAGS) $(TCTI_TABRMD_CFLAGS)\n+AM_CFLAGS    := $(INCLUDE_DIRS) $(TPM20_TSS_CFLAGS) $(EXTRA_CFLAGS) $(TCTI_TABRMD_CFLAGS) $(CRYPTO_CFLAGS)\n AM_LDFLAGS   := $(EXTRA_LDFLAGS)\n \n-LDADD = $(LIB_COMMON) $(TPM20_TSS_LIBS) $(TCTI_SOCK_LIBS) $(TCTI_DEV_LIBS) $(TCTI_TABRMD_LIBS)\n+LDADD = $(LIB_COMMON) $(TPM20_TSS_LIBS) $(TCTI_SOCK_LIBS) $(TCTI_DEV_LIBS) $(TCTI_TABRMD_LIBS) $(CRYPTO_LIBS)\n \n sbin_PROGRAMS = \\\n     tools/tpm2_create \\""}<_**next**_>{""sha"": ""8ef3b173b30f5d6af3b7cd7737b75705b5879798"", ""filename"": ""configure.ac"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/tpm2-software/tpm2-tools/blob/c5d72beaab1cbbbe68271f4bc4b6670d69985157/configure.ac"", ""raw_url"": ""https://github.com/tpm2-software/tpm2-tools/raw/c5d72beaab1cbbbe68271f4bc4b6670d69985157/configure.ac"", ""contents_url"": ""https://api.github.com/repos/tpm2-software/tpm2-tools/contents/configure.ac?ref=c5d72beaab1cbbbe68271f4bc4b6670d69985157"", ""patch"": ""@@ -69,7 +69,8 @@ AS_IF(\n     [AC_MSG_ERROR(\n         [no TCTIs: at least one TCTI library must be enabled],\n         [1])])\n-PKG_CHECK_MODULES([CURL],[libcurl libcrypto])\n+PKG_CHECK_MODULES([CRYPTO],[libcrypto])\n+PKG_CHECK_MODULES([CURL],[libcurl])\n AC_ARG_ENABLE([unit],\n             [AS_HELP_STRING([--enable-unit],\n                             [build cmocka unit tests (default is no)])],""}<_**next**_>{""sha"": ""8198c9bbf00ab217e7175c02d9dfeded8f486e8f"", ""filename"": ""lib/tpm_kdfa.c"", ""status"": ""modified"", ""additions"": 66, ""deletions"": 10, ""changes"": 76, ""blob_url"": ""https://github.com/tpm2-software/tpm2-tools/blob/c5d72beaab1cbbbe68271f4bc4b6670d69985157/lib/tpm_kdfa.c"", ""raw_url"": ""https://github.com/tpm2-software/tpm2-tools/raw/c5d72beaab1cbbbe68271f4bc4b6670d69985157/lib/tpm_kdfa.c"", ""contents_url"": ""https://api.github.com/repos/tpm2-software/tpm2-tools/contents/lib/tpm_kdfa.c?ref=c5d72beaab1cbbbe68271f4bc4b6670d69985157"", ""patch"": ""@@ -27,20 +27,40 @@\n \n #include <sapi/tpm20.h>\n \n+ #include <openssl/err.h>\n+#include <openssl/hmac.h>\n+\n #include \""string-bytes.h\""\n #include \""tpm_hmac.h\""\n+#include \""log.h\""\n+\n+static const EVP_MD *tpm_algorithm_to_openssl_digest(TPMI_ALG_HASH algorithm) {\n+\n+    switch(algorithm) {\n+    case TPM_ALG_SHA1:\n+        return EVP_sha1();\n+    case ALG_SHA256_VALUE:\n+        return EVP_sha256();\n+    case TPM_ALG_SHA384:\n+        return EVP_sha384();\n+    case TPM_ALG_SHA512:\n+        return EVP_sha512();\n+    default:\n+        return NULL;\n+    }\n+    /* no return, not possible */\n+}\n \n-TPM_RC tpm_kdfa(TSS2_SYS_CONTEXT *sapi_context, TPMI_ALG_HASH hashAlg,\n+TPM_RC tpm_kdfa(TPMI_ALG_HASH hashAlg,\n         TPM2B *key, char *label, TPM2B *contextU, TPM2B *contextV, UINT16 bits,\n         TPM2B_MAX_BUFFER  *resultKey )\n {\n-    TPM2B_DIGEST tmpResult;\n     TPM2B_DIGEST tpm2bLabel, tpm2bBits, tpm2b_i_2;\n     UINT8 *tpm2bBitsPtr = &tpm2bBits.t.buffer[0];\n     UINT8 *tpm2b_i_2Ptr = &tpm2b_i_2.t.buffer[0];\n     TPM2B_DIGEST *bufferList[8];\n     UINT32 bitsSwizzled, i_Swizzled;\n-    TPM_RC rval;\n+    TPM_RC rval = TPM_RC_SUCCESS;\n     int i, j;\n     UINT16 bytes = bits / 8;\n \n@@ -64,8 +84,24 @@ TPM_RC tpm_kdfa(TSS2_SYS_CONTEXT *sapi_context, TPMI_ALG_HASH hashAlg,\n \n     i = 1;\n \n+    const EVP_MD *md = tpm_algorithm_to_openssl_digest(hashAlg);\n+    if (!md) {\n+        LOG_ERR(\""Algorithm not supported for hmac: %x\"", hashAlg);\n+        return TPM_RC_HASH;\n+    }\n+\n+    HMAC_CTX ctx;\n+    HMAC_CTX_init(&ctx);\n+    int rc = HMAC_Init_ex(&ctx, key->buffer, key->size, md, NULL);\n+    if (!rc) {\n+        LOG_ERR(\""HMAC Init failed: %s\"", ERR_error_string(rc, NULL));\n+        return TPM_RC_MEMORY;\n+    }\n+\n+    // TODO Why is this a loop? It appears to only execute once.\n     while( resultKey->t.size < bytes )\n     {\n+        TPM2B_DIGEST tmpResult;\n         // Inner loop\n \n         i_Swizzled = string_bytes_endian_convert_32( i );\n@@ -77,21 +113,41 @@ TPM_RC tpm_kdfa(TSS2_SYS_CONTEXT *sapi_context, TPMI_ALG_HASH hashAlg,\n         bufferList[j++] = (TPM2B_DIGEST *)contextU;\n         bufferList[j++] = (TPM2B_DIGEST *)contextV;\n         bufferList[j++] = (TPM2B_DIGEST *)&(tpm2bBits.b);\n-        bufferList[j++] = (TPM2B_DIGEST *)0;\n-        rval = tpm_hmac(sapi_context, hashAlg, key, (TPM2B **)&( bufferList[0] ), &tmpResult );\n-        if( rval != TPM_RC_SUCCESS )\n-        {\n-            return( rval );\n+        bufferList[j] = (TPM2B_DIGEST *)0;\n+\n+        int c;\n+        for(c=0; c < j; c++) {\n+            TPM2B_DIGEST *digest = bufferList[c];\n+            int rc =  HMAC_Update(&ctx, digest->b.buffer, digest->b.size);\n+            if (!rc) {\n+                LOG_ERR(\""HMAC Update failed: %s\"", ERR_error_string(rc, NULL));\n+                rval = TPM_RC_MEMORY;\n+                goto err;\n+            }\n+        }\n+\n+        unsigned size = sizeof(tmpResult.t.buffer);\n+        int rc = HMAC_Final(&ctx, tmpResult.t.buffer, &size);\n+        if (!rc) {\n+            LOG_ERR(\""HMAC Final failed: %s\"", ERR_error_string(rc, NULL));\n+            rval = TPM_RC_MEMORY;\n+            goto err;\n         }\n \n+        tmpResult.t.size = size;\n+\n         bool res = string_bytes_concat_buffer(resultKey, &(tmpResult.b));\n         if (!res) {\n-            return TSS2_SYS_RC_BAD_VALUE;\n+            rval = TSS2_SYS_RC_BAD_VALUE;\n+            goto err;\n         }\n     }\n \n     // Truncate the result to the desired size.\n     resultKey->t.size = bytes;\n \n-    return TPM_RC_SUCCESS;\n+err:\n+    HMAC_CTX_cleanup(&ctx);\n+\n+    return rval;\n }""}<_**next**_>{""sha"": ""e26b111ca34a1745123d6bed86363466fa7c17b7"", ""filename"": ""lib/tpm_kdfa.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/tpm2-software/tpm2-tools/blob/c5d72beaab1cbbbe68271f4bc4b6670d69985157/lib/tpm_kdfa.h"", ""raw_url"": ""https://github.com/tpm2-software/tpm2-tools/raw/c5d72beaab1cbbbe68271f4bc4b6670d69985157/lib/tpm_kdfa.h"", ""contents_url"": ""https://api.github.com/repos/tpm2-software/tpm2-tools/contents/lib/tpm_kdfa.h?ref=c5d72beaab1cbbbe68271f4bc4b6670d69985157"", ""patch"": ""@@ -42,7 +42,7 @@\n  * @param resultKey\n  * @return\n  */\n-TPM_RC tpm_kdfa(TSS2_SYS_CONTEXT *sapi_context, TPMI_ALG_HASH hashAlg,\n+TPM_RC tpm_kdfa(TPMI_ALG_HASH hashAlg,\n         TPM2B *key, char *label, TPM2B *contextU, TPM2B *contextV,\n         UINT16 bits, TPM2B_MAX_BUFFER *resultKey );\n ""}<_**next**_>{""sha"": ""f13e7efcc789f985b3bda00b07eaecc8fea3f830"", ""filename"": ""lib/tpm_session.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/tpm2-software/tpm2-tools/blob/c5d72beaab1cbbbe68271f4bc4b6670d69985157/lib/tpm_session.c"", ""raw_url"": ""https://github.com/tpm2-software/tpm2-tools/raw/c5d72beaab1cbbbe68271f4bc4b6670d69985157/lib/tpm_session.c"", ""contents_url"": ""https://api.github.com/repos/tpm2-software/tpm2-tools/contents/lib/tpm_session.c?ref=c5d72beaab1cbbbe68271f4bc4b6670d69985157"", ""patch"": ""@@ -198,7 +198,7 @@ static TPM_RC StartAuthSession(TSS2_SYS_CONTEXT *sapi_context, SESSION *session\n             }\n             else\n             {\n-                rval = tpm_kdfa(sapi_context, session->authHash, &(key.b), label, &( session->nonceNewer.b ),\n+                rval = tpm_kdfa(session->authHash, &(key.b), label, &( session->nonceNewer.b ),\n                         &( session->nonceOlder.b ), bytes * 8, (TPM2B_MAX_BUFFER *)&( session->sessionKey ) );\n             }\n ""}","static TPM_RC StartAuthSession(TSS2_SYS_CONTEXT *sapi_context, SESSION *session )
{
    TPM_RC rval;
    TPM2B_ENCRYPTED_SECRET key;
    char label[] = ""ATH"";
    UINT16 bytes;
    int i;

    key.t.size = 0;

    if( session->nonceOlder.t.size == 0 )
    {
        /* this is an internal routine to TSS and should be removed */
        session->nonceOlder.t.size = GetDigestSize( TPM_ALG_SHA1 );
        for( i = 0; i < session->nonceOlder.t.size; i++ )
            session->nonceOlder.t.buffer[i] = 0;
    }

    session->nonceNewer.t.size = session->nonceOlder.t.size;
    rval = Tss2_Sys_StartAuthSession( sapi_context, session->tpmKey, session->bind, 0,
            &( session->nonceOlder ), &( session->encryptedSalt ), session->sessionType,
            &( session->symmetric ), session->authHash, &( session->sessionHandle ),
            &( session->nonceNewer ), 0 );

    if( rval == TPM_RC_SUCCESS )
    {
        if( session->tpmKey == TPM_RH_NULL )
            session->salt.t.size = 0;
        if( session->bind == TPM_RH_NULL )
            session->authValueBind.t.size = 0;

        if( session->tpmKey == TPM_RH_NULL && session->bind == TPM_RH_NULL )
        {
            session->sessionKey.b.size = 0;
        }
        else
        {
            bool result = string_bytes_concat_buffer( (TPM2B_MAX_BUFFER *)&key, &( session->authValueBind.b ) );
            if (!result)
            {
               return TSS2_SYS_RC_BAD_VALUE;
            }

            result = string_bytes_concat_buffer( (TPM2B_MAX_BUFFER *)&key, &( session->salt.b ) );
            if (!result)
            {
                return TSS2_SYS_RC_BAD_VALUE;
            }

            bytes = GetDigestSize( session->authHash );

            if( key.t.size == 0 )
            {
                session->sessionKey.t.size = 0;
             }
             else
             {
                rval = tpm_kdfa(session->authHash, &(key.b), label, &( session->nonceNewer.b ),
                         &( session->nonceOlder.b ), bytes * 8, (TPM2B_MAX_BUFFER *)&( session->sessionKey ) );
             }
 
            if( rval != TPM_RC_SUCCESS )
            {
                return( TSS2_APP_RC_CREATE_SESSION_KEY_FAILED );
            }
        }

        session->nonceTpmDecrypt.b.size = 0;
        session->nonceTpmEncrypt.b.size = 0;
        session->nvNameChanged = 0;
    }

    return rval;
}
","static TPM_RC StartAuthSession(TSS2_SYS_CONTEXT *sapi_context, SESSION *session )
{
    TPM_RC rval;
    TPM2B_ENCRYPTED_SECRET key;
    char label[] = ""ATH"";
    UINT16 bytes;
    int i;

    key.t.size = 0;

    if( session->nonceOlder.t.size == 0 )
    {
        /* this is an internal routine to TSS and should be removed */
        session->nonceOlder.t.size = GetDigestSize( TPM_ALG_SHA1 );
        for( i = 0; i < session->nonceOlder.t.size; i++ )
            session->nonceOlder.t.buffer[i] = 0;
    }

    session->nonceNewer.t.size = session->nonceOlder.t.size;
    rval = Tss2_Sys_StartAuthSession( sapi_context, session->tpmKey, session->bind, 0,
            &( session->nonceOlder ), &( session->encryptedSalt ), session->sessionType,
            &( session->symmetric ), session->authHash, &( session->sessionHandle ),
            &( session->nonceNewer ), 0 );

    if( rval == TPM_RC_SUCCESS )
    {
        if( session->tpmKey == TPM_RH_NULL )
            session->salt.t.size = 0;
        if( session->bind == TPM_RH_NULL )
            session->authValueBind.t.size = 0;

        if( session->tpmKey == TPM_RH_NULL && session->bind == TPM_RH_NULL )
        {
            session->sessionKey.b.size = 0;
        }
        else
        {
            bool result = string_bytes_concat_buffer( (TPM2B_MAX_BUFFER *)&key, &( session->authValueBind.b ) );
            if (!result)
            {
               return TSS2_SYS_RC_BAD_VALUE;
            }

            result = string_bytes_concat_buffer( (TPM2B_MAX_BUFFER *)&key, &( session->salt.b ) );
            if (!result)
            {
                return TSS2_SYS_RC_BAD_VALUE;
            }

            bytes = GetDigestSize( session->authHash );

            if( key.t.size == 0 )
            {
                session->sessionKey.t.size = 0;
             }
             else
             {
                rval = tpm_kdfa(sapi_context, session->authHash, &(key.b), label, &( session->nonceNewer.b ),
                         &( session->nonceOlder.b ), bytes * 8, (TPM2B_MAX_BUFFER *)&( session->sessionKey ) );
             }
 
            if( rval != TPM_RC_SUCCESS )
            {
                return( TSS2_APP_RC_CREATE_SESSION_KEY_FAILED );
            }
        }

        session->nonceTpmDecrypt.b.size = 0;
        session->nonceTpmEncrypt.b.size = 0;
        session->nvNameChanged = 0;
    }

    return rval;
}
",C,"                rval = tpm_kdfa(session->authHash, &(key.b), label, &( session->nonceNewer.b ),
","                rval = tpm_kdfa(sapi_context, session->authHash, &(key.b), label, &( session->nonceNewer.b ),
",,"@@ -198,7 +198,7 @@ static TPM_RC StartAuthSession(TSS2_SYS_CONTEXT *sapi_context, SESSION *session
             }
             else
             {
-                rval = tpm_kdfa(sapi_context, session->authHash, &(key.b), label, &( session->nonceNewer.b ),
+                rval = tpm_kdfa(session->authHash, &(key.b), label, &( session->nonceNewer.b ),
                         &( session->nonceOlder.b ), bytes * 8, (TPM2B_MAX_BUFFER *)&( session->sessionKey ) );
             }
 ",tpm2.0-tools,c5d72beaab1cbbbe68271f4bc4b6670d69985157,ada4c20d23d99b4b489c6c793e4132c1d5234b66,1,"static TPM_RC StartAuthSession(TSS2_SYS_CONTEXT *sapi_context, SESSION *session )
{
    TPM_RC rval;
    TPM2B_ENCRYPTED_SECRET key;
    char label[] = ""ATH"";
    UINT16 bytes;
    int i;

    key.t.size = 0;

    if( session->nonceOlder.t.size == 0 )
    {
        /* this is an internal routine to TSS and should be removed */
        session->nonceOlder.t.size = GetDigestSize( TPM_ALG_SHA1 );
        for( i = 0; i < session->nonceOlder.t.size; i++ )
            session->nonceOlder.t.buffer[i] = 0;
    }

    session->nonceNewer.t.size = session->nonceOlder.t.size;
    rval = Tss2_Sys_StartAuthSession( sapi_context, session->tpmKey, session->bind, 0,
            &( session->nonceOlder ), &( session->encryptedSalt ), session->sessionType,
            &( session->symmetric ), session->authHash, &( session->sessionHandle ),
            &( session->nonceNewer ), 0 );

    if( rval == TPM_RC_SUCCESS )
    {
        if( session->tpmKey == TPM_RH_NULL )
            session->salt.t.size = 0;
        if( session->bind == TPM_RH_NULL )
            session->authValueBind.t.size = 0;

        if( session->tpmKey == TPM_RH_NULL && session->bind == TPM_RH_NULL )
        {
            session->sessionKey.b.size = 0;
        }
        else
        {
            // Generate the key used as input to the KDF.
            // Generate the key used as input to the KDF.
            bool result = string_bytes_concat_buffer( (TPM2B_MAX_BUFFER *)&key, &( session->authValueBind.b ) );
            if (!result)
            {
               return TSS2_SYS_RC_BAD_VALUE;
            }

            result = string_bytes_concat_buffer( (TPM2B_MAX_BUFFER *)&key, &( session->salt.b ) );
            if (!result)
            {
                return TSS2_SYS_RC_BAD_VALUE;
            }

            bytes = GetDigestSize( session->authHash );

            if( key.t.size == 0 )
            {
                session->sessionKey.t.size = 0;
             }
             else
             {
//flaw_line_below:
                rval = tpm_kdfa(sapi_context, session->authHash, &(key.b), label, &( session->nonceNewer.b ),
//fix_flaw_line_below:
//                rval = tpm_kdfa(session->authHash, &(key.b), label, &( session->nonceNewer.b ),
                         &( session->nonceOlder.b ), bytes * 8, (TPM2B_MAX_BUFFER *)&( session->sessionKey ) );
             }
 
            if( rval != TPM_RC_SUCCESS )
            {
                return( TSS2_APP_RC_CREATE_SESSION_KEY_FAILED );
            }
        }

        session->nonceTpmDecrypt.b.size = 0;
        session->nonceTpmEncrypt.b.size = 0;
        session->nvNameChanged = 0;
    }

    return rval;
}
"
