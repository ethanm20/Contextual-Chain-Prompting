,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix
2078,179814,,Remote,Not required,Complete,CVE-2015-2696,https://www.cvedetails.com/cve/CVE-2015-2696/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/krb5/iakerb.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted IAKERB packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,0,https://github.com/krb5/krb5/commit/e04f0283516e80d2f93366e0d479d13c9b5c8c2a,e04f0283516e80d2f93366e0d479d13c9b5c8c2a,"Fix IAKERB context aliasing bugs [CVE-2015-2696]

The IAKERB mechanism currently replaces its context handle with the
krb5 mechanism handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the IAKERB context structure after context
establishment and add new IAKERB entry points to refer to it with that
type.  Add initiate and established flags to the IAKERB context
structure for use in gss_inquire_context() prior to context
establishment.

CVE-2015-2696:

In MIT krb5 1.9 and later, applications which call
gss_inquire_context() on a partially-established IAKERB context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  Java server applications using the
native JGSS provider are vulnerable to this bug.  A carefully crafted
IAKERB packet might allow the gss_inquire_context() call to succeed
with attacker-determined results, but applications should not make
access control decisions based on gss_inquire_context() results prior
to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",8,src/lib/gssapi/krb5/gssapi_krb5.c,"{""sha"": ""97e090d099f3672e9fe67c969c1615dc0710922c"", ""filename"": ""src/lib/gssapi/krb5/gssapiP_krb5.h"", ""status"": ""modified"", ""additions"": 114, ""deletions"": 0, ""changes"": 114, ""blob_url"": ""https://github.com/krb5/krb5/blob/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/gssapiP_krb5.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/gssapiP_krb5.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/krb5/gssapiP_krb5.h?ref=e04f0283516e80d2f93366e0d479d13c9b5c8c2a"", ""patch"": ""@@ -621,6 +621,21 @@ OM_uint32 KRB5_CALLCONV krb5_gss_accept_sec_context_ext\n );\n #endif /* LEAN_CLIENT */\n \n+OM_uint32 KRB5_CALLCONV krb5_gss_inquire_sec_context_by_oid\n+(OM_uint32*,       /* minor_status */\n+ const gss_ctx_id_t,\n+ /* context_handle */\n+ const gss_OID,    /* desired_object */\n+ gss_buffer_set_t* /* data_set */\n+);\n+\n+OM_uint32 KRB5_CALLCONV krb5_gss_set_sec_context_option\n+(OM_uint32*,       /* minor_status */\n+ gss_ctx_id_t*,    /* context_handle */\n+ const gss_OID,    /* desired_object */\n+ const gss_buffer_t/* value */\n+);\n+\n OM_uint32 KRB5_CALLCONV krb5_gss_process_context_token\n (OM_uint32*,       /* minor_status */\n  gss_ctx_id_t,     /* context_handle */\n@@ -1302,6 +1317,105 @@ OM_uint32 KRB5_CALLCONV\n krb5_gss_import_cred(OM_uint32 *minor_status, gss_buffer_t token,\n                      gss_cred_id_t *cred_handle);\n \n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_process_context_token(OM_uint32 *minor_status,\n+                                 const gss_ctx_id_t context_handle,\n+                                 const gss_buffer_t token_buffer);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_context_time(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                        OM_uint32 *time_rec);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_inquire_context(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, gss_name_t *src_name,\n+                           gss_name_t *targ_name, OM_uint32 *lifetime_rec,\n+                           gss_OID *mech_type, OM_uint32 *ctx_flags,\n+                           int *locally_initiated, int *opened);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                   gss_qop_t qop_req, gss_buffer_t message_buffer,\n+                   gss_buffer_t message_token);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n+                       int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic_iov_length(OM_uint32 *minor_status,\n+                              gss_ctx_id_t context_handle, gss_qop_t qop_req,\n+                              gss_iov_buffer_desc *iov, int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_verify_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                      gss_buffer_t msg_buffer, gss_buffer_t token_buffer,\n+                      gss_qop_t *qop_state);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                          gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n+                          int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                int conf_req_flag, gss_qop_t qop_req,\n+                gss_buffer_t input_message_buffer, int *conf_state,\n+                gss_buffer_t output_message_buffer);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                    int conf_req_flag, gss_qop_t qop_req, int *conf_state,\n+                    gss_iov_buffer_desc *iov, int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_iov_length(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, int conf_req_flag,\n+                           gss_qop_t qop_req, int *conf_state,\n+                           gss_iov_buffer_desc *iov, int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_unwrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                  gss_buffer_t input_message_buffer,\n+                  gss_buffer_t output_message_buffer, int *conf_state,\n+                  gss_qop_t *qop_state);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_unwrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                      int *conf_state, gss_qop_t *qop_state,\n+                      gss_iov_buffer_desc *iov, int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_size_limit(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, int conf_req_flag,\n+                           gss_qop_t qop_req, OM_uint32 req_output_size,\n+                           OM_uint32 *max_input_size);\n+\n+#ifndef LEAN_CLIENT\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n+                              gss_ctx_id_t *context_handle,\n+                              gss_buffer_t interprocess_token);\n+#endif /* LEAN_CLIENT */\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_inquire_sec_context_by_oid(OM_uint32 *minor_status,\n+                                      const gss_ctx_id_t context_handle,\n+                                      const gss_OID desired_object,\n+                                      gss_buffer_set_t *data_set);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_set_sec_context_option(OM_uint32 *minor_status,\n+                                  gss_ctx_id_t *context_handle,\n+                                  const gss_OID desired_object,\n+                                  const gss_buffer_t value);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_pseudo_random(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                         int prf_key, const gss_buffer_t prf_in,\n+                         ssize_t desired_output_len, gss_buffer_t prf_out);\n+\n /* Magic string to identify exported krb5 GSS credentials.  Increment this if\n  * the format changes. */\n #define CRED_EXPORT_MAGIC \""K5C1\""""}<_**next**_>{""sha"": ""c4dfdd6fbd1338c6ad8bb2a395fff7cafa8de82b"", ""filename"": ""src/lib/gssapi/krb5/gssapi_krb5.c"", ""status"": ""modified"", ""additions"": 94, ""deletions"": 11, ""changes"": 105, ""blob_url"": ""https://github.com/krb5/krb5/blob/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/gssapi_krb5.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/gssapi_krb5.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/krb5/gssapi_krb5.c?ref=e04f0283516e80d2f93366e0d479d13c9b5c8c2a"", ""patch"": ""@@ -351,7 +351,7 @@ static struct {\n     }\n };\n \n-static OM_uint32 KRB5_CALLCONV\n+OM_uint32 KRB5_CALLCONV\n krb5_gss_inquire_sec_context_by_oid (OM_uint32 *minor_status,\n                                      const gss_ctx_id_t context_handle,\n                                      const gss_OID desired_object,\n@@ -465,7 +465,7 @@ static struct {\n };\n #endif\n \n-static OM_uint32 KRB5_CALLCONV\n+OM_uint32 KRB5_CALLCONV\n krb5_gss_set_sec_context_option (OM_uint32 *minor_status,\n                                  gss_ctx_id_t *context_handle,\n                                  const gss_OID desired_object,\n@@ -929,20 +929,103 @@ static struct gss_config krb5_mechanism = {\n     krb5_gss_get_mic_iov_length,\n };\n \n+/* Functions which use security contexts or acquire creds are IAKERB-specific;\n+ * other functions can borrow from the krb5 mech. */\n+static struct gss_config iakerb_mechanism = {\n+    { GSS_MECH_KRB5_OID_LENGTH, GSS_MECH_KRB5_OID },\n+    NULL,\n+    iakerb_gss_acquire_cred,\n+    krb5_gss_release_cred,\n+    iakerb_gss_init_sec_context,\n+#ifdef LEAN_CLIENT\n+    NULL,\n+#else\n+    iakerb_gss_accept_sec_context,\n+#endif\n+    iakerb_gss_process_context_token,\n+    iakerb_gss_delete_sec_context,\n+    iakerb_gss_context_time,\n+    iakerb_gss_get_mic,\n+    iakerb_gss_verify_mic,\n+#if defined(IOV_SHIM_EXERCISE_WRAP) || defined(IOV_SHIM_EXERCISE)\n+    NULL,\n+#else\n+    iakerb_gss_wrap,\n+#endif\n+#if defined(IOV_SHIM_EXERCISE_UNWRAP) || defined(IOV_SHIM_EXERCISE)\n+    NULL,\n+#else\n+    iakerb_gss_unwrap,\n+#endif\n+    krb5_gss_display_status,\n+    krb5_gss_indicate_mechs,\n+    krb5_gss_compare_name,\n+    krb5_gss_display_name,\n+    krb5_gss_import_name,\n+    krb5_gss_release_name,\n+    krb5_gss_inquire_cred,\n+    NULL,                /* add_cred */\n+#ifdef LEAN_CLIENT\n+    NULL,\n+    NULL,\n+#else\n+    iakerb_gss_export_sec_context,\n+    NULL,\n+#endif\n+    krb5_gss_inquire_cred_by_mech,\n+    krb5_gss_inquire_names_for_mech,\n+    iakerb_gss_inquire_context,\n+    krb5_gss_internal_release_oid,\n+    iakerb_gss_wrap_size_limit,\n+    krb5_gss_localname,\n+    krb5_gss_authorize_localname,\n+    krb5_gss_export_name,\n+    krb5_gss_duplicate_name,\n+    krb5_gss_store_cred,\n+    iakerb_gss_inquire_sec_context_by_oid,\n+    krb5_gss_inquire_cred_by_oid,\n+    iakerb_gss_set_sec_context_option,\n+    krb5_gssspi_set_cred_option,\n+    krb5_gssspi_mech_invoke,\n+    NULL,                /* wrap_aead */\n+    NULL,                /* unwrap_aead */\n+    iakerb_gss_wrap_iov,\n+    iakerb_gss_unwrap_iov,\n+    iakerb_gss_wrap_iov_length,\n+    NULL,               /* complete_auth_token */\n+    NULL,               /* acquire_cred_impersonate_name */\n+    NULL,               /* add_cred_impersonate_name */\n+    NULL,               /* display_name_ext */\n+    krb5_gss_inquire_name,\n+    krb5_gss_get_name_attribute,\n+    krb5_gss_set_name_attribute,\n+    krb5_gss_delete_name_attribute,\n+    krb5_gss_export_name_composite,\n+    krb5_gss_map_name_to_any,\n+    krb5_gss_release_any_name_mapping,\n+    iakerb_gss_pseudo_random,\n+    NULL,               /* set_neg_mechs */\n+    krb5_gss_inquire_saslname_for_mech,\n+    krb5_gss_inquire_mech_for_saslname,\n+    krb5_gss_inquire_attrs_for_mech,\n+    krb5_gss_acquire_cred_from,\n+    krb5_gss_store_cred_into,\n+    iakerb_gss_acquire_cred_with_password,\n+    krb5_gss_export_cred,\n+    krb5_gss_import_cred,\n+    NULL,               /* import_sec_context_by_mech */\n+    NULL,               /* import_name_by_mech */\n+    NULL,               /* import_cred_by_mech */\n+    iakerb_gss_get_mic_iov,\n+    iakerb_gss_verify_mic_iov,\n+    iakerb_gss_get_mic_iov_length,\n+};\n+\n #ifdef _GSS_STATIC_LINK\n #include \""mglueP.h\""\n static int gss_iakerbmechglue_init(void)\n {\n     struct gss_mech_config mech_iakerb;\n-    struct gss_config iakerb_mechanism = krb5_mechanism;\n-\n-    /* IAKERB mechanism mirrors krb5, but with different context SPIs */\n-    iakerb_mechanism.gss_accept_sec_context = iakerb_gss_accept_sec_context;\n-    iakerb_mechanism.gss_init_sec_context   = iakerb_gss_init_sec_context;\n-    iakerb_mechanism.gss_delete_sec_context = iakerb_gss_delete_sec_context;\n-    iakerb_mechanism.gss_acquire_cred       = iakerb_gss_acquire_cred;\n-    iakerb_mechanism.gssspi_acquire_cred_with_password\n-                                    = iakerb_gss_acquire_cred_with_password;\n \n     memset(&mech_iakerb, 0, sizeof(mech_iakerb));\n     mech_iakerb.mech = &iakerb_mechanism;""}<_**next**_>{""sha"": ""4662bd9fe382fdde657abaa6db06fa47ad69d8b7"", ""filename"": ""src/lib/gssapi/krb5/iakerb.c"", ""status"": ""modified"", ""additions"": 321, ""deletions"": 30, ""changes"": 351, ""blob_url"": ""https://github.com/krb5/krb5/blob/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/iakerb.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/iakerb.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/krb5/iakerb.c?ref=e04f0283516e80d2f93366e0d479d13c9b5c8c2a"", ""patch"": ""@@ -47,6 +47,8 @@ struct _iakerb_ctx_id_rec {\n     gss_ctx_id_t gssc;\n     krb5_data conv;                     /* conversation for checksumming */\n     unsigned int count;                 /* number of round trips */\n+    int initiate;\n+    int established;\n     krb5_get_init_creds_opt *gic_opts;\n };\n \n@@ -695,7 +697,7 @@ iakerb_get_initial_state(iakerb_ctx_id_t ctx,\n  * Allocate and initialise an IAKERB context\n  */\n static krb5_error_code\n-iakerb_alloc_context(iakerb_ctx_id_t *pctx)\n+iakerb_alloc_context(iakerb_ctx_id_t *pctx, int initiate)\n {\n     iakerb_ctx_id_t ctx;\n     krb5_error_code code;\n@@ -709,6 +711,8 @@ iakerb_alloc_context(iakerb_ctx_id_t *pctx)\n     ctx->magic = KG_IAKERB_CONTEXT;\n     ctx->state = IAKERB_AS_REQ;\n     ctx->count = 0;\n+    ctx->initiate = initiate;\n+    ctx->established = 0;\n \n     code = krb5_gss_init_context(&ctx->k5c);\n     if (code != 0)\n@@ -732,31 +736,18 @@ iakerb_gss_delete_sec_context(OM_uint32 *minor_status,\n                               gss_ctx_id_t *context_handle,\n                               gss_buffer_t output_token)\n {\n-    OM_uint32 major_status = GSS_S_COMPLETE;\n+    iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n \n     if (output_token != GSS_C_NO_BUFFER) {\n         output_token->length = 0;\n         output_token->value = NULL;\n     }\n \n     *minor_status = 0;\n+    *context_handle = GSS_C_NO_CONTEXT;\n+    iakerb_release_context(iakerb_ctx);\n \n-    if (*context_handle != GSS_C_NO_CONTEXT) {\n-        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n-\n-        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {\n-            iakerb_release_context(iakerb_ctx);\n-            *context_handle = GSS_C_NO_CONTEXT;\n-        } else {\n-            assert(iakerb_ctx->magic == KG_CONTEXT);\n-\n-            major_status = krb5_gss_delete_sec_context(minor_status,\n-                                                       context_handle,\n-                                                       output_token);\n-        }\n-    }\n-\n-    return major_status;\n+    return GSS_S_COMPLETE;\n }\n \n static krb5_boolean\n@@ -802,7 +793,7 @@ iakerb_gss_accept_sec_context(OM_uint32 *minor_status,\n     int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);\n \n     if (initialContextToken) {\n-        code = iakerb_alloc_context(&ctx);\n+        code = iakerb_alloc_context(&ctx, 0);\n         if (code != 0)\n             goto cleanup;\n \n@@ -854,11 +845,8 @@ iakerb_gss_accept_sec_context(OM_uint32 *minor_status,\n                                                        time_rec,\n                                                        delegated_cred_handle,\n                                                        &exts);\n-        if (major_status == GSS_S_COMPLETE) {\n-            *context_handle = ctx->gssc;\n-            ctx->gssc = NULL;\n-            iakerb_release_context(ctx);\n-        }\n+        if (major_status == GSS_S_COMPLETE)\n+            ctx->established = 1;\n         if (mech_type != NULL)\n             *mech_type = (gss_OID)gss_mech_krb5;\n     }\n@@ -897,7 +885,7 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,\n     int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);\n \n     if (initialContextToken) {\n-        code = iakerb_alloc_context(&ctx);\n+        code = iakerb_alloc_context(&ctx, 1);\n         if (code != 0) {\n             *minor_status = code;\n             goto cleanup;\n@@ -983,11 +971,8 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,\n                                                      ret_flags,\n                                                      time_rec,\n                                                      &exts);\n-        if (major_status == GSS_S_COMPLETE) {\n-            *context_handle = ctx->gssc;\n-            ctx->gssc = GSS_C_NO_CONTEXT;\n-            iakerb_release_context(ctx);\n-        }\n+        if (major_status == GSS_S_COMPLETE)\n+            ctx->established = 1;\n         if (actual_mech_type != NULL)\n             *actual_mech_type = (gss_OID)gss_mech_krb5;\n     } else {\n@@ -1010,3 +995,309 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,\n \n     return major_status;\n }\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_unwrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                  gss_buffer_t input_message_buffer,\n+                  gss_buffer_t output_message_buffer, int *conf_state,\n+                  gss_qop_t *qop_state)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_unwrap(minor_status, ctx->gssc, input_message_buffer,\n+                           output_message_buffer, conf_state, qop_state);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                int conf_req_flag, gss_qop_t qop_req,\n+                gss_buffer_t input_message_buffer, int *conf_state,\n+                gss_buffer_t output_message_buffer)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_wrap(minor_status, ctx->gssc, conf_req_flag, qop_req,\n+                         input_message_buffer, conf_state,\n+                         output_message_buffer);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_process_context_token(OM_uint32 *minor_status,\n+                                 const gss_ctx_id_t context_handle,\n+                                 const gss_buffer_t token_buffer)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_DEFECTIVE_TOKEN;\n+\n+    return krb5_gss_process_context_token(minor_status, ctx->gssc,\n+                                          token_buffer);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_context_time(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                        OM_uint32 *time_rec)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_context_time(minor_status, ctx->gssc, time_rec);\n+}\n+\n+#ifndef LEAN_CLIENT\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n+                              gss_ctx_id_t *context_handle,\n+                              gss_buffer_t interprocess_token)\n+{\n+    OM_uint32 maj;\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    /* We don't currently support exporting partially established contexts. */\n+    if (!ctx->established)\n+        return GSS_S_UNAVAILABLE;\n+\n+    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,\n+                                      interprocess_token);\n+    if (ctx->gssc == GSS_C_NO_CONTEXT) {\n+        iakerb_release_context(ctx);\n+        *context_handle = GSS_C_NO_CONTEXT;\n+    }\n+    return maj;\n+}\n+\n+/*\n+ * Until we implement partial context exports, there are no SPNEGO exported\n+ * context tokens, only tokens for the underlying krb5 context.  So we do not\n+ * need to implement an iakerb_gss_import_sec_context() yet; it would be\n+ * unreachable except via a manually constructed token.\n+ */\n+\n+#endif /* LEAN_CLIENT */\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_inquire_context(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, gss_name_t *src_name,\n+                           gss_name_t *targ_name, OM_uint32 *lifetime_rec,\n+                           gss_OID *mech_type, OM_uint32 *ctx_flags,\n+                           int *initiate, int *opened)\n+{\n+    OM_uint32 ret;\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (src_name != NULL)\n+        *src_name = GSS_C_NO_NAME;\n+    if (targ_name != NULL)\n+        *targ_name = GSS_C_NO_NAME;\n+    if (lifetime_rec != NULL)\n+        *lifetime_rec = 0;\n+    if (mech_type != NULL)\n+        *mech_type = (gss_OID)gss_mech_iakerb;\n+    if (ctx_flags != NULL)\n+        *ctx_flags = 0;\n+    if (initiate != NULL)\n+        *initiate = ctx->initiate;\n+    if (opened != NULL)\n+        *opened = ctx->established;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_COMPLETE;\n+\n+    ret = krb5_gss_inquire_context(minor_status, ctx->gssc, src_name,\n+                                   targ_name, lifetime_rec, mech_type,\n+                                   ctx_flags, initiate, opened);\n+\n+    if (!ctx->established) {\n+        /* Report IAKERB as the mech OID until the context is established. */\n+        if (mech_type != NULL)\n+            *mech_type = (gss_OID)gss_mech_iakerb;\n+\n+        /* We don't support exporting partially-established contexts. */\n+        if (ctx_flags != NULL)\n+            *ctx_flags &= ~GSS_C_TRANS_FLAG;\n+    }\n+\n+    return ret;\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_size_limit(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, int conf_req_flag,\n+                           gss_qop_t qop_req, OM_uint32 req_output_size,\n+                           OM_uint32 *max_input_size)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_wrap_size_limit(minor_status, ctx->gssc, conf_req_flag,\n+                                    qop_req, req_output_size, max_input_size);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                   gss_qop_t qop_req, gss_buffer_t message_buffer,\n+                   gss_buffer_t message_token)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_get_mic(minor_status, ctx->gssc, qop_req, message_buffer,\n+                            message_token);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_verify_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                      gss_buffer_t msg_buffer, gss_buffer_t token_buffer,\n+                      gss_qop_t *qop_state)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_verify_mic(minor_status, ctx->gssc, msg_buffer,\n+                               token_buffer, qop_state);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_inquire_sec_context_by_oid(OM_uint32 *minor_status,\n+                                      const gss_ctx_id_t context_handle,\n+                                      const gss_OID desired_object,\n+                                      gss_buffer_set_t *data_set)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_UNAVAILABLE;\n+\n+    return krb5_gss_inquire_sec_context_by_oid(minor_status, ctx->gssc,\n+                                               desired_object, data_set);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_set_sec_context_option(OM_uint32 *minor_status,\n+                                  gss_ctx_id_t *context_handle,\n+                                  const gss_OID desired_object,\n+                                  const gss_buffer_t value)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)*context_handle;\n+\n+    if (ctx == NULL || ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_UNAVAILABLE;\n+\n+    return krb5_gss_set_sec_context_option(minor_status, &ctx->gssc,\n+                                           desired_object, value);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                    int conf_req_flag, gss_qop_t qop_req, int *conf_state,\n+                    gss_iov_buffer_desc *iov, int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_wrap_iov(minor_status, ctx->gssc, conf_req_flag, qop_req,\n+                             conf_state, iov, iov_count);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_unwrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                      int *conf_state, gss_qop_t *qop_state,\n+                      gss_iov_buffer_desc *iov, int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_unwrap_iov(minor_status, ctx->gssc, conf_state, qop_state,\n+                               iov, iov_count);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_iov_length(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, int conf_req_flag,\n+                           gss_qop_t qop_req, int *conf_state,\n+                           gss_iov_buffer_desc *iov, int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_wrap_iov_length(minor_status, ctx->gssc, conf_req_flag,\n+                                    qop_req, conf_state, iov, iov_count);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_pseudo_random(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                         int prf_key, const gss_buffer_t prf_in,\n+                         ssize_t desired_output_len, gss_buffer_t prf_out)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_pseudo_random(minor_status, ctx->gssc, prf_key, prf_in,\n+                                  desired_output_len, prf_out);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n+                       int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_get_mic_iov(minor_status, ctx->gssc, qop_req, iov,\n+                                iov_count);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                          gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n+                          int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_verify_mic_iov(minor_status, ctx->gssc, qop_state, iov,\n+                                   iov_count);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic_iov_length(OM_uint32 *minor_status,\n+                              gss_ctx_id_t context_handle, gss_qop_t qop_req,\n+                              gss_iov_buffer_desc *iov, int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_get_mic_iov_length(minor_status, ctx->gssc, qop_req, iov,\n+                                       iov_count);\n+}""}"," static int gss_iakerbmechglue_init(void)
 {
     struct gss_mech_config mech_iakerb;
 
     memset(&mech_iakerb, 0, sizeof(mech_iakerb));
     mech_iakerb.mech = &iakerb_mechanism;

    mech_iakerb.mechNameStr = ""iakerb"";
    mech_iakerb.mech_type = (gss_OID)gss_mech_iakerb;
    gssint_register_mechinfo(&mech_iakerb);

    return 0;
}
"," static int gss_iakerbmechglue_init(void)
 {
     struct gss_mech_config mech_iakerb;
    struct gss_config iakerb_mechanism = krb5_mechanism;
    /* IAKERB mechanism mirrors krb5, but with different context SPIs */
    iakerb_mechanism.gss_accept_sec_context = iakerb_gss_accept_sec_context;
    iakerb_mechanism.gss_init_sec_context   = iakerb_gss_init_sec_context;
    iakerb_mechanism.gss_delete_sec_context = iakerb_gss_delete_sec_context;
    iakerb_mechanism.gss_acquire_cred       = iakerb_gss_acquire_cred;
    iakerb_mechanism.gssspi_acquire_cred_with_password
                                    = iakerb_gss_acquire_cred_with_password;
 
     memset(&mech_iakerb, 0, sizeof(mech_iakerb));
     mech_iakerb.mech = &iakerb_mechanism;

    mech_iakerb.mechNameStr = ""iakerb"";
    mech_iakerb.mech_type = (gss_OID)gss_mech_iakerb;
    gssint_register_mechinfo(&mech_iakerb);

    return 0;
}
",C,,"    struct gss_config iakerb_mechanism = krb5_mechanism;
    /* IAKERB mechanism mirrors krb5, but with different context SPIs */
    iakerb_mechanism.gss_accept_sec_context = iakerb_gss_accept_sec_context;
    iakerb_mechanism.gss_init_sec_context   = iakerb_gss_init_sec_context;
    iakerb_mechanism.gss_delete_sec_context = iakerb_gss_delete_sec_context;
    iakerb_mechanism.gss_acquire_cred       = iakerb_gss_acquire_cred;
    iakerb_mechanism.gssspi_acquire_cred_with_password
                                    = iakerb_gss_acquire_cred_with_password;
",,"@@ -351,7 +351,7 @@ static struct {
     }
 };
 
-static OM_uint32 KRB5_CALLCONV
+OM_uint32 KRB5_CALLCONV
 krb5_gss_inquire_sec_context_by_oid (OM_uint32 *minor_status,
                                      const gss_ctx_id_t context_handle,
                                      const gss_OID desired_object,
@@ -465,7 +465,7 @@ static struct {
 };
 #endif
 
-static OM_uint32 KRB5_CALLCONV
+OM_uint32 KRB5_CALLCONV
 krb5_gss_set_sec_context_option (OM_uint32 *minor_status,
                                  gss_ctx_id_t *context_handle,
                                  const gss_OID desired_object,
@@ -929,20 +929,103 @@ static struct gss_config krb5_mechanism = {
     krb5_gss_get_mic_iov_length,
 };
 
+/* Functions which use security contexts or acquire creds are IAKERB-specific;
+ * other functions can borrow from the krb5 mech. */
+static struct gss_config iakerb_mechanism = {
+    { GSS_MECH_KRB5_OID_LENGTH, GSS_MECH_KRB5_OID },
+    NULL,
+    iakerb_gss_acquire_cred,
+    krb5_gss_release_cred,
+    iakerb_gss_init_sec_context,
+#ifdef LEAN_CLIENT
+    NULL,
+#else
+    iakerb_gss_accept_sec_context,
+#endif
+    iakerb_gss_process_context_token,
+    iakerb_gss_delete_sec_context,
+    iakerb_gss_context_time,
+    iakerb_gss_get_mic,
+    iakerb_gss_verify_mic,
+#if defined(IOV_SHIM_EXERCISE_WRAP) || defined(IOV_SHIM_EXERCISE)
+    NULL,
+#else
+    iakerb_gss_wrap,
+#endif
+#if defined(IOV_SHIM_EXERCISE_UNWRAP) || defined(IOV_SHIM_EXERCISE)
+    NULL,
+#else
+    iakerb_gss_unwrap,
+#endif
+    krb5_gss_display_status,
+    krb5_gss_indicate_mechs,
+    krb5_gss_compare_name,
+    krb5_gss_display_name,
+    krb5_gss_import_name,
+    krb5_gss_release_name,
+    krb5_gss_inquire_cred,
+    NULL,                /* add_cred */
+#ifdef LEAN_CLIENT
+    NULL,
+    NULL,
+#else
+    iakerb_gss_export_sec_context,
+    NULL,
+#endif
+    krb5_gss_inquire_cred_by_mech,
+    krb5_gss_inquire_names_for_mech,
+    iakerb_gss_inquire_context,
+    krb5_gss_internal_release_oid,
+    iakerb_gss_wrap_size_limit,
+    krb5_gss_localname,
+    krb5_gss_authorize_localname,
+    krb5_gss_export_name,
+    krb5_gss_duplicate_name,
+    krb5_gss_store_cred,
+    iakerb_gss_inquire_sec_context_by_oid,
+    krb5_gss_inquire_cred_by_oid,
+    iakerb_gss_set_sec_context_option,
+    krb5_gssspi_set_cred_option,
+    krb5_gssspi_mech_invoke,
+    NULL,                /* wrap_aead */
+    NULL,                /* unwrap_aead */
+    iakerb_gss_wrap_iov,
+    iakerb_gss_unwrap_iov,
+    iakerb_gss_wrap_iov_length,
+    NULL,               /* complete_auth_token */
+    NULL,               /* acquire_cred_impersonate_name */
+    NULL,               /* add_cred_impersonate_name */
+    NULL,               /* display_name_ext */
+    krb5_gss_inquire_name,
+    krb5_gss_get_name_attribute,
+    krb5_gss_set_name_attribute,
+    krb5_gss_delete_name_attribute,
+    krb5_gss_export_name_composite,
+    krb5_gss_map_name_to_any,
+    krb5_gss_release_any_name_mapping,
+    iakerb_gss_pseudo_random,
+    NULL,               /* set_neg_mechs */
+    krb5_gss_inquire_saslname_for_mech,
+    krb5_gss_inquire_mech_for_saslname,
+    krb5_gss_inquire_attrs_for_mech,
+    krb5_gss_acquire_cred_from,
+    krb5_gss_store_cred_into,
+    iakerb_gss_acquire_cred_with_password,
+    krb5_gss_export_cred,
+    krb5_gss_import_cred,
+    NULL,               /* import_sec_context_by_mech */
+    NULL,               /* import_name_by_mech */
+    NULL,               /* import_cred_by_mech */
+    iakerb_gss_get_mic_iov,
+    iakerb_gss_verify_mic_iov,
+    iakerb_gss_get_mic_iov_length,
+};
+
 #ifdef _GSS_STATIC_LINK
 #include ""mglueP.h""
 static int gss_iakerbmechglue_init(void)
 {
     struct gss_mech_config mech_iakerb;
-    struct gss_config iakerb_mechanism = krb5_mechanism;
-
-    /* IAKERB mechanism mirrors krb5, but with different context SPIs */
-    iakerb_mechanism.gss_accept_sec_context = iakerb_gss_accept_sec_context;
-    iakerb_mechanism.gss_init_sec_context   = iakerb_gss_init_sec_context;
-    iakerb_mechanism.gss_delete_sec_context = iakerb_gss_delete_sec_context;
-    iakerb_mechanism.gss_acquire_cred       = iakerb_gss_acquire_cred;
-    iakerb_mechanism.gssspi_acquire_cred_with_password
-                                    = iakerb_gss_acquire_cred_with_password;
 
     memset(&mech_iakerb, 0, sizeof(mech_iakerb));
     mech_iakerb.mech = &iakerb_mechanism;",krb5,e04f0283516e80d2f93366e0d479d13c9b5c8c2a,b51b33f2bc5d1497ddf5bd107f791c101695000d,1," static int gss_iakerbmechglue_init(void)
 {
     struct gss_mech_config mech_iakerb;
//flaw_line_below:
    struct gss_config iakerb_mechanism = krb5_mechanism;
//flaw_line_below:

//flaw_line_below:
    /* IAKERB mechanism mirrors krb5, but with different context SPIs */
//flaw_line_below:
    iakerb_mechanism.gss_accept_sec_context = iakerb_gss_accept_sec_context;
//flaw_line_below:
    iakerb_mechanism.gss_init_sec_context   = iakerb_gss_init_sec_context;
//flaw_line_below:
    iakerb_mechanism.gss_delete_sec_context = iakerb_gss_delete_sec_context;
//flaw_line_below:
    iakerb_mechanism.gss_acquire_cred       = iakerb_gss_acquire_cred;
//flaw_line_below:
    iakerb_mechanism.gssspi_acquire_cred_with_password
//flaw_line_below:
                                    = iakerb_gss_acquire_cred_with_password;
 
     memset(&mech_iakerb, 0, sizeof(mech_iakerb));
     mech_iakerb.mech = &iakerb_mechanism;

    mech_iakerb.mechNameStr = ""iakerb"";
    mech_iakerb.mech_type = (gss_OID)gss_mech_iakerb;
    gssint_register_mechinfo(&mech_iakerb);

    return 0;
}
"
2079,179815,,Remote,Not required,Complete,CVE-2015-2696,https://www.cvedetails.com/cve/CVE-2015-2696/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/krb5/iakerb.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted IAKERB packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,3,https://github.com/krb5/krb5/commit/e04f0283516e80d2f93366e0d479d13c9b5c8c2a,e04f0283516e80d2f93366e0d479d13c9b5c8c2a,"Fix IAKERB context aliasing bugs [CVE-2015-2696]

The IAKERB mechanism currently replaces its context handle with the
krb5 mechanism handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the IAKERB context structure after context
establishment and add new IAKERB entry points to refer to it with that
type.  Add initiate and established flags to the IAKERB context
structure for use in gss_inquire_context() prior to context
establishment.

CVE-2015-2696:

In MIT krb5 1.9 and later, applications which call
gss_inquire_context() on a partially-established IAKERB context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  Java server applications using the
native JGSS provider are vulnerable to this bug.  A carefully crafted
IAKERB packet might allow the gss_inquire_context() call to succeed
with attacker-determined results, but applications should not make
access control decisions based on gss_inquire_context() results prior
to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",0,src/lib/gssapi/krb5/iakerb.c,"{""sha"": ""97e090d099f3672e9fe67c969c1615dc0710922c"", ""filename"": ""src/lib/gssapi/krb5/gssapiP_krb5.h"", ""status"": ""modified"", ""additions"": 114, ""deletions"": 0, ""changes"": 114, ""blob_url"": ""https://github.com/krb5/krb5/blob/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/gssapiP_krb5.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/gssapiP_krb5.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/krb5/gssapiP_krb5.h?ref=e04f0283516e80d2f93366e0d479d13c9b5c8c2a"", ""patch"": ""@@ -621,6 +621,21 @@ OM_uint32 KRB5_CALLCONV krb5_gss_accept_sec_context_ext\n );\n #endif /* LEAN_CLIENT */\n \n+OM_uint32 KRB5_CALLCONV krb5_gss_inquire_sec_context_by_oid\n+(OM_uint32*,       /* minor_status */\n+ const gss_ctx_id_t,\n+ /* context_handle */\n+ const gss_OID,    /* desired_object */\n+ gss_buffer_set_t* /* data_set */\n+);\n+\n+OM_uint32 KRB5_CALLCONV krb5_gss_set_sec_context_option\n+(OM_uint32*,       /* minor_status */\n+ gss_ctx_id_t*,    /* context_handle */\n+ const gss_OID,    /* desired_object */\n+ const gss_buffer_t/* value */\n+);\n+\n OM_uint32 KRB5_CALLCONV krb5_gss_process_context_token\n (OM_uint32*,       /* minor_status */\n  gss_ctx_id_t,     /* context_handle */\n@@ -1302,6 +1317,105 @@ OM_uint32 KRB5_CALLCONV\n krb5_gss_import_cred(OM_uint32 *minor_status, gss_buffer_t token,\n                      gss_cred_id_t *cred_handle);\n \n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_process_context_token(OM_uint32 *minor_status,\n+                                 const gss_ctx_id_t context_handle,\n+                                 const gss_buffer_t token_buffer);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_context_time(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                        OM_uint32 *time_rec);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_inquire_context(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, gss_name_t *src_name,\n+                           gss_name_t *targ_name, OM_uint32 *lifetime_rec,\n+                           gss_OID *mech_type, OM_uint32 *ctx_flags,\n+                           int *locally_initiated, int *opened);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                   gss_qop_t qop_req, gss_buffer_t message_buffer,\n+                   gss_buffer_t message_token);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n+                       int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic_iov_length(OM_uint32 *minor_status,\n+                              gss_ctx_id_t context_handle, gss_qop_t qop_req,\n+                              gss_iov_buffer_desc *iov, int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_verify_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                      gss_buffer_t msg_buffer, gss_buffer_t token_buffer,\n+                      gss_qop_t *qop_state);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                          gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n+                          int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                int conf_req_flag, gss_qop_t qop_req,\n+                gss_buffer_t input_message_buffer, int *conf_state,\n+                gss_buffer_t output_message_buffer);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                    int conf_req_flag, gss_qop_t qop_req, int *conf_state,\n+                    gss_iov_buffer_desc *iov, int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_iov_length(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, int conf_req_flag,\n+                           gss_qop_t qop_req, int *conf_state,\n+                           gss_iov_buffer_desc *iov, int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_unwrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                  gss_buffer_t input_message_buffer,\n+                  gss_buffer_t output_message_buffer, int *conf_state,\n+                  gss_qop_t *qop_state);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_unwrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                      int *conf_state, gss_qop_t *qop_state,\n+                      gss_iov_buffer_desc *iov, int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_size_limit(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, int conf_req_flag,\n+                           gss_qop_t qop_req, OM_uint32 req_output_size,\n+                           OM_uint32 *max_input_size);\n+\n+#ifndef LEAN_CLIENT\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n+                              gss_ctx_id_t *context_handle,\n+                              gss_buffer_t interprocess_token);\n+#endif /* LEAN_CLIENT */\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_inquire_sec_context_by_oid(OM_uint32 *minor_status,\n+                                      const gss_ctx_id_t context_handle,\n+                                      const gss_OID desired_object,\n+                                      gss_buffer_set_t *data_set);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_set_sec_context_option(OM_uint32 *minor_status,\n+                                  gss_ctx_id_t *context_handle,\n+                                  const gss_OID desired_object,\n+                                  const gss_buffer_t value);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_pseudo_random(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                         int prf_key, const gss_buffer_t prf_in,\n+                         ssize_t desired_output_len, gss_buffer_t prf_out);\n+\n /* Magic string to identify exported krb5 GSS credentials.  Increment this if\n  * the format changes. */\n #define CRED_EXPORT_MAGIC \""K5C1\""""}<_**next**_>{""sha"": ""c4dfdd6fbd1338c6ad8bb2a395fff7cafa8de82b"", ""filename"": ""src/lib/gssapi/krb5/gssapi_krb5.c"", ""status"": ""modified"", ""additions"": 94, ""deletions"": 11, ""changes"": 105, ""blob_url"": ""https://github.com/krb5/krb5/blob/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/gssapi_krb5.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/gssapi_krb5.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/krb5/gssapi_krb5.c?ref=e04f0283516e80d2f93366e0d479d13c9b5c8c2a"", ""patch"": ""@@ -351,7 +351,7 @@ static struct {\n     }\n };\n \n-static OM_uint32 KRB5_CALLCONV\n+OM_uint32 KRB5_CALLCONV\n krb5_gss_inquire_sec_context_by_oid (OM_uint32 *minor_status,\n                                      const gss_ctx_id_t context_handle,\n                                      const gss_OID desired_object,\n@@ -465,7 +465,7 @@ static struct {\n };\n #endif\n \n-static OM_uint32 KRB5_CALLCONV\n+OM_uint32 KRB5_CALLCONV\n krb5_gss_set_sec_context_option (OM_uint32 *minor_status,\n                                  gss_ctx_id_t *context_handle,\n                                  const gss_OID desired_object,\n@@ -929,20 +929,103 @@ static struct gss_config krb5_mechanism = {\n     krb5_gss_get_mic_iov_length,\n };\n \n+/* Functions which use security contexts or acquire creds are IAKERB-specific;\n+ * other functions can borrow from the krb5 mech. */\n+static struct gss_config iakerb_mechanism = {\n+    { GSS_MECH_KRB5_OID_LENGTH, GSS_MECH_KRB5_OID },\n+    NULL,\n+    iakerb_gss_acquire_cred,\n+    krb5_gss_release_cred,\n+    iakerb_gss_init_sec_context,\n+#ifdef LEAN_CLIENT\n+    NULL,\n+#else\n+    iakerb_gss_accept_sec_context,\n+#endif\n+    iakerb_gss_process_context_token,\n+    iakerb_gss_delete_sec_context,\n+    iakerb_gss_context_time,\n+    iakerb_gss_get_mic,\n+    iakerb_gss_verify_mic,\n+#if defined(IOV_SHIM_EXERCISE_WRAP) || defined(IOV_SHIM_EXERCISE)\n+    NULL,\n+#else\n+    iakerb_gss_wrap,\n+#endif\n+#if defined(IOV_SHIM_EXERCISE_UNWRAP) || defined(IOV_SHIM_EXERCISE)\n+    NULL,\n+#else\n+    iakerb_gss_unwrap,\n+#endif\n+    krb5_gss_display_status,\n+    krb5_gss_indicate_mechs,\n+    krb5_gss_compare_name,\n+    krb5_gss_display_name,\n+    krb5_gss_import_name,\n+    krb5_gss_release_name,\n+    krb5_gss_inquire_cred,\n+    NULL,                /* add_cred */\n+#ifdef LEAN_CLIENT\n+    NULL,\n+    NULL,\n+#else\n+    iakerb_gss_export_sec_context,\n+    NULL,\n+#endif\n+    krb5_gss_inquire_cred_by_mech,\n+    krb5_gss_inquire_names_for_mech,\n+    iakerb_gss_inquire_context,\n+    krb5_gss_internal_release_oid,\n+    iakerb_gss_wrap_size_limit,\n+    krb5_gss_localname,\n+    krb5_gss_authorize_localname,\n+    krb5_gss_export_name,\n+    krb5_gss_duplicate_name,\n+    krb5_gss_store_cred,\n+    iakerb_gss_inquire_sec_context_by_oid,\n+    krb5_gss_inquire_cred_by_oid,\n+    iakerb_gss_set_sec_context_option,\n+    krb5_gssspi_set_cred_option,\n+    krb5_gssspi_mech_invoke,\n+    NULL,                /* wrap_aead */\n+    NULL,                /* unwrap_aead */\n+    iakerb_gss_wrap_iov,\n+    iakerb_gss_unwrap_iov,\n+    iakerb_gss_wrap_iov_length,\n+    NULL,               /* complete_auth_token */\n+    NULL,               /* acquire_cred_impersonate_name */\n+    NULL,               /* add_cred_impersonate_name */\n+    NULL,               /* display_name_ext */\n+    krb5_gss_inquire_name,\n+    krb5_gss_get_name_attribute,\n+    krb5_gss_set_name_attribute,\n+    krb5_gss_delete_name_attribute,\n+    krb5_gss_export_name_composite,\n+    krb5_gss_map_name_to_any,\n+    krb5_gss_release_any_name_mapping,\n+    iakerb_gss_pseudo_random,\n+    NULL,               /* set_neg_mechs */\n+    krb5_gss_inquire_saslname_for_mech,\n+    krb5_gss_inquire_mech_for_saslname,\n+    krb5_gss_inquire_attrs_for_mech,\n+    krb5_gss_acquire_cred_from,\n+    krb5_gss_store_cred_into,\n+    iakerb_gss_acquire_cred_with_password,\n+    krb5_gss_export_cred,\n+    krb5_gss_import_cred,\n+    NULL,               /* import_sec_context_by_mech */\n+    NULL,               /* import_name_by_mech */\n+    NULL,               /* import_cred_by_mech */\n+    iakerb_gss_get_mic_iov,\n+    iakerb_gss_verify_mic_iov,\n+    iakerb_gss_get_mic_iov_length,\n+};\n+\n #ifdef _GSS_STATIC_LINK\n #include \""mglueP.h\""\n static int gss_iakerbmechglue_init(void)\n {\n     struct gss_mech_config mech_iakerb;\n-    struct gss_config iakerb_mechanism = krb5_mechanism;\n-\n-    /* IAKERB mechanism mirrors krb5, but with different context SPIs */\n-    iakerb_mechanism.gss_accept_sec_context = iakerb_gss_accept_sec_context;\n-    iakerb_mechanism.gss_init_sec_context   = iakerb_gss_init_sec_context;\n-    iakerb_mechanism.gss_delete_sec_context = iakerb_gss_delete_sec_context;\n-    iakerb_mechanism.gss_acquire_cred       = iakerb_gss_acquire_cred;\n-    iakerb_mechanism.gssspi_acquire_cred_with_password\n-                                    = iakerb_gss_acquire_cred_with_password;\n \n     memset(&mech_iakerb, 0, sizeof(mech_iakerb));\n     mech_iakerb.mech = &iakerb_mechanism;""}<_**next**_>{""sha"": ""4662bd9fe382fdde657abaa6db06fa47ad69d8b7"", ""filename"": ""src/lib/gssapi/krb5/iakerb.c"", ""status"": ""modified"", ""additions"": 321, ""deletions"": 30, ""changes"": 351, ""blob_url"": ""https://github.com/krb5/krb5/blob/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/iakerb.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/iakerb.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/krb5/iakerb.c?ref=e04f0283516e80d2f93366e0d479d13c9b5c8c2a"", ""patch"": ""@@ -47,6 +47,8 @@ struct _iakerb_ctx_id_rec {\n     gss_ctx_id_t gssc;\n     krb5_data conv;                     /* conversation for checksumming */\n     unsigned int count;                 /* number of round trips */\n+    int initiate;\n+    int established;\n     krb5_get_init_creds_opt *gic_opts;\n };\n \n@@ -695,7 +697,7 @@ iakerb_get_initial_state(iakerb_ctx_id_t ctx,\n  * Allocate and initialise an IAKERB context\n  */\n static krb5_error_code\n-iakerb_alloc_context(iakerb_ctx_id_t *pctx)\n+iakerb_alloc_context(iakerb_ctx_id_t *pctx, int initiate)\n {\n     iakerb_ctx_id_t ctx;\n     krb5_error_code code;\n@@ -709,6 +711,8 @@ iakerb_alloc_context(iakerb_ctx_id_t *pctx)\n     ctx->magic = KG_IAKERB_CONTEXT;\n     ctx->state = IAKERB_AS_REQ;\n     ctx->count = 0;\n+    ctx->initiate = initiate;\n+    ctx->established = 0;\n \n     code = krb5_gss_init_context(&ctx->k5c);\n     if (code != 0)\n@@ -732,31 +736,18 @@ iakerb_gss_delete_sec_context(OM_uint32 *minor_status,\n                               gss_ctx_id_t *context_handle,\n                               gss_buffer_t output_token)\n {\n-    OM_uint32 major_status = GSS_S_COMPLETE;\n+    iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n \n     if (output_token != GSS_C_NO_BUFFER) {\n         output_token->length = 0;\n         output_token->value = NULL;\n     }\n \n     *minor_status = 0;\n+    *context_handle = GSS_C_NO_CONTEXT;\n+    iakerb_release_context(iakerb_ctx);\n \n-    if (*context_handle != GSS_C_NO_CONTEXT) {\n-        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n-\n-        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {\n-            iakerb_release_context(iakerb_ctx);\n-            *context_handle = GSS_C_NO_CONTEXT;\n-        } else {\n-            assert(iakerb_ctx->magic == KG_CONTEXT);\n-\n-            major_status = krb5_gss_delete_sec_context(minor_status,\n-                                                       context_handle,\n-                                                       output_token);\n-        }\n-    }\n-\n-    return major_status;\n+    return GSS_S_COMPLETE;\n }\n \n static krb5_boolean\n@@ -802,7 +793,7 @@ iakerb_gss_accept_sec_context(OM_uint32 *minor_status,\n     int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);\n \n     if (initialContextToken) {\n-        code = iakerb_alloc_context(&ctx);\n+        code = iakerb_alloc_context(&ctx, 0);\n         if (code != 0)\n             goto cleanup;\n \n@@ -854,11 +845,8 @@ iakerb_gss_accept_sec_context(OM_uint32 *minor_status,\n                                                        time_rec,\n                                                        delegated_cred_handle,\n                                                        &exts);\n-        if (major_status == GSS_S_COMPLETE) {\n-            *context_handle = ctx->gssc;\n-            ctx->gssc = NULL;\n-            iakerb_release_context(ctx);\n-        }\n+        if (major_status == GSS_S_COMPLETE)\n+            ctx->established = 1;\n         if (mech_type != NULL)\n             *mech_type = (gss_OID)gss_mech_krb5;\n     }\n@@ -897,7 +885,7 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,\n     int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);\n \n     if (initialContextToken) {\n-        code = iakerb_alloc_context(&ctx);\n+        code = iakerb_alloc_context(&ctx, 1);\n         if (code != 0) {\n             *minor_status = code;\n             goto cleanup;\n@@ -983,11 +971,8 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,\n                                                      ret_flags,\n                                                      time_rec,\n                                                      &exts);\n-        if (major_status == GSS_S_COMPLETE) {\n-            *context_handle = ctx->gssc;\n-            ctx->gssc = GSS_C_NO_CONTEXT;\n-            iakerb_release_context(ctx);\n-        }\n+        if (major_status == GSS_S_COMPLETE)\n+            ctx->established = 1;\n         if (actual_mech_type != NULL)\n             *actual_mech_type = (gss_OID)gss_mech_krb5;\n     } else {\n@@ -1010,3 +995,309 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,\n \n     return major_status;\n }\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_unwrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                  gss_buffer_t input_message_buffer,\n+                  gss_buffer_t output_message_buffer, int *conf_state,\n+                  gss_qop_t *qop_state)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_unwrap(minor_status, ctx->gssc, input_message_buffer,\n+                           output_message_buffer, conf_state, qop_state);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                int conf_req_flag, gss_qop_t qop_req,\n+                gss_buffer_t input_message_buffer, int *conf_state,\n+                gss_buffer_t output_message_buffer)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_wrap(minor_status, ctx->gssc, conf_req_flag, qop_req,\n+                         input_message_buffer, conf_state,\n+                         output_message_buffer);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_process_context_token(OM_uint32 *minor_status,\n+                                 const gss_ctx_id_t context_handle,\n+                                 const gss_buffer_t token_buffer)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_DEFECTIVE_TOKEN;\n+\n+    return krb5_gss_process_context_token(minor_status, ctx->gssc,\n+                                          token_buffer);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_context_time(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                        OM_uint32 *time_rec)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_context_time(minor_status, ctx->gssc, time_rec);\n+}\n+\n+#ifndef LEAN_CLIENT\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n+                              gss_ctx_id_t *context_handle,\n+                              gss_buffer_t interprocess_token)\n+{\n+    OM_uint32 maj;\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    /* We don't currently support exporting partially established contexts. */\n+    if (!ctx->established)\n+        return GSS_S_UNAVAILABLE;\n+\n+    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,\n+                                      interprocess_token);\n+    if (ctx->gssc == GSS_C_NO_CONTEXT) {\n+        iakerb_release_context(ctx);\n+        *context_handle = GSS_C_NO_CONTEXT;\n+    }\n+    return maj;\n+}\n+\n+/*\n+ * Until we implement partial context exports, there are no SPNEGO exported\n+ * context tokens, only tokens for the underlying krb5 context.  So we do not\n+ * need to implement an iakerb_gss_import_sec_context() yet; it would be\n+ * unreachable except via a manually constructed token.\n+ */\n+\n+#endif /* LEAN_CLIENT */\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_inquire_context(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, gss_name_t *src_name,\n+                           gss_name_t *targ_name, OM_uint32 *lifetime_rec,\n+                           gss_OID *mech_type, OM_uint32 *ctx_flags,\n+                           int *initiate, int *opened)\n+{\n+    OM_uint32 ret;\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (src_name != NULL)\n+        *src_name = GSS_C_NO_NAME;\n+    if (targ_name != NULL)\n+        *targ_name = GSS_C_NO_NAME;\n+    if (lifetime_rec != NULL)\n+        *lifetime_rec = 0;\n+    if (mech_type != NULL)\n+        *mech_type = (gss_OID)gss_mech_iakerb;\n+    if (ctx_flags != NULL)\n+        *ctx_flags = 0;\n+    if (initiate != NULL)\n+        *initiate = ctx->initiate;\n+    if (opened != NULL)\n+        *opened = ctx->established;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_COMPLETE;\n+\n+    ret = krb5_gss_inquire_context(minor_status, ctx->gssc, src_name,\n+                                   targ_name, lifetime_rec, mech_type,\n+                                   ctx_flags, initiate, opened);\n+\n+    if (!ctx->established) {\n+        /* Report IAKERB as the mech OID until the context is established. */\n+        if (mech_type != NULL)\n+            *mech_type = (gss_OID)gss_mech_iakerb;\n+\n+        /* We don't support exporting partially-established contexts. */\n+        if (ctx_flags != NULL)\n+            *ctx_flags &= ~GSS_C_TRANS_FLAG;\n+    }\n+\n+    return ret;\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_size_limit(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, int conf_req_flag,\n+                           gss_qop_t qop_req, OM_uint32 req_output_size,\n+                           OM_uint32 *max_input_size)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_wrap_size_limit(minor_status, ctx->gssc, conf_req_flag,\n+                                    qop_req, req_output_size, max_input_size);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                   gss_qop_t qop_req, gss_buffer_t message_buffer,\n+                   gss_buffer_t message_token)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_get_mic(minor_status, ctx->gssc, qop_req, message_buffer,\n+                            message_token);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_verify_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                      gss_buffer_t msg_buffer, gss_buffer_t token_buffer,\n+                      gss_qop_t *qop_state)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_verify_mic(minor_status, ctx->gssc, msg_buffer,\n+                               token_buffer, qop_state);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_inquire_sec_context_by_oid(OM_uint32 *minor_status,\n+                                      const gss_ctx_id_t context_handle,\n+                                      const gss_OID desired_object,\n+                                      gss_buffer_set_t *data_set)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_UNAVAILABLE;\n+\n+    return krb5_gss_inquire_sec_context_by_oid(minor_status, ctx->gssc,\n+                                               desired_object, data_set);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_set_sec_context_option(OM_uint32 *minor_status,\n+                                  gss_ctx_id_t *context_handle,\n+                                  const gss_OID desired_object,\n+                                  const gss_buffer_t value)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)*context_handle;\n+\n+    if (ctx == NULL || ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_UNAVAILABLE;\n+\n+    return krb5_gss_set_sec_context_option(minor_status, &ctx->gssc,\n+                                           desired_object, value);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                    int conf_req_flag, gss_qop_t qop_req, int *conf_state,\n+                    gss_iov_buffer_desc *iov, int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_wrap_iov(minor_status, ctx->gssc, conf_req_flag, qop_req,\n+                             conf_state, iov, iov_count);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_unwrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                      int *conf_state, gss_qop_t *qop_state,\n+                      gss_iov_buffer_desc *iov, int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_unwrap_iov(minor_status, ctx->gssc, conf_state, qop_state,\n+                               iov, iov_count);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_iov_length(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, int conf_req_flag,\n+                           gss_qop_t qop_req, int *conf_state,\n+                           gss_iov_buffer_desc *iov, int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_wrap_iov_length(minor_status, ctx->gssc, conf_req_flag,\n+                                    qop_req, conf_state, iov, iov_count);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_pseudo_random(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                         int prf_key, const gss_buffer_t prf_in,\n+                         ssize_t desired_output_len, gss_buffer_t prf_out)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_pseudo_random(minor_status, ctx->gssc, prf_key, prf_in,\n+                                  desired_output_len, prf_out);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n+                       int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_get_mic_iov(minor_status, ctx->gssc, qop_req, iov,\n+                                iov_count);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                          gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n+                          int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_verify_mic_iov(minor_status, ctx->gssc, qop_state, iov,\n+                                   iov_count);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic_iov_length(OM_uint32 *minor_status,\n+                              gss_ctx_id_t context_handle, gss_qop_t qop_req,\n+                              gss_iov_buffer_desc *iov, int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_get_mic_iov_length(minor_status, ctx->gssc, qop_req, iov,\n+                                       iov_count);\n+}""}","iakerb_alloc_context(iakerb_ctx_id_t *pctx)
iakerb_alloc_context(iakerb_ctx_id_t *pctx, int initiate)
 {
     iakerb_ctx_id_t ctx;
     krb5_error_code code;

    *pctx = NULL;

    ctx = k5alloc(sizeof(*ctx), &code);
    if (ctx == NULL)
        goto cleanup;
    ctx->defcred = GSS_C_NO_CREDENTIAL;
     ctx->magic = KG_IAKERB_CONTEXT;
     ctx->state = IAKERB_AS_REQ;
     ctx->count = 0;
    ctx->initiate = initiate;
    ctx->established = 0;
 
     code = krb5_gss_init_context(&ctx->k5c);
     if (code != 0)
        goto cleanup;

    *pctx = ctx;

cleanup:
    if (code != 0)
        iakerb_release_context(ctx);

    return code;
}
","iakerb_alloc_context(iakerb_ctx_id_t *pctx)
 {
     iakerb_ctx_id_t ctx;
     krb5_error_code code;

    *pctx = NULL;

    ctx = k5alloc(sizeof(*ctx), &code);
    if (ctx == NULL)
        goto cleanup;
    ctx->defcred = GSS_C_NO_CREDENTIAL;
     ctx->magic = KG_IAKERB_CONTEXT;
     ctx->state = IAKERB_AS_REQ;
     ctx->count = 0;
 
     code = krb5_gss_init_context(&ctx->k5c);
     if (code != 0)
        goto cleanup;

    *pctx = ctx;

cleanup:
    if (code != 0)
        iakerb_release_context(ctx);

    return code;
}
",C,"iakerb_alloc_context(iakerb_ctx_id_t *pctx, int initiate)
    ctx->initiate = initiate;
    ctx->established = 0;
",,,"@@ -47,6 +47,8 @@ struct _iakerb_ctx_id_rec {
     gss_ctx_id_t gssc;
     krb5_data conv;                     /* conversation for checksumming */
     unsigned int count;                 /* number of round trips */
+    int initiate;
+    int established;
     krb5_get_init_creds_opt *gic_opts;
 };
 
@@ -695,7 +697,7 @@ iakerb_get_initial_state(iakerb_ctx_id_t ctx,
  * Allocate and initialise an IAKERB context
  */
 static krb5_error_code
-iakerb_alloc_context(iakerb_ctx_id_t *pctx)
+iakerb_alloc_context(iakerb_ctx_id_t *pctx, int initiate)
 {
     iakerb_ctx_id_t ctx;
     krb5_error_code code;
@@ -709,6 +711,8 @@ iakerb_alloc_context(iakerb_ctx_id_t *pctx)
     ctx->magic = KG_IAKERB_CONTEXT;
     ctx->state = IAKERB_AS_REQ;
     ctx->count = 0;
+    ctx->initiate = initiate;
+    ctx->established = 0;
 
     code = krb5_gss_init_context(&ctx->k5c);
     if (code != 0)
@@ -732,31 +736,18 @@ iakerb_gss_delete_sec_context(OM_uint32 *minor_status,
                               gss_ctx_id_t *context_handle,
                               gss_buffer_t output_token)
 {
-    OM_uint32 major_status = GSS_S_COMPLETE;
+    iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;
 
     if (output_token != GSS_C_NO_BUFFER) {
         output_token->length = 0;
         output_token->value = NULL;
     }
 
     *minor_status = 0;
+    *context_handle = GSS_C_NO_CONTEXT;
+    iakerb_release_context(iakerb_ctx);
 
-    if (*context_handle != GSS_C_NO_CONTEXT) {
-        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;
-
-        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {
-            iakerb_release_context(iakerb_ctx);
-            *context_handle = GSS_C_NO_CONTEXT;
-        } else {
-            assert(iakerb_ctx->magic == KG_CONTEXT);
-
-            major_status = krb5_gss_delete_sec_context(minor_status,
-                                                       context_handle,
-                                                       output_token);
-        }
-    }
-
-    return major_status;
+    return GSS_S_COMPLETE;
 }
 
 static krb5_boolean
@@ -802,7 +793,7 @@ iakerb_gss_accept_sec_context(OM_uint32 *minor_status,
     int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);
 
     if (initialContextToken) {
-        code = iakerb_alloc_context(&ctx);
+        code = iakerb_alloc_context(&ctx, 0);
         if (code != 0)
             goto cleanup;
 
@@ -854,11 +845,8 @@ iakerb_gss_accept_sec_context(OM_uint32 *minor_status,
                                                        time_rec,
                                                        delegated_cred_handle,
                                                        &exts);
-        if (major_status == GSS_S_COMPLETE) {
-            *context_handle = ctx->gssc;
-            ctx->gssc = NULL;
-            iakerb_release_context(ctx);
-        }
+        if (major_status == GSS_S_COMPLETE)
+            ctx->established = 1;
         if (mech_type != NULL)
             *mech_type = (gss_OID)gss_mech_krb5;
     }
@@ -897,7 +885,7 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,
     int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);
 
     if (initialContextToken) {
-        code = iakerb_alloc_context(&ctx);
+        code = iakerb_alloc_context(&ctx, 1);
         if (code != 0) {
             *minor_status = code;
             goto cleanup;
@@ -983,11 +971,8 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,
                                                      ret_flags,
                                                      time_rec,
                                                      &exts);
-        if (major_status == GSS_S_COMPLETE) {
-            *context_handle = ctx->gssc;
-            ctx->gssc = GSS_C_NO_CONTEXT;
-            iakerb_release_context(ctx);
-        }
+        if (major_status == GSS_S_COMPLETE)
+            ctx->established = 1;
         if (actual_mech_type != NULL)
             *actual_mech_type = (gss_OID)gss_mech_krb5;
     } else {
@@ -1010,3 +995,309 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,
 
     return major_status;
 }
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_unwrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                  gss_buffer_t input_message_buffer,
+                  gss_buffer_t output_message_buffer, int *conf_state,
+                  gss_qop_t *qop_state)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_unwrap(minor_status, ctx->gssc, input_message_buffer,
+                           output_message_buffer, conf_state, qop_state);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_wrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                int conf_req_flag, gss_qop_t qop_req,
+                gss_buffer_t input_message_buffer, int *conf_state,
+                gss_buffer_t output_message_buffer)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_wrap(minor_status, ctx->gssc, conf_req_flag, qop_req,
+                         input_message_buffer, conf_state,
+                         output_message_buffer);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_process_context_token(OM_uint32 *minor_status,
+                                 const gss_ctx_id_t context_handle,
+                                 const gss_buffer_t token_buffer)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_DEFECTIVE_TOKEN;
+
+    return krb5_gss_process_context_token(minor_status, ctx->gssc,
+                                          token_buffer);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_context_time(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                        OM_uint32 *time_rec)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_context_time(minor_status, ctx->gssc, time_rec);
+}
+
+#ifndef LEAN_CLIENT
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_export_sec_context(OM_uint32 *minor_status,
+                              gss_ctx_id_t *context_handle,
+                              gss_buffer_t interprocess_token)
+{
+    OM_uint32 maj;
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    /* We don't currently support exporting partially established contexts. */
+    if (!ctx->established)
+        return GSS_S_UNAVAILABLE;
+
+    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,
+                                      interprocess_token);
+    if (ctx->gssc == GSS_C_NO_CONTEXT) {
+        iakerb_release_context(ctx);
+        *context_handle = GSS_C_NO_CONTEXT;
+    }
+    return maj;
+}
+
+/*
+ * Until we implement partial context exports, there are no SPNEGO exported
+ * context tokens, only tokens for the underlying krb5 context.  So we do not
+ * need to implement an iakerb_gss_import_sec_context() yet; it would be
+ * unreachable except via a manually constructed token.
+ */
+
+#endif /* LEAN_CLIENT */
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_inquire_context(OM_uint32 *minor_status,
+                           gss_ctx_id_t context_handle, gss_name_t *src_name,
+                           gss_name_t *targ_name, OM_uint32 *lifetime_rec,
+                           gss_OID *mech_type, OM_uint32 *ctx_flags,
+                           int *initiate, int *opened)
+{
+    OM_uint32 ret;
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (src_name != NULL)
+        *src_name = GSS_C_NO_NAME;
+    if (targ_name != NULL)
+        *targ_name = GSS_C_NO_NAME;
+    if (lifetime_rec != NULL)
+        *lifetime_rec = 0;
+    if (mech_type != NULL)
+        *mech_type = (gss_OID)gss_mech_iakerb;
+    if (ctx_flags != NULL)
+        *ctx_flags = 0;
+    if (initiate != NULL)
+        *initiate = ctx->initiate;
+    if (opened != NULL)
+        *opened = ctx->established;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_COMPLETE;
+
+    ret = krb5_gss_inquire_context(minor_status, ctx->gssc, src_name,
+                                   targ_name, lifetime_rec, mech_type,
+                                   ctx_flags, initiate, opened);
+
+    if (!ctx->established) {
+        /* Report IAKERB as the mech OID until the context is established. */
+        if (mech_type != NULL)
+            *mech_type = (gss_OID)gss_mech_iakerb;
+
+        /* We don't support exporting partially-established contexts. */
+        if (ctx_flags != NULL)
+            *ctx_flags &= ~GSS_C_TRANS_FLAG;
+    }
+
+    return ret;
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_wrap_size_limit(OM_uint32 *minor_status,
+                           gss_ctx_id_t context_handle, int conf_req_flag,
+                           gss_qop_t qop_req, OM_uint32 req_output_size,
+                           OM_uint32 *max_input_size)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_wrap_size_limit(minor_status, ctx->gssc, conf_req_flag,
+                                    qop_req, req_output_size, max_input_size);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_get_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                   gss_qop_t qop_req, gss_buffer_t message_buffer,
+                   gss_buffer_t message_token)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_get_mic(minor_status, ctx->gssc, qop_req, message_buffer,
+                            message_token);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_verify_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                      gss_buffer_t msg_buffer, gss_buffer_t token_buffer,
+                      gss_qop_t *qop_state)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_verify_mic(minor_status, ctx->gssc, msg_buffer,
+                               token_buffer, qop_state);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_inquire_sec_context_by_oid(OM_uint32 *minor_status,
+                                      const gss_ctx_id_t context_handle,
+                                      const gss_OID desired_object,
+                                      gss_buffer_set_t *data_set)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_UNAVAILABLE;
+
+    return krb5_gss_inquire_sec_context_by_oid(minor_status, ctx->gssc,
+                                               desired_object, data_set);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_set_sec_context_option(OM_uint32 *minor_status,
+                                  gss_ctx_id_t *context_handle,
+                                  const gss_OID desired_object,
+                                  const gss_buffer_t value)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)*context_handle;
+
+    if (ctx == NULL || ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_UNAVAILABLE;
+
+    return krb5_gss_set_sec_context_option(minor_status, &ctx->gssc,
+                                           desired_object, value);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_wrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                    int conf_req_flag, gss_qop_t qop_req, int *conf_state,
+                    gss_iov_buffer_desc *iov, int iov_count)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_wrap_iov(minor_status, ctx->gssc, conf_req_flag, qop_req,
+                             conf_state, iov, iov_count);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_unwrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                      int *conf_state, gss_qop_t *qop_state,
+                      gss_iov_buffer_desc *iov, int iov_count)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_unwrap_iov(minor_status, ctx->gssc, conf_state, qop_state,
+                               iov, iov_count);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_wrap_iov_length(OM_uint32 *minor_status,
+                           gss_ctx_id_t context_handle, int conf_req_flag,
+                           gss_qop_t qop_req, int *conf_state,
+                           gss_iov_buffer_desc *iov, int iov_count)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_wrap_iov_length(minor_status, ctx->gssc, conf_req_flag,
+                                    qop_req, conf_state, iov, iov_count);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_pseudo_random(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                         int prf_key, const gss_buffer_t prf_in,
+                         ssize_t desired_output_len, gss_buffer_t prf_out)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_pseudo_random(minor_status, ctx->gssc, prf_key, prf_in,
+                                  desired_output_len, prf_out);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
+                       int iov_count)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_get_mic_iov(minor_status, ctx->gssc, qop_req, iov,
+                                iov_count);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                          gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
+                          int iov_count)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_verify_mic_iov(minor_status, ctx->gssc, qop_state, iov,
+                                   iov_count);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_get_mic_iov_length(OM_uint32 *minor_status,
+                              gss_ctx_id_t context_handle, gss_qop_t qop_req,
+                              gss_iov_buffer_desc *iov, int iov_count)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_get_mic_iov_length(minor_status, ctx->gssc, qop_req, iov,
+                                       iov_count);
+}",krb5,e04f0283516e80d2f93366e0d479d13c9b5c8c2a,b51b33f2bc5d1497ddf5bd107f791c101695000d,1,"iakerb_alloc_context(iakerb_ctx_id_t *pctx)
//fix_flaw_line_below:
//iakerb_alloc_context(iakerb_ctx_id_t *pctx, int initiate)
 {
     iakerb_ctx_id_t ctx;
     krb5_error_code code;

    *pctx = NULL;

    ctx = k5alloc(sizeof(*ctx), &code);
    if (ctx == NULL)
        goto cleanup;
    ctx->defcred = GSS_C_NO_CREDENTIAL;
     ctx->magic = KG_IAKERB_CONTEXT;
     ctx->state = IAKERB_AS_REQ;
     ctx->count = 0;
//fix_flaw_line_below:
//    ctx->initiate = initiate;
//fix_flaw_line_below:
//    ctx->established = 0;
 
     code = krb5_gss_init_context(&ctx->k5c);
     if (code != 0)
        goto cleanup;

    *pctx = ctx;

cleanup:
    if (code != 0)
        iakerb_release_context(ctx);

    return code;
}
"
2080,179816,,Remote,Not required,Complete,CVE-2015-2696,https://www.cvedetails.com/cve/CVE-2015-2696/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/krb5/iakerb.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted IAKERB packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,3,https://github.com/krb5/krb5/commit/e04f0283516e80d2f93366e0d479d13c9b5c8c2a,e04f0283516e80d2f93366e0d479d13c9b5c8c2a,"Fix IAKERB context aliasing bugs [CVE-2015-2696]

The IAKERB mechanism currently replaces its context handle with the
krb5 mechanism handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the IAKERB context structure after context
establishment and add new IAKERB entry points to refer to it with that
type.  Add initiate and established flags to the IAKERB context
structure for use in gss_inquire_context() prior to context
establishment.

CVE-2015-2696:

In MIT krb5 1.9 and later, applications which call
gss_inquire_context() on a partially-established IAKERB context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  Java server applications using the
native JGSS provider are vulnerable to this bug.  A carefully crafted
IAKERB packet might allow the gss_inquire_context() call to succeed
with attacker-determined results, but applications should not make
access control decisions based on gss_inquire_context() results prior
to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",6,src/lib/gssapi/krb5/iakerb.c,"{""sha"": ""97e090d099f3672e9fe67c969c1615dc0710922c"", ""filename"": ""src/lib/gssapi/krb5/gssapiP_krb5.h"", ""status"": ""modified"", ""additions"": 114, ""deletions"": 0, ""changes"": 114, ""blob_url"": ""https://github.com/krb5/krb5/blob/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/gssapiP_krb5.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/gssapiP_krb5.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/krb5/gssapiP_krb5.h?ref=e04f0283516e80d2f93366e0d479d13c9b5c8c2a"", ""patch"": ""@@ -621,6 +621,21 @@ OM_uint32 KRB5_CALLCONV krb5_gss_accept_sec_context_ext\n );\n #endif /* LEAN_CLIENT */\n \n+OM_uint32 KRB5_CALLCONV krb5_gss_inquire_sec_context_by_oid\n+(OM_uint32*,       /* minor_status */\n+ const gss_ctx_id_t,\n+ /* context_handle */\n+ const gss_OID,    /* desired_object */\n+ gss_buffer_set_t* /* data_set */\n+);\n+\n+OM_uint32 KRB5_CALLCONV krb5_gss_set_sec_context_option\n+(OM_uint32*,       /* minor_status */\n+ gss_ctx_id_t*,    /* context_handle */\n+ const gss_OID,    /* desired_object */\n+ const gss_buffer_t/* value */\n+);\n+\n OM_uint32 KRB5_CALLCONV krb5_gss_process_context_token\n (OM_uint32*,       /* minor_status */\n  gss_ctx_id_t,     /* context_handle */\n@@ -1302,6 +1317,105 @@ OM_uint32 KRB5_CALLCONV\n krb5_gss_import_cred(OM_uint32 *minor_status, gss_buffer_t token,\n                      gss_cred_id_t *cred_handle);\n \n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_process_context_token(OM_uint32 *minor_status,\n+                                 const gss_ctx_id_t context_handle,\n+                                 const gss_buffer_t token_buffer);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_context_time(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                        OM_uint32 *time_rec);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_inquire_context(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, gss_name_t *src_name,\n+                           gss_name_t *targ_name, OM_uint32 *lifetime_rec,\n+                           gss_OID *mech_type, OM_uint32 *ctx_flags,\n+                           int *locally_initiated, int *opened);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                   gss_qop_t qop_req, gss_buffer_t message_buffer,\n+                   gss_buffer_t message_token);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n+                       int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic_iov_length(OM_uint32 *minor_status,\n+                              gss_ctx_id_t context_handle, gss_qop_t qop_req,\n+                              gss_iov_buffer_desc *iov, int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_verify_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                      gss_buffer_t msg_buffer, gss_buffer_t token_buffer,\n+                      gss_qop_t *qop_state);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                          gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n+                          int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                int conf_req_flag, gss_qop_t qop_req,\n+                gss_buffer_t input_message_buffer, int *conf_state,\n+                gss_buffer_t output_message_buffer);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                    int conf_req_flag, gss_qop_t qop_req, int *conf_state,\n+                    gss_iov_buffer_desc *iov, int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_iov_length(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, int conf_req_flag,\n+                           gss_qop_t qop_req, int *conf_state,\n+                           gss_iov_buffer_desc *iov, int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_unwrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                  gss_buffer_t input_message_buffer,\n+                  gss_buffer_t output_message_buffer, int *conf_state,\n+                  gss_qop_t *qop_state);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_unwrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                      int *conf_state, gss_qop_t *qop_state,\n+                      gss_iov_buffer_desc *iov, int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_size_limit(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, int conf_req_flag,\n+                           gss_qop_t qop_req, OM_uint32 req_output_size,\n+                           OM_uint32 *max_input_size);\n+\n+#ifndef LEAN_CLIENT\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n+                              gss_ctx_id_t *context_handle,\n+                              gss_buffer_t interprocess_token);\n+#endif /* LEAN_CLIENT */\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_inquire_sec_context_by_oid(OM_uint32 *minor_status,\n+                                      const gss_ctx_id_t context_handle,\n+                                      const gss_OID desired_object,\n+                                      gss_buffer_set_t *data_set);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_set_sec_context_option(OM_uint32 *minor_status,\n+                                  gss_ctx_id_t *context_handle,\n+                                  const gss_OID desired_object,\n+                                  const gss_buffer_t value);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_pseudo_random(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                         int prf_key, const gss_buffer_t prf_in,\n+                         ssize_t desired_output_len, gss_buffer_t prf_out);\n+\n /* Magic string to identify exported krb5 GSS credentials.  Increment this if\n  * the format changes. */\n #define CRED_EXPORT_MAGIC \""K5C1\""""}<_**next**_>{""sha"": ""c4dfdd6fbd1338c6ad8bb2a395fff7cafa8de82b"", ""filename"": ""src/lib/gssapi/krb5/gssapi_krb5.c"", ""status"": ""modified"", ""additions"": 94, ""deletions"": 11, ""changes"": 105, ""blob_url"": ""https://github.com/krb5/krb5/blob/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/gssapi_krb5.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/gssapi_krb5.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/krb5/gssapi_krb5.c?ref=e04f0283516e80d2f93366e0d479d13c9b5c8c2a"", ""patch"": ""@@ -351,7 +351,7 @@ static struct {\n     }\n };\n \n-static OM_uint32 KRB5_CALLCONV\n+OM_uint32 KRB5_CALLCONV\n krb5_gss_inquire_sec_context_by_oid (OM_uint32 *minor_status,\n                                      const gss_ctx_id_t context_handle,\n                                      const gss_OID desired_object,\n@@ -465,7 +465,7 @@ static struct {\n };\n #endif\n \n-static OM_uint32 KRB5_CALLCONV\n+OM_uint32 KRB5_CALLCONV\n krb5_gss_set_sec_context_option (OM_uint32 *minor_status,\n                                  gss_ctx_id_t *context_handle,\n                                  const gss_OID desired_object,\n@@ -929,20 +929,103 @@ static struct gss_config krb5_mechanism = {\n     krb5_gss_get_mic_iov_length,\n };\n \n+/* Functions which use security contexts or acquire creds are IAKERB-specific;\n+ * other functions can borrow from the krb5 mech. */\n+static struct gss_config iakerb_mechanism = {\n+    { GSS_MECH_KRB5_OID_LENGTH, GSS_MECH_KRB5_OID },\n+    NULL,\n+    iakerb_gss_acquire_cred,\n+    krb5_gss_release_cred,\n+    iakerb_gss_init_sec_context,\n+#ifdef LEAN_CLIENT\n+    NULL,\n+#else\n+    iakerb_gss_accept_sec_context,\n+#endif\n+    iakerb_gss_process_context_token,\n+    iakerb_gss_delete_sec_context,\n+    iakerb_gss_context_time,\n+    iakerb_gss_get_mic,\n+    iakerb_gss_verify_mic,\n+#if defined(IOV_SHIM_EXERCISE_WRAP) || defined(IOV_SHIM_EXERCISE)\n+    NULL,\n+#else\n+    iakerb_gss_wrap,\n+#endif\n+#if defined(IOV_SHIM_EXERCISE_UNWRAP) || defined(IOV_SHIM_EXERCISE)\n+    NULL,\n+#else\n+    iakerb_gss_unwrap,\n+#endif\n+    krb5_gss_display_status,\n+    krb5_gss_indicate_mechs,\n+    krb5_gss_compare_name,\n+    krb5_gss_display_name,\n+    krb5_gss_import_name,\n+    krb5_gss_release_name,\n+    krb5_gss_inquire_cred,\n+    NULL,                /* add_cred */\n+#ifdef LEAN_CLIENT\n+    NULL,\n+    NULL,\n+#else\n+    iakerb_gss_export_sec_context,\n+    NULL,\n+#endif\n+    krb5_gss_inquire_cred_by_mech,\n+    krb5_gss_inquire_names_for_mech,\n+    iakerb_gss_inquire_context,\n+    krb5_gss_internal_release_oid,\n+    iakerb_gss_wrap_size_limit,\n+    krb5_gss_localname,\n+    krb5_gss_authorize_localname,\n+    krb5_gss_export_name,\n+    krb5_gss_duplicate_name,\n+    krb5_gss_store_cred,\n+    iakerb_gss_inquire_sec_context_by_oid,\n+    krb5_gss_inquire_cred_by_oid,\n+    iakerb_gss_set_sec_context_option,\n+    krb5_gssspi_set_cred_option,\n+    krb5_gssspi_mech_invoke,\n+    NULL,                /* wrap_aead */\n+    NULL,                /* unwrap_aead */\n+    iakerb_gss_wrap_iov,\n+    iakerb_gss_unwrap_iov,\n+    iakerb_gss_wrap_iov_length,\n+    NULL,               /* complete_auth_token */\n+    NULL,               /* acquire_cred_impersonate_name */\n+    NULL,               /* add_cred_impersonate_name */\n+    NULL,               /* display_name_ext */\n+    krb5_gss_inquire_name,\n+    krb5_gss_get_name_attribute,\n+    krb5_gss_set_name_attribute,\n+    krb5_gss_delete_name_attribute,\n+    krb5_gss_export_name_composite,\n+    krb5_gss_map_name_to_any,\n+    krb5_gss_release_any_name_mapping,\n+    iakerb_gss_pseudo_random,\n+    NULL,               /* set_neg_mechs */\n+    krb5_gss_inquire_saslname_for_mech,\n+    krb5_gss_inquire_mech_for_saslname,\n+    krb5_gss_inquire_attrs_for_mech,\n+    krb5_gss_acquire_cred_from,\n+    krb5_gss_store_cred_into,\n+    iakerb_gss_acquire_cred_with_password,\n+    krb5_gss_export_cred,\n+    krb5_gss_import_cred,\n+    NULL,               /* import_sec_context_by_mech */\n+    NULL,               /* import_name_by_mech */\n+    NULL,               /* import_cred_by_mech */\n+    iakerb_gss_get_mic_iov,\n+    iakerb_gss_verify_mic_iov,\n+    iakerb_gss_get_mic_iov_length,\n+};\n+\n #ifdef _GSS_STATIC_LINK\n #include \""mglueP.h\""\n static int gss_iakerbmechglue_init(void)\n {\n     struct gss_mech_config mech_iakerb;\n-    struct gss_config iakerb_mechanism = krb5_mechanism;\n-\n-    /* IAKERB mechanism mirrors krb5, but with different context SPIs */\n-    iakerb_mechanism.gss_accept_sec_context = iakerb_gss_accept_sec_context;\n-    iakerb_mechanism.gss_init_sec_context   = iakerb_gss_init_sec_context;\n-    iakerb_mechanism.gss_delete_sec_context = iakerb_gss_delete_sec_context;\n-    iakerb_mechanism.gss_acquire_cred       = iakerb_gss_acquire_cred;\n-    iakerb_mechanism.gssspi_acquire_cred_with_password\n-                                    = iakerb_gss_acquire_cred_with_password;\n \n     memset(&mech_iakerb, 0, sizeof(mech_iakerb));\n     mech_iakerb.mech = &iakerb_mechanism;""}<_**next**_>{""sha"": ""4662bd9fe382fdde657abaa6db06fa47ad69d8b7"", ""filename"": ""src/lib/gssapi/krb5/iakerb.c"", ""status"": ""modified"", ""additions"": 321, ""deletions"": 30, ""changes"": 351, ""blob_url"": ""https://github.com/krb5/krb5/blob/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/iakerb.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/iakerb.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/krb5/iakerb.c?ref=e04f0283516e80d2f93366e0d479d13c9b5c8c2a"", ""patch"": ""@@ -47,6 +47,8 @@ struct _iakerb_ctx_id_rec {\n     gss_ctx_id_t gssc;\n     krb5_data conv;                     /* conversation for checksumming */\n     unsigned int count;                 /* number of round trips */\n+    int initiate;\n+    int established;\n     krb5_get_init_creds_opt *gic_opts;\n };\n \n@@ -695,7 +697,7 @@ iakerb_get_initial_state(iakerb_ctx_id_t ctx,\n  * Allocate and initialise an IAKERB context\n  */\n static krb5_error_code\n-iakerb_alloc_context(iakerb_ctx_id_t *pctx)\n+iakerb_alloc_context(iakerb_ctx_id_t *pctx, int initiate)\n {\n     iakerb_ctx_id_t ctx;\n     krb5_error_code code;\n@@ -709,6 +711,8 @@ iakerb_alloc_context(iakerb_ctx_id_t *pctx)\n     ctx->magic = KG_IAKERB_CONTEXT;\n     ctx->state = IAKERB_AS_REQ;\n     ctx->count = 0;\n+    ctx->initiate = initiate;\n+    ctx->established = 0;\n \n     code = krb5_gss_init_context(&ctx->k5c);\n     if (code != 0)\n@@ -732,31 +736,18 @@ iakerb_gss_delete_sec_context(OM_uint32 *minor_status,\n                               gss_ctx_id_t *context_handle,\n                               gss_buffer_t output_token)\n {\n-    OM_uint32 major_status = GSS_S_COMPLETE;\n+    iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n \n     if (output_token != GSS_C_NO_BUFFER) {\n         output_token->length = 0;\n         output_token->value = NULL;\n     }\n \n     *minor_status = 0;\n+    *context_handle = GSS_C_NO_CONTEXT;\n+    iakerb_release_context(iakerb_ctx);\n \n-    if (*context_handle != GSS_C_NO_CONTEXT) {\n-        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n-\n-        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {\n-            iakerb_release_context(iakerb_ctx);\n-            *context_handle = GSS_C_NO_CONTEXT;\n-        } else {\n-            assert(iakerb_ctx->magic == KG_CONTEXT);\n-\n-            major_status = krb5_gss_delete_sec_context(minor_status,\n-                                                       context_handle,\n-                                                       output_token);\n-        }\n-    }\n-\n-    return major_status;\n+    return GSS_S_COMPLETE;\n }\n \n static krb5_boolean\n@@ -802,7 +793,7 @@ iakerb_gss_accept_sec_context(OM_uint32 *minor_status,\n     int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);\n \n     if (initialContextToken) {\n-        code = iakerb_alloc_context(&ctx);\n+        code = iakerb_alloc_context(&ctx, 0);\n         if (code != 0)\n             goto cleanup;\n \n@@ -854,11 +845,8 @@ iakerb_gss_accept_sec_context(OM_uint32 *minor_status,\n                                                        time_rec,\n                                                        delegated_cred_handle,\n                                                        &exts);\n-        if (major_status == GSS_S_COMPLETE) {\n-            *context_handle = ctx->gssc;\n-            ctx->gssc = NULL;\n-            iakerb_release_context(ctx);\n-        }\n+        if (major_status == GSS_S_COMPLETE)\n+            ctx->established = 1;\n         if (mech_type != NULL)\n             *mech_type = (gss_OID)gss_mech_krb5;\n     }\n@@ -897,7 +885,7 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,\n     int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);\n \n     if (initialContextToken) {\n-        code = iakerb_alloc_context(&ctx);\n+        code = iakerb_alloc_context(&ctx, 1);\n         if (code != 0) {\n             *minor_status = code;\n             goto cleanup;\n@@ -983,11 +971,8 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,\n                                                      ret_flags,\n                                                      time_rec,\n                                                      &exts);\n-        if (major_status == GSS_S_COMPLETE) {\n-            *context_handle = ctx->gssc;\n-            ctx->gssc = GSS_C_NO_CONTEXT;\n-            iakerb_release_context(ctx);\n-        }\n+        if (major_status == GSS_S_COMPLETE)\n+            ctx->established = 1;\n         if (actual_mech_type != NULL)\n             *actual_mech_type = (gss_OID)gss_mech_krb5;\n     } else {\n@@ -1010,3 +995,309 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,\n \n     return major_status;\n }\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_unwrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                  gss_buffer_t input_message_buffer,\n+                  gss_buffer_t output_message_buffer, int *conf_state,\n+                  gss_qop_t *qop_state)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_unwrap(minor_status, ctx->gssc, input_message_buffer,\n+                           output_message_buffer, conf_state, qop_state);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                int conf_req_flag, gss_qop_t qop_req,\n+                gss_buffer_t input_message_buffer, int *conf_state,\n+                gss_buffer_t output_message_buffer)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_wrap(minor_status, ctx->gssc, conf_req_flag, qop_req,\n+                         input_message_buffer, conf_state,\n+                         output_message_buffer);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_process_context_token(OM_uint32 *minor_status,\n+                                 const gss_ctx_id_t context_handle,\n+                                 const gss_buffer_t token_buffer)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_DEFECTIVE_TOKEN;\n+\n+    return krb5_gss_process_context_token(minor_status, ctx->gssc,\n+                                          token_buffer);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_context_time(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                        OM_uint32 *time_rec)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_context_time(minor_status, ctx->gssc, time_rec);\n+}\n+\n+#ifndef LEAN_CLIENT\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n+                              gss_ctx_id_t *context_handle,\n+                              gss_buffer_t interprocess_token)\n+{\n+    OM_uint32 maj;\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    /* We don't currently support exporting partially established contexts. */\n+    if (!ctx->established)\n+        return GSS_S_UNAVAILABLE;\n+\n+    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,\n+                                      interprocess_token);\n+    if (ctx->gssc == GSS_C_NO_CONTEXT) {\n+        iakerb_release_context(ctx);\n+        *context_handle = GSS_C_NO_CONTEXT;\n+    }\n+    return maj;\n+}\n+\n+/*\n+ * Until we implement partial context exports, there are no SPNEGO exported\n+ * context tokens, only tokens for the underlying krb5 context.  So we do not\n+ * need to implement an iakerb_gss_import_sec_context() yet; it would be\n+ * unreachable except via a manually constructed token.\n+ */\n+\n+#endif /* LEAN_CLIENT */\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_inquire_context(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, gss_name_t *src_name,\n+                           gss_name_t *targ_name, OM_uint32 *lifetime_rec,\n+                           gss_OID *mech_type, OM_uint32 *ctx_flags,\n+                           int *initiate, int *opened)\n+{\n+    OM_uint32 ret;\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (src_name != NULL)\n+        *src_name = GSS_C_NO_NAME;\n+    if (targ_name != NULL)\n+        *targ_name = GSS_C_NO_NAME;\n+    if (lifetime_rec != NULL)\n+        *lifetime_rec = 0;\n+    if (mech_type != NULL)\n+        *mech_type = (gss_OID)gss_mech_iakerb;\n+    if (ctx_flags != NULL)\n+        *ctx_flags = 0;\n+    if (initiate != NULL)\n+        *initiate = ctx->initiate;\n+    if (opened != NULL)\n+        *opened = ctx->established;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_COMPLETE;\n+\n+    ret = krb5_gss_inquire_context(minor_status, ctx->gssc, src_name,\n+                                   targ_name, lifetime_rec, mech_type,\n+                                   ctx_flags, initiate, opened);\n+\n+    if (!ctx->established) {\n+        /* Report IAKERB as the mech OID until the context is established. */\n+        if (mech_type != NULL)\n+            *mech_type = (gss_OID)gss_mech_iakerb;\n+\n+        /* We don't support exporting partially-established contexts. */\n+        if (ctx_flags != NULL)\n+            *ctx_flags &= ~GSS_C_TRANS_FLAG;\n+    }\n+\n+    return ret;\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_size_limit(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, int conf_req_flag,\n+                           gss_qop_t qop_req, OM_uint32 req_output_size,\n+                           OM_uint32 *max_input_size)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_wrap_size_limit(minor_status, ctx->gssc, conf_req_flag,\n+                                    qop_req, req_output_size, max_input_size);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                   gss_qop_t qop_req, gss_buffer_t message_buffer,\n+                   gss_buffer_t message_token)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_get_mic(minor_status, ctx->gssc, qop_req, message_buffer,\n+                            message_token);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_verify_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                      gss_buffer_t msg_buffer, gss_buffer_t token_buffer,\n+                      gss_qop_t *qop_state)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_verify_mic(minor_status, ctx->gssc, msg_buffer,\n+                               token_buffer, qop_state);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_inquire_sec_context_by_oid(OM_uint32 *minor_status,\n+                                      const gss_ctx_id_t context_handle,\n+                                      const gss_OID desired_object,\n+                                      gss_buffer_set_t *data_set)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_UNAVAILABLE;\n+\n+    return krb5_gss_inquire_sec_context_by_oid(minor_status, ctx->gssc,\n+                                               desired_object, data_set);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_set_sec_context_option(OM_uint32 *minor_status,\n+                                  gss_ctx_id_t *context_handle,\n+                                  const gss_OID desired_object,\n+                                  const gss_buffer_t value)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)*context_handle;\n+\n+    if (ctx == NULL || ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_UNAVAILABLE;\n+\n+    return krb5_gss_set_sec_context_option(minor_status, &ctx->gssc,\n+                                           desired_object, value);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                    int conf_req_flag, gss_qop_t qop_req, int *conf_state,\n+                    gss_iov_buffer_desc *iov, int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_wrap_iov(minor_status, ctx->gssc, conf_req_flag, qop_req,\n+                             conf_state, iov, iov_count);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_unwrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                      int *conf_state, gss_qop_t *qop_state,\n+                      gss_iov_buffer_desc *iov, int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_unwrap_iov(minor_status, ctx->gssc, conf_state, qop_state,\n+                               iov, iov_count);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_iov_length(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, int conf_req_flag,\n+                           gss_qop_t qop_req, int *conf_state,\n+                           gss_iov_buffer_desc *iov, int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_wrap_iov_length(minor_status, ctx->gssc, conf_req_flag,\n+                                    qop_req, conf_state, iov, iov_count);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_pseudo_random(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                         int prf_key, const gss_buffer_t prf_in,\n+                         ssize_t desired_output_len, gss_buffer_t prf_out)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_pseudo_random(minor_status, ctx->gssc, prf_key, prf_in,\n+                                  desired_output_len, prf_out);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n+                       int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_get_mic_iov(minor_status, ctx->gssc, qop_req, iov,\n+                                iov_count);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                          gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n+                          int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_verify_mic_iov(minor_status, ctx->gssc, qop_state, iov,\n+                                   iov_count);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic_iov_length(OM_uint32 *minor_status,\n+                              gss_ctx_id_t context_handle, gss_qop_t qop_req,\n+                              gss_iov_buffer_desc *iov, int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_get_mic_iov_length(minor_status, ctx->gssc, qop_req, iov,\n+                                       iov_count);\n+}""}","iakerb_gss_accept_sec_context(OM_uint32 *minor_status,
                              gss_ctx_id_t *context_handle,
                              gss_cred_id_t verifier_cred_handle,
                              gss_buffer_t input_token,
                              gss_channel_bindings_t input_chan_bindings,
                              gss_name_t *src_name,
                              gss_OID *mech_type,
                              gss_buffer_t output_token,
                              OM_uint32 *ret_flags,
                              OM_uint32 *time_rec,
                              gss_cred_id_t *delegated_cred_handle)
{
    OM_uint32 major_status = GSS_S_FAILURE;
    OM_uint32 code;
    iakerb_ctx_id_t ctx;
     int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);
 
     if (initialContextToken) {
        code = iakerb_alloc_context(&ctx, 0);
         if (code != 0)
             goto cleanup;
 
    } else
        ctx = (iakerb_ctx_id_t)*context_handle;

    if (iakerb_is_iakerb_token(input_token)) {
        if (ctx->gssc != GSS_C_NO_CONTEXT) {
            /* We shouldn't get an IAKERB token now. */
            code = G_WRONG_TOKID;
            major_status = GSS_S_DEFECTIVE_TOKEN;
            goto cleanup;
        }
        code = iakerb_acceptor_step(ctx, initialContextToken,
                                    input_token, output_token);
        if (code == (OM_uint32)KRB5_BAD_MSIZE)
            major_status = GSS_S_DEFECTIVE_TOKEN;
        if (code != 0)
            goto cleanup;
        if (initialContextToken) {
            *context_handle = (gss_ctx_id_t)ctx;
            ctx = NULL;
        }
        if (src_name != NULL)
            *src_name = GSS_C_NO_NAME;
        if (mech_type != NULL)
            *mech_type = (gss_OID)gss_mech_iakerb;
        if (ret_flags != NULL)
            *ret_flags = 0;
        if (time_rec != NULL)
            *time_rec = 0;
        if (delegated_cred_handle != NULL)
            *delegated_cred_handle = GSS_C_NO_CREDENTIAL;
        major_status = GSS_S_CONTINUE_NEEDED;
    } else {
        krb5_gss_ctx_ext_rec exts;

        iakerb_make_exts(ctx, &exts);

        major_status = krb5_gss_accept_sec_context_ext(&code,
                                                       &ctx->gssc,
                                                       verifier_cred_handle,
                                                       input_token,
                                                       input_chan_bindings,
                                                       src_name,
                                                       NULL,
                                                       output_token,
                                                       ret_flags,
                                                        time_rec,
                                                        delegated_cred_handle,
                                                        &exts);
        if (major_status == GSS_S_COMPLETE)
            ctx->established = 1;
         if (mech_type != NULL)
             *mech_type = (gss_OID)gss_mech_krb5;
     }

cleanup:
    if (initialContextToken && GSS_ERROR(major_status)) {
        iakerb_release_context(ctx);
        *context_handle = GSS_C_NO_CONTEXT;
    }

    *minor_status = code;
    return major_status;
}
","iakerb_gss_accept_sec_context(OM_uint32 *minor_status,
                              gss_ctx_id_t *context_handle,
                              gss_cred_id_t verifier_cred_handle,
                              gss_buffer_t input_token,
                              gss_channel_bindings_t input_chan_bindings,
                              gss_name_t *src_name,
                              gss_OID *mech_type,
                              gss_buffer_t output_token,
                              OM_uint32 *ret_flags,
                              OM_uint32 *time_rec,
                              gss_cred_id_t *delegated_cred_handle)
{
    OM_uint32 major_status = GSS_S_FAILURE;
    OM_uint32 code;
    iakerb_ctx_id_t ctx;
     int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);
 
     if (initialContextToken) {
        code = iakerb_alloc_context(&ctx);
         if (code != 0)
             goto cleanup;
 
    } else
        ctx = (iakerb_ctx_id_t)*context_handle;

    if (iakerb_is_iakerb_token(input_token)) {
        if (ctx->gssc != GSS_C_NO_CONTEXT) {
            /* We shouldn't get an IAKERB token now. */
            code = G_WRONG_TOKID;
            major_status = GSS_S_DEFECTIVE_TOKEN;
            goto cleanup;
        }
        code = iakerb_acceptor_step(ctx, initialContextToken,
                                    input_token, output_token);
        if (code == (OM_uint32)KRB5_BAD_MSIZE)
            major_status = GSS_S_DEFECTIVE_TOKEN;
        if (code != 0)
            goto cleanup;
        if (initialContextToken) {
            *context_handle = (gss_ctx_id_t)ctx;
            ctx = NULL;
        }
        if (src_name != NULL)
            *src_name = GSS_C_NO_NAME;
        if (mech_type != NULL)
            *mech_type = (gss_OID)gss_mech_iakerb;
        if (ret_flags != NULL)
            *ret_flags = 0;
        if (time_rec != NULL)
            *time_rec = 0;
        if (delegated_cred_handle != NULL)
            *delegated_cred_handle = GSS_C_NO_CREDENTIAL;
        major_status = GSS_S_CONTINUE_NEEDED;
    } else {
        krb5_gss_ctx_ext_rec exts;

        iakerb_make_exts(ctx, &exts);

        major_status = krb5_gss_accept_sec_context_ext(&code,
                                                       &ctx->gssc,
                                                       verifier_cred_handle,
                                                       input_token,
                                                       input_chan_bindings,
                                                       src_name,
                                                       NULL,
                                                       output_token,
                                                       ret_flags,
                                                        time_rec,
                                                        delegated_cred_handle,
                                                        &exts);
        if (major_status == GSS_S_COMPLETE) {
            *context_handle = ctx->gssc;
            ctx->gssc = NULL;
            iakerb_release_context(ctx);
        }
         if (mech_type != NULL)
             *mech_type = (gss_OID)gss_mech_krb5;
     }

cleanup:
    if (initialContextToken && GSS_ERROR(major_status)) {
        iakerb_release_context(ctx);
        *context_handle = GSS_C_NO_CONTEXT;
    }

    *minor_status = code;
    return major_status;
}
",C,"        code = iakerb_alloc_context(&ctx, 0);
        if (major_status == GSS_S_COMPLETE)
            ctx->established = 1;
","        code = iakerb_alloc_context(&ctx);
        if (major_status == GSS_S_COMPLETE) {
            *context_handle = ctx->gssc;
            ctx->gssc = NULL;
            iakerb_release_context(ctx);
        }
",,"@@ -47,6 +47,8 @@ struct _iakerb_ctx_id_rec {
     gss_ctx_id_t gssc;
     krb5_data conv;                     /* conversation for checksumming */
     unsigned int count;                 /* number of round trips */
+    int initiate;
+    int established;
     krb5_get_init_creds_opt *gic_opts;
 };
 
@@ -695,7 +697,7 @@ iakerb_get_initial_state(iakerb_ctx_id_t ctx,
  * Allocate and initialise an IAKERB context
  */
 static krb5_error_code
-iakerb_alloc_context(iakerb_ctx_id_t *pctx)
+iakerb_alloc_context(iakerb_ctx_id_t *pctx, int initiate)
 {
     iakerb_ctx_id_t ctx;
     krb5_error_code code;
@@ -709,6 +711,8 @@ iakerb_alloc_context(iakerb_ctx_id_t *pctx)
     ctx->magic = KG_IAKERB_CONTEXT;
     ctx->state = IAKERB_AS_REQ;
     ctx->count = 0;
+    ctx->initiate = initiate;
+    ctx->established = 0;
 
     code = krb5_gss_init_context(&ctx->k5c);
     if (code != 0)
@@ -732,31 +736,18 @@ iakerb_gss_delete_sec_context(OM_uint32 *minor_status,
                               gss_ctx_id_t *context_handle,
                               gss_buffer_t output_token)
 {
-    OM_uint32 major_status = GSS_S_COMPLETE;
+    iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;
 
     if (output_token != GSS_C_NO_BUFFER) {
         output_token->length = 0;
         output_token->value = NULL;
     }
 
     *minor_status = 0;
+    *context_handle = GSS_C_NO_CONTEXT;
+    iakerb_release_context(iakerb_ctx);
 
-    if (*context_handle != GSS_C_NO_CONTEXT) {
-        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;
-
-        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {
-            iakerb_release_context(iakerb_ctx);
-            *context_handle = GSS_C_NO_CONTEXT;
-        } else {
-            assert(iakerb_ctx->magic == KG_CONTEXT);
-
-            major_status = krb5_gss_delete_sec_context(minor_status,
-                                                       context_handle,
-                                                       output_token);
-        }
-    }
-
-    return major_status;
+    return GSS_S_COMPLETE;
 }
 
 static krb5_boolean
@@ -802,7 +793,7 @@ iakerb_gss_accept_sec_context(OM_uint32 *minor_status,
     int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);
 
     if (initialContextToken) {
-        code = iakerb_alloc_context(&ctx);
+        code = iakerb_alloc_context(&ctx, 0);
         if (code != 0)
             goto cleanup;
 
@@ -854,11 +845,8 @@ iakerb_gss_accept_sec_context(OM_uint32 *minor_status,
                                                        time_rec,
                                                        delegated_cred_handle,
                                                        &exts);
-        if (major_status == GSS_S_COMPLETE) {
-            *context_handle = ctx->gssc;
-            ctx->gssc = NULL;
-            iakerb_release_context(ctx);
-        }
+        if (major_status == GSS_S_COMPLETE)
+            ctx->established = 1;
         if (mech_type != NULL)
             *mech_type = (gss_OID)gss_mech_krb5;
     }
@@ -897,7 +885,7 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,
     int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);
 
     if (initialContextToken) {
-        code = iakerb_alloc_context(&ctx);
+        code = iakerb_alloc_context(&ctx, 1);
         if (code != 0) {
             *minor_status = code;
             goto cleanup;
@@ -983,11 +971,8 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,
                                                      ret_flags,
                                                      time_rec,
                                                      &exts);
-        if (major_status == GSS_S_COMPLETE) {
-            *context_handle = ctx->gssc;
-            ctx->gssc = GSS_C_NO_CONTEXT;
-            iakerb_release_context(ctx);
-        }
+        if (major_status == GSS_S_COMPLETE)
+            ctx->established = 1;
         if (actual_mech_type != NULL)
             *actual_mech_type = (gss_OID)gss_mech_krb5;
     } else {
@@ -1010,3 +995,309 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,
 
     return major_status;
 }
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_unwrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                  gss_buffer_t input_message_buffer,
+                  gss_buffer_t output_message_buffer, int *conf_state,
+                  gss_qop_t *qop_state)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_unwrap(minor_status, ctx->gssc, input_message_buffer,
+                           output_message_buffer, conf_state, qop_state);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_wrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                int conf_req_flag, gss_qop_t qop_req,
+                gss_buffer_t input_message_buffer, int *conf_state,
+                gss_buffer_t output_message_buffer)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_wrap(minor_status, ctx->gssc, conf_req_flag, qop_req,
+                         input_message_buffer, conf_state,
+                         output_message_buffer);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_process_context_token(OM_uint32 *minor_status,
+                                 const gss_ctx_id_t context_handle,
+                                 const gss_buffer_t token_buffer)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_DEFECTIVE_TOKEN;
+
+    return krb5_gss_process_context_token(minor_status, ctx->gssc,
+                                          token_buffer);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_context_time(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                        OM_uint32 *time_rec)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_context_time(minor_status, ctx->gssc, time_rec);
+}
+
+#ifndef LEAN_CLIENT
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_export_sec_context(OM_uint32 *minor_status,
+                              gss_ctx_id_t *context_handle,
+                              gss_buffer_t interprocess_token)
+{
+    OM_uint32 maj;
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    /* We don't currently support exporting partially established contexts. */
+    if (!ctx->established)
+        return GSS_S_UNAVAILABLE;
+
+    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,
+                                      interprocess_token);
+    if (ctx->gssc == GSS_C_NO_CONTEXT) {
+        iakerb_release_context(ctx);
+        *context_handle = GSS_C_NO_CONTEXT;
+    }
+    return maj;
+}
+
+/*
+ * Until we implement partial context exports, there are no SPNEGO exported
+ * context tokens, only tokens for the underlying krb5 context.  So we do not
+ * need to implement an iakerb_gss_import_sec_context() yet; it would be
+ * unreachable except via a manually constructed token.
+ */
+
+#endif /* LEAN_CLIENT */
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_inquire_context(OM_uint32 *minor_status,
+                           gss_ctx_id_t context_handle, gss_name_t *src_name,
+                           gss_name_t *targ_name, OM_uint32 *lifetime_rec,
+                           gss_OID *mech_type, OM_uint32 *ctx_flags,
+                           int *initiate, int *opened)
+{
+    OM_uint32 ret;
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (src_name != NULL)
+        *src_name = GSS_C_NO_NAME;
+    if (targ_name != NULL)
+        *targ_name = GSS_C_NO_NAME;
+    if (lifetime_rec != NULL)
+        *lifetime_rec = 0;
+    if (mech_type != NULL)
+        *mech_type = (gss_OID)gss_mech_iakerb;
+    if (ctx_flags != NULL)
+        *ctx_flags = 0;
+    if (initiate != NULL)
+        *initiate = ctx->initiate;
+    if (opened != NULL)
+        *opened = ctx->established;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_COMPLETE;
+
+    ret = krb5_gss_inquire_context(minor_status, ctx->gssc, src_name,
+                                   targ_name, lifetime_rec, mech_type,
+                                   ctx_flags, initiate, opened);
+
+    if (!ctx->established) {
+        /* Report IAKERB as the mech OID until the context is established. */
+        if (mech_type != NULL)
+            *mech_type = (gss_OID)gss_mech_iakerb;
+
+        /* We don't support exporting partially-established contexts. */
+        if (ctx_flags != NULL)
+            *ctx_flags &= ~GSS_C_TRANS_FLAG;
+    }
+
+    return ret;
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_wrap_size_limit(OM_uint32 *minor_status,
+                           gss_ctx_id_t context_handle, int conf_req_flag,
+                           gss_qop_t qop_req, OM_uint32 req_output_size,
+                           OM_uint32 *max_input_size)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_wrap_size_limit(minor_status, ctx->gssc, conf_req_flag,
+                                    qop_req, req_output_size, max_input_size);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_get_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                   gss_qop_t qop_req, gss_buffer_t message_buffer,
+                   gss_buffer_t message_token)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_get_mic(minor_status, ctx->gssc, qop_req, message_buffer,
+                            message_token);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_verify_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                      gss_buffer_t msg_buffer, gss_buffer_t token_buffer,
+                      gss_qop_t *qop_state)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_verify_mic(minor_status, ctx->gssc, msg_buffer,
+                               token_buffer, qop_state);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_inquire_sec_context_by_oid(OM_uint32 *minor_status,
+                                      const gss_ctx_id_t context_handle,
+                                      const gss_OID desired_object,
+                                      gss_buffer_set_t *data_set)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_UNAVAILABLE;
+
+    return krb5_gss_inquire_sec_context_by_oid(minor_status, ctx->gssc,
+                                               desired_object, data_set);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_set_sec_context_option(OM_uint32 *minor_status,
+                                  gss_ctx_id_t *context_handle,
+                                  const gss_OID desired_object,
+                                  const gss_buffer_t value)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)*context_handle;
+
+    if (ctx == NULL || ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_UNAVAILABLE;
+
+    return krb5_gss_set_sec_context_option(minor_status, &ctx->gssc,
+                                           desired_object, value);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_wrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                    int conf_req_flag, gss_qop_t qop_req, int *conf_state,
+                    gss_iov_buffer_desc *iov, int iov_count)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_wrap_iov(minor_status, ctx->gssc, conf_req_flag, qop_req,
+                             conf_state, iov, iov_count);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_unwrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                      int *conf_state, gss_qop_t *qop_state,
+                      gss_iov_buffer_desc *iov, int iov_count)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_unwrap_iov(minor_status, ctx->gssc, conf_state, qop_state,
+                               iov, iov_count);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_wrap_iov_length(OM_uint32 *minor_status,
+                           gss_ctx_id_t context_handle, int conf_req_flag,
+                           gss_qop_t qop_req, int *conf_state,
+                           gss_iov_buffer_desc *iov, int iov_count)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_wrap_iov_length(minor_status, ctx->gssc, conf_req_flag,
+                                    qop_req, conf_state, iov, iov_count);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_pseudo_random(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                         int prf_key, const gss_buffer_t prf_in,
+                         ssize_t desired_output_len, gss_buffer_t prf_out)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_pseudo_random(minor_status, ctx->gssc, prf_key, prf_in,
+                                  desired_output_len, prf_out);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
+                       int iov_count)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_get_mic_iov(minor_status, ctx->gssc, qop_req, iov,
+                                iov_count);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                          gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
+                          int iov_count)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_verify_mic_iov(minor_status, ctx->gssc, qop_state, iov,
+                                   iov_count);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_get_mic_iov_length(OM_uint32 *minor_status,
+                              gss_ctx_id_t context_handle, gss_qop_t qop_req,
+                              gss_iov_buffer_desc *iov, int iov_count)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_get_mic_iov_length(minor_status, ctx->gssc, qop_req, iov,
+                                       iov_count);
+}",krb5,e04f0283516e80d2f93366e0d479d13c9b5c8c2a,b51b33f2bc5d1497ddf5bd107f791c101695000d,1,"iakerb_gss_accept_sec_context(OM_uint32 *minor_status,
                              gss_ctx_id_t *context_handle,
                              gss_cred_id_t verifier_cred_handle,
                              gss_buffer_t input_token,
                              gss_channel_bindings_t input_chan_bindings,
                              gss_name_t *src_name,
                              gss_OID *mech_type,
                              gss_buffer_t output_token,
                              OM_uint32 *ret_flags,
                              OM_uint32 *time_rec,
                              gss_cred_id_t *delegated_cred_handle)
{
    OM_uint32 major_status = GSS_S_FAILURE;
    OM_uint32 code;
    iakerb_ctx_id_t ctx;
     int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);
 
     if (initialContextToken) {
//flaw_line_below:
        code = iakerb_alloc_context(&ctx);
//fix_flaw_line_below:
//        code = iakerb_alloc_context(&ctx, 0);
         if (code != 0)
             goto cleanup;
 
    } else
        ctx = (iakerb_ctx_id_t)*context_handle;

    if (iakerb_is_iakerb_token(input_token)) {
        if (ctx->gssc != GSS_C_NO_CONTEXT) {
            /* We shouldn't get an IAKERB token now. */
            code = G_WRONG_TOKID;
            major_status = GSS_S_DEFECTIVE_TOKEN;
            goto cleanup;
        }
        code = iakerb_acceptor_step(ctx, initialContextToken,
                                    input_token, output_token);
        if (code == (OM_uint32)KRB5_BAD_MSIZE)
            major_status = GSS_S_DEFECTIVE_TOKEN;
        if (code != 0)
            goto cleanup;
        if (initialContextToken) {
            *context_handle = (gss_ctx_id_t)ctx;
            ctx = NULL;
        }
        if (src_name != NULL)
            *src_name = GSS_C_NO_NAME;
        if (mech_type != NULL)
            *mech_type = (gss_OID)gss_mech_iakerb;
        if (ret_flags != NULL)
            *ret_flags = 0;
        if (time_rec != NULL)
            *time_rec = 0;
        if (delegated_cred_handle != NULL)
            *delegated_cred_handle = GSS_C_NO_CREDENTIAL;
        major_status = GSS_S_CONTINUE_NEEDED;
    } else {
        krb5_gss_ctx_ext_rec exts;

        iakerb_make_exts(ctx, &exts);

        major_status = krb5_gss_accept_sec_context_ext(&code,
                                                       &ctx->gssc,
                                                       verifier_cred_handle,
                                                       input_token,
                                                       input_chan_bindings,
                                                       src_name,
                                                       NULL,
                                                       output_token,
                                                       ret_flags,
                                                        time_rec,
                                                        delegated_cred_handle,
                                                        &exts);
//flaw_line_below:
        if (major_status == GSS_S_COMPLETE) {
//flaw_line_below:
            *context_handle = ctx->gssc;
//flaw_line_below:
            ctx->gssc = NULL;
//flaw_line_below:
            iakerb_release_context(ctx);
//flaw_line_below:
        }
//fix_flaw_line_below:
//        if (major_status == GSS_S_COMPLETE)
//fix_flaw_line_below:
//            ctx->established = 1;
         if (mech_type != NULL)
             *mech_type = (gss_OID)gss_mech_krb5;
     }

cleanup:
    if (initialContextToken && GSS_ERROR(major_status)) {
        iakerb_release_context(ctx);
        *context_handle = GSS_C_NO_CONTEXT;
    }

    *minor_status = code;
    return major_status;
}
"
2081,179817,,Remote,Not required,Complete,CVE-2015-2696,https://www.cvedetails.com/cve/CVE-2015-2696/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/krb5/iakerb.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted IAKERB packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,4,https://github.com/krb5/krb5/commit/e04f0283516e80d2f93366e0d479d13c9b5c8c2a,e04f0283516e80d2f93366e0d479d13c9b5c8c2a,"Fix IAKERB context aliasing bugs [CVE-2015-2696]

The IAKERB mechanism currently replaces its context handle with the
krb5 mechanism handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the IAKERB context structure after context
establishment and add new IAKERB entry points to refer to it with that
type.  Add initiate and established flags to the IAKERB context
structure for use in gss_inquire_context() prior to context
establishment.

CVE-2015-2696:

In MIT krb5 1.9 and later, applications which call
gss_inquire_context() on a partially-established IAKERB context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  Java server applications using the
native JGSS provider are vulnerable to this bug.  A carefully crafted
IAKERB packet might allow the gss_inquire_context() call to succeed
with attacker-determined results, but applications should not make
access control decisions based on gss_inquire_context() results prior
to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",14,src/lib/gssapi/krb5/iakerb.c,"{""sha"": ""97e090d099f3672e9fe67c969c1615dc0710922c"", ""filename"": ""src/lib/gssapi/krb5/gssapiP_krb5.h"", ""status"": ""modified"", ""additions"": 114, ""deletions"": 0, ""changes"": 114, ""blob_url"": ""https://github.com/krb5/krb5/blob/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/gssapiP_krb5.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/gssapiP_krb5.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/krb5/gssapiP_krb5.h?ref=e04f0283516e80d2f93366e0d479d13c9b5c8c2a"", ""patch"": ""@@ -621,6 +621,21 @@ OM_uint32 KRB5_CALLCONV krb5_gss_accept_sec_context_ext\n );\n #endif /* LEAN_CLIENT */\n \n+OM_uint32 KRB5_CALLCONV krb5_gss_inquire_sec_context_by_oid\n+(OM_uint32*,       /* minor_status */\n+ const gss_ctx_id_t,\n+ /* context_handle */\n+ const gss_OID,    /* desired_object */\n+ gss_buffer_set_t* /* data_set */\n+);\n+\n+OM_uint32 KRB5_CALLCONV krb5_gss_set_sec_context_option\n+(OM_uint32*,       /* minor_status */\n+ gss_ctx_id_t*,    /* context_handle */\n+ const gss_OID,    /* desired_object */\n+ const gss_buffer_t/* value */\n+);\n+\n OM_uint32 KRB5_CALLCONV krb5_gss_process_context_token\n (OM_uint32*,       /* minor_status */\n  gss_ctx_id_t,     /* context_handle */\n@@ -1302,6 +1317,105 @@ OM_uint32 KRB5_CALLCONV\n krb5_gss_import_cred(OM_uint32 *minor_status, gss_buffer_t token,\n                      gss_cred_id_t *cred_handle);\n \n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_process_context_token(OM_uint32 *minor_status,\n+                                 const gss_ctx_id_t context_handle,\n+                                 const gss_buffer_t token_buffer);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_context_time(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                        OM_uint32 *time_rec);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_inquire_context(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, gss_name_t *src_name,\n+                           gss_name_t *targ_name, OM_uint32 *lifetime_rec,\n+                           gss_OID *mech_type, OM_uint32 *ctx_flags,\n+                           int *locally_initiated, int *opened);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                   gss_qop_t qop_req, gss_buffer_t message_buffer,\n+                   gss_buffer_t message_token);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n+                       int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic_iov_length(OM_uint32 *minor_status,\n+                              gss_ctx_id_t context_handle, gss_qop_t qop_req,\n+                              gss_iov_buffer_desc *iov, int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_verify_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                      gss_buffer_t msg_buffer, gss_buffer_t token_buffer,\n+                      gss_qop_t *qop_state);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                          gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n+                          int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                int conf_req_flag, gss_qop_t qop_req,\n+                gss_buffer_t input_message_buffer, int *conf_state,\n+                gss_buffer_t output_message_buffer);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                    int conf_req_flag, gss_qop_t qop_req, int *conf_state,\n+                    gss_iov_buffer_desc *iov, int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_iov_length(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, int conf_req_flag,\n+                           gss_qop_t qop_req, int *conf_state,\n+                           gss_iov_buffer_desc *iov, int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_unwrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                  gss_buffer_t input_message_buffer,\n+                  gss_buffer_t output_message_buffer, int *conf_state,\n+                  gss_qop_t *qop_state);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_unwrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                      int *conf_state, gss_qop_t *qop_state,\n+                      gss_iov_buffer_desc *iov, int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_size_limit(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, int conf_req_flag,\n+                           gss_qop_t qop_req, OM_uint32 req_output_size,\n+                           OM_uint32 *max_input_size);\n+\n+#ifndef LEAN_CLIENT\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n+                              gss_ctx_id_t *context_handle,\n+                              gss_buffer_t interprocess_token);\n+#endif /* LEAN_CLIENT */\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_inquire_sec_context_by_oid(OM_uint32 *minor_status,\n+                                      const gss_ctx_id_t context_handle,\n+                                      const gss_OID desired_object,\n+                                      gss_buffer_set_t *data_set);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_set_sec_context_option(OM_uint32 *minor_status,\n+                                  gss_ctx_id_t *context_handle,\n+                                  const gss_OID desired_object,\n+                                  const gss_buffer_t value);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_pseudo_random(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                         int prf_key, const gss_buffer_t prf_in,\n+                         ssize_t desired_output_len, gss_buffer_t prf_out);\n+\n /* Magic string to identify exported krb5 GSS credentials.  Increment this if\n  * the format changes. */\n #define CRED_EXPORT_MAGIC \""K5C1\""""}<_**next**_>{""sha"": ""c4dfdd6fbd1338c6ad8bb2a395fff7cafa8de82b"", ""filename"": ""src/lib/gssapi/krb5/gssapi_krb5.c"", ""status"": ""modified"", ""additions"": 94, ""deletions"": 11, ""changes"": 105, ""blob_url"": ""https://github.com/krb5/krb5/blob/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/gssapi_krb5.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/gssapi_krb5.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/krb5/gssapi_krb5.c?ref=e04f0283516e80d2f93366e0d479d13c9b5c8c2a"", ""patch"": ""@@ -351,7 +351,7 @@ static struct {\n     }\n };\n \n-static OM_uint32 KRB5_CALLCONV\n+OM_uint32 KRB5_CALLCONV\n krb5_gss_inquire_sec_context_by_oid (OM_uint32 *minor_status,\n                                      const gss_ctx_id_t context_handle,\n                                      const gss_OID desired_object,\n@@ -465,7 +465,7 @@ static struct {\n };\n #endif\n \n-static OM_uint32 KRB5_CALLCONV\n+OM_uint32 KRB5_CALLCONV\n krb5_gss_set_sec_context_option (OM_uint32 *minor_status,\n                                  gss_ctx_id_t *context_handle,\n                                  const gss_OID desired_object,\n@@ -929,20 +929,103 @@ static struct gss_config krb5_mechanism = {\n     krb5_gss_get_mic_iov_length,\n };\n \n+/* Functions which use security contexts or acquire creds are IAKERB-specific;\n+ * other functions can borrow from the krb5 mech. */\n+static struct gss_config iakerb_mechanism = {\n+    { GSS_MECH_KRB5_OID_LENGTH, GSS_MECH_KRB5_OID },\n+    NULL,\n+    iakerb_gss_acquire_cred,\n+    krb5_gss_release_cred,\n+    iakerb_gss_init_sec_context,\n+#ifdef LEAN_CLIENT\n+    NULL,\n+#else\n+    iakerb_gss_accept_sec_context,\n+#endif\n+    iakerb_gss_process_context_token,\n+    iakerb_gss_delete_sec_context,\n+    iakerb_gss_context_time,\n+    iakerb_gss_get_mic,\n+    iakerb_gss_verify_mic,\n+#if defined(IOV_SHIM_EXERCISE_WRAP) || defined(IOV_SHIM_EXERCISE)\n+    NULL,\n+#else\n+    iakerb_gss_wrap,\n+#endif\n+#if defined(IOV_SHIM_EXERCISE_UNWRAP) || defined(IOV_SHIM_EXERCISE)\n+    NULL,\n+#else\n+    iakerb_gss_unwrap,\n+#endif\n+    krb5_gss_display_status,\n+    krb5_gss_indicate_mechs,\n+    krb5_gss_compare_name,\n+    krb5_gss_display_name,\n+    krb5_gss_import_name,\n+    krb5_gss_release_name,\n+    krb5_gss_inquire_cred,\n+    NULL,                /* add_cred */\n+#ifdef LEAN_CLIENT\n+    NULL,\n+    NULL,\n+#else\n+    iakerb_gss_export_sec_context,\n+    NULL,\n+#endif\n+    krb5_gss_inquire_cred_by_mech,\n+    krb5_gss_inquire_names_for_mech,\n+    iakerb_gss_inquire_context,\n+    krb5_gss_internal_release_oid,\n+    iakerb_gss_wrap_size_limit,\n+    krb5_gss_localname,\n+    krb5_gss_authorize_localname,\n+    krb5_gss_export_name,\n+    krb5_gss_duplicate_name,\n+    krb5_gss_store_cred,\n+    iakerb_gss_inquire_sec_context_by_oid,\n+    krb5_gss_inquire_cred_by_oid,\n+    iakerb_gss_set_sec_context_option,\n+    krb5_gssspi_set_cred_option,\n+    krb5_gssspi_mech_invoke,\n+    NULL,                /* wrap_aead */\n+    NULL,                /* unwrap_aead */\n+    iakerb_gss_wrap_iov,\n+    iakerb_gss_unwrap_iov,\n+    iakerb_gss_wrap_iov_length,\n+    NULL,               /* complete_auth_token */\n+    NULL,               /* acquire_cred_impersonate_name */\n+    NULL,               /* add_cred_impersonate_name */\n+    NULL,               /* display_name_ext */\n+    krb5_gss_inquire_name,\n+    krb5_gss_get_name_attribute,\n+    krb5_gss_set_name_attribute,\n+    krb5_gss_delete_name_attribute,\n+    krb5_gss_export_name_composite,\n+    krb5_gss_map_name_to_any,\n+    krb5_gss_release_any_name_mapping,\n+    iakerb_gss_pseudo_random,\n+    NULL,               /* set_neg_mechs */\n+    krb5_gss_inquire_saslname_for_mech,\n+    krb5_gss_inquire_mech_for_saslname,\n+    krb5_gss_inquire_attrs_for_mech,\n+    krb5_gss_acquire_cred_from,\n+    krb5_gss_store_cred_into,\n+    iakerb_gss_acquire_cred_with_password,\n+    krb5_gss_export_cred,\n+    krb5_gss_import_cred,\n+    NULL,               /* import_sec_context_by_mech */\n+    NULL,               /* import_name_by_mech */\n+    NULL,               /* import_cred_by_mech */\n+    iakerb_gss_get_mic_iov,\n+    iakerb_gss_verify_mic_iov,\n+    iakerb_gss_get_mic_iov_length,\n+};\n+\n #ifdef _GSS_STATIC_LINK\n #include \""mglueP.h\""\n static int gss_iakerbmechglue_init(void)\n {\n     struct gss_mech_config mech_iakerb;\n-    struct gss_config iakerb_mechanism = krb5_mechanism;\n-\n-    /* IAKERB mechanism mirrors krb5, but with different context SPIs */\n-    iakerb_mechanism.gss_accept_sec_context = iakerb_gss_accept_sec_context;\n-    iakerb_mechanism.gss_init_sec_context   = iakerb_gss_init_sec_context;\n-    iakerb_mechanism.gss_delete_sec_context = iakerb_gss_delete_sec_context;\n-    iakerb_mechanism.gss_acquire_cred       = iakerb_gss_acquire_cred;\n-    iakerb_mechanism.gssspi_acquire_cred_with_password\n-                                    = iakerb_gss_acquire_cred_with_password;\n \n     memset(&mech_iakerb, 0, sizeof(mech_iakerb));\n     mech_iakerb.mech = &iakerb_mechanism;""}<_**next**_>{""sha"": ""4662bd9fe382fdde657abaa6db06fa47ad69d8b7"", ""filename"": ""src/lib/gssapi/krb5/iakerb.c"", ""status"": ""modified"", ""additions"": 321, ""deletions"": 30, ""changes"": 351, ""blob_url"": ""https://github.com/krb5/krb5/blob/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/iakerb.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/iakerb.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/krb5/iakerb.c?ref=e04f0283516e80d2f93366e0d479d13c9b5c8c2a"", ""patch"": ""@@ -47,6 +47,8 @@ struct _iakerb_ctx_id_rec {\n     gss_ctx_id_t gssc;\n     krb5_data conv;                     /* conversation for checksumming */\n     unsigned int count;                 /* number of round trips */\n+    int initiate;\n+    int established;\n     krb5_get_init_creds_opt *gic_opts;\n };\n \n@@ -695,7 +697,7 @@ iakerb_get_initial_state(iakerb_ctx_id_t ctx,\n  * Allocate and initialise an IAKERB context\n  */\n static krb5_error_code\n-iakerb_alloc_context(iakerb_ctx_id_t *pctx)\n+iakerb_alloc_context(iakerb_ctx_id_t *pctx, int initiate)\n {\n     iakerb_ctx_id_t ctx;\n     krb5_error_code code;\n@@ -709,6 +711,8 @@ iakerb_alloc_context(iakerb_ctx_id_t *pctx)\n     ctx->magic = KG_IAKERB_CONTEXT;\n     ctx->state = IAKERB_AS_REQ;\n     ctx->count = 0;\n+    ctx->initiate = initiate;\n+    ctx->established = 0;\n \n     code = krb5_gss_init_context(&ctx->k5c);\n     if (code != 0)\n@@ -732,31 +736,18 @@ iakerb_gss_delete_sec_context(OM_uint32 *minor_status,\n                               gss_ctx_id_t *context_handle,\n                               gss_buffer_t output_token)\n {\n-    OM_uint32 major_status = GSS_S_COMPLETE;\n+    iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n \n     if (output_token != GSS_C_NO_BUFFER) {\n         output_token->length = 0;\n         output_token->value = NULL;\n     }\n \n     *minor_status = 0;\n+    *context_handle = GSS_C_NO_CONTEXT;\n+    iakerb_release_context(iakerb_ctx);\n \n-    if (*context_handle != GSS_C_NO_CONTEXT) {\n-        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n-\n-        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {\n-            iakerb_release_context(iakerb_ctx);\n-            *context_handle = GSS_C_NO_CONTEXT;\n-        } else {\n-            assert(iakerb_ctx->magic == KG_CONTEXT);\n-\n-            major_status = krb5_gss_delete_sec_context(minor_status,\n-                                                       context_handle,\n-                                                       output_token);\n-        }\n-    }\n-\n-    return major_status;\n+    return GSS_S_COMPLETE;\n }\n \n static krb5_boolean\n@@ -802,7 +793,7 @@ iakerb_gss_accept_sec_context(OM_uint32 *minor_status,\n     int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);\n \n     if (initialContextToken) {\n-        code = iakerb_alloc_context(&ctx);\n+        code = iakerb_alloc_context(&ctx, 0);\n         if (code != 0)\n             goto cleanup;\n \n@@ -854,11 +845,8 @@ iakerb_gss_accept_sec_context(OM_uint32 *minor_status,\n                                                        time_rec,\n                                                        delegated_cred_handle,\n                                                        &exts);\n-        if (major_status == GSS_S_COMPLETE) {\n-            *context_handle = ctx->gssc;\n-            ctx->gssc = NULL;\n-            iakerb_release_context(ctx);\n-        }\n+        if (major_status == GSS_S_COMPLETE)\n+            ctx->established = 1;\n         if (mech_type != NULL)\n             *mech_type = (gss_OID)gss_mech_krb5;\n     }\n@@ -897,7 +885,7 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,\n     int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);\n \n     if (initialContextToken) {\n-        code = iakerb_alloc_context(&ctx);\n+        code = iakerb_alloc_context(&ctx, 1);\n         if (code != 0) {\n             *minor_status = code;\n             goto cleanup;\n@@ -983,11 +971,8 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,\n                                                      ret_flags,\n                                                      time_rec,\n                                                      &exts);\n-        if (major_status == GSS_S_COMPLETE) {\n-            *context_handle = ctx->gssc;\n-            ctx->gssc = GSS_C_NO_CONTEXT;\n-            iakerb_release_context(ctx);\n-        }\n+        if (major_status == GSS_S_COMPLETE)\n+            ctx->established = 1;\n         if (actual_mech_type != NULL)\n             *actual_mech_type = (gss_OID)gss_mech_krb5;\n     } else {\n@@ -1010,3 +995,309 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,\n \n     return major_status;\n }\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_unwrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                  gss_buffer_t input_message_buffer,\n+                  gss_buffer_t output_message_buffer, int *conf_state,\n+                  gss_qop_t *qop_state)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_unwrap(minor_status, ctx->gssc, input_message_buffer,\n+                           output_message_buffer, conf_state, qop_state);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                int conf_req_flag, gss_qop_t qop_req,\n+                gss_buffer_t input_message_buffer, int *conf_state,\n+                gss_buffer_t output_message_buffer)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_wrap(minor_status, ctx->gssc, conf_req_flag, qop_req,\n+                         input_message_buffer, conf_state,\n+                         output_message_buffer);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_process_context_token(OM_uint32 *minor_status,\n+                                 const gss_ctx_id_t context_handle,\n+                                 const gss_buffer_t token_buffer)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_DEFECTIVE_TOKEN;\n+\n+    return krb5_gss_process_context_token(minor_status, ctx->gssc,\n+                                          token_buffer);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_context_time(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                        OM_uint32 *time_rec)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_context_time(minor_status, ctx->gssc, time_rec);\n+}\n+\n+#ifndef LEAN_CLIENT\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n+                              gss_ctx_id_t *context_handle,\n+                              gss_buffer_t interprocess_token)\n+{\n+    OM_uint32 maj;\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    /* We don't currently support exporting partially established contexts. */\n+    if (!ctx->established)\n+        return GSS_S_UNAVAILABLE;\n+\n+    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,\n+                                      interprocess_token);\n+    if (ctx->gssc == GSS_C_NO_CONTEXT) {\n+        iakerb_release_context(ctx);\n+        *context_handle = GSS_C_NO_CONTEXT;\n+    }\n+    return maj;\n+}\n+\n+/*\n+ * Until we implement partial context exports, there are no SPNEGO exported\n+ * context tokens, only tokens for the underlying krb5 context.  So we do not\n+ * need to implement an iakerb_gss_import_sec_context() yet; it would be\n+ * unreachable except via a manually constructed token.\n+ */\n+\n+#endif /* LEAN_CLIENT */\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_inquire_context(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, gss_name_t *src_name,\n+                           gss_name_t *targ_name, OM_uint32 *lifetime_rec,\n+                           gss_OID *mech_type, OM_uint32 *ctx_flags,\n+                           int *initiate, int *opened)\n+{\n+    OM_uint32 ret;\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (src_name != NULL)\n+        *src_name = GSS_C_NO_NAME;\n+    if (targ_name != NULL)\n+        *targ_name = GSS_C_NO_NAME;\n+    if (lifetime_rec != NULL)\n+        *lifetime_rec = 0;\n+    if (mech_type != NULL)\n+        *mech_type = (gss_OID)gss_mech_iakerb;\n+    if (ctx_flags != NULL)\n+        *ctx_flags = 0;\n+    if (initiate != NULL)\n+        *initiate = ctx->initiate;\n+    if (opened != NULL)\n+        *opened = ctx->established;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_COMPLETE;\n+\n+    ret = krb5_gss_inquire_context(minor_status, ctx->gssc, src_name,\n+                                   targ_name, lifetime_rec, mech_type,\n+                                   ctx_flags, initiate, opened);\n+\n+    if (!ctx->established) {\n+        /* Report IAKERB as the mech OID until the context is established. */\n+        if (mech_type != NULL)\n+            *mech_type = (gss_OID)gss_mech_iakerb;\n+\n+        /* We don't support exporting partially-established contexts. */\n+        if (ctx_flags != NULL)\n+            *ctx_flags &= ~GSS_C_TRANS_FLAG;\n+    }\n+\n+    return ret;\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_size_limit(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, int conf_req_flag,\n+                           gss_qop_t qop_req, OM_uint32 req_output_size,\n+                           OM_uint32 *max_input_size)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_wrap_size_limit(minor_status, ctx->gssc, conf_req_flag,\n+                                    qop_req, req_output_size, max_input_size);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                   gss_qop_t qop_req, gss_buffer_t message_buffer,\n+                   gss_buffer_t message_token)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_get_mic(minor_status, ctx->gssc, qop_req, message_buffer,\n+                            message_token);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_verify_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                      gss_buffer_t msg_buffer, gss_buffer_t token_buffer,\n+                      gss_qop_t *qop_state)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_verify_mic(minor_status, ctx->gssc, msg_buffer,\n+                               token_buffer, qop_state);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_inquire_sec_context_by_oid(OM_uint32 *minor_status,\n+                                      const gss_ctx_id_t context_handle,\n+                                      const gss_OID desired_object,\n+                                      gss_buffer_set_t *data_set)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_UNAVAILABLE;\n+\n+    return krb5_gss_inquire_sec_context_by_oid(minor_status, ctx->gssc,\n+                                               desired_object, data_set);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_set_sec_context_option(OM_uint32 *minor_status,\n+                                  gss_ctx_id_t *context_handle,\n+                                  const gss_OID desired_object,\n+                                  const gss_buffer_t value)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)*context_handle;\n+\n+    if (ctx == NULL || ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_UNAVAILABLE;\n+\n+    return krb5_gss_set_sec_context_option(minor_status, &ctx->gssc,\n+                                           desired_object, value);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                    int conf_req_flag, gss_qop_t qop_req, int *conf_state,\n+                    gss_iov_buffer_desc *iov, int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_wrap_iov(minor_status, ctx->gssc, conf_req_flag, qop_req,\n+                             conf_state, iov, iov_count);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_unwrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                      int *conf_state, gss_qop_t *qop_state,\n+                      gss_iov_buffer_desc *iov, int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_unwrap_iov(minor_status, ctx->gssc, conf_state, qop_state,\n+                               iov, iov_count);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_iov_length(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, int conf_req_flag,\n+                           gss_qop_t qop_req, int *conf_state,\n+                           gss_iov_buffer_desc *iov, int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_wrap_iov_length(minor_status, ctx->gssc, conf_req_flag,\n+                                    qop_req, conf_state, iov, iov_count);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_pseudo_random(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                         int prf_key, const gss_buffer_t prf_in,\n+                         ssize_t desired_output_len, gss_buffer_t prf_out)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_pseudo_random(minor_status, ctx->gssc, prf_key, prf_in,\n+                                  desired_output_len, prf_out);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n+                       int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_get_mic_iov(minor_status, ctx->gssc, qop_req, iov,\n+                                iov_count);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                          gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n+                          int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_verify_mic_iov(minor_status, ctx->gssc, qop_state, iov,\n+                                   iov_count);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic_iov_length(OM_uint32 *minor_status,\n+                              gss_ctx_id_t context_handle, gss_qop_t qop_req,\n+                              gss_iov_buffer_desc *iov, int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_get_mic_iov_length(minor_status, ctx->gssc, qop_req, iov,\n+                                       iov_count);\n+}""}","iakerb_gss_delete_sec_context(OM_uint32 *minor_status,
                               gss_ctx_id_t *context_handle,
                               gss_buffer_t output_token)
 {
    iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;
 
     if (output_token != GSS_C_NO_BUFFER) {
         output_token->length = 0;
         output_token->value = NULL;
     }
 
     *minor_status = 0;
    *context_handle = GSS_C_NO_CONTEXT;
    iakerb_release_context(iakerb_ctx);
 
    return GSS_S_COMPLETE;
 }
","iakerb_gss_delete_sec_context(OM_uint32 *minor_status,
                               gss_ctx_id_t *context_handle,
                               gss_buffer_t output_token)
 {
    OM_uint32 major_status = GSS_S_COMPLETE;
 
     if (output_token != GSS_C_NO_BUFFER) {
         output_token->length = 0;
         output_token->value = NULL;
     }
 
     *minor_status = 0;
 
    if (*context_handle != GSS_C_NO_CONTEXT) {
        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;
        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {
            iakerb_release_context(iakerb_ctx);
            *context_handle = GSS_C_NO_CONTEXT;
        } else {
            assert(iakerb_ctx->magic == KG_CONTEXT);
            major_status = krb5_gss_delete_sec_context(minor_status,
                                                       context_handle,
                                                       output_token);
        }
    }
    return major_status;
 }
",C,"    iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;
    *context_handle = GSS_C_NO_CONTEXT;
    iakerb_release_context(iakerb_ctx);
    return GSS_S_COMPLETE;
","    OM_uint32 major_status = GSS_S_COMPLETE;
    if (*context_handle != GSS_C_NO_CONTEXT) {
        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;
        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {
            iakerb_release_context(iakerb_ctx);
            *context_handle = GSS_C_NO_CONTEXT;
        } else {
            assert(iakerb_ctx->magic == KG_CONTEXT);
            major_status = krb5_gss_delete_sec_context(minor_status,
                                                       context_handle,
                                                       output_token);
        }
    }
    return major_status;
",,"@@ -47,6 +47,8 @@ struct _iakerb_ctx_id_rec {
     gss_ctx_id_t gssc;
     krb5_data conv;                     /* conversation for checksumming */
     unsigned int count;                 /* number of round trips */
+    int initiate;
+    int established;
     krb5_get_init_creds_opt *gic_opts;
 };
 
@@ -695,7 +697,7 @@ iakerb_get_initial_state(iakerb_ctx_id_t ctx,
  * Allocate and initialise an IAKERB context
  */
 static krb5_error_code
-iakerb_alloc_context(iakerb_ctx_id_t *pctx)
+iakerb_alloc_context(iakerb_ctx_id_t *pctx, int initiate)
 {
     iakerb_ctx_id_t ctx;
     krb5_error_code code;
@@ -709,6 +711,8 @@ iakerb_alloc_context(iakerb_ctx_id_t *pctx)
     ctx->magic = KG_IAKERB_CONTEXT;
     ctx->state = IAKERB_AS_REQ;
     ctx->count = 0;
+    ctx->initiate = initiate;
+    ctx->established = 0;
 
     code = krb5_gss_init_context(&ctx->k5c);
     if (code != 0)
@@ -732,31 +736,18 @@ iakerb_gss_delete_sec_context(OM_uint32 *minor_status,
                               gss_ctx_id_t *context_handle,
                               gss_buffer_t output_token)
 {
-    OM_uint32 major_status = GSS_S_COMPLETE;
+    iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;
 
     if (output_token != GSS_C_NO_BUFFER) {
         output_token->length = 0;
         output_token->value = NULL;
     }
 
     *minor_status = 0;
+    *context_handle = GSS_C_NO_CONTEXT;
+    iakerb_release_context(iakerb_ctx);
 
-    if (*context_handle != GSS_C_NO_CONTEXT) {
-        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;
-
-        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {
-            iakerb_release_context(iakerb_ctx);
-            *context_handle = GSS_C_NO_CONTEXT;
-        } else {
-            assert(iakerb_ctx->magic == KG_CONTEXT);
-
-            major_status = krb5_gss_delete_sec_context(minor_status,
-                                                       context_handle,
-                                                       output_token);
-        }
-    }
-
-    return major_status;
+    return GSS_S_COMPLETE;
 }
 
 static krb5_boolean
@@ -802,7 +793,7 @@ iakerb_gss_accept_sec_context(OM_uint32 *minor_status,
     int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);
 
     if (initialContextToken) {
-        code = iakerb_alloc_context(&ctx);
+        code = iakerb_alloc_context(&ctx, 0);
         if (code != 0)
             goto cleanup;
 
@@ -854,11 +845,8 @@ iakerb_gss_accept_sec_context(OM_uint32 *minor_status,
                                                        time_rec,
                                                        delegated_cred_handle,
                                                        &exts);
-        if (major_status == GSS_S_COMPLETE) {
-            *context_handle = ctx->gssc;
-            ctx->gssc = NULL;
-            iakerb_release_context(ctx);
-        }
+        if (major_status == GSS_S_COMPLETE)
+            ctx->established = 1;
         if (mech_type != NULL)
             *mech_type = (gss_OID)gss_mech_krb5;
     }
@@ -897,7 +885,7 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,
     int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);
 
     if (initialContextToken) {
-        code = iakerb_alloc_context(&ctx);
+        code = iakerb_alloc_context(&ctx, 1);
         if (code != 0) {
             *minor_status = code;
             goto cleanup;
@@ -983,11 +971,8 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,
                                                      ret_flags,
                                                      time_rec,
                                                      &exts);
-        if (major_status == GSS_S_COMPLETE) {
-            *context_handle = ctx->gssc;
-            ctx->gssc = GSS_C_NO_CONTEXT;
-            iakerb_release_context(ctx);
-        }
+        if (major_status == GSS_S_COMPLETE)
+            ctx->established = 1;
         if (actual_mech_type != NULL)
             *actual_mech_type = (gss_OID)gss_mech_krb5;
     } else {
@@ -1010,3 +995,309 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,
 
     return major_status;
 }
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_unwrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                  gss_buffer_t input_message_buffer,
+                  gss_buffer_t output_message_buffer, int *conf_state,
+                  gss_qop_t *qop_state)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_unwrap(minor_status, ctx->gssc, input_message_buffer,
+                           output_message_buffer, conf_state, qop_state);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_wrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                int conf_req_flag, gss_qop_t qop_req,
+                gss_buffer_t input_message_buffer, int *conf_state,
+                gss_buffer_t output_message_buffer)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_wrap(minor_status, ctx->gssc, conf_req_flag, qop_req,
+                         input_message_buffer, conf_state,
+                         output_message_buffer);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_process_context_token(OM_uint32 *minor_status,
+                                 const gss_ctx_id_t context_handle,
+                                 const gss_buffer_t token_buffer)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_DEFECTIVE_TOKEN;
+
+    return krb5_gss_process_context_token(minor_status, ctx->gssc,
+                                          token_buffer);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_context_time(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                        OM_uint32 *time_rec)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_context_time(minor_status, ctx->gssc, time_rec);
+}
+
+#ifndef LEAN_CLIENT
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_export_sec_context(OM_uint32 *minor_status,
+                              gss_ctx_id_t *context_handle,
+                              gss_buffer_t interprocess_token)
+{
+    OM_uint32 maj;
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    /* We don't currently support exporting partially established contexts. */
+    if (!ctx->established)
+        return GSS_S_UNAVAILABLE;
+
+    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,
+                                      interprocess_token);
+    if (ctx->gssc == GSS_C_NO_CONTEXT) {
+        iakerb_release_context(ctx);
+        *context_handle = GSS_C_NO_CONTEXT;
+    }
+    return maj;
+}
+
+/*
+ * Until we implement partial context exports, there are no SPNEGO exported
+ * context tokens, only tokens for the underlying krb5 context.  So we do not
+ * need to implement an iakerb_gss_import_sec_context() yet; it would be
+ * unreachable except via a manually constructed token.
+ */
+
+#endif /* LEAN_CLIENT */
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_inquire_context(OM_uint32 *minor_status,
+                           gss_ctx_id_t context_handle, gss_name_t *src_name,
+                           gss_name_t *targ_name, OM_uint32 *lifetime_rec,
+                           gss_OID *mech_type, OM_uint32 *ctx_flags,
+                           int *initiate, int *opened)
+{
+    OM_uint32 ret;
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (src_name != NULL)
+        *src_name = GSS_C_NO_NAME;
+    if (targ_name != NULL)
+        *targ_name = GSS_C_NO_NAME;
+    if (lifetime_rec != NULL)
+        *lifetime_rec = 0;
+    if (mech_type != NULL)
+        *mech_type = (gss_OID)gss_mech_iakerb;
+    if (ctx_flags != NULL)
+        *ctx_flags = 0;
+    if (initiate != NULL)
+        *initiate = ctx->initiate;
+    if (opened != NULL)
+        *opened = ctx->established;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_COMPLETE;
+
+    ret = krb5_gss_inquire_context(minor_status, ctx->gssc, src_name,
+                                   targ_name, lifetime_rec, mech_type,
+                                   ctx_flags, initiate, opened);
+
+    if (!ctx->established) {
+        /* Report IAKERB as the mech OID until the context is established. */
+        if (mech_type != NULL)
+            *mech_type = (gss_OID)gss_mech_iakerb;
+
+        /* We don't support exporting partially-established contexts. */
+        if (ctx_flags != NULL)
+            *ctx_flags &= ~GSS_C_TRANS_FLAG;
+    }
+
+    return ret;
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_wrap_size_limit(OM_uint32 *minor_status,
+                           gss_ctx_id_t context_handle, int conf_req_flag,
+                           gss_qop_t qop_req, OM_uint32 req_output_size,
+                           OM_uint32 *max_input_size)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_wrap_size_limit(minor_status, ctx->gssc, conf_req_flag,
+                                    qop_req, req_output_size, max_input_size);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_get_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                   gss_qop_t qop_req, gss_buffer_t message_buffer,
+                   gss_buffer_t message_token)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_get_mic(minor_status, ctx->gssc, qop_req, message_buffer,
+                            message_token);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_verify_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                      gss_buffer_t msg_buffer, gss_buffer_t token_buffer,
+                      gss_qop_t *qop_state)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_verify_mic(minor_status, ctx->gssc, msg_buffer,
+                               token_buffer, qop_state);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_inquire_sec_context_by_oid(OM_uint32 *minor_status,
+                                      const gss_ctx_id_t context_handle,
+                                      const gss_OID desired_object,
+                                      gss_buffer_set_t *data_set)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_UNAVAILABLE;
+
+    return krb5_gss_inquire_sec_context_by_oid(minor_status, ctx->gssc,
+                                               desired_object, data_set);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_set_sec_context_option(OM_uint32 *minor_status,
+                                  gss_ctx_id_t *context_handle,
+                                  const gss_OID desired_object,
+                                  const gss_buffer_t value)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)*context_handle;
+
+    if (ctx == NULL || ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_UNAVAILABLE;
+
+    return krb5_gss_set_sec_context_option(minor_status, &ctx->gssc,
+                                           desired_object, value);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_wrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                    int conf_req_flag, gss_qop_t qop_req, int *conf_state,
+                    gss_iov_buffer_desc *iov, int iov_count)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_wrap_iov(minor_status, ctx->gssc, conf_req_flag, qop_req,
+                             conf_state, iov, iov_count);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_unwrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                      int *conf_state, gss_qop_t *qop_state,
+                      gss_iov_buffer_desc *iov, int iov_count)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_unwrap_iov(minor_status, ctx->gssc, conf_state, qop_state,
+                               iov, iov_count);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_wrap_iov_length(OM_uint32 *minor_status,
+                           gss_ctx_id_t context_handle, int conf_req_flag,
+                           gss_qop_t qop_req, int *conf_state,
+                           gss_iov_buffer_desc *iov, int iov_count)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_wrap_iov_length(minor_status, ctx->gssc, conf_req_flag,
+                                    qop_req, conf_state, iov, iov_count);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_pseudo_random(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                         int prf_key, const gss_buffer_t prf_in,
+                         ssize_t desired_output_len, gss_buffer_t prf_out)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_pseudo_random(minor_status, ctx->gssc, prf_key, prf_in,
+                                  desired_output_len, prf_out);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
+                       int iov_count)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_get_mic_iov(minor_status, ctx->gssc, qop_req, iov,
+                                iov_count);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                          gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
+                          int iov_count)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_verify_mic_iov(minor_status, ctx->gssc, qop_state, iov,
+                                   iov_count);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_get_mic_iov_length(OM_uint32 *minor_status,
+                              gss_ctx_id_t context_handle, gss_qop_t qop_req,
+                              gss_iov_buffer_desc *iov, int iov_count)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_get_mic_iov_length(minor_status, ctx->gssc, qop_req, iov,
+                                       iov_count);
+}",krb5,e04f0283516e80d2f93366e0d479d13c9b5c8c2a,b51b33f2bc5d1497ddf5bd107f791c101695000d,1,"iakerb_gss_delete_sec_context(OM_uint32 *minor_status,
                               gss_ctx_id_t *context_handle,
                               gss_buffer_t output_token)
 {
//flaw_line_below:
    OM_uint32 major_status = GSS_S_COMPLETE;
//fix_flaw_line_below:
//    iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;
 
     if (output_token != GSS_C_NO_BUFFER) {
         output_token->length = 0;
         output_token->value = NULL;
     }
 
     *minor_status = 0;
//fix_flaw_line_below:
//    *context_handle = GSS_C_NO_CONTEXT;
//fix_flaw_line_below:
//    iakerb_release_context(iakerb_ctx);
 
//flaw_line_below:
    if (*context_handle != GSS_C_NO_CONTEXT) {
//flaw_line_below:
        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;
//flaw_line_below:

//flaw_line_below:
        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {
//flaw_line_below:
            iakerb_release_context(iakerb_ctx);
//flaw_line_below:
            *context_handle = GSS_C_NO_CONTEXT;
//flaw_line_below:
        } else {
//flaw_line_below:
            assert(iakerb_ctx->magic == KG_CONTEXT);
//flaw_line_below:

//flaw_line_below:
            major_status = krb5_gss_delete_sec_context(minor_status,
//flaw_line_below:
                                                       context_handle,
//flaw_line_below:
                                                       output_token);
//flaw_line_below:
        }
//flaw_line_below:
    }
//flaw_line_below:

//flaw_line_below:
    return major_status;
//fix_flaw_line_below:
//    return GSS_S_COMPLETE;
 }
"
2082,179818,,Remote,Not required,Complete,CVE-2015-2696,https://www.cvedetails.com/cve/CVE-2015-2696/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/krb5/iakerb.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted IAKERB packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,3,https://github.com/krb5/krb5/commit/e04f0283516e80d2f93366e0d479d13c9b5c8c2a,e04f0283516e80d2f93366e0d479d13c9b5c8c2a,"Fix IAKERB context aliasing bugs [CVE-2015-2696]

The IAKERB mechanism currently replaces its context handle with the
krb5 mechanism handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the IAKERB context structure after context
establishment and add new IAKERB entry points to refer to it with that
type.  Add initiate and established flags to the IAKERB context
structure for use in gss_inquire_context() prior to context
establishment.

CVE-2015-2696:

In MIT krb5 1.9 and later, applications which call
gss_inquire_context() on a partially-established IAKERB context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  Java server applications using the
native JGSS provider are vulnerable to this bug.  A carefully crafted
IAKERB packet might allow the gss_inquire_context() call to succeed
with attacker-determined results, but applications should not make
access control decisions based on gss_inquire_context() results prior
to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",6,src/lib/gssapi/krb5/iakerb.c,"{""sha"": ""97e090d099f3672e9fe67c969c1615dc0710922c"", ""filename"": ""src/lib/gssapi/krb5/gssapiP_krb5.h"", ""status"": ""modified"", ""additions"": 114, ""deletions"": 0, ""changes"": 114, ""blob_url"": ""https://github.com/krb5/krb5/blob/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/gssapiP_krb5.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/gssapiP_krb5.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/krb5/gssapiP_krb5.h?ref=e04f0283516e80d2f93366e0d479d13c9b5c8c2a"", ""patch"": ""@@ -621,6 +621,21 @@ OM_uint32 KRB5_CALLCONV krb5_gss_accept_sec_context_ext\n );\n #endif /* LEAN_CLIENT */\n \n+OM_uint32 KRB5_CALLCONV krb5_gss_inquire_sec_context_by_oid\n+(OM_uint32*,       /* minor_status */\n+ const gss_ctx_id_t,\n+ /* context_handle */\n+ const gss_OID,    /* desired_object */\n+ gss_buffer_set_t* /* data_set */\n+);\n+\n+OM_uint32 KRB5_CALLCONV krb5_gss_set_sec_context_option\n+(OM_uint32*,       /* minor_status */\n+ gss_ctx_id_t*,    /* context_handle */\n+ const gss_OID,    /* desired_object */\n+ const gss_buffer_t/* value */\n+);\n+\n OM_uint32 KRB5_CALLCONV krb5_gss_process_context_token\n (OM_uint32*,       /* minor_status */\n  gss_ctx_id_t,     /* context_handle */\n@@ -1302,6 +1317,105 @@ OM_uint32 KRB5_CALLCONV\n krb5_gss_import_cred(OM_uint32 *minor_status, gss_buffer_t token,\n                      gss_cred_id_t *cred_handle);\n \n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_process_context_token(OM_uint32 *minor_status,\n+                                 const gss_ctx_id_t context_handle,\n+                                 const gss_buffer_t token_buffer);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_context_time(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                        OM_uint32 *time_rec);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_inquire_context(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, gss_name_t *src_name,\n+                           gss_name_t *targ_name, OM_uint32 *lifetime_rec,\n+                           gss_OID *mech_type, OM_uint32 *ctx_flags,\n+                           int *locally_initiated, int *opened);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                   gss_qop_t qop_req, gss_buffer_t message_buffer,\n+                   gss_buffer_t message_token);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n+                       int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic_iov_length(OM_uint32 *minor_status,\n+                              gss_ctx_id_t context_handle, gss_qop_t qop_req,\n+                              gss_iov_buffer_desc *iov, int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_verify_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                      gss_buffer_t msg_buffer, gss_buffer_t token_buffer,\n+                      gss_qop_t *qop_state);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                          gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n+                          int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                int conf_req_flag, gss_qop_t qop_req,\n+                gss_buffer_t input_message_buffer, int *conf_state,\n+                gss_buffer_t output_message_buffer);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                    int conf_req_flag, gss_qop_t qop_req, int *conf_state,\n+                    gss_iov_buffer_desc *iov, int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_iov_length(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, int conf_req_flag,\n+                           gss_qop_t qop_req, int *conf_state,\n+                           gss_iov_buffer_desc *iov, int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_unwrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                  gss_buffer_t input_message_buffer,\n+                  gss_buffer_t output_message_buffer, int *conf_state,\n+                  gss_qop_t *qop_state);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_unwrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                      int *conf_state, gss_qop_t *qop_state,\n+                      gss_iov_buffer_desc *iov, int iov_count);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_size_limit(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, int conf_req_flag,\n+                           gss_qop_t qop_req, OM_uint32 req_output_size,\n+                           OM_uint32 *max_input_size);\n+\n+#ifndef LEAN_CLIENT\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n+                              gss_ctx_id_t *context_handle,\n+                              gss_buffer_t interprocess_token);\n+#endif /* LEAN_CLIENT */\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_inquire_sec_context_by_oid(OM_uint32 *minor_status,\n+                                      const gss_ctx_id_t context_handle,\n+                                      const gss_OID desired_object,\n+                                      gss_buffer_set_t *data_set);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_set_sec_context_option(OM_uint32 *minor_status,\n+                                  gss_ctx_id_t *context_handle,\n+                                  const gss_OID desired_object,\n+                                  const gss_buffer_t value);\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_pseudo_random(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                         int prf_key, const gss_buffer_t prf_in,\n+                         ssize_t desired_output_len, gss_buffer_t prf_out);\n+\n /* Magic string to identify exported krb5 GSS credentials.  Increment this if\n  * the format changes. */\n #define CRED_EXPORT_MAGIC \""K5C1\""""}<_**next**_>{""sha"": ""c4dfdd6fbd1338c6ad8bb2a395fff7cafa8de82b"", ""filename"": ""src/lib/gssapi/krb5/gssapi_krb5.c"", ""status"": ""modified"", ""additions"": 94, ""deletions"": 11, ""changes"": 105, ""blob_url"": ""https://github.com/krb5/krb5/blob/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/gssapi_krb5.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/gssapi_krb5.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/krb5/gssapi_krb5.c?ref=e04f0283516e80d2f93366e0d479d13c9b5c8c2a"", ""patch"": ""@@ -351,7 +351,7 @@ static struct {\n     }\n };\n \n-static OM_uint32 KRB5_CALLCONV\n+OM_uint32 KRB5_CALLCONV\n krb5_gss_inquire_sec_context_by_oid (OM_uint32 *minor_status,\n                                      const gss_ctx_id_t context_handle,\n                                      const gss_OID desired_object,\n@@ -465,7 +465,7 @@ static struct {\n };\n #endif\n \n-static OM_uint32 KRB5_CALLCONV\n+OM_uint32 KRB5_CALLCONV\n krb5_gss_set_sec_context_option (OM_uint32 *minor_status,\n                                  gss_ctx_id_t *context_handle,\n                                  const gss_OID desired_object,\n@@ -929,20 +929,103 @@ static struct gss_config krb5_mechanism = {\n     krb5_gss_get_mic_iov_length,\n };\n \n+/* Functions which use security contexts or acquire creds are IAKERB-specific;\n+ * other functions can borrow from the krb5 mech. */\n+static struct gss_config iakerb_mechanism = {\n+    { GSS_MECH_KRB5_OID_LENGTH, GSS_MECH_KRB5_OID },\n+    NULL,\n+    iakerb_gss_acquire_cred,\n+    krb5_gss_release_cred,\n+    iakerb_gss_init_sec_context,\n+#ifdef LEAN_CLIENT\n+    NULL,\n+#else\n+    iakerb_gss_accept_sec_context,\n+#endif\n+    iakerb_gss_process_context_token,\n+    iakerb_gss_delete_sec_context,\n+    iakerb_gss_context_time,\n+    iakerb_gss_get_mic,\n+    iakerb_gss_verify_mic,\n+#if defined(IOV_SHIM_EXERCISE_WRAP) || defined(IOV_SHIM_EXERCISE)\n+    NULL,\n+#else\n+    iakerb_gss_wrap,\n+#endif\n+#if defined(IOV_SHIM_EXERCISE_UNWRAP) || defined(IOV_SHIM_EXERCISE)\n+    NULL,\n+#else\n+    iakerb_gss_unwrap,\n+#endif\n+    krb5_gss_display_status,\n+    krb5_gss_indicate_mechs,\n+    krb5_gss_compare_name,\n+    krb5_gss_display_name,\n+    krb5_gss_import_name,\n+    krb5_gss_release_name,\n+    krb5_gss_inquire_cred,\n+    NULL,                /* add_cred */\n+#ifdef LEAN_CLIENT\n+    NULL,\n+    NULL,\n+#else\n+    iakerb_gss_export_sec_context,\n+    NULL,\n+#endif\n+    krb5_gss_inquire_cred_by_mech,\n+    krb5_gss_inquire_names_for_mech,\n+    iakerb_gss_inquire_context,\n+    krb5_gss_internal_release_oid,\n+    iakerb_gss_wrap_size_limit,\n+    krb5_gss_localname,\n+    krb5_gss_authorize_localname,\n+    krb5_gss_export_name,\n+    krb5_gss_duplicate_name,\n+    krb5_gss_store_cred,\n+    iakerb_gss_inquire_sec_context_by_oid,\n+    krb5_gss_inquire_cred_by_oid,\n+    iakerb_gss_set_sec_context_option,\n+    krb5_gssspi_set_cred_option,\n+    krb5_gssspi_mech_invoke,\n+    NULL,                /* wrap_aead */\n+    NULL,                /* unwrap_aead */\n+    iakerb_gss_wrap_iov,\n+    iakerb_gss_unwrap_iov,\n+    iakerb_gss_wrap_iov_length,\n+    NULL,               /* complete_auth_token */\n+    NULL,               /* acquire_cred_impersonate_name */\n+    NULL,               /* add_cred_impersonate_name */\n+    NULL,               /* display_name_ext */\n+    krb5_gss_inquire_name,\n+    krb5_gss_get_name_attribute,\n+    krb5_gss_set_name_attribute,\n+    krb5_gss_delete_name_attribute,\n+    krb5_gss_export_name_composite,\n+    krb5_gss_map_name_to_any,\n+    krb5_gss_release_any_name_mapping,\n+    iakerb_gss_pseudo_random,\n+    NULL,               /* set_neg_mechs */\n+    krb5_gss_inquire_saslname_for_mech,\n+    krb5_gss_inquire_mech_for_saslname,\n+    krb5_gss_inquire_attrs_for_mech,\n+    krb5_gss_acquire_cred_from,\n+    krb5_gss_store_cred_into,\n+    iakerb_gss_acquire_cred_with_password,\n+    krb5_gss_export_cred,\n+    krb5_gss_import_cred,\n+    NULL,               /* import_sec_context_by_mech */\n+    NULL,               /* import_name_by_mech */\n+    NULL,               /* import_cred_by_mech */\n+    iakerb_gss_get_mic_iov,\n+    iakerb_gss_verify_mic_iov,\n+    iakerb_gss_get_mic_iov_length,\n+};\n+\n #ifdef _GSS_STATIC_LINK\n #include \""mglueP.h\""\n static int gss_iakerbmechglue_init(void)\n {\n     struct gss_mech_config mech_iakerb;\n-    struct gss_config iakerb_mechanism = krb5_mechanism;\n-\n-    /* IAKERB mechanism mirrors krb5, but with different context SPIs */\n-    iakerb_mechanism.gss_accept_sec_context = iakerb_gss_accept_sec_context;\n-    iakerb_mechanism.gss_init_sec_context   = iakerb_gss_init_sec_context;\n-    iakerb_mechanism.gss_delete_sec_context = iakerb_gss_delete_sec_context;\n-    iakerb_mechanism.gss_acquire_cred       = iakerb_gss_acquire_cred;\n-    iakerb_mechanism.gssspi_acquire_cred_with_password\n-                                    = iakerb_gss_acquire_cred_with_password;\n \n     memset(&mech_iakerb, 0, sizeof(mech_iakerb));\n     mech_iakerb.mech = &iakerb_mechanism;""}<_**next**_>{""sha"": ""4662bd9fe382fdde657abaa6db06fa47ad69d8b7"", ""filename"": ""src/lib/gssapi/krb5/iakerb.c"", ""status"": ""modified"", ""additions"": 321, ""deletions"": 30, ""changes"": 351, ""blob_url"": ""https://github.com/krb5/krb5/blob/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/iakerb.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/e04f0283516e80d2f93366e0d479d13c9b5c8c2a/src/lib/gssapi/krb5/iakerb.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/krb5/iakerb.c?ref=e04f0283516e80d2f93366e0d479d13c9b5c8c2a"", ""patch"": ""@@ -47,6 +47,8 @@ struct _iakerb_ctx_id_rec {\n     gss_ctx_id_t gssc;\n     krb5_data conv;                     /* conversation for checksumming */\n     unsigned int count;                 /* number of round trips */\n+    int initiate;\n+    int established;\n     krb5_get_init_creds_opt *gic_opts;\n };\n \n@@ -695,7 +697,7 @@ iakerb_get_initial_state(iakerb_ctx_id_t ctx,\n  * Allocate and initialise an IAKERB context\n  */\n static krb5_error_code\n-iakerb_alloc_context(iakerb_ctx_id_t *pctx)\n+iakerb_alloc_context(iakerb_ctx_id_t *pctx, int initiate)\n {\n     iakerb_ctx_id_t ctx;\n     krb5_error_code code;\n@@ -709,6 +711,8 @@ iakerb_alloc_context(iakerb_ctx_id_t *pctx)\n     ctx->magic = KG_IAKERB_CONTEXT;\n     ctx->state = IAKERB_AS_REQ;\n     ctx->count = 0;\n+    ctx->initiate = initiate;\n+    ctx->established = 0;\n \n     code = krb5_gss_init_context(&ctx->k5c);\n     if (code != 0)\n@@ -732,31 +736,18 @@ iakerb_gss_delete_sec_context(OM_uint32 *minor_status,\n                               gss_ctx_id_t *context_handle,\n                               gss_buffer_t output_token)\n {\n-    OM_uint32 major_status = GSS_S_COMPLETE;\n+    iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n \n     if (output_token != GSS_C_NO_BUFFER) {\n         output_token->length = 0;\n         output_token->value = NULL;\n     }\n \n     *minor_status = 0;\n+    *context_handle = GSS_C_NO_CONTEXT;\n+    iakerb_release_context(iakerb_ctx);\n \n-    if (*context_handle != GSS_C_NO_CONTEXT) {\n-        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n-\n-        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {\n-            iakerb_release_context(iakerb_ctx);\n-            *context_handle = GSS_C_NO_CONTEXT;\n-        } else {\n-            assert(iakerb_ctx->magic == KG_CONTEXT);\n-\n-            major_status = krb5_gss_delete_sec_context(minor_status,\n-                                                       context_handle,\n-                                                       output_token);\n-        }\n-    }\n-\n-    return major_status;\n+    return GSS_S_COMPLETE;\n }\n \n static krb5_boolean\n@@ -802,7 +793,7 @@ iakerb_gss_accept_sec_context(OM_uint32 *minor_status,\n     int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);\n \n     if (initialContextToken) {\n-        code = iakerb_alloc_context(&ctx);\n+        code = iakerb_alloc_context(&ctx, 0);\n         if (code != 0)\n             goto cleanup;\n \n@@ -854,11 +845,8 @@ iakerb_gss_accept_sec_context(OM_uint32 *minor_status,\n                                                        time_rec,\n                                                        delegated_cred_handle,\n                                                        &exts);\n-        if (major_status == GSS_S_COMPLETE) {\n-            *context_handle = ctx->gssc;\n-            ctx->gssc = NULL;\n-            iakerb_release_context(ctx);\n-        }\n+        if (major_status == GSS_S_COMPLETE)\n+            ctx->established = 1;\n         if (mech_type != NULL)\n             *mech_type = (gss_OID)gss_mech_krb5;\n     }\n@@ -897,7 +885,7 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,\n     int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);\n \n     if (initialContextToken) {\n-        code = iakerb_alloc_context(&ctx);\n+        code = iakerb_alloc_context(&ctx, 1);\n         if (code != 0) {\n             *minor_status = code;\n             goto cleanup;\n@@ -983,11 +971,8 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,\n                                                      ret_flags,\n                                                      time_rec,\n                                                      &exts);\n-        if (major_status == GSS_S_COMPLETE) {\n-            *context_handle = ctx->gssc;\n-            ctx->gssc = GSS_C_NO_CONTEXT;\n-            iakerb_release_context(ctx);\n-        }\n+        if (major_status == GSS_S_COMPLETE)\n+            ctx->established = 1;\n         if (actual_mech_type != NULL)\n             *actual_mech_type = (gss_OID)gss_mech_krb5;\n     } else {\n@@ -1010,3 +995,309 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,\n \n     return major_status;\n }\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_unwrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                  gss_buffer_t input_message_buffer,\n+                  gss_buffer_t output_message_buffer, int *conf_state,\n+                  gss_qop_t *qop_state)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_unwrap(minor_status, ctx->gssc, input_message_buffer,\n+                           output_message_buffer, conf_state, qop_state);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                int conf_req_flag, gss_qop_t qop_req,\n+                gss_buffer_t input_message_buffer, int *conf_state,\n+                gss_buffer_t output_message_buffer)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_wrap(minor_status, ctx->gssc, conf_req_flag, qop_req,\n+                         input_message_buffer, conf_state,\n+                         output_message_buffer);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_process_context_token(OM_uint32 *minor_status,\n+                                 const gss_ctx_id_t context_handle,\n+                                 const gss_buffer_t token_buffer)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_DEFECTIVE_TOKEN;\n+\n+    return krb5_gss_process_context_token(minor_status, ctx->gssc,\n+                                          token_buffer);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_context_time(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                        OM_uint32 *time_rec)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_context_time(minor_status, ctx->gssc, time_rec);\n+}\n+\n+#ifndef LEAN_CLIENT\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n+                              gss_ctx_id_t *context_handle,\n+                              gss_buffer_t interprocess_token)\n+{\n+    OM_uint32 maj;\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    /* We don't currently support exporting partially established contexts. */\n+    if (!ctx->established)\n+        return GSS_S_UNAVAILABLE;\n+\n+    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,\n+                                      interprocess_token);\n+    if (ctx->gssc == GSS_C_NO_CONTEXT) {\n+        iakerb_release_context(ctx);\n+        *context_handle = GSS_C_NO_CONTEXT;\n+    }\n+    return maj;\n+}\n+\n+/*\n+ * Until we implement partial context exports, there are no SPNEGO exported\n+ * context tokens, only tokens for the underlying krb5 context.  So we do not\n+ * need to implement an iakerb_gss_import_sec_context() yet; it would be\n+ * unreachable except via a manually constructed token.\n+ */\n+\n+#endif /* LEAN_CLIENT */\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_inquire_context(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, gss_name_t *src_name,\n+                           gss_name_t *targ_name, OM_uint32 *lifetime_rec,\n+                           gss_OID *mech_type, OM_uint32 *ctx_flags,\n+                           int *initiate, int *opened)\n+{\n+    OM_uint32 ret;\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (src_name != NULL)\n+        *src_name = GSS_C_NO_NAME;\n+    if (targ_name != NULL)\n+        *targ_name = GSS_C_NO_NAME;\n+    if (lifetime_rec != NULL)\n+        *lifetime_rec = 0;\n+    if (mech_type != NULL)\n+        *mech_type = (gss_OID)gss_mech_iakerb;\n+    if (ctx_flags != NULL)\n+        *ctx_flags = 0;\n+    if (initiate != NULL)\n+        *initiate = ctx->initiate;\n+    if (opened != NULL)\n+        *opened = ctx->established;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_COMPLETE;\n+\n+    ret = krb5_gss_inquire_context(minor_status, ctx->gssc, src_name,\n+                                   targ_name, lifetime_rec, mech_type,\n+                                   ctx_flags, initiate, opened);\n+\n+    if (!ctx->established) {\n+        /* Report IAKERB as the mech OID until the context is established. */\n+        if (mech_type != NULL)\n+            *mech_type = (gss_OID)gss_mech_iakerb;\n+\n+        /* We don't support exporting partially-established contexts. */\n+        if (ctx_flags != NULL)\n+            *ctx_flags &= ~GSS_C_TRANS_FLAG;\n+    }\n+\n+    return ret;\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_size_limit(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, int conf_req_flag,\n+                           gss_qop_t qop_req, OM_uint32 req_output_size,\n+                           OM_uint32 *max_input_size)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_wrap_size_limit(minor_status, ctx->gssc, conf_req_flag,\n+                                    qop_req, req_output_size, max_input_size);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                   gss_qop_t qop_req, gss_buffer_t message_buffer,\n+                   gss_buffer_t message_token)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_get_mic(minor_status, ctx->gssc, qop_req, message_buffer,\n+                            message_token);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_verify_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                      gss_buffer_t msg_buffer, gss_buffer_t token_buffer,\n+                      gss_qop_t *qop_state)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_verify_mic(minor_status, ctx->gssc, msg_buffer,\n+                               token_buffer, qop_state);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_inquire_sec_context_by_oid(OM_uint32 *minor_status,\n+                                      const gss_ctx_id_t context_handle,\n+                                      const gss_OID desired_object,\n+                                      gss_buffer_set_t *data_set)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_UNAVAILABLE;\n+\n+    return krb5_gss_inquire_sec_context_by_oid(minor_status, ctx->gssc,\n+                                               desired_object, data_set);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_set_sec_context_option(OM_uint32 *minor_status,\n+                                  gss_ctx_id_t *context_handle,\n+                                  const gss_OID desired_object,\n+                                  const gss_buffer_t value)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)*context_handle;\n+\n+    if (ctx == NULL || ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_UNAVAILABLE;\n+\n+    return krb5_gss_set_sec_context_option(minor_status, &ctx->gssc,\n+                                           desired_object, value);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                    int conf_req_flag, gss_qop_t qop_req, int *conf_state,\n+                    gss_iov_buffer_desc *iov, int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_wrap_iov(minor_status, ctx->gssc, conf_req_flag, qop_req,\n+                             conf_state, iov, iov_count);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_unwrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                      int *conf_state, gss_qop_t *qop_state,\n+                      gss_iov_buffer_desc *iov, int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_unwrap_iov(minor_status, ctx->gssc, conf_state, qop_state,\n+                               iov, iov_count);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_wrap_iov_length(OM_uint32 *minor_status,\n+                           gss_ctx_id_t context_handle, int conf_req_flag,\n+                           gss_qop_t qop_req, int *conf_state,\n+                           gss_iov_buffer_desc *iov, int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_wrap_iov_length(minor_status, ctx->gssc, conf_req_flag,\n+                                    qop_req, conf_state, iov, iov_count);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_pseudo_random(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                         int prf_key, const gss_buffer_t prf_in,\n+                         ssize_t desired_output_len, gss_buffer_t prf_out)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_pseudo_random(minor_status, ctx->gssc, prf_key, prf_in,\n+                                  desired_output_len, prf_out);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n+                       int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_get_mic_iov(minor_status, ctx->gssc, qop_req, iov,\n+                                iov_count);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n+                          gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n+                          int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_verify_mic_iov(minor_status, ctx->gssc, qop_state, iov,\n+                                   iov_count);\n+}\n+\n+OM_uint32 KRB5_CALLCONV\n+iakerb_gss_get_mic_iov_length(OM_uint32 *minor_status,\n+                              gss_ctx_id_t context_handle, gss_qop_t qop_req,\n+                              gss_iov_buffer_desc *iov, int iov_count)\n+{\n+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n+\n+    if (ctx->gssc == GSS_C_NO_CONTEXT)\n+        return GSS_S_NO_CONTEXT;\n+\n+    return krb5_gss_get_mic_iov_length(minor_status, ctx->gssc, qop_req, iov,\n+                                       iov_count);\n+}""}","iakerb_gss_init_sec_context(OM_uint32 *minor_status,
                            gss_cred_id_t claimant_cred_handle,
                            gss_ctx_id_t *context_handle,
                            gss_name_t target_name,
                            gss_OID mech_type,
                            OM_uint32 req_flags,
                            OM_uint32 time_req,
                            gss_channel_bindings_t input_chan_bindings,
                            gss_buffer_t input_token,
                            gss_OID *actual_mech_type,
                            gss_buffer_t output_token,
                            OM_uint32 *ret_flags,
                            OM_uint32 *time_rec)
{
    OM_uint32 major_status = GSS_S_FAILURE;
    krb5_error_code code;
    iakerb_ctx_id_t ctx;
    krb5_gss_cred_id_t kcred;
    krb5_gss_name_t kname;
    krb5_boolean cred_locked = FALSE;
     int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);
 
     if (initialContextToken) {
        code = iakerb_alloc_context(&ctx, 1);
         if (code != 0) {
             *minor_status = code;
             goto cleanup;
        }
        if (claimant_cred_handle == GSS_C_NO_CREDENTIAL) {
            major_status = iakerb_gss_acquire_cred(minor_status, NULL,
                                                   GSS_C_INDEFINITE,
                                                   GSS_C_NULL_OID_SET,
                                                   GSS_C_INITIATE,
                                                   &ctx->defcred, NULL, NULL);
            if (GSS_ERROR(major_status))
                goto cleanup;
            claimant_cred_handle = ctx->defcred;
        }
    } else {
        ctx = (iakerb_ctx_id_t)*context_handle;
        if (claimant_cred_handle == GSS_C_NO_CREDENTIAL)
            claimant_cred_handle = ctx->defcred;
    }

    kname = (krb5_gss_name_t)target_name;

    major_status = kg_cred_resolve(minor_status, ctx->k5c,
                                   claimant_cred_handle, target_name);
    if (GSS_ERROR(major_status))
        goto cleanup;
    cred_locked = TRUE;
    kcred = (krb5_gss_cred_id_t)claimant_cred_handle;

    major_status = GSS_S_FAILURE;

    if (initialContextToken) {
        code = iakerb_get_initial_state(ctx, kcred, kname, time_req,
                                        &ctx->state);
        if (code != 0) {
            *minor_status = code;
            goto cleanup;
        }
        *context_handle = (gss_ctx_id_t)ctx;
    }

    if (ctx->state != IAKERB_AP_REQ) {
        /* We need to do IAKERB. */
        code = iakerb_initiator_step(ctx,
                                     kcred,
                                     kname,
                                     time_req,
                                     input_token,
                                     output_token);
        if (code == KRB5_BAD_MSIZE)
            major_status = GSS_S_DEFECTIVE_TOKEN;
        if (code != 0) {
            *minor_status = code;
            goto cleanup;
        }
    }

    if (ctx->state == IAKERB_AP_REQ) {
        krb5_gss_ctx_ext_rec exts;

        if (cred_locked) {
            k5_mutex_unlock(&kcred->lock);
            cred_locked = FALSE;
        }

        iakerb_make_exts(ctx, &exts);

        if (ctx->gssc == GSS_C_NO_CONTEXT)
            input_token = GSS_C_NO_BUFFER;

        /* IAKERB is finished, or we skipped to Kerberos directly. */
        major_status = krb5_gss_init_sec_context_ext(minor_status,
                                                     (gss_cred_id_t) kcred,
                                                     &ctx->gssc,
                                                     target_name,
                                                     (gss_OID)gss_mech_iakerb,
                                                     req_flags,
                                                     time_req,
                                                     input_chan_bindings,
                                                     input_token,
                                                     NULL,
                                                     output_token,
                                                      ret_flags,
                                                      time_rec,
                                                      &exts);
        if (major_status == GSS_S_COMPLETE)
            ctx->established = 1;
         if (actual_mech_type != NULL)
             *actual_mech_type = (gss_OID)gss_mech_krb5;
     } else {
        if (actual_mech_type != NULL)
            *actual_mech_type = (gss_OID)gss_mech_iakerb;
        if (ret_flags != NULL)
            *ret_flags = 0;
        if (time_rec != NULL)
            *time_rec = 0;
        major_status = GSS_S_CONTINUE_NEEDED;
    }

cleanup:
    if (cred_locked)
        k5_mutex_unlock(&kcred->lock);
    if (initialContextToken && GSS_ERROR(major_status)) {
        iakerb_release_context(ctx);
        *context_handle = GSS_C_NO_CONTEXT;
    }
 
     return major_status;
 }
","iakerb_gss_init_sec_context(OM_uint32 *minor_status,
                            gss_cred_id_t claimant_cred_handle,
                            gss_ctx_id_t *context_handle,
                            gss_name_t target_name,
                            gss_OID mech_type,
                            OM_uint32 req_flags,
                            OM_uint32 time_req,
                            gss_channel_bindings_t input_chan_bindings,
                            gss_buffer_t input_token,
                            gss_OID *actual_mech_type,
                            gss_buffer_t output_token,
                            OM_uint32 *ret_flags,
                            OM_uint32 *time_rec)
{
    OM_uint32 major_status = GSS_S_FAILURE;
    krb5_error_code code;
    iakerb_ctx_id_t ctx;
    krb5_gss_cred_id_t kcred;
    krb5_gss_name_t kname;
    krb5_boolean cred_locked = FALSE;
     int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);
 
     if (initialContextToken) {
        code = iakerb_alloc_context(&ctx);
         if (code != 0) {
             *minor_status = code;
             goto cleanup;
        }
        if (claimant_cred_handle == GSS_C_NO_CREDENTIAL) {
            major_status = iakerb_gss_acquire_cred(minor_status, NULL,
                                                   GSS_C_INDEFINITE,
                                                   GSS_C_NULL_OID_SET,
                                                   GSS_C_INITIATE,
                                                   &ctx->defcred, NULL, NULL);
            if (GSS_ERROR(major_status))
                goto cleanup;
            claimant_cred_handle = ctx->defcred;
        }
    } else {
        ctx = (iakerb_ctx_id_t)*context_handle;
        if (claimant_cred_handle == GSS_C_NO_CREDENTIAL)
            claimant_cred_handle = ctx->defcred;
    }

    kname = (krb5_gss_name_t)target_name;

    major_status = kg_cred_resolve(minor_status, ctx->k5c,
                                   claimant_cred_handle, target_name);
    if (GSS_ERROR(major_status))
        goto cleanup;
    cred_locked = TRUE;
    kcred = (krb5_gss_cred_id_t)claimant_cred_handle;

    major_status = GSS_S_FAILURE;

    if (initialContextToken) {
        code = iakerb_get_initial_state(ctx, kcred, kname, time_req,
                                        &ctx->state);
        if (code != 0) {
            *minor_status = code;
            goto cleanup;
        }
        *context_handle = (gss_ctx_id_t)ctx;
    }

    if (ctx->state != IAKERB_AP_REQ) {
        /* We need to do IAKERB. */
        code = iakerb_initiator_step(ctx,
                                     kcred,
                                     kname,
                                     time_req,
                                     input_token,
                                     output_token);
        if (code == KRB5_BAD_MSIZE)
            major_status = GSS_S_DEFECTIVE_TOKEN;
        if (code != 0) {
            *minor_status = code;
            goto cleanup;
        }
    }

    if (ctx->state == IAKERB_AP_REQ) {
        krb5_gss_ctx_ext_rec exts;

        if (cred_locked) {
            k5_mutex_unlock(&kcred->lock);
            cred_locked = FALSE;
        }

        iakerb_make_exts(ctx, &exts);

        if (ctx->gssc == GSS_C_NO_CONTEXT)
            input_token = GSS_C_NO_BUFFER;

        /* IAKERB is finished, or we skipped to Kerberos directly. */
        major_status = krb5_gss_init_sec_context_ext(minor_status,
                                                     (gss_cred_id_t) kcred,
                                                     &ctx->gssc,
                                                     target_name,
                                                     (gss_OID)gss_mech_iakerb,
                                                     req_flags,
                                                     time_req,
                                                     input_chan_bindings,
                                                     input_token,
                                                     NULL,
                                                     output_token,
                                                      ret_flags,
                                                      time_rec,
                                                      &exts);
        if (major_status == GSS_S_COMPLETE) {
            *context_handle = ctx->gssc;
            ctx->gssc = GSS_C_NO_CONTEXT;
            iakerb_release_context(ctx);
        }
         if (actual_mech_type != NULL)
             *actual_mech_type = (gss_OID)gss_mech_krb5;
     } else {
        if (actual_mech_type != NULL)
            *actual_mech_type = (gss_OID)gss_mech_iakerb;
        if (ret_flags != NULL)
            *ret_flags = 0;
        if (time_rec != NULL)
            *time_rec = 0;
        major_status = GSS_S_CONTINUE_NEEDED;
    }

cleanup:
    if (cred_locked)
        k5_mutex_unlock(&kcred->lock);
    if (initialContextToken && GSS_ERROR(major_status)) {
        iakerb_release_context(ctx);
        *context_handle = GSS_C_NO_CONTEXT;
    }
 
     return major_status;
 }
",C,"        code = iakerb_alloc_context(&ctx, 1);
        if (major_status == GSS_S_COMPLETE)
            ctx->established = 1;
","        code = iakerb_alloc_context(&ctx);
        if (major_status == GSS_S_COMPLETE) {
            *context_handle = ctx->gssc;
            ctx->gssc = GSS_C_NO_CONTEXT;
            iakerb_release_context(ctx);
        }
",,"@@ -47,6 +47,8 @@ struct _iakerb_ctx_id_rec {
     gss_ctx_id_t gssc;
     krb5_data conv;                     /* conversation for checksumming */
     unsigned int count;                 /* number of round trips */
+    int initiate;
+    int established;
     krb5_get_init_creds_opt *gic_opts;
 };
 
@@ -695,7 +697,7 @@ iakerb_get_initial_state(iakerb_ctx_id_t ctx,
  * Allocate and initialise an IAKERB context
  */
 static krb5_error_code
-iakerb_alloc_context(iakerb_ctx_id_t *pctx)
+iakerb_alloc_context(iakerb_ctx_id_t *pctx, int initiate)
 {
     iakerb_ctx_id_t ctx;
     krb5_error_code code;
@@ -709,6 +711,8 @@ iakerb_alloc_context(iakerb_ctx_id_t *pctx)
     ctx->magic = KG_IAKERB_CONTEXT;
     ctx->state = IAKERB_AS_REQ;
     ctx->count = 0;
+    ctx->initiate = initiate;
+    ctx->established = 0;
 
     code = krb5_gss_init_context(&ctx->k5c);
     if (code != 0)
@@ -732,31 +736,18 @@ iakerb_gss_delete_sec_context(OM_uint32 *minor_status,
                               gss_ctx_id_t *context_handle,
                               gss_buffer_t output_token)
 {
-    OM_uint32 major_status = GSS_S_COMPLETE;
+    iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;
 
     if (output_token != GSS_C_NO_BUFFER) {
         output_token->length = 0;
         output_token->value = NULL;
     }
 
     *minor_status = 0;
+    *context_handle = GSS_C_NO_CONTEXT;
+    iakerb_release_context(iakerb_ctx);
 
-    if (*context_handle != GSS_C_NO_CONTEXT) {
-        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;
-
-        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {
-            iakerb_release_context(iakerb_ctx);
-            *context_handle = GSS_C_NO_CONTEXT;
-        } else {
-            assert(iakerb_ctx->magic == KG_CONTEXT);
-
-            major_status = krb5_gss_delete_sec_context(minor_status,
-                                                       context_handle,
-                                                       output_token);
-        }
-    }
-
-    return major_status;
+    return GSS_S_COMPLETE;
 }
 
 static krb5_boolean
@@ -802,7 +793,7 @@ iakerb_gss_accept_sec_context(OM_uint32 *minor_status,
     int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);
 
     if (initialContextToken) {
-        code = iakerb_alloc_context(&ctx);
+        code = iakerb_alloc_context(&ctx, 0);
         if (code != 0)
             goto cleanup;
 
@@ -854,11 +845,8 @@ iakerb_gss_accept_sec_context(OM_uint32 *minor_status,
                                                        time_rec,
                                                        delegated_cred_handle,
                                                        &exts);
-        if (major_status == GSS_S_COMPLETE) {
-            *context_handle = ctx->gssc;
-            ctx->gssc = NULL;
-            iakerb_release_context(ctx);
-        }
+        if (major_status == GSS_S_COMPLETE)
+            ctx->established = 1;
         if (mech_type != NULL)
             *mech_type = (gss_OID)gss_mech_krb5;
     }
@@ -897,7 +885,7 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,
     int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);
 
     if (initialContextToken) {
-        code = iakerb_alloc_context(&ctx);
+        code = iakerb_alloc_context(&ctx, 1);
         if (code != 0) {
             *minor_status = code;
             goto cleanup;
@@ -983,11 +971,8 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,
                                                      ret_flags,
                                                      time_rec,
                                                      &exts);
-        if (major_status == GSS_S_COMPLETE) {
-            *context_handle = ctx->gssc;
-            ctx->gssc = GSS_C_NO_CONTEXT;
-            iakerb_release_context(ctx);
-        }
+        if (major_status == GSS_S_COMPLETE)
+            ctx->established = 1;
         if (actual_mech_type != NULL)
             *actual_mech_type = (gss_OID)gss_mech_krb5;
     } else {
@@ -1010,3 +995,309 @@ iakerb_gss_init_sec_context(OM_uint32 *minor_status,
 
     return major_status;
 }
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_unwrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                  gss_buffer_t input_message_buffer,
+                  gss_buffer_t output_message_buffer, int *conf_state,
+                  gss_qop_t *qop_state)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_unwrap(minor_status, ctx->gssc, input_message_buffer,
+                           output_message_buffer, conf_state, qop_state);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_wrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                int conf_req_flag, gss_qop_t qop_req,
+                gss_buffer_t input_message_buffer, int *conf_state,
+                gss_buffer_t output_message_buffer)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_wrap(minor_status, ctx->gssc, conf_req_flag, qop_req,
+                         input_message_buffer, conf_state,
+                         output_message_buffer);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_process_context_token(OM_uint32 *minor_status,
+                                 const gss_ctx_id_t context_handle,
+                                 const gss_buffer_t token_buffer)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_DEFECTIVE_TOKEN;
+
+    return krb5_gss_process_context_token(minor_status, ctx->gssc,
+                                          token_buffer);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_context_time(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                        OM_uint32 *time_rec)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_context_time(minor_status, ctx->gssc, time_rec);
+}
+
+#ifndef LEAN_CLIENT
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_export_sec_context(OM_uint32 *minor_status,
+                              gss_ctx_id_t *context_handle,
+                              gss_buffer_t interprocess_token)
+{
+    OM_uint32 maj;
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    /* We don't currently support exporting partially established contexts. */
+    if (!ctx->established)
+        return GSS_S_UNAVAILABLE;
+
+    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,
+                                      interprocess_token);
+    if (ctx->gssc == GSS_C_NO_CONTEXT) {
+        iakerb_release_context(ctx);
+        *context_handle = GSS_C_NO_CONTEXT;
+    }
+    return maj;
+}
+
+/*
+ * Until we implement partial context exports, there are no SPNEGO exported
+ * context tokens, only tokens for the underlying krb5 context.  So we do not
+ * need to implement an iakerb_gss_import_sec_context() yet; it would be
+ * unreachable except via a manually constructed token.
+ */
+
+#endif /* LEAN_CLIENT */
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_inquire_context(OM_uint32 *minor_status,
+                           gss_ctx_id_t context_handle, gss_name_t *src_name,
+                           gss_name_t *targ_name, OM_uint32 *lifetime_rec,
+                           gss_OID *mech_type, OM_uint32 *ctx_flags,
+                           int *initiate, int *opened)
+{
+    OM_uint32 ret;
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (src_name != NULL)
+        *src_name = GSS_C_NO_NAME;
+    if (targ_name != NULL)
+        *targ_name = GSS_C_NO_NAME;
+    if (lifetime_rec != NULL)
+        *lifetime_rec = 0;
+    if (mech_type != NULL)
+        *mech_type = (gss_OID)gss_mech_iakerb;
+    if (ctx_flags != NULL)
+        *ctx_flags = 0;
+    if (initiate != NULL)
+        *initiate = ctx->initiate;
+    if (opened != NULL)
+        *opened = ctx->established;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_COMPLETE;
+
+    ret = krb5_gss_inquire_context(minor_status, ctx->gssc, src_name,
+                                   targ_name, lifetime_rec, mech_type,
+                                   ctx_flags, initiate, opened);
+
+    if (!ctx->established) {
+        /* Report IAKERB as the mech OID until the context is established. */
+        if (mech_type != NULL)
+            *mech_type = (gss_OID)gss_mech_iakerb;
+
+        /* We don't support exporting partially-established contexts. */
+        if (ctx_flags != NULL)
+            *ctx_flags &= ~GSS_C_TRANS_FLAG;
+    }
+
+    return ret;
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_wrap_size_limit(OM_uint32 *minor_status,
+                           gss_ctx_id_t context_handle, int conf_req_flag,
+                           gss_qop_t qop_req, OM_uint32 req_output_size,
+                           OM_uint32 *max_input_size)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_wrap_size_limit(minor_status, ctx->gssc, conf_req_flag,
+                                    qop_req, req_output_size, max_input_size);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_get_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                   gss_qop_t qop_req, gss_buffer_t message_buffer,
+                   gss_buffer_t message_token)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_get_mic(minor_status, ctx->gssc, qop_req, message_buffer,
+                            message_token);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_verify_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                      gss_buffer_t msg_buffer, gss_buffer_t token_buffer,
+                      gss_qop_t *qop_state)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_verify_mic(minor_status, ctx->gssc, msg_buffer,
+                               token_buffer, qop_state);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_inquire_sec_context_by_oid(OM_uint32 *minor_status,
+                                      const gss_ctx_id_t context_handle,
+                                      const gss_OID desired_object,
+                                      gss_buffer_set_t *data_set)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_UNAVAILABLE;
+
+    return krb5_gss_inquire_sec_context_by_oid(minor_status, ctx->gssc,
+                                               desired_object, data_set);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_set_sec_context_option(OM_uint32 *minor_status,
+                                  gss_ctx_id_t *context_handle,
+                                  const gss_OID desired_object,
+                                  const gss_buffer_t value)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)*context_handle;
+
+    if (ctx == NULL || ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_UNAVAILABLE;
+
+    return krb5_gss_set_sec_context_option(minor_status, &ctx->gssc,
+                                           desired_object, value);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_wrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                    int conf_req_flag, gss_qop_t qop_req, int *conf_state,
+                    gss_iov_buffer_desc *iov, int iov_count)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_wrap_iov(minor_status, ctx->gssc, conf_req_flag, qop_req,
+                             conf_state, iov, iov_count);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_unwrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                      int *conf_state, gss_qop_t *qop_state,
+                      gss_iov_buffer_desc *iov, int iov_count)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_unwrap_iov(minor_status, ctx->gssc, conf_state, qop_state,
+                               iov, iov_count);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_wrap_iov_length(OM_uint32 *minor_status,
+                           gss_ctx_id_t context_handle, int conf_req_flag,
+                           gss_qop_t qop_req, int *conf_state,
+                           gss_iov_buffer_desc *iov, int iov_count)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_wrap_iov_length(minor_status, ctx->gssc, conf_req_flag,
+                                    qop_req, conf_state, iov, iov_count);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_pseudo_random(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                         int prf_key, const gss_buffer_t prf_in,
+                         ssize_t desired_output_len, gss_buffer_t prf_out)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_pseudo_random(minor_status, ctx->gssc, prf_key, prf_in,
+                                  desired_output_len, prf_out);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
+                       int iov_count)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_get_mic_iov(minor_status, ctx->gssc, qop_req, iov,
+                                iov_count);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
+                          gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
+                          int iov_count)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_verify_mic_iov(minor_status, ctx->gssc, qop_state, iov,
+                                   iov_count);
+}
+
+OM_uint32 KRB5_CALLCONV
+iakerb_gss_get_mic_iov_length(OM_uint32 *minor_status,
+                              gss_ctx_id_t context_handle, gss_qop_t qop_req,
+                              gss_iov_buffer_desc *iov, int iov_count)
+{
+    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;
+
+    if (ctx->gssc == GSS_C_NO_CONTEXT)
+        return GSS_S_NO_CONTEXT;
+
+    return krb5_gss_get_mic_iov_length(minor_status, ctx->gssc, qop_req, iov,
+                                       iov_count);
+}",krb5,e04f0283516e80d2f93366e0d479d13c9b5c8c2a,b51b33f2bc5d1497ddf5bd107f791c101695000d,1,"iakerb_gss_init_sec_context(OM_uint32 *minor_status,
                            gss_cred_id_t claimant_cred_handle,
                            gss_ctx_id_t *context_handle,
                            gss_name_t target_name,
                            gss_OID mech_type,
                            OM_uint32 req_flags,
                            OM_uint32 time_req,
                            gss_channel_bindings_t input_chan_bindings,
                            gss_buffer_t input_token,
                            gss_OID *actual_mech_type,
                            gss_buffer_t output_token,
                            OM_uint32 *ret_flags,
                            OM_uint32 *time_rec)
{
    OM_uint32 major_status = GSS_S_FAILURE;
    krb5_error_code code;
    iakerb_ctx_id_t ctx;
    krb5_gss_cred_id_t kcred;
    krb5_gss_name_t kname;
    krb5_boolean cred_locked = FALSE;
     int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);
 
     if (initialContextToken) {
//flaw_line_below:
        code = iakerb_alloc_context(&ctx);
//fix_flaw_line_below:
//        code = iakerb_alloc_context(&ctx, 1);
         if (code != 0) {
             *minor_status = code;
             goto cleanup;
        }
        if (claimant_cred_handle == GSS_C_NO_CREDENTIAL) {
            major_status = iakerb_gss_acquire_cred(minor_status, NULL,
                                                   GSS_C_INDEFINITE,
                                                   GSS_C_NULL_OID_SET,
                                                   GSS_C_INITIATE,
                                                   &ctx->defcred, NULL, NULL);
            if (GSS_ERROR(major_status))
                goto cleanup;
            claimant_cred_handle = ctx->defcred;
        }
    } else {
        ctx = (iakerb_ctx_id_t)*context_handle;
        if (claimant_cred_handle == GSS_C_NO_CREDENTIAL)
            claimant_cred_handle = ctx->defcred;
    }

    kname = (krb5_gss_name_t)target_name;

    major_status = kg_cred_resolve(minor_status, ctx->k5c,
                                   claimant_cred_handle, target_name);
    if (GSS_ERROR(major_status))
        goto cleanup;
    cred_locked = TRUE;
    kcred = (krb5_gss_cred_id_t)claimant_cred_handle;

    major_status = GSS_S_FAILURE;

    if (initialContextToken) {
        code = iakerb_get_initial_state(ctx, kcred, kname, time_req,
                                        &ctx->state);
        if (code != 0) {
            *minor_status = code;
            goto cleanup;
        }
        *context_handle = (gss_ctx_id_t)ctx;
    }

    if (ctx->state != IAKERB_AP_REQ) {
        /* We need to do IAKERB. */
        code = iakerb_initiator_step(ctx,
                                     kcred,
                                     kname,
                                     time_req,
                                     input_token,
                                     output_token);
        if (code == KRB5_BAD_MSIZE)
            major_status = GSS_S_DEFECTIVE_TOKEN;
        if (code != 0) {
            *minor_status = code;
            goto cleanup;
        }
    }

    if (ctx->state == IAKERB_AP_REQ) {
        krb5_gss_ctx_ext_rec exts;

        if (cred_locked) {
            k5_mutex_unlock(&kcred->lock);
            cred_locked = FALSE;
        }

        iakerb_make_exts(ctx, &exts);

        if (ctx->gssc == GSS_C_NO_CONTEXT)
            input_token = GSS_C_NO_BUFFER;

        /* IAKERB is finished, or we skipped to Kerberos directly. */
        major_status = krb5_gss_init_sec_context_ext(minor_status,
                                                     (gss_cred_id_t) kcred,
                                                     &ctx->gssc,
                                                     target_name,
                                                     (gss_OID)gss_mech_iakerb,
                                                     req_flags,
                                                     time_req,
                                                     input_chan_bindings,
                                                     input_token,
                                                     NULL,
                                                     output_token,
                                                      ret_flags,
                                                      time_rec,
                                                      &exts);
//flaw_line_below:
        if (major_status == GSS_S_COMPLETE) {
//flaw_line_below:
            *context_handle = ctx->gssc;
//flaw_line_below:
            ctx->gssc = GSS_C_NO_CONTEXT;
//flaw_line_below:
            iakerb_release_context(ctx);
//flaw_line_below:
        }
//fix_flaw_line_below:
//        if (major_status == GSS_S_COMPLETE)
//fix_flaw_line_below:
//            ctx->established = 1;
         if (actual_mech_type != NULL)
             *actual_mech_type = (gss_OID)gss_mech_krb5;
     } else {
        if (actual_mech_type != NULL)
            *actual_mech_type = (gss_OID)gss_mech_iakerb;
        if (ret_flags != NULL)
            *ret_flags = 0;
        if (time_rec != NULL)
            *time_rec = 0;
        major_status = GSS_S_CONTINUE_NEEDED;
    }

cleanup:
    if (cred_locked)
        k5_mutex_unlock(&kcred->lock);
    if (initialContextToken && GSS_ERROR(major_status)) {
        iakerb_release_context(ctx);
        *context_handle = GSS_C_NO_CONTEXT;
    }
 
     return major_status;
 }
"
2083,179819,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,1,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",1,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","acc_ctx_hints(OM_uint32 *minor_status,
	      gss_ctx_id_t *ctx,
	      spnego_gss_cred_id_t spcred,
	      gss_buffer_t *mechListMIC,
	      OM_uint32 *negState,
	      send_token_flag *return_token)
{
	OM_uint32 tmpmin, ret;
	gss_OID_set supported_mechSet;
	spnego_gss_ctx_id_t sc = NULL;

	*mechListMIC = GSS_C_NO_BUFFER;
	supported_mechSet = GSS_C_NO_OID_SET;
	*return_token = NO_TOKEN_SEND;
	*negState = REJECT;
	*minor_status = 0;

	/* A hint request must be the first token received. */
	if (*ctx != GSS_C_NO_CONTEXT)
	    return GSS_S_DEFECTIVE_TOKEN;

	ret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,
				   &supported_mechSet);
	if (ret != GSS_S_COMPLETE)
		goto cleanup;

	ret = make_NegHints(minor_status, mechListMIC);
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
	}
	if (put_mech_set(supported_mechSet, &sc->DER_mechTypes) < 0) {
		ret = GSS_S_FAILURE;
		goto cleanup;
	}
	sc->internal_mech = GSS_C_NO_OID;

	*negState = ACCEPT_INCOMPLETE;
	*return_token = INIT_TOKEN_SEND;
	sc->firstpass = 1;
	*ctx = (gss_ctx_id_t)sc;
	sc = NULL;
	ret = GSS_S_COMPLETE;

cleanup:
	release_spnego_ctx(&sc);
	gss_release_oid_set(&tmpmin, &supported_mechSet);

	return ret;
}
","acc_ctx_hints(OM_uint32 *minor_status,
	      gss_ctx_id_t *ctx,
	      spnego_gss_cred_id_t spcred,
	      gss_buffer_t *mechListMIC,
	      OM_uint32 *negState,
	      send_token_flag *return_token)
{
	OM_uint32 tmpmin, ret;
	gss_OID_set supported_mechSet;
	spnego_gss_ctx_id_t sc = NULL;

	*mechListMIC = GSS_C_NO_BUFFER;
	supported_mechSet = GSS_C_NO_OID_SET;
	*return_token = NO_TOKEN_SEND;
	*negState = REJECT;
	*minor_status = 0;

	/* A hint request must be the first token received. */
	if (*ctx != GSS_C_NO_CONTEXT)
	    return GSS_S_DEFECTIVE_TOKEN;

	ret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,
				   &supported_mechSet);
	if (ret != GSS_S_COMPLETE)
		goto cleanup;

	ret = make_NegHints(minor_status, mechListMIC);
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
	sc = create_spnego_ctx();
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
	}
	if (put_mech_set(supported_mechSet, &sc->DER_mechTypes) < 0) {
		ret = GSS_S_FAILURE;
		goto cleanup;
	}
	sc->internal_mech = GSS_C_NO_OID;

	*negState = ACCEPT_INCOMPLETE;
	*return_token = INIT_TOKEN_SEND;
	sc->firstpass = 1;
	*ctx = (gss_ctx_id_t)sc;
	sc = NULL;
	ret = GSS_S_COMPLETE;

cleanup:
	release_spnego_ctx(&sc);
	gss_release_oid_set(&tmpmin, &supported_mechSet);

	return ret;
}
",C,"	sc = create_spnego_ctx(0);
","	sc = create_spnego_ctx();
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"acc_ctx_hints(OM_uint32 *minor_status,
	      gss_ctx_id_t *ctx,
	      spnego_gss_cred_id_t spcred,
	      gss_buffer_t *mechListMIC,
	      OM_uint32 *negState,
	      send_token_flag *return_token)
{
	OM_uint32 tmpmin, ret;
	gss_OID_set supported_mechSet;
	spnego_gss_ctx_id_t sc = NULL;

	*mechListMIC = GSS_C_NO_BUFFER;
	supported_mechSet = GSS_C_NO_OID_SET;
	*return_token = NO_TOKEN_SEND;
	*negState = REJECT;
	*minor_status = 0;

	/* A hint request must be the first token received. */
	if (*ctx != GSS_C_NO_CONTEXT)
	    return GSS_S_DEFECTIVE_TOKEN;

	ret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,
				   &supported_mechSet);
	if (ret != GSS_S_COMPLETE)
		goto cleanup;

	ret = make_NegHints(minor_status, mechListMIC);
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
//flaw_line_below:
	sc = create_spnego_ctx();
//fix_flaw_line_below:
//	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
	}
	if (put_mech_set(supported_mechSet, &sc->DER_mechTypes) < 0) {
		ret = GSS_S_FAILURE;
		goto cleanup;
	}
	sc->internal_mech = GSS_C_NO_OID;

	*negState = ACCEPT_INCOMPLETE;
	*return_token = INIT_TOKEN_SEND;
	sc->firstpass = 1;
	*ctx = (gss_ctx_id_t)sc;
	sc = NULL;
	ret = GSS_S_COMPLETE;

cleanup:
	release_spnego_ctx(&sc);
	gss_release_oid_set(&tmpmin, &supported_mechSet);

	return ret;
}
"
2084,179820,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,1,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",1,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","acc_ctx_new(OM_uint32 *minor_status,
	    gss_buffer_t buf,
	    gss_ctx_id_t *ctx,
	    spnego_gss_cred_id_t spcred,
	    gss_buffer_t *mechToken,
	    gss_buffer_t *mechListMIC,
	    OM_uint32 *negState,
	    send_token_flag *return_token)
{
	OM_uint32 tmpmin, ret, req_flags;
	gss_OID_set supported_mechSet, mechTypes;
	gss_buffer_desc der_mechTypes;
	gss_OID mech_wanted;
	spnego_gss_ctx_id_t sc = NULL;

	ret = GSS_S_DEFECTIVE_TOKEN;
	der_mechTypes.length = 0;
	der_mechTypes.value = NULL;
	*mechToken = *mechListMIC = GSS_C_NO_BUFFER;
	supported_mechSet = mechTypes = GSS_C_NO_OID_SET;
	*return_token = ERROR_TOKEN_SEND;
	*negState = REJECT;
	*minor_status = 0;

	ret = get_negTokenInit(minor_status, buf, &der_mechTypes,
			       &mechTypes, &req_flags,
			       mechToken, mechListMIC);
	if (ret != GSS_S_COMPLETE) {
		goto cleanup;
	}
	ret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,
				   &supported_mechSet);
	if (ret != GSS_S_COMPLETE) {
		*return_token = NO_TOKEN_SEND;
		goto cleanup;
	}
	/*
	 * Select the best match between the list of mechs
	 * that the initiator requested and the list that
	 * the acceptor will support.
	 */
	mech_wanted = negotiate_mech(supported_mechSet, mechTypes, negState);
	if (*negState == REJECT) {
		ret = GSS_S_BAD_MECH;
		goto cleanup;
	}
	sc = (spnego_gss_ctx_id_t)*ctx;
	if (sc != NULL) {
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
		goto cleanup;
	}
	sc->mech_set = mechTypes;
	mechTypes = GSS_C_NO_OID_SET;
	sc->internal_mech = mech_wanted;
	sc->DER_mechTypes = der_mechTypes;
	der_mechTypes.length = 0;
	der_mechTypes.value = NULL;

	if (*negState == REQUEST_MIC)
		sc->mic_reqd = 1;

	*return_token = INIT_TOKEN_SEND;
	sc->firstpass = 1;
	*ctx = (gss_ctx_id_t)sc;
	ret = GSS_S_COMPLETE;
cleanup:
	gss_release_oid_set(&tmpmin, &mechTypes);
	gss_release_oid_set(&tmpmin, &supported_mechSet);
	if (der_mechTypes.length != 0)
		gss_release_buffer(&tmpmin, &der_mechTypes);

	return ret;
}
","acc_ctx_new(OM_uint32 *minor_status,
	    gss_buffer_t buf,
	    gss_ctx_id_t *ctx,
	    spnego_gss_cred_id_t spcred,
	    gss_buffer_t *mechToken,
	    gss_buffer_t *mechListMIC,
	    OM_uint32 *negState,
	    send_token_flag *return_token)
{
	OM_uint32 tmpmin, ret, req_flags;
	gss_OID_set supported_mechSet, mechTypes;
	gss_buffer_desc der_mechTypes;
	gss_OID mech_wanted;
	spnego_gss_ctx_id_t sc = NULL;

	ret = GSS_S_DEFECTIVE_TOKEN;
	der_mechTypes.length = 0;
	der_mechTypes.value = NULL;
	*mechToken = *mechListMIC = GSS_C_NO_BUFFER;
	supported_mechSet = mechTypes = GSS_C_NO_OID_SET;
	*return_token = ERROR_TOKEN_SEND;
	*negState = REJECT;
	*minor_status = 0;

	ret = get_negTokenInit(minor_status, buf, &der_mechTypes,
			       &mechTypes, &req_flags,
			       mechToken, mechListMIC);
	if (ret != GSS_S_COMPLETE) {
		goto cleanup;
	}
	ret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,
				   &supported_mechSet);
	if (ret != GSS_S_COMPLETE) {
		*return_token = NO_TOKEN_SEND;
		goto cleanup;
	}
	/*
	 * Select the best match between the list of mechs
	 * that the initiator requested and the list that
	 * the acceptor will support.
	 */
	mech_wanted = negotiate_mech(supported_mechSet, mechTypes, negState);
	if (*negState == REJECT) {
		ret = GSS_S_BAD_MECH;
		goto cleanup;
	}
	sc = (spnego_gss_ctx_id_t)*ctx;
	if (sc != NULL) {
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
		sc = create_spnego_ctx();
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
		goto cleanup;
	}
	sc->mech_set = mechTypes;
	mechTypes = GSS_C_NO_OID_SET;
	sc->internal_mech = mech_wanted;
	sc->DER_mechTypes = der_mechTypes;
	der_mechTypes.length = 0;
	der_mechTypes.value = NULL;

	if (*negState == REQUEST_MIC)
		sc->mic_reqd = 1;

	*return_token = INIT_TOKEN_SEND;
	sc->firstpass = 1;
	*ctx = (gss_ctx_id_t)sc;
	ret = GSS_S_COMPLETE;
cleanup:
	gss_release_oid_set(&tmpmin, &mechTypes);
	gss_release_oid_set(&tmpmin, &supported_mechSet);
	if (der_mechTypes.length != 0)
		gss_release_buffer(&tmpmin, &der_mechTypes);

	return ret;
}
",C,"		sc = create_spnego_ctx(0);
","		sc = create_spnego_ctx();
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"acc_ctx_new(OM_uint32 *minor_status,
	    gss_buffer_t buf,
	    gss_ctx_id_t *ctx,
	    spnego_gss_cred_id_t spcred,
	    gss_buffer_t *mechToken,
	    gss_buffer_t *mechListMIC,
	    OM_uint32 *negState,
	    send_token_flag *return_token)
{
	OM_uint32 tmpmin, ret, req_flags;
	gss_OID_set supported_mechSet, mechTypes;
	gss_buffer_desc der_mechTypes;
	gss_OID mech_wanted;
	spnego_gss_ctx_id_t sc = NULL;

	ret = GSS_S_DEFECTIVE_TOKEN;
	der_mechTypes.length = 0;
	der_mechTypes.value = NULL;
	*mechToken = *mechListMIC = GSS_C_NO_BUFFER;
	supported_mechSet = mechTypes = GSS_C_NO_OID_SET;
	*return_token = ERROR_TOKEN_SEND;
	*negState = REJECT;
	*minor_status = 0;

	ret = get_negTokenInit(minor_status, buf, &der_mechTypes,
			       &mechTypes, &req_flags,
			       mechToken, mechListMIC);
	if (ret != GSS_S_COMPLETE) {
		goto cleanup;
	}
	ret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,
				   &supported_mechSet);
	if (ret != GSS_S_COMPLETE) {
		*return_token = NO_TOKEN_SEND;
		goto cleanup;
	}
	/*
	 * Select the best match between the list of mechs
	 * that the initiator requested and the list that
	 * the acceptor will support.
	 */
	mech_wanted = negotiate_mech(supported_mechSet, mechTypes, negState);
	if (*negState == REJECT) {
		ret = GSS_S_BAD_MECH;
		goto cleanup;
	}
	sc = (spnego_gss_ctx_id_t)*ctx;
	if (sc != NULL) {
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
//flaw_line_below:
		sc = create_spnego_ctx();
//fix_flaw_line_below:
//		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
		goto cleanup;
	}
	sc->mech_set = mechTypes;
	mechTypes = GSS_C_NO_OID_SET;
	sc->internal_mech = mech_wanted;
	sc->DER_mechTypes = der_mechTypes;
	der_mechTypes.length = 0;
	der_mechTypes.value = NULL;

	if (*negState == REQUEST_MIC)
		sc->mic_reqd = 1;

	*return_token = INIT_TOKEN_SEND;
	sc->firstpass = 1;
	*ctx = (gss_ctx_id_t)sc;
	ret = GSS_S_COMPLETE;
cleanup:
	gss_release_oid_set(&tmpmin, &mechTypes);
	gss_release_oid_set(&tmpmin, &supported_mechSet);
	if (der_mechTypes.length != 0)
		gss_release_buffer(&tmpmin, &der_mechTypes);

	return ret;
}
"
2085,179821,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,3,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",0,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","create_spnego_ctx(void)
create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
		malloc(sizeof (spnego_gss_ctx_id_rec));

	if (spnego_ctx == NULL) {
		return (NULL);
	}

	spnego_ctx->magic_num = SPNEGO_MAGIC_ID;
	spnego_ctx->ctx_handle = GSS_C_NO_CONTEXT;
	spnego_ctx->mech_set = NULL;
	spnego_ctx->internal_mech = NULL;
	spnego_ctx->optionStr = NULL;
	spnego_ctx->DER_mechTypes.length = 0;
	spnego_ctx->DER_mechTypes.value = NULL;
	spnego_ctx->default_cred = GSS_C_NO_CREDENTIAL;
	spnego_ctx->mic_reqd = 0;
	spnego_ctx->mic_sent = 0;
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
	spnego_ctx->opened = 0;
	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
	check_spnego_options(spnego_ctx);

	return (spnego_ctx);
}
","create_spnego_ctx(void)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
		malloc(sizeof (spnego_gss_ctx_id_rec));

	if (spnego_ctx == NULL) {
		return (NULL);
	}

	spnego_ctx->magic_num = SPNEGO_MAGIC_ID;
	spnego_ctx->ctx_handle = GSS_C_NO_CONTEXT;
	spnego_ctx->mech_set = NULL;
	spnego_ctx->internal_mech = NULL;
	spnego_ctx->optionStr = NULL;
	spnego_ctx->DER_mechTypes.length = 0;
	spnego_ctx->DER_mechTypes.value = NULL;
	spnego_ctx->default_cred = GSS_C_NO_CREDENTIAL;
	spnego_ctx->mic_reqd = 0;
	spnego_ctx->mic_sent = 0;
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
	check_spnego_options(spnego_ctx);

	return (spnego_ctx);
}
",C,"create_spnego_ctx(int initiate)
	spnego_ctx->opened = 0;
	spnego_ctx->initiate = initiate;
",,,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"create_spnego_ctx(void)
//fix_flaw_line_below:
//create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
		malloc(sizeof (spnego_gss_ctx_id_rec));

	if (spnego_ctx == NULL) {
		return (NULL);
	}

	spnego_ctx->magic_num = SPNEGO_MAGIC_ID;
	spnego_ctx->ctx_handle = GSS_C_NO_CONTEXT;
	spnego_ctx->mech_set = NULL;
	spnego_ctx->internal_mech = NULL;
	spnego_ctx->optionStr = NULL;
	spnego_ctx->DER_mechTypes.length = 0;
	spnego_ctx->DER_mechTypes.value = NULL;
	spnego_ctx->default_cred = GSS_C_NO_CREDENTIAL;
	spnego_ctx->mic_reqd = 0;
	spnego_ctx->mic_sent = 0;
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
//fix_flaw_line_below:
//	spnego_ctx->opened = 0;
//fix_flaw_line_below:
//	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
	check_spnego_options(spnego_ctx);

	return (spnego_ctx);
}
"
2086,179822,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,2,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",5,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","init_ctx_new(OM_uint32 *minor_status,
	     spnego_gss_cred_id_t spcred,
	     gss_ctx_id_t *ctx,
	     send_token_flag *tokflag)
{
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
	/* determine negotiation mech set */
	ret = get_negotiable_mechs(minor_status, spcred, GSS_C_INITIATE,
				   &sc->mech_set);
	if (ret != GSS_S_COMPLETE)
		goto cleanup;

	/* Set an initial internal mech to make the first context token. */
	sc->internal_mech = &sc->mech_set->elements[0];

	if (put_mech_set(sc->mech_set, &sc->DER_mechTypes) < 0) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}

 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
	*tokflag = INIT_TOKEN_SEND;
	ret = GSS_S_CONTINUE_NEEDED;

cleanup:
	release_spnego_ctx(&sc);
	return ret;
}
","init_ctx_new(OM_uint32 *minor_status,
	     spnego_gss_cred_id_t spcred,
	     gss_ctx_id_t *ctx,
	     send_token_flag *tokflag)
{
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
	sc = create_spnego_ctx();
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
	/* determine negotiation mech set */
	ret = get_negotiable_mechs(minor_status, spcred, GSS_C_INITIATE,
				   &sc->mech_set);
	if (ret != GSS_S_COMPLETE)
		goto cleanup;

	/* Set an initial internal mech to make the first context token. */
	sc->internal_mech = &sc->mech_set->elements[0];

	if (put_mech_set(sc->mech_set, &sc->DER_mechTypes) < 0) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
	/*
	 * The actual context is not yet determined, set the output
	 * context handle to refer to the spnego context itself.
	 */
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
	*tokflag = INIT_TOKEN_SEND;
	ret = GSS_S_CONTINUE_NEEDED;

cleanup:
	release_spnego_ctx(&sc);
	return ret;
}
",C,"	sc = create_spnego_ctx(1);

","	sc = create_spnego_ctx();
	/*
	 * The actual context is not yet determined, set the output
	 * context handle to refer to the spnego context itself.
	 */
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"init_ctx_new(OM_uint32 *minor_status,
	     spnego_gss_cred_id_t spcred,
	     gss_ctx_id_t *ctx,
	     send_token_flag *tokflag)
{
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
//flaw_line_below:
	sc = create_spnego_ctx();
//fix_flaw_line_below:
//	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
	/* determine negotiation mech set */
	ret = get_negotiable_mechs(minor_status, spcred, GSS_C_INITIATE,
				   &sc->mech_set);
	if (ret != GSS_S_COMPLETE)
		goto cleanup;

	/* Set an initial internal mech to make the first context token. */
	sc->internal_mech = &sc->mech_set->elements[0];

	if (put_mech_set(sc->mech_set, &sc->DER_mechTypes) < 0) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
//flaw_line_below:
	/*
//flaw_line_below:
	 * The actual context is not yet determined, set the output
//flaw_line_below:
	 * context handle to refer to the spnego context itself.
//flaw_line_below:
	 */
//fix_flaw_line_below:
//
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
	*tokflag = INIT_TOKEN_SEND;
	ret = GSS_S_CONTINUE_NEEDED;

cleanup:
	release_spnego_ctx(&sc);
	return ret;
}
"
2087,179823,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,1,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",2,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","spnego_gss_accept_sec_context(
			    OM_uint32 *minor_status,
			    gss_ctx_id_t *context_handle,
			    gss_cred_id_t verifier_cred_handle,
			    gss_buffer_t input_token,
			    gss_channel_bindings_t input_chan_bindings,
			    gss_name_t *src_name,
			    gss_OID *mech_type,
			    gss_buffer_t output_token,
			    OM_uint32 *ret_flags,
			    OM_uint32 *time_rec,
			    gss_cred_id_t *delegated_cred_handle)
{
	OM_uint32 ret, tmpmin, negState;
	send_token_flag return_token;
	gss_buffer_t mechtok_in, mic_in, mic_out;
	gss_buffer_desc mechtok_out = GSS_C_EMPTY_BUFFER;
	spnego_gss_ctx_id_t sc = NULL;
	spnego_gss_cred_id_t spcred = NULL;
	int sendTokenInit = 0, tmpret;

	mechtok_in = mic_in = mic_out = GSS_C_NO_BUFFER;

	/*
	 * This function works in three steps:
	 *
	 *   1. Perform mechanism negotiation.
	 *   2. Invoke the negotiated mech's gss_accept_sec_context function
	 *      and examine the results.
	 *   3. Process or generate MICs if necessary.
	 *
	 * Step one determines whether the negotiation requires a MIC exchange,
	 * while steps two and three share responsibility for determining when
	 * the exchange is complete.  If the selected mech completes in this
	 * call and no MIC exchange is expected, then step 2 will decide.  If a
	 * MIC exchange is expected, then step 3 will decide.  If an error
	 * occurs in any step, the exchange will be aborted, possibly with an
	 * error token.
	 *
	 * negState determines the state of the negotiation, and is
	 * communicated to the acceptor if a continuing token is sent.
	 * return_token is used to indicate what type of token, if any, should
	 * be generated.
	 */

	/* Validate arguments. */
	if (minor_status != NULL)
		*minor_status = 0;
	if (output_token != GSS_C_NO_BUFFER) {
		output_token->length = 0;
		output_token->value = NULL;
	}

	if (minor_status == NULL ||
	    output_token == GSS_C_NO_BUFFER ||
	    context_handle == NULL)
		return GSS_S_CALL_INACCESSIBLE_WRITE;

	if (input_token == GSS_C_NO_BUFFER)
		return GSS_S_CALL_INACCESSIBLE_READ;

	/* Step 1: Perform mechanism negotiation. */
	sc = (spnego_gss_ctx_id_t)*context_handle;
	spcred = (spnego_gss_cred_id_t)verifier_cred_handle;
	if (sc == NULL || sc->internal_mech == GSS_C_NO_OID) {
		/* Process an initial token or request for NegHints. */
		if (src_name != NULL)
			*src_name = GSS_C_NO_NAME;
		if (mech_type != NULL)
			*mech_type = GSS_C_NO_OID;
		if (time_rec != NULL)
			*time_rec = 0;
		if (ret_flags != NULL)
			*ret_flags = 0;
		if (delegated_cred_handle != NULL)
			*delegated_cred_handle = GSS_C_NO_CREDENTIAL;
		if (input_token->length == 0) {
			ret = acc_ctx_hints(minor_status,
					    context_handle, spcred,
					    &mic_out,
					    &negState,
					    &return_token);
			if (ret != GSS_S_COMPLETE)
				goto cleanup;
			sendTokenInit = 1;
			ret = GSS_S_CONTINUE_NEEDED;
		} else {
			/* Can set negState to REQUEST_MIC */
			ret = acc_ctx_new(minor_status, input_token,
					  context_handle, spcred,
					  &mechtok_in, &mic_in,
					  &negState, &return_token);
			if (ret != GSS_S_COMPLETE)
				goto cleanup;
			ret = GSS_S_CONTINUE_NEEDED;
		}
	} else {
		/* Process a response token.  Can set negState to
		 * ACCEPT_INCOMPLETE. */
		ret = acc_ctx_cont(minor_status, input_token,
				   context_handle, &mechtok_in,
				   &mic_in, &negState, &return_token);
		if (ret != GSS_S_COMPLETE)
			goto cleanup;
		ret = GSS_S_CONTINUE_NEEDED;
	}

	/* Step 2: invoke the negotiated mechanism's gss_accept_sec_context
	 * function. */
	sc = (spnego_gss_ctx_id_t)*context_handle;
	/*
	 * Handle mechtok_in and mic_in only if they are
	 * present in input_token.  If neither is present, whether
	 * this is an error depends on whether this is the first
	 * round-trip.  RET is set to a default value according to
	 * whether it is the first round-trip.
	 */
	if (negState != REQUEST_MIC && mechtok_in != GSS_C_NO_BUFFER) {
		ret = acc_ctx_call_acc(minor_status, sc, spcred,
				       mechtok_in, mech_type, &mechtok_out,
				       ret_flags, time_rec,
				       delegated_cred_handle,
				       &negState, &return_token);
	}

	/* Step 3: process or generate the MIC, if the negotiated mech is
	 * complete and supports MICs. */
	if (!HARD_ERROR(ret) && sc->mech_complete &&
	    (sc->ctx_flags & GSS_C_INTEG_FLAG)) {

		ret = handle_mic(minor_status, mic_in,
				 (mechtok_out.length != 0),
				 sc, &mic_out,
				 &negState, &return_token);
	}
cleanup:
	if (return_token == INIT_TOKEN_SEND && sendTokenInit) {
		assert(sc != NULL);
		tmpret = make_spnego_tokenInit_msg(sc, 1, mic_out, 0,
						   GSS_C_NO_BUFFER,
						   return_token, output_token);
		if (tmpret < 0)
			ret = GSS_S_FAILURE;
	} else if (return_token != NO_TOKEN_SEND &&
		   return_token != CHECK_MIC) {
		tmpret = make_spnego_tokenTarg_msg(negState,
						   sc ? sc->internal_mech :
						   GSS_C_NO_OID,
						   &mechtok_out, mic_out,
						   return_token,
						   output_token);
		if (tmpret < 0)
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
					       GSS_C_NO_BUFFER);
			release_spnego_ctx(&sc);
		}
		*context_handle = GSS_C_NO_CONTEXT;
	}
	gss_release_buffer(&tmpmin, &mechtok_out);
	if (mechtok_in != GSS_C_NO_BUFFER) {
		gss_release_buffer(&tmpmin, mechtok_in);
		free(mechtok_in);
	}
	if (mic_in != GSS_C_NO_BUFFER) {
		gss_release_buffer(&tmpmin, mic_in);
		free(mic_in);
	}
	if (mic_out != GSS_C_NO_BUFFER) {
		gss_release_buffer(&tmpmin, mic_out);
		free(mic_out);
	}
	return ret;
}
","spnego_gss_accept_sec_context(
			    OM_uint32 *minor_status,
			    gss_ctx_id_t *context_handle,
			    gss_cred_id_t verifier_cred_handle,
			    gss_buffer_t input_token,
			    gss_channel_bindings_t input_chan_bindings,
			    gss_name_t *src_name,
			    gss_OID *mech_type,
			    gss_buffer_t output_token,
			    OM_uint32 *ret_flags,
			    OM_uint32 *time_rec,
			    gss_cred_id_t *delegated_cred_handle)
{
	OM_uint32 ret, tmpmin, negState;
	send_token_flag return_token;
	gss_buffer_t mechtok_in, mic_in, mic_out;
	gss_buffer_desc mechtok_out = GSS_C_EMPTY_BUFFER;
	spnego_gss_ctx_id_t sc = NULL;
	spnego_gss_cred_id_t spcred = NULL;
	int sendTokenInit = 0, tmpret;

	mechtok_in = mic_in = mic_out = GSS_C_NO_BUFFER;

	/*
	 * This function works in three steps:
	 *
	 *   1. Perform mechanism negotiation.
	 *   2. Invoke the negotiated mech's gss_accept_sec_context function
	 *      and examine the results.
	 *   3. Process or generate MICs if necessary.
	 *
	 * Step one determines whether the negotiation requires a MIC exchange,
	 * while steps two and three share responsibility for determining when
	 * the exchange is complete.  If the selected mech completes in this
	 * call and no MIC exchange is expected, then step 2 will decide.  If a
	 * MIC exchange is expected, then step 3 will decide.  If an error
	 * occurs in any step, the exchange will be aborted, possibly with an
	 * error token.
	 *
	 * negState determines the state of the negotiation, and is
	 * communicated to the acceptor if a continuing token is sent.
	 * return_token is used to indicate what type of token, if any, should
	 * be generated.
	 */

	/* Validate arguments. */
	if (minor_status != NULL)
		*minor_status = 0;
	if (output_token != GSS_C_NO_BUFFER) {
		output_token->length = 0;
		output_token->value = NULL;
	}

	if (minor_status == NULL ||
	    output_token == GSS_C_NO_BUFFER ||
	    context_handle == NULL)
		return GSS_S_CALL_INACCESSIBLE_WRITE;

	if (input_token == GSS_C_NO_BUFFER)
		return GSS_S_CALL_INACCESSIBLE_READ;

	/* Step 1: Perform mechanism negotiation. */
	sc = (spnego_gss_ctx_id_t)*context_handle;
	spcred = (spnego_gss_cred_id_t)verifier_cred_handle;
	if (sc == NULL || sc->internal_mech == GSS_C_NO_OID) {
		/* Process an initial token or request for NegHints. */
		if (src_name != NULL)
			*src_name = GSS_C_NO_NAME;
		if (mech_type != NULL)
			*mech_type = GSS_C_NO_OID;
		if (time_rec != NULL)
			*time_rec = 0;
		if (ret_flags != NULL)
			*ret_flags = 0;
		if (delegated_cred_handle != NULL)
			*delegated_cred_handle = GSS_C_NO_CREDENTIAL;
		if (input_token->length == 0) {
			ret = acc_ctx_hints(minor_status,
					    context_handle, spcred,
					    &mic_out,
					    &negState,
					    &return_token);
			if (ret != GSS_S_COMPLETE)
				goto cleanup;
			sendTokenInit = 1;
			ret = GSS_S_CONTINUE_NEEDED;
		} else {
			/* Can set negState to REQUEST_MIC */
			ret = acc_ctx_new(minor_status, input_token,
					  context_handle, spcred,
					  &mechtok_in, &mic_in,
					  &negState, &return_token);
			if (ret != GSS_S_COMPLETE)
				goto cleanup;
			ret = GSS_S_CONTINUE_NEEDED;
		}
	} else {
		/* Process a response token.  Can set negState to
		 * ACCEPT_INCOMPLETE. */
		ret = acc_ctx_cont(minor_status, input_token,
				   context_handle, &mechtok_in,
				   &mic_in, &negState, &return_token);
		if (ret != GSS_S_COMPLETE)
			goto cleanup;
		ret = GSS_S_CONTINUE_NEEDED;
	}

	/* Step 2: invoke the negotiated mechanism's gss_accept_sec_context
	 * function. */
	sc = (spnego_gss_ctx_id_t)*context_handle;
	/*
	 * Handle mechtok_in and mic_in only if they are
	 * present in input_token.  If neither is present, whether
	 * this is an error depends on whether this is the first
	 * round-trip.  RET is set to a default value according to
	 * whether it is the first round-trip.
	 */
	if (negState != REQUEST_MIC && mechtok_in != GSS_C_NO_BUFFER) {
		ret = acc_ctx_call_acc(minor_status, sc, spcred,
				       mechtok_in, mech_type, &mechtok_out,
				       ret_flags, time_rec,
				       delegated_cred_handle,
				       &negState, &return_token);
	}

	/* Step 3: process or generate the MIC, if the negotiated mech is
	 * complete and supports MICs. */
	if (!HARD_ERROR(ret) && sc->mech_complete &&
	    (sc->ctx_flags & GSS_C_INTEG_FLAG)) {

		ret = handle_mic(minor_status, mic_in,
				 (mechtok_out.length != 0),
				 sc, &mic_out,
				 &negState, &return_token);
	}
cleanup:
	if (return_token == INIT_TOKEN_SEND && sendTokenInit) {
		assert(sc != NULL);
		tmpret = make_spnego_tokenInit_msg(sc, 1, mic_out, 0,
						   GSS_C_NO_BUFFER,
						   return_token, output_token);
		if (tmpret < 0)
			ret = GSS_S_FAILURE;
	} else if (return_token != NO_TOKEN_SEND &&
		   return_token != CHECK_MIC) {
		tmpret = make_spnego_tokenTarg_msg(negState,
						   sc ? sc->internal_mech :
						   GSS_C_NO_OID,
						   &mechtok_out, mic_out,
						   return_token,
						   output_token);
		if (tmpret < 0)
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
					       GSS_C_NO_BUFFER);
			release_spnego_ctx(&sc);
		}
		*context_handle = GSS_C_NO_CONTEXT;
	}
	gss_release_buffer(&tmpmin, &mechtok_out);
	if (mechtok_in != GSS_C_NO_BUFFER) {
		gss_release_buffer(&tmpmin, mechtok_in);
		free(mechtok_in);
	}
	if (mic_in != GSS_C_NO_BUFFER) {
		gss_release_buffer(&tmpmin, mic_in);
		free(mic_in);
	}
	if (mic_out != GSS_C_NO_BUFFER) {
		gss_release_buffer(&tmpmin, mic_out);
		free(mic_out);
	}
	return ret;
}
",C,"		sc->opened = 1;
","		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
		release_spnego_ctx(&sc);
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"spnego_gss_accept_sec_context(
			    OM_uint32 *minor_status,
			    gss_ctx_id_t *context_handle,
			    gss_cred_id_t verifier_cred_handle,
			    gss_buffer_t input_token,
			    gss_channel_bindings_t input_chan_bindings,
			    gss_name_t *src_name,
			    gss_OID *mech_type,
			    gss_buffer_t output_token,
			    OM_uint32 *ret_flags,
			    OM_uint32 *time_rec,
			    gss_cred_id_t *delegated_cred_handle)
{
	OM_uint32 ret, tmpmin, negState;
	send_token_flag return_token;
	gss_buffer_t mechtok_in, mic_in, mic_out;
	gss_buffer_desc mechtok_out = GSS_C_EMPTY_BUFFER;
	spnego_gss_ctx_id_t sc = NULL;
	spnego_gss_cred_id_t spcred = NULL;
	int sendTokenInit = 0, tmpret;

	mechtok_in = mic_in = mic_out = GSS_C_NO_BUFFER;

	/*
	 * This function works in three steps:
	 *
	 *   1. Perform mechanism negotiation.
	 *   2. Invoke the negotiated mech's gss_accept_sec_context function
	 *      and examine the results.
	 *   3. Process or generate MICs if necessary.
	 *
	 * Step one determines whether the negotiation requires a MIC exchange,
	 * while steps two and three share responsibility for determining when
	 * the exchange is complete.  If the selected mech completes in this
	 * call and no MIC exchange is expected, then step 2 will decide.  If a
	 * MIC exchange is expected, then step 3 will decide.  If an error
	 * occurs in any step, the exchange will be aborted, possibly with an
	 * error token.
	 *
	 * negState determines the state of the negotiation, and is
	 * communicated to the acceptor if a continuing token is sent.
	 * return_token is used to indicate what type of token, if any, should
	 * be generated.
	 */

	/* Validate arguments. */
	if (minor_status != NULL)
		*minor_status = 0;
	if (output_token != GSS_C_NO_BUFFER) {
		output_token->length = 0;
		output_token->value = NULL;
	}

	if (minor_status == NULL ||
	    output_token == GSS_C_NO_BUFFER ||
	    context_handle == NULL)
		return GSS_S_CALL_INACCESSIBLE_WRITE;

	if (input_token == GSS_C_NO_BUFFER)
		return GSS_S_CALL_INACCESSIBLE_READ;

	/* Step 1: Perform mechanism negotiation. */
	sc = (spnego_gss_ctx_id_t)*context_handle;
	spcred = (spnego_gss_cred_id_t)verifier_cred_handle;
	if (sc == NULL || sc->internal_mech == GSS_C_NO_OID) {
		/* Process an initial token or request for NegHints. */
		if (src_name != NULL)
			*src_name = GSS_C_NO_NAME;
		if (mech_type != NULL)
			*mech_type = GSS_C_NO_OID;
		if (time_rec != NULL)
			*time_rec = 0;
		if (ret_flags != NULL)
			*ret_flags = 0;
		if (delegated_cred_handle != NULL)
			*delegated_cred_handle = GSS_C_NO_CREDENTIAL;
		if (input_token->length == 0) {
			ret = acc_ctx_hints(minor_status,
					    context_handle, spcred,
					    &mic_out,
					    &negState,
					    &return_token);
			if (ret != GSS_S_COMPLETE)
				goto cleanup;
			sendTokenInit = 1;
			ret = GSS_S_CONTINUE_NEEDED;
		} else {
			/* Can set negState to REQUEST_MIC */
			ret = acc_ctx_new(minor_status, input_token,
					  context_handle, spcred,
					  &mechtok_in, &mic_in,
					  &negState, &return_token);
			if (ret != GSS_S_COMPLETE)
				goto cleanup;
			ret = GSS_S_CONTINUE_NEEDED;
		}
	} else {
		/* Process a response token.  Can set negState to
		 * ACCEPT_INCOMPLETE. */
		ret = acc_ctx_cont(minor_status, input_token,
				   context_handle, &mechtok_in,
				   &mic_in, &negState, &return_token);
		if (ret != GSS_S_COMPLETE)
			goto cleanup;
		ret = GSS_S_CONTINUE_NEEDED;
	}

	/* Step 2: invoke the negotiated mechanism's gss_accept_sec_context
	 * function. */
	sc = (spnego_gss_ctx_id_t)*context_handle;
	/*
	 * Handle mechtok_in and mic_in only if they are
	 * present in input_token.  If neither is present, whether
	 * this is an error depends on whether this is the first
	 * round-trip.  RET is set to a default value according to
	 * whether it is the first round-trip.
	 */
	if (negState != REQUEST_MIC && mechtok_in != GSS_C_NO_BUFFER) {
		ret = acc_ctx_call_acc(minor_status, sc, spcred,
				       mechtok_in, mech_type, &mechtok_out,
				       ret_flags, time_rec,
				       delegated_cred_handle,
				       &negState, &return_token);
	}

	/* Step 3: process or generate the MIC, if the negotiated mech is
	 * complete and supports MICs. */
	if (!HARD_ERROR(ret) && sc->mech_complete &&
	    (sc->ctx_flags & GSS_C_INTEG_FLAG)) {

		ret = handle_mic(minor_status, mic_in,
				 (mechtok_out.length != 0),
				 sc, &mic_out,
				 &negState, &return_token);
	}
cleanup:
	if (return_token == INIT_TOKEN_SEND && sendTokenInit) {
		assert(sc != NULL);
		tmpret = make_spnego_tokenInit_msg(sc, 1, mic_out, 0,
						   GSS_C_NO_BUFFER,
						   return_token, output_token);
		if (tmpret < 0)
			ret = GSS_S_FAILURE;
	} else if (return_token != NO_TOKEN_SEND &&
		   return_token != CHECK_MIC) {
		tmpret = make_spnego_tokenTarg_msg(negState,
						   sc ? sc->internal_mech :
						   GSS_C_NO_OID,
						   &mechtok_out, mic_out,
						   return_token,
						   output_token);
		if (tmpret < 0)
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
//flaw_line_below:
		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
//fix_flaw_line_below:
//		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
//flaw_line_below:
		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
					       GSS_C_NO_BUFFER);
			release_spnego_ctx(&sc);
		}
		*context_handle = GSS_C_NO_CONTEXT;
	}
	gss_release_buffer(&tmpmin, &mechtok_out);
	if (mechtok_in != GSS_C_NO_BUFFER) {
		gss_release_buffer(&tmpmin, mechtok_in);
		free(mechtok_in);
	}
	if (mic_in != GSS_C_NO_BUFFER) {
		gss_release_buffer(&tmpmin, mic_in);
		free(mic_in);
	}
	if (mic_out != GSS_C_NO_BUFFER) {
		gss_release_buffer(&tmpmin, mic_out);
		free(mic_out);
	}
	return ret;
}
"
2088,179824,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,6,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",1,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","spnego_gss_complete_auth_token(
		OM_uint32 *minor_status,
		const gss_ctx_id_t context_handle,
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_UNAVAILABLE);

 	ret = gss_complete_auth_token(minor_status,
				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
","spnego_gss_complete_auth_token(
		OM_uint32 *minor_status,
		const gss_ctx_id_t context_handle,
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
 	ret = gss_complete_auth_token(minor_status,
				      context_handle,
 				      input_message_buffer);
 	return (ret);
 }
",C,"	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_UNAVAILABLE);

				      sc->ctx_handle,
","				      context_handle,
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"spnego_gss_complete_auth_token(
		OM_uint32 *minor_status,
		const gss_ctx_id_t context_handle,
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
//fix_flaw_line_below:
//	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//		return (GSS_S_UNAVAILABLE);
//fix_flaw_line_below:
//
 	ret = gss_complete_auth_token(minor_status,
//flaw_line_below:
				      context_handle,
//fix_flaw_line_below:
//				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
"
2089,179825,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,6,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",1,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","spnego_gss_context_time(
			OM_uint32	*minor_status,
			const gss_ctx_id_t context_handle,
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_NO_CONTEXT);

 	ret = gss_context_time(minor_status,
			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
","spnego_gss_context_time(
			OM_uint32	*minor_status,
			const gss_ctx_id_t context_handle,
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
 	ret = gss_context_time(minor_status,
			    context_handle,
 			    time_rec);
 	return (ret);
 }
",C,"	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_NO_CONTEXT);

			    sc->ctx_handle,
","			    context_handle,
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"spnego_gss_context_time(
			OM_uint32	*minor_status,
			const gss_ctx_id_t context_handle,
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
//fix_flaw_line_below:
//	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//		return (GSS_S_NO_CONTEXT);
//fix_flaw_line_below:
//
 	ret = gss_context_time(minor_status,
//flaw_line_below:
			    context_handle,
//fix_flaw_line_below:
//			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
"
2090,179826,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,3,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",13,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","spnego_gss_delete_sec_context(
			    OM_uint32 *minor_status,
			    gss_ctx_id_t *context_handle,
			    gss_buffer_t output_token)
{
	OM_uint32 ret = GSS_S_COMPLETE;
	spnego_gss_ctx_id_t *ctx =
		    (spnego_gss_ctx_id_t *)context_handle;

	*minor_status = 0;

	if (context_handle == NULL)
		return (GSS_S_FAILURE);

 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
				      output_token);
	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
","spnego_gss_delete_sec_context(
			    OM_uint32 *minor_status,
			    gss_ctx_id_t *context_handle,
			    gss_buffer_t output_token)
{
	OM_uint32 ret = GSS_S_COMPLETE;
	spnego_gss_ctx_id_t *ctx =
		    (spnego_gss_ctx_id_t *)context_handle;

	*minor_status = 0;

	if (context_handle == NULL)
		return (GSS_S_FAILURE);

 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
	/*
	 * If this is still an SPNEGO mech, release it locally.
	 */
	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
		(void) gss_delete_sec_context(minor_status,
				    &(*ctx)->ctx_handle,
				    output_token);
		(void) release_spnego_ctx(ctx);
	} else {
		ret = gss_delete_sec_context(minor_status,
				    context_handle,
				    output_token);
	}
 
 	return (ret);
 }
",C,"	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
				      output_token);
	(void) release_spnego_ctx(ctx);
","	/*
	 * If this is still an SPNEGO mech, release it locally.
	 */
	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
		(void) gss_delete_sec_context(minor_status,
				    &(*ctx)->ctx_handle,
				    output_token);
		(void) release_spnego_ctx(ctx);
	} else {
		ret = gss_delete_sec_context(minor_status,
				    context_handle,
				    output_token);
	}
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"spnego_gss_delete_sec_context(
			    OM_uint32 *minor_status,
			    gss_ctx_id_t *context_handle,
			    gss_buffer_t output_token)
{
	OM_uint32 ret = GSS_S_COMPLETE;
	spnego_gss_ctx_id_t *ctx =
		    (spnego_gss_ctx_id_t *)context_handle;

	*minor_status = 0;

	if (context_handle == NULL)
		return (GSS_S_FAILURE);

 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
//flaw_line_below:
	/*
//flaw_line_below:
	 * If this is still an SPNEGO mech, release it locally.
//flaw_line_below:
	 */
//flaw_line_below:
	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
//flaw_line_below:
		(void) gss_delete_sec_context(minor_status,
//flaw_line_below:
				    &(*ctx)->ctx_handle,
//flaw_line_below:
				    output_token);
//flaw_line_below:
		(void) release_spnego_ctx(ctx);
//flaw_line_below:
	} else {
//flaw_line_below:
		ret = gss_delete_sec_context(minor_status,
//flaw_line_below:
				    context_handle,
//flaw_line_below:
				    output_token);
//flaw_line_below:
	}
//fix_flaw_line_below:
//	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
//fix_flaw_line_below:
//				      output_token);
//fix_flaw_line_below:
//	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
"
2091,179827,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,12,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",1,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","spnego_gss_export_sec_context(
			    OM_uint32	  *minor_status,
			    gss_ctx_id_t *context_handle,
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;

	/* We don't currently support exporting partially established
	 * contexts. */
	if (!sc->opened)
		return GSS_S_UNAVAILABLE;

 	ret = gss_export_sec_context(minor_status,
				    &sc->ctx_handle,
 				    interprocess_token);
	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
		release_spnego_ctx(&sc);
		*context_handle = GSS_C_NO_CONTEXT;
	}
 	return (ret);
 }
","spnego_gss_export_sec_context(
			    OM_uint32	  *minor_status,
			    gss_ctx_id_t *context_handle,
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
 	ret = gss_export_sec_context(minor_status,
				    context_handle,
 				    interprocess_token);
 	return (ret);
 }
",C,"	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;

	/* We don't currently support exporting partially established
	 * contexts. */
	if (!sc->opened)
		return GSS_S_UNAVAILABLE;

				    &sc->ctx_handle,
	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
		release_spnego_ctx(&sc);
		*context_handle = GSS_C_NO_CONTEXT;
	}
","				    context_handle,
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"spnego_gss_export_sec_context(
			    OM_uint32	  *minor_status,
			    gss_ctx_id_t *context_handle,
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
//fix_flaw_line_below:
//	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	/* We don't currently support exporting partially established
//fix_flaw_line_below:
//	 * contexts. */
//fix_flaw_line_below:
//	if (!sc->opened)
//fix_flaw_line_below:
//		return GSS_S_UNAVAILABLE;
//fix_flaw_line_below:
//
 	ret = gss_export_sec_context(minor_status,
//flaw_line_below:
				    context_handle,
//fix_flaw_line_below:
//				    &sc->ctx_handle,
 				    interprocess_token);
//fix_flaw_line_below:
//	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
//fix_flaw_line_below:
//		release_spnego_ctx(&sc);
//fix_flaw_line_below:
//		*context_handle = GSS_C_NO_CONTEXT;
//fix_flaw_line_below:
//	}
 	return (ret);
 }
"
2092,179828,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,6,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",1,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","spnego_gss_get_mic(
		OM_uint32 *minor_status,
		const gss_ctx_id_t context_handle,
		gss_qop_t  qop_req,
		const gss_buffer_t message_buffer,
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_NO_CONTEXT);

 	ret = gss_get_mic(minor_status,
		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
	return (ret);
}
","spnego_gss_get_mic(
		OM_uint32 *minor_status,
		const gss_ctx_id_t context_handle,
		gss_qop_t  qop_req,
		const gss_buffer_t message_buffer,
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
 	ret = gss_get_mic(minor_status,
		    context_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
	return (ret);
}
",C,"	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_NO_CONTEXT);

		    sc->ctx_handle,
","		    context_handle,
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"spnego_gss_get_mic(
		OM_uint32 *minor_status,
		const gss_ctx_id_t context_handle,
		gss_qop_t  qop_req,
		const gss_buffer_t message_buffer,
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
//fix_flaw_line_below:
//	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//		return (GSS_S_NO_CONTEXT);
//fix_flaw_line_below:
//
 	ret = gss_get_mic(minor_status,
//flaw_line_below:
		    context_handle,
//fix_flaw_line_below:
//		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
	return (ret);
}
"
2093,179829,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,6,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",1,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
	    return (GSS_S_NO_CONTEXT);

    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
","spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
 			   iov_count);
 }
",C,"    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
	    return (GSS_S_NO_CONTEXT);

    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
","    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
//flaw_line_below:
    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
//fix_flaw_line_below:
//    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//	    return (GSS_S_NO_CONTEXT);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
"
2094,179830,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,6,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",1,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
	    return (GSS_S_NO_CONTEXT);

    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
","spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
 				  iov_count);
 }
",C,"    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
	    return (GSS_S_NO_CONTEXT);

    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
","    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
//flaw_line_below:
    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
//fix_flaw_line_below:
//    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//	    return (GSS_S_NO_CONTEXT);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
"
2095,179831,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,6,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",5,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","spnego_gss_import_sec_context(
	OM_uint32		*minor_status,
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
	/*
	 * Until we implement partial context exports, there are no SPNEGO
	 * exported context tokens, only tokens for underlying mechs.  So just
	 * return an error for now.
	 */
	return GSS_S_UNAVAILABLE;
 }
","spnego_gss_import_sec_context(
	OM_uint32		*minor_status,
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
	OM_uint32 ret;
	ret = gss_import_sec_context(minor_status,
				    interprocess_token,
				    context_handle);
	return (ret);
 }
",C,"	/*
	 * Until we implement partial context exports, there are no SPNEGO
	 * exported context tokens, only tokens for underlying mechs.  So just
	 * return an error for now.
	 */
	return GSS_S_UNAVAILABLE;
","	OM_uint32 ret;
	ret = gss_import_sec_context(minor_status,
				    interprocess_token,
				    context_handle);
	return (ret);
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"spnego_gss_import_sec_context(
	OM_uint32		*minor_status,
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
//flaw_line_below:
	OM_uint32 ret;
//flaw_line_below:
	ret = gss_import_sec_context(minor_status,
//flaw_line_below:
				    interprocess_token,
//flaw_line_below:
				    context_handle);
//flaw_line_below:
	return (ret);
//fix_flaw_line_below:
//	/*
//fix_flaw_line_below:
//	 * Until we implement partial context exports, there are no SPNEGO
//fix_flaw_line_below:
//	 * exported context tokens, only tokens for underlying mechs.  So just
//fix_flaw_line_below:
//	 * return an error for now.
//fix_flaw_line_below:
//	 */
//fix_flaw_line_below:
//	return GSS_S_UNAVAILABLE;
 }
"
2096,179832,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,1,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",6,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","spnego_gss_init_sec_context(
			OM_uint32 *minor_status,
			gss_cred_id_t claimant_cred_handle,
			gss_ctx_id_t *context_handle,
			gss_name_t target_name,
			gss_OID mech_type,
			OM_uint32 req_flags,
			OM_uint32 time_req,
			gss_channel_bindings_t input_chan_bindings,
			gss_buffer_t input_token,
			gss_OID *actual_mech,
			gss_buffer_t output_token,
			OM_uint32 *ret_flags,
			OM_uint32 *time_rec)
{
	send_token_flag send_token = NO_TOKEN_SEND;
	OM_uint32 tmpmin, ret, negState;
	gss_buffer_t mechtok_in, mechListMIC_in, mechListMIC_out;
	gss_buffer_desc mechtok_out = GSS_C_EMPTY_BUFFER;
	spnego_gss_cred_id_t spcred = NULL;
	spnego_gss_ctx_id_t spnego_ctx = NULL;

	dsyslog(""Entering init_sec_context\n"");

	mechtok_in = mechListMIC_out = mechListMIC_in = GSS_C_NO_BUFFER;
	negState = REJECT;

	/*
	 * This function works in three steps:
	 *
	 *   1. Perform mechanism negotiation.
	 *   2. Invoke the negotiated or optimistic mech's gss_init_sec_context
	 *      function and examine the results.
	 *   3. Process or generate MICs if necessary.
	 *
	 * The three steps share responsibility for determining when the
	 * exchange is complete.  If the selected mech completed in a previous
	 * call and no MIC exchange is expected, then step 1 will decide.  If
	 * the selected mech completes in this call and no MIC exchange is
	 * expected, then step 2 will decide.  If a MIC exchange is expected,
	 * then step 3 will decide.  If an error occurs in any step, the
	 * exchange will be aborted, possibly with an error token.
	 *
	 * negState determines the state of the negotiation, and is
	 * communicated to the acceptor if a continuing token is sent.
	 * send_token is used to indicate what type of token, if any, should be
	 * generated.
	 */

	/* Validate arguments. */
	if (minor_status != NULL)
		*minor_status = 0;
	if (output_token != GSS_C_NO_BUFFER) {
		output_token->length = 0;
		output_token->value = NULL;
	}
	if (minor_status == NULL ||
	    output_token == GSS_C_NO_BUFFER ||
	    context_handle == NULL)
		return GSS_S_CALL_INACCESSIBLE_WRITE;

	if (actual_mech != NULL)
		*actual_mech = GSS_C_NO_OID;

	/* Step 1: perform mechanism negotiation. */
	spcred = (spnego_gss_cred_id_t)claimant_cred_handle;
	if (*context_handle == GSS_C_NO_CONTEXT) {
		ret = init_ctx_new(minor_status, spcred,
				   context_handle, &send_token);
		if (ret != GSS_S_CONTINUE_NEEDED) {
			goto cleanup;
		}
	} else {
		ret = init_ctx_cont(minor_status, context_handle,
				    input_token, &mechtok_in,
				    &mechListMIC_in, &negState, &send_token);
		if (HARD_ERROR(ret)) {
			goto cleanup;
		}
	}

	/* Step 2: invoke the selected or optimistic mechanism's
	 * gss_init_sec_context function, if it didn't complete previously. */
	spnego_ctx = (spnego_gss_ctx_id_t)*context_handle;
	if (!spnego_ctx->mech_complete) {
		ret = init_ctx_call_init(
			minor_status, spnego_ctx, spcred,
			target_name, req_flags,
			time_req, mechtok_in,
			actual_mech, &mechtok_out,
			ret_flags, time_rec,
			&negState, &send_token);

		/* Give the mechanism a chance to force a mechlistMIC. */
		if (!HARD_ERROR(ret) && mech_requires_mechlistMIC(spnego_ctx))
			spnego_ctx->mic_reqd = 1;
	}

	/* Step 3: process or generate the MIC, if the negotiated mech is
	 * complete and supports MICs. */
	if (!HARD_ERROR(ret) && spnego_ctx->mech_complete &&
	    (spnego_ctx->ctx_flags & GSS_C_INTEG_FLAG)) {

		ret = handle_mic(minor_status,
				 mechListMIC_in,
				 (mechtok_out.length != 0),
				 spnego_ctx, &mechListMIC_out,
				 &negState, &send_token);
	}
cleanup:
	if (send_token == INIT_TOKEN_SEND) {
		if (make_spnego_tokenInit_msg(spnego_ctx,
					      0,
					      mechListMIC_out,
					      req_flags,
					      &mechtok_out, send_token,
					      output_token) < 0) {
			ret = GSS_S_FAILURE;
		}
	} else if (send_token != NO_TOKEN_SEND) {
		if (make_spnego_tokenTarg_msg(negState, GSS_C_NO_OID,
					      &mechtok_out, mechListMIC_out,
					      send_token,
					      output_token) < 0) {
			ret = GSS_S_FAILURE;
		}
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
					       &spnego_ctx->ctx_handle,
					       GSS_C_NO_BUFFER);
			release_spnego_ctx(&spnego_ctx);
		}
		*context_handle = GSS_C_NO_CONTEXT;
	}
	if (mechtok_in != GSS_C_NO_BUFFER) {
		gss_release_buffer(&tmpmin, mechtok_in);
		free(mechtok_in);
	}
	if (mechListMIC_in != GSS_C_NO_BUFFER) {
		gss_release_buffer(&tmpmin, mechListMIC_in);
		free(mechListMIC_in);
	}
	if (mechListMIC_out != GSS_C_NO_BUFFER) {
		gss_release_buffer(&tmpmin, mechListMIC_out);
		free(mechListMIC_out);
	}
	return ret;
} /* init_sec_context */
","spnego_gss_init_sec_context(
			OM_uint32 *minor_status,
			gss_cred_id_t claimant_cred_handle,
			gss_ctx_id_t *context_handle,
			gss_name_t target_name,
			gss_OID mech_type,
			OM_uint32 req_flags,
			OM_uint32 time_req,
			gss_channel_bindings_t input_chan_bindings,
			gss_buffer_t input_token,
			gss_OID *actual_mech,
			gss_buffer_t output_token,
			OM_uint32 *ret_flags,
			OM_uint32 *time_rec)
{
	send_token_flag send_token = NO_TOKEN_SEND;
	OM_uint32 tmpmin, ret, negState;
	gss_buffer_t mechtok_in, mechListMIC_in, mechListMIC_out;
	gss_buffer_desc mechtok_out = GSS_C_EMPTY_BUFFER;
	spnego_gss_cred_id_t spcred = NULL;
	spnego_gss_ctx_id_t spnego_ctx = NULL;

	dsyslog(""Entering init_sec_context\n"");

	mechtok_in = mechListMIC_out = mechListMIC_in = GSS_C_NO_BUFFER;
	negState = REJECT;

	/*
	 * This function works in three steps:
	 *
	 *   1. Perform mechanism negotiation.
	 *   2. Invoke the negotiated or optimistic mech's gss_init_sec_context
	 *      function and examine the results.
	 *   3. Process or generate MICs if necessary.
	 *
	 * The three steps share responsibility for determining when the
	 * exchange is complete.  If the selected mech completed in a previous
	 * call and no MIC exchange is expected, then step 1 will decide.  If
	 * the selected mech completes in this call and no MIC exchange is
	 * expected, then step 2 will decide.  If a MIC exchange is expected,
	 * then step 3 will decide.  If an error occurs in any step, the
	 * exchange will be aborted, possibly with an error token.
	 *
	 * negState determines the state of the negotiation, and is
	 * communicated to the acceptor if a continuing token is sent.
	 * send_token is used to indicate what type of token, if any, should be
	 * generated.
	 */

	/* Validate arguments. */
	if (minor_status != NULL)
		*minor_status = 0;
	if (output_token != GSS_C_NO_BUFFER) {
		output_token->length = 0;
		output_token->value = NULL;
	}
	if (minor_status == NULL ||
	    output_token == GSS_C_NO_BUFFER ||
	    context_handle == NULL)
		return GSS_S_CALL_INACCESSIBLE_WRITE;

	if (actual_mech != NULL)
		*actual_mech = GSS_C_NO_OID;

	/* Step 1: perform mechanism negotiation. */
	spcred = (spnego_gss_cred_id_t)claimant_cred_handle;
	if (*context_handle == GSS_C_NO_CONTEXT) {
		ret = init_ctx_new(minor_status, spcred,
				   context_handle, &send_token);
		if (ret != GSS_S_CONTINUE_NEEDED) {
			goto cleanup;
		}
	} else {
		ret = init_ctx_cont(minor_status, context_handle,
				    input_token, &mechtok_in,
				    &mechListMIC_in, &negState, &send_token);
		if (HARD_ERROR(ret)) {
			goto cleanup;
		}
	}

	/* Step 2: invoke the selected or optimistic mechanism's
	 * gss_init_sec_context function, if it didn't complete previously. */
	spnego_ctx = (spnego_gss_ctx_id_t)*context_handle;
	if (!spnego_ctx->mech_complete) {
		ret = init_ctx_call_init(
			minor_status, spnego_ctx, spcred,
			target_name, req_flags,
			time_req, mechtok_in,
			actual_mech, &mechtok_out,
			ret_flags, time_rec,
			&negState, &send_token);

		/* Give the mechanism a chance to force a mechlistMIC. */
		if (!HARD_ERROR(ret) && mech_requires_mechlistMIC(spnego_ctx))
			spnego_ctx->mic_reqd = 1;
	}

	/* Step 3: process or generate the MIC, if the negotiated mech is
	 * complete and supports MICs. */
	if (!HARD_ERROR(ret) && spnego_ctx->mech_complete &&
	    (spnego_ctx->ctx_flags & GSS_C_INTEG_FLAG)) {

		ret = handle_mic(minor_status,
				 mechListMIC_in,
				 (mechtok_out.length != 0),
				 spnego_ctx, &mechListMIC_out,
				 &negState, &send_token);
	}
cleanup:
	if (send_token == INIT_TOKEN_SEND) {
		if (make_spnego_tokenInit_msg(spnego_ctx,
					      0,
					      mechListMIC_out,
					      req_flags,
					      &mechtok_out, send_token,
					      output_token) < 0) {
			ret = GSS_S_FAILURE;
		}
	} else if (send_token != NO_TOKEN_SEND) {
		if (make_spnego_tokenTarg_msg(negState, GSS_C_NO_OID,
					      &mechtok_out, mechListMIC_out,
					      send_token,
					      output_token) < 0) {
			ret = GSS_S_FAILURE;
		}
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
		/*
		 * Now, switch the output context to refer to the
		 * negotiated mechanism's context.
		 */
		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
					       &spnego_ctx->ctx_handle,
					       GSS_C_NO_BUFFER);
			release_spnego_ctx(&spnego_ctx);
		}
		*context_handle = GSS_C_NO_CONTEXT;
	}
	if (mechtok_in != GSS_C_NO_BUFFER) {
		gss_release_buffer(&tmpmin, mechtok_in);
		free(mechtok_in);
	}
	if (mechListMIC_in != GSS_C_NO_BUFFER) {
		gss_release_buffer(&tmpmin, mechListMIC_in);
		free(mechListMIC_in);
	}
	if (mechListMIC_out != GSS_C_NO_BUFFER) {
		gss_release_buffer(&tmpmin, mechListMIC_out);
		free(mechListMIC_out);
	}
	return ret;
} /* init_sec_context */
",C,"		spnego_ctx->opened = 1;
","		/*
		 * Now, switch the output context to refer to the
		 * negotiated mechanism's context.
		 */
		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
		release_spnego_ctx(&spnego_ctx);
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"spnego_gss_init_sec_context(
			OM_uint32 *minor_status,
			gss_cred_id_t claimant_cred_handle,
			gss_ctx_id_t *context_handle,
			gss_name_t target_name,
			gss_OID mech_type,
			OM_uint32 req_flags,
			OM_uint32 time_req,
			gss_channel_bindings_t input_chan_bindings,
			gss_buffer_t input_token,
			gss_OID *actual_mech,
			gss_buffer_t output_token,
			OM_uint32 *ret_flags,
			OM_uint32 *time_rec)
{
	send_token_flag send_token = NO_TOKEN_SEND;
	OM_uint32 tmpmin, ret, negState;
	gss_buffer_t mechtok_in, mechListMIC_in, mechListMIC_out;
	gss_buffer_desc mechtok_out = GSS_C_EMPTY_BUFFER;
	spnego_gss_cred_id_t spcred = NULL;
	spnego_gss_ctx_id_t spnego_ctx = NULL;

	dsyslog(""Entering init_sec_context\n"");

	mechtok_in = mechListMIC_out = mechListMIC_in = GSS_C_NO_BUFFER;
	negState = REJECT;

	/*
	 * This function works in three steps:
	 *
	 *   1. Perform mechanism negotiation.
	 *   2. Invoke the negotiated or optimistic mech's gss_init_sec_context
	 *      function and examine the results.
	 *   3. Process or generate MICs if necessary.
	 *
	 * The three steps share responsibility for determining when the
	 * exchange is complete.  If the selected mech completed in a previous
	 * call and no MIC exchange is expected, then step 1 will decide.  If
	 * the selected mech completes in this call and no MIC exchange is
	 * expected, then step 2 will decide.  If a MIC exchange is expected,
	 * then step 3 will decide.  If an error occurs in any step, the
	 * exchange will be aborted, possibly with an error token.
	 *
	 * negState determines the state of the negotiation, and is
	 * communicated to the acceptor if a continuing token is sent.
	 * send_token is used to indicate what type of token, if any, should be
	 * generated.
	 */

	/* Validate arguments. */
	if (minor_status != NULL)
		*minor_status = 0;
	if (output_token != GSS_C_NO_BUFFER) {
		output_token->length = 0;
		output_token->value = NULL;
	}
	if (minor_status == NULL ||
	    output_token == GSS_C_NO_BUFFER ||
	    context_handle == NULL)
		return GSS_S_CALL_INACCESSIBLE_WRITE;

	if (actual_mech != NULL)
		*actual_mech = GSS_C_NO_OID;

	/* Step 1: perform mechanism negotiation. */
	spcred = (spnego_gss_cred_id_t)claimant_cred_handle;
	if (*context_handle == GSS_C_NO_CONTEXT) {
		ret = init_ctx_new(minor_status, spcred,
				   context_handle, &send_token);
		if (ret != GSS_S_CONTINUE_NEEDED) {
			goto cleanup;
		}
	} else {
		ret = init_ctx_cont(minor_status, context_handle,
				    input_token, &mechtok_in,
				    &mechListMIC_in, &negState, &send_token);
		if (HARD_ERROR(ret)) {
			goto cleanup;
		}
	}

	/* Step 2: invoke the selected or optimistic mechanism's
	 * gss_init_sec_context function, if it didn't complete previously. */
	spnego_ctx = (spnego_gss_ctx_id_t)*context_handle;
	if (!spnego_ctx->mech_complete) {
		ret = init_ctx_call_init(
			minor_status, spnego_ctx, spcred,
			target_name, req_flags,
			time_req, mechtok_in,
			actual_mech, &mechtok_out,
			ret_flags, time_rec,
			&negState, &send_token);

		/* Give the mechanism a chance to force a mechlistMIC. */
		if (!HARD_ERROR(ret) && mech_requires_mechlistMIC(spnego_ctx))
			spnego_ctx->mic_reqd = 1;
	}

	/* Step 3: process or generate the MIC, if the negotiated mech is
	 * complete and supports MICs. */
	if (!HARD_ERROR(ret) && spnego_ctx->mech_complete &&
	    (spnego_ctx->ctx_flags & GSS_C_INTEG_FLAG)) {

		ret = handle_mic(minor_status,
				 mechListMIC_in,
				 (mechtok_out.length != 0),
				 spnego_ctx, &mechListMIC_out,
				 &negState, &send_token);
	}
cleanup:
	if (send_token == INIT_TOKEN_SEND) {
		if (make_spnego_tokenInit_msg(spnego_ctx,
					      0,
					      mechListMIC_out,
					      req_flags,
					      &mechtok_out, send_token,
					      output_token) < 0) {
			ret = GSS_S_FAILURE;
		}
	} else if (send_token != NO_TOKEN_SEND) {
		if (make_spnego_tokenTarg_msg(negState, GSS_C_NO_OID,
					      &mechtok_out, mechListMIC_out,
					      send_token,
					      output_token) < 0) {
			ret = GSS_S_FAILURE;
		}
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
//flaw_line_below:
		/*
//flaw_line_below:
		 * Now, switch the output context to refer to the
//flaw_line_below:
		 * negotiated mechanism's context.
//flaw_line_below:
		 */
//flaw_line_below:
		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
//fix_flaw_line_below:
//		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
//flaw_line_below:
		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
					       &spnego_ctx->ctx_handle,
					       GSS_C_NO_BUFFER);
			release_spnego_ctx(&spnego_ctx);
		}
		*context_handle = GSS_C_NO_CONTEXT;
	}
	if (mechtok_in != GSS_C_NO_BUFFER) {
		gss_release_buffer(&tmpmin, mechtok_in);
		free(mechtok_in);
	}
	if (mechListMIC_in != GSS_C_NO_BUFFER) {
		gss_release_buffer(&tmpmin, mechListMIC_in);
		free(mechListMIC_in);
	}
	if (mechListMIC_out != GSS_C_NO_BUFFER) {
		gss_release_buffer(&tmpmin, mechListMIC_out);
		free(mechListMIC_out);
	}
	return ret;
} /* init_sec_context */
"
2097,179833,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,41,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",9,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","spnego_gss_inquire_context(
			OM_uint32	*minor_status,
			const gss_ctx_id_t context_handle,
			gss_name_t	*src_name,
			gss_name_t	*targ_name,
			OM_uint32	*lifetime_rec,
			gss_OID		*mech_type,
			OM_uint32	*ctx_flags,
			int		*locally_initiated,
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	if (src_name != NULL)
		*src_name = GSS_C_NO_NAME;
	if (targ_name != NULL)
		*targ_name = GSS_C_NO_NAME;
	if (lifetime_rec != NULL)
		*lifetime_rec = 0;
	if (mech_type != NULL)
		*mech_type = (gss_OID)gss_mech_spnego;
	if (ctx_flags != NULL)
		*ctx_flags = 0;
	if (locally_initiated != NULL)
		*locally_initiated = sc->initiate;
	if (opened != NULL)
		*opened = sc->opened;

	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
		ret = gss_inquire_context(minor_status, sc->ctx_handle,
					  src_name, targ_name, lifetime_rec,
					  mech_type, ctx_flags, NULL, NULL);
	}
 
	if (!sc->opened) {
		/*
		 * We are still doing SPNEGO negotiation, so report SPNEGO as
		 * the OID.  After negotiation is complete we will report the
		 * underlying mechanism OID.
		 */
		if (mech_type != NULL)
			*mech_type = (gss_OID)gss_mech_spnego;

		/*
		 * Remove flags we don't support with partially-established
		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
		 * support for exporting partial SPNEGO contexts.)
		 */
		if (ctx_flags != NULL) {
			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
			*ctx_flags &= ~GSS_C_TRANS_FLAG;
		}
	}
 
 	return (ret);
 }
","spnego_gss_inquire_context(
			OM_uint32	*minor_status,
			const gss_ctx_id_t context_handle,
			gss_name_t	*src_name,
			gss_name_t	*targ_name,
			OM_uint32	*lifetime_rec,
			gss_OID		*mech_type,
			OM_uint32	*ctx_flags,
			int		*locally_initiated,
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
 
	ret = gss_inquire_context(minor_status,
				context_handle,
				src_name,
				targ_name,
				lifetime_rec,
				mech_type,
				ctx_flags,
				locally_initiated,
				opened);
 
 	return (ret);
 }
",C,"	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	if (src_name != NULL)
		*src_name = GSS_C_NO_NAME;
	if (targ_name != NULL)
		*targ_name = GSS_C_NO_NAME;
	if (lifetime_rec != NULL)
		*lifetime_rec = 0;
	if (mech_type != NULL)
		*mech_type = (gss_OID)gss_mech_spnego;
	if (ctx_flags != NULL)
		*ctx_flags = 0;
	if (locally_initiated != NULL)
		*locally_initiated = sc->initiate;
	if (opened != NULL)
		*opened = sc->opened;

	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
		ret = gss_inquire_context(minor_status, sc->ctx_handle,
					  src_name, targ_name, lifetime_rec,
					  mech_type, ctx_flags, NULL, NULL);
	}
	if (!sc->opened) {
		/*
		 * We are still doing SPNEGO negotiation, so report SPNEGO as
		 * the OID.  After negotiation is complete we will report the
		 * underlying mechanism OID.
		 */
		if (mech_type != NULL)
			*mech_type = (gss_OID)gss_mech_spnego;

		/*
		 * Remove flags we don't support with partially-established
		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
		 * support for exporting partial SPNEGO contexts.)
		 */
		if (ctx_flags != NULL) {
			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
			*ctx_flags &= ~GSS_C_TRANS_FLAG;
		}
	}
","	ret = gss_inquire_context(minor_status,
				context_handle,
				src_name,
				targ_name,
				lifetime_rec,
				mech_type,
				ctx_flags,
				locally_initiated,
				opened);
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"spnego_gss_inquire_context(
			OM_uint32	*minor_status,
			const gss_ctx_id_t context_handle,
			gss_name_t	*src_name,
			gss_name_t	*targ_name,
			OM_uint32	*lifetime_rec,
			gss_OID		*mech_type,
			OM_uint32	*ctx_flags,
			int		*locally_initiated,
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
//fix_flaw_line_below:
//	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (src_name != NULL)
//fix_flaw_line_below:
//		*src_name = GSS_C_NO_NAME;
//fix_flaw_line_below:
//	if (targ_name != NULL)
//fix_flaw_line_below:
//		*targ_name = GSS_C_NO_NAME;
//fix_flaw_line_below:
//	if (lifetime_rec != NULL)
//fix_flaw_line_below:
//		*lifetime_rec = 0;
//fix_flaw_line_below:
//	if (mech_type != NULL)
//fix_flaw_line_below:
//		*mech_type = (gss_OID)gss_mech_spnego;
//fix_flaw_line_below:
//	if (ctx_flags != NULL)
//fix_flaw_line_below:
//		*ctx_flags = 0;
//fix_flaw_line_below:
//	if (locally_initiated != NULL)
//fix_flaw_line_below:
//		*locally_initiated = sc->initiate;
//fix_flaw_line_below:
//	if (opened != NULL)
//fix_flaw_line_below:
//		*opened = sc->opened;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
//fix_flaw_line_below:
//		ret = gss_inquire_context(minor_status, sc->ctx_handle,
//fix_flaw_line_below:
//					  src_name, targ_name, lifetime_rec,
//fix_flaw_line_below:
//					  mech_type, ctx_flags, NULL, NULL);
//fix_flaw_line_below:
//	}
 
//flaw_line_below:
	ret = gss_inquire_context(minor_status,
//flaw_line_below:
				context_handle,
//flaw_line_below:
				src_name,
//flaw_line_below:
				targ_name,
//flaw_line_below:
				lifetime_rec,
//flaw_line_below:
				mech_type,
//flaw_line_below:
				ctx_flags,
//flaw_line_below:
				locally_initiated,
//flaw_line_below:
				opened);
//fix_flaw_line_below:
//	if (!sc->opened) {
//fix_flaw_line_below:
//		/*
//fix_flaw_line_below:
//		 * We are still doing SPNEGO negotiation, so report SPNEGO as
//fix_flaw_line_below:
//		 * the OID.  After negotiation is complete we will report the
//fix_flaw_line_below:
//		 * underlying mechanism OID.
//fix_flaw_line_below:
//		 */
//fix_flaw_line_below:
//		if (mech_type != NULL)
//fix_flaw_line_below:
//			*mech_type = (gss_OID)gss_mech_spnego;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//		/*
//fix_flaw_line_below:
//		 * Remove flags we don't support with partially-established
//fix_flaw_line_below:
//		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
//fix_flaw_line_below:
//		 * support for exporting partial SPNEGO contexts.)
//fix_flaw_line_below:
//		 */
//fix_flaw_line_below:
//		if (ctx_flags != NULL) {
//fix_flaw_line_below:
//			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
//fix_flaw_line_below:
//			*ctx_flags &= ~GSS_C_TRANS_FLAG;
//fix_flaw_line_below:
//		}
//fix_flaw_line_below:
//	}
 
 	return (ret);
 }
"
2098,179834,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,7,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",1,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","spnego_gss_inquire_sec_context_by_oid(
		OM_uint32 *minor_status,
		const gss_ctx_id_t context_handle,
		const gss_OID desired_object,
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	/* There are no SPNEGO-specific OIDs for this function. */
	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_UNAVAILABLE);

 	ret = gss_inquire_sec_context_by_oid(minor_status,
			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
}
","spnego_gss_inquire_sec_context_by_oid(
		OM_uint32 *minor_status,
		const gss_ctx_id_t context_handle,
		const gss_OID desired_object,
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
 	ret = gss_inquire_sec_context_by_oid(minor_status,
			    context_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
}
",C,"	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	/* There are no SPNEGO-specific OIDs for this function. */
	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_UNAVAILABLE);

			    sc->ctx_handle,
","			    context_handle,
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"spnego_gss_inquire_sec_context_by_oid(
		OM_uint32 *minor_status,
		const gss_ctx_id_t context_handle,
		const gss_OID desired_object,
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
//fix_flaw_line_below:
//	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	/* There are no SPNEGO-specific OIDs for this function. */
//fix_flaw_line_below:
//	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//		return (GSS_S_UNAVAILABLE);
//fix_flaw_line_below:
//
 	ret = gss_inquire_sec_context_by_oid(minor_status,
//flaw_line_below:
			    context_handle,
//fix_flaw_line_below:
//			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
}
"
2099,179835,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,7,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",1,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","spnego_gss_process_context_token(
				OM_uint32	*minor_status,
				const gss_ctx_id_t context_handle,
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	/* SPNEGO doesn't have its own context tokens. */
	if (!sc->opened)
		return (GSS_S_DEFECTIVE_TOKEN);

 	ret = gss_process_context_token(minor_status,
					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
}
","spnego_gss_process_context_token(
				OM_uint32	*minor_status,
				const gss_ctx_id_t context_handle,
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
 	ret = gss_process_context_token(minor_status,
					context_handle,
 					token_buffer);
 
 	return (ret);
}
",C,"	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	/* SPNEGO doesn't have its own context tokens. */
	if (!sc->opened)
		return (GSS_S_DEFECTIVE_TOKEN);

					sc->ctx_handle,
","					context_handle,
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"spnego_gss_process_context_token(
				OM_uint32	*minor_status,
				const gss_ctx_id_t context_handle,
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
//fix_flaw_line_below:
//	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	/* SPNEGO doesn't have its own context tokens. */
//fix_flaw_line_below:
//	if (!sc->opened)
//fix_flaw_line_below:
//		return (GSS_S_DEFECTIVE_TOKEN);
//fix_flaw_line_below:
//
 	ret = gss_process_context_token(minor_status,
//flaw_line_below:
					context_handle,
//fix_flaw_line_below:
//					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
}
"
2100,179836,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,6,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",1,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","spnego_gss_pseudo_random(OM_uint32 *minor_status,
			 gss_ctx_id_t context,
			 int prf_key,
			 const gss_buffer_t prf_in,
			 ssize_t desired_output_len,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;

	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_NO_CONTEXT);

 	ret = gss_pseudo_random(minor_status,
				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
				prf_out);
        return (ret);
}
","spnego_gss_pseudo_random(OM_uint32 *minor_status,
			 gss_ctx_id_t context,
			 int prf_key,
			 const gss_buffer_t prf_in,
			 ssize_t desired_output_len,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
 	ret = gss_pseudo_random(minor_status,
				context,
 				prf_key,
 				prf_in,
 				desired_output_len,
				prf_out);
        return (ret);
}
",C,"	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;

	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_NO_CONTEXT);

				sc->ctx_handle,
","				context,
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"spnego_gss_pseudo_random(OM_uint32 *minor_status,
			 gss_ctx_id_t context,
			 int prf_key,
			 const gss_buffer_t prf_in,
			 ssize_t desired_output_len,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
//fix_flaw_line_below:
//	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//		return (GSS_S_NO_CONTEXT);
//fix_flaw_line_below:
//
 	ret = gss_pseudo_random(minor_status,
//flaw_line_below:
				context,
//fix_flaw_line_below:
//				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
				prf_out);
        return (ret);
}
"
2101,179837,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,8,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",1,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","spnego_gss_set_sec_context_option(
		OM_uint32 *minor_status,
		gss_ctx_id_t *context_handle,
		const gss_OID desired_object,
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;

	/* There are no SPNEGO-specific OIDs for this function, and we cannot
	 * construct an empty SPNEGO context with it. */
	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_UNAVAILABLE);

 	ret = gss_set_sec_context_option(minor_status,
			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
}
","spnego_gss_set_sec_context_option(
		OM_uint32 *minor_status,
		gss_ctx_id_t *context_handle,
		const gss_OID desired_object,
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
 	ret = gss_set_sec_context_option(minor_status,
			    context_handle,
 			    desired_object,
 			    value);
 	return (ret);
}
",C,"	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;

	/* There are no SPNEGO-specific OIDs for this function, and we cannot
	 * construct an empty SPNEGO context with it. */
	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_UNAVAILABLE);

			    &sc->ctx_handle,
","			    context_handle,
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"spnego_gss_set_sec_context_option(
		OM_uint32 *minor_status,
		gss_ctx_id_t *context_handle,
		const gss_OID desired_object,
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
//fix_flaw_line_below:
//	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	/* There are no SPNEGO-specific OIDs for this function, and we cannot
//fix_flaw_line_below:
//	 * construct an empty SPNEGO context with it. */
//fix_flaw_line_below:
//	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//		return (GSS_S_UNAVAILABLE);
//fix_flaw_line_below:
//
 	ret = gss_set_sec_context_option(minor_status,
//flaw_line_below:
			    context_handle,
//fix_flaw_line_below:
//			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
}
"
2102,179838,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,6,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",1,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","spnego_gss_unwrap(
		OM_uint32 *minor_status,
		gss_ctx_id_t context_handle,
		gss_buffer_t input_message_buffer,
		gss_buffer_t output_message_buffer,
		int *conf_state,
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_NO_CONTEXT);

 	ret = gss_unwrap(minor_status,
			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
			qop_state);

	return (ret);
}
","spnego_gss_unwrap(
		OM_uint32 *minor_status,
		gss_ctx_id_t context_handle,
		gss_buffer_t input_message_buffer,
		gss_buffer_t output_message_buffer,
		int *conf_state,
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
 	ret = gss_unwrap(minor_status,
			context_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
			qop_state);

	return (ret);
}
",C,"	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_NO_CONTEXT);

			sc->ctx_handle,
","			context_handle,
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"spnego_gss_unwrap(
		OM_uint32 *minor_status,
		gss_ctx_id_t context_handle,
		gss_buffer_t input_message_buffer,
		gss_buffer_t output_message_buffer,
		int *conf_state,
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
//fix_flaw_line_below:
//	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//		return (GSS_S_NO_CONTEXT);
//fix_flaw_line_below:
//
 	ret = gss_unwrap(minor_status,
//flaw_line_below:
			context_handle,
//fix_flaw_line_below:
//			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
			qop_state);

	return (ret);
}
"
2103,179839,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,6,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",1,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","spnego_gss_unwrap_aead(OM_uint32 *minor_status,
		       gss_ctx_id_t context_handle,
		       gss_buffer_t input_message_buffer,
		       gss_buffer_t input_assoc_buffer,
		       gss_buffer_t output_payload_buffer,
		       int *conf_state,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_NO_CONTEXT);

 	ret = gss_unwrap_aead(minor_status,
			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
			      conf_state,
			      qop_state);
	return (ret);
}
","spnego_gss_unwrap_aead(OM_uint32 *minor_status,
		       gss_ctx_id_t context_handle,
		       gss_buffer_t input_message_buffer,
		       gss_buffer_t input_assoc_buffer,
		       gss_buffer_t output_payload_buffer,
		       int *conf_state,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
 	ret = gss_unwrap_aead(minor_status,
			      context_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
			      conf_state,
			      qop_state);
	return (ret);
}
",C,"	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_NO_CONTEXT);

			      sc->ctx_handle,
","			      context_handle,
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"spnego_gss_unwrap_aead(OM_uint32 *minor_status,
		       gss_ctx_id_t context_handle,
		       gss_buffer_t input_message_buffer,
		       gss_buffer_t input_assoc_buffer,
		       gss_buffer_t output_payload_buffer,
		       int *conf_state,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
//fix_flaw_line_below:
//	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//		return (GSS_S_NO_CONTEXT);
//fix_flaw_line_below:
//
 	ret = gss_unwrap_aead(minor_status,
//flaw_line_below:
			      context_handle,
//fix_flaw_line_below:
//			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
			      conf_state,
			      qop_state);
	return (ret);
}
"
2104,179840,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,6,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",1,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","spnego_gss_unwrap_iov(OM_uint32 *minor_status,
		      gss_ctx_id_t context_handle,
		      int *conf_state,
		      gss_qop_t *qop_state,
		      gss_iov_buffer_desc *iov,
 		      int iov_count)
 {
 	OM_uint32 ret;
	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_NO_CONTEXT);

 	ret = gss_unwrap_iov(minor_status,
			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
			     iov_count);
	return (ret);
}
","spnego_gss_unwrap_iov(OM_uint32 *minor_status,
		      gss_ctx_id_t context_handle,
		      int *conf_state,
		      gss_qop_t *qop_state,
		      gss_iov_buffer_desc *iov,
 		      int iov_count)
 {
 	OM_uint32 ret;
 	ret = gss_unwrap_iov(minor_status,
			     context_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
			     iov_count);
	return (ret);
}
",C,"	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_NO_CONTEXT);

			     sc->ctx_handle,
","			     context_handle,
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"spnego_gss_unwrap_iov(OM_uint32 *minor_status,
		      gss_ctx_id_t context_handle,
		      int *conf_state,
		      gss_qop_t *qop_state,
		      gss_iov_buffer_desc *iov,
 		      int iov_count)
 {
 	OM_uint32 ret;
//fix_flaw_line_below:
//	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//		return (GSS_S_NO_CONTEXT);
//fix_flaw_line_below:
//
 	ret = gss_unwrap_iov(minor_status,
//flaw_line_below:
			     context_handle,
//fix_flaw_line_below:
//			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
			     iov_count);
	return (ret);
}
"
2105,179841,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,6,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",1,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","spnego_gss_verify_mic(
		OM_uint32 *minor_status,
		const gss_ctx_id_t context_handle,
		const gss_buffer_t msg_buffer,
		const gss_buffer_t token_buffer,
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_NO_CONTEXT);

 	ret = gss_verify_mic(minor_status,
			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
	return (ret);
}
","spnego_gss_verify_mic(
		OM_uint32 *minor_status,
		const gss_ctx_id_t context_handle,
		const gss_buffer_t msg_buffer,
		const gss_buffer_t token_buffer,
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
 	ret = gss_verify_mic(minor_status,
			    context_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
	return (ret);
}
",C,"	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_NO_CONTEXT);

			    sc->ctx_handle,
","			    context_handle,
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"spnego_gss_verify_mic(
		OM_uint32 *minor_status,
		const gss_ctx_id_t context_handle,
		const gss_buffer_t msg_buffer,
		const gss_buffer_t token_buffer,
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
//fix_flaw_line_below:
//	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//		return (GSS_S_NO_CONTEXT);
//fix_flaw_line_below:
//
 	ret = gss_verify_mic(minor_status,
//flaw_line_below:
			    context_handle,
//fix_flaw_line_below:
//			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
	return (ret);
}
"
2106,179842,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,6,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",1,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
	    return (GSS_S_NO_CONTEXT);

    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
","spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
 			      iov_count);
 }
",C,"    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
	    return (GSS_S_NO_CONTEXT);

    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
","    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
//flaw_line_below:
    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
//fix_flaw_line_below:
//    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//	    return (GSS_S_NO_CONTEXT);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
"
2107,179843,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,6,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",1,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","spnego_gss_wrap(
		OM_uint32 *minor_status,
		gss_ctx_id_t context_handle,
		int conf_req_flag,
		gss_qop_t qop_req,
		gss_buffer_t input_message_buffer,
		int *conf_state,
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_NO_CONTEXT);

 	ret = gss_wrap(minor_status,
		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
		    conf_state,
		    output_message_buffer);

	return (ret);
}
","spnego_gss_wrap(
		OM_uint32 *minor_status,
		gss_ctx_id_t context_handle,
		int conf_req_flag,
		gss_qop_t qop_req,
		gss_buffer_t input_message_buffer,
		int *conf_state,
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
 	ret = gss_wrap(minor_status,
		    context_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
		    conf_state,
		    output_message_buffer);

	return (ret);
}
",C,"	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_NO_CONTEXT);

		    sc->ctx_handle,
","		    context_handle,
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"spnego_gss_wrap(
		OM_uint32 *minor_status,
		gss_ctx_id_t context_handle,
		int conf_req_flag,
		gss_qop_t qop_req,
		gss_buffer_t input_message_buffer,
		int *conf_state,
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
//fix_flaw_line_below:
//	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//		return (GSS_S_NO_CONTEXT);
//fix_flaw_line_below:
//
 	ret = gss_wrap(minor_status,
//flaw_line_below:
		    context_handle,
//fix_flaw_line_below:
//		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
		    conf_state,
		    output_message_buffer);

	return (ret);
}
"
2108,179844,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,6,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",1,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","spnego_gss_wrap_aead(OM_uint32 *minor_status,
		     gss_ctx_id_t context_handle,
		     int conf_req_flag,
		     gss_qop_t qop_req,
		     gss_buffer_t input_assoc_buffer,
		     gss_buffer_t input_payload_buffer,
		     int *conf_state,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_NO_CONTEXT);

 	ret = gss_wrap_aead(minor_status,
			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
			    input_payload_buffer,
			    conf_state,
			    output_message_buffer);

	return (ret);
}
","spnego_gss_wrap_aead(OM_uint32 *minor_status,
		     gss_ctx_id_t context_handle,
		     int conf_req_flag,
		     gss_qop_t qop_req,
		     gss_buffer_t input_assoc_buffer,
		     gss_buffer_t input_payload_buffer,
		     int *conf_state,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
 	ret = gss_wrap_aead(minor_status,
			    context_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
			    input_payload_buffer,
			    conf_state,
			    output_message_buffer);

	return (ret);
}
",C,"	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_NO_CONTEXT);

			    sc->ctx_handle,
","			    context_handle,
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"spnego_gss_wrap_aead(OM_uint32 *minor_status,
		     gss_ctx_id_t context_handle,
		     int conf_req_flag,
		     gss_qop_t qop_req,
		     gss_buffer_t input_assoc_buffer,
		     gss_buffer_t input_payload_buffer,
		     int *conf_state,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
//fix_flaw_line_below:
//	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//		return (GSS_S_NO_CONTEXT);
//fix_flaw_line_below:
//
 	ret = gss_wrap_aead(minor_status,
//flaw_line_below:
			    context_handle,
//fix_flaw_line_below:
//			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
			    input_payload_buffer,
			    conf_state,
			    output_message_buffer);

	return (ret);
}
"
2109,179845,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,6,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",1,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","spnego_gss_wrap_iov(OM_uint32 *minor_status,
		    gss_ctx_id_t context_handle,
		    int conf_req_flag,
		    gss_qop_t qop_req,
		    int *conf_state,
		    gss_iov_buffer_desc *iov,
 		    int iov_count)
 {
 	OM_uint32 ret;
	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_NO_CONTEXT);

 	ret = gss_wrap_iov(minor_status,
			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
			   iov,
			   iov_count);
	return (ret);
}
","spnego_gss_wrap_iov(OM_uint32 *minor_status,
		    gss_ctx_id_t context_handle,
		    int conf_req_flag,
		    gss_qop_t qop_req,
		    int *conf_state,
		    gss_iov_buffer_desc *iov,
 		    int iov_count)
 {
 	OM_uint32 ret;
 	ret = gss_wrap_iov(minor_status,
			   context_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
			   iov,
			   iov_count);
	return (ret);
}
",C,"	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_NO_CONTEXT);

			   sc->ctx_handle,
","			   context_handle,
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"spnego_gss_wrap_iov(OM_uint32 *minor_status,
		    gss_ctx_id_t context_handle,
		    int conf_req_flag,
		    gss_qop_t qop_req,
		    int *conf_state,
		    gss_iov_buffer_desc *iov,
 		    int iov_count)
 {
 	OM_uint32 ret;
//fix_flaw_line_below:
//	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//		return (GSS_S_NO_CONTEXT);
//fix_flaw_line_below:
//
 	ret = gss_wrap_iov(minor_status,
//flaw_line_below:
			   context_handle,
//fix_flaw_line_below:
//			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
			   iov,
			   iov_count);
	return (ret);
}
"
2110,179846,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,6,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",1,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
			   gss_ctx_id_t context_handle,
			   int conf_req_flag,
			   gss_qop_t qop_req,
			   int *conf_state,
			   gss_iov_buffer_desc *iov,
 			   int iov_count)
 {
 	OM_uint32 ret;
	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_NO_CONTEXT);

 	ret = gss_wrap_iov_length(minor_status,
				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
				  iov,
				  iov_count);
	return (ret);
}
","spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
			   gss_ctx_id_t context_handle,
			   int conf_req_flag,
			   gss_qop_t qop_req,
			   int *conf_state,
			   gss_iov_buffer_desc *iov,
 			   int iov_count)
 {
 	OM_uint32 ret;
 	ret = gss_wrap_iov_length(minor_status,
				  context_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
				  iov,
				  iov_count);
	return (ret);
}
",C,"	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_NO_CONTEXT);

				  sc->ctx_handle,
","				  context_handle,
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
			   gss_ctx_id_t context_handle,
			   int conf_req_flag,
			   gss_qop_t qop_req,
			   int *conf_state,
			   gss_iov_buffer_desc *iov,
 			   int iov_count)
 {
 	OM_uint32 ret;
//fix_flaw_line_below:
//	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//		return (GSS_S_NO_CONTEXT);
//fix_flaw_line_below:
//
 	ret = gss_wrap_iov_length(minor_status,
//flaw_line_below:
				  context_handle,
//fix_flaw_line_below:
//				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
				  iov,
				  iov_count);
	return (ret);
}
"
2111,179847,,Remote,Not required,Complete,CVE-2015-2695,https://www.cvedetails.com/cve/CVE-2015-2695/,CWE-18,Medium,,,,2015-11-08,7.1,"lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call.",2017-06-30,DoS ,6,https://github.com/krb5/krb5/commit/b51b33f2bc5d1497ddf5bd107f791c101695000d,b51b33f2bc5d1497ddf5bd107f791c101695000d,"Fix SPNEGO context aliasing bugs [CVE-2015-2695]

The SPNEGO mechanism currently replaces its context handle with the
mechanism context handle upon establishment, under the assumption that
most GSS functions are only called after context establishment.  This
assumption is incorrect, and can lead to aliasing violations for some
programs.  Maintain the SPNEGO context structure after context
establishment and refer to it in all GSS methods.  Add initiate and
opened flags to the SPNEGO context structure for use in
gss_inquire_context() prior to context establishment.

CVE-2015-2695:

In MIT krb5 1.5 and later, applications which call
gss_inquire_context() on a partially-established SPNEGO context can
cause the GSS-API library to read from a pointer using the wrong type,
generally causing a process crash.  This bug may go unnoticed, because
the most common SPNEGO authentication scenario establishes the context
after just one call to gss_accept_sec_context().  Java server
applications using the native JGSS provider are vulnerable to this
bug.  A carefully crafted SPNEGO packet might allow the
gss_inquire_context() call to succeed with attacker-determined
results, but applications should not make access control decisions
based on gss_inquire_context() results prior to context establishment.

    CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C

[ghudson@mit.edu: several bugfixes, style changes, and edge-case
behavior changes; commit message and CVE description]

ticket: 8244
target_version: 1.14
tags: pullup",1,src/lib/gssapi/spnego/spnego_mech.c,"{""sha"": ""5c82764234b2568726e6900087ac38a3cb8d1620"", ""filename"": ""src/lib/gssapi/spnego/gssapiP_spnego.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/gssapiP_spnego.h"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/gssapiP_spnego.h?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -103,6 +103,8 @@ typedef struct {\n \tint firstpass;\n \tint mech_complete;\n \tint nego_done;\n+\tint initiate;\n+\tint opened;\n \tOM_uint32 ctx_flags;\n \tgss_name_t internal_name;\n \tgss_OID actual_mech;""}<_**next**_>{""sha"": ""7849c85808c3adea3413b82ee2ec4b76d88604f5"", ""filename"": ""src/lib/gssapi/spnego/spnego_mech.c"", ""status"": ""modified"", ""additions"": 190, ""deletions"": 64, ""changes"": 254, ""blob_url"": ""https://github.com/krb5/krb5/blob/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""raw_url"": ""https://github.com/krb5/krb5/raw/b51b33f2bc5d1497ddf5bd107f791c101695000d/src/lib/gssapi/spnego/spnego_mech.c"", ""contents_url"": ""https://api.github.com/repos/krb5/krb5/contents/src/lib/gssapi/spnego/spnego_mech.c?ref=b51b33f2bc5d1497ddf5bd107f791c101695000d"", ""patch"": ""@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,\n \t\t\t\t      gss_cred_usage_t, gss_OID_set *);\n static void release_spnego_ctx(spnego_gss_ctx_id_t *);\n static void check_spnego_options(spnego_gss_ctx_id_t);\n-static spnego_gss_ctx_id_t create_spnego_ctx(void);\n+static spnego_gss_ctx_id_t create_spnego_ctx(int);\n static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);\n static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);\n static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);\n@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)\n }\n \n static spnego_gss_ctx_id_t\n-create_spnego_ctx(void)\n+create_spnego_ctx(int initiate)\n {\n \tspnego_gss_ctx_id_t spnego_ctx = NULL;\n \tspnego_ctx = (spnego_gss_ctx_id_t)\n@@ -477,6 +477,8 @@ create_spnego_ctx(void)\n \tspnego_ctx->mic_rcvd = 0;\n \tspnego_ctx->mech_complete = 0;\n \tspnego_ctx->nego_done = 0;\n+\tspnego_ctx->opened = 0;\n+\tspnego_ctx->initiate = initiate;\n \tspnego_ctx->internal_name = GSS_C_NO_NAME;\n \tspnego_ctx->actual_mech = GSS_C_NO_OID;\n \n@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \tOM_uint32 ret;\n \tspnego_gss_ctx_id_t sc = NULL;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(1);\n \tif (sc == NULL)\n \t\treturn GSS_S_FAILURE;\n \n@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n \t}\n-\t/*\n-\t * The actual context is not yet determined, set the output\n-\t * context handle to refer to the spnego context itself.\n-\t */\n+\n \tsc->ctx_handle = GSS_C_NO_CONTEXT;\n \t*ctx = (gss_ctx_id_t)sc;\n \tsc = NULL;\n@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(\n \t}\n \tgss_release_buffer(&tmpmin, &mechtok_out);\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t/*\n-\t\t * Now, switch the output context to refer to the\n-\t\t * negotiated mechanism's context.\n-\t\t */\n-\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n+\t\tspnego_ctx->opened = 1;\n \t\tif (actual_mech != NULL)\n \t\t\t*actual_mech = spnego_ctx->actual_mech;\n \t\tif (ret_flags != NULL)\n \t\t\t*ret_flags = spnego_ctx->ctx_flags;\n-\t\trelease_spnego_ctx(&spnego_ctx);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (spnego_ctx != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin,\n@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n-\tsc = create_spnego_ctx();\n+\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n-\t\tsc = create_spnego_ctx();\n+\t\tsc = create_spnego_ctx(0);\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(\n \t\t\tret = GSS_S_FAILURE;\n \t}\n \tif (ret == GSS_S_COMPLETE) {\n-\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n+\t\tsc->opened = 1;\n \t\tif (sc->internal_name != GSS_C_NO_NAME &&\n \t\t    src_name != NULL) {\n \t\t\t*src_name = sc->internal_name;\n \t\t\tsc->internal_name = GSS_C_NO_NAME;\n \t\t}\n-\t\trelease_spnego_ctx(&sc);\n \t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n \t\tif (sc != NULL) {\n \t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap(minor_status,\n-\t\t\tcontext_handle,\n+\t\t\tsc->ctx_handle,\n \t\t\tinput_message_buffer,\n \t\t\toutput_message_buffer,\n \t\t\tconf_state,\n@@ -2090,8 +2088,13 @@ spnego_gss_wrap(\n \t\tgss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    conf_req_flag,\n \t\t    qop_req,\n \t\t    input_message_buffer,\n@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(\n \t\t\t\tconst gss_buffer_t token_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* SPNEGO doesn't have its own context tokens. */\n+\tif (!sc->opened)\n+\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n+\n \tret = gss_process_context_token(minor_status,\n-\t\t\t\t\tcontext_handle,\n+\t\t\t\t\tsc->ctx_handle,\n \t\t\t\t\ttoken_buffer);\n \n \treturn (ret);\n@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(\n \tif (*ctx == NULL)\n \t\treturn (GSS_S_COMPLETE);\n \n-\t/*\n-\t * If this is still an SPNEGO mech, release it locally.\n-\t */\n-\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n-\t\t(void) gss_delete_sec_context(minor_status,\n-\t\t\t\t    &(*ctx)->ctx_handle,\n-\t\t\t\t    output_token);\n-\t\t(void) release_spnego_ctx(ctx);\n-\t} else {\n-\t\tret = gss_delete_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n-\t\t\t\t    output_token);\n-\t}\n+\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n+\t\t\t\t      output_token);\n+\t(void) release_spnego_ctx(ctx);\n \n \treturn (ret);\n }\n@@ -2157,8 +2156,13 @@ spnego_gss_context_time(\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_context_time(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(\n \t\t\t    gss_buffer_t interprocess_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n+\n+\t/* We don't currently support exporting partially established\n+\t * contexts. */\n+\tif (!sc->opened)\n+\t\treturn GSS_S_UNAVAILABLE;\n+\n \tret = gss_export_sec_context(minor_status,\n-\t\t\t\t    context_handle,\n+\t\t\t\t    &sc->ctx_handle,\n \t\t\t\t    interprocess_token);\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n+\t\trelease_spnego_ctx(&sc);\n+\t\t*context_handle = GSS_C_NO_CONTEXT;\n+\t}\n \treturn (ret);\n }\n \n@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(\n \tconst gss_buffer_t\tinterprocess_token,\n \tgss_ctx_id_t\t\t*context_handle)\n {\n-\tOM_uint32 ret;\n-\tret = gss_import_sec_context(minor_status,\n-\t\t\t\t    interprocess_token,\n-\t\t\t\t    context_handle);\n-\treturn (ret);\n+\t/*\n+\t * Until we implement partial context exports, there are no SPNEGO\n+\t * exported context tokens, only tokens for underlying mechs.  So just\n+\t * return an error for now.\n+\t */\n+\treturn GSS_S_UNAVAILABLE;\n }\n #endif /* LEAN_CLIENT */\n \n@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (src_name != NULL)\n+\t\t*src_name = GSS_C_NO_NAME;\n+\tif (targ_name != NULL)\n+\t\t*targ_name = GSS_C_NO_NAME;\n+\tif (lifetime_rec != NULL)\n+\t\t*lifetime_rec = 0;\n+\tif (mech_type != NULL)\n+\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\tif (ctx_flags != NULL)\n+\t\t*ctx_flags = 0;\n+\tif (locally_initiated != NULL)\n+\t\t*locally_initiated = sc->initiate;\n+\tif (opened != NULL)\n+\t\t*opened = sc->opened;\n+\n+\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n+\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n+\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n+\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n+\t}\n \n-\tret = gss_inquire_context(minor_status,\n-\t\t\t\tcontext_handle,\n-\t\t\t\tsrc_name,\n-\t\t\t\ttarg_name,\n-\t\t\t\tlifetime_rec,\n-\t\t\t\tmech_type,\n-\t\t\t\tctx_flags,\n-\t\t\t\tlocally_initiated,\n-\t\t\t\topened);\n+\tif (!sc->opened) {\n+\t\t/*\n+\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n+\t\t * the OID.  After negotiation is complete we will report the\n+\t\t * underlying mechanism OID.\n+\t\t */\n+\t\tif (mech_type != NULL)\n+\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n+\n+\t\t/*\n+\t\t * Remove flags we don't support with partially-established\n+\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n+\t\t * support for exporting partial SPNEGO contexts.)\n+\t\t */\n+\t\tif (ctx_flags != NULL) {\n+\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n+\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n+\t\t}\n+\t}\n \n \treturn (ret);\n }\n@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(\n \tOM_uint32\t*max_input_size)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_size_limit(minor_status,\n-\t\t\t\tcontext_handle,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tconf_req_flag,\n \t\t\t\tqop_req,\n \t\t\t\treq_output_size,\n@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(\n \t\tgss_buffer_t message_token)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_get_mic(minor_status,\n-\t\t    context_handle,\n+\t\t    sc->ctx_handle,\n \t\t    qop_req,\n \t\t    message_buffer,\n \t\t    message_token);\n@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(\n \t\tgss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_verify_mic(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    msg_buffer,\n \t\t\t    token_buffer,\n \t\t\t    qop_state);\n@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(\n \t\tgss_buffer_set_t *data_set)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function. */\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_inquire_sec_context_by_oid(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    data_set);\n \treturn (ret);\n@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n+\n+\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n+\t * construct an empty SPNEGO context with it. */\n+\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_set_sec_context_option(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    &sc->ctx_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_aead(minor_status,\n-\t\t\t    context_handle,\n+\t\t\t    sc->ctx_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n \t\t       gss_qop_t *qop_state)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_aead(minor_status,\n-\t\t\t      context_handle,\n+\t\t\t      sc->ctx_handle,\n \t\t\t      input_message_buffer,\n \t\t\t      input_assoc_buffer,\n \t\t\t      output_payload_buffer,\n@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov(minor_status,\n-\t\t\t   context_handle,\n+\t\t\t   sc->ctx_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n \t\t      int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_unwrap_iov(minor_status,\n-\t\t\t     context_handle,\n+\t\t\t     sc->ctx_handle,\n \t\t\t     conf_state,\n \t\t\t     qop_state,\n \t\t\t     iov,\n@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n \t\t\t   int iov_count)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_wrap_iov_length(minor_status,\n-\t\t\t\t  context_handle,\n+\t\t\t\t  sc->ctx_handle,\n \t\t\t\t  conf_req_flag,\n \t\t\t\t  qop_req,\n \t\t\t\t  conf_state,\n@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(\n \t\tgss_buffer_t input_message_buffer)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_UNAVAILABLE);\n+\n \tret = gss_complete_auth_token(minor_status,\n-\t\t\t\t      context_handle,\n+\t\t\t\t      sc->ctx_handle,\n \t\t\t\t      input_message_buffer);\n \treturn (ret);\n }\n@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,\n \t\t\t gss_buffer_t prf_out)\n {\n \tOM_uint32 ret;\n+\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n+\n+\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t\treturn (GSS_S_NO_CONTEXT);\n+\n \tret = gss_pseudo_random(minor_status,\n-\t\t\t\tcontext,\n+\t\t\t\tsc->ctx_handle,\n \t\t\t\tprf_key,\n \t\t\t\tprf_in,\n \t\t\t\tdesired_output_len,\n@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n \n@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n \t\t\t  int iov_count)\n {\n-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n \t\t\t      iov_count);\n }\n \n@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n \t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n \t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n {\n-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n+\n+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n+\t    return (GSS_S_NO_CONTEXT);\n+\n+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n \t\t\t\t  iov_count);\n }\n ""}","spnego_gss_wrap_size_limit(
	OM_uint32	*minor_status,
	const gss_ctx_id_t context_handle,
	int		conf_req_flag,
	gss_qop_t	qop_req,
	OM_uint32	req_output_size,
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_NO_CONTEXT);

 	ret = gss_wrap_size_limit(minor_status,
				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
				max_input_size);
	return (ret);
}
","spnego_gss_wrap_size_limit(
	OM_uint32	*minor_status,
	const gss_ctx_id_t context_handle,
	int		conf_req_flag,
	gss_qop_t	qop_req,
	OM_uint32	req_output_size,
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
 	ret = gss_wrap_size_limit(minor_status,
				context_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
				max_input_size);
	return (ret);
}
",C,"	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;

	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
		return (GSS_S_NO_CONTEXT);

				sc->ctx_handle,
","				context_handle,
",,"@@ -102,7 +102,7 @@ static OM_uint32 get_negotiable_mechs(OM_uint32 *, spnego_gss_cred_id_t,
 				      gss_cred_usage_t, gss_OID_set *);
 static void release_spnego_ctx(spnego_gss_ctx_id_t *);
 static void check_spnego_options(spnego_gss_ctx_id_t);
-static spnego_gss_ctx_id_t create_spnego_ctx(void);
+static spnego_gss_ctx_id_t create_spnego_ctx(int);
 static int put_mech_set(gss_OID_set mechSet, gss_buffer_t buf);
 static int put_input_token(unsigned char **, gss_buffer_t, unsigned int);
 static int put_mech_oid(unsigned char **, gss_OID_const, unsigned int);
@@ -454,7 +454,7 @@ check_spnego_options(spnego_gss_ctx_id_t spnego_ctx)
 }
 
 static spnego_gss_ctx_id_t
-create_spnego_ctx(void)
+create_spnego_ctx(int initiate)
 {
 	spnego_gss_ctx_id_t spnego_ctx = NULL;
 	spnego_ctx = (spnego_gss_ctx_id_t)
@@ -477,6 +477,8 @@ create_spnego_ctx(void)
 	spnego_ctx->mic_rcvd = 0;
 	spnego_ctx->mech_complete = 0;
 	spnego_ctx->nego_done = 0;
+	spnego_ctx->opened = 0;
+	spnego_ctx->initiate = initiate;
 	spnego_ctx->internal_name = GSS_C_NO_NAME;
 	spnego_ctx->actual_mech = GSS_C_NO_OID;
 
@@ -642,7 +644,7 @@ init_ctx_new(OM_uint32 *minor_status,
 	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = NULL;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(1);
 	if (sc == NULL)
 		return GSS_S_FAILURE;
 
@@ -659,10 +661,7 @@ init_ctx_new(OM_uint32 *minor_status,
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
-	/*
-	 * The actual context is not yet determined, set the output
-	 * context handle to refer to the spnego context itself.
-	 */
+
 	sc->ctx_handle = GSS_C_NO_CONTEXT;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
@@ -1108,16 +1107,11 @@ spnego_gss_init_sec_context(
 	}
 	gss_release_buffer(&tmpmin, &mechtok_out);
 	if (ret == GSS_S_COMPLETE) {
-		/*
-		 * Now, switch the output context to refer to the
-		 * negotiated mechanism's context.
-		 */
-		*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;
+		spnego_ctx->opened = 1;
 		if (actual_mech != NULL)
 			*actual_mech = spnego_ctx->actual_mech;
 		if (ret_flags != NULL)
 			*ret_flags = spnego_ctx->ctx_flags;
-		release_spnego_ctx(&spnego_ctx);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (spnego_ctx != NULL) {
 			gss_delete_sec_context(&tmpmin,
@@ -1285,7 +1279,7 @@ acc_ctx_hints(OM_uint32 *minor_status,
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
-	sc = create_spnego_ctx();
+	sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
@@ -1367,7 +1361,7 @@ acc_ctx_new(OM_uint32 *minor_status,
 		gss_release_buffer(&tmpmin, &sc->DER_mechTypes);
 		assert(mech_wanted != GSS_C_NO_OID);
 	} else
-		sc = create_spnego_ctx();
+		sc = create_spnego_ctx(0);
 	if (sc == NULL) {
 		ret = GSS_S_FAILURE;
 		*return_token = NO_TOKEN_SEND;
@@ -1750,13 +1744,12 @@ spnego_gss_accept_sec_context(
 			ret = GSS_S_FAILURE;
 	}
 	if (ret == GSS_S_COMPLETE) {
-		*context_handle = (gss_ctx_id_t)sc->ctx_handle;
+		sc->opened = 1;
 		if (sc->internal_name != GSS_C_NO_NAME &&
 		    src_name != NULL) {
 			*src_name = sc->internal_name;
 			sc->internal_name = GSS_C_NO_NAME;
 		}
-		release_spnego_ctx(&sc);
 	} else if (ret != GSS_S_CONTINUE_NEEDED) {
 		if (sc != NULL) {
 			gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
@@ -2069,8 +2062,13 @@ spnego_gss_unwrap(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap(minor_status,
-			context_handle,
+			sc->ctx_handle,
 			input_message_buffer,
 			output_message_buffer,
 			conf_state,
@@ -2090,8 +2088,13 @@ spnego_gss_wrap(
 		gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    conf_req_flag,
 		    qop_req,
 		    input_message_buffer,
@@ -2108,8 +2111,14 @@ spnego_gss_process_context_token(
 				const gss_buffer_t token_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* SPNEGO doesn't have its own context tokens. */
+	if (!sc->opened)
+		return (GSS_S_DEFECTIVE_TOKEN);
+
 	ret = gss_process_context_token(minor_status,
-					context_handle,
+					sc->ctx_handle,
 					token_buffer);
 
 	return (ret);
@@ -2133,19 +2142,9 @@ spnego_gss_delete_sec_context(
 	if (*ctx == NULL)
 		return (GSS_S_COMPLETE);
 
-	/*
-	 * If this is still an SPNEGO mech, release it locally.
-	 */
-	if ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {
-		(void) gss_delete_sec_context(minor_status,
-				    &(*ctx)->ctx_handle,
-				    output_token);
-		(void) release_spnego_ctx(ctx);
-	} else {
-		ret = gss_delete_sec_context(minor_status,
-				    context_handle,
-				    output_token);
-	}
+	(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,
+				      output_token);
+	(void) release_spnego_ctx(ctx);
 
 	return (ret);
 }
@@ -2157,8 +2156,13 @@ spnego_gss_context_time(
 			OM_uint32	*time_rec)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_context_time(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    time_rec);
 	return (ret);
 }
@@ -2170,9 +2174,20 @@ spnego_gss_export_sec_context(
 			    gss_buffer_t interprocess_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;
+
+	/* We don't currently support exporting partially established
+	 * contexts. */
+	if (!sc->opened)
+		return GSS_S_UNAVAILABLE;
+
 	ret = gss_export_sec_context(minor_status,
-				    context_handle,
+				    &sc->ctx_handle,
 				    interprocess_token);
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT) {
+		release_spnego_ctx(&sc);
+		*context_handle = GSS_C_NO_CONTEXT;
+	}
 	return (ret);
 }
 
@@ -2182,11 +2197,12 @@ spnego_gss_import_sec_context(
 	const gss_buffer_t	interprocess_token,
 	gss_ctx_id_t		*context_handle)
 {
-	OM_uint32 ret;
-	ret = gss_import_sec_context(minor_status,
-				    interprocess_token,
-				    context_handle);
-	return (ret);
+	/*
+	 * Until we implement partial context exports, there are no SPNEGO
+	 * exported context tokens, only tokens for underlying mechs.  So just
+	 * return an error for now.
+	 */
+	return GSS_S_UNAVAILABLE;
 }
 #endif /* LEAN_CLIENT */
 
@@ -2203,16 +2219,48 @@ spnego_gss_inquire_context(
 			int		*opened)
 {
 	OM_uint32 ret = GSS_S_COMPLETE;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (src_name != NULL)
+		*src_name = GSS_C_NO_NAME;
+	if (targ_name != NULL)
+		*targ_name = GSS_C_NO_NAME;
+	if (lifetime_rec != NULL)
+		*lifetime_rec = 0;
+	if (mech_type != NULL)
+		*mech_type = (gss_OID)gss_mech_spnego;
+	if (ctx_flags != NULL)
+		*ctx_flags = 0;
+	if (locally_initiated != NULL)
+		*locally_initiated = sc->initiate;
+	if (opened != NULL)
+		*opened = sc->opened;
+
+	if (sc->ctx_handle != GSS_C_NO_CONTEXT) {
+		ret = gss_inquire_context(minor_status, sc->ctx_handle,
+					  src_name, targ_name, lifetime_rec,
+					  mech_type, ctx_flags, NULL, NULL);
+	}
 
-	ret = gss_inquire_context(minor_status,
-				context_handle,
-				src_name,
-				targ_name,
-				lifetime_rec,
-				mech_type,
-				ctx_flags,
-				locally_initiated,
-				opened);
+	if (!sc->opened) {
+		/*
+		 * We are still doing SPNEGO negotiation, so report SPNEGO as
+		 * the OID.  After negotiation is complete we will report the
+		 * underlying mechanism OID.
+		 */
+		if (mech_type != NULL)
+			*mech_type = (gss_OID)gss_mech_spnego;
+
+		/*
+		 * Remove flags we don't support with partially-established
+		 * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add
+		 * support for exporting partial SPNEGO contexts.)
+		 */
+		if (ctx_flags != NULL) {
+			*ctx_flags &= ~GSS_C_PROT_READY_FLAG;
+			*ctx_flags &= ~GSS_C_TRANS_FLAG;
+		}
+	}
 
 	return (ret);
 }
@@ -2227,8 +2275,13 @@ spnego_gss_wrap_size_limit(
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_size_limit(minor_status,
-				context_handle,
+				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
@@ -2245,8 +2298,13 @@ spnego_gss_get_mic(
 		gss_buffer_t message_token)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_get_mic(minor_status,
-		    context_handle,
+		    sc->ctx_handle,
 		    qop_req,
 		    message_buffer,
 		    message_token);
@@ -2262,8 +2320,13 @@ spnego_gss_verify_mic(
 		gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_verify_mic(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    msg_buffer,
 			    token_buffer,
 			    qop_state);
@@ -2278,8 +2341,14 @@ spnego_gss_inquire_sec_context_by_oid(
 		gss_buffer_set_t *data_set)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function. */
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_inquire_sec_context_by_oid(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    desired_object,
 			    data_set);
 	return (ret);
@@ -2359,8 +2428,15 @@ spnego_gss_set_sec_context_option(
 		const gss_buffer_t value)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
+
+	/* There are no SPNEGO-specific OIDs for this function, and we cannot
+	 * construct an empty SPNEGO context with it. */
+	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_set_sec_context_option(minor_status,
-			    context_handle,
+			    &sc->ctx_handle,
 			    desired_object,
 			    value);
 	return (ret);
@@ -2377,8 +2453,13 @@ spnego_gss_wrap_aead(OM_uint32 *minor_status,
 		     gss_buffer_t output_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_aead(minor_status,
-			    context_handle,
+			    sc->ctx_handle,
 			    conf_req_flag,
 			    qop_req,
 			    input_assoc_buffer,
@@ -2399,8 +2480,13 @@ spnego_gss_unwrap_aead(OM_uint32 *minor_status,
 		       gss_qop_t *qop_state)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_aead(minor_status,
-			      context_handle,
+			      sc->ctx_handle,
 			      input_message_buffer,
 			      input_assoc_buffer,
 			      output_payload_buffer,
@@ -2419,8 +2505,13 @@ spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov(minor_status,
-			   context_handle,
+			   sc->ctx_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
@@ -2438,8 +2529,13 @@ spnego_gss_unwrap_iov(OM_uint32 *minor_status,
 		      int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_unwrap_iov(minor_status,
-			     context_handle,
+			     sc->ctx_handle,
 			     conf_state,
 			     qop_state,
 			     iov,
@@ -2457,8 +2553,13 @@ spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
 			   int iov_count)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_wrap_iov_length(minor_status,
-				  context_handle,
+				  sc->ctx_handle,
 				  conf_req_flag,
 				  qop_req,
 				  conf_state,
@@ -2475,8 +2576,13 @@ spnego_gss_complete_auth_token(
 		gss_buffer_t input_message_buffer)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_UNAVAILABLE);
+
 	ret = gss_complete_auth_token(minor_status,
-				      context_handle,
+				      sc->ctx_handle,
 				      input_message_buffer);
 	return (ret);
 }
@@ -2721,8 +2827,13 @@ spnego_gss_pseudo_random(OM_uint32 *minor_status,
 			 gss_buffer_t prf_out)
 {
 	OM_uint32 ret;
+	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;
+
+	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+		return (GSS_S_NO_CONTEXT);
+
 	ret = gss_pseudo_random(minor_status,
-				context,
+				sc->ctx_handle,
 				prf_key,
 				prf_in,
 				desired_output_len,
@@ -2863,7 +2974,12 @@ spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 		       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
 		       int iov_count)
 {
-    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,
 			   iov_count);
 }
 
@@ -2872,7 +2988,12 @@ spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
 			  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
 			  int iov_count)
 {
-    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,
 			      iov_count);
 }
 
@@ -2881,7 +3002,12 @@ spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
 			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
 			      gss_iov_buffer_desc *iov, int iov_count)
 {
-    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+
+    if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+	    return (GSS_S_NO_CONTEXT);
+
+    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
 				  iov_count);
 }
 ",krb5,b51b33f2bc5d1497ddf5bd107f791c101695000d,e767d9fe054a9976d3d7ef25348688fc54995832,1,"spnego_gss_wrap_size_limit(
	OM_uint32	*minor_status,
	const gss_ctx_id_t context_handle,
	int		conf_req_flag,
	gss_qop_t	qop_req,
	OM_uint32	req_output_size,
 	OM_uint32	*max_input_size)
 {
 	OM_uint32 ret;
//fix_flaw_line_below:
//	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
//fix_flaw_line_below:
//		return (GSS_S_NO_CONTEXT);
//fix_flaw_line_below:
//
 	ret = gss_wrap_size_limit(minor_status,
//flaw_line_below:
				context_handle,
//fix_flaw_line_below:
//				sc->ctx_handle,
 				conf_req_flag,
 				qop_req,
 				req_output_size,
				max_input_size);
	return (ret);
}
"
