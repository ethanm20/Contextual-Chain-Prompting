,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix
331,178067,,Local,Not required,Complete,CVE-2016-9913,https://www.cvedetails.com/cve/CVE-2016-9913/,CWE-400,Low,,,,2016-12-29,4.9,Memory leak in the v9fs_device_unrealize_common function in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local privileged guest OS users to cause a denial of service (host memory consumption and possibly QEMU process crash) via vectors involving the order of resource cleanup.,2017-06-30,DoS,1,https://git.qemu.org/?p=qemu.git;a=commit;h=4774718e5c194026ba5ee7a28d9be49be3080e42,4774718e5c194026ba5ee7a28d9be49be3080e42,,1,,,"int v9fs_device_realize_common(V9fsState *s, Error **errp)
{
    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);
    int i, len;
    struct stat stat;
    FsDriverEntry *fse;
    V9fsPath path;
    int rc = 1;

    /* initialize pdu allocator */
    QLIST_INIT(&s->free_list);
    QLIST_INIT(&s->active_list);
    for (i = 0; i < (MAX_REQ - 1); i++) {
        QLIST_INSERT_HEAD(&s->free_list, &v->pdus[i], next);
        v->pdus[i].s = s;
        v->pdus[i].idx = i;
    }

    v9fs_path_init(&path);

    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);

    if (!fse) {
        /* We don't have a fsdev identified by fsdev_id */
        error_setg(errp, ""9pfs device couldn't find fsdev with the ""
                   ""id = %s"",
                   s->fsconf.fsdev_id ? s->fsconf.fsdev_id : ""NULL"");
        goto out;
    }

    if (!s->fsconf.tag) {
        /* we haven't specified a mount_tag */
        error_setg(errp, ""fsdev with id %s needs mount_tag arguments"",
                   s->fsconf.fsdev_id);
        goto out;
    }

    s->ctx.export_flags = fse->export_flags;
    s->ctx.fs_root = g_strdup(fse->path);
    s->ctx.exops.get_st_gen = NULL;
    len = strlen(s->fsconf.tag);
    if (len > MAX_TAG_LEN - 1) {
        error_setg(errp, ""mount tag '%s' (%d bytes) is longer than ""
                   ""maximum (%d bytes)"", s->fsconf.tag, len, MAX_TAG_LEN - 1);
        goto out;
    }

    s->tag = g_strdup(s->fsconf.tag);
    s->ctx.uid = -1;

    s->ops = fse->ops;

    s->fid_list = NULL;
    qemu_co_rwlock_init(&s->rename_lock);

    if (s->ops->init(&s->ctx) < 0) {
        error_setg(errp, ""9pfs Failed to initialize fs-driver with id:%s""
                   "" and export path:%s"", s->fsconf.fsdev_id, s->ctx.fs_root);
        goto out;
    }

    /*
     * Check details of export path, We need to use fs driver
     * call back to do that. Since we are in the init path, we don't
     * use co-routines here.
     */
    if (s->ops->name_to_path(&s->ctx, NULL, ""/"", &path) < 0) {
        error_setg(errp,
                   ""error in converting name to path %s"", strerror(errno));
        goto out;
    }
    if (s->ops->lstat(&s->ctx, &path, &stat)) {
        error_setg(errp, ""share path %s does not exist"", fse->path);
        goto out;
    } else if (!S_ISDIR(stat.st_mode)) {
        error_setg(errp, ""share path %s is not a directory"", fse->path);
        goto out;
    }
    v9fs_path_free(&path);

     rc = 0;
 out:
     if (rc) {
         g_free(s->tag);
        g_free(s->ctx.fs_root);
         v9fs_path_free(&path);
     }
     return rc;
}
","int v9fs_device_realize_common(V9fsState *s, Error **errp)
{
    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);
    int i, len;
    struct stat stat;
    FsDriverEntry *fse;
    V9fsPath path;
    int rc = 1;

    /* initialize pdu allocator */
    QLIST_INIT(&s->free_list);
    QLIST_INIT(&s->active_list);
    for (i = 0; i < (MAX_REQ - 1); i++) {
        QLIST_INSERT_HEAD(&s->free_list, &v->pdus[i], next);
        v->pdus[i].s = s;
        v->pdus[i].idx = i;
    }

    v9fs_path_init(&path);

    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);

    if (!fse) {
        /* We don't have a fsdev identified by fsdev_id */
        error_setg(errp, ""9pfs device couldn't find fsdev with the ""
                   ""id = %s"",
                   s->fsconf.fsdev_id ? s->fsconf.fsdev_id : ""NULL"");
        goto out;
    }

    if (!s->fsconf.tag) {
        /* we haven't specified a mount_tag */
        error_setg(errp, ""fsdev with id %s needs mount_tag arguments"",
                   s->fsconf.fsdev_id);
        goto out;
    }

    s->ctx.export_flags = fse->export_flags;
    s->ctx.fs_root = g_strdup(fse->path);
    s->ctx.exops.get_st_gen = NULL;
    len = strlen(s->fsconf.tag);
    if (len > MAX_TAG_LEN - 1) {
        error_setg(errp, ""mount tag '%s' (%d bytes) is longer than ""
                   ""maximum (%d bytes)"", s->fsconf.tag, len, MAX_TAG_LEN - 1);
        goto out;
    }

    s->tag = g_strdup(s->fsconf.tag);
    s->ctx.uid = -1;

    s->ops = fse->ops;

    s->fid_list = NULL;
    qemu_co_rwlock_init(&s->rename_lock);

    if (s->ops->init(&s->ctx) < 0) {
        error_setg(errp, ""9pfs Failed to initialize fs-driver with id:%s""
                   "" and export path:%s"", s->fsconf.fsdev_id, s->ctx.fs_root);
        goto out;
    }

    /*
     * Check details of export path, We need to use fs driver
     * call back to do that. Since we are in the init path, we don't
     * use co-routines here.
     */
    if (s->ops->name_to_path(&s->ctx, NULL, ""/"", &path) < 0) {
        error_setg(errp,
                   ""error in converting name to path %s"", strerror(errno));
        goto out;
    }
    if (s->ops->lstat(&s->ctx, &path, &stat)) {
        error_setg(errp, ""share path %s does not exist"", fse->path);
        goto out;
    } else if (!S_ISDIR(stat.st_mode)) {
        error_setg(errp, ""share path %s is not a directory"", fse->path);
        goto out;
    }
    v9fs_path_free(&path);

     rc = 0;
 out:
     if (rc) {
        g_free(s->ctx.fs_root);
         g_free(s->tag);
         v9fs_path_free(&path);
     }
     return rc;
}
",C,"        g_free(s->ctx.fs_root);
","        g_free(s->ctx.fs_root);
",00227fefd2059464cd2f59aed29944874c630e2f,"@@ -3521,8 +3521,8 @@ int v9fs_device_realize_common(V9fsState *s, Error **errp)
     rc = 0;
 out:
     if (rc) {
-        g_free(s->ctx.fs_root);
         g_free(s->tag);
+        g_free(s->ctx.fs_root);
         v9fs_path_free(&path);
     }
     return rc;
@@ -3530,8 +3530,8 @@ out:
 
 void v9fs_device_unrealize_common(V9fsState *s, Error **errp)
 {
-    g_free(s->ctx.fs_root);
     g_free(s->tag);
+    g_free(s->ctx.fs_root);
 }
 
 typedef struct VirtfsCoResetData {",qemu,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/9pfs/9p.c;h=087b5c98eec1bd475eba39003f3c86dfe4e8a2f2;hb=087b5c98eec1bd475eba39003f3c86dfe4e8a2f2,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/9pfs/9p.c;h=aea7e9d392061edbea2b4375d879ed5a123ea0a0;hb=aea7e9d392061edbea2b4375d879ed5a123ea0a0,1,"int v9fs_device_realize_common(V9fsState *s, Error **errp)
{
    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);
    int i, len;
    struct stat stat;
    FsDriverEntry *fse;
    V9fsPath path;
    int rc = 1;

    /* initialize pdu allocator */
    QLIST_INIT(&s->free_list);
    QLIST_INIT(&s->active_list);
    for (i = 0; i < (MAX_REQ - 1); i++) {
        QLIST_INSERT_HEAD(&s->free_list, &v->pdus[i], next);
        v->pdus[i].s = s;
        v->pdus[i].idx = i;
    }

    v9fs_path_init(&path);

    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);

    if (!fse) {
        /* We don't have a fsdev identified by fsdev_id */
        error_setg(errp, ""9pfs device couldn't find fsdev with the ""
                   ""id = %s"",
                   s->fsconf.fsdev_id ? s->fsconf.fsdev_id : ""NULL"");
        goto out;
    }

    if (!s->fsconf.tag) {
        /* we haven't specified a mount_tag */
        error_setg(errp, ""fsdev with id %s needs mount_tag arguments"",
                   s->fsconf.fsdev_id);
        goto out;
    }

    s->ctx.export_flags = fse->export_flags;
    s->ctx.fs_root = g_strdup(fse->path);
    s->ctx.exops.get_st_gen = NULL;
    len = strlen(s->fsconf.tag);
    if (len > MAX_TAG_LEN - 1) {
        error_setg(errp, ""mount tag '%s' (%d bytes) is longer than ""
                   ""maximum (%d bytes)"", s->fsconf.tag, len, MAX_TAG_LEN - 1);
        goto out;
    }

    s->tag = g_strdup(s->fsconf.tag);
    s->ctx.uid = -1;

    s->ops = fse->ops;

    s->fid_list = NULL;
    qemu_co_rwlock_init(&s->rename_lock);

    if (s->ops->init(&s->ctx) < 0) {
        error_setg(errp, ""9pfs Failed to initialize fs-driver with id:%s""
                   "" and export path:%s"", s->fsconf.fsdev_id, s->ctx.fs_root);
        goto out;
    }

    /*
     * Check details of export path, We need to use fs driver
     * call back to do that. Since we are in the init path, we don't
     * use co-routines here.
     */
    if (s->ops->name_to_path(&s->ctx, NULL, ""/"", &path) < 0) {
        error_setg(errp,
                   ""error in converting name to path %s"", strerror(errno));
        goto out;
    }
    if (s->ops->lstat(&s->ctx, &path, &stat)) {
        error_setg(errp, ""share path %s does not exist"", fse->path);
        goto out;
    } else if (!S_ISDIR(stat.st_mode)) {
        error_setg(errp, ""share path %s is not a directory"", fse->path);
        goto out;
    }
    v9fs_path_free(&path);

     rc = 0;
 out:
     if (rc) {
//flaw_line_below:
        g_free(s->ctx.fs_root);
         g_free(s->tag);
//fix_flaw_line_below:
//        g_free(s->ctx.fs_root);
         v9fs_path_free(&path);
     }
     return rc;
}
"
332,178068,,Local,Not required,Complete,CVE-2016-9913,https://www.cvedetails.com/cve/CVE-2016-9913/,CWE-400,Low,,,,2016-12-29,4.9,Memory leak in the v9fs_device_unrealize_common function in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local privileged guest OS users to cause a denial of service (host memory consumption and possibly QEMU process crash) via vectors involving the order of resource cleanup.,2017-06-30,DoS,1,https://git.qemu.org/?p=qemu.git;a=commit;h=4774718e5c194026ba5ee7a28d9be49be3080e42,4774718e5c194026ba5ee7a28d9be49be3080e42,,1,,," void v9fs_device_unrealize_common(V9fsState *s, Error **errp)
 {
     g_free(s->tag);
    g_free(s->ctx.fs_root);
 }
"," void v9fs_device_unrealize_common(V9fsState *s, Error **errp)
 {
    g_free(s->ctx.fs_root);
     g_free(s->tag);
 }
",C,"    g_free(s->ctx.fs_root);
","    g_free(s->ctx.fs_root);
",00227fefd2059464cd2f59aed29944874c630e2f,"@@ -3521,8 +3521,8 @@ int v9fs_device_realize_common(V9fsState *s, Error **errp)
     rc = 0;
 out:
     if (rc) {
-        g_free(s->ctx.fs_root);
         g_free(s->tag);
+        g_free(s->ctx.fs_root);
         v9fs_path_free(&path);
     }
     return rc;
@@ -3530,8 +3530,8 @@ out:
 
 void v9fs_device_unrealize_common(V9fsState *s, Error **errp)
 {
-    g_free(s->ctx.fs_root);
     g_free(s->tag);
+    g_free(s->ctx.fs_root);
 }
 
 typedef struct VirtfsCoResetData {",qemu,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/9pfs/9p.c;h=087b5c98eec1bd475eba39003f3c86dfe4e8a2f2;hb=087b5c98eec1bd475eba39003f3c86dfe4e8a2f2,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/9pfs/9p.c;h=aea7e9d392061edbea2b4375d879ed5a123ea0a0;hb=aea7e9d392061edbea2b4375d879ed5a123ea0a0,1," void v9fs_device_unrealize_common(V9fsState *s, Error **errp)
 {
//flaw_line_below:
    g_free(s->ctx.fs_root);
     g_free(s->tag);
//fix_flaw_line_below:
//    g_free(s->ctx.fs_root);
 }
"
398,178134,,Remote,Not required,Partial,CVE-2016-6307,https://www.cvedetails.com/cve/CVE-2016-6307/,CWE-400,Medium,,,,2016-09-26,4.3,"The state-machine implementation in OpenSSL 1.1.0 before 1.1.0a allocates memory before checking for an excessive length, which might allow remote attackers to cause a denial of service (memory consumption) via crafted TLS messages, related to statem/statem.c and statem/statem_lib.c.",2018-04-19,DoS,11,https://git.openssl.org/?p=openssl.git;a=commit;h=4b390b6c3f8df925dc92a3dd6b022baa9a2f4650,4b390b6c3f8df925dc92a3dd6b022baa9a2f4650,,0,,,"static SUB_STATE_RETURN read_state_machine(SSL *s)
{
    OSSL_STATEM *st = &s->statem;
    int ret, mt;
    unsigned long len = 0;
    int (*transition) (SSL *s, int mt);
    PACKET pkt;
    MSG_PROCESS_RETURN(*process_message) (SSL *s, PACKET *pkt);
    WORK_STATE(*post_process_message) (SSL *s, WORK_STATE wst);
    unsigned long (*max_message_size) (SSL *s);
    void (*cb) (const SSL *ssl, int type, int val) = NULL;

    cb = get_callback(s);

    if (s->server) {
        transition = ossl_statem_server_read_transition;
        process_message = ossl_statem_server_process_message;
        max_message_size = ossl_statem_server_max_message_size;
        post_process_message = ossl_statem_server_post_process_message;
    } else {
        transition = ossl_statem_client_read_transition;
        process_message = ossl_statem_client_process_message;
        max_message_size = ossl_statem_client_max_message_size;
        post_process_message = ossl_statem_client_post_process_message;
    }

    if (st->read_state_first_init) {
        s->first_packet = 1;
        st->read_state_first_init = 0;
    }

    while (1) {
        switch (st->read_state) {
        case READ_STATE_HEADER:
            /* Get the state the peer wants to move to */
            if (SSL_IS_DTLS(s)) {
                /*
                 * In DTLS we get the whole message in one go - header and body
                 */
                ret = dtls_get_message(s, &mt, &len);
            } else {
                ret = tls_get_message_header(s, &mt);
            }

            if (ret == 0) {
                /* Could be non-blocking IO */
                return SUB_STATE_ERROR;
            }

            if (cb != NULL) {
                /* Notify callback of an impending state change */
                if (s->server)
                    cb(s, SSL_CB_ACCEPT_LOOP, 1);
                else
                    cb(s, SSL_CB_CONNECT_LOOP, 1);
            }
            /*
             * Validate that we are allowed to move to the new state and move
             * to that state if so
             */
            if (!transition(s, mt)) {
                ossl_statem_set_error(s);
                return SUB_STATE_ERROR;
            }

            if (s->s3->tmp.message_size > max_message_size(s)) {
                ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);
                SSLerr(SSL_F_READ_STATE_MACHINE, SSL_R_EXCESSIVE_MESSAGE_SIZE);
                 return SUB_STATE_ERROR;
             }
 
            /* dtls_get_message already did this */
            if (!SSL_IS_DTLS(s)
                    && s->s3->tmp.message_size > 0
                    && !BUF_MEM_grow_clean(s->init_buf,
                                           (int)s->s3->tmp.message_size
                                           + SSL3_HM_HEADER_LENGTH)) {
                ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);
                SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, ERR_R_BUF_LIB);
                return SUB_STATE_ERROR;
            }

             st->read_state = READ_STATE_BODY;
             /* Fall through */
            if (!PACKET_buf_init(&pkt, s->init_msg, len)) {
                ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);
                SSLerr(SSL_F_READ_STATE_MACHINE, ERR_R_INTERNAL_ERROR);
                return SUB_STATE_ERROR;
            }
            ret = process_message(s, &pkt);

            /* Discard the packet data */
            s->init_num = 0;

            switch (ret) {
            case MSG_PROCESS_ERROR:
                return SUB_STATE_ERROR;

            case MSG_PROCESS_FINISHED_READING:
                if (SSL_IS_DTLS(s)) {
                    dtls1_stop_timer(s);
                }
                return SUB_STATE_FINISHED;

            case MSG_PROCESS_CONTINUE_PROCESSING:
                st->read_state = READ_STATE_POST_PROCESS;
                st->read_state_work = WORK_MORE_A;
                break;

            default:
                st->read_state = READ_STATE_HEADER;
                break;
            }
            break;

        case READ_STATE_POST_PROCESS:
            st->read_state_work = post_process_message(s, st->read_state_work);
            switch (st->read_state_work) {
            default:
                return SUB_STATE_ERROR;

            case WORK_FINISHED_CONTINUE:
                st->read_state = READ_STATE_HEADER;
                break;

            case WORK_FINISHED_STOP:
                if (SSL_IS_DTLS(s)) {
                    dtls1_stop_timer(s);
                }
                return SUB_STATE_FINISHED;
            }
            break;

        default:
            /* Shouldn't happen */
            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);
            SSLerr(SSL_F_READ_STATE_MACHINE, ERR_R_INTERNAL_ERROR);
            ossl_statem_set_error(s);
            return SUB_STATE_ERROR;
        }
    }
}
","static SUB_STATE_RETURN read_state_machine(SSL *s)
{
    OSSL_STATEM *st = &s->statem;
    int ret, mt;
    unsigned long len = 0;
    int (*transition) (SSL *s, int mt);
    PACKET pkt;
    MSG_PROCESS_RETURN(*process_message) (SSL *s, PACKET *pkt);
    WORK_STATE(*post_process_message) (SSL *s, WORK_STATE wst);
    unsigned long (*max_message_size) (SSL *s);
    void (*cb) (const SSL *ssl, int type, int val) = NULL;

    cb = get_callback(s);

    if (s->server) {
        transition = ossl_statem_server_read_transition;
        process_message = ossl_statem_server_process_message;
        max_message_size = ossl_statem_server_max_message_size;
        post_process_message = ossl_statem_server_post_process_message;
    } else {
        transition = ossl_statem_client_read_transition;
        process_message = ossl_statem_client_process_message;
        max_message_size = ossl_statem_client_max_message_size;
        post_process_message = ossl_statem_client_post_process_message;
    }

    if (st->read_state_first_init) {
        s->first_packet = 1;
        st->read_state_first_init = 0;
    }

    while (1) {
        switch (st->read_state) {
        case READ_STATE_HEADER:
            /* Get the state the peer wants to move to */
            if (SSL_IS_DTLS(s)) {
                /*
                 * In DTLS we get the whole message in one go - header and body
                 */
                ret = dtls_get_message(s, &mt, &len);
            } else {
                ret = tls_get_message_header(s, &mt);
            }

            if (ret == 0) {
                /* Could be non-blocking IO */
                return SUB_STATE_ERROR;
            }

            if (cb != NULL) {
                /* Notify callback of an impending state change */
                if (s->server)
                    cb(s, SSL_CB_ACCEPT_LOOP, 1);
                else
                    cb(s, SSL_CB_CONNECT_LOOP, 1);
            }
            /*
             * Validate that we are allowed to move to the new state and move
             * to that state if so
             */
            if (!transition(s, mt)) {
                ossl_statem_set_error(s);
                return SUB_STATE_ERROR;
            }

            if (s->s3->tmp.message_size > max_message_size(s)) {
                ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);
                SSLerr(SSL_F_READ_STATE_MACHINE, SSL_R_EXCESSIVE_MESSAGE_SIZE);
                 return SUB_STATE_ERROR;
             }
 
             st->read_state = READ_STATE_BODY;
             /* Fall through */
            if (!PACKET_buf_init(&pkt, s->init_msg, len)) {
                ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);
                SSLerr(SSL_F_READ_STATE_MACHINE, ERR_R_INTERNAL_ERROR);
                return SUB_STATE_ERROR;
            }
            ret = process_message(s, &pkt);

            /* Discard the packet data */
            s->init_num = 0;

            switch (ret) {
            case MSG_PROCESS_ERROR:
                return SUB_STATE_ERROR;

            case MSG_PROCESS_FINISHED_READING:
                if (SSL_IS_DTLS(s)) {
                    dtls1_stop_timer(s);
                }
                return SUB_STATE_FINISHED;

            case MSG_PROCESS_CONTINUE_PROCESSING:
                st->read_state = READ_STATE_POST_PROCESS;
                st->read_state_work = WORK_MORE_A;
                break;

            default:
                st->read_state = READ_STATE_HEADER;
                break;
            }
            break;

        case READ_STATE_POST_PROCESS:
            st->read_state_work = post_process_message(s, st->read_state_work);
            switch (st->read_state_work) {
            default:
                return SUB_STATE_ERROR;

            case WORK_FINISHED_CONTINUE:
                st->read_state = READ_STATE_HEADER;
                break;

            case WORK_FINISHED_STOP:
                if (SSL_IS_DTLS(s)) {
                    dtls1_stop_timer(s);
                }
                return SUB_STATE_FINISHED;
            }
            break;

        default:
            /* Shouldn't happen */
            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);
            SSLerr(SSL_F_READ_STATE_MACHINE, ERR_R_INTERNAL_ERROR);
            ossl_statem_set_error(s);
            return SUB_STATE_ERROR;
        }
    }
}
",C,"            /* dtls_get_message already did this */
            if (!SSL_IS_DTLS(s)
                    && s->s3->tmp.message_size > 0
                    && !BUF_MEM_grow_clean(s->init_buf,
                                           (int)s->s3->tmp.message_size
                                           + SSL3_HM_HEADER_LENGTH)) {
                ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);
                SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, ERR_R_BUF_LIB);
                return SUB_STATE_ERROR;
            }

",,f757ce2a3df9c16c2ddbf83bf1725f6a89bccade,"@@ -542,6 +542,17 @@ static SUB_STATE_RETURN read_state_machine(SSL *s)
                 return SUB_STATE_ERROR;
             }
 
+            /* dtls_get_message already did this */
+            if (!SSL_IS_DTLS(s)
+                    && s->s3->tmp.message_size > 0
+                    && !BUF_MEM_grow_clean(s->init_buf,
+                                           (int)s->s3->tmp.message_size
+                                           + SSL3_HM_HEADER_LENGTH)) {
+                ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);
+                SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, ERR_R_BUF_LIB);
+                return SUB_STATE_ERROR;
+            }
+
             st->read_state = READ_STATE_BODY;
             /* Fall through */",openssl,https://git.openssl.org/?p=openssl.git;a=blob;f=ssl/statem/statem.c;h=8bc1febd1074244e64963d4e802ee1329b18dc43;hb=4b390b6c3f8df925dc92a3dd6b022baa9a2f4650,https://git.openssl.org/?p=openssl.git;a=blob;f=ssl/statem/statem.c;h=df3008575d19604ad0f3702f7ff489d3ac0d69dd,1,"static SUB_STATE_RETURN read_state_machine(SSL *s)
{
    OSSL_STATEM *st = &s->statem;
    int ret, mt;
    unsigned long len = 0;
    int (*transition) (SSL *s, int mt);
    PACKET pkt;
    MSG_PROCESS_RETURN(*process_message) (SSL *s, PACKET *pkt);
    WORK_STATE(*post_process_message) (SSL *s, WORK_STATE wst);
    unsigned long (*max_message_size) (SSL *s);
    void (*cb) (const SSL *ssl, int type, int val) = NULL;

    cb = get_callback(s);

    if (s->server) {
        transition = ossl_statem_server_read_transition;
        process_message = ossl_statem_server_process_message;
        max_message_size = ossl_statem_server_max_message_size;
        post_process_message = ossl_statem_server_post_process_message;
    } else {
        transition = ossl_statem_client_read_transition;
        process_message = ossl_statem_client_process_message;
        max_message_size = ossl_statem_client_max_message_size;
        post_process_message = ossl_statem_client_post_process_message;
    }

    if (st->read_state_first_init) {
        s->first_packet = 1;
        st->read_state_first_init = 0;
    }

    while (1) {
        switch (st->read_state) {
        case READ_STATE_HEADER:
            /* Get the state the peer wants to move to */
            if (SSL_IS_DTLS(s)) {
                /*
                 * In DTLS we get the whole message in one go - header and body
                 */
                ret = dtls_get_message(s, &mt, &len);
            } else {
                ret = tls_get_message_header(s, &mt);
            }

            if (ret == 0) {
                /* Could be non-blocking IO */
                return SUB_STATE_ERROR;
            }

            if (cb != NULL) {
                /* Notify callback of an impending state change */
                if (s->server)
                    cb(s, SSL_CB_ACCEPT_LOOP, 1);
                else
                    cb(s, SSL_CB_CONNECT_LOOP, 1);
            }
            /*
             * Validate that we are allowed to move to the new state and move
             * to that state if so
             */
            if (!transition(s, mt)) {
                ossl_statem_set_error(s);
                return SUB_STATE_ERROR;
            }

            if (s->s3->tmp.message_size > max_message_size(s)) {
                ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);
                SSLerr(SSL_F_READ_STATE_MACHINE, SSL_R_EXCESSIVE_MESSAGE_SIZE);
                 return SUB_STATE_ERROR;
             }
 
//fix_flaw_line_below:
//            /* dtls_get_message already did this */
//fix_flaw_line_below:
//            if (!SSL_IS_DTLS(s)
//fix_flaw_line_below:
//                    && s->s3->tmp.message_size > 0
//fix_flaw_line_below:
//                    && !BUF_MEM_grow_clean(s->init_buf,
//fix_flaw_line_below:
//                                           (int)s->s3->tmp.message_size
//fix_flaw_line_below:
//                                           + SSL3_HM_HEADER_LENGTH)) {
//fix_flaw_line_below:
//                ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);
//fix_flaw_line_below:
//                SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, ERR_R_BUF_LIB);
//fix_flaw_line_below:
//                return SUB_STATE_ERROR;
//fix_flaw_line_below:
//            }
//fix_flaw_line_below:
//
             st->read_state = READ_STATE_BODY;
             /* Fall through */
            if (!PACKET_buf_init(&pkt, s->init_msg, len)) {
                ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);
                SSLerr(SSL_F_READ_STATE_MACHINE, ERR_R_INTERNAL_ERROR);
                return SUB_STATE_ERROR;
            }
            ret = process_message(s, &pkt);

            /* Discard the packet data */
            s->init_num = 0;

            switch (ret) {
            case MSG_PROCESS_ERROR:
                return SUB_STATE_ERROR;

            case MSG_PROCESS_FINISHED_READING:
                if (SSL_IS_DTLS(s)) {
                    dtls1_stop_timer(s);
                }
                return SUB_STATE_FINISHED;

            case MSG_PROCESS_CONTINUE_PROCESSING:
                st->read_state = READ_STATE_POST_PROCESS;
                st->read_state_work = WORK_MORE_A;
                break;

            default:
                st->read_state = READ_STATE_HEADER;
                break;
            }
            break;

        case READ_STATE_POST_PROCESS:
            st->read_state_work = post_process_message(s, st->read_state_work);
            switch (st->read_state_work) {
            default:
                return SUB_STATE_ERROR;

            case WORK_FINISHED_CONTINUE:
                st->read_state = READ_STATE_HEADER;
                break;

            case WORK_FINISHED_STOP:
                if (SSL_IS_DTLS(s)) {
                    dtls1_stop_timer(s);
                }
                return SUB_STATE_FINISHED;
            }
            break;

        default:
            /* Shouldn't happen */
            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);
            SSLerr(SSL_F_READ_STATE_MACHINE, ERR_R_INTERNAL_ERROR);
            ossl_statem_set_error(s);
            return SUB_STATE_ERROR;
        }
    }
}
"
399,178135,,Remote,Not required,Partial,CVE-2016-6307,https://www.cvedetails.com/cve/CVE-2016-6307/,CWE-400,Medium,,,,2016-09-26,4.3,"The state-machine implementation in OpenSSL 1.1.0 before 1.1.0a allocates memory before checking for an excessive length, which might allow remote attackers to cause a denial of service (memory consumption) via crafted TLS messages, related to statem/statem.c and statem/statem_lib.c.",2018-04-19,DoS,0,https://git.openssl.org/?p=openssl.git;a=commit;h=4b390b6c3f8df925dc92a3dd6b022baa9a2f4650,4b390b6c3f8df925dc92a3dd6b022baa9a2f4650,,4,,,"int tls_get_message_header(SSL *s, int *mt)
{
    /* s->init_num < SSL3_HM_HEADER_LENGTH */
    int skip_message, i, recvd_type, al;
    unsigned char *p;
    unsigned long l;

    p = (unsigned char *)s->init_buf->data;

    do {
        while (s->init_num < SSL3_HM_HEADER_LENGTH) {
            i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE, &recvd_type,
                                          &p[s->init_num],
                                          SSL3_HM_HEADER_LENGTH - s->init_num,
                                          0);
            if (i <= 0) {
                s->rwstate = SSL_READING;
                return 0;
            }
            if (recvd_type == SSL3_RT_CHANGE_CIPHER_SPEC) {
                /*
                 * A ChangeCipherSpec must be a single byte and may not occur
                 * in the middle of a handshake message.
                 */
                if (s->init_num != 0 || i != 1 || p[0] != SSL3_MT_CCS) {
                    al = SSL_AD_UNEXPECTED_MESSAGE;
                    SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER,
                           SSL_R_BAD_CHANGE_CIPHER_SPEC);
                    goto f_err;
                }
                s->s3->tmp.message_type = *mt = SSL3_MT_CHANGE_CIPHER_SPEC;
                s->init_num = i - 1;
                s->s3->tmp.message_size = i;
                return 1;
            } else if (recvd_type != SSL3_RT_HANDSHAKE) {
                al = SSL_AD_UNEXPECTED_MESSAGE;
                SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, SSL_R_CCS_RECEIVED_EARLY);
                goto f_err;
            }
            s->init_num += i;
        }

        skip_message = 0;
        if (!s->server)
            if (p[0] == SSL3_MT_HELLO_REQUEST)
                /*
                 * The server may always send 'Hello Request' messages --
                 * we are doing a handshake anyway now, so ignore them if
                 * their format is correct. Does not count for 'Finished'
                 * MAC.
                 */
                if (p[1] == 0 && p[2] == 0 && p[3] == 0) {
                    s->init_num = 0;
                    skip_message = 1;

                    if (s->msg_callback)
                        s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,
                                        p, SSL3_HM_HEADER_LENGTH, s,
                                        s->msg_callback_arg);
                }
    } while (skip_message);
    /* s->init_num == SSL3_HM_HEADER_LENGTH */

    *mt = *p;
    s->s3->tmp.message_type = *(p++);

    if (RECORD_LAYER_is_sslv2_record(&s->rlayer)) {
        /*
         * Only happens with SSLv3+ in an SSLv2 backward compatible
         * ClientHello
         *
         * Total message size is the remaining record bytes to read
         * plus the SSL3_HM_HEADER_LENGTH bytes that we already read
          */
         l = RECORD_LAYER_get_rrec_length(&s->rlayer)
             + SSL3_HM_HEADER_LENGTH;
         s->s3->tmp.message_size = l;
 
         s->init_msg = s->init_buf->data;
        }
        s->s3->tmp.message_size = l;

        s->init_msg = s->init_buf->data;
        s->init_num = SSL3_HM_HEADER_LENGTH;
    } else {
             SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, SSL_R_EXCESSIVE_MESSAGE_SIZE);
             goto f_err;
         }
","int tls_get_message_header(SSL *s, int *mt)
{
    /* s->init_num < SSL3_HM_HEADER_LENGTH */
    int skip_message, i, recvd_type, al;
    unsigned char *p;
    unsigned long l;

    p = (unsigned char *)s->init_buf->data;

    do {
        while (s->init_num < SSL3_HM_HEADER_LENGTH) {
            i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE, &recvd_type,
                                          &p[s->init_num],
                                          SSL3_HM_HEADER_LENGTH - s->init_num,
                                          0);
            if (i <= 0) {
                s->rwstate = SSL_READING;
                return 0;
            }
            if (recvd_type == SSL3_RT_CHANGE_CIPHER_SPEC) {
                /*
                 * A ChangeCipherSpec must be a single byte and may not occur
                 * in the middle of a handshake message.
                 */
                if (s->init_num != 0 || i != 1 || p[0] != SSL3_MT_CCS) {
                    al = SSL_AD_UNEXPECTED_MESSAGE;
                    SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER,
                           SSL_R_BAD_CHANGE_CIPHER_SPEC);
                    goto f_err;
                }
                s->s3->tmp.message_type = *mt = SSL3_MT_CHANGE_CIPHER_SPEC;
                s->init_num = i - 1;
                s->s3->tmp.message_size = i;
                return 1;
            } else if (recvd_type != SSL3_RT_HANDSHAKE) {
                al = SSL_AD_UNEXPECTED_MESSAGE;
                SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, SSL_R_CCS_RECEIVED_EARLY);
                goto f_err;
            }
            s->init_num += i;
        }

        skip_message = 0;
        if (!s->server)
            if (p[0] == SSL3_MT_HELLO_REQUEST)
                /*
                 * The server may always send 'Hello Request' messages --
                 * we are doing a handshake anyway now, so ignore them if
                 * their format is correct. Does not count for 'Finished'
                 * MAC.
                 */
                if (p[1] == 0 && p[2] == 0 && p[3] == 0) {
                    s->init_num = 0;
                    skip_message = 1;

                    if (s->msg_callback)
                        s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,
                                        p, SSL3_HM_HEADER_LENGTH, s,
                                        s->msg_callback_arg);
                }
    } while (skip_message);
    /* s->init_num == SSL3_HM_HEADER_LENGTH */

    *mt = *p;
    s->s3->tmp.message_type = *(p++);

    if (RECORD_LAYER_is_sslv2_record(&s->rlayer)) {
        /*
         * Only happens with SSLv3+ in an SSLv2 backward compatible
         * ClientHello
         *
         * Total message size is the remaining record bytes to read
         * plus the SSL3_HM_HEADER_LENGTH bytes that we already read
          */
         l = RECORD_LAYER_get_rrec_length(&s->rlayer)
             + SSL3_HM_HEADER_LENGTH;
        if (l && !BUF_MEM_grow_clean(s->init_buf, (int)l)) {
            SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, ERR_R_BUF_LIB);
            goto err;
        }
         s->s3->tmp.message_size = l;
 
         s->init_msg = s->init_buf->data;
        }
        s->s3->tmp.message_size = l;

        s->init_msg = s->init_buf->data;
        s->init_num = SSL3_HM_HEADER_LENGTH;
    } else {
             SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, SSL_R_EXCESSIVE_MESSAGE_SIZE);
             goto f_err;
         }
",C,,"        if (l && !BUF_MEM_grow_clean(s->init_buf, (int)l)) {
            SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, ERR_R_BUF_LIB);
            goto err;
        }
",f757ce2a3df9c16c2ddbf83bf1725f6a89bccade,"@@ -414,10 +414,6 @@ int tls_get_message_header(SSL *s, int *mt)
          */
         l = RECORD_LAYER_get_rrec_length(&s->rlayer)
             + SSL3_HM_HEADER_LENGTH;
-        if (l && !BUF_MEM_grow_clean(s->init_buf, (int)l)) {
-            SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, ERR_R_BUF_LIB);
-            goto err;
-        }
         s->s3->tmp.message_size = l;
 
         s->init_msg = s->init_buf->data;
@@ -430,11 +426,6 @@ int tls_get_message_header(SSL *s, int *mt)
             SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, SSL_R_EXCESSIVE_MESSAGE_SIZE);
             goto f_err;
         }
-        if (l && !BUF_MEM_grow_clean(s->init_buf,
-                                     (int)l + SSL3_HM_HEADER_LENGTH)) {
-            SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, ERR_R_BUF_LIB);
-            goto err;
-        }
         s->s3->tmp.message_size = l;
 
         s->init_msg = s->init_buf->data + SSL3_HM_HEADER_LENGTH;
@@ -444,7 +435,6 @@ int tls_get_message_header(SSL *s, int *mt)
     return 1;
  f_err:
     ssl3_send_alert(s, SSL3_AL_FATAL, al);
- err:
     return 0;
 }",openssl,https://git.openssl.org/?p=openssl.git;a=blob;f=ssl/statem/statem_lib.c;h=31a84e44282564d909400b84c690bac2a2839d7e;hb=4b390b6c3f8df925dc92a3dd6b022baa9a2f4650,https://git.openssl.org/?p=openssl.git;a=blob;f=ssl/statem/statem_lib.c;h=19b75a7ac70f9cfb91698419219f7ceb296a7547,1,"int tls_get_message_header(SSL *s, int *mt)
{
    /* s->init_num < SSL3_HM_HEADER_LENGTH */
    int skip_message, i, recvd_type, al;
    unsigned char *p;
    unsigned long l;

    p = (unsigned char *)s->init_buf->data;

    do {
        while (s->init_num < SSL3_HM_HEADER_LENGTH) {
            i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE, &recvd_type,
                                          &p[s->init_num],
                                          SSL3_HM_HEADER_LENGTH - s->init_num,
                                          0);
            if (i <= 0) {
                s->rwstate = SSL_READING;
                return 0;
            }
            if (recvd_type == SSL3_RT_CHANGE_CIPHER_SPEC) {
                /*
                 * A ChangeCipherSpec must be a single byte and may not occur
                 * in the middle of a handshake message.
                 */
                if (s->init_num != 0 || i != 1 || p[0] != SSL3_MT_CCS) {
                    al = SSL_AD_UNEXPECTED_MESSAGE;
                    SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER,
                           SSL_R_BAD_CHANGE_CIPHER_SPEC);
                    goto f_err;
                }
                s->s3->tmp.message_type = *mt = SSL3_MT_CHANGE_CIPHER_SPEC;
                s->init_num = i - 1;
                s->s3->tmp.message_size = i;
                return 1;
            } else if (recvd_type != SSL3_RT_HANDSHAKE) {
                al = SSL_AD_UNEXPECTED_MESSAGE;
                SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, SSL_R_CCS_RECEIVED_EARLY);
                goto f_err;
            }
            s->init_num += i;
        }

        skip_message = 0;
        if (!s->server)
            if (p[0] == SSL3_MT_HELLO_REQUEST)
                /*
                 * The server may always send 'Hello Request' messages --
                 * we are doing a handshake anyway now, so ignore them if
                 * their format is correct. Does not count for 'Finished'
                 * MAC.
                 */
                if (p[1] == 0 && p[2] == 0 && p[3] == 0) {
                    s->init_num = 0;
                    skip_message = 1;

                    if (s->msg_callback)
                        s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,
                                        p, SSL3_HM_HEADER_LENGTH, s,
                                        s->msg_callback_arg);
                }
    } while (skip_message);
    /* s->init_num == SSL3_HM_HEADER_LENGTH */

    *mt = *p;
    s->s3->tmp.message_type = *(p++);

    if (RECORD_LAYER_is_sslv2_record(&s->rlayer)) {
        /*
         * Only happens with SSLv3+ in an SSLv2 backward compatible
         * ClientHello
         *
         * Total message size is the remaining record bytes to read
         * plus the SSL3_HM_HEADER_LENGTH bytes that we already read
          */
         l = RECORD_LAYER_get_rrec_length(&s->rlayer)
             + SSL3_HM_HEADER_LENGTH;
//flaw_line_below:
        if (l && !BUF_MEM_grow_clean(s->init_buf, (int)l)) {
//flaw_line_below:
            SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, ERR_R_BUF_LIB);
//flaw_line_below:
            goto err;
//flaw_line_below:
        }
         s->s3->tmp.message_size = l;
 
         s->init_msg = s->init_buf->data;
        }
        s->s3->tmp.message_size = l;

        s->init_msg = s->init_buf->data;
        s->init_num = SSL3_HM_HEADER_LENGTH;
    } else {
             SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, SSL_R_EXCESSIVE_MESSAGE_SIZE);
             goto f_err;
         }
"
698,178434,,Remote,Not required,Partial,CVE-2016-8610,https://www.cvedetails.com/cve/CVE-2016-8610/,CWE-400,Low,,,,2017-11-13,5.0,"A denial of service flaw was found in OpenSSL 0.9.8, 1.0.1, 1.0.2 through 1.0.2h, and 1.1.0 in the way the TLS/SSL protocol defined processing of ALERT packets during a connection handshake. A remote attacker could use this flaw to make a TLS/SSL server consume an excessive amount of CPU and fail to accept connections from other clients.",2019-07-23,DoS,8,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=af58be768ebb690f78530f796e92b8ae5c9a4401,af58be768ebb690f78530f796e92b8ae5c9a4401,,0,,,"int dtls1_read_bytes(SSL *s, int type, int *recvd_type, unsigned char *buf,
                     int len, int peek)
{
    int al, i, j, ret;
    unsigned int n;
    SSL3_RECORD *rr;
    void (*cb) (const SSL *ssl, int type2, int val) = NULL;

    if (!SSL3_BUFFER_is_initialised(&s->rlayer.rbuf)) {
        /* Not initialized yet */
        if (!ssl3_setup_buffers(s))
            return (-1);
    }

    if ((type && (type != SSL3_RT_APPLICATION_DATA) &&
         (type != SSL3_RT_HANDSHAKE)) ||
        (peek && (type != SSL3_RT_APPLICATION_DATA))) {
        SSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);
        return -1;
    }

    /*
     * check whether there's a handshake message (client hello?) waiting
     */
    if ((ret = have_handshake_fragment(s, type, buf, len)))
        return ret;

    /*
     * Now s->rlayer.d->handshake_fragment_len == 0 if
     * type == SSL3_RT_HANDSHAKE.
     */

#ifndef OPENSSL_NO_SCTP
    /*
     * Continue handshake if it had to be interrupted to read app data with
     * SCTP.
     */
    if ((!ossl_statem_get_in_handshake(s) && SSL_in_init(s)) ||
        (BIO_dgram_is_sctp(SSL_get_rbio(s))
         && ossl_statem_in_sctp_read_sock(s)
         && s->s3->in_read_app_data != 2))
#else
    if (!ossl_statem_get_in_handshake(s) && SSL_in_init(s))
#endif
    {
        /* type == SSL3_RT_APPLICATION_DATA */
        i = s->handshake_func(s);
        if (i < 0)
            return (i);
        if (i == 0) {
            SSLerr(SSL_F_DTLS1_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);
            return (-1);
        }
    }

 start:
    s->rwstate = SSL_NOTHING;

    /*-
     * s->s3->rrec.type         - is the type of record
     * s->s3->rrec.data,    - data
     * s->s3->rrec.off,     - offset into 'data' for next read
     * s->s3->rrec.length,  - number of bytes.
     */
    rr = s->rlayer.rrec;

    /*
     * We are not handshaking and have no data yet, so process data buffered
     * during the last handshake in advance, if any.
     */
    if (SSL_is_init_finished(s) && SSL3_RECORD_get_length(rr) == 0) {
        pitem *item;
        item = pqueue_pop(s->rlayer.d->buffered_app_data.q);
        if (item) {
#ifndef OPENSSL_NO_SCTP
            /* Restore bio_dgram_sctp_rcvinfo struct */
            if (BIO_dgram_is_sctp(SSL_get_rbio(s))) {
                DTLS1_RECORD_DATA *rdata = (DTLS1_RECORD_DATA *)item->data;
                BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_SET_RCVINFO,
                         sizeof(rdata->recordinfo), &rdata->recordinfo);
            }
#endif

            dtls1_copy_record(s, item);

            OPENSSL_free(item->data);
            pitem_free(item);
        }
    }

    /* Check for timeout */
    if (dtls1_handle_timeout(s) > 0)
        goto start;

    /* get new packet if necessary */
    if ((SSL3_RECORD_get_length(rr) == 0)
        || (s->rlayer.rstate == SSL_ST_READ_BODY)) {
        ret = dtls1_get_record(s);
        if (ret <= 0) {
            ret = dtls1_read_failed(s, ret);
            /* anything other than a timeout is an error */
            if (ret <= 0)
                return (ret);
            else
                goto start;
         }
     }
 
    /*
     * Reset the count of consecutive warning alerts if we've got a non-empty
     * record that isn't an alert.
     */
    if (SSL3_RECORD_get_type(rr) != SSL3_RT_ALERT
            && SSL3_RECORD_get_length(rr) != 0)
        s->rlayer.alert_count = 0;

     /* we now have a packet which can be read and processed */
 
     if (s->s3->change_cipher_spec /* set when we receive ChangeCipherSpec,
                                SSL3_RECORD_get_seq_num(rr)) < 0) {
            SSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);
            return -1;
        }
        SSL3_RECORD_set_length(rr, 0);
        goto start;
    }
","int dtls1_read_bytes(SSL *s, int type, int *recvd_type, unsigned char *buf,
                     int len, int peek)
{
    int al, i, j, ret;
    unsigned int n;
    SSL3_RECORD *rr;
    void (*cb) (const SSL *ssl, int type2, int val) = NULL;

    if (!SSL3_BUFFER_is_initialised(&s->rlayer.rbuf)) {
        /* Not initialized yet */
        if (!ssl3_setup_buffers(s))
            return (-1);
    }

    if ((type && (type != SSL3_RT_APPLICATION_DATA) &&
         (type != SSL3_RT_HANDSHAKE)) ||
        (peek && (type != SSL3_RT_APPLICATION_DATA))) {
        SSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);
        return -1;
    }

    /*
     * check whether there's a handshake message (client hello?) waiting
     */
    if ((ret = have_handshake_fragment(s, type, buf, len)))
        return ret;

    /*
     * Now s->rlayer.d->handshake_fragment_len == 0 if
     * type == SSL3_RT_HANDSHAKE.
     */

#ifndef OPENSSL_NO_SCTP
    /*
     * Continue handshake if it had to be interrupted to read app data with
     * SCTP.
     */
    if ((!ossl_statem_get_in_handshake(s) && SSL_in_init(s)) ||
        (BIO_dgram_is_sctp(SSL_get_rbio(s))
         && ossl_statem_in_sctp_read_sock(s)
         && s->s3->in_read_app_data != 2))
#else
    if (!ossl_statem_get_in_handshake(s) && SSL_in_init(s))
#endif
    {
        /* type == SSL3_RT_APPLICATION_DATA */
        i = s->handshake_func(s);
        if (i < 0)
            return (i);
        if (i == 0) {
            SSLerr(SSL_F_DTLS1_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);
            return (-1);
        }
    }

 start:
    s->rwstate = SSL_NOTHING;

    /*-
     * s->s3->rrec.type         - is the type of record
     * s->s3->rrec.data,    - data
     * s->s3->rrec.off,     - offset into 'data' for next read
     * s->s3->rrec.length,  - number of bytes.
     */
    rr = s->rlayer.rrec;

    /*
     * We are not handshaking and have no data yet, so process data buffered
     * during the last handshake in advance, if any.
     */
    if (SSL_is_init_finished(s) && SSL3_RECORD_get_length(rr) == 0) {
        pitem *item;
        item = pqueue_pop(s->rlayer.d->buffered_app_data.q);
        if (item) {
#ifndef OPENSSL_NO_SCTP
            /* Restore bio_dgram_sctp_rcvinfo struct */
            if (BIO_dgram_is_sctp(SSL_get_rbio(s))) {
                DTLS1_RECORD_DATA *rdata = (DTLS1_RECORD_DATA *)item->data;
                BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_SET_RCVINFO,
                         sizeof(rdata->recordinfo), &rdata->recordinfo);
            }
#endif

            dtls1_copy_record(s, item);

            OPENSSL_free(item->data);
            pitem_free(item);
        }
    }

    /* Check for timeout */
    if (dtls1_handle_timeout(s) > 0)
        goto start;

    /* get new packet if necessary */
    if ((SSL3_RECORD_get_length(rr) == 0)
        || (s->rlayer.rstate == SSL_ST_READ_BODY)) {
        ret = dtls1_get_record(s);
        if (ret <= 0) {
            ret = dtls1_read_failed(s, ret);
            /* anything other than a timeout is an error */
            if (ret <= 0)
                return (ret);
            else
                goto start;
         }
     }
 
     /* we now have a packet which can be read and processed */
 
     if (s->s3->change_cipher_spec /* set when we receive ChangeCipherSpec,
                                SSL3_RECORD_get_seq_num(rr)) < 0) {
            SSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);
            return -1;
        }
        SSL3_RECORD_set_length(rr, 0);
        goto start;
    }
",C,"    /*
     * Reset the count of consecutive warning alerts if we've got a non-empty
     * record that isn't an alert.
     */
    if (SSL3_RECORD_get_type(rr) != SSL3_RT_ALERT
            && SSL3_RECORD_get_length(rr) != 0)
        s->rlayer.alert_count = 0;

",,7dc0ad4d6dca81a003be7fa1fbd58a55f4be8646,"@@ -443,6 +443,14 @@ int dtls1_read_bytes(SSL *s, int type, int *recvd_type, unsigned char *buf,
         }
     }
 
+    /*
+     * Reset the count of consecutive warning alerts if we've got a non-empty
+     * record that isn't an alert.
+     */
+    if (SSL3_RECORD_get_type(rr) != SSL3_RT_ALERT
+            && SSL3_RECORD_get_length(rr) != 0)
+        s->rlayer.alert_count = 0;
+
     /* we now have a packet which can be read and processed */
 
     if (s->s3->change_cipher_spec /* set when we receive ChangeCipherSpec,
@@ -722,6 +730,14 @@ int dtls1_read_bytes(SSL *s, int type, int *recvd_type, unsigned char *buf,
 
         if (alert_level == SSL3_AL_WARNING) {
             s->s3->warn_alert = alert_descr;
+
+            s->rlayer.alert_count++;
+            if (s->rlayer.alert_count == MAX_WARN_ALERT_COUNT) {
+                al = SSL_AD_UNEXPECTED_MESSAGE;
+                SSLerr(SSL_F_DTLS1_READ_BYTES, SSL_R_TOO_MANY_WARN_ALERTS);
+                goto f_err;
+            }
+
             if (alert_descr == SSL_AD_CLOSE_NOTIFY) {
 #ifndef OPENSSL_NO_SCTP
                 /*",openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=ssl/record/rec_layer_d1.c;h=2455c2bd124affcfcf606869a7572a02dd1c90d4;hb=af58be768ebb690f78530f796e92b8ae5c9a4401,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=ssl/record/rec_layer_d1.c;h=cd582f32225b15be617c3ce6a484dfcf8dde7d64,1,"int dtls1_read_bytes(SSL *s, int type, int *recvd_type, unsigned char *buf,
                     int len, int peek)
{
    int al, i, j, ret;
    unsigned int n;
    SSL3_RECORD *rr;
    void (*cb) (const SSL *ssl, int type2, int val) = NULL;

    if (!SSL3_BUFFER_is_initialised(&s->rlayer.rbuf)) {
        /* Not initialized yet */
        if (!ssl3_setup_buffers(s))
            return (-1);
    }

    if ((type && (type != SSL3_RT_APPLICATION_DATA) &&
         (type != SSL3_RT_HANDSHAKE)) ||
        (peek && (type != SSL3_RT_APPLICATION_DATA))) {
        SSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);
        return -1;
    }

    /*
     * check whether there's a handshake message (client hello?) waiting
     */
    if ((ret = have_handshake_fragment(s, type, buf, len)))
        return ret;

    /*
     * Now s->rlayer.d->handshake_fragment_len == 0 if
     * type == SSL3_RT_HANDSHAKE.
     */

#ifndef OPENSSL_NO_SCTP
    /*
     * Continue handshake if it had to be interrupted to read app data with
     * SCTP.
     */
    if ((!ossl_statem_get_in_handshake(s) && SSL_in_init(s)) ||
        (BIO_dgram_is_sctp(SSL_get_rbio(s))
         && ossl_statem_in_sctp_read_sock(s)
         && s->s3->in_read_app_data != 2))
#else
    if (!ossl_statem_get_in_handshake(s) && SSL_in_init(s))
#endif
    {
        /* type == SSL3_RT_APPLICATION_DATA */
        i = s->handshake_func(s);
        if (i < 0)
            return (i);
        if (i == 0) {
            SSLerr(SSL_F_DTLS1_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);
            return (-1);
        }
    }

 start:
    s->rwstate = SSL_NOTHING;

    /*-
     * s->s3->rrec.type         - is the type of record
     * s->s3->rrec.data,    - data
     * s->s3->rrec.off,     - offset into 'data' for next read
     * s->s3->rrec.length,  - number of bytes.
     */
    rr = s->rlayer.rrec;

    /*
     * We are not handshaking and have no data yet, so process data buffered
     * during the last handshake in advance, if any.
     */
    if (SSL_is_init_finished(s) && SSL3_RECORD_get_length(rr) == 0) {
        pitem *item;
        item = pqueue_pop(s->rlayer.d->buffered_app_data.q);
        if (item) {
#ifndef OPENSSL_NO_SCTP
            /* Restore bio_dgram_sctp_rcvinfo struct */
            if (BIO_dgram_is_sctp(SSL_get_rbio(s))) {
                DTLS1_RECORD_DATA *rdata = (DTLS1_RECORD_DATA *)item->data;
                BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_SET_RCVINFO,
                         sizeof(rdata->recordinfo), &rdata->recordinfo);
            }
#endif

            dtls1_copy_record(s, item);

            OPENSSL_free(item->data);
            pitem_free(item);
        }
    }

    /* Check for timeout */
    if (dtls1_handle_timeout(s) > 0)
        goto start;

    /* get new packet if necessary */
    if ((SSL3_RECORD_get_length(rr) == 0)
        || (s->rlayer.rstate == SSL_ST_READ_BODY)) {
        ret = dtls1_get_record(s);
        if (ret <= 0) {
            ret = dtls1_read_failed(s, ret);
            /* anything other than a timeout is an error */
            if (ret <= 0)
                return (ret);
            else
                goto start;
         }
     }
 
//fix_flaw_line_below:
//    /*
//fix_flaw_line_below:
//     * Reset the count of consecutive warning alerts if we've got a non-empty
//fix_flaw_line_below:
//     * record that isn't an alert.
//fix_flaw_line_below:
//     */
//fix_flaw_line_below:
//    if (SSL3_RECORD_get_type(rr) != SSL3_RT_ALERT
//fix_flaw_line_below:
//            && SSL3_RECORD_get_length(rr) != 0)
//fix_flaw_line_below:
//        s->rlayer.alert_count = 0;
//fix_flaw_line_below:
//
     /* we now have a packet which can be read and processed */
 
     if (s->s3->change_cipher_spec /* set when we receive ChangeCipherSpec,
                                SSL3_RECORD_get_seq_num(rr)) < 0) {
            SSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);
            return -1;
        }
        SSL3_RECORD_set_length(rr, 0);
        goto start;
    }
"
762,178498,,Remote,Not required,Partial,CVE-2018-0739,https://www.cvedetails.com/cve/CVE-2018-0739/,CWE-400,Medium,,,,2018-03-27,4.3,Constructed ASN.1 types with a recursive definition (such as can be found in PKCS7) could eventually exceed the stack given malicious input with excessive recursion. This could result in a Denial Of Service attack. There are no such structures used within SSL/TLS that come from untrusted sources so this is considered safe. Fixed in OpenSSL 1.1.0h (Affected 1.1.0-1.1.0g). Fixed in OpenSSL 1.0.2o (Affected 1.0.2b-1.0.2n).,2019-04-23,DoS,2,https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=2ac4c6f7b2b2af20c0e2b0ba05367e454cd11b33,2ac4c6f7b2b2af20c0e2b0ba05367e454cd11b33,,2,,,"static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,
 static int asn1_template_ex_d2i(ASN1_VALUE **pval,
                                 const unsigned char **in, long len,
                                 const ASN1_TEMPLATE *tt, char opt,
                                ASN1_TLC *ctx, int depth);
 static int asn1_template_noexp_d2i(ASN1_VALUE **val,
                                    const unsigned char **in, long len,
                                    const ASN1_TEMPLATE *tt, char opt,
                                   ASN1_TLC *ctx, int depth);
 static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,
                                  const unsigned char **in, long len,
                                  const ASN1_ITEM *it,
    /* tags  4- 7 */
    B_ASN1_OCTET_STRING, 0, 0, B_ASN1_UNKNOWN,
    /* tags  8-11 */
    B_ASN1_UNKNOWN, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN,
    /* tags 12-15 */
    B_ASN1_UTF8STRING, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN,
    /* tags 16-19 */
    B_ASN1_SEQUENCE, 0, B_ASN1_NUMERICSTRING, B_ASN1_PRINTABLESTRING,
    /* tags 20-22 */
    B_ASN1_T61STRING, B_ASN1_VIDEOTEXSTRING, B_ASN1_IA5STRING,
    /* tags 23-24 */
    B_ASN1_UTCTIME, B_ASN1_GENERALIZEDTIME,
    /* tags 25-27 */
    B_ASN1_GRAPHICSTRING, B_ASN1_ISO64STRING, B_ASN1_GENERALSTRING,
    /* tags 28-31 */
    B_ASN1_UNIVERSALSTRING, B_ASN1_UNKNOWN, B_ASN1_BMPSTRING, B_ASN1_UNKNOWN,
};

unsigned long ASN1_tag2bit(int tag)
{
","static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,
 static int asn1_template_ex_d2i(ASN1_VALUE **pval,
                                 const unsigned char **in, long len,
                                 const ASN1_TEMPLATE *tt, char opt,
                                ASN1_TLC *ctx);
 static int asn1_template_noexp_d2i(ASN1_VALUE **val,
                                    const unsigned char **in, long len,
                                    const ASN1_TEMPLATE *tt, char opt,
                                   ASN1_TLC *ctx);
 static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,
                                  const unsigned char **in, long len,
                                  const ASN1_ITEM *it,
    /* tags  4- 7 */
    B_ASN1_OCTET_STRING, 0, 0, B_ASN1_UNKNOWN,
    /* tags  8-11 */
    B_ASN1_UNKNOWN, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN,
    /* tags 12-15 */
    B_ASN1_UTF8STRING, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN,
    /* tags 16-19 */
    B_ASN1_SEQUENCE, 0, B_ASN1_NUMERICSTRING, B_ASN1_PRINTABLESTRING,
    /* tags 20-22 */
    B_ASN1_T61STRING, B_ASN1_VIDEOTEXSTRING, B_ASN1_IA5STRING,
    /* tags 23-24 */
    B_ASN1_UTCTIME, B_ASN1_GENERALIZEDTIME,
    /* tags 25-27 */
    B_ASN1_GRAPHICSTRING, B_ASN1_ISO64STRING, B_ASN1_GENERALSTRING,
    /* tags 28-31 */
    B_ASN1_UNIVERSALSTRING, B_ASN1_UNKNOWN, B_ASN1_BMPSTRING, B_ASN1_UNKNOWN,
};

unsigned long ASN1_tag2bit(int tag)
{
",C,"                                ASN1_TLC *ctx, int depth);
                                   ASN1_TLC *ctx, int depth);
","                                ASN1_TLC *ctx);
                                   ASN1_TLC *ctx);
",d8278dac47996a442a480958702d913f2eff7b93,"@@ -17,9 +17,18 @@
 #include ""internal/numbers.h""
 #include ""asn1_locl.h""
 
+/*
+ * Constructed types with a recursive definition (such as can be found in PKCS7)
+ * could eventually exceed the stack given malicious input with excessive
+ * recursion. Therefore we limit the stack depth. This is the maximum number of
+ * recursive invocations of asn1_item_embed_d2i().
+ */
+#define ASN1_MAX_CONSTRUCTED_NEST 30
+
 static int asn1_item_embed_d2i(ASN1_VALUE **pval, const unsigned char **in,
                                long len, const ASN1_ITEM *it,
-                               int tag, int aclass, char opt, ASN1_TLC *ctx);
+                               int tag, int aclass, char opt, ASN1_TLC *ctx,
+                               int depth);
 
 static int asn1_check_eoc(const unsigned char **in, long len);
 static int asn1_find_end(const unsigned char **in, long len, char inf);
@@ -37,11 +46,11 @@ static int asn1_check_tlen(long *olen, int *otag, unsigned char *oclass,
 static int asn1_template_ex_d2i(ASN1_VALUE **pval,
                                 const unsigned char **in, long len,
                                 const ASN1_TEMPLATE *tt, char opt,
-                                ASN1_TLC *ctx);
+                                ASN1_TLC *ctx, int depth);
 static int asn1_template_noexp_d2i(ASN1_VALUE **val,
                                    const unsigned char **in, long len,
                                    const ASN1_TEMPLATE *tt, char opt,
-                                   ASN1_TLC *ctx);
+                                   ASN1_TLC *ctx, int depth);
 static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,
                                  const unsigned char **in, long len,
                                  const ASN1_ITEM *it,
@@ -111,7 +120,7 @@ int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
                      int tag, int aclass, char opt, ASN1_TLC *ctx)
 {
     int rv;
-    rv = asn1_item_embed_d2i(pval, in, len, it, tag, aclass, opt, ctx);
+    rv = asn1_item_embed_d2i(pval, in, len, it, tag, aclass, opt, ctx, 0);
     if (rv <= 0)
         ASN1_item_ex_free(pval, it);
     return rv;
@@ -124,7 +133,8 @@ int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
 
 static int asn1_item_embed_d2i(ASN1_VALUE **pval, const unsigned char **in,
                                long len, const ASN1_ITEM *it,
-                               int tag, int aclass, char opt, ASN1_TLC *ctx)
+                               int tag, int aclass, char opt, ASN1_TLC *ctx,
+                               int depth)
 {
     const ASN1_TEMPLATE *tt, *errtt = NULL;
     const ASN1_EXTERN_FUNCS *ef;
@@ -145,6 +155,11 @@ static int asn1_item_embed_d2i(ASN1_VALUE **pval, const unsigned char **in,
     else
         asn1_cb = 0;
 
+    if (++depth > ASN1_MAX_CONSTRUCTED_NEST) {
+        ASN1err(ASN1_F_ASN1_ITEM_EMBED_D2I, ASN1_R_NESTED_TOO_DEEP);
+        goto err;
+    }
+
     switch (it->itype) {
     case ASN1_ITYPE_PRIMITIVE:
         if (it->templates) {
@@ -160,7 +175,7 @@ static int asn1_item_embed_d2i(ASN1_VALUE **pval, const unsigned char **in,
                 goto err;
             }
             return asn1_template_ex_d2i(pval, in, len,
-                                        it->templates, opt, ctx);
+                                        it->templates, opt, ctx, depth);
         }
         return asn1_d2i_ex_primitive(pval, in, len, it,
                                      tag, aclass, opt, ctx);
@@ -221,7 +236,7 @@ static int asn1_item_embed_d2i(ASN1_VALUE **pval, const unsigned char **in,
             /*
              * We mark field as OPTIONAL so its absence can be recognised.
              */
-            ret = asn1_template_ex_d2i(pchptr, &p, len, tt, 1, ctx);
+            ret = asn1_template_ex_d2i(pchptr, &p, len, tt, 1, ctx, depth);
             /* If field not present, try the next one */
             if (ret == -1)
                 continue;
@@ -344,7 +359,8 @@ static int asn1_item_embed_d2i(ASN1_VALUE **pval, const unsigned char **in,
              * attempt to read in field, allowing each to be OPTIONAL
              */
 
-            ret = asn1_template_ex_d2i(pseqval, &p, len, seqtt, isopt, ctx);
+            ret = asn1_template_ex_d2i(pseqval, &p, len, seqtt, isopt, ctx,
+                                       depth);
             if (!ret) {
                 errtt = seqtt;
                 goto err;
@@ -420,7 +436,7 @@ static int asn1_item_embed_d2i(ASN1_VALUE **pval, const unsigned char **in,
 static int asn1_template_ex_d2i(ASN1_VALUE **val,
                                 const unsigned char **in, long inlen,
                                 const ASN1_TEMPLATE *tt, char opt,
-                                ASN1_TLC *ctx)
+                                ASN1_TLC *ctx, int depth)
 {
     int flags, aclass;
     int ret;
@@ -455,7 +471,7 @@ static int asn1_template_ex_d2i(ASN1_VALUE **val,
             return 0;
         }
         /* We've found the field so it can't be OPTIONAL now */
-        ret = asn1_template_noexp_d2i(val, &p, len, tt, 0, ctx);
+        ret = asn1_template_noexp_d2i(val, &p, len, tt, 0, ctx, depth);
         if (!ret) {
             ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
             return 0;
@@ -479,7 +495,7 @@ static int asn1_template_ex_d2i(ASN1_VALUE **val,
             }
         }
     } else
-        return asn1_template_noexp_d2i(val, in, inlen, tt, opt, ctx);
+        return asn1_template_noexp_d2i(val, in, inlen, tt, opt, ctx, depth);
 
     *in = p;
     return 1;
@@ -491,7 +507,7 @@ static int asn1_template_ex_d2i(ASN1_VALUE **val,
 static int asn1_template_noexp_d2i(ASN1_VALUE **val,
                                    const unsigned char **in, long len,
                                    const ASN1_TEMPLATE *tt, char opt,
-                                   ASN1_TLC *ctx)
+                                   ASN1_TLC *ctx, int depth)
 {
     int flags, aclass;
     int ret;
@@ -573,7 +589,8 @@ static int asn1_template_noexp_d2i(ASN1_VALUE **val,
             }
             skfield = NULL;
             if (!asn1_item_embed_d2i(&skfield, &p, len,
-                                     ASN1_ITEM_ptr(tt->item), -1, 0, 0, ctx)) {
+                                     ASN1_ITEM_ptr(tt->item), -1, 0, 0, ctx,
+                                     depth)) {
                 ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,
                         ERR_R_NESTED_ASN1_ERROR);
                 /* |skfield| may be partially allocated despite failure. */
@@ -595,7 +612,7 @@ static int asn1_template_noexp_d2i(ASN1_VALUE **val,
         /* IMPLICIT tagging */
         ret = asn1_item_embed_d2i(val, &p, len,
                                   ASN1_ITEM_ptr(tt->item), tt->tag, aclass, opt,
-                                  ctx);
+                                  ctx, depth);
         if (!ret) {
             ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ERR_R_NESTED_ASN1_ERROR);
             goto err;
@@ -604,7 +621,7 @@ static int asn1_template_noexp_d2i(ASN1_VALUE **val,
     } else {
         /* Nothing special */
         ret = asn1_item_embed_d2i(val, &p, len, ASN1_ITEM_ptr(tt->item),
-                                  -1, 0, opt, ctx);
+                                  -1, 0, opt, ctx, depth);
         if (!ret) {
             ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ERR_R_NESTED_ASN1_ERROR);
             goto err;",openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/asn1/tasn_dec.c;h=bc3d193757af6e7dd11e9ec6d536377bbaf1c6f3;hb=2ac4c6f7b2b2af20c0e2b0ba05367e454cd11b33,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/asn1/tasn_dec.c;h=c9b637516e38a2fd7c901d606323085389e2c092,1,"static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,
 static int asn1_template_ex_d2i(ASN1_VALUE **pval,
                                 const unsigned char **in, long len,
                                 const ASN1_TEMPLATE *tt, char opt,
//flaw_line_below:
                                ASN1_TLC *ctx);
//fix_flaw_line_below:
//                                ASN1_TLC *ctx, int depth);
 static int asn1_template_noexp_d2i(ASN1_VALUE **val,
                                    const unsigned char **in, long len,
                                    const ASN1_TEMPLATE *tt, char opt,
//flaw_line_below:
                                   ASN1_TLC *ctx);
//fix_flaw_line_below:
//                                   ASN1_TLC *ctx, int depth);
 static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,
                                  const unsigned char **in, long len,
                                  const ASN1_ITEM *it,
    /* tags  4- 7 */
    B_ASN1_OCTET_STRING, 0, 0, B_ASN1_UNKNOWN,
    /* tags  8-11 */
    B_ASN1_UNKNOWN, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN,
    /* tags 12-15 */
    B_ASN1_UTF8STRING, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN,
    /* tags 16-19 */
    B_ASN1_SEQUENCE, 0, B_ASN1_NUMERICSTRING, B_ASN1_PRINTABLESTRING,
    /* tags 20-22 */
    B_ASN1_T61STRING, B_ASN1_VIDEOTEXSTRING, B_ASN1_IA5STRING,
    /* tags 23-24 */
    B_ASN1_UTCTIME, B_ASN1_GENERALIZEDTIME,
    /* tags 25-27 */
    B_ASN1_GRAPHICSTRING, B_ASN1_ISO64STRING, B_ASN1_GENERALSTRING,
    /* tags 28-31 */
    B_ASN1_UNIVERSALSTRING, B_ASN1_UNKNOWN, B_ASN1_BMPSTRING, B_ASN1_UNKNOWN,
};

unsigned long ASN1_tag2bit(int tag)
{
"
2288,180024,,Local,Not required,Complete,CVE-2016-9685,https://www.cvedetails.com/cve/CVE-2016-9685/,CWE-400,Low,,,,2016-12-28,4.9,Multiple memory leaks in error paths in fs/xfs/xfs_attr_list.c in the Linux kernel before 4.5.1 allow local users to cause a denial of service (memory consumption) via crafted XFS filesystem operations.,2018-01-04,DoS ,7,https://github.com/torvalds/linux/commit/2e83b79b2d6c78bf1b4aa227938a214dcbddc83f,2e83b79b2d6c78bf1b4aa227938a214dcbddc83f,"xfs: fix two memory leaks in xfs_attr_list.c error paths

This plugs 2 trivial leaks in xfs_attr_shortform_list and
xfs_attr3_leaf_list_int.

Signed-off-by: Mateusz Guzik <mguzik@redhat.com>
Cc: <stable@vger.kernel.org>
Reviewed-by: Eric Sandeen <sandeen@redhat.com>
Signed-off-by: Dave Chinner <david@fromorbit.com>",8,fs/xfs/xfs_attr_list.c,"{""sha"": ""4fa14820e2e22b687ef852b81e1d6b9f9028caf3"", ""filename"": ""fs/xfs/xfs_attr_list.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 9, ""changes"": 19, ""blob_url"": ""https://github.com/torvalds/linux/blob/2e83b79b2d6c78bf1b4aa227938a214dcbddc83f/fs/xfs/xfs_attr_list.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/2e83b79b2d6c78bf1b4aa227938a214dcbddc83f/fs/xfs/xfs_attr_list.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/xfs_attr_list.c?ref=2e83b79b2d6c78bf1b4aa227938a214dcbddc83f"", ""patch"": ""@@ -202,8 +202,10 @@ xfs_attr_shortform_list(xfs_attr_list_context_t *context)\n \t\t\t\t\tsbp->namelen,\n \t\t\t\t\tsbp->valuelen,\n \t\t\t\t\t&sbp->name[sbp->namelen]);\n-\t\tif (error)\n+\t\tif (error) {\n+\t\t\tkmem_free(sbuf);\n \t\t\treturn error;\n+\t\t}\n \t\tif (context->seen_enough)\n \t\t\tbreak;\n \t\tcursor->offset++;\n@@ -454,14 +456,13 @@ xfs_attr3_leaf_list_int(\n \t\t\t\targs.rmtblkcnt = xfs_attr3_rmt_blocks(\n \t\t\t\t\t\t\targs.dp->i_mount, valuelen);\n \t\t\t\tretval = xfs_attr_rmtval_get(&args);\n-\t\t\t\tif (retval)\n-\t\t\t\t\treturn retval;\n-\t\t\t\tretval = context->put_listent(context,\n-\t\t\t\t\t\tentry->flags,\n-\t\t\t\t\t\tname_rmt->name,\n-\t\t\t\t\t\t(int)name_rmt->namelen,\n-\t\t\t\t\t\tvaluelen,\n-\t\t\t\t\t\targs.value);\n+\t\t\t\tif (!retval)\n+\t\t\t\t\tretval = context->put_listent(context,\n+\t\t\t\t\t\t\tentry->flags,\n+\t\t\t\t\t\t\tname_rmt->name,\n+\t\t\t\t\t\t\t(int)name_rmt->namelen,\n+\t\t\t\t\t\t\tvaluelen,\n+\t\t\t\t\t\t\targs.value);\n \t\t\t\tkmem_free(args.value);\n \t\t\t} else {\n \t\t\t\tretval = context->put_listent(context,""}","xfs_attr3_leaf_list_int(
	struct xfs_buf			*bp,
	struct xfs_attr_list_context	*context)
{
	struct attrlist_cursor_kern	*cursor;
	struct xfs_attr_leafblock	*leaf;
	struct xfs_attr3_icleaf_hdr	ichdr;
	struct xfs_attr_leaf_entry	*entries;
	struct xfs_attr_leaf_entry	*entry;
	int				retval;
	int				i;
	struct xfs_mount		*mp = context->dp->i_mount;

	trace_xfs_attr_list_leaf(context);

	leaf = bp->b_addr;
	xfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &ichdr, leaf);
	entries = xfs_attr3_leaf_entryp(leaf);

	cursor = context->cursor;
	cursor->initted = 1;

	/*
	 * Re-find our place in the leaf block if this is a new syscall.
	 */
	if (context->resynch) {
		entry = &entries[0];
		for (i = 0; i < ichdr.count; entry++, i++) {
			if (be32_to_cpu(entry->hashval) == cursor->hashval) {
				if (cursor->offset == context->dupcnt) {
					context->dupcnt = 0;
					break;
				}
				context->dupcnt++;
			} else if (be32_to_cpu(entry->hashval) >
					cursor->hashval) {
				context->dupcnt = 0;
				break;
			}
		}
		if (i == ichdr.count) {
			trace_xfs_attr_list_notfound(context);
			return 0;
		}
	} else {
		entry = &entries[0];
		i = 0;
	}
	context->resynch = 0;

	/*
	 * We have found our place, start copying out the new attributes.
	 */
	retval = 0;
	for (; i < ichdr.count; entry++, i++) {
		if (be32_to_cpu(entry->hashval) != cursor->hashval) {
			cursor->hashval = be32_to_cpu(entry->hashval);
			cursor->offset = 0;
		}

		if (entry->flags & XFS_ATTR_INCOMPLETE)
			continue;		/* skip incomplete entries */

		if (entry->flags & XFS_ATTR_LOCAL) {
			xfs_attr_leaf_name_local_t *name_loc =
				xfs_attr3_leaf_name_local(leaf, i);

			retval = context->put_listent(context,
						entry->flags,
						name_loc->nameval,
						(int)name_loc->namelen,
						be16_to_cpu(name_loc->valuelen),
						&name_loc->nameval[name_loc->namelen]);
			if (retval)
				return retval;
		} else {
			xfs_attr_leaf_name_remote_t *name_rmt =
				xfs_attr3_leaf_name_remote(leaf, i);

			int valuelen = be32_to_cpu(name_rmt->valuelen);

			if (context->put_value) {
				xfs_da_args_t args;

				memset((char *)&args, 0, sizeof(args));
				args.geo = context->dp->i_mount->m_attr_geo;
				args.dp = context->dp;
				args.whichfork = XFS_ATTR_FORK;
				args.valuelen = valuelen;
				args.rmtvaluelen = valuelen;
				args.value = kmem_alloc(valuelen, KM_SLEEP | KM_NOFS);
				args.rmtblkno = be32_to_cpu(name_rmt->valueblk);
 				args.rmtblkcnt = xfs_attr3_rmt_blocks(
 							args.dp->i_mount, valuelen);
 				retval = xfs_attr_rmtval_get(&args);
				if (!retval)
					retval = context->put_listent(context,
							entry->flags,
							name_rmt->name,
							(int)name_rmt->namelen,
							valuelen,
							args.value);
 				kmem_free(args.value);
 			} else {
 				retval = context->put_listent(context,
						entry->flags,
						name_rmt->name,
						(int)name_rmt->namelen,
						valuelen,
						NULL);
			}
			if (retval)
				return retval;
		}
		if (context->seen_enough)
			break;
		cursor->offset++;
	}
	trace_xfs_attr_list_leaf_end(context);
	return retval;
}
","xfs_attr3_leaf_list_int(
	struct xfs_buf			*bp,
	struct xfs_attr_list_context	*context)
{
	struct attrlist_cursor_kern	*cursor;
	struct xfs_attr_leafblock	*leaf;
	struct xfs_attr3_icleaf_hdr	ichdr;
	struct xfs_attr_leaf_entry	*entries;
	struct xfs_attr_leaf_entry	*entry;
	int				retval;
	int				i;
	struct xfs_mount		*mp = context->dp->i_mount;

	trace_xfs_attr_list_leaf(context);

	leaf = bp->b_addr;
	xfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &ichdr, leaf);
	entries = xfs_attr3_leaf_entryp(leaf);

	cursor = context->cursor;
	cursor->initted = 1;

	/*
	 * Re-find our place in the leaf block if this is a new syscall.
	 */
	if (context->resynch) {
		entry = &entries[0];
		for (i = 0; i < ichdr.count; entry++, i++) {
			if (be32_to_cpu(entry->hashval) == cursor->hashval) {
				if (cursor->offset == context->dupcnt) {
					context->dupcnt = 0;
					break;
				}
				context->dupcnt++;
			} else if (be32_to_cpu(entry->hashval) >
					cursor->hashval) {
				context->dupcnt = 0;
				break;
			}
		}
		if (i == ichdr.count) {
			trace_xfs_attr_list_notfound(context);
			return 0;
		}
	} else {
		entry = &entries[0];
		i = 0;
	}
	context->resynch = 0;

	/*
	 * We have found our place, start copying out the new attributes.
	 */
	retval = 0;
	for (; i < ichdr.count; entry++, i++) {
		if (be32_to_cpu(entry->hashval) != cursor->hashval) {
			cursor->hashval = be32_to_cpu(entry->hashval);
			cursor->offset = 0;
		}

		if (entry->flags & XFS_ATTR_INCOMPLETE)
			continue;		/* skip incomplete entries */

		if (entry->flags & XFS_ATTR_LOCAL) {
			xfs_attr_leaf_name_local_t *name_loc =
				xfs_attr3_leaf_name_local(leaf, i);

			retval = context->put_listent(context,
						entry->flags,
						name_loc->nameval,
						(int)name_loc->namelen,
						be16_to_cpu(name_loc->valuelen),
						&name_loc->nameval[name_loc->namelen]);
			if (retval)
				return retval;
		} else {
			xfs_attr_leaf_name_remote_t *name_rmt =
				xfs_attr3_leaf_name_remote(leaf, i);

			int valuelen = be32_to_cpu(name_rmt->valuelen);

			if (context->put_value) {
				xfs_da_args_t args;

				memset((char *)&args, 0, sizeof(args));
				args.geo = context->dp->i_mount->m_attr_geo;
				args.dp = context->dp;
				args.whichfork = XFS_ATTR_FORK;
				args.valuelen = valuelen;
				args.rmtvaluelen = valuelen;
				args.value = kmem_alloc(valuelen, KM_SLEEP | KM_NOFS);
				args.rmtblkno = be32_to_cpu(name_rmt->valueblk);
 				args.rmtblkcnt = xfs_attr3_rmt_blocks(
 							args.dp->i_mount, valuelen);
 				retval = xfs_attr_rmtval_get(&args);
				if (retval)
					return retval;
				retval = context->put_listent(context,
						entry->flags,
						name_rmt->name,
						(int)name_rmt->namelen,
						valuelen,
						args.value);
 				kmem_free(args.value);
 			} else {
 				retval = context->put_listent(context,
						entry->flags,
						name_rmt->name,
						(int)name_rmt->namelen,
						valuelen,
						NULL);
			}
			if (retval)
				return retval;
		}
		if (context->seen_enough)
			break;
		cursor->offset++;
	}
	trace_xfs_attr_list_leaf_end(context);
	return retval;
}
",C,"				if (!retval)
					retval = context->put_listent(context,
							entry->flags,
							name_rmt->name,
							(int)name_rmt->namelen,
							valuelen,
							args.value);
","				if (retval)
					return retval;
				retval = context->put_listent(context,
						entry->flags,
						name_rmt->name,
						(int)name_rmt->namelen,
						valuelen,
						args.value);
",,"@@ -202,8 +202,10 @@ xfs_attr_shortform_list(xfs_attr_list_context_t *context)
 					sbp->namelen,
 					sbp->valuelen,
 					&sbp->name[sbp->namelen]);
-		if (error)
+		if (error) {
+			kmem_free(sbuf);
 			return error;
+		}
 		if (context->seen_enough)
 			break;
 		cursor->offset++;
@@ -454,14 +456,13 @@ xfs_attr3_leaf_list_int(
 				args.rmtblkcnt = xfs_attr3_rmt_blocks(
 							args.dp->i_mount, valuelen);
 				retval = xfs_attr_rmtval_get(&args);
-				if (retval)
-					return retval;
-				retval = context->put_listent(context,
-						entry->flags,
-						name_rmt->name,
-						(int)name_rmt->namelen,
-						valuelen,
-						args.value);
+				if (!retval)
+					retval = context->put_listent(context,
+							entry->flags,
+							name_rmt->name,
+							(int)name_rmt->namelen,
+							valuelen,
+							args.value);
 				kmem_free(args.value);
 			} else {
 				retval = context->put_listent(context,",linux,2e83b79b2d6c78bf1b4aa227938a214dcbddc83f,36f90b0a2ddd60823fe193a85e60ff1906c2a9b3,1,"xfs_attr3_leaf_list_int(
	struct xfs_buf			*bp,
	struct xfs_attr_list_context	*context)
{
	struct attrlist_cursor_kern	*cursor;
	struct xfs_attr_leafblock	*leaf;
	struct xfs_attr3_icleaf_hdr	ichdr;
	struct xfs_attr_leaf_entry	*entries;
	struct xfs_attr_leaf_entry	*entry;
	int				retval;
	int				i;
	struct xfs_mount		*mp = context->dp->i_mount;

	trace_xfs_attr_list_leaf(context);

	leaf = bp->b_addr;
	xfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &ichdr, leaf);
	entries = xfs_attr3_leaf_entryp(leaf);

	cursor = context->cursor;
	cursor->initted = 1;

	/*
	 * Re-find our place in the leaf block if this is a new syscall.
	 */
	if (context->resynch) {
		entry = &entries[0];
		for (i = 0; i < ichdr.count; entry++, i++) {
			if (be32_to_cpu(entry->hashval) == cursor->hashval) {
				if (cursor->offset == context->dupcnt) {
					context->dupcnt = 0;
					break;
				}
				context->dupcnt++;
			} else if (be32_to_cpu(entry->hashval) >
					cursor->hashval) {
				context->dupcnt = 0;
				break;
			}
		}
		if (i == ichdr.count) {
			trace_xfs_attr_list_notfound(context);
			return 0;
		}
	} else {
		entry = &entries[0];
		i = 0;
	}
	context->resynch = 0;

	/*
	 * We have found our place, start copying out the new attributes.
	 */
	retval = 0;
	for (; i < ichdr.count; entry++, i++) {
		if (be32_to_cpu(entry->hashval) != cursor->hashval) {
			cursor->hashval = be32_to_cpu(entry->hashval);
			cursor->offset = 0;
		}

		if (entry->flags & XFS_ATTR_INCOMPLETE)
			continue;		/* skip incomplete entries */

		if (entry->flags & XFS_ATTR_LOCAL) {
			xfs_attr_leaf_name_local_t *name_loc =
				xfs_attr3_leaf_name_local(leaf, i);

			retval = context->put_listent(context,
						entry->flags,
						name_loc->nameval,
						(int)name_loc->namelen,
						be16_to_cpu(name_loc->valuelen),
						&name_loc->nameval[name_loc->namelen]);
			if (retval)
				return retval;
		} else {
			xfs_attr_leaf_name_remote_t *name_rmt =
				xfs_attr3_leaf_name_remote(leaf, i);

			int valuelen = be32_to_cpu(name_rmt->valuelen);

			if (context->put_value) {
				xfs_da_args_t args;

				memset((char *)&args, 0, sizeof(args));
				args.geo = context->dp->i_mount->m_attr_geo;
				args.dp = context->dp;
				args.whichfork = XFS_ATTR_FORK;
				args.valuelen = valuelen;
				args.rmtvaluelen = valuelen;
				args.value = kmem_alloc(valuelen, KM_SLEEP | KM_NOFS);
				args.rmtblkno = be32_to_cpu(name_rmt->valueblk);
 				args.rmtblkcnt = xfs_attr3_rmt_blocks(
 							args.dp->i_mount, valuelen);
 				retval = xfs_attr_rmtval_get(&args);
//flaw_line_below:
				if (retval)
//flaw_line_below:
					return retval;
//flaw_line_below:
				retval = context->put_listent(context,
//flaw_line_below:
						entry->flags,
//flaw_line_below:
						name_rmt->name,
//flaw_line_below:
						(int)name_rmt->namelen,
//flaw_line_below:
						valuelen,
//flaw_line_below:
						args.value);
//fix_flaw_line_below:
//				if (!retval)
//fix_flaw_line_below:
//					retval = context->put_listent(context,
//fix_flaw_line_below:
//							entry->flags,
//fix_flaw_line_below:
//							name_rmt->name,
//fix_flaw_line_below:
//							(int)name_rmt->namelen,
//fix_flaw_line_below:
//							valuelen,
//fix_flaw_line_below:
//							args.value);
 				kmem_free(args.value);
 			} else {
 				retval = context->put_listent(context,
						entry->flags,
						name_rmt->name,
						(int)name_rmt->namelen,
						valuelen,
						NULL);
			}
			if (retval)
				return retval;
		}
		if (context->seen_enough)
			break;
		cursor->offset++;
	}
	trace_xfs_attr_list_leaf_end(context);
	return retval;
}
"
2289,180025,,Local,Not required,Complete,CVE-2016-9685,https://www.cvedetails.com/cve/CVE-2016-9685/,CWE-400,Low,,,,2016-12-28,4.9,Multiple memory leaks in error paths in fs/xfs/xfs_attr_list.c in the Linux kernel before 4.5.1 allow local users to cause a denial of service (memory consumption) via crafted XFS filesystem operations.,2018-01-04,DoS ,3,https://github.com/torvalds/linux/commit/2e83b79b2d6c78bf1b4aa227938a214dcbddc83f,2e83b79b2d6c78bf1b4aa227938a214dcbddc83f,"xfs: fix two memory leaks in xfs_attr_list.c error paths

This plugs 2 trivial leaks in xfs_attr_shortform_list and
xfs_attr3_leaf_list_int.

Signed-off-by: Mateusz Guzik <mguzik@redhat.com>
Cc: <stable@vger.kernel.org>
Reviewed-by: Eric Sandeen <sandeen@redhat.com>
Signed-off-by: Dave Chinner <david@fromorbit.com>",1,fs/xfs/xfs_attr_list.c,"{""sha"": ""4fa14820e2e22b687ef852b81e1d6b9f9028caf3"", ""filename"": ""fs/xfs/xfs_attr_list.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 9, ""changes"": 19, ""blob_url"": ""https://github.com/torvalds/linux/blob/2e83b79b2d6c78bf1b4aa227938a214dcbddc83f/fs/xfs/xfs_attr_list.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/2e83b79b2d6c78bf1b4aa227938a214dcbddc83f/fs/xfs/xfs_attr_list.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/xfs/xfs_attr_list.c?ref=2e83b79b2d6c78bf1b4aa227938a214dcbddc83f"", ""patch"": ""@@ -202,8 +202,10 @@ xfs_attr_shortform_list(xfs_attr_list_context_t *context)\n \t\t\t\t\tsbp->namelen,\n \t\t\t\t\tsbp->valuelen,\n \t\t\t\t\t&sbp->name[sbp->namelen]);\n-\t\tif (error)\n+\t\tif (error) {\n+\t\t\tkmem_free(sbuf);\n \t\t\treturn error;\n+\t\t}\n \t\tif (context->seen_enough)\n \t\t\tbreak;\n \t\tcursor->offset++;\n@@ -454,14 +456,13 @@ xfs_attr3_leaf_list_int(\n \t\t\t\targs.rmtblkcnt = xfs_attr3_rmt_blocks(\n \t\t\t\t\t\t\targs.dp->i_mount, valuelen);\n \t\t\t\tretval = xfs_attr_rmtval_get(&args);\n-\t\t\t\tif (retval)\n-\t\t\t\t\treturn retval;\n-\t\t\t\tretval = context->put_listent(context,\n-\t\t\t\t\t\tentry->flags,\n-\t\t\t\t\t\tname_rmt->name,\n-\t\t\t\t\t\t(int)name_rmt->namelen,\n-\t\t\t\t\t\tvaluelen,\n-\t\t\t\t\t\targs.value);\n+\t\t\t\tif (!retval)\n+\t\t\t\t\tretval = context->put_listent(context,\n+\t\t\t\t\t\t\tentry->flags,\n+\t\t\t\t\t\t\tname_rmt->name,\n+\t\t\t\t\t\t\t(int)name_rmt->namelen,\n+\t\t\t\t\t\t\tvaluelen,\n+\t\t\t\t\t\t\targs.value);\n \t\t\t\tkmem_free(args.value);\n \t\t\t} else {\n \t\t\t\tretval = context->put_listent(context,""}","xfs_attr_shortform_list(xfs_attr_list_context_t *context)
{
	attrlist_cursor_kern_t *cursor;
	xfs_attr_sf_sort_t *sbuf, *sbp;
	xfs_attr_shortform_t *sf;
	xfs_attr_sf_entry_t *sfe;
	xfs_inode_t *dp;
	int sbsize, nsbuf, count, i;
	int error;

	ASSERT(context != NULL);
	dp = context->dp;
	ASSERT(dp != NULL);
	ASSERT(dp->i_afp != NULL);
	sf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;
	ASSERT(sf != NULL);
	if (!sf->hdr.count)
		return 0;
	cursor = context->cursor;
	ASSERT(cursor != NULL);

	trace_xfs_attr_list_sf(context);

	/*
	 * If the buffer is large enough and the cursor is at the start,
	 * do not bother with sorting since we will return everything in
	 * one buffer and another call using the cursor won't need to be
	 * made.
	 * Note the generous fudge factor of 16 overhead bytes per entry.
	 * If bufsize is zero then put_listent must be a search function
	 * and can just scan through what we have.
	 */
	if (context->bufsize == 0 ||
	    (XFS_ISRESET_CURSOR(cursor) &&
             (dp->i_afp->if_bytes + sf->hdr.count * 16) < context->bufsize)) {
		for (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {
			error = context->put_listent(context,
					   sfe->flags,
					   sfe->nameval,
					   (int)sfe->namelen,
					   (int)sfe->valuelen,
					   &sfe->nameval[sfe->namelen]);

			/*
			 * Either search callback finished early or
			 * didn't fit it all in the buffer after all.
			 */
			if (context->seen_enough)
				break;

			if (error)
				return error;
			sfe = XFS_ATTR_SF_NEXTENTRY(sfe);
		}
		trace_xfs_attr_list_sf_all(context);
		return 0;
	}

	/* do no more for a search callback */
	if (context->bufsize == 0)
		return 0;

	/*
	 * It didn't all fit, so we have to sort everything on hashval.
	 */
	sbsize = sf->hdr.count * sizeof(*sbuf);
	sbp = sbuf = kmem_alloc(sbsize, KM_SLEEP | KM_NOFS);

	/*
	 * Scan the attribute list for the rest of the entries, storing
	 * the relevant info from only those that match into a buffer.
	 */
	nsbuf = 0;
	for (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {
		if (unlikely(
		    ((char *)sfe < (char *)sf) ||
		    ((char *)sfe >= ((char *)sf + dp->i_afp->if_bytes)))) {
			XFS_CORRUPTION_ERROR(""xfs_attr_shortform_list"",
					     XFS_ERRLEVEL_LOW,
					     context->dp->i_mount, sfe);
			kmem_free(sbuf);
			return -EFSCORRUPTED;
		}

		sbp->entno = i;
		sbp->hash = xfs_da_hashname(sfe->nameval, sfe->namelen);
		sbp->name = sfe->nameval;
		sbp->namelen = sfe->namelen;
		/* These are bytes, and both on-disk, don't endian-flip */
		sbp->valuelen = sfe->valuelen;
		sbp->flags = sfe->flags;
		sfe = XFS_ATTR_SF_NEXTENTRY(sfe);
		sbp++;
		nsbuf++;
	}

	/*
	 * Sort the entries on hash then entno.
	 */
	xfs_sort(sbuf, nsbuf, sizeof(*sbuf), xfs_attr_shortform_compare);

	/*
	 * Re-find our place IN THE SORTED LIST.
	 */
	count = 0;
	cursor->initted = 1;
	cursor->blkno = 0;
	for (sbp = sbuf, i = 0; i < nsbuf; i++, sbp++) {
		if (sbp->hash == cursor->hashval) {
			if (cursor->offset == count) {
				break;
			}
			count++;
		} else if (sbp->hash > cursor->hashval) {
			break;
		}
	}
	if (i == nsbuf) {
		kmem_free(sbuf);
		return 0;
	}

	/*
	 * Loop putting entries into the user buffer.
	 */
	for ( ; i < nsbuf; i++, sbp++) {
		if (cursor->hashval != sbp->hash) {
			cursor->hashval = sbp->hash;
			cursor->offset = 0;
		}
		error = context->put_listent(context,
					sbp->flags,
					sbp->name,
 					sbp->namelen,
 					sbp->valuelen,
 					&sbp->name[sbp->namelen]);
		if (error) {
			kmem_free(sbuf);
 			return error;
		}
 		if (context->seen_enough)
 			break;
 		cursor->offset++;
	}

	kmem_free(sbuf);
	return 0;
}
","xfs_attr_shortform_list(xfs_attr_list_context_t *context)
{
	attrlist_cursor_kern_t *cursor;
	xfs_attr_sf_sort_t *sbuf, *sbp;
	xfs_attr_shortform_t *sf;
	xfs_attr_sf_entry_t *sfe;
	xfs_inode_t *dp;
	int sbsize, nsbuf, count, i;
	int error;

	ASSERT(context != NULL);
	dp = context->dp;
	ASSERT(dp != NULL);
	ASSERT(dp->i_afp != NULL);
	sf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;
	ASSERT(sf != NULL);
	if (!sf->hdr.count)
		return 0;
	cursor = context->cursor;
	ASSERT(cursor != NULL);

	trace_xfs_attr_list_sf(context);

	/*
	 * If the buffer is large enough and the cursor is at the start,
	 * do not bother with sorting since we will return everything in
	 * one buffer and another call using the cursor won't need to be
	 * made.
	 * Note the generous fudge factor of 16 overhead bytes per entry.
	 * If bufsize is zero then put_listent must be a search function
	 * and can just scan through what we have.
	 */
	if (context->bufsize == 0 ||
	    (XFS_ISRESET_CURSOR(cursor) &&
             (dp->i_afp->if_bytes + sf->hdr.count * 16) < context->bufsize)) {
		for (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {
			error = context->put_listent(context,
					   sfe->flags,
					   sfe->nameval,
					   (int)sfe->namelen,
					   (int)sfe->valuelen,
					   &sfe->nameval[sfe->namelen]);

			/*
			 * Either search callback finished early or
			 * didn't fit it all in the buffer after all.
			 */
			if (context->seen_enough)
				break;

			if (error)
				return error;
			sfe = XFS_ATTR_SF_NEXTENTRY(sfe);
		}
		trace_xfs_attr_list_sf_all(context);
		return 0;
	}

	/* do no more for a search callback */
	if (context->bufsize == 0)
		return 0;

	/*
	 * It didn't all fit, so we have to sort everything on hashval.
	 */
	sbsize = sf->hdr.count * sizeof(*sbuf);
	sbp = sbuf = kmem_alloc(sbsize, KM_SLEEP | KM_NOFS);

	/*
	 * Scan the attribute list for the rest of the entries, storing
	 * the relevant info from only those that match into a buffer.
	 */
	nsbuf = 0;
	for (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {
		if (unlikely(
		    ((char *)sfe < (char *)sf) ||
		    ((char *)sfe >= ((char *)sf + dp->i_afp->if_bytes)))) {
			XFS_CORRUPTION_ERROR(""xfs_attr_shortform_list"",
					     XFS_ERRLEVEL_LOW,
					     context->dp->i_mount, sfe);
			kmem_free(sbuf);
			return -EFSCORRUPTED;
		}

		sbp->entno = i;
		sbp->hash = xfs_da_hashname(sfe->nameval, sfe->namelen);
		sbp->name = sfe->nameval;
		sbp->namelen = sfe->namelen;
		/* These are bytes, and both on-disk, don't endian-flip */
		sbp->valuelen = sfe->valuelen;
		sbp->flags = sfe->flags;
		sfe = XFS_ATTR_SF_NEXTENTRY(sfe);
		sbp++;
		nsbuf++;
	}

	/*
	 * Sort the entries on hash then entno.
	 */
	xfs_sort(sbuf, nsbuf, sizeof(*sbuf), xfs_attr_shortform_compare);

	/*
	 * Re-find our place IN THE SORTED LIST.
	 */
	count = 0;
	cursor->initted = 1;
	cursor->blkno = 0;
	for (sbp = sbuf, i = 0; i < nsbuf; i++, sbp++) {
		if (sbp->hash == cursor->hashval) {
			if (cursor->offset == count) {
				break;
			}
			count++;
		} else if (sbp->hash > cursor->hashval) {
			break;
		}
	}
	if (i == nsbuf) {
		kmem_free(sbuf);
		return 0;
	}

	/*
	 * Loop putting entries into the user buffer.
	 */
	for ( ; i < nsbuf; i++, sbp++) {
		if (cursor->hashval != sbp->hash) {
			cursor->hashval = sbp->hash;
			cursor->offset = 0;
		}
		error = context->put_listent(context,
					sbp->flags,
					sbp->name,
 					sbp->namelen,
 					sbp->valuelen,
 					&sbp->name[sbp->namelen]);
		if (error)
 			return error;
 		if (context->seen_enough)
 			break;
 		cursor->offset++;
	}

	kmem_free(sbuf);
	return 0;
}
",C,"		if (error) {
			kmem_free(sbuf);
		}
","		if (error)
",,"@@ -202,8 +202,10 @@ xfs_attr_shortform_list(xfs_attr_list_context_t *context)
 					sbp->namelen,
 					sbp->valuelen,
 					&sbp->name[sbp->namelen]);
-		if (error)
+		if (error) {
+			kmem_free(sbuf);
 			return error;
+		}
 		if (context->seen_enough)
 			break;
 		cursor->offset++;
@@ -454,14 +456,13 @@ xfs_attr3_leaf_list_int(
 				args.rmtblkcnt = xfs_attr3_rmt_blocks(
 							args.dp->i_mount, valuelen);
 				retval = xfs_attr_rmtval_get(&args);
-				if (retval)
-					return retval;
-				retval = context->put_listent(context,
-						entry->flags,
-						name_rmt->name,
-						(int)name_rmt->namelen,
-						valuelen,
-						args.value);
+				if (!retval)
+					retval = context->put_listent(context,
+							entry->flags,
+							name_rmt->name,
+							(int)name_rmt->namelen,
+							valuelen,
+							args.value);
 				kmem_free(args.value);
 			} else {
 				retval = context->put_listent(context,",linux,2e83b79b2d6c78bf1b4aa227938a214dcbddc83f,36f90b0a2ddd60823fe193a85e60ff1906c2a9b3,1,"xfs_attr_shortform_list(xfs_attr_list_context_t *context)
{
	attrlist_cursor_kern_t *cursor;
	xfs_attr_sf_sort_t *sbuf, *sbp;
	xfs_attr_shortform_t *sf;
	xfs_attr_sf_entry_t *sfe;
	xfs_inode_t *dp;
	int sbsize, nsbuf, count, i;
	int error;

	ASSERT(context != NULL);
	dp = context->dp;
	ASSERT(dp != NULL);
	ASSERT(dp->i_afp != NULL);
	sf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;
	ASSERT(sf != NULL);
	if (!sf->hdr.count)
		return 0;
	cursor = context->cursor;
	ASSERT(cursor != NULL);

	trace_xfs_attr_list_sf(context);

	/*
	 * If the buffer is large enough and the cursor is at the start,
	 * do not bother with sorting since we will return everything in
	 * one buffer and another call using the cursor won't need to be
	 * made.
	 * Note the generous fudge factor of 16 overhead bytes per entry.
	 * If bufsize is zero then put_listent must be a search function
	 * and can just scan through what we have.
	 */
	if (context->bufsize == 0 ||
	    (XFS_ISRESET_CURSOR(cursor) &&
             (dp->i_afp->if_bytes + sf->hdr.count * 16) < context->bufsize)) {
		for (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {
			error = context->put_listent(context,
					   sfe->flags,
					   sfe->nameval,
					   (int)sfe->namelen,
					   (int)sfe->valuelen,
					   &sfe->nameval[sfe->namelen]);

			/*
			 * Either search callback finished early or
			 * didn't fit it all in the buffer after all.
			 */
			if (context->seen_enough)
				break;

			if (error)
				return error;
			sfe = XFS_ATTR_SF_NEXTENTRY(sfe);
		}
		trace_xfs_attr_list_sf_all(context);
		return 0;
	}

	/* do no more for a search callback */
	if (context->bufsize == 0)
		return 0;

	/*
	 * It didn't all fit, so we have to sort everything on hashval.
	 */
	sbsize = sf->hdr.count * sizeof(*sbuf);
	sbp = sbuf = kmem_alloc(sbsize, KM_SLEEP | KM_NOFS);

	/*
	 * Scan the attribute list for the rest of the entries, storing
	 * the relevant info from only those that match into a buffer.
	 */
	nsbuf = 0;
	for (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {
		if (unlikely(
		    ((char *)sfe < (char *)sf) ||
		    ((char *)sfe >= ((char *)sf + dp->i_afp->if_bytes)))) {
			XFS_CORRUPTION_ERROR(""xfs_attr_shortform_list"",
					     XFS_ERRLEVEL_LOW,
					     context->dp->i_mount, sfe);
			kmem_free(sbuf);
			return -EFSCORRUPTED;
		}

		sbp->entno = i;
		sbp->hash = xfs_da_hashname(sfe->nameval, sfe->namelen);
		sbp->name = sfe->nameval;
		sbp->namelen = sfe->namelen;
		/* These are bytes, and both on-disk, don't endian-flip */
		sbp->valuelen = sfe->valuelen;
		sbp->flags = sfe->flags;
		sfe = XFS_ATTR_SF_NEXTENTRY(sfe);
		sbp++;
		nsbuf++;
	}

	/*
	 * Sort the entries on hash then entno.
	 */
	xfs_sort(sbuf, nsbuf, sizeof(*sbuf), xfs_attr_shortform_compare);

	/*
	 * Re-find our place IN THE SORTED LIST.
	 */
	count = 0;
	cursor->initted = 1;
	cursor->blkno = 0;
	for (sbp = sbuf, i = 0; i < nsbuf; i++, sbp++) {
		if (sbp->hash == cursor->hashval) {
			if (cursor->offset == count) {
				break;
			}
			count++;
		} else if (sbp->hash > cursor->hashval) {
			break;
		}
	}
	if (i == nsbuf) {
		kmem_free(sbuf);
		return 0;
	}

	/*
	 * Loop putting entries into the user buffer.
	 */
	for ( ; i < nsbuf; i++, sbp++) {
		if (cursor->hashval != sbp->hash) {
			cursor->hashval = sbp->hash;
			cursor->offset = 0;
		}
		error = context->put_listent(context,
					sbp->flags,
					sbp->name,
 					sbp->namelen,
 					sbp->valuelen,
 					&sbp->name[sbp->namelen]);
//flaw_line_below:
		if (error)
//fix_flaw_line_below:
//		if (error) {
//fix_flaw_line_below:
//			kmem_free(sbuf);
 			return error;
//fix_flaw_line_below:
//		}
 		if (context->seen_enough)
 			break;
 		cursor->offset++;
	}

	kmem_free(sbuf);
	return 0;
}
"
2341,180077,,Remote,Not required,Complete,CVE-2016-8666,https://www.cvedetails.com/cve/CVE-2016-8666/,CWE-400,Low,,,,2016-10-16,7.8,"The IP stack in the Linux kernel before 4.6 allows remote attackers to cause a denial of service (stack consumption and panic) or possibly have unspecified other impact by triggering use of the GRO path for packets with tunnel stacking, as demonstrated by interleaved IPv4 headers and GRE headers, a related issue to CVE-2016-7039.",2018-01-04,DoS ,1,https://github.com/torvalds/linux/commit/fac8e0f579695a3ecbc4d3cac369139d7f819971,fac8e0f579695a3ecbc4d3cac369139d7f819971,"tunnels: Don't apply GRO to multiple layers of encapsulation.

When drivers express support for TSO of encapsulated packets, they
only mean that they can do it for one layer of encapsulation.
Supporting additional levels would mean updating, at a minimum,
more IP length fields and they are unaware of this.

No encapsulation device expresses support for handling offloaded
encapsulated packets, so we won't generate these types of frames
in the transmit path. However, GRO doesn't have a check for
multiple levels of encapsulation and will attempt to build them.

UDP tunnel GRO actually does prevent this situation but it only
handles multiple UDP tunnels stacked on top of each other. This
generalizes that solution to prevent any kind of tunnel stacking
that would cause problems.

Fixes: bf5a755f (""net-gre-gro: Add GRE support to the GRO stack"")
Signed-off-by: Jesse Gross <jesse@kernel.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",1,net/core/dev.c,"{""sha"": ""f9eebd518545f2767e8f906d9d011f904853bd67"", ""filename"": ""include/linux/netdevice.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/fac8e0f579695a3ecbc4d3cac369139d7f819971/include/linux/netdevice.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/fac8e0f579695a3ecbc4d3cac369139d7f819971/include/linux/netdevice.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/netdevice.h?ref=fac8e0f579695a3ecbc4d3cac369139d7f819971"", ""patch"": ""@@ -2096,8 +2096,8 @@ struct napi_gro_cb {\n \t/* This is non-zero if the packet may be of the same flow. */\n \tu8\tsame_flow:1;\n \n-\t/* Used in udp_gro_receive */\n-\tu8\tudp_mark:1;\n+\t/* Used in tunnel GRO receive */\n+\tu8\tencap_mark:1;\n \n \t/* GRO checksum is valid */\n \tu8\tcsum_valid:1;""}<_**next**_>{""sha"": ""43c74cad25bc2fdb181aa9c64cd208432bdb439b"", ""filename"": ""net/core/dev.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/core/dev.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/core/dev.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/core/dev.c?ref=fac8e0f579695a3ecbc4d3cac369139d7f819971"", ""patch"": ""@@ -4438,7 +4438,7 @@ static enum gro_result dev_gro_receive(struct napi_struct *napi, struct sk_buff\n \t\tNAPI_GRO_CB(skb)->same_flow = 0;\n \t\tNAPI_GRO_CB(skb)->flush = 0;\n \t\tNAPI_GRO_CB(skb)->free = 0;\n-\t\tNAPI_GRO_CB(skb)->udp_mark = 0;\n+\t\tNAPI_GRO_CB(skb)->encap_mark = 0;\n \t\tNAPI_GRO_CB(skb)->gro_remcsum_start = 0;\n \n \t\t/* Setup for GRO checksum validation */""}<_**next**_>{""sha"": ""0fefba64ee79426b76782cef2da50e050b0cd59c"", ""filename"": ""net/ipv4/af_inet.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 1, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/ipv4/af_inet.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/ipv4/af_inet.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/af_inet.c?ref=fac8e0f579695a3ecbc4d3cac369139d7f819971"", ""patch"": ""@@ -1380,6 +1380,19 @@ static struct sk_buff **inet_gro_receive(struct sk_buff **head,\n \treturn pp;\n }\n \n+static struct sk_buff **ipip_gro_receive(struct sk_buff **head,\n+\t\t\t\t\t struct sk_buff *skb)\n+{\n+\tif (NAPI_GRO_CB(skb)->encap_mark) {\n+\t\tNAPI_GRO_CB(skb)->flush = 1;\n+\t\treturn NULL;\n+\t}\n+\n+\tNAPI_GRO_CB(skb)->encap_mark = 1;\n+\n+\treturn inet_gro_receive(head, skb);\n+}\n+\n #define SECONDS_PER_DAY\t86400\n \n /* inet_current_timestamp - Return IP network timestamp\n@@ -1682,7 +1695,7 @@ static struct packet_offload ip_packet_offload __read_mostly = {\n static const struct net_offload ipip_offload = {\n \t.callbacks = {\n \t\t.gso_segment\t= inet_gso_segment,\n-\t\t.gro_receive\t= inet_gro_receive,\n+\t\t.gro_receive\t= ipip_gro_receive,\n \t\t.gro_complete\t= ipip_gro_complete,\n \t},\n };""}<_**next**_>{""sha"": ""dd031617160ae8ac4ad1ae0441665d3a1acc8651"", ""filename"": ""net/ipv4/gre_offload.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/ipv4/gre_offload.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/ipv4/gre_offload.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/gre_offload.c?ref=fac8e0f579695a3ecbc4d3cac369139d7f819971"", ""patch"": ""@@ -126,6 +126,11 @@ static struct sk_buff **gre_gro_receive(struct sk_buff **head,\n \tstruct packet_offload *ptype;\n \t__be16 type;\n \n+\tif (NAPI_GRO_CB(skb)->encap_mark)\n+\t\tgoto out;\n+\n+\tNAPI_GRO_CB(skb)->encap_mark = 1;\n+\n \toff = skb_gro_offset(skb);\n \thlen = off + sizeof(*greh);\n \tgreh = skb_gro_header_fast(skb, off);""}<_**next**_>{""sha"": ""8007f73b8981be7e894849e4737d000da4436796"", ""filename"": ""net/ipv4/udp_offload.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/ipv4/udp_offload.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/ipv4/udp_offload.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/udp_offload.c?ref=fac8e0f579695a3ecbc4d3cac369139d7f819971"", ""patch"": ""@@ -311,14 +311,14 @@ struct sk_buff **udp_gro_receive(struct sk_buff **head, struct sk_buff *skb,\n \tunsigned int off = skb_gro_offset(skb);\n \tint flush = 1;\n \n-\tif (NAPI_GRO_CB(skb)->udp_mark ||\n+\tif (NAPI_GRO_CB(skb)->encap_mark ||\n \t    (skb->ip_summed != CHECKSUM_PARTIAL &&\n \t     NAPI_GRO_CB(skb)->csum_cnt == 0 &&\n \t     !NAPI_GRO_CB(skb)->csum_valid))\n \t\tgoto out;\n \n-\t/* mark that this skb passed once through the udp gro layer */\n-\tNAPI_GRO_CB(skb)->udp_mark = 1;\n+\t/* mark that this skb passed once through the tunnel gro layer */\n+\tNAPI_GRO_CB(skb)->encap_mark = 1;\n \n \trcu_read_lock();\n \tuo_priv = rcu_dereference(udp_offload_base);""}<_**next**_>{""sha"": ""82e9f30760283aca2f3d9468573aea607bd5bf6b"", ""filename"": ""net/ipv6/ip6_offload.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 1, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/ipv6/ip6_offload.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/ipv6/ip6_offload.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/ip6_offload.c?ref=fac8e0f579695a3ecbc4d3cac369139d7f819971"", ""patch"": ""@@ -258,6 +258,19 @@ static struct sk_buff **ipv6_gro_receive(struct sk_buff **head,\n \treturn pp;\n }\n \n+static struct sk_buff **sit_gro_receive(struct sk_buff **head,\n+\t\t\t\t\tstruct sk_buff *skb)\n+{\n+\tif (NAPI_GRO_CB(skb)->encap_mark) {\n+\t\tNAPI_GRO_CB(skb)->flush = 1;\n+\t\treturn NULL;\n+\t}\n+\n+\tNAPI_GRO_CB(skb)->encap_mark = 1;\n+\n+\treturn ipv6_gro_receive(head, skb);\n+}\n+\n static int ipv6_gro_complete(struct sk_buff *skb, int nhoff)\n {\n \tconst struct net_offload *ops;\n@@ -302,7 +315,7 @@ static struct packet_offload ipv6_packet_offload __read_mostly = {\n static const struct net_offload sit_offload = {\n \t.callbacks = {\n \t\t.gso_segment\t= ipv6_gso_segment,\n-\t\t.gro_receive    = ipv6_gro_receive,\n+\t\t.gro_receive    = sit_gro_receive,\n \t\t.gro_complete   = sit_gro_complete,\n \t},\n };""}","static enum gro_result dev_gro_receive(struct napi_struct *napi, struct sk_buff *skb)
{
	struct sk_buff **pp = NULL;
	struct packet_offload *ptype;
	__be16 type = skb->protocol;
	struct list_head *head = &offload_base;
	int same_flow;
	enum gro_result ret;
	int grow;

	if (!(skb->dev->features & NETIF_F_GRO))
		goto normal;

	if (skb_is_gso(skb) || skb_has_frag_list(skb) || skb->csum_bad)
		goto normal;

	gro_list_prepare(napi, skb);

	rcu_read_lock();
	list_for_each_entry_rcu(ptype, head, list) {
		if (ptype->type != type || !ptype->callbacks.gro_receive)
			continue;

		skb_set_network_header(skb, skb_gro_offset(skb));
		skb_reset_mac_len(skb);
 		NAPI_GRO_CB(skb)->same_flow = 0;
 		NAPI_GRO_CB(skb)->flush = 0;
 		NAPI_GRO_CB(skb)->free = 0;
		NAPI_GRO_CB(skb)->encap_mark = 0;
 		NAPI_GRO_CB(skb)->gro_remcsum_start = 0;
 
 		/* Setup for GRO checksum validation */
		switch (skb->ip_summed) {
		case CHECKSUM_COMPLETE:
			NAPI_GRO_CB(skb)->csum = skb->csum;
			NAPI_GRO_CB(skb)->csum_valid = 1;
			NAPI_GRO_CB(skb)->csum_cnt = 0;
			break;
		case CHECKSUM_UNNECESSARY:
			NAPI_GRO_CB(skb)->csum_cnt = skb->csum_level + 1;
			NAPI_GRO_CB(skb)->csum_valid = 0;
			break;
		default:
			NAPI_GRO_CB(skb)->csum_cnt = 0;
			NAPI_GRO_CB(skb)->csum_valid = 0;
		}

		pp = ptype->callbacks.gro_receive(&napi->gro_list, skb);
		break;
	}
	rcu_read_unlock();

	if (&ptype->list == head)
		goto normal;

	same_flow = NAPI_GRO_CB(skb)->same_flow;
	ret = NAPI_GRO_CB(skb)->free ? GRO_MERGED_FREE : GRO_MERGED;

	if (pp) {
		struct sk_buff *nskb = *pp;

		*pp = nskb->next;
		nskb->next = NULL;
		napi_gro_complete(nskb);
		napi->gro_count--;
	}

	if (same_flow)
		goto ok;

	if (NAPI_GRO_CB(skb)->flush)
		goto normal;

	if (unlikely(napi->gro_count >= MAX_GRO_SKBS)) {
		struct sk_buff *nskb = napi->gro_list;

		/* locate the end of the list to select the 'oldest' flow */
		while (nskb->next) {
			pp = &nskb->next;
			nskb = *pp;
		}
		*pp = NULL;
		nskb->next = NULL;
		napi_gro_complete(nskb);
	} else {
		napi->gro_count++;
	}
	NAPI_GRO_CB(skb)->count = 1;
	NAPI_GRO_CB(skb)->age = jiffies;
	NAPI_GRO_CB(skb)->last = skb;
	skb_shinfo(skb)->gso_size = skb_gro_len(skb);
	skb->next = napi->gro_list;
	napi->gro_list = skb;
	ret = GRO_HELD;

pull:
	grow = skb_gro_offset(skb) - skb_headlen(skb);
	if (grow > 0)
		gro_pull_from_frag0(skb, grow);
ok:
	return ret;

normal:
	ret = GRO_NORMAL;
	goto pull;
}
","static enum gro_result dev_gro_receive(struct napi_struct *napi, struct sk_buff *skb)
{
	struct sk_buff **pp = NULL;
	struct packet_offload *ptype;
	__be16 type = skb->protocol;
	struct list_head *head = &offload_base;
	int same_flow;
	enum gro_result ret;
	int grow;

	if (!(skb->dev->features & NETIF_F_GRO))
		goto normal;

	if (skb_is_gso(skb) || skb_has_frag_list(skb) || skb->csum_bad)
		goto normal;

	gro_list_prepare(napi, skb);

	rcu_read_lock();
	list_for_each_entry_rcu(ptype, head, list) {
		if (ptype->type != type || !ptype->callbacks.gro_receive)
			continue;

		skb_set_network_header(skb, skb_gro_offset(skb));
		skb_reset_mac_len(skb);
 		NAPI_GRO_CB(skb)->same_flow = 0;
 		NAPI_GRO_CB(skb)->flush = 0;
 		NAPI_GRO_CB(skb)->free = 0;
		NAPI_GRO_CB(skb)->udp_mark = 0;
 		NAPI_GRO_CB(skb)->gro_remcsum_start = 0;
 
 		/* Setup for GRO checksum validation */
		switch (skb->ip_summed) {
		case CHECKSUM_COMPLETE:
			NAPI_GRO_CB(skb)->csum = skb->csum;
			NAPI_GRO_CB(skb)->csum_valid = 1;
			NAPI_GRO_CB(skb)->csum_cnt = 0;
			break;
		case CHECKSUM_UNNECESSARY:
			NAPI_GRO_CB(skb)->csum_cnt = skb->csum_level + 1;
			NAPI_GRO_CB(skb)->csum_valid = 0;
			break;
		default:
			NAPI_GRO_CB(skb)->csum_cnt = 0;
			NAPI_GRO_CB(skb)->csum_valid = 0;
		}

		pp = ptype->callbacks.gro_receive(&napi->gro_list, skb);
		break;
	}
	rcu_read_unlock();

	if (&ptype->list == head)
		goto normal;

	same_flow = NAPI_GRO_CB(skb)->same_flow;
	ret = NAPI_GRO_CB(skb)->free ? GRO_MERGED_FREE : GRO_MERGED;

	if (pp) {
		struct sk_buff *nskb = *pp;

		*pp = nskb->next;
		nskb->next = NULL;
		napi_gro_complete(nskb);
		napi->gro_count--;
	}

	if (same_flow)
		goto ok;

	if (NAPI_GRO_CB(skb)->flush)
		goto normal;

	if (unlikely(napi->gro_count >= MAX_GRO_SKBS)) {
		struct sk_buff *nskb = napi->gro_list;

		/* locate the end of the list to select the 'oldest' flow */
		while (nskb->next) {
			pp = &nskb->next;
			nskb = *pp;
		}
		*pp = NULL;
		nskb->next = NULL;
		napi_gro_complete(nskb);
	} else {
		napi->gro_count++;
	}
	NAPI_GRO_CB(skb)->count = 1;
	NAPI_GRO_CB(skb)->age = jiffies;
	NAPI_GRO_CB(skb)->last = skb;
	skb_shinfo(skb)->gso_size = skb_gro_len(skb);
	skb->next = napi->gro_list;
	napi->gro_list = skb;
	ret = GRO_HELD;

pull:
	grow = skb_gro_offset(skb) - skb_headlen(skb);
	if (grow > 0)
		gro_pull_from_frag0(skb, grow);
ok:
	return ret;

normal:
	ret = GRO_NORMAL;
	goto pull;
}
",C,"		NAPI_GRO_CB(skb)->encap_mark = 0;
","		NAPI_GRO_CB(skb)->udp_mark = 0;
",,"@@ -4438,7 +4438,7 @@ static enum gro_result dev_gro_receive(struct napi_struct *napi, struct sk_buff
 		NAPI_GRO_CB(skb)->same_flow = 0;
 		NAPI_GRO_CB(skb)->flush = 0;
 		NAPI_GRO_CB(skb)->free = 0;
-		NAPI_GRO_CB(skb)->udp_mark = 0;
+		NAPI_GRO_CB(skb)->encap_mark = 0;
 		NAPI_GRO_CB(skb)->gro_remcsum_start = 0;
 
 		/* Setup for GRO checksum validation */",linux,fac8e0f579695a3ecbc4d3cac369139d7f819971,b8cba75bdf6a48ea4811bbefb11a94a5c7281b68,1,"static enum gro_result dev_gro_receive(struct napi_struct *napi, struct sk_buff *skb)
{
	struct sk_buff **pp = NULL;
	struct packet_offload *ptype;
	__be16 type = skb->protocol;
	struct list_head *head = &offload_base;
	int same_flow;
	enum gro_result ret;
	int grow;

	if (!(skb->dev->features & NETIF_F_GRO))
		goto normal;

	if (skb_is_gso(skb) || skb_has_frag_list(skb) || skb->csum_bad)
		goto normal;

	gro_list_prepare(napi, skb);

	rcu_read_lock();
	list_for_each_entry_rcu(ptype, head, list) {
		if (ptype->type != type || !ptype->callbacks.gro_receive)
			continue;

		skb_set_network_header(skb, skb_gro_offset(skb));
		skb_reset_mac_len(skb);
 		NAPI_GRO_CB(skb)->same_flow = 0;
 		NAPI_GRO_CB(skb)->flush = 0;
 		NAPI_GRO_CB(skb)->free = 0;
//flaw_line_below:
		NAPI_GRO_CB(skb)->udp_mark = 0;
//fix_flaw_line_below:
//		NAPI_GRO_CB(skb)->encap_mark = 0;
 		NAPI_GRO_CB(skb)->gro_remcsum_start = 0;
 
 		/* Setup for GRO checksum validation */
		switch (skb->ip_summed) {
		case CHECKSUM_COMPLETE:
			NAPI_GRO_CB(skb)->csum = skb->csum;
			NAPI_GRO_CB(skb)->csum_valid = 1;
			NAPI_GRO_CB(skb)->csum_cnt = 0;
			break;
		case CHECKSUM_UNNECESSARY:
			NAPI_GRO_CB(skb)->csum_cnt = skb->csum_level + 1;
			NAPI_GRO_CB(skb)->csum_valid = 0;
			break;
		default:
			NAPI_GRO_CB(skb)->csum_cnt = 0;
			NAPI_GRO_CB(skb)->csum_valid = 0;
		}

		pp = ptype->callbacks.gro_receive(&napi->gro_list, skb);
		break;
	}
	rcu_read_unlock();

	if (&ptype->list == head)
		goto normal;

	same_flow = NAPI_GRO_CB(skb)->same_flow;
	ret = NAPI_GRO_CB(skb)->free ? GRO_MERGED_FREE : GRO_MERGED;

	if (pp) {
		struct sk_buff *nskb = *pp;

		*pp = nskb->next;
		nskb->next = NULL;
		napi_gro_complete(nskb);
		napi->gro_count--;
	}

	if (same_flow)
		goto ok;

	if (NAPI_GRO_CB(skb)->flush)
		goto normal;

	if (unlikely(napi->gro_count >= MAX_GRO_SKBS)) {
		struct sk_buff *nskb = napi->gro_list;

		/* locate the end of the list to select the 'oldest' flow */
		while (nskb->next) {
			pp = &nskb->next;
			nskb = *pp;
		}
		*pp = NULL;
		nskb->next = NULL;
		napi_gro_complete(nskb);
	} else {
		napi->gro_count++;
	}
	NAPI_GRO_CB(skb)->count = 1;
	NAPI_GRO_CB(skb)->age = jiffies;
	NAPI_GRO_CB(skb)->last = skb;
	skb_shinfo(skb)->gso_size = skb_gro_len(skb);
	skb->next = napi->gro_list;
	napi->gro_list = skb;
	ret = GRO_HELD;

pull:
	grow = skb_gro_offset(skb) - skb_headlen(skb);
	if (grow > 0)
		gro_pull_from_frag0(skb, grow);
ok:
	return ret;

normal:
	ret = GRO_NORMAL;
	goto pull;
}
"
2342,180078,,Remote,Not required,Complete,CVE-2016-8666,https://www.cvedetails.com/cve/CVE-2016-8666/,CWE-400,Low,,,,2016-10-16,7.8,"The IP stack in the Linux kernel before 4.6 allows remote attackers to cause a denial of service (stack consumption and panic) or possibly have unspecified other impact by triggering use of the GRO path for packets with tunnel stacking, as demonstrated by interleaved IPv4 headers and GRE headers, a related issue to CVE-2016-7039.",2018-01-04,DoS ,5,https://github.com/torvalds/linux/commit/fac8e0f579695a3ecbc4d3cac369139d7f819971,fac8e0f579695a3ecbc4d3cac369139d7f819971,"tunnels: Don't apply GRO to multiple layers of encapsulation.

When drivers express support for TSO of encapsulated packets, they
only mean that they can do it for one layer of encapsulation.
Supporting additional levels would mean updating, at a minimum,
more IP length fields and they are unaware of this.

No encapsulation device expresses support for handling offloaded
encapsulated packets, so we won't generate these types of frames
in the transmit path. However, GRO doesn't have a check for
multiple levels of encapsulation and will attempt to build them.

UDP tunnel GRO actually does prevent this situation but it only
handles multiple UDP tunnels stacked on top of each other. This
generalizes that solution to prevent any kind of tunnel stacking
that would cause problems.

Fixes: bf5a755f (""net-gre-gro: Add GRE support to the GRO stack"")
Signed-off-by: Jesse Gross <jesse@kernel.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/ipv4/gre_offload.c,"{""sha"": ""f9eebd518545f2767e8f906d9d011f904853bd67"", ""filename"": ""include/linux/netdevice.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/fac8e0f579695a3ecbc4d3cac369139d7f819971/include/linux/netdevice.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/fac8e0f579695a3ecbc4d3cac369139d7f819971/include/linux/netdevice.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/netdevice.h?ref=fac8e0f579695a3ecbc4d3cac369139d7f819971"", ""patch"": ""@@ -2096,8 +2096,8 @@ struct napi_gro_cb {\n \t/* This is non-zero if the packet may be of the same flow. */\n \tu8\tsame_flow:1;\n \n-\t/* Used in udp_gro_receive */\n-\tu8\tudp_mark:1;\n+\t/* Used in tunnel GRO receive */\n+\tu8\tencap_mark:1;\n \n \t/* GRO checksum is valid */\n \tu8\tcsum_valid:1;""}<_**next**_>{""sha"": ""43c74cad25bc2fdb181aa9c64cd208432bdb439b"", ""filename"": ""net/core/dev.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/core/dev.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/core/dev.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/core/dev.c?ref=fac8e0f579695a3ecbc4d3cac369139d7f819971"", ""patch"": ""@@ -4438,7 +4438,7 @@ static enum gro_result dev_gro_receive(struct napi_struct *napi, struct sk_buff\n \t\tNAPI_GRO_CB(skb)->same_flow = 0;\n \t\tNAPI_GRO_CB(skb)->flush = 0;\n \t\tNAPI_GRO_CB(skb)->free = 0;\n-\t\tNAPI_GRO_CB(skb)->udp_mark = 0;\n+\t\tNAPI_GRO_CB(skb)->encap_mark = 0;\n \t\tNAPI_GRO_CB(skb)->gro_remcsum_start = 0;\n \n \t\t/* Setup for GRO checksum validation */""}<_**next**_>{""sha"": ""0fefba64ee79426b76782cef2da50e050b0cd59c"", ""filename"": ""net/ipv4/af_inet.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 1, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/ipv4/af_inet.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/ipv4/af_inet.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/af_inet.c?ref=fac8e0f579695a3ecbc4d3cac369139d7f819971"", ""patch"": ""@@ -1380,6 +1380,19 @@ static struct sk_buff **inet_gro_receive(struct sk_buff **head,\n \treturn pp;\n }\n \n+static struct sk_buff **ipip_gro_receive(struct sk_buff **head,\n+\t\t\t\t\t struct sk_buff *skb)\n+{\n+\tif (NAPI_GRO_CB(skb)->encap_mark) {\n+\t\tNAPI_GRO_CB(skb)->flush = 1;\n+\t\treturn NULL;\n+\t}\n+\n+\tNAPI_GRO_CB(skb)->encap_mark = 1;\n+\n+\treturn inet_gro_receive(head, skb);\n+}\n+\n #define SECONDS_PER_DAY\t86400\n \n /* inet_current_timestamp - Return IP network timestamp\n@@ -1682,7 +1695,7 @@ static struct packet_offload ip_packet_offload __read_mostly = {\n static const struct net_offload ipip_offload = {\n \t.callbacks = {\n \t\t.gso_segment\t= inet_gso_segment,\n-\t\t.gro_receive\t= inet_gro_receive,\n+\t\t.gro_receive\t= ipip_gro_receive,\n \t\t.gro_complete\t= ipip_gro_complete,\n \t},\n };""}<_**next**_>{""sha"": ""dd031617160ae8ac4ad1ae0441665d3a1acc8651"", ""filename"": ""net/ipv4/gre_offload.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/ipv4/gre_offload.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/ipv4/gre_offload.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/gre_offload.c?ref=fac8e0f579695a3ecbc4d3cac369139d7f819971"", ""patch"": ""@@ -126,6 +126,11 @@ static struct sk_buff **gre_gro_receive(struct sk_buff **head,\n \tstruct packet_offload *ptype;\n \t__be16 type;\n \n+\tif (NAPI_GRO_CB(skb)->encap_mark)\n+\t\tgoto out;\n+\n+\tNAPI_GRO_CB(skb)->encap_mark = 1;\n+\n \toff = skb_gro_offset(skb);\n \thlen = off + sizeof(*greh);\n \tgreh = skb_gro_header_fast(skb, off);""}<_**next**_>{""sha"": ""8007f73b8981be7e894849e4737d000da4436796"", ""filename"": ""net/ipv4/udp_offload.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/ipv4/udp_offload.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/ipv4/udp_offload.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/udp_offload.c?ref=fac8e0f579695a3ecbc4d3cac369139d7f819971"", ""patch"": ""@@ -311,14 +311,14 @@ struct sk_buff **udp_gro_receive(struct sk_buff **head, struct sk_buff *skb,\n \tunsigned int off = skb_gro_offset(skb);\n \tint flush = 1;\n \n-\tif (NAPI_GRO_CB(skb)->udp_mark ||\n+\tif (NAPI_GRO_CB(skb)->encap_mark ||\n \t    (skb->ip_summed != CHECKSUM_PARTIAL &&\n \t     NAPI_GRO_CB(skb)->csum_cnt == 0 &&\n \t     !NAPI_GRO_CB(skb)->csum_valid))\n \t\tgoto out;\n \n-\t/* mark that this skb passed once through the udp gro layer */\n-\tNAPI_GRO_CB(skb)->udp_mark = 1;\n+\t/* mark that this skb passed once through the tunnel gro layer */\n+\tNAPI_GRO_CB(skb)->encap_mark = 1;\n \n \trcu_read_lock();\n \tuo_priv = rcu_dereference(udp_offload_base);""}<_**next**_>{""sha"": ""82e9f30760283aca2f3d9468573aea607bd5bf6b"", ""filename"": ""net/ipv6/ip6_offload.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 1, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/ipv6/ip6_offload.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/ipv6/ip6_offload.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/ip6_offload.c?ref=fac8e0f579695a3ecbc4d3cac369139d7f819971"", ""patch"": ""@@ -258,6 +258,19 @@ static struct sk_buff **ipv6_gro_receive(struct sk_buff **head,\n \treturn pp;\n }\n \n+static struct sk_buff **sit_gro_receive(struct sk_buff **head,\n+\t\t\t\t\tstruct sk_buff *skb)\n+{\n+\tif (NAPI_GRO_CB(skb)->encap_mark) {\n+\t\tNAPI_GRO_CB(skb)->flush = 1;\n+\t\treturn NULL;\n+\t}\n+\n+\tNAPI_GRO_CB(skb)->encap_mark = 1;\n+\n+\treturn ipv6_gro_receive(head, skb);\n+}\n+\n static int ipv6_gro_complete(struct sk_buff *skb, int nhoff)\n {\n \tconst struct net_offload *ops;\n@@ -302,7 +315,7 @@ static struct packet_offload ipv6_packet_offload __read_mostly = {\n static const struct net_offload sit_offload = {\n \t.callbacks = {\n \t\t.gso_segment\t= ipv6_gso_segment,\n-\t\t.gro_receive    = ipv6_gro_receive,\n+\t\t.gro_receive    = sit_gro_receive,\n \t\t.gro_complete   = sit_gro_complete,\n \t},\n };""}","static struct sk_buff **gre_gro_receive(struct sk_buff **head,
					struct sk_buff *skb)
{
	struct sk_buff **pp = NULL;
	struct sk_buff *p;
	const struct gre_base_hdr *greh;
	unsigned int hlen, grehlen;
	unsigned int off;
	int flush = 1;
 	struct packet_offload *ptype;
 	__be16 type;
 
	if (NAPI_GRO_CB(skb)->encap_mark)
		goto out;

	NAPI_GRO_CB(skb)->encap_mark = 1;

 	off = skb_gro_offset(skb);
 	hlen = off + sizeof(*greh);
 	greh = skb_gro_header_fast(skb, off);
	if (skb_gro_header_hard(skb, hlen)) {
		greh = skb_gro_header_slow(skb, hlen, off);
		if (unlikely(!greh))
			goto out;
	}

	/* Only support version 0 and K (key), C (csum) flags. Note that
	 * although the support for the S (seq#) flag can be added easily
	 * for GRO, this is problematic for GSO hence can not be enabled
	 * here because a GRO pkt may end up in the forwarding path, thus
	 * requiring GSO support to break it up correctly.
	 */
	if ((greh->flags & ~(GRE_KEY|GRE_CSUM)) != 0)
		goto out;

	type = greh->protocol;

	rcu_read_lock();
	ptype = gro_find_receive_by_type(type);
	if (!ptype)
		goto out_unlock;

	grehlen = GRE_HEADER_SECTION;

	if (greh->flags & GRE_KEY)
		grehlen += GRE_HEADER_SECTION;

	if (greh->flags & GRE_CSUM)
		grehlen += GRE_HEADER_SECTION;

	hlen = off + grehlen;
	if (skb_gro_header_hard(skb, hlen)) {
		greh = skb_gro_header_slow(skb, hlen, off);
		if (unlikely(!greh))
			goto out_unlock;
	}

	/* Don't bother verifying checksum if we're going to flush anyway. */
	if ((greh->flags & GRE_CSUM) && !NAPI_GRO_CB(skb)->flush) {
		if (skb_gro_checksum_simple_validate(skb))
			goto out_unlock;

		skb_gro_checksum_try_convert(skb, IPPROTO_GRE, 0,
					     null_compute_pseudo);
	}

	for (p = *head; p; p = p->next) {
		const struct gre_base_hdr *greh2;

		if (!NAPI_GRO_CB(p)->same_flow)
			continue;

		/* The following checks are needed to ensure only pkts
		 * from the same tunnel are considered for aggregation.
		 * The criteria for ""the same tunnel"" includes:
		 * 1) same version (we only support version 0 here)
		 * 2) same protocol (we only support ETH_P_IP for now)
		 * 3) same set of flags
		 * 4) same key if the key field is present.
		 */
		greh2 = (struct gre_base_hdr *)(p->data + off);

		if (greh2->flags != greh->flags ||
		    greh2->protocol != greh->protocol) {
			NAPI_GRO_CB(p)->same_flow = 0;
			continue;
		}
		if (greh->flags & GRE_KEY) {
			/* compare keys */
			if (*(__be32 *)(greh2+1) != *(__be32 *)(greh+1)) {
				NAPI_GRO_CB(p)->same_flow = 0;
				continue;
			}
		}
	}

	skb_gro_pull(skb, grehlen);

	/* Adjusted NAPI_GRO_CB(skb)->csum after skb_gro_pull()*/
	skb_gro_postpull_rcsum(skb, greh, grehlen);

	pp = ptype->callbacks.gro_receive(head, skb);
	flush = 0;

out_unlock:
	rcu_read_unlock();
out:
	NAPI_GRO_CB(skb)->flush |= flush;

	return pp;
}
","static struct sk_buff **gre_gro_receive(struct sk_buff **head,
					struct sk_buff *skb)
{
	struct sk_buff **pp = NULL;
	struct sk_buff *p;
	const struct gre_base_hdr *greh;
	unsigned int hlen, grehlen;
	unsigned int off;
	int flush = 1;
 	struct packet_offload *ptype;
 	__be16 type;
 
 	off = skb_gro_offset(skb);
 	hlen = off + sizeof(*greh);
 	greh = skb_gro_header_fast(skb, off);
	if (skb_gro_header_hard(skb, hlen)) {
		greh = skb_gro_header_slow(skb, hlen, off);
		if (unlikely(!greh))
			goto out;
	}

	/* Only support version 0 and K (key), C (csum) flags. Note that
	 * although the support for the S (seq#) flag can be added easily
	 * for GRO, this is problematic for GSO hence can not be enabled
	 * here because a GRO pkt may end up in the forwarding path, thus
	 * requiring GSO support to break it up correctly.
	 */
	if ((greh->flags & ~(GRE_KEY|GRE_CSUM)) != 0)
		goto out;

	type = greh->protocol;

	rcu_read_lock();
	ptype = gro_find_receive_by_type(type);
	if (!ptype)
		goto out_unlock;

	grehlen = GRE_HEADER_SECTION;

	if (greh->flags & GRE_KEY)
		grehlen += GRE_HEADER_SECTION;

	if (greh->flags & GRE_CSUM)
		grehlen += GRE_HEADER_SECTION;

	hlen = off + grehlen;
	if (skb_gro_header_hard(skb, hlen)) {
		greh = skb_gro_header_slow(skb, hlen, off);
		if (unlikely(!greh))
			goto out_unlock;
	}

	/* Don't bother verifying checksum if we're going to flush anyway. */
	if ((greh->flags & GRE_CSUM) && !NAPI_GRO_CB(skb)->flush) {
		if (skb_gro_checksum_simple_validate(skb))
			goto out_unlock;

		skb_gro_checksum_try_convert(skb, IPPROTO_GRE, 0,
					     null_compute_pseudo);
	}

	for (p = *head; p; p = p->next) {
		const struct gre_base_hdr *greh2;

		if (!NAPI_GRO_CB(p)->same_flow)
			continue;

		/* The following checks are needed to ensure only pkts
		 * from the same tunnel are considered for aggregation.
		 * The criteria for ""the same tunnel"" includes:
		 * 1) same version (we only support version 0 here)
		 * 2) same protocol (we only support ETH_P_IP for now)
		 * 3) same set of flags
		 * 4) same key if the key field is present.
		 */
		greh2 = (struct gre_base_hdr *)(p->data + off);

		if (greh2->flags != greh->flags ||
		    greh2->protocol != greh->protocol) {
			NAPI_GRO_CB(p)->same_flow = 0;
			continue;
		}
		if (greh->flags & GRE_KEY) {
			/* compare keys */
			if (*(__be32 *)(greh2+1) != *(__be32 *)(greh+1)) {
				NAPI_GRO_CB(p)->same_flow = 0;
				continue;
			}
		}
	}

	skb_gro_pull(skb, grehlen);

	/* Adjusted NAPI_GRO_CB(skb)->csum after skb_gro_pull()*/
	skb_gro_postpull_rcsum(skb, greh, grehlen);

	pp = ptype->callbacks.gro_receive(head, skb);
	flush = 0;

out_unlock:
	rcu_read_unlock();
out:
	NAPI_GRO_CB(skb)->flush |= flush;

	return pp;
}
",C,"	if (NAPI_GRO_CB(skb)->encap_mark)
		goto out;

	NAPI_GRO_CB(skb)->encap_mark = 1;

",,,"@@ -126,6 +126,11 @@ static struct sk_buff **gre_gro_receive(struct sk_buff **head,
 	struct packet_offload *ptype;
 	__be16 type;
 
+	if (NAPI_GRO_CB(skb)->encap_mark)
+		goto out;
+
+	NAPI_GRO_CB(skb)->encap_mark = 1;
+
 	off = skb_gro_offset(skb);
 	hlen = off + sizeof(*greh);
 	greh = skb_gro_header_fast(skb, off);",linux,fac8e0f579695a3ecbc4d3cac369139d7f819971,b8cba75bdf6a48ea4811bbefb11a94a5c7281b68,1,"static struct sk_buff **gre_gro_receive(struct sk_buff **head,
					struct sk_buff *skb)
{
	struct sk_buff **pp = NULL;
	struct sk_buff *p;
	const struct gre_base_hdr *greh;
	unsigned int hlen, grehlen;
	unsigned int off;
	int flush = 1;
 	struct packet_offload *ptype;
 	__be16 type;
 
//fix_flaw_line_below:
//	if (NAPI_GRO_CB(skb)->encap_mark)
//fix_flaw_line_below:
//		goto out;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	NAPI_GRO_CB(skb)->encap_mark = 1;
//fix_flaw_line_below:
//
 	off = skb_gro_offset(skb);
 	hlen = off + sizeof(*greh);
 	greh = skb_gro_header_fast(skb, off);
	if (skb_gro_header_hard(skb, hlen)) {
		greh = skb_gro_header_slow(skb, hlen, off);
		if (unlikely(!greh))
			goto out;
	}

	/* Only support version 0 and K (key), C (csum) flags. Note that
	 * although the support for the S (seq#) flag can be added easily
	 * for GRO, this is problematic for GSO hence can not be enabled
	 * here because a GRO pkt may end up in the forwarding path, thus
	 * requiring GSO support to break it up correctly.
	 */
	if ((greh->flags & ~(GRE_KEY|GRE_CSUM)) != 0)
		goto out;

	type = greh->protocol;

	rcu_read_lock();
	ptype = gro_find_receive_by_type(type);
	if (!ptype)
		goto out_unlock;

	grehlen = GRE_HEADER_SECTION;

	if (greh->flags & GRE_KEY)
		grehlen += GRE_HEADER_SECTION;

	if (greh->flags & GRE_CSUM)
		grehlen += GRE_HEADER_SECTION;

	hlen = off + grehlen;
	if (skb_gro_header_hard(skb, hlen)) {
		greh = skb_gro_header_slow(skb, hlen, off);
		if (unlikely(!greh))
			goto out_unlock;
	}

	/* Don't bother verifying checksum if we're going to flush anyway. */
	if ((greh->flags & GRE_CSUM) && !NAPI_GRO_CB(skb)->flush) {
		if (skb_gro_checksum_simple_validate(skb))
			goto out_unlock;

		skb_gro_checksum_try_convert(skb, IPPROTO_GRE, 0,
					     null_compute_pseudo);
	}

	for (p = *head; p; p = p->next) {
		const struct gre_base_hdr *greh2;

		if (!NAPI_GRO_CB(p)->same_flow)
			continue;

		/* The following checks are needed to ensure only pkts
		 * from the same tunnel are considered for aggregation.
		 * The criteria for ""the same tunnel"" includes:
		 * 1) same version (we only support version 0 here)
		 * 2) same protocol (we only support ETH_P_IP for now)
		 * 3) same set of flags
		 * 4) same key if the key field is present.
		 */
		greh2 = (struct gre_base_hdr *)(p->data + off);

		if (greh2->flags != greh->flags ||
		    greh2->protocol != greh->protocol) {
			NAPI_GRO_CB(p)->same_flow = 0;
			continue;
		}
		if (greh->flags & GRE_KEY) {
			/* compare keys */
			if (*(__be32 *)(greh2+1) != *(__be32 *)(greh+1)) {
				NAPI_GRO_CB(p)->same_flow = 0;
				continue;
			}
		}
	}

	skb_gro_pull(skb, grehlen);

	/* Adjusted NAPI_GRO_CB(skb)->csum after skb_gro_pull()*/
	skb_gro_postpull_rcsum(skb, greh, grehlen);

	pp = ptype->callbacks.gro_receive(head, skb);
	flush = 0;

out_unlock:
	rcu_read_unlock();
out:
	NAPI_GRO_CB(skb)->flush |= flush;

	return pp;
}
"
2343,180079,,Remote,Not required,Complete,CVE-2016-8666,https://www.cvedetails.com/cve/CVE-2016-8666/,CWE-400,Low,,,,2016-10-16,7.8,"The IP stack in the Linux kernel before 4.6 allows remote attackers to cause a denial of service (stack consumption and panic) or possibly have unspecified other impact by triggering use of the GRO path for packets with tunnel stacking, as demonstrated by interleaved IPv4 headers and GRE headers, a related issue to CVE-2016-7039.",2018-01-04,DoS ,3,https://github.com/torvalds/linux/commit/fac8e0f579695a3ecbc4d3cac369139d7f819971,fac8e0f579695a3ecbc4d3cac369139d7f819971,"tunnels: Don't apply GRO to multiple layers of encapsulation.

When drivers express support for TSO of encapsulated packets, they
only mean that they can do it for one layer of encapsulation.
Supporting additional levels would mean updating, at a minimum,
more IP length fields and they are unaware of this.

No encapsulation device expresses support for handling offloaded
encapsulated packets, so we won't generate these types of frames
in the transmit path. However, GRO doesn't have a check for
multiple levels of encapsulation and will attempt to build them.

UDP tunnel GRO actually does prevent this situation but it only
handles multiple UDP tunnels stacked on top of each other. This
generalizes that solution to prevent any kind of tunnel stacking
that would cause problems.

Fixes: bf5a755f (""net-gre-gro: Add GRE support to the GRO stack"")
Signed-off-by: Jesse Gross <jesse@kernel.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",3,net/ipv4/udp_offload.c,"{""sha"": ""f9eebd518545f2767e8f906d9d011f904853bd67"", ""filename"": ""include/linux/netdevice.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/fac8e0f579695a3ecbc4d3cac369139d7f819971/include/linux/netdevice.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/fac8e0f579695a3ecbc4d3cac369139d7f819971/include/linux/netdevice.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/netdevice.h?ref=fac8e0f579695a3ecbc4d3cac369139d7f819971"", ""patch"": ""@@ -2096,8 +2096,8 @@ struct napi_gro_cb {\n \t/* This is non-zero if the packet may be of the same flow. */\n \tu8\tsame_flow:1;\n \n-\t/* Used in udp_gro_receive */\n-\tu8\tudp_mark:1;\n+\t/* Used in tunnel GRO receive */\n+\tu8\tencap_mark:1;\n \n \t/* GRO checksum is valid */\n \tu8\tcsum_valid:1;""}<_**next**_>{""sha"": ""43c74cad25bc2fdb181aa9c64cd208432bdb439b"", ""filename"": ""net/core/dev.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/core/dev.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/core/dev.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/core/dev.c?ref=fac8e0f579695a3ecbc4d3cac369139d7f819971"", ""patch"": ""@@ -4438,7 +4438,7 @@ static enum gro_result dev_gro_receive(struct napi_struct *napi, struct sk_buff\n \t\tNAPI_GRO_CB(skb)->same_flow = 0;\n \t\tNAPI_GRO_CB(skb)->flush = 0;\n \t\tNAPI_GRO_CB(skb)->free = 0;\n-\t\tNAPI_GRO_CB(skb)->udp_mark = 0;\n+\t\tNAPI_GRO_CB(skb)->encap_mark = 0;\n \t\tNAPI_GRO_CB(skb)->gro_remcsum_start = 0;\n \n \t\t/* Setup for GRO checksum validation */""}<_**next**_>{""sha"": ""0fefba64ee79426b76782cef2da50e050b0cd59c"", ""filename"": ""net/ipv4/af_inet.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 1, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/ipv4/af_inet.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/ipv4/af_inet.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/af_inet.c?ref=fac8e0f579695a3ecbc4d3cac369139d7f819971"", ""patch"": ""@@ -1380,6 +1380,19 @@ static struct sk_buff **inet_gro_receive(struct sk_buff **head,\n \treturn pp;\n }\n \n+static struct sk_buff **ipip_gro_receive(struct sk_buff **head,\n+\t\t\t\t\t struct sk_buff *skb)\n+{\n+\tif (NAPI_GRO_CB(skb)->encap_mark) {\n+\t\tNAPI_GRO_CB(skb)->flush = 1;\n+\t\treturn NULL;\n+\t}\n+\n+\tNAPI_GRO_CB(skb)->encap_mark = 1;\n+\n+\treturn inet_gro_receive(head, skb);\n+}\n+\n #define SECONDS_PER_DAY\t86400\n \n /* inet_current_timestamp - Return IP network timestamp\n@@ -1682,7 +1695,7 @@ static struct packet_offload ip_packet_offload __read_mostly = {\n static const struct net_offload ipip_offload = {\n \t.callbacks = {\n \t\t.gso_segment\t= inet_gso_segment,\n-\t\t.gro_receive\t= inet_gro_receive,\n+\t\t.gro_receive\t= ipip_gro_receive,\n \t\t.gro_complete\t= ipip_gro_complete,\n \t},\n };""}<_**next**_>{""sha"": ""dd031617160ae8ac4ad1ae0441665d3a1acc8651"", ""filename"": ""net/ipv4/gre_offload.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/ipv4/gre_offload.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/ipv4/gre_offload.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/gre_offload.c?ref=fac8e0f579695a3ecbc4d3cac369139d7f819971"", ""patch"": ""@@ -126,6 +126,11 @@ static struct sk_buff **gre_gro_receive(struct sk_buff **head,\n \tstruct packet_offload *ptype;\n \t__be16 type;\n \n+\tif (NAPI_GRO_CB(skb)->encap_mark)\n+\t\tgoto out;\n+\n+\tNAPI_GRO_CB(skb)->encap_mark = 1;\n+\n \toff = skb_gro_offset(skb);\n \thlen = off + sizeof(*greh);\n \tgreh = skb_gro_header_fast(skb, off);""}<_**next**_>{""sha"": ""8007f73b8981be7e894849e4737d000da4436796"", ""filename"": ""net/ipv4/udp_offload.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/ipv4/udp_offload.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/ipv4/udp_offload.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/udp_offload.c?ref=fac8e0f579695a3ecbc4d3cac369139d7f819971"", ""patch"": ""@@ -311,14 +311,14 @@ struct sk_buff **udp_gro_receive(struct sk_buff **head, struct sk_buff *skb,\n \tunsigned int off = skb_gro_offset(skb);\n \tint flush = 1;\n \n-\tif (NAPI_GRO_CB(skb)->udp_mark ||\n+\tif (NAPI_GRO_CB(skb)->encap_mark ||\n \t    (skb->ip_summed != CHECKSUM_PARTIAL &&\n \t     NAPI_GRO_CB(skb)->csum_cnt == 0 &&\n \t     !NAPI_GRO_CB(skb)->csum_valid))\n \t\tgoto out;\n \n-\t/* mark that this skb passed once through the udp gro layer */\n-\tNAPI_GRO_CB(skb)->udp_mark = 1;\n+\t/* mark that this skb passed once through the tunnel gro layer */\n+\tNAPI_GRO_CB(skb)->encap_mark = 1;\n \n \trcu_read_lock();\n \tuo_priv = rcu_dereference(udp_offload_base);""}<_**next**_>{""sha"": ""82e9f30760283aca2f3d9468573aea607bd5bf6b"", ""filename"": ""net/ipv6/ip6_offload.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 1, ""changes"": 15, ""blob_url"": ""https://github.com/torvalds/linux/blob/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/ipv6/ip6_offload.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/fac8e0f579695a3ecbc4d3cac369139d7f819971/net/ipv6/ip6_offload.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/ip6_offload.c?ref=fac8e0f579695a3ecbc4d3cac369139d7f819971"", ""patch"": ""@@ -258,6 +258,19 @@ static struct sk_buff **ipv6_gro_receive(struct sk_buff **head,\n \treturn pp;\n }\n \n+static struct sk_buff **sit_gro_receive(struct sk_buff **head,\n+\t\t\t\t\tstruct sk_buff *skb)\n+{\n+\tif (NAPI_GRO_CB(skb)->encap_mark) {\n+\t\tNAPI_GRO_CB(skb)->flush = 1;\n+\t\treturn NULL;\n+\t}\n+\n+\tNAPI_GRO_CB(skb)->encap_mark = 1;\n+\n+\treturn ipv6_gro_receive(head, skb);\n+}\n+\n static int ipv6_gro_complete(struct sk_buff *skb, int nhoff)\n {\n \tconst struct net_offload *ops;\n@@ -302,7 +315,7 @@ static struct packet_offload ipv6_packet_offload __read_mostly = {\n static const struct net_offload sit_offload = {\n \t.callbacks = {\n \t\t.gso_segment\t= ipv6_gso_segment,\n-\t\t.gro_receive    = ipv6_gro_receive,\n+\t\t.gro_receive    = sit_gro_receive,\n \t\t.gro_complete   = sit_gro_complete,\n \t},\n };""}","struct sk_buff **udp_gro_receive(struct sk_buff **head, struct sk_buff *skb,
				 struct udphdr *uh)
{
	struct udp_offload_priv *uo_priv;
	struct sk_buff *p, **pp = NULL;
	struct udphdr *uh2;
 	unsigned int off = skb_gro_offset(skb);
 	int flush = 1;
 
	if (NAPI_GRO_CB(skb)->encap_mark ||
 	    (skb->ip_summed != CHECKSUM_PARTIAL &&
 	     NAPI_GRO_CB(skb)->csum_cnt == 0 &&
 	     !NAPI_GRO_CB(skb)->csum_valid))
 		goto out;
 
	/* mark that this skb passed once through the tunnel gro layer */
	NAPI_GRO_CB(skb)->encap_mark = 1;
 
 	rcu_read_lock();
 	uo_priv = rcu_dereference(udp_offload_base);
	for (; uo_priv != NULL; uo_priv = rcu_dereference(uo_priv->next)) {
		if (net_eq(read_pnet(&uo_priv->net), dev_net(skb->dev)) &&
		    uo_priv->offload->port == uh->dest &&
		    uo_priv->offload->callbacks.gro_receive)
			goto unflush;
	}
	goto out_unlock;

unflush:
	flush = 0;

	for (p = *head; p; p = p->next) {
		if (!NAPI_GRO_CB(p)->same_flow)
			continue;

		uh2 = (struct udphdr   *)(p->data + off);

		/* Match ports and either checksums are either both zero
		 * or nonzero.
		 */
		if ((*(u32 *)&uh->source != *(u32 *)&uh2->source) ||
		    (!uh->check ^ !uh2->check)) {
			NAPI_GRO_CB(p)->same_flow = 0;
			continue;
		}
	}

	skb_gro_pull(skb, sizeof(struct udphdr)); /* pull encapsulating udp header */
	skb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr));
	NAPI_GRO_CB(skb)->proto = uo_priv->offload->ipproto;
	pp = uo_priv->offload->callbacks.gro_receive(head, skb,
						     uo_priv->offload);

out_unlock:
	rcu_read_unlock();
out:
	NAPI_GRO_CB(skb)->flush |= flush;
	return pp;
}
","struct sk_buff **udp_gro_receive(struct sk_buff **head, struct sk_buff *skb,
				 struct udphdr *uh)
{
	struct udp_offload_priv *uo_priv;
	struct sk_buff *p, **pp = NULL;
	struct udphdr *uh2;
 	unsigned int off = skb_gro_offset(skb);
 	int flush = 1;
 
	if (NAPI_GRO_CB(skb)->udp_mark ||
 	    (skb->ip_summed != CHECKSUM_PARTIAL &&
 	     NAPI_GRO_CB(skb)->csum_cnt == 0 &&
 	     !NAPI_GRO_CB(skb)->csum_valid))
 		goto out;
 
	/* mark that this skb passed once through the udp gro layer */
	NAPI_GRO_CB(skb)->udp_mark = 1;
 
 	rcu_read_lock();
 	uo_priv = rcu_dereference(udp_offload_base);
	for (; uo_priv != NULL; uo_priv = rcu_dereference(uo_priv->next)) {
		if (net_eq(read_pnet(&uo_priv->net), dev_net(skb->dev)) &&
		    uo_priv->offload->port == uh->dest &&
		    uo_priv->offload->callbacks.gro_receive)
			goto unflush;
	}
	goto out_unlock;

unflush:
	flush = 0;

	for (p = *head; p; p = p->next) {
		if (!NAPI_GRO_CB(p)->same_flow)
			continue;

		uh2 = (struct udphdr   *)(p->data + off);

		/* Match ports and either checksums are either both zero
		 * or nonzero.
		 */
		if ((*(u32 *)&uh->source != *(u32 *)&uh2->source) ||
		    (!uh->check ^ !uh2->check)) {
			NAPI_GRO_CB(p)->same_flow = 0;
			continue;
		}
	}

	skb_gro_pull(skb, sizeof(struct udphdr)); /* pull encapsulating udp header */
	skb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr));
	NAPI_GRO_CB(skb)->proto = uo_priv->offload->ipproto;
	pp = uo_priv->offload->callbacks.gro_receive(head, skb,
						     uo_priv->offload);

out_unlock:
	rcu_read_unlock();
out:
	NAPI_GRO_CB(skb)->flush |= flush;
	return pp;
}
",C,"	if (NAPI_GRO_CB(skb)->encap_mark ||
	/* mark that this skb passed once through the tunnel gro layer */
	NAPI_GRO_CB(skb)->encap_mark = 1;
","	if (NAPI_GRO_CB(skb)->udp_mark ||
	/* mark that this skb passed once through the udp gro layer */
	NAPI_GRO_CB(skb)->udp_mark = 1;
",,"@@ -311,14 +311,14 @@ struct sk_buff **udp_gro_receive(struct sk_buff **head, struct sk_buff *skb,
 	unsigned int off = skb_gro_offset(skb);
 	int flush = 1;
 
-	if (NAPI_GRO_CB(skb)->udp_mark ||
+	if (NAPI_GRO_CB(skb)->encap_mark ||
 	    (skb->ip_summed != CHECKSUM_PARTIAL &&
 	     NAPI_GRO_CB(skb)->csum_cnt == 0 &&
 	     !NAPI_GRO_CB(skb)->csum_valid))
 		goto out;
 
-	/* mark that this skb passed once through the udp gro layer */
-	NAPI_GRO_CB(skb)->udp_mark = 1;
+	/* mark that this skb passed once through the tunnel gro layer */
+	NAPI_GRO_CB(skb)->encap_mark = 1;
 
 	rcu_read_lock();
 	uo_priv = rcu_dereference(udp_offload_base);",linux,fac8e0f579695a3ecbc4d3cac369139d7f819971,b8cba75bdf6a48ea4811bbefb11a94a5c7281b68,1,"struct sk_buff **udp_gro_receive(struct sk_buff **head, struct sk_buff *skb,
				 struct udphdr *uh)
{
	struct udp_offload_priv *uo_priv;
	struct sk_buff *p, **pp = NULL;
	struct udphdr *uh2;
 	unsigned int off = skb_gro_offset(skb);
 	int flush = 1;
 
//flaw_line_below:
	if (NAPI_GRO_CB(skb)->udp_mark ||
//fix_flaw_line_below:
//	if (NAPI_GRO_CB(skb)->encap_mark ||
 	    (skb->ip_summed != CHECKSUM_PARTIAL &&
 	     NAPI_GRO_CB(skb)->csum_cnt == 0 &&
 	     !NAPI_GRO_CB(skb)->csum_valid))
 		goto out;
 
//flaw_line_below:
	/* mark that this skb passed once through the udp gro layer */
//flaw_line_below:
	NAPI_GRO_CB(skb)->udp_mark = 1;
//fix_flaw_line_below:
//	/* mark that this skb passed once through the tunnel gro layer */
//fix_flaw_line_below:
//	NAPI_GRO_CB(skb)->encap_mark = 1;
 
 	rcu_read_lock();
 	uo_priv = rcu_dereference(udp_offload_base);
	for (; uo_priv != NULL; uo_priv = rcu_dereference(uo_priv->next)) {
		if (net_eq(read_pnet(&uo_priv->net), dev_net(skb->dev)) &&
		    uo_priv->offload->port == uh->dest &&
		    uo_priv->offload->callbacks.gro_receive)
			goto unflush;
	}
	goto out_unlock;

unflush:
	flush = 0;

	for (p = *head; p; p = p->next) {
		if (!NAPI_GRO_CB(p)->same_flow)
			continue;

		uh2 = (struct udphdr   *)(p->data + off);

		/* Match ports and either checksums are either both zero
		 * or nonzero.
		 */
		if ((*(u32 *)&uh->source != *(u32 *)&uh2->source) ||
		    (!uh->check ^ !uh2->check)) {
			NAPI_GRO_CB(p)->same_flow = 0;
			continue;
		}
	}

	skb_gro_pull(skb, sizeof(struct udphdr)); /* pull encapsulating udp header */
	skb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr));
	NAPI_GRO_CB(skb)->proto = uo_priv->offload->ipproto;
	pp = uo_priv->offload->callbacks.gro_receive(head, skb,
						     uo_priv->offload);

out_unlock:
	rcu_read_unlock();
out:
	NAPI_GRO_CB(skb)->flush |= flush;
	return pp;
}
"
2442,180178,,Local,Not required,Complete,CVE-2016-6213,https://www.cvedetails.com/cve/CVE-2016-6213/,CWE-400,Medium,,,,2016-12-28,4.7,"fs/namespace.c in the Linux kernel before 4.9 does not restrict how many mounts may exist in a mount namespace, which allows local users to cause a denial of service (memory consumption and deadlock) via MS_BIND mount system calls, as demonstrated by a loop that triggers exponential growth in the number of mounts.",2018-01-04,DoS ,2,https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498,d29216842a85c7970c536108e093963f02714498,"mnt: Add a per mount namespace limit on the number of mounts

CAI Qian <caiqian@redhat.com> pointed out that the semantics
of shared subtrees make it possible to create an exponentially
increasing number of mounts in a mount namespace.

    mkdir /tmp/1 /tmp/2
    mount --make-rshared /
    for i in $(seq 1 20) ; do mount --bind /tmp/1 /tmp/2 ; done

Will create create 2^20 or 1048576 mounts, which is a practical problem
as some people have managed to hit this by accident.

As such CVE-2016-6213 was assigned.

Ian Kent <raven@themaw.net> described the situation for autofs users
as follows:

> The number of mounts for direct mount maps is usually not very large because of
> the way they are implemented, large direct mount maps can have performance
> problems. There can be anywhere from a few (likely case a few hundred) to less
> than 10000, plus mounts that have been triggered and not yet expired.
>
> Indirect mounts have one autofs mount at the root plus the number of mounts that
> have been triggered and not yet expired.
>
> The number of autofs indirect map entries can range from a few to the common
> case of several thousand and in rare cases up to between 30000 and 50000. I've
> not heard of people with maps larger than 50000 entries.
>
> The larger the number of map entries the greater the possibility for a large
> number of active mounts so it's not hard to expect cases of a 1000 or somewhat
> more active mounts.

So I am setting the default number of mounts allowed per mount
namespace at 100,000.  This is more than enough for any use case I
know of, but small enough to quickly stop an exponential increase
in mounts.  Which should be perfect to catch misconfigurations and
malfunctioning programs.

For anyone who needs a higher limit this can be changed by writing
to the new /proc/sys/fs/mount-max sysctl.

Tested-by: CAI Qian <caiqian@redhat.com>
Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>",0,fs/namespace.c,"{""sha"": ""35e17f748ca78a927df127289ccd20689382aa73"", ""filename"": ""Documentation/sysctl/fs.txt"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/Documentation/sysctl/fs.txt"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/Documentation/sysctl/fs.txt"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/Documentation/sysctl/fs.txt?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -265,6 +265,13 @@ aio-nr can grow to.\n \n ==============================================================\n \n+mount-max:\n+\n+This denotes the maximum number of mounts that may exist\n+in a mount namespace.\n+\n+==============================================================\n+\n \n 2. /proc/sys/fs/binfmt_misc\n ----------------------------------------------------------""}<_**next**_>{""sha"": ""d2e25d7b64b3073c28f37a339b31ac75d275c6f4"", ""filename"": ""fs/mount.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/mount.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/mount.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/mount.h?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -14,6 +14,8 @@ struct mnt_namespace {\n \tu64\t\t\tseq;\t/* Sequence number to prevent loops */\n \twait_queue_head_t poll;\n \tu64 event;\n+\tunsigned int\t\tmounts; /* # of mounts in the namespace */\n+\tunsigned int\t\tpending_mounts;\n };\n \n struct mnt_pcp {""}<_**next**_>{""sha"": ""db1b5a38864e98aa512be772765e00b13ec6c25d"", ""filename"": ""fs/namespace.c"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 1, ""changes"": 49, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/namespace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/namespace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/namespace.c?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -27,6 +27,9 @@\n #include \""pnode.h\""\n #include \""internal.h\""\n \n+/* Maximum number of mounts in a mount namespace */\n+unsigned int sysctl_mount_max __read_mostly = 100000;\n+\n static unsigned int m_hash_mask __read_mostly;\n static unsigned int m_hash_shift __read_mostly;\n static unsigned int mp_hash_mask __read_mostly;\n@@ -899,6 +902,9 @@ static void commit_tree(struct mount *mnt, struct mount *shadows)\n \n \tlist_splice(&head, n->list.prev);\n \n+\tn->mounts += n->pending_mounts;\n+\tn->pending_mounts = 0;\n+\n \tattach_shadowed(mnt, parent, shadows);\n \ttouch_mnt_namespace(n);\n }\n@@ -1419,11 +1425,16 @@ static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n \t\tpropagate_umount(&tmp_list);\n \n \twhile (!list_empty(&tmp_list)) {\n+\t\tstruct mnt_namespace *ns;\n \t\tbool disconnect;\n \t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n \t\tlist_del_init(&p->mnt_expire);\n \t\tlist_del_init(&p->mnt_list);\n-\t\t__touch_mnt_namespace(p->mnt_ns);\n+\t\tns = p->mnt_ns;\n+\t\tif (ns) {\n+\t\t\tns->mounts--;\n+\t\t\t__touch_mnt_namespace(ns);\n+\t\t}\n \t\tp->mnt_ns = NULL;\n \t\tif (how & UMOUNT_SYNC)\n \t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n@@ -1840,6 +1851,28 @@ static int invent_group_ids(struct mount *mnt, bool recurse)\n \treturn 0;\n }\n \n+int count_mounts(struct mnt_namespace *ns, struct mount *mnt)\n+{\n+\tunsigned int max = READ_ONCE(sysctl_mount_max);\n+\tunsigned int mounts = 0, old, pending, sum;\n+\tstruct mount *p;\n+\n+\tfor (p = mnt; p; p = next_mnt(p, mnt))\n+\t\tmounts++;\n+\n+\told = ns->mounts;\n+\tpending = ns->pending_mounts;\n+\tsum = old + pending;\n+\tif ((old > sum) ||\n+\t    (pending > sum) ||\n+\t    (max < sum) ||\n+\t    (mounts > (max - sum)))\n+\t\treturn -ENOSPC;\n+\n+\tns->pending_mounts = pending + mounts;\n+\treturn 0;\n+}\n+\n /*\n  *  @source_mnt : mount tree to be attached\n  *  @nd         : place the mount tree @source_mnt is attached\n@@ -1909,10 +1942,18 @@ static int attach_recursive_mnt(struct mount *source_mnt,\n \t\t\tstruct path *parent_path)\n {\n \tHLIST_HEAD(tree_list);\n+\tstruct mnt_namespace *ns = dest_mnt->mnt_ns;\n \tstruct mount *child, *p;\n \tstruct hlist_node *n;\n \tint err;\n \n+\t/* Is there space to add these mounts to the mount namespace? */\n+\tif (!parent_path) {\n+\t\terr = count_mounts(ns, source_mnt);\n+\t\tif (err)\n+\t\t\tgoto out;\n+\t}\n+\n \tif (IS_MNT_SHARED(dest_mnt)) {\n \t\terr = invent_group_ids(source_mnt, true);\n \t\tif (err)\n@@ -1949,11 +1990,13 @@ static int attach_recursive_mnt(struct mount *source_mnt,\n  out_cleanup_ids:\n \twhile (!hlist_empty(&tree_list)) {\n \t\tchild = hlist_entry(tree_list.first, struct mount, mnt_hash);\n+\t\tchild->mnt_parent->mnt_ns->pending_mounts = 0;\n \t\tumount_tree(child, UMOUNT_SYNC);\n \t}\n \tunlock_mount_hash();\n \tcleanup_group_ids(source_mnt, NULL);\n  out:\n+\tns->pending_mounts = 0;\n \treturn err;\n }\n \n@@ -2776,6 +2819,8 @@ static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)\n \tnew_ns->event = 0;\n \tnew_ns->user_ns = get_user_ns(user_ns);\n \tnew_ns->ucounts = ucounts;\n+\tnew_ns->mounts = 0;\n+\tnew_ns->pending_mounts = 0;\n \treturn new_ns;\n }\n \n@@ -2825,6 +2870,7 @@ struct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns,\n \tq = new;\n \twhile (p) {\n \t\tq->mnt_ns = new_ns;\n+\t\tnew_ns->mounts++;\n \t\tif (new_fs) {\n \t\t\tif (&p->mnt == new_fs->root.mnt) {\n \t\t\t\tnew_fs->root.mnt = mntget(&q->mnt);\n@@ -2863,6 +2909,7 @@ static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)\n \t\tstruct mount *mnt = real_mount(m);\n \t\tmnt->mnt_ns = new_ns;\n \t\tnew_ns->root = mnt;\n+\t\tnew_ns->mounts++;\n \t\tlist_add(&mnt->mnt_list, &new_ns->list);\n \t} else {\n \t\tmntput(m);""}<_**next**_>{""sha"": ""234a9ac49958ed978f67aad68d81fb75cf5717ce"", ""filename"": ""fs/pnode.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/pnode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/pnode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/pnode.c?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -259,7 +259,7 @@ static int propagate_one(struct mount *m)\n \t\tread_sequnlock_excl(&mount_lock);\n \t}\n \thlist_add_head(&child->mnt_hash, list);\n-\treturn 0;\n+\treturn count_mounts(m->mnt_ns, child);\n }\n \n /*""}<_**next**_>{""sha"": ""550f5a8b4fcf462d12d36fb6e7c646670247c317"", ""filename"": ""fs/pnode.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/pnode.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/pnode.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/pnode.h?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -52,4 +52,5 @@ void mnt_set_mountpoint(struct mount *, struct mountpoint *,\n struct mount *copy_tree(struct mount *, struct dentry *, int);\n bool is_path_reachable(struct mount *, struct dentry *,\n \t\t\t const struct path *root);\n+int count_mounts(struct mnt_namespace *ns, struct mount *mnt);\n #endif /* _LINUX_PNODE_H */""}<_**next**_>{""sha"": ""1172cce949a4c36226fea3b1c64c66d6b01c313e"", ""filename"": ""include/linux/mount.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/include/linux/mount.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/include/linux/mount.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/mount.h?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -96,4 +96,6 @@ extern void mark_mounts_for_expiry(struct list_head *mounts);\n \n extern dev_t name_to_dev_t(const char *name);\n \n+extern unsigned int sysctl_mount_max;\n+\n #endif /* _LINUX_MOUNT_H */""}<_**next**_>{""sha"": ""03f18cc15697a9138d79b146040fe786fe60f68d"", ""filename"": ""kernel/sysctl.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/kernel/sysctl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/kernel/sysctl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/sysctl.c?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -65,6 +65,7 @@\n #include <linux/sched/sysctl.h>\n #include <linux/kexec.h>\n #include <linux/bpf.h>\n+#include <linux/mount.h>\n \n #include <asm/uaccess.h>\n #include <asm/processor.h>\n@@ -1838,6 +1839,14 @@ static struct ctl_table fs_table[] = {\n \t\t.mode\t\t= 0644,\n \t\t.proc_handler\t= proc_doulongvec_minmax,\n \t},\n+\t{\n+\t\t.procname\t= \""mount-max\"",\n+\t\t.data\t\t= &sysctl_mount_max,\n+\t\t.maxlen\t\t= sizeof(unsigned int),\n+\t\t.mode\t\t= 0644,\n+\t\t.proc_handler\t= proc_dointvec_minmax,\n+\t\t.extra1\t\t= &one,\n+\t},\n \t{ }\n };\n ""}","static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)
{
	struct mnt_namespace *new_ns;
	struct ucounts *ucounts;
	int ret;

	ucounts = inc_mnt_namespaces(user_ns);
	if (!ucounts)
		return ERR_PTR(-ENOSPC);

	new_ns = kmalloc(sizeof(struct mnt_namespace), GFP_KERNEL);
	if (!new_ns) {
		dec_mnt_namespaces(ucounts);
		return ERR_PTR(-ENOMEM);
	}
	ret = ns_alloc_inum(&new_ns->ns);
	if (ret) {
		kfree(new_ns);
		dec_mnt_namespaces(ucounts);
		return ERR_PTR(ret);
	}
	new_ns->ns.ops = &mntns_operations;
	new_ns->seq = atomic64_add_return(1, &mnt_ns_seq);
	atomic_set(&new_ns->count, 1);
	new_ns->root = NULL;
	INIT_LIST_HEAD(&new_ns->list);
	init_waitqueue_head(&new_ns->poll);
 	new_ns->event = 0;
 	new_ns->user_ns = get_user_ns(user_ns);
 	new_ns->ucounts = ucounts;
	new_ns->mounts = 0;
	new_ns->pending_mounts = 0;
 	return new_ns;
 }
","static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)
{
	struct mnt_namespace *new_ns;
	struct ucounts *ucounts;
	int ret;

	ucounts = inc_mnt_namespaces(user_ns);
	if (!ucounts)
		return ERR_PTR(-ENOSPC);

	new_ns = kmalloc(sizeof(struct mnt_namespace), GFP_KERNEL);
	if (!new_ns) {
		dec_mnt_namespaces(ucounts);
		return ERR_PTR(-ENOMEM);
	}
	ret = ns_alloc_inum(&new_ns->ns);
	if (ret) {
		kfree(new_ns);
		dec_mnt_namespaces(ucounts);
		return ERR_PTR(ret);
	}
	new_ns->ns.ops = &mntns_operations;
	new_ns->seq = atomic64_add_return(1, &mnt_ns_seq);
	atomic_set(&new_ns->count, 1);
	new_ns->root = NULL;
	INIT_LIST_HEAD(&new_ns->list);
	init_waitqueue_head(&new_ns->poll);
 	new_ns->event = 0;
 	new_ns->user_ns = get_user_ns(user_ns);
 	new_ns->ucounts = ucounts;
 	return new_ns;
 }
",C,"	new_ns->mounts = 0;
	new_ns->pending_mounts = 0;
",,,"@@ -27,6 +27,9 @@
 #include ""pnode.h""
 #include ""internal.h""
 
+/* Maximum number of mounts in a mount namespace */
+unsigned int sysctl_mount_max __read_mostly = 100000;
+
 static unsigned int m_hash_mask __read_mostly;
 static unsigned int m_hash_shift __read_mostly;
 static unsigned int mp_hash_mask __read_mostly;
@@ -899,6 +902,9 @@ static void commit_tree(struct mount *mnt, struct mount *shadows)
 
 	list_splice(&head, n->list.prev);
 
+	n->mounts += n->pending_mounts;
+	n->pending_mounts = 0;
+
 	attach_shadowed(mnt, parent, shadows);
 	touch_mnt_namespace(n);
 }
@@ -1419,11 +1425,16 @@ static void umount_tree(struct mount *mnt, enum umount_tree_flags how)
 		propagate_umount(&tmp_list);
 
 	while (!list_empty(&tmp_list)) {
+		struct mnt_namespace *ns;
 		bool disconnect;
 		p = list_first_entry(&tmp_list, struct mount, mnt_list);
 		list_del_init(&p->mnt_expire);
 		list_del_init(&p->mnt_list);
-		__touch_mnt_namespace(p->mnt_ns);
+		ns = p->mnt_ns;
+		if (ns) {
+			ns->mounts--;
+			__touch_mnt_namespace(ns);
+		}
 		p->mnt_ns = NULL;
 		if (how & UMOUNT_SYNC)
 			p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;
@@ -1840,6 +1851,28 @@ static int invent_group_ids(struct mount *mnt, bool recurse)
 	return 0;
 }
 
+int count_mounts(struct mnt_namespace *ns, struct mount *mnt)
+{
+	unsigned int max = READ_ONCE(sysctl_mount_max);
+	unsigned int mounts = 0, old, pending, sum;
+	struct mount *p;
+
+	for (p = mnt; p; p = next_mnt(p, mnt))
+		mounts++;
+
+	old = ns->mounts;
+	pending = ns->pending_mounts;
+	sum = old + pending;
+	if ((old > sum) ||
+	    (pending > sum) ||
+	    (max < sum) ||
+	    (mounts > (max - sum)))
+		return -ENOSPC;
+
+	ns->pending_mounts = pending + mounts;
+	return 0;
+}
+
 /*
  *  @source_mnt : mount tree to be attached
  *  @nd         : place the mount tree @source_mnt is attached
@@ -1909,10 +1942,18 @@ static int attach_recursive_mnt(struct mount *source_mnt,
 			struct path *parent_path)
 {
 	HLIST_HEAD(tree_list);
+	struct mnt_namespace *ns = dest_mnt->mnt_ns;
 	struct mount *child, *p;
 	struct hlist_node *n;
 	int err;
 
+	/* Is there space to add these mounts to the mount namespace? */
+	if (!parent_path) {
+		err = count_mounts(ns, source_mnt);
+		if (err)
+			goto out;
+	}
+
 	if (IS_MNT_SHARED(dest_mnt)) {
 		err = invent_group_ids(source_mnt, true);
 		if (err)
@@ -1949,11 +1990,13 @@ static int attach_recursive_mnt(struct mount *source_mnt,
  out_cleanup_ids:
 	while (!hlist_empty(&tree_list)) {
 		child = hlist_entry(tree_list.first, struct mount, mnt_hash);
+		child->mnt_parent->mnt_ns->pending_mounts = 0;
 		umount_tree(child, UMOUNT_SYNC);
 	}
 	unlock_mount_hash();
 	cleanup_group_ids(source_mnt, NULL);
  out:
+	ns->pending_mounts = 0;
 	return err;
 }
 
@@ -2776,6 +2819,8 @@ static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)
 	new_ns->event = 0;
 	new_ns->user_ns = get_user_ns(user_ns);
 	new_ns->ucounts = ucounts;
+	new_ns->mounts = 0;
+	new_ns->pending_mounts = 0;
 	return new_ns;
 }
 
@@ -2825,6 +2870,7 @@ struct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns,
 	q = new;
 	while (p) {
 		q->mnt_ns = new_ns;
+		new_ns->mounts++;
 		if (new_fs) {
 			if (&p->mnt == new_fs->root.mnt) {
 				new_fs->root.mnt = mntget(&q->mnt);
@@ -2863,6 +2909,7 @@ static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)
 		struct mount *mnt = real_mount(m);
 		mnt->mnt_ns = new_ns;
 		new_ns->root = mnt;
+		new_ns->mounts++;
 		list_add(&mnt->mnt_list, &new_ns->list);
 	} else {
 		mntput(m);",linux,d29216842a85c7970c536108e093963f02714498,2ed6afdee798658fe3c33b50c4a79d1bde45f1d8,1,"static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)
{
	struct mnt_namespace *new_ns;
	struct ucounts *ucounts;
	int ret;

	ucounts = inc_mnt_namespaces(user_ns);
	if (!ucounts)
		return ERR_PTR(-ENOSPC);

	new_ns = kmalloc(sizeof(struct mnt_namespace), GFP_KERNEL);
	if (!new_ns) {
		dec_mnt_namespaces(ucounts);
		return ERR_PTR(-ENOMEM);
	}
	ret = ns_alloc_inum(&new_ns->ns);
	if (ret) {
		kfree(new_ns);
		dec_mnt_namespaces(ucounts);
		return ERR_PTR(ret);
	}
	new_ns->ns.ops = &mntns_operations;
	new_ns->seq = atomic64_add_return(1, &mnt_ns_seq);
	atomic_set(&new_ns->count, 1);
	new_ns->root = NULL;
	INIT_LIST_HEAD(&new_ns->list);
	init_waitqueue_head(&new_ns->poll);
 	new_ns->event = 0;
 	new_ns->user_ns = get_user_ns(user_ns);
 	new_ns->ucounts = ucounts;
//fix_flaw_line_below:
//	new_ns->mounts = 0;
//fix_flaw_line_below:
//	new_ns->pending_mounts = 0;
 	return new_ns;
 }
"
2443,180179,,Local,Not required,Complete,CVE-2016-6213,https://www.cvedetails.com/cve/CVE-2016-6213/,CWE-400,Medium,,,,2016-12-28,4.7,"fs/namespace.c in the Linux kernel before 4.9 does not restrict how many mounts may exist in a mount namespace, which allows local users to cause a denial of service (memory consumption and deadlock) via MS_BIND mount system calls, as demonstrated by a loop that triggers exponential growth in the number of mounts.",2018-01-04,DoS ,10,https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498,d29216842a85c7970c536108e093963f02714498,"mnt: Add a per mount namespace limit on the number of mounts

CAI Qian <caiqian@redhat.com> pointed out that the semantics
of shared subtrees make it possible to create an exponentially
increasing number of mounts in a mount namespace.

    mkdir /tmp/1 /tmp/2
    mount --make-rshared /
    for i in $(seq 1 20) ; do mount --bind /tmp/1 /tmp/2 ; done

Will create create 2^20 or 1048576 mounts, which is a practical problem
as some people have managed to hit this by accident.

As such CVE-2016-6213 was assigned.

Ian Kent <raven@themaw.net> described the situation for autofs users
as follows:

> The number of mounts for direct mount maps is usually not very large because of
> the way they are implemented, large direct mount maps can have performance
> problems. There can be anywhere from a few (likely case a few hundred) to less
> than 10000, plus mounts that have been triggered and not yet expired.
>
> Indirect mounts have one autofs mount at the root plus the number of mounts that
> have been triggered and not yet expired.
>
> The number of autofs indirect map entries can range from a few to the common
> case of several thousand and in rare cases up to between 30000 and 50000. I've
> not heard of people with maps larger than 50000 entries.
>
> The larger the number of map entries the greater the possibility for a large
> number of active mounts so it's not hard to expect cases of a 1000 or somewhat
> more active mounts.

So I am setting the default number of mounts allowed per mount
namespace at 100,000.  This is more than enough for any use case I
know of, but small enough to quickly stop an exponential increase
in mounts.  Which should be perfect to catch misconfigurations and
malfunctioning programs.

For anyone who needs a higher limit this can be changed by writing
to the new /proc/sys/fs/mount-max sysctl.

Tested-by: CAI Qian <caiqian@redhat.com>
Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>",0,fs/namespace.c,"{""sha"": ""35e17f748ca78a927df127289ccd20689382aa73"", ""filename"": ""Documentation/sysctl/fs.txt"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/Documentation/sysctl/fs.txt"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/Documentation/sysctl/fs.txt"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/Documentation/sysctl/fs.txt?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -265,6 +265,13 @@ aio-nr can grow to.\n \n ==============================================================\n \n+mount-max:\n+\n+This denotes the maximum number of mounts that may exist\n+in a mount namespace.\n+\n+==============================================================\n+\n \n 2. /proc/sys/fs/binfmt_misc\n ----------------------------------------------------------""}<_**next**_>{""sha"": ""d2e25d7b64b3073c28f37a339b31ac75d275c6f4"", ""filename"": ""fs/mount.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/mount.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/mount.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/mount.h?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -14,6 +14,8 @@ struct mnt_namespace {\n \tu64\t\t\tseq;\t/* Sequence number to prevent loops */\n \twait_queue_head_t poll;\n \tu64 event;\n+\tunsigned int\t\tmounts; /* # of mounts in the namespace */\n+\tunsigned int\t\tpending_mounts;\n };\n \n struct mnt_pcp {""}<_**next**_>{""sha"": ""db1b5a38864e98aa512be772765e00b13ec6c25d"", ""filename"": ""fs/namespace.c"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 1, ""changes"": 49, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/namespace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/namespace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/namespace.c?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -27,6 +27,9 @@\n #include \""pnode.h\""\n #include \""internal.h\""\n \n+/* Maximum number of mounts in a mount namespace */\n+unsigned int sysctl_mount_max __read_mostly = 100000;\n+\n static unsigned int m_hash_mask __read_mostly;\n static unsigned int m_hash_shift __read_mostly;\n static unsigned int mp_hash_mask __read_mostly;\n@@ -899,6 +902,9 @@ static void commit_tree(struct mount *mnt, struct mount *shadows)\n \n \tlist_splice(&head, n->list.prev);\n \n+\tn->mounts += n->pending_mounts;\n+\tn->pending_mounts = 0;\n+\n \tattach_shadowed(mnt, parent, shadows);\n \ttouch_mnt_namespace(n);\n }\n@@ -1419,11 +1425,16 @@ static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n \t\tpropagate_umount(&tmp_list);\n \n \twhile (!list_empty(&tmp_list)) {\n+\t\tstruct mnt_namespace *ns;\n \t\tbool disconnect;\n \t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n \t\tlist_del_init(&p->mnt_expire);\n \t\tlist_del_init(&p->mnt_list);\n-\t\t__touch_mnt_namespace(p->mnt_ns);\n+\t\tns = p->mnt_ns;\n+\t\tif (ns) {\n+\t\t\tns->mounts--;\n+\t\t\t__touch_mnt_namespace(ns);\n+\t\t}\n \t\tp->mnt_ns = NULL;\n \t\tif (how & UMOUNT_SYNC)\n \t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n@@ -1840,6 +1851,28 @@ static int invent_group_ids(struct mount *mnt, bool recurse)\n \treturn 0;\n }\n \n+int count_mounts(struct mnt_namespace *ns, struct mount *mnt)\n+{\n+\tunsigned int max = READ_ONCE(sysctl_mount_max);\n+\tunsigned int mounts = 0, old, pending, sum;\n+\tstruct mount *p;\n+\n+\tfor (p = mnt; p; p = next_mnt(p, mnt))\n+\t\tmounts++;\n+\n+\told = ns->mounts;\n+\tpending = ns->pending_mounts;\n+\tsum = old + pending;\n+\tif ((old > sum) ||\n+\t    (pending > sum) ||\n+\t    (max < sum) ||\n+\t    (mounts > (max - sum)))\n+\t\treturn -ENOSPC;\n+\n+\tns->pending_mounts = pending + mounts;\n+\treturn 0;\n+}\n+\n /*\n  *  @source_mnt : mount tree to be attached\n  *  @nd         : place the mount tree @source_mnt is attached\n@@ -1909,10 +1942,18 @@ static int attach_recursive_mnt(struct mount *source_mnt,\n \t\t\tstruct path *parent_path)\n {\n \tHLIST_HEAD(tree_list);\n+\tstruct mnt_namespace *ns = dest_mnt->mnt_ns;\n \tstruct mount *child, *p;\n \tstruct hlist_node *n;\n \tint err;\n \n+\t/* Is there space to add these mounts to the mount namespace? */\n+\tif (!parent_path) {\n+\t\terr = count_mounts(ns, source_mnt);\n+\t\tif (err)\n+\t\t\tgoto out;\n+\t}\n+\n \tif (IS_MNT_SHARED(dest_mnt)) {\n \t\terr = invent_group_ids(source_mnt, true);\n \t\tif (err)\n@@ -1949,11 +1990,13 @@ static int attach_recursive_mnt(struct mount *source_mnt,\n  out_cleanup_ids:\n \twhile (!hlist_empty(&tree_list)) {\n \t\tchild = hlist_entry(tree_list.first, struct mount, mnt_hash);\n+\t\tchild->mnt_parent->mnt_ns->pending_mounts = 0;\n \t\tumount_tree(child, UMOUNT_SYNC);\n \t}\n \tunlock_mount_hash();\n \tcleanup_group_ids(source_mnt, NULL);\n  out:\n+\tns->pending_mounts = 0;\n \treturn err;\n }\n \n@@ -2776,6 +2819,8 @@ static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)\n \tnew_ns->event = 0;\n \tnew_ns->user_ns = get_user_ns(user_ns);\n \tnew_ns->ucounts = ucounts;\n+\tnew_ns->mounts = 0;\n+\tnew_ns->pending_mounts = 0;\n \treturn new_ns;\n }\n \n@@ -2825,6 +2870,7 @@ struct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns,\n \tq = new;\n \twhile (p) {\n \t\tq->mnt_ns = new_ns;\n+\t\tnew_ns->mounts++;\n \t\tif (new_fs) {\n \t\t\tif (&p->mnt == new_fs->root.mnt) {\n \t\t\t\tnew_fs->root.mnt = mntget(&q->mnt);\n@@ -2863,6 +2909,7 @@ static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)\n \t\tstruct mount *mnt = real_mount(m);\n \t\tmnt->mnt_ns = new_ns;\n \t\tnew_ns->root = mnt;\n+\t\tnew_ns->mounts++;\n \t\tlist_add(&mnt->mnt_list, &new_ns->list);\n \t} else {\n \t\tmntput(m);""}<_**next**_>{""sha"": ""234a9ac49958ed978f67aad68d81fb75cf5717ce"", ""filename"": ""fs/pnode.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/pnode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/pnode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/pnode.c?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -259,7 +259,7 @@ static int propagate_one(struct mount *m)\n \t\tread_sequnlock_excl(&mount_lock);\n \t}\n \thlist_add_head(&child->mnt_hash, list);\n-\treturn 0;\n+\treturn count_mounts(m->mnt_ns, child);\n }\n \n /*""}<_**next**_>{""sha"": ""550f5a8b4fcf462d12d36fb6e7c646670247c317"", ""filename"": ""fs/pnode.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/pnode.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/pnode.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/pnode.h?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -52,4 +52,5 @@ void mnt_set_mountpoint(struct mount *, struct mountpoint *,\n struct mount *copy_tree(struct mount *, struct dentry *, int);\n bool is_path_reachable(struct mount *, struct dentry *,\n \t\t\t const struct path *root);\n+int count_mounts(struct mnt_namespace *ns, struct mount *mnt);\n #endif /* _LINUX_PNODE_H */""}<_**next**_>{""sha"": ""1172cce949a4c36226fea3b1c64c66d6b01c313e"", ""filename"": ""include/linux/mount.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/include/linux/mount.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/include/linux/mount.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/mount.h?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -96,4 +96,6 @@ extern void mark_mounts_for_expiry(struct list_head *mounts);\n \n extern dev_t name_to_dev_t(const char *name);\n \n+extern unsigned int sysctl_mount_max;\n+\n #endif /* _LINUX_MOUNT_H */""}<_**next**_>{""sha"": ""03f18cc15697a9138d79b146040fe786fe60f68d"", ""filename"": ""kernel/sysctl.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/kernel/sysctl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/kernel/sysctl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/sysctl.c?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -65,6 +65,7 @@\n #include <linux/sched/sysctl.h>\n #include <linux/kexec.h>\n #include <linux/bpf.h>\n+#include <linux/mount.h>\n \n #include <asm/uaccess.h>\n #include <asm/processor.h>\n@@ -1838,6 +1839,14 @@ static struct ctl_table fs_table[] = {\n \t\t.mode\t\t= 0644,\n \t\t.proc_handler\t= proc_doulongvec_minmax,\n \t},\n+\t{\n+\t\t.procname\t= \""mount-max\"",\n+\t\t.data\t\t= &sysctl_mount_max,\n+\t\t.maxlen\t\t= sizeof(unsigned int),\n+\t\t.mode\t\t= 0644,\n+\t\t.proc_handler\t= proc_dointvec_minmax,\n+\t\t.extra1\t\t= &one,\n+\t},\n \t{ }\n };\n ""}","static int attach_recursive_mnt(struct mount *source_mnt,
			struct mount *dest_mnt,
			struct mountpoint *dest_mp,
 			struct path *parent_path)
 {
 	HLIST_HEAD(tree_list);
	struct mnt_namespace *ns = dest_mnt->mnt_ns;
 	struct mount *child, *p;
 	struct hlist_node *n;
 	int err;
 
	/* Is there space to add these mounts to the mount namespace? */
	if (!parent_path) {
		err = count_mounts(ns, source_mnt);
		if (err)
			goto out;
	}

 	if (IS_MNT_SHARED(dest_mnt)) {
 		err = invent_group_ids(source_mnt, true);
 		if (err)
			goto out;
		err = propagate_mnt(dest_mnt, dest_mp, source_mnt, &tree_list);
		lock_mount_hash();
		if (err)
			goto out_cleanup_ids;
		for (p = source_mnt; p; p = next_mnt(p, source_mnt))
			set_mnt_shared(p);
	} else {
		lock_mount_hash();
	}
	if (parent_path) {
		detach_mnt(source_mnt, parent_path);
		attach_mnt(source_mnt, dest_mnt, dest_mp);
		touch_mnt_namespace(source_mnt->mnt_ns);
	} else {
		mnt_set_mountpoint(dest_mnt, dest_mp, source_mnt);
		commit_tree(source_mnt, NULL);
	}

	hlist_for_each_entry_safe(child, n, &tree_list, mnt_hash) {
		struct mount *q;
		hlist_del_init(&child->mnt_hash);
		q = __lookup_mnt_last(&child->mnt_parent->mnt,
				      child->mnt_mountpoint);
		commit_tree(child, q);
	}
	unlock_mount_hash();

	return 0;

  out_cleanup_ids:
 	while (!hlist_empty(&tree_list)) {
 		child = hlist_entry(tree_list.first, struct mount, mnt_hash);
		child->mnt_parent->mnt_ns->pending_mounts = 0;
 		umount_tree(child, UMOUNT_SYNC);
 	}
 	unlock_mount_hash();
 	cleanup_group_ids(source_mnt, NULL);
  out:
	ns->pending_mounts = 0;
 	return err;
 }
","static int attach_recursive_mnt(struct mount *source_mnt,
			struct mount *dest_mnt,
			struct mountpoint *dest_mp,
 			struct path *parent_path)
 {
 	HLIST_HEAD(tree_list);
 	struct mount *child, *p;
 	struct hlist_node *n;
 	int err;
 
 	if (IS_MNT_SHARED(dest_mnt)) {
 		err = invent_group_ids(source_mnt, true);
 		if (err)
			goto out;
		err = propagate_mnt(dest_mnt, dest_mp, source_mnt, &tree_list);
		lock_mount_hash();
		if (err)
			goto out_cleanup_ids;
		for (p = source_mnt; p; p = next_mnt(p, source_mnt))
			set_mnt_shared(p);
	} else {
		lock_mount_hash();
	}
	if (parent_path) {
		detach_mnt(source_mnt, parent_path);
		attach_mnt(source_mnt, dest_mnt, dest_mp);
		touch_mnt_namespace(source_mnt->mnt_ns);
	} else {
		mnt_set_mountpoint(dest_mnt, dest_mp, source_mnt);
		commit_tree(source_mnt, NULL);
	}

	hlist_for_each_entry_safe(child, n, &tree_list, mnt_hash) {
		struct mount *q;
		hlist_del_init(&child->mnt_hash);
		q = __lookup_mnt_last(&child->mnt_parent->mnt,
				      child->mnt_mountpoint);
		commit_tree(child, q);
	}
	unlock_mount_hash();

	return 0;

  out_cleanup_ids:
 	while (!hlist_empty(&tree_list)) {
 		child = hlist_entry(tree_list.first, struct mount, mnt_hash);
 		umount_tree(child, UMOUNT_SYNC);
 	}
 	unlock_mount_hash();
 	cleanup_group_ids(source_mnt, NULL);
  out:
 	return err;
 }
",C,"	struct mnt_namespace *ns = dest_mnt->mnt_ns;
	/* Is there space to add these mounts to the mount namespace? */
	if (!parent_path) {
		err = count_mounts(ns, source_mnt);
		if (err)
			goto out;
	}

		child->mnt_parent->mnt_ns->pending_mounts = 0;
	ns->pending_mounts = 0;
",,,"@@ -27,6 +27,9 @@
 #include ""pnode.h""
 #include ""internal.h""
 
+/* Maximum number of mounts in a mount namespace */
+unsigned int sysctl_mount_max __read_mostly = 100000;
+
 static unsigned int m_hash_mask __read_mostly;
 static unsigned int m_hash_shift __read_mostly;
 static unsigned int mp_hash_mask __read_mostly;
@@ -899,6 +902,9 @@ static void commit_tree(struct mount *mnt, struct mount *shadows)
 
 	list_splice(&head, n->list.prev);
 
+	n->mounts += n->pending_mounts;
+	n->pending_mounts = 0;
+
 	attach_shadowed(mnt, parent, shadows);
 	touch_mnt_namespace(n);
 }
@@ -1419,11 +1425,16 @@ static void umount_tree(struct mount *mnt, enum umount_tree_flags how)
 		propagate_umount(&tmp_list);
 
 	while (!list_empty(&tmp_list)) {
+		struct mnt_namespace *ns;
 		bool disconnect;
 		p = list_first_entry(&tmp_list, struct mount, mnt_list);
 		list_del_init(&p->mnt_expire);
 		list_del_init(&p->mnt_list);
-		__touch_mnt_namespace(p->mnt_ns);
+		ns = p->mnt_ns;
+		if (ns) {
+			ns->mounts--;
+			__touch_mnt_namespace(ns);
+		}
 		p->mnt_ns = NULL;
 		if (how & UMOUNT_SYNC)
 			p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;
@@ -1840,6 +1851,28 @@ static int invent_group_ids(struct mount *mnt, bool recurse)
 	return 0;
 }
 
+int count_mounts(struct mnt_namespace *ns, struct mount *mnt)
+{
+	unsigned int max = READ_ONCE(sysctl_mount_max);
+	unsigned int mounts = 0, old, pending, sum;
+	struct mount *p;
+
+	for (p = mnt; p; p = next_mnt(p, mnt))
+		mounts++;
+
+	old = ns->mounts;
+	pending = ns->pending_mounts;
+	sum = old + pending;
+	if ((old > sum) ||
+	    (pending > sum) ||
+	    (max < sum) ||
+	    (mounts > (max - sum)))
+		return -ENOSPC;
+
+	ns->pending_mounts = pending + mounts;
+	return 0;
+}
+
 /*
  *  @source_mnt : mount tree to be attached
  *  @nd         : place the mount tree @source_mnt is attached
@@ -1909,10 +1942,18 @@ static int attach_recursive_mnt(struct mount *source_mnt,
 			struct path *parent_path)
 {
 	HLIST_HEAD(tree_list);
+	struct mnt_namespace *ns = dest_mnt->mnt_ns;
 	struct mount *child, *p;
 	struct hlist_node *n;
 	int err;
 
+	/* Is there space to add these mounts to the mount namespace? */
+	if (!parent_path) {
+		err = count_mounts(ns, source_mnt);
+		if (err)
+			goto out;
+	}
+
 	if (IS_MNT_SHARED(dest_mnt)) {
 		err = invent_group_ids(source_mnt, true);
 		if (err)
@@ -1949,11 +1990,13 @@ static int attach_recursive_mnt(struct mount *source_mnt,
  out_cleanup_ids:
 	while (!hlist_empty(&tree_list)) {
 		child = hlist_entry(tree_list.first, struct mount, mnt_hash);
+		child->mnt_parent->mnt_ns->pending_mounts = 0;
 		umount_tree(child, UMOUNT_SYNC);
 	}
 	unlock_mount_hash();
 	cleanup_group_ids(source_mnt, NULL);
  out:
+	ns->pending_mounts = 0;
 	return err;
 }
 
@@ -2776,6 +2819,8 @@ static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)
 	new_ns->event = 0;
 	new_ns->user_ns = get_user_ns(user_ns);
 	new_ns->ucounts = ucounts;
+	new_ns->mounts = 0;
+	new_ns->pending_mounts = 0;
 	return new_ns;
 }
 
@@ -2825,6 +2870,7 @@ struct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns,
 	q = new;
 	while (p) {
 		q->mnt_ns = new_ns;
+		new_ns->mounts++;
 		if (new_fs) {
 			if (&p->mnt == new_fs->root.mnt) {
 				new_fs->root.mnt = mntget(&q->mnt);
@@ -2863,6 +2909,7 @@ static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)
 		struct mount *mnt = real_mount(m);
 		mnt->mnt_ns = new_ns;
 		new_ns->root = mnt;
+		new_ns->mounts++;
 		list_add(&mnt->mnt_list, &new_ns->list);
 	} else {
 		mntput(m);",linux,d29216842a85c7970c536108e093963f02714498,2ed6afdee798658fe3c33b50c4a79d1bde45f1d8,1,"static int attach_recursive_mnt(struct mount *source_mnt,
			struct mount *dest_mnt,
			struct mountpoint *dest_mp,
 			struct path *parent_path)
 {
 	HLIST_HEAD(tree_list);
//fix_flaw_line_below:
//	struct mnt_namespace *ns = dest_mnt->mnt_ns;
 	struct mount *child, *p;
 	struct hlist_node *n;
 	int err;
 
//fix_flaw_line_below:
//	/* Is there space to add these mounts to the mount namespace? */
//fix_flaw_line_below:
//	if (!parent_path) {
//fix_flaw_line_below:
//		err = count_mounts(ns, source_mnt);
//fix_flaw_line_below:
//		if (err)
//fix_flaw_line_below:
//			goto out;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
 	if (IS_MNT_SHARED(dest_mnt)) {
 		err = invent_group_ids(source_mnt, true);
 		if (err)
			goto out;
		err = propagate_mnt(dest_mnt, dest_mp, source_mnt, &tree_list);
		lock_mount_hash();
		if (err)
			goto out_cleanup_ids;
		for (p = source_mnt; p; p = next_mnt(p, source_mnt))
			set_mnt_shared(p);
	} else {
		lock_mount_hash();
	}
	if (parent_path) {
		detach_mnt(source_mnt, parent_path);
		attach_mnt(source_mnt, dest_mnt, dest_mp);
		touch_mnt_namespace(source_mnt->mnt_ns);
	} else {
		mnt_set_mountpoint(dest_mnt, dest_mp, source_mnt);
		commit_tree(source_mnt, NULL);
	}

	hlist_for_each_entry_safe(child, n, &tree_list, mnt_hash) {
		struct mount *q;
		hlist_del_init(&child->mnt_hash);
		q = __lookup_mnt_last(&child->mnt_parent->mnt,
				      child->mnt_mountpoint);
		commit_tree(child, q);
	}
	unlock_mount_hash();

	return 0;

  out_cleanup_ids:
 	while (!hlist_empty(&tree_list)) {
 		child = hlist_entry(tree_list.first, struct mount, mnt_hash);
//fix_flaw_line_below:
//		child->mnt_parent->mnt_ns->pending_mounts = 0;
 		umount_tree(child, UMOUNT_SYNC);
 	}
 	unlock_mount_hash();
 	cleanup_group_ids(source_mnt, NULL);
  out:
//fix_flaw_line_below:
//	ns->pending_mounts = 0;
 	return err;
 }
"
2444,180180,,Local,Not required,Complete,CVE-2016-6213,https://www.cvedetails.com/cve/CVE-2016-6213/,CWE-400,Medium,,,,2016-12-28,4.7,"fs/namespace.c in the Linux kernel before 4.9 does not restrict how many mounts may exist in a mount namespace, which allows local users to cause a denial of service (memory consumption and deadlock) via MS_BIND mount system calls, as demonstrated by a loop that triggers exponential growth in the number of mounts.",2018-01-04,DoS ,3,https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498,d29216842a85c7970c536108e093963f02714498,"mnt: Add a per mount namespace limit on the number of mounts

CAI Qian <caiqian@redhat.com> pointed out that the semantics
of shared subtrees make it possible to create an exponentially
increasing number of mounts in a mount namespace.

    mkdir /tmp/1 /tmp/2
    mount --make-rshared /
    for i in $(seq 1 20) ; do mount --bind /tmp/1 /tmp/2 ; done

Will create create 2^20 or 1048576 mounts, which is a practical problem
as some people have managed to hit this by accident.

As such CVE-2016-6213 was assigned.

Ian Kent <raven@themaw.net> described the situation for autofs users
as follows:

> The number of mounts for direct mount maps is usually not very large because of
> the way they are implemented, large direct mount maps can have performance
> problems. There can be anywhere from a few (likely case a few hundred) to less
> than 10000, plus mounts that have been triggered and not yet expired.
>
> Indirect mounts have one autofs mount at the root plus the number of mounts that
> have been triggered and not yet expired.
>
> The number of autofs indirect map entries can range from a few to the common
> case of several thousand and in rare cases up to between 30000 and 50000. I've
> not heard of people with maps larger than 50000 entries.
>
> The larger the number of map entries the greater the possibility for a large
> number of active mounts so it's not hard to expect cases of a 1000 or somewhat
> more active mounts.

So I am setting the default number of mounts allowed per mount
namespace at 100,000.  This is more than enough for any use case I
know of, but small enough to quickly stop an exponential increase
in mounts.  Which should be perfect to catch misconfigurations and
malfunctioning programs.

For anyone who needs a higher limit this can be changed by writing
to the new /proc/sys/fs/mount-max sysctl.

Tested-by: CAI Qian <caiqian@redhat.com>
Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>",0,fs/namespace.c,"{""sha"": ""35e17f748ca78a927df127289ccd20689382aa73"", ""filename"": ""Documentation/sysctl/fs.txt"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/Documentation/sysctl/fs.txt"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/Documentation/sysctl/fs.txt"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/Documentation/sysctl/fs.txt?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -265,6 +265,13 @@ aio-nr can grow to.\n \n ==============================================================\n \n+mount-max:\n+\n+This denotes the maximum number of mounts that may exist\n+in a mount namespace.\n+\n+==============================================================\n+\n \n 2. /proc/sys/fs/binfmt_misc\n ----------------------------------------------------------""}<_**next**_>{""sha"": ""d2e25d7b64b3073c28f37a339b31ac75d275c6f4"", ""filename"": ""fs/mount.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/mount.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/mount.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/mount.h?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -14,6 +14,8 @@ struct mnt_namespace {\n \tu64\t\t\tseq;\t/* Sequence number to prevent loops */\n \twait_queue_head_t poll;\n \tu64 event;\n+\tunsigned int\t\tmounts; /* # of mounts in the namespace */\n+\tunsigned int\t\tpending_mounts;\n };\n \n struct mnt_pcp {""}<_**next**_>{""sha"": ""db1b5a38864e98aa512be772765e00b13ec6c25d"", ""filename"": ""fs/namespace.c"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 1, ""changes"": 49, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/namespace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/namespace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/namespace.c?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -27,6 +27,9 @@\n #include \""pnode.h\""\n #include \""internal.h\""\n \n+/* Maximum number of mounts in a mount namespace */\n+unsigned int sysctl_mount_max __read_mostly = 100000;\n+\n static unsigned int m_hash_mask __read_mostly;\n static unsigned int m_hash_shift __read_mostly;\n static unsigned int mp_hash_mask __read_mostly;\n@@ -899,6 +902,9 @@ static void commit_tree(struct mount *mnt, struct mount *shadows)\n \n \tlist_splice(&head, n->list.prev);\n \n+\tn->mounts += n->pending_mounts;\n+\tn->pending_mounts = 0;\n+\n \tattach_shadowed(mnt, parent, shadows);\n \ttouch_mnt_namespace(n);\n }\n@@ -1419,11 +1425,16 @@ static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n \t\tpropagate_umount(&tmp_list);\n \n \twhile (!list_empty(&tmp_list)) {\n+\t\tstruct mnt_namespace *ns;\n \t\tbool disconnect;\n \t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n \t\tlist_del_init(&p->mnt_expire);\n \t\tlist_del_init(&p->mnt_list);\n-\t\t__touch_mnt_namespace(p->mnt_ns);\n+\t\tns = p->mnt_ns;\n+\t\tif (ns) {\n+\t\t\tns->mounts--;\n+\t\t\t__touch_mnt_namespace(ns);\n+\t\t}\n \t\tp->mnt_ns = NULL;\n \t\tif (how & UMOUNT_SYNC)\n \t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n@@ -1840,6 +1851,28 @@ static int invent_group_ids(struct mount *mnt, bool recurse)\n \treturn 0;\n }\n \n+int count_mounts(struct mnt_namespace *ns, struct mount *mnt)\n+{\n+\tunsigned int max = READ_ONCE(sysctl_mount_max);\n+\tunsigned int mounts = 0, old, pending, sum;\n+\tstruct mount *p;\n+\n+\tfor (p = mnt; p; p = next_mnt(p, mnt))\n+\t\tmounts++;\n+\n+\told = ns->mounts;\n+\tpending = ns->pending_mounts;\n+\tsum = old + pending;\n+\tif ((old > sum) ||\n+\t    (pending > sum) ||\n+\t    (max < sum) ||\n+\t    (mounts > (max - sum)))\n+\t\treturn -ENOSPC;\n+\n+\tns->pending_mounts = pending + mounts;\n+\treturn 0;\n+}\n+\n /*\n  *  @source_mnt : mount tree to be attached\n  *  @nd         : place the mount tree @source_mnt is attached\n@@ -1909,10 +1942,18 @@ static int attach_recursive_mnt(struct mount *source_mnt,\n \t\t\tstruct path *parent_path)\n {\n \tHLIST_HEAD(tree_list);\n+\tstruct mnt_namespace *ns = dest_mnt->mnt_ns;\n \tstruct mount *child, *p;\n \tstruct hlist_node *n;\n \tint err;\n \n+\t/* Is there space to add these mounts to the mount namespace? */\n+\tif (!parent_path) {\n+\t\terr = count_mounts(ns, source_mnt);\n+\t\tif (err)\n+\t\t\tgoto out;\n+\t}\n+\n \tif (IS_MNT_SHARED(dest_mnt)) {\n \t\terr = invent_group_ids(source_mnt, true);\n \t\tif (err)\n@@ -1949,11 +1990,13 @@ static int attach_recursive_mnt(struct mount *source_mnt,\n  out_cleanup_ids:\n \twhile (!hlist_empty(&tree_list)) {\n \t\tchild = hlist_entry(tree_list.first, struct mount, mnt_hash);\n+\t\tchild->mnt_parent->mnt_ns->pending_mounts = 0;\n \t\tumount_tree(child, UMOUNT_SYNC);\n \t}\n \tunlock_mount_hash();\n \tcleanup_group_ids(source_mnt, NULL);\n  out:\n+\tns->pending_mounts = 0;\n \treturn err;\n }\n \n@@ -2776,6 +2819,8 @@ static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)\n \tnew_ns->event = 0;\n \tnew_ns->user_ns = get_user_ns(user_ns);\n \tnew_ns->ucounts = ucounts;\n+\tnew_ns->mounts = 0;\n+\tnew_ns->pending_mounts = 0;\n \treturn new_ns;\n }\n \n@@ -2825,6 +2870,7 @@ struct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns,\n \tq = new;\n \twhile (p) {\n \t\tq->mnt_ns = new_ns;\n+\t\tnew_ns->mounts++;\n \t\tif (new_fs) {\n \t\t\tif (&p->mnt == new_fs->root.mnt) {\n \t\t\t\tnew_fs->root.mnt = mntget(&q->mnt);\n@@ -2863,6 +2909,7 @@ static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)\n \t\tstruct mount *mnt = real_mount(m);\n \t\tmnt->mnt_ns = new_ns;\n \t\tnew_ns->root = mnt;\n+\t\tnew_ns->mounts++;\n \t\tlist_add(&mnt->mnt_list, &new_ns->list);\n \t} else {\n \t\tmntput(m);""}<_**next**_>{""sha"": ""234a9ac49958ed978f67aad68d81fb75cf5717ce"", ""filename"": ""fs/pnode.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/pnode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/pnode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/pnode.c?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -259,7 +259,7 @@ static int propagate_one(struct mount *m)\n \t\tread_sequnlock_excl(&mount_lock);\n \t}\n \thlist_add_head(&child->mnt_hash, list);\n-\treturn 0;\n+\treturn count_mounts(m->mnt_ns, child);\n }\n \n /*""}<_**next**_>{""sha"": ""550f5a8b4fcf462d12d36fb6e7c646670247c317"", ""filename"": ""fs/pnode.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/pnode.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/pnode.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/pnode.h?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -52,4 +52,5 @@ void mnt_set_mountpoint(struct mount *, struct mountpoint *,\n struct mount *copy_tree(struct mount *, struct dentry *, int);\n bool is_path_reachable(struct mount *, struct dentry *,\n \t\t\t const struct path *root);\n+int count_mounts(struct mnt_namespace *ns, struct mount *mnt);\n #endif /* _LINUX_PNODE_H */""}<_**next**_>{""sha"": ""1172cce949a4c36226fea3b1c64c66d6b01c313e"", ""filename"": ""include/linux/mount.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/include/linux/mount.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/include/linux/mount.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/mount.h?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -96,4 +96,6 @@ extern void mark_mounts_for_expiry(struct list_head *mounts);\n \n extern dev_t name_to_dev_t(const char *name);\n \n+extern unsigned int sysctl_mount_max;\n+\n #endif /* _LINUX_MOUNT_H */""}<_**next**_>{""sha"": ""03f18cc15697a9138d79b146040fe786fe60f68d"", ""filename"": ""kernel/sysctl.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/kernel/sysctl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/kernel/sysctl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/sysctl.c?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -65,6 +65,7 @@\n #include <linux/sched/sysctl.h>\n #include <linux/kexec.h>\n #include <linux/bpf.h>\n+#include <linux/mount.h>\n \n #include <asm/uaccess.h>\n #include <asm/processor.h>\n@@ -1838,6 +1839,14 @@ static struct ctl_table fs_table[] = {\n \t\t.mode\t\t= 0644,\n \t\t.proc_handler\t= proc_doulongvec_minmax,\n \t},\n+\t{\n+\t\t.procname\t= \""mount-max\"",\n+\t\t.data\t\t= &sysctl_mount_max,\n+\t\t.maxlen\t\t= sizeof(unsigned int),\n+\t\t.mode\t\t= 0644,\n+\t\t.proc_handler\t= proc_dointvec_minmax,\n+\t\t.extra1\t\t= &one,\n+\t},\n \t{ }\n };\n ""}","static void commit_tree(struct mount *mnt, struct mount *shadows)
{
	struct mount *parent = mnt->mnt_parent;
	struct mount *m;
	LIST_HEAD(head);
	struct mnt_namespace *n = parent->mnt_ns;

	BUG_ON(parent == mnt);

	list_add_tail(&head, &mnt->mnt_list);
	list_for_each_entry(m, &head, mnt_list)
		m->mnt_ns = n;
 
 	list_splice(&head, n->list.prev);
 
	n->mounts += n->pending_mounts;
	n->pending_mounts = 0;

 	attach_shadowed(mnt, parent, shadows);
 	touch_mnt_namespace(n);
 }
","static void commit_tree(struct mount *mnt, struct mount *shadows)
{
	struct mount *parent = mnt->mnt_parent;
	struct mount *m;
	LIST_HEAD(head);
	struct mnt_namespace *n = parent->mnt_ns;

	BUG_ON(parent == mnt);

	list_add_tail(&head, &mnt->mnt_list);
	list_for_each_entry(m, &head, mnt_list)
		m->mnt_ns = n;
 
 	list_splice(&head, n->list.prev);
 
 	attach_shadowed(mnt, parent, shadows);
 	touch_mnt_namespace(n);
 }
",C,"	n->mounts += n->pending_mounts;
	n->pending_mounts = 0;

",,,"@@ -27,6 +27,9 @@
 #include ""pnode.h""
 #include ""internal.h""
 
+/* Maximum number of mounts in a mount namespace */
+unsigned int sysctl_mount_max __read_mostly = 100000;
+
 static unsigned int m_hash_mask __read_mostly;
 static unsigned int m_hash_shift __read_mostly;
 static unsigned int mp_hash_mask __read_mostly;
@@ -899,6 +902,9 @@ static void commit_tree(struct mount *mnt, struct mount *shadows)
 
 	list_splice(&head, n->list.prev);
 
+	n->mounts += n->pending_mounts;
+	n->pending_mounts = 0;
+
 	attach_shadowed(mnt, parent, shadows);
 	touch_mnt_namespace(n);
 }
@@ -1419,11 +1425,16 @@ static void umount_tree(struct mount *mnt, enum umount_tree_flags how)
 		propagate_umount(&tmp_list);
 
 	while (!list_empty(&tmp_list)) {
+		struct mnt_namespace *ns;
 		bool disconnect;
 		p = list_first_entry(&tmp_list, struct mount, mnt_list);
 		list_del_init(&p->mnt_expire);
 		list_del_init(&p->mnt_list);
-		__touch_mnt_namespace(p->mnt_ns);
+		ns = p->mnt_ns;
+		if (ns) {
+			ns->mounts--;
+			__touch_mnt_namespace(ns);
+		}
 		p->mnt_ns = NULL;
 		if (how & UMOUNT_SYNC)
 			p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;
@@ -1840,6 +1851,28 @@ static int invent_group_ids(struct mount *mnt, bool recurse)
 	return 0;
 }
 
+int count_mounts(struct mnt_namespace *ns, struct mount *mnt)
+{
+	unsigned int max = READ_ONCE(sysctl_mount_max);
+	unsigned int mounts = 0, old, pending, sum;
+	struct mount *p;
+
+	for (p = mnt; p; p = next_mnt(p, mnt))
+		mounts++;
+
+	old = ns->mounts;
+	pending = ns->pending_mounts;
+	sum = old + pending;
+	if ((old > sum) ||
+	    (pending > sum) ||
+	    (max < sum) ||
+	    (mounts > (max - sum)))
+		return -ENOSPC;
+
+	ns->pending_mounts = pending + mounts;
+	return 0;
+}
+
 /*
  *  @source_mnt : mount tree to be attached
  *  @nd         : place the mount tree @source_mnt is attached
@@ -1909,10 +1942,18 @@ static int attach_recursive_mnt(struct mount *source_mnt,
 			struct path *parent_path)
 {
 	HLIST_HEAD(tree_list);
+	struct mnt_namespace *ns = dest_mnt->mnt_ns;
 	struct mount *child, *p;
 	struct hlist_node *n;
 	int err;
 
+	/* Is there space to add these mounts to the mount namespace? */
+	if (!parent_path) {
+		err = count_mounts(ns, source_mnt);
+		if (err)
+			goto out;
+	}
+
 	if (IS_MNT_SHARED(dest_mnt)) {
 		err = invent_group_ids(source_mnt, true);
 		if (err)
@@ -1949,11 +1990,13 @@ static int attach_recursive_mnt(struct mount *source_mnt,
  out_cleanup_ids:
 	while (!hlist_empty(&tree_list)) {
 		child = hlist_entry(tree_list.first, struct mount, mnt_hash);
+		child->mnt_parent->mnt_ns->pending_mounts = 0;
 		umount_tree(child, UMOUNT_SYNC);
 	}
 	unlock_mount_hash();
 	cleanup_group_ids(source_mnt, NULL);
  out:
+	ns->pending_mounts = 0;
 	return err;
 }
 
@@ -2776,6 +2819,8 @@ static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)
 	new_ns->event = 0;
 	new_ns->user_ns = get_user_ns(user_ns);
 	new_ns->ucounts = ucounts;
+	new_ns->mounts = 0;
+	new_ns->pending_mounts = 0;
 	return new_ns;
 }
 
@@ -2825,6 +2870,7 @@ struct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns,
 	q = new;
 	while (p) {
 		q->mnt_ns = new_ns;
+		new_ns->mounts++;
 		if (new_fs) {
 			if (&p->mnt == new_fs->root.mnt) {
 				new_fs->root.mnt = mntget(&q->mnt);
@@ -2863,6 +2909,7 @@ static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)
 		struct mount *mnt = real_mount(m);
 		mnt->mnt_ns = new_ns;
 		new_ns->root = mnt;
+		new_ns->mounts++;
 		list_add(&mnt->mnt_list, &new_ns->list);
 	} else {
 		mntput(m);",linux,d29216842a85c7970c536108e093963f02714498,2ed6afdee798658fe3c33b50c4a79d1bde45f1d8,1,"static void commit_tree(struct mount *mnt, struct mount *shadows)
{
	struct mount *parent = mnt->mnt_parent;
	struct mount *m;
	LIST_HEAD(head);
	struct mnt_namespace *n = parent->mnt_ns;

	BUG_ON(parent == mnt);

	list_add_tail(&head, &mnt->mnt_list);
	list_for_each_entry(m, &head, mnt_list)
		m->mnt_ns = n;
 
 	list_splice(&head, n->list.prev);
 
//fix_flaw_line_below:
//	n->mounts += n->pending_mounts;
//fix_flaw_line_below:
//	n->pending_mounts = 0;
//fix_flaw_line_below:
//
 	attach_shadowed(mnt, parent, shadows);
 	touch_mnt_namespace(n);
 }
"
2445,180181,,Local,Not required,Complete,CVE-2016-6213,https://www.cvedetails.com/cve/CVE-2016-6213/,CWE-400,Medium,,,,2016-12-28,4.7,"fs/namespace.c in the Linux kernel before 4.9 does not restrict how many mounts may exist in a mount namespace, which allows local users to cause a denial of service (memory consumption and deadlock) via MS_BIND mount system calls, as demonstrated by a loop that triggers exponential growth in the number of mounts.",2018-01-04,DoS ,1,https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498,d29216842a85c7970c536108e093963f02714498,"mnt: Add a per mount namespace limit on the number of mounts

CAI Qian <caiqian@redhat.com> pointed out that the semantics
of shared subtrees make it possible to create an exponentially
increasing number of mounts in a mount namespace.

    mkdir /tmp/1 /tmp/2
    mount --make-rshared /
    for i in $(seq 1 20) ; do mount --bind /tmp/1 /tmp/2 ; done

Will create create 2^20 or 1048576 mounts, which is a practical problem
as some people have managed to hit this by accident.

As such CVE-2016-6213 was assigned.

Ian Kent <raven@themaw.net> described the situation for autofs users
as follows:

> The number of mounts for direct mount maps is usually not very large because of
> the way they are implemented, large direct mount maps can have performance
> problems. There can be anywhere from a few (likely case a few hundred) to less
> than 10000, plus mounts that have been triggered and not yet expired.
>
> Indirect mounts have one autofs mount at the root plus the number of mounts that
> have been triggered and not yet expired.
>
> The number of autofs indirect map entries can range from a few to the common
> case of several thousand and in rare cases up to between 30000 and 50000. I've
> not heard of people with maps larger than 50000 entries.
>
> The larger the number of map entries the greater the possibility for a large
> number of active mounts so it's not hard to expect cases of a 1000 or somewhat
> more active mounts.

So I am setting the default number of mounts allowed per mount
namespace at 100,000.  This is more than enough for any use case I
know of, but small enough to quickly stop an exponential increase
in mounts.  Which should be perfect to catch misconfigurations and
malfunctioning programs.

For anyone who needs a higher limit this can be changed by writing
to the new /proc/sys/fs/mount-max sysctl.

Tested-by: CAI Qian <caiqian@redhat.com>
Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>",0,fs/namespace.c,"{""sha"": ""35e17f748ca78a927df127289ccd20689382aa73"", ""filename"": ""Documentation/sysctl/fs.txt"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/Documentation/sysctl/fs.txt"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/Documentation/sysctl/fs.txt"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/Documentation/sysctl/fs.txt?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -265,6 +265,13 @@ aio-nr can grow to.\n \n ==============================================================\n \n+mount-max:\n+\n+This denotes the maximum number of mounts that may exist\n+in a mount namespace.\n+\n+==============================================================\n+\n \n 2. /proc/sys/fs/binfmt_misc\n ----------------------------------------------------------""}<_**next**_>{""sha"": ""d2e25d7b64b3073c28f37a339b31ac75d275c6f4"", ""filename"": ""fs/mount.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/mount.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/mount.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/mount.h?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -14,6 +14,8 @@ struct mnt_namespace {\n \tu64\t\t\tseq;\t/* Sequence number to prevent loops */\n \twait_queue_head_t poll;\n \tu64 event;\n+\tunsigned int\t\tmounts; /* # of mounts in the namespace */\n+\tunsigned int\t\tpending_mounts;\n };\n \n struct mnt_pcp {""}<_**next**_>{""sha"": ""db1b5a38864e98aa512be772765e00b13ec6c25d"", ""filename"": ""fs/namespace.c"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 1, ""changes"": 49, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/namespace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/namespace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/namespace.c?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -27,6 +27,9 @@\n #include \""pnode.h\""\n #include \""internal.h\""\n \n+/* Maximum number of mounts in a mount namespace */\n+unsigned int sysctl_mount_max __read_mostly = 100000;\n+\n static unsigned int m_hash_mask __read_mostly;\n static unsigned int m_hash_shift __read_mostly;\n static unsigned int mp_hash_mask __read_mostly;\n@@ -899,6 +902,9 @@ static void commit_tree(struct mount *mnt, struct mount *shadows)\n \n \tlist_splice(&head, n->list.prev);\n \n+\tn->mounts += n->pending_mounts;\n+\tn->pending_mounts = 0;\n+\n \tattach_shadowed(mnt, parent, shadows);\n \ttouch_mnt_namespace(n);\n }\n@@ -1419,11 +1425,16 @@ static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n \t\tpropagate_umount(&tmp_list);\n \n \twhile (!list_empty(&tmp_list)) {\n+\t\tstruct mnt_namespace *ns;\n \t\tbool disconnect;\n \t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n \t\tlist_del_init(&p->mnt_expire);\n \t\tlist_del_init(&p->mnt_list);\n-\t\t__touch_mnt_namespace(p->mnt_ns);\n+\t\tns = p->mnt_ns;\n+\t\tif (ns) {\n+\t\t\tns->mounts--;\n+\t\t\t__touch_mnt_namespace(ns);\n+\t\t}\n \t\tp->mnt_ns = NULL;\n \t\tif (how & UMOUNT_SYNC)\n \t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n@@ -1840,6 +1851,28 @@ static int invent_group_ids(struct mount *mnt, bool recurse)\n \treturn 0;\n }\n \n+int count_mounts(struct mnt_namespace *ns, struct mount *mnt)\n+{\n+\tunsigned int max = READ_ONCE(sysctl_mount_max);\n+\tunsigned int mounts = 0, old, pending, sum;\n+\tstruct mount *p;\n+\n+\tfor (p = mnt; p; p = next_mnt(p, mnt))\n+\t\tmounts++;\n+\n+\told = ns->mounts;\n+\tpending = ns->pending_mounts;\n+\tsum = old + pending;\n+\tif ((old > sum) ||\n+\t    (pending > sum) ||\n+\t    (max < sum) ||\n+\t    (mounts > (max - sum)))\n+\t\treturn -ENOSPC;\n+\n+\tns->pending_mounts = pending + mounts;\n+\treturn 0;\n+}\n+\n /*\n  *  @source_mnt : mount tree to be attached\n  *  @nd         : place the mount tree @source_mnt is attached\n@@ -1909,10 +1942,18 @@ static int attach_recursive_mnt(struct mount *source_mnt,\n \t\t\tstruct path *parent_path)\n {\n \tHLIST_HEAD(tree_list);\n+\tstruct mnt_namespace *ns = dest_mnt->mnt_ns;\n \tstruct mount *child, *p;\n \tstruct hlist_node *n;\n \tint err;\n \n+\t/* Is there space to add these mounts to the mount namespace? */\n+\tif (!parent_path) {\n+\t\terr = count_mounts(ns, source_mnt);\n+\t\tif (err)\n+\t\t\tgoto out;\n+\t}\n+\n \tif (IS_MNT_SHARED(dest_mnt)) {\n \t\terr = invent_group_ids(source_mnt, true);\n \t\tif (err)\n@@ -1949,11 +1990,13 @@ static int attach_recursive_mnt(struct mount *source_mnt,\n  out_cleanup_ids:\n \twhile (!hlist_empty(&tree_list)) {\n \t\tchild = hlist_entry(tree_list.first, struct mount, mnt_hash);\n+\t\tchild->mnt_parent->mnt_ns->pending_mounts = 0;\n \t\tumount_tree(child, UMOUNT_SYNC);\n \t}\n \tunlock_mount_hash();\n \tcleanup_group_ids(source_mnt, NULL);\n  out:\n+\tns->pending_mounts = 0;\n \treturn err;\n }\n \n@@ -2776,6 +2819,8 @@ static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)\n \tnew_ns->event = 0;\n \tnew_ns->user_ns = get_user_ns(user_ns);\n \tnew_ns->ucounts = ucounts;\n+\tnew_ns->mounts = 0;\n+\tnew_ns->pending_mounts = 0;\n \treturn new_ns;\n }\n \n@@ -2825,6 +2870,7 @@ struct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns,\n \tq = new;\n \twhile (p) {\n \t\tq->mnt_ns = new_ns;\n+\t\tnew_ns->mounts++;\n \t\tif (new_fs) {\n \t\t\tif (&p->mnt == new_fs->root.mnt) {\n \t\t\t\tnew_fs->root.mnt = mntget(&q->mnt);\n@@ -2863,6 +2909,7 @@ static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)\n \t\tstruct mount *mnt = real_mount(m);\n \t\tmnt->mnt_ns = new_ns;\n \t\tnew_ns->root = mnt;\n+\t\tnew_ns->mounts++;\n \t\tlist_add(&mnt->mnt_list, &new_ns->list);\n \t} else {\n \t\tmntput(m);""}<_**next**_>{""sha"": ""234a9ac49958ed978f67aad68d81fb75cf5717ce"", ""filename"": ""fs/pnode.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/pnode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/pnode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/pnode.c?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -259,7 +259,7 @@ static int propagate_one(struct mount *m)\n \t\tread_sequnlock_excl(&mount_lock);\n \t}\n \thlist_add_head(&child->mnt_hash, list);\n-\treturn 0;\n+\treturn count_mounts(m->mnt_ns, child);\n }\n \n /*""}<_**next**_>{""sha"": ""550f5a8b4fcf462d12d36fb6e7c646670247c317"", ""filename"": ""fs/pnode.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/pnode.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/pnode.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/pnode.h?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -52,4 +52,5 @@ void mnt_set_mountpoint(struct mount *, struct mountpoint *,\n struct mount *copy_tree(struct mount *, struct dentry *, int);\n bool is_path_reachable(struct mount *, struct dentry *,\n \t\t\t const struct path *root);\n+int count_mounts(struct mnt_namespace *ns, struct mount *mnt);\n #endif /* _LINUX_PNODE_H */""}<_**next**_>{""sha"": ""1172cce949a4c36226fea3b1c64c66d6b01c313e"", ""filename"": ""include/linux/mount.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/include/linux/mount.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/include/linux/mount.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/mount.h?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -96,4 +96,6 @@ extern void mark_mounts_for_expiry(struct list_head *mounts);\n \n extern dev_t name_to_dev_t(const char *name);\n \n+extern unsigned int sysctl_mount_max;\n+\n #endif /* _LINUX_MOUNT_H */""}<_**next**_>{""sha"": ""03f18cc15697a9138d79b146040fe786fe60f68d"", ""filename"": ""kernel/sysctl.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/kernel/sysctl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/kernel/sysctl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/sysctl.c?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -65,6 +65,7 @@\n #include <linux/sched/sysctl.h>\n #include <linux/kexec.h>\n #include <linux/bpf.h>\n+#include <linux/mount.h>\n \n #include <asm/uaccess.h>\n #include <asm/processor.h>\n@@ -1838,6 +1839,14 @@ static struct ctl_table fs_table[] = {\n \t\t.mode\t\t= 0644,\n \t\t.proc_handler\t= proc_doulongvec_minmax,\n \t},\n+\t{\n+\t\t.procname\t= \""mount-max\"",\n+\t\t.data\t\t= &sysctl_mount_max,\n+\t\t.maxlen\t\t= sizeof(unsigned int),\n+\t\t.mode\t\t= 0644,\n+\t\t.proc_handler\t= proc_dointvec_minmax,\n+\t\t.extra1\t\t= &one,\n+\t},\n \t{ }\n };\n ""}","struct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns,
		struct user_namespace *user_ns, struct fs_struct *new_fs)
{
	struct mnt_namespace *new_ns;
	struct vfsmount *rootmnt = NULL, *pwdmnt = NULL;
	struct mount *p, *q;
	struct mount *old;
	struct mount *new;
	int copy_flags;

	BUG_ON(!ns);

	if (likely(!(flags & CLONE_NEWNS))) {
		get_mnt_ns(ns);
		return ns;
	}

	old = ns->root;

	new_ns = alloc_mnt_ns(user_ns);
	if (IS_ERR(new_ns))
		return new_ns;

	namespace_lock();
	/* First pass: copy the tree topology */
	copy_flags = CL_COPY_UNBINDABLE | CL_EXPIRE;
	if (user_ns != ns->user_ns)
		copy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED;
	new = copy_tree(old, old->mnt.mnt_root, copy_flags);
	if (IS_ERR(new)) {
		namespace_unlock();
		free_mnt_ns(new_ns);
		return ERR_CAST(new);
	}
	new_ns->root = new;
	list_add_tail(&new_ns->list, &new->mnt_list);

	/*
	 * Second pass: switch the tsk->fs->* elements and mark new vfsmounts
	 * as belonging to new namespace.  We have already acquired a private
	 * fs_struct, so tsk->fs->lock is not needed.
	 */
	p = old;
 	q = new;
 	while (p) {
 		q->mnt_ns = new_ns;
		new_ns->mounts++;
 		if (new_fs) {
 			if (&p->mnt == new_fs->root.mnt) {
 				new_fs->root.mnt = mntget(&q->mnt);
				rootmnt = &p->mnt;
			}
			if (&p->mnt == new_fs->pwd.mnt) {
				new_fs->pwd.mnt = mntget(&q->mnt);
				pwdmnt = &p->mnt;
			}
		}
		p = next_mnt(p, old);
		q = next_mnt(q, new);
		if (!q)
			break;
		while (p->mnt.mnt_root != q->mnt.mnt_root)
			p = next_mnt(p, old);
	}
	namespace_unlock();

	if (rootmnt)
		mntput(rootmnt);
	if (pwdmnt)
		mntput(pwdmnt);

	return new_ns;
}
","struct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns,
		struct user_namespace *user_ns, struct fs_struct *new_fs)
{
	struct mnt_namespace *new_ns;
	struct vfsmount *rootmnt = NULL, *pwdmnt = NULL;
	struct mount *p, *q;
	struct mount *old;
	struct mount *new;
	int copy_flags;

	BUG_ON(!ns);

	if (likely(!(flags & CLONE_NEWNS))) {
		get_mnt_ns(ns);
		return ns;
	}

	old = ns->root;

	new_ns = alloc_mnt_ns(user_ns);
	if (IS_ERR(new_ns))
		return new_ns;

	namespace_lock();
	/* First pass: copy the tree topology */
	copy_flags = CL_COPY_UNBINDABLE | CL_EXPIRE;
	if (user_ns != ns->user_ns)
		copy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED;
	new = copy_tree(old, old->mnt.mnt_root, copy_flags);
	if (IS_ERR(new)) {
		namespace_unlock();
		free_mnt_ns(new_ns);
		return ERR_CAST(new);
	}
	new_ns->root = new;
	list_add_tail(&new_ns->list, &new->mnt_list);

	/*
	 * Second pass: switch the tsk->fs->* elements and mark new vfsmounts
	 * as belonging to new namespace.  We have already acquired a private
	 * fs_struct, so tsk->fs->lock is not needed.
	 */
	p = old;
 	q = new;
 	while (p) {
 		q->mnt_ns = new_ns;
 		if (new_fs) {
 			if (&p->mnt == new_fs->root.mnt) {
 				new_fs->root.mnt = mntget(&q->mnt);
				rootmnt = &p->mnt;
			}
			if (&p->mnt == new_fs->pwd.mnt) {
				new_fs->pwd.mnt = mntget(&q->mnt);
				pwdmnt = &p->mnt;
			}
		}
		p = next_mnt(p, old);
		q = next_mnt(q, new);
		if (!q)
			break;
		while (p->mnt.mnt_root != q->mnt.mnt_root)
			p = next_mnt(p, old);
	}
	namespace_unlock();

	if (rootmnt)
		mntput(rootmnt);
	if (pwdmnt)
		mntput(pwdmnt);

	return new_ns;
}
",C,"		new_ns->mounts++;
",,,"@@ -27,6 +27,9 @@
 #include ""pnode.h""
 #include ""internal.h""
 
+/* Maximum number of mounts in a mount namespace */
+unsigned int sysctl_mount_max __read_mostly = 100000;
+
 static unsigned int m_hash_mask __read_mostly;
 static unsigned int m_hash_shift __read_mostly;
 static unsigned int mp_hash_mask __read_mostly;
@@ -899,6 +902,9 @@ static void commit_tree(struct mount *mnt, struct mount *shadows)
 
 	list_splice(&head, n->list.prev);
 
+	n->mounts += n->pending_mounts;
+	n->pending_mounts = 0;
+
 	attach_shadowed(mnt, parent, shadows);
 	touch_mnt_namespace(n);
 }
@@ -1419,11 +1425,16 @@ static void umount_tree(struct mount *mnt, enum umount_tree_flags how)
 		propagate_umount(&tmp_list);
 
 	while (!list_empty(&tmp_list)) {
+		struct mnt_namespace *ns;
 		bool disconnect;
 		p = list_first_entry(&tmp_list, struct mount, mnt_list);
 		list_del_init(&p->mnt_expire);
 		list_del_init(&p->mnt_list);
-		__touch_mnt_namespace(p->mnt_ns);
+		ns = p->mnt_ns;
+		if (ns) {
+			ns->mounts--;
+			__touch_mnt_namespace(ns);
+		}
 		p->mnt_ns = NULL;
 		if (how & UMOUNT_SYNC)
 			p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;
@@ -1840,6 +1851,28 @@ static int invent_group_ids(struct mount *mnt, bool recurse)
 	return 0;
 }
 
+int count_mounts(struct mnt_namespace *ns, struct mount *mnt)
+{
+	unsigned int max = READ_ONCE(sysctl_mount_max);
+	unsigned int mounts = 0, old, pending, sum;
+	struct mount *p;
+
+	for (p = mnt; p; p = next_mnt(p, mnt))
+		mounts++;
+
+	old = ns->mounts;
+	pending = ns->pending_mounts;
+	sum = old + pending;
+	if ((old > sum) ||
+	    (pending > sum) ||
+	    (max < sum) ||
+	    (mounts > (max - sum)))
+		return -ENOSPC;
+
+	ns->pending_mounts = pending + mounts;
+	return 0;
+}
+
 /*
  *  @source_mnt : mount tree to be attached
  *  @nd         : place the mount tree @source_mnt is attached
@@ -1909,10 +1942,18 @@ static int attach_recursive_mnt(struct mount *source_mnt,
 			struct path *parent_path)
 {
 	HLIST_HEAD(tree_list);
+	struct mnt_namespace *ns = dest_mnt->mnt_ns;
 	struct mount *child, *p;
 	struct hlist_node *n;
 	int err;
 
+	/* Is there space to add these mounts to the mount namespace? */
+	if (!parent_path) {
+		err = count_mounts(ns, source_mnt);
+		if (err)
+			goto out;
+	}
+
 	if (IS_MNT_SHARED(dest_mnt)) {
 		err = invent_group_ids(source_mnt, true);
 		if (err)
@@ -1949,11 +1990,13 @@ static int attach_recursive_mnt(struct mount *source_mnt,
  out_cleanup_ids:
 	while (!hlist_empty(&tree_list)) {
 		child = hlist_entry(tree_list.first, struct mount, mnt_hash);
+		child->mnt_parent->mnt_ns->pending_mounts = 0;
 		umount_tree(child, UMOUNT_SYNC);
 	}
 	unlock_mount_hash();
 	cleanup_group_ids(source_mnt, NULL);
  out:
+	ns->pending_mounts = 0;
 	return err;
 }
 
@@ -2776,6 +2819,8 @@ static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)
 	new_ns->event = 0;
 	new_ns->user_ns = get_user_ns(user_ns);
 	new_ns->ucounts = ucounts;
+	new_ns->mounts = 0;
+	new_ns->pending_mounts = 0;
 	return new_ns;
 }
 
@@ -2825,6 +2870,7 @@ struct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns,
 	q = new;
 	while (p) {
 		q->mnt_ns = new_ns;
+		new_ns->mounts++;
 		if (new_fs) {
 			if (&p->mnt == new_fs->root.mnt) {
 				new_fs->root.mnt = mntget(&q->mnt);
@@ -2863,6 +2909,7 @@ static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)
 		struct mount *mnt = real_mount(m);
 		mnt->mnt_ns = new_ns;
 		new_ns->root = mnt;
+		new_ns->mounts++;
 		list_add(&mnt->mnt_list, &new_ns->list);
 	} else {
 		mntput(m);",linux,d29216842a85c7970c536108e093963f02714498,2ed6afdee798658fe3c33b50c4a79d1bde45f1d8,1,"struct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns,
		struct user_namespace *user_ns, struct fs_struct *new_fs)
{
	struct mnt_namespace *new_ns;
	struct vfsmount *rootmnt = NULL, *pwdmnt = NULL;
	struct mount *p, *q;
	struct mount *old;
	struct mount *new;
	int copy_flags;

	BUG_ON(!ns);

	if (likely(!(flags & CLONE_NEWNS))) {
		get_mnt_ns(ns);
		return ns;
	}

	old = ns->root;

	new_ns = alloc_mnt_ns(user_ns);
	if (IS_ERR(new_ns))
		return new_ns;

	namespace_lock();
	/* First pass: copy the tree topology */
	copy_flags = CL_COPY_UNBINDABLE | CL_EXPIRE;
	if (user_ns != ns->user_ns)
		copy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED;
	new = copy_tree(old, old->mnt.mnt_root, copy_flags);
	if (IS_ERR(new)) {
		namespace_unlock();
		free_mnt_ns(new_ns);
		return ERR_CAST(new);
	}
	new_ns->root = new;
	list_add_tail(&new_ns->list, &new->mnt_list);

	/*
	 * Second pass: switch the tsk->fs->* elements and mark new vfsmounts
	 * as belonging to new namespace.  We have already acquired a private
	 * fs_struct, so tsk->fs->lock is not needed.
	 */
	p = old;
 	q = new;
 	while (p) {
 		q->mnt_ns = new_ns;
//fix_flaw_line_below:
//		new_ns->mounts++;
 		if (new_fs) {
 			if (&p->mnt == new_fs->root.mnt) {
 				new_fs->root.mnt = mntget(&q->mnt);
				rootmnt = &p->mnt;
			}
			if (&p->mnt == new_fs->pwd.mnt) {
				new_fs->pwd.mnt = mntget(&q->mnt);
				pwdmnt = &p->mnt;
			}
		}
		p = next_mnt(p, old);
		q = next_mnt(q, new);
		if (!q)
			break;
		while (p->mnt.mnt_root != q->mnt.mnt_root)
			p = next_mnt(p, old);
	}
	namespace_unlock();

	if (rootmnt)
		mntput(rootmnt);
	if (pwdmnt)
		mntput(pwdmnt);

	return new_ns;
}
"
2446,180182,,Local,Not required,Complete,CVE-2016-6213,https://www.cvedetails.com/cve/CVE-2016-6213/,CWE-400,Medium,,,,2016-12-28,4.7,"fs/namespace.c in the Linux kernel before 4.9 does not restrict how many mounts may exist in a mount namespace, which allows local users to cause a denial of service (memory consumption and deadlock) via MS_BIND mount system calls, as demonstrated by a loop that triggers exponential growth in the number of mounts.",2018-01-04,DoS ,1,https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498,d29216842a85c7970c536108e093963f02714498,"mnt: Add a per mount namespace limit on the number of mounts

CAI Qian <caiqian@redhat.com> pointed out that the semantics
of shared subtrees make it possible to create an exponentially
increasing number of mounts in a mount namespace.

    mkdir /tmp/1 /tmp/2
    mount --make-rshared /
    for i in $(seq 1 20) ; do mount --bind /tmp/1 /tmp/2 ; done

Will create create 2^20 or 1048576 mounts, which is a practical problem
as some people have managed to hit this by accident.

As such CVE-2016-6213 was assigned.

Ian Kent <raven@themaw.net> described the situation for autofs users
as follows:

> The number of mounts for direct mount maps is usually not very large because of
> the way they are implemented, large direct mount maps can have performance
> problems. There can be anywhere from a few (likely case a few hundred) to less
> than 10000, plus mounts that have been triggered and not yet expired.
>
> Indirect mounts have one autofs mount at the root plus the number of mounts that
> have been triggered and not yet expired.
>
> The number of autofs indirect map entries can range from a few to the common
> case of several thousand and in rare cases up to between 30000 and 50000. I've
> not heard of people with maps larger than 50000 entries.
>
> The larger the number of map entries the greater the possibility for a large
> number of active mounts so it's not hard to expect cases of a 1000 or somewhat
> more active mounts.

So I am setting the default number of mounts allowed per mount
namespace at 100,000.  This is more than enough for any use case I
know of, but small enough to quickly stop an exponential increase
in mounts.  Which should be perfect to catch misconfigurations and
malfunctioning programs.

For anyone who needs a higher limit this can be changed by writing
to the new /proc/sys/fs/mount-max sysctl.

Tested-by: CAI Qian <caiqian@redhat.com>
Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>",0,fs/namespace.c,"{""sha"": ""35e17f748ca78a927df127289ccd20689382aa73"", ""filename"": ""Documentation/sysctl/fs.txt"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/Documentation/sysctl/fs.txt"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/Documentation/sysctl/fs.txt"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/Documentation/sysctl/fs.txt?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -265,6 +265,13 @@ aio-nr can grow to.\n \n ==============================================================\n \n+mount-max:\n+\n+This denotes the maximum number of mounts that may exist\n+in a mount namespace.\n+\n+==============================================================\n+\n \n 2. /proc/sys/fs/binfmt_misc\n ----------------------------------------------------------""}<_**next**_>{""sha"": ""d2e25d7b64b3073c28f37a339b31ac75d275c6f4"", ""filename"": ""fs/mount.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/mount.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/mount.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/mount.h?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -14,6 +14,8 @@ struct mnt_namespace {\n \tu64\t\t\tseq;\t/* Sequence number to prevent loops */\n \twait_queue_head_t poll;\n \tu64 event;\n+\tunsigned int\t\tmounts; /* # of mounts in the namespace */\n+\tunsigned int\t\tpending_mounts;\n };\n \n struct mnt_pcp {""}<_**next**_>{""sha"": ""db1b5a38864e98aa512be772765e00b13ec6c25d"", ""filename"": ""fs/namespace.c"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 1, ""changes"": 49, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/namespace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/namespace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/namespace.c?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -27,6 +27,9 @@\n #include \""pnode.h\""\n #include \""internal.h\""\n \n+/* Maximum number of mounts in a mount namespace */\n+unsigned int sysctl_mount_max __read_mostly = 100000;\n+\n static unsigned int m_hash_mask __read_mostly;\n static unsigned int m_hash_shift __read_mostly;\n static unsigned int mp_hash_mask __read_mostly;\n@@ -899,6 +902,9 @@ static void commit_tree(struct mount *mnt, struct mount *shadows)\n \n \tlist_splice(&head, n->list.prev);\n \n+\tn->mounts += n->pending_mounts;\n+\tn->pending_mounts = 0;\n+\n \tattach_shadowed(mnt, parent, shadows);\n \ttouch_mnt_namespace(n);\n }\n@@ -1419,11 +1425,16 @@ static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n \t\tpropagate_umount(&tmp_list);\n \n \twhile (!list_empty(&tmp_list)) {\n+\t\tstruct mnt_namespace *ns;\n \t\tbool disconnect;\n \t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n \t\tlist_del_init(&p->mnt_expire);\n \t\tlist_del_init(&p->mnt_list);\n-\t\t__touch_mnt_namespace(p->mnt_ns);\n+\t\tns = p->mnt_ns;\n+\t\tif (ns) {\n+\t\t\tns->mounts--;\n+\t\t\t__touch_mnt_namespace(ns);\n+\t\t}\n \t\tp->mnt_ns = NULL;\n \t\tif (how & UMOUNT_SYNC)\n \t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n@@ -1840,6 +1851,28 @@ static int invent_group_ids(struct mount *mnt, bool recurse)\n \treturn 0;\n }\n \n+int count_mounts(struct mnt_namespace *ns, struct mount *mnt)\n+{\n+\tunsigned int max = READ_ONCE(sysctl_mount_max);\n+\tunsigned int mounts = 0, old, pending, sum;\n+\tstruct mount *p;\n+\n+\tfor (p = mnt; p; p = next_mnt(p, mnt))\n+\t\tmounts++;\n+\n+\told = ns->mounts;\n+\tpending = ns->pending_mounts;\n+\tsum = old + pending;\n+\tif ((old > sum) ||\n+\t    (pending > sum) ||\n+\t    (max < sum) ||\n+\t    (mounts > (max - sum)))\n+\t\treturn -ENOSPC;\n+\n+\tns->pending_mounts = pending + mounts;\n+\treturn 0;\n+}\n+\n /*\n  *  @source_mnt : mount tree to be attached\n  *  @nd         : place the mount tree @source_mnt is attached\n@@ -1909,10 +1942,18 @@ static int attach_recursive_mnt(struct mount *source_mnt,\n \t\t\tstruct path *parent_path)\n {\n \tHLIST_HEAD(tree_list);\n+\tstruct mnt_namespace *ns = dest_mnt->mnt_ns;\n \tstruct mount *child, *p;\n \tstruct hlist_node *n;\n \tint err;\n \n+\t/* Is there space to add these mounts to the mount namespace? */\n+\tif (!parent_path) {\n+\t\terr = count_mounts(ns, source_mnt);\n+\t\tif (err)\n+\t\t\tgoto out;\n+\t}\n+\n \tif (IS_MNT_SHARED(dest_mnt)) {\n \t\terr = invent_group_ids(source_mnt, true);\n \t\tif (err)\n@@ -1949,11 +1990,13 @@ static int attach_recursive_mnt(struct mount *source_mnt,\n  out_cleanup_ids:\n \twhile (!hlist_empty(&tree_list)) {\n \t\tchild = hlist_entry(tree_list.first, struct mount, mnt_hash);\n+\t\tchild->mnt_parent->mnt_ns->pending_mounts = 0;\n \t\tumount_tree(child, UMOUNT_SYNC);\n \t}\n \tunlock_mount_hash();\n \tcleanup_group_ids(source_mnt, NULL);\n  out:\n+\tns->pending_mounts = 0;\n \treturn err;\n }\n \n@@ -2776,6 +2819,8 @@ static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)\n \tnew_ns->event = 0;\n \tnew_ns->user_ns = get_user_ns(user_ns);\n \tnew_ns->ucounts = ucounts;\n+\tnew_ns->mounts = 0;\n+\tnew_ns->pending_mounts = 0;\n \treturn new_ns;\n }\n \n@@ -2825,6 +2870,7 @@ struct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns,\n \tq = new;\n \twhile (p) {\n \t\tq->mnt_ns = new_ns;\n+\t\tnew_ns->mounts++;\n \t\tif (new_fs) {\n \t\t\tif (&p->mnt == new_fs->root.mnt) {\n \t\t\t\tnew_fs->root.mnt = mntget(&q->mnt);\n@@ -2863,6 +2909,7 @@ static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)\n \t\tstruct mount *mnt = real_mount(m);\n \t\tmnt->mnt_ns = new_ns;\n \t\tnew_ns->root = mnt;\n+\t\tnew_ns->mounts++;\n \t\tlist_add(&mnt->mnt_list, &new_ns->list);\n \t} else {\n \t\tmntput(m);""}<_**next**_>{""sha"": ""234a9ac49958ed978f67aad68d81fb75cf5717ce"", ""filename"": ""fs/pnode.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/pnode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/pnode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/pnode.c?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -259,7 +259,7 @@ static int propagate_one(struct mount *m)\n \t\tread_sequnlock_excl(&mount_lock);\n \t}\n \thlist_add_head(&child->mnt_hash, list);\n-\treturn 0;\n+\treturn count_mounts(m->mnt_ns, child);\n }\n \n /*""}<_**next**_>{""sha"": ""550f5a8b4fcf462d12d36fb6e7c646670247c317"", ""filename"": ""fs/pnode.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/pnode.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/pnode.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/pnode.h?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -52,4 +52,5 @@ void mnt_set_mountpoint(struct mount *, struct mountpoint *,\n struct mount *copy_tree(struct mount *, struct dentry *, int);\n bool is_path_reachable(struct mount *, struct dentry *,\n \t\t\t const struct path *root);\n+int count_mounts(struct mnt_namespace *ns, struct mount *mnt);\n #endif /* _LINUX_PNODE_H */""}<_**next**_>{""sha"": ""1172cce949a4c36226fea3b1c64c66d6b01c313e"", ""filename"": ""include/linux/mount.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/include/linux/mount.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/include/linux/mount.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/mount.h?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -96,4 +96,6 @@ extern void mark_mounts_for_expiry(struct list_head *mounts);\n \n extern dev_t name_to_dev_t(const char *name);\n \n+extern unsigned int sysctl_mount_max;\n+\n #endif /* _LINUX_MOUNT_H */""}<_**next**_>{""sha"": ""03f18cc15697a9138d79b146040fe786fe60f68d"", ""filename"": ""kernel/sysctl.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/kernel/sysctl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/kernel/sysctl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/sysctl.c?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -65,6 +65,7 @@\n #include <linux/sched/sysctl.h>\n #include <linux/kexec.h>\n #include <linux/bpf.h>\n+#include <linux/mount.h>\n \n #include <asm/uaccess.h>\n #include <asm/processor.h>\n@@ -1838,6 +1839,14 @@ static struct ctl_table fs_table[] = {\n \t\t.mode\t\t= 0644,\n \t\t.proc_handler\t= proc_doulongvec_minmax,\n \t},\n+\t{\n+\t\t.procname\t= \""mount-max\"",\n+\t\t.data\t\t= &sysctl_mount_max,\n+\t\t.maxlen\t\t= sizeof(unsigned int),\n+\t\t.mode\t\t= 0644,\n+\t\t.proc_handler\t= proc_dointvec_minmax,\n+\t\t.extra1\t\t= &one,\n+\t},\n \t{ }\n };\n ""}","static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)
{
	struct mnt_namespace *new_ns = alloc_mnt_ns(&init_user_ns);
	if (!IS_ERR(new_ns)) {
 		struct mount *mnt = real_mount(m);
 		mnt->mnt_ns = new_ns;
 		new_ns->root = mnt;
		new_ns->mounts++;
 		list_add(&mnt->mnt_list, &new_ns->list);
 	} else {
 		mntput(m);
	}
	return new_ns;
}
","static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)
{
	struct mnt_namespace *new_ns = alloc_mnt_ns(&init_user_ns);
	if (!IS_ERR(new_ns)) {
 		struct mount *mnt = real_mount(m);
 		mnt->mnt_ns = new_ns;
 		new_ns->root = mnt;
 		list_add(&mnt->mnt_list, &new_ns->list);
 	} else {
 		mntput(m);
	}
	return new_ns;
}
",C,"		new_ns->mounts++;
",,,"@@ -27,6 +27,9 @@
 #include ""pnode.h""
 #include ""internal.h""
 
+/* Maximum number of mounts in a mount namespace */
+unsigned int sysctl_mount_max __read_mostly = 100000;
+
 static unsigned int m_hash_mask __read_mostly;
 static unsigned int m_hash_shift __read_mostly;
 static unsigned int mp_hash_mask __read_mostly;
@@ -899,6 +902,9 @@ static void commit_tree(struct mount *mnt, struct mount *shadows)
 
 	list_splice(&head, n->list.prev);
 
+	n->mounts += n->pending_mounts;
+	n->pending_mounts = 0;
+
 	attach_shadowed(mnt, parent, shadows);
 	touch_mnt_namespace(n);
 }
@@ -1419,11 +1425,16 @@ static void umount_tree(struct mount *mnt, enum umount_tree_flags how)
 		propagate_umount(&tmp_list);
 
 	while (!list_empty(&tmp_list)) {
+		struct mnt_namespace *ns;
 		bool disconnect;
 		p = list_first_entry(&tmp_list, struct mount, mnt_list);
 		list_del_init(&p->mnt_expire);
 		list_del_init(&p->mnt_list);
-		__touch_mnt_namespace(p->mnt_ns);
+		ns = p->mnt_ns;
+		if (ns) {
+			ns->mounts--;
+			__touch_mnt_namespace(ns);
+		}
 		p->mnt_ns = NULL;
 		if (how & UMOUNT_SYNC)
 			p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;
@@ -1840,6 +1851,28 @@ static int invent_group_ids(struct mount *mnt, bool recurse)
 	return 0;
 }
 
+int count_mounts(struct mnt_namespace *ns, struct mount *mnt)
+{
+	unsigned int max = READ_ONCE(sysctl_mount_max);
+	unsigned int mounts = 0, old, pending, sum;
+	struct mount *p;
+
+	for (p = mnt; p; p = next_mnt(p, mnt))
+		mounts++;
+
+	old = ns->mounts;
+	pending = ns->pending_mounts;
+	sum = old + pending;
+	if ((old > sum) ||
+	    (pending > sum) ||
+	    (max < sum) ||
+	    (mounts > (max - sum)))
+		return -ENOSPC;
+
+	ns->pending_mounts = pending + mounts;
+	return 0;
+}
+
 /*
  *  @source_mnt : mount tree to be attached
  *  @nd         : place the mount tree @source_mnt is attached
@@ -1909,10 +1942,18 @@ static int attach_recursive_mnt(struct mount *source_mnt,
 			struct path *parent_path)
 {
 	HLIST_HEAD(tree_list);
+	struct mnt_namespace *ns = dest_mnt->mnt_ns;
 	struct mount *child, *p;
 	struct hlist_node *n;
 	int err;
 
+	/* Is there space to add these mounts to the mount namespace? */
+	if (!parent_path) {
+		err = count_mounts(ns, source_mnt);
+		if (err)
+			goto out;
+	}
+
 	if (IS_MNT_SHARED(dest_mnt)) {
 		err = invent_group_ids(source_mnt, true);
 		if (err)
@@ -1949,11 +1990,13 @@ static int attach_recursive_mnt(struct mount *source_mnt,
  out_cleanup_ids:
 	while (!hlist_empty(&tree_list)) {
 		child = hlist_entry(tree_list.first, struct mount, mnt_hash);
+		child->mnt_parent->mnt_ns->pending_mounts = 0;
 		umount_tree(child, UMOUNT_SYNC);
 	}
 	unlock_mount_hash();
 	cleanup_group_ids(source_mnt, NULL);
  out:
+	ns->pending_mounts = 0;
 	return err;
 }
 
@@ -2776,6 +2819,8 @@ static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)
 	new_ns->event = 0;
 	new_ns->user_ns = get_user_ns(user_ns);
 	new_ns->ucounts = ucounts;
+	new_ns->mounts = 0;
+	new_ns->pending_mounts = 0;
 	return new_ns;
 }
 
@@ -2825,6 +2870,7 @@ struct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns,
 	q = new;
 	while (p) {
 		q->mnt_ns = new_ns;
+		new_ns->mounts++;
 		if (new_fs) {
 			if (&p->mnt == new_fs->root.mnt) {
 				new_fs->root.mnt = mntget(&q->mnt);
@@ -2863,6 +2909,7 @@ static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)
 		struct mount *mnt = real_mount(m);
 		mnt->mnt_ns = new_ns;
 		new_ns->root = mnt;
+		new_ns->mounts++;
 		list_add(&mnt->mnt_list, &new_ns->list);
 	} else {
 		mntput(m);",linux,d29216842a85c7970c536108e093963f02714498,2ed6afdee798658fe3c33b50c4a79d1bde45f1d8,1,"static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)
{
	struct mnt_namespace *new_ns = alloc_mnt_ns(&init_user_ns);
	if (!IS_ERR(new_ns)) {
 		struct mount *mnt = real_mount(m);
 		mnt->mnt_ns = new_ns;
 		new_ns->root = mnt;
//fix_flaw_line_below:
//		new_ns->mounts++;
 		list_add(&mnt->mnt_list, &new_ns->list);
 	} else {
 		mntput(m);
	}
	return new_ns;
}
"
2447,180183,,Local,Not required,Complete,CVE-2016-6213,https://www.cvedetails.com/cve/CVE-2016-6213/,CWE-400,Medium,,,,2016-12-28,4.7,"fs/namespace.c in the Linux kernel before 4.9 does not restrict how many mounts may exist in a mount namespace, which allows local users to cause a denial of service (memory consumption and deadlock) via MS_BIND mount system calls, as demonstrated by a loop that triggers exponential growth in the number of mounts.",2018-01-04,DoS ,6,https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498,d29216842a85c7970c536108e093963f02714498,"mnt: Add a per mount namespace limit on the number of mounts

CAI Qian <caiqian@redhat.com> pointed out that the semantics
of shared subtrees make it possible to create an exponentially
increasing number of mounts in a mount namespace.

    mkdir /tmp/1 /tmp/2
    mount --make-rshared /
    for i in $(seq 1 20) ; do mount --bind /tmp/1 /tmp/2 ; done

Will create create 2^20 or 1048576 mounts, which is a practical problem
as some people have managed to hit this by accident.

As such CVE-2016-6213 was assigned.

Ian Kent <raven@themaw.net> described the situation for autofs users
as follows:

> The number of mounts for direct mount maps is usually not very large because of
> the way they are implemented, large direct mount maps can have performance
> problems. There can be anywhere from a few (likely case a few hundred) to less
> than 10000, plus mounts that have been triggered and not yet expired.
>
> Indirect mounts have one autofs mount at the root plus the number of mounts that
> have been triggered and not yet expired.
>
> The number of autofs indirect map entries can range from a few to the common
> case of several thousand and in rare cases up to between 30000 and 50000. I've
> not heard of people with maps larger than 50000 entries.
>
> The larger the number of map entries the greater the possibility for a large
> number of active mounts so it's not hard to expect cases of a 1000 or somewhat
> more active mounts.

So I am setting the default number of mounts allowed per mount
namespace at 100,000.  This is more than enough for any use case I
know of, but small enough to quickly stop an exponential increase
in mounts.  Which should be perfect to catch misconfigurations and
malfunctioning programs.

For anyone who needs a higher limit this can be changed by writing
to the new /proc/sys/fs/mount-max sysctl.

Tested-by: CAI Qian <caiqian@redhat.com>
Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>",1,fs/namespace.c,"{""sha"": ""35e17f748ca78a927df127289ccd20689382aa73"", ""filename"": ""Documentation/sysctl/fs.txt"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/Documentation/sysctl/fs.txt"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/Documentation/sysctl/fs.txt"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/Documentation/sysctl/fs.txt?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -265,6 +265,13 @@ aio-nr can grow to.\n \n ==============================================================\n \n+mount-max:\n+\n+This denotes the maximum number of mounts that may exist\n+in a mount namespace.\n+\n+==============================================================\n+\n \n 2. /proc/sys/fs/binfmt_misc\n ----------------------------------------------------------""}<_**next**_>{""sha"": ""d2e25d7b64b3073c28f37a339b31ac75d275c6f4"", ""filename"": ""fs/mount.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/mount.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/mount.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/mount.h?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -14,6 +14,8 @@ struct mnt_namespace {\n \tu64\t\t\tseq;\t/* Sequence number to prevent loops */\n \twait_queue_head_t poll;\n \tu64 event;\n+\tunsigned int\t\tmounts; /* # of mounts in the namespace */\n+\tunsigned int\t\tpending_mounts;\n };\n \n struct mnt_pcp {""}<_**next**_>{""sha"": ""db1b5a38864e98aa512be772765e00b13ec6c25d"", ""filename"": ""fs/namespace.c"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 1, ""changes"": 49, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/namespace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/namespace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/namespace.c?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -27,6 +27,9 @@\n #include \""pnode.h\""\n #include \""internal.h\""\n \n+/* Maximum number of mounts in a mount namespace */\n+unsigned int sysctl_mount_max __read_mostly = 100000;\n+\n static unsigned int m_hash_mask __read_mostly;\n static unsigned int m_hash_shift __read_mostly;\n static unsigned int mp_hash_mask __read_mostly;\n@@ -899,6 +902,9 @@ static void commit_tree(struct mount *mnt, struct mount *shadows)\n \n \tlist_splice(&head, n->list.prev);\n \n+\tn->mounts += n->pending_mounts;\n+\tn->pending_mounts = 0;\n+\n \tattach_shadowed(mnt, parent, shadows);\n \ttouch_mnt_namespace(n);\n }\n@@ -1419,11 +1425,16 @@ static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n \t\tpropagate_umount(&tmp_list);\n \n \twhile (!list_empty(&tmp_list)) {\n+\t\tstruct mnt_namespace *ns;\n \t\tbool disconnect;\n \t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n \t\tlist_del_init(&p->mnt_expire);\n \t\tlist_del_init(&p->mnt_list);\n-\t\t__touch_mnt_namespace(p->mnt_ns);\n+\t\tns = p->mnt_ns;\n+\t\tif (ns) {\n+\t\t\tns->mounts--;\n+\t\t\t__touch_mnt_namespace(ns);\n+\t\t}\n \t\tp->mnt_ns = NULL;\n \t\tif (how & UMOUNT_SYNC)\n \t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n@@ -1840,6 +1851,28 @@ static int invent_group_ids(struct mount *mnt, bool recurse)\n \treturn 0;\n }\n \n+int count_mounts(struct mnt_namespace *ns, struct mount *mnt)\n+{\n+\tunsigned int max = READ_ONCE(sysctl_mount_max);\n+\tunsigned int mounts = 0, old, pending, sum;\n+\tstruct mount *p;\n+\n+\tfor (p = mnt; p; p = next_mnt(p, mnt))\n+\t\tmounts++;\n+\n+\told = ns->mounts;\n+\tpending = ns->pending_mounts;\n+\tsum = old + pending;\n+\tif ((old > sum) ||\n+\t    (pending > sum) ||\n+\t    (max < sum) ||\n+\t    (mounts > (max - sum)))\n+\t\treturn -ENOSPC;\n+\n+\tns->pending_mounts = pending + mounts;\n+\treturn 0;\n+}\n+\n /*\n  *  @source_mnt : mount tree to be attached\n  *  @nd         : place the mount tree @source_mnt is attached\n@@ -1909,10 +1942,18 @@ static int attach_recursive_mnt(struct mount *source_mnt,\n \t\t\tstruct path *parent_path)\n {\n \tHLIST_HEAD(tree_list);\n+\tstruct mnt_namespace *ns = dest_mnt->mnt_ns;\n \tstruct mount *child, *p;\n \tstruct hlist_node *n;\n \tint err;\n \n+\t/* Is there space to add these mounts to the mount namespace? */\n+\tif (!parent_path) {\n+\t\terr = count_mounts(ns, source_mnt);\n+\t\tif (err)\n+\t\t\tgoto out;\n+\t}\n+\n \tif (IS_MNT_SHARED(dest_mnt)) {\n \t\terr = invent_group_ids(source_mnt, true);\n \t\tif (err)\n@@ -1949,11 +1990,13 @@ static int attach_recursive_mnt(struct mount *source_mnt,\n  out_cleanup_ids:\n \twhile (!hlist_empty(&tree_list)) {\n \t\tchild = hlist_entry(tree_list.first, struct mount, mnt_hash);\n+\t\tchild->mnt_parent->mnt_ns->pending_mounts = 0;\n \t\tumount_tree(child, UMOUNT_SYNC);\n \t}\n \tunlock_mount_hash();\n \tcleanup_group_ids(source_mnt, NULL);\n  out:\n+\tns->pending_mounts = 0;\n \treturn err;\n }\n \n@@ -2776,6 +2819,8 @@ static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)\n \tnew_ns->event = 0;\n \tnew_ns->user_ns = get_user_ns(user_ns);\n \tnew_ns->ucounts = ucounts;\n+\tnew_ns->mounts = 0;\n+\tnew_ns->pending_mounts = 0;\n \treturn new_ns;\n }\n \n@@ -2825,6 +2870,7 @@ struct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns,\n \tq = new;\n \twhile (p) {\n \t\tq->mnt_ns = new_ns;\n+\t\tnew_ns->mounts++;\n \t\tif (new_fs) {\n \t\t\tif (&p->mnt == new_fs->root.mnt) {\n \t\t\t\tnew_fs->root.mnt = mntget(&q->mnt);\n@@ -2863,6 +2909,7 @@ static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)\n \t\tstruct mount *mnt = real_mount(m);\n \t\tmnt->mnt_ns = new_ns;\n \t\tnew_ns->root = mnt;\n+\t\tnew_ns->mounts++;\n \t\tlist_add(&mnt->mnt_list, &new_ns->list);\n \t} else {\n \t\tmntput(m);""}<_**next**_>{""sha"": ""234a9ac49958ed978f67aad68d81fb75cf5717ce"", ""filename"": ""fs/pnode.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/pnode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/pnode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/pnode.c?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -259,7 +259,7 @@ static int propagate_one(struct mount *m)\n \t\tread_sequnlock_excl(&mount_lock);\n \t}\n \thlist_add_head(&child->mnt_hash, list);\n-\treturn 0;\n+\treturn count_mounts(m->mnt_ns, child);\n }\n \n /*""}<_**next**_>{""sha"": ""550f5a8b4fcf462d12d36fb6e7c646670247c317"", ""filename"": ""fs/pnode.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/pnode.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/pnode.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/pnode.h?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -52,4 +52,5 @@ void mnt_set_mountpoint(struct mount *, struct mountpoint *,\n struct mount *copy_tree(struct mount *, struct dentry *, int);\n bool is_path_reachable(struct mount *, struct dentry *,\n \t\t\t const struct path *root);\n+int count_mounts(struct mnt_namespace *ns, struct mount *mnt);\n #endif /* _LINUX_PNODE_H */""}<_**next**_>{""sha"": ""1172cce949a4c36226fea3b1c64c66d6b01c313e"", ""filename"": ""include/linux/mount.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/include/linux/mount.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/include/linux/mount.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/mount.h?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -96,4 +96,6 @@ extern void mark_mounts_for_expiry(struct list_head *mounts);\n \n extern dev_t name_to_dev_t(const char *name);\n \n+extern unsigned int sysctl_mount_max;\n+\n #endif /* _LINUX_MOUNT_H */""}<_**next**_>{""sha"": ""03f18cc15697a9138d79b146040fe786fe60f68d"", ""filename"": ""kernel/sysctl.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/kernel/sysctl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/kernel/sysctl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/sysctl.c?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -65,6 +65,7 @@\n #include <linux/sched/sysctl.h>\n #include <linux/kexec.h>\n #include <linux/bpf.h>\n+#include <linux/mount.h>\n \n #include <asm/uaccess.h>\n #include <asm/processor.h>\n@@ -1838,6 +1839,14 @@ static struct ctl_table fs_table[] = {\n \t\t.mode\t\t= 0644,\n \t\t.proc_handler\t= proc_doulongvec_minmax,\n \t},\n+\t{\n+\t\t.procname\t= \""mount-max\"",\n+\t\t.data\t\t= &sysctl_mount_max,\n+\t\t.maxlen\t\t= sizeof(unsigned int),\n+\t\t.mode\t\t= 0644,\n+\t\t.proc_handler\t= proc_dointvec_minmax,\n+\t\t.extra1\t\t= &one,\n+\t},\n \t{ }\n };\n ""}","static void umount_tree(struct mount *mnt, enum umount_tree_flags how)
{
	LIST_HEAD(tmp_list);
	struct mount *p;

	if (how & UMOUNT_PROPAGATE)
		propagate_mount_unlock(mnt);

	/* Gather the mounts to umount */
	for (p = mnt; p; p = next_mnt(p, mnt)) {
		p->mnt.mnt_flags |= MNT_UMOUNT;
		list_move(&p->mnt_list, &tmp_list);
	}

	/* Hide the mounts from mnt_mounts */
	list_for_each_entry(p, &tmp_list, mnt_list) {
		list_del_init(&p->mnt_child);
	}

	/* Add propogated mounts to the tmp_list */
	if (how & UMOUNT_PROPAGATE)
 		propagate_umount(&tmp_list);
 
 	while (!list_empty(&tmp_list)) {
		struct mnt_namespace *ns;
 		bool disconnect;
 		p = list_first_entry(&tmp_list, struct mount, mnt_list);
 		list_del_init(&p->mnt_expire);
 		list_del_init(&p->mnt_list);
		ns = p->mnt_ns;
		if (ns) {
			ns->mounts--;
			__touch_mnt_namespace(ns);
		}
 		p->mnt_ns = NULL;
 		if (how & UMOUNT_SYNC)
 			p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;

		disconnect = disconnect_mount(p, how);

		pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,
				 disconnect ? &unmounted : NULL);
		if (mnt_has_parent(p)) {
			mnt_add_count(p->mnt_parent, -1);
			if (!disconnect) {
				/* Don't forget about p */
				list_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);
			} else {
				umount_mnt(p);
			}
		}
		change_mnt_propagation(p, MS_PRIVATE);
	}
}
","static void umount_tree(struct mount *mnt, enum umount_tree_flags how)
{
	LIST_HEAD(tmp_list);
	struct mount *p;

	if (how & UMOUNT_PROPAGATE)
		propagate_mount_unlock(mnt);

	/* Gather the mounts to umount */
	for (p = mnt; p; p = next_mnt(p, mnt)) {
		p->mnt.mnt_flags |= MNT_UMOUNT;
		list_move(&p->mnt_list, &tmp_list);
	}

	/* Hide the mounts from mnt_mounts */
	list_for_each_entry(p, &tmp_list, mnt_list) {
		list_del_init(&p->mnt_child);
	}

	/* Add propogated mounts to the tmp_list */
	if (how & UMOUNT_PROPAGATE)
 		propagate_umount(&tmp_list);
 
 	while (!list_empty(&tmp_list)) {
 		bool disconnect;
 		p = list_first_entry(&tmp_list, struct mount, mnt_list);
 		list_del_init(&p->mnt_expire);
 		list_del_init(&p->mnt_list);
		__touch_mnt_namespace(p->mnt_ns);
 		p->mnt_ns = NULL;
 		if (how & UMOUNT_SYNC)
 			p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;

		disconnect = disconnect_mount(p, how);

		pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,
				 disconnect ? &unmounted : NULL);
		if (mnt_has_parent(p)) {
			mnt_add_count(p->mnt_parent, -1);
			if (!disconnect) {
				/* Don't forget about p */
				list_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);
			} else {
				umount_mnt(p);
			}
		}
		change_mnt_propagation(p, MS_PRIVATE);
	}
}
",C,"		struct mnt_namespace *ns;
		ns = p->mnt_ns;
		if (ns) {
			ns->mounts--;
			__touch_mnt_namespace(ns);
		}
","		__touch_mnt_namespace(p->mnt_ns);
",,"@@ -27,6 +27,9 @@
 #include ""pnode.h""
 #include ""internal.h""
 
+/* Maximum number of mounts in a mount namespace */
+unsigned int sysctl_mount_max __read_mostly = 100000;
+
 static unsigned int m_hash_mask __read_mostly;
 static unsigned int m_hash_shift __read_mostly;
 static unsigned int mp_hash_mask __read_mostly;
@@ -899,6 +902,9 @@ static void commit_tree(struct mount *mnt, struct mount *shadows)
 
 	list_splice(&head, n->list.prev);
 
+	n->mounts += n->pending_mounts;
+	n->pending_mounts = 0;
+
 	attach_shadowed(mnt, parent, shadows);
 	touch_mnt_namespace(n);
 }
@@ -1419,11 +1425,16 @@ static void umount_tree(struct mount *mnt, enum umount_tree_flags how)
 		propagate_umount(&tmp_list);
 
 	while (!list_empty(&tmp_list)) {
+		struct mnt_namespace *ns;
 		bool disconnect;
 		p = list_first_entry(&tmp_list, struct mount, mnt_list);
 		list_del_init(&p->mnt_expire);
 		list_del_init(&p->mnt_list);
-		__touch_mnt_namespace(p->mnt_ns);
+		ns = p->mnt_ns;
+		if (ns) {
+			ns->mounts--;
+			__touch_mnt_namespace(ns);
+		}
 		p->mnt_ns = NULL;
 		if (how & UMOUNT_SYNC)
 			p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;
@@ -1840,6 +1851,28 @@ static int invent_group_ids(struct mount *mnt, bool recurse)
 	return 0;
 }
 
+int count_mounts(struct mnt_namespace *ns, struct mount *mnt)
+{
+	unsigned int max = READ_ONCE(sysctl_mount_max);
+	unsigned int mounts = 0, old, pending, sum;
+	struct mount *p;
+
+	for (p = mnt; p; p = next_mnt(p, mnt))
+		mounts++;
+
+	old = ns->mounts;
+	pending = ns->pending_mounts;
+	sum = old + pending;
+	if ((old > sum) ||
+	    (pending > sum) ||
+	    (max < sum) ||
+	    (mounts > (max - sum)))
+		return -ENOSPC;
+
+	ns->pending_mounts = pending + mounts;
+	return 0;
+}
+
 /*
  *  @source_mnt : mount tree to be attached
  *  @nd         : place the mount tree @source_mnt is attached
@@ -1909,10 +1942,18 @@ static int attach_recursive_mnt(struct mount *source_mnt,
 			struct path *parent_path)
 {
 	HLIST_HEAD(tree_list);
+	struct mnt_namespace *ns = dest_mnt->mnt_ns;
 	struct mount *child, *p;
 	struct hlist_node *n;
 	int err;
 
+	/* Is there space to add these mounts to the mount namespace? */
+	if (!parent_path) {
+		err = count_mounts(ns, source_mnt);
+		if (err)
+			goto out;
+	}
+
 	if (IS_MNT_SHARED(dest_mnt)) {
 		err = invent_group_ids(source_mnt, true);
 		if (err)
@@ -1949,11 +1990,13 @@ static int attach_recursive_mnt(struct mount *source_mnt,
  out_cleanup_ids:
 	while (!hlist_empty(&tree_list)) {
 		child = hlist_entry(tree_list.first, struct mount, mnt_hash);
+		child->mnt_parent->mnt_ns->pending_mounts = 0;
 		umount_tree(child, UMOUNT_SYNC);
 	}
 	unlock_mount_hash();
 	cleanup_group_ids(source_mnt, NULL);
  out:
+	ns->pending_mounts = 0;
 	return err;
 }
 
@@ -2776,6 +2819,8 @@ static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)
 	new_ns->event = 0;
 	new_ns->user_ns = get_user_ns(user_ns);
 	new_ns->ucounts = ucounts;
+	new_ns->mounts = 0;
+	new_ns->pending_mounts = 0;
 	return new_ns;
 }
 
@@ -2825,6 +2870,7 @@ struct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns,
 	q = new;
 	while (p) {
 		q->mnt_ns = new_ns;
+		new_ns->mounts++;
 		if (new_fs) {
 			if (&p->mnt == new_fs->root.mnt) {
 				new_fs->root.mnt = mntget(&q->mnt);
@@ -2863,6 +2909,7 @@ static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)
 		struct mount *mnt = real_mount(m);
 		mnt->mnt_ns = new_ns;
 		new_ns->root = mnt;
+		new_ns->mounts++;
 		list_add(&mnt->mnt_list, &new_ns->list);
 	} else {
 		mntput(m);",linux,d29216842a85c7970c536108e093963f02714498,2ed6afdee798658fe3c33b50c4a79d1bde45f1d8,1,"static void umount_tree(struct mount *mnt, enum umount_tree_flags how)
{
	LIST_HEAD(tmp_list);
	struct mount *p;

	if (how & UMOUNT_PROPAGATE)
		propagate_mount_unlock(mnt);

	/* Gather the mounts to umount */
	for (p = mnt; p; p = next_mnt(p, mnt)) {
		p->mnt.mnt_flags |= MNT_UMOUNT;
		list_move(&p->mnt_list, &tmp_list);
	}

	/* Hide the mounts from mnt_mounts */
	list_for_each_entry(p, &tmp_list, mnt_list) {
		list_del_init(&p->mnt_child);
	}

	/* Add propogated mounts to the tmp_list */
	if (how & UMOUNT_PROPAGATE)
 		propagate_umount(&tmp_list);
 
 	while (!list_empty(&tmp_list)) {
//fix_flaw_line_below:
//		struct mnt_namespace *ns;
 		bool disconnect;
 		p = list_first_entry(&tmp_list, struct mount, mnt_list);
 		list_del_init(&p->mnt_expire);
 		list_del_init(&p->mnt_list);
//flaw_line_below:
		__touch_mnt_namespace(p->mnt_ns);
//fix_flaw_line_below:
//		ns = p->mnt_ns;
//fix_flaw_line_below:
//		if (ns) {
//fix_flaw_line_below:
//			ns->mounts--;
//fix_flaw_line_below:
//			__touch_mnt_namespace(ns);
//fix_flaw_line_below:
//		}
 		p->mnt_ns = NULL;
 		if (how & UMOUNT_SYNC)
 			p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;

		disconnect = disconnect_mount(p, how);

		pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,
				 disconnect ? &unmounted : NULL);
		if (mnt_has_parent(p)) {
			mnt_add_count(p->mnt_parent, -1);
			if (!disconnect) {
				/* Don't forget about p */
				list_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);
			} else {
				umount_mnt(p);
			}
		}
		change_mnt_propagation(p, MS_PRIVATE);
	}
}
"
2448,180184,,Local,Not required,Complete,CVE-2016-6213,https://www.cvedetails.com/cve/CVE-2016-6213/,CWE-400,Medium,,,,2016-12-28,4.7,"fs/namespace.c in the Linux kernel before 4.9 does not restrict how many mounts may exist in a mount namespace, which allows local users to cause a denial of service (memory consumption and deadlock) via MS_BIND mount system calls, as demonstrated by a loop that triggers exponential growth in the number of mounts.",2018-01-04,DoS ,1,https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498,d29216842a85c7970c536108e093963f02714498,"mnt: Add a per mount namespace limit on the number of mounts

CAI Qian <caiqian@redhat.com> pointed out that the semantics
of shared subtrees make it possible to create an exponentially
increasing number of mounts in a mount namespace.

    mkdir /tmp/1 /tmp/2
    mount --make-rshared /
    for i in $(seq 1 20) ; do mount --bind /tmp/1 /tmp/2 ; done

Will create create 2^20 or 1048576 mounts, which is a practical problem
as some people have managed to hit this by accident.

As such CVE-2016-6213 was assigned.

Ian Kent <raven@themaw.net> described the situation for autofs users
as follows:

> The number of mounts for direct mount maps is usually not very large because of
> the way they are implemented, large direct mount maps can have performance
> problems. There can be anywhere from a few (likely case a few hundred) to less
> than 10000, plus mounts that have been triggered and not yet expired.
>
> Indirect mounts have one autofs mount at the root plus the number of mounts that
> have been triggered and not yet expired.
>
> The number of autofs indirect map entries can range from a few to the common
> case of several thousand and in rare cases up to between 30000 and 50000. I've
> not heard of people with maps larger than 50000 entries.
>
> The larger the number of map entries the greater the possibility for a large
> number of active mounts so it's not hard to expect cases of a 1000 or somewhat
> more active mounts.

So I am setting the default number of mounts allowed per mount
namespace at 100,000.  This is more than enough for any use case I
know of, but small enough to quickly stop an exponential increase
in mounts.  Which should be perfect to catch misconfigurations and
malfunctioning programs.

For anyone who needs a higher limit this can be changed by writing
to the new /proc/sys/fs/mount-max sysctl.

Tested-by: CAI Qian <caiqian@redhat.com>
Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>",1,fs/pnode.c,"{""sha"": ""35e17f748ca78a927df127289ccd20689382aa73"", ""filename"": ""Documentation/sysctl/fs.txt"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/Documentation/sysctl/fs.txt"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/Documentation/sysctl/fs.txt"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/Documentation/sysctl/fs.txt?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -265,6 +265,13 @@ aio-nr can grow to.\n \n ==============================================================\n \n+mount-max:\n+\n+This denotes the maximum number of mounts that may exist\n+in a mount namespace.\n+\n+==============================================================\n+\n \n 2. /proc/sys/fs/binfmt_misc\n ----------------------------------------------------------""}<_**next**_>{""sha"": ""d2e25d7b64b3073c28f37a339b31ac75d275c6f4"", ""filename"": ""fs/mount.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/mount.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/mount.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/mount.h?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -14,6 +14,8 @@ struct mnt_namespace {\n \tu64\t\t\tseq;\t/* Sequence number to prevent loops */\n \twait_queue_head_t poll;\n \tu64 event;\n+\tunsigned int\t\tmounts; /* # of mounts in the namespace */\n+\tunsigned int\t\tpending_mounts;\n };\n \n struct mnt_pcp {""}<_**next**_>{""sha"": ""db1b5a38864e98aa512be772765e00b13ec6c25d"", ""filename"": ""fs/namespace.c"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 1, ""changes"": 49, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/namespace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/namespace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/namespace.c?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -27,6 +27,9 @@\n #include \""pnode.h\""\n #include \""internal.h\""\n \n+/* Maximum number of mounts in a mount namespace */\n+unsigned int sysctl_mount_max __read_mostly = 100000;\n+\n static unsigned int m_hash_mask __read_mostly;\n static unsigned int m_hash_shift __read_mostly;\n static unsigned int mp_hash_mask __read_mostly;\n@@ -899,6 +902,9 @@ static void commit_tree(struct mount *mnt, struct mount *shadows)\n \n \tlist_splice(&head, n->list.prev);\n \n+\tn->mounts += n->pending_mounts;\n+\tn->pending_mounts = 0;\n+\n \tattach_shadowed(mnt, parent, shadows);\n \ttouch_mnt_namespace(n);\n }\n@@ -1419,11 +1425,16 @@ static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n \t\tpropagate_umount(&tmp_list);\n \n \twhile (!list_empty(&tmp_list)) {\n+\t\tstruct mnt_namespace *ns;\n \t\tbool disconnect;\n \t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n \t\tlist_del_init(&p->mnt_expire);\n \t\tlist_del_init(&p->mnt_list);\n-\t\t__touch_mnt_namespace(p->mnt_ns);\n+\t\tns = p->mnt_ns;\n+\t\tif (ns) {\n+\t\t\tns->mounts--;\n+\t\t\t__touch_mnt_namespace(ns);\n+\t\t}\n \t\tp->mnt_ns = NULL;\n \t\tif (how & UMOUNT_SYNC)\n \t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n@@ -1840,6 +1851,28 @@ static int invent_group_ids(struct mount *mnt, bool recurse)\n \treturn 0;\n }\n \n+int count_mounts(struct mnt_namespace *ns, struct mount *mnt)\n+{\n+\tunsigned int max = READ_ONCE(sysctl_mount_max);\n+\tunsigned int mounts = 0, old, pending, sum;\n+\tstruct mount *p;\n+\n+\tfor (p = mnt; p; p = next_mnt(p, mnt))\n+\t\tmounts++;\n+\n+\told = ns->mounts;\n+\tpending = ns->pending_mounts;\n+\tsum = old + pending;\n+\tif ((old > sum) ||\n+\t    (pending > sum) ||\n+\t    (max < sum) ||\n+\t    (mounts > (max - sum)))\n+\t\treturn -ENOSPC;\n+\n+\tns->pending_mounts = pending + mounts;\n+\treturn 0;\n+}\n+\n /*\n  *  @source_mnt : mount tree to be attached\n  *  @nd         : place the mount tree @source_mnt is attached\n@@ -1909,10 +1942,18 @@ static int attach_recursive_mnt(struct mount *source_mnt,\n \t\t\tstruct path *parent_path)\n {\n \tHLIST_HEAD(tree_list);\n+\tstruct mnt_namespace *ns = dest_mnt->mnt_ns;\n \tstruct mount *child, *p;\n \tstruct hlist_node *n;\n \tint err;\n \n+\t/* Is there space to add these mounts to the mount namespace? */\n+\tif (!parent_path) {\n+\t\terr = count_mounts(ns, source_mnt);\n+\t\tif (err)\n+\t\t\tgoto out;\n+\t}\n+\n \tif (IS_MNT_SHARED(dest_mnt)) {\n \t\terr = invent_group_ids(source_mnt, true);\n \t\tif (err)\n@@ -1949,11 +1990,13 @@ static int attach_recursive_mnt(struct mount *source_mnt,\n  out_cleanup_ids:\n \twhile (!hlist_empty(&tree_list)) {\n \t\tchild = hlist_entry(tree_list.first, struct mount, mnt_hash);\n+\t\tchild->mnt_parent->mnt_ns->pending_mounts = 0;\n \t\tumount_tree(child, UMOUNT_SYNC);\n \t}\n \tunlock_mount_hash();\n \tcleanup_group_ids(source_mnt, NULL);\n  out:\n+\tns->pending_mounts = 0;\n \treturn err;\n }\n \n@@ -2776,6 +2819,8 @@ static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)\n \tnew_ns->event = 0;\n \tnew_ns->user_ns = get_user_ns(user_ns);\n \tnew_ns->ucounts = ucounts;\n+\tnew_ns->mounts = 0;\n+\tnew_ns->pending_mounts = 0;\n \treturn new_ns;\n }\n \n@@ -2825,6 +2870,7 @@ struct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns,\n \tq = new;\n \twhile (p) {\n \t\tq->mnt_ns = new_ns;\n+\t\tnew_ns->mounts++;\n \t\tif (new_fs) {\n \t\t\tif (&p->mnt == new_fs->root.mnt) {\n \t\t\t\tnew_fs->root.mnt = mntget(&q->mnt);\n@@ -2863,6 +2909,7 @@ static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)\n \t\tstruct mount *mnt = real_mount(m);\n \t\tmnt->mnt_ns = new_ns;\n \t\tnew_ns->root = mnt;\n+\t\tnew_ns->mounts++;\n \t\tlist_add(&mnt->mnt_list, &new_ns->list);\n \t} else {\n \t\tmntput(m);""}<_**next**_>{""sha"": ""234a9ac49958ed978f67aad68d81fb75cf5717ce"", ""filename"": ""fs/pnode.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/pnode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/pnode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/pnode.c?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -259,7 +259,7 @@ static int propagate_one(struct mount *m)\n \t\tread_sequnlock_excl(&mount_lock);\n \t}\n \thlist_add_head(&child->mnt_hash, list);\n-\treturn 0;\n+\treturn count_mounts(m->mnt_ns, child);\n }\n \n /*""}<_**next**_>{""sha"": ""550f5a8b4fcf462d12d36fb6e7c646670247c317"", ""filename"": ""fs/pnode.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/fs/pnode.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/fs/pnode.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/pnode.h?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -52,4 +52,5 @@ void mnt_set_mountpoint(struct mount *, struct mountpoint *,\n struct mount *copy_tree(struct mount *, struct dentry *, int);\n bool is_path_reachable(struct mount *, struct dentry *,\n \t\t\t const struct path *root);\n+int count_mounts(struct mnt_namespace *ns, struct mount *mnt);\n #endif /* _LINUX_PNODE_H */""}<_**next**_>{""sha"": ""1172cce949a4c36226fea3b1c64c66d6b01c313e"", ""filename"": ""include/linux/mount.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/include/linux/mount.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/include/linux/mount.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/mount.h?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -96,4 +96,6 @@ extern void mark_mounts_for_expiry(struct list_head *mounts);\n \n extern dev_t name_to_dev_t(const char *name);\n \n+extern unsigned int sysctl_mount_max;\n+\n #endif /* _LINUX_MOUNT_H */""}<_**next**_>{""sha"": ""03f18cc15697a9138d79b146040fe786fe60f68d"", ""filename"": ""kernel/sysctl.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/d29216842a85c7970c536108e093963f02714498/kernel/sysctl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d29216842a85c7970c536108e093963f02714498/kernel/sysctl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/sysctl.c?ref=d29216842a85c7970c536108e093963f02714498"", ""patch"": ""@@ -65,6 +65,7 @@\n #include <linux/sched/sysctl.h>\n #include <linux/kexec.h>\n #include <linux/bpf.h>\n+#include <linux/mount.h>\n \n #include <asm/uaccess.h>\n #include <asm/processor.h>\n@@ -1838,6 +1839,14 @@ static struct ctl_table fs_table[] = {\n \t\t.mode\t\t= 0644,\n \t\t.proc_handler\t= proc_doulongvec_minmax,\n \t},\n+\t{\n+\t\t.procname\t= \""mount-max\"",\n+\t\t.data\t\t= &sysctl_mount_max,\n+\t\t.maxlen\t\t= sizeof(unsigned int),\n+\t\t.mode\t\t= 0644,\n+\t\t.proc_handler\t= proc_dointvec_minmax,\n+\t\t.extra1\t\t= &one,\n+\t},\n \t{ }\n };\n ""}","static int propagate_one(struct mount *m)
{
	struct mount *child;
	int type;
	/* skip ones added by this propagate_mnt() */
	if (IS_MNT_NEW(m))
		return 0;
	/* skip if mountpoint isn't covered by it */
	if (!is_subdir(mp->m_dentry, m->mnt.mnt_root))
		return 0;
	if (peers(m, last_dest)) {
		type = CL_MAKE_SHARED;
	} else {
		struct mount *n, *p;
		bool done;
		for (n = m; ; n = p) {
			p = n->mnt_master;
			if (p == dest_master || IS_MNT_MARKED(p))
				break;
		}
		do {
			struct mount *parent = last_source->mnt_parent;
			if (last_source == first_source)
				break;
			done = parent->mnt_master == p;
			if (done && peers(n, parent))
				break;
			last_source = last_source->mnt_master;
		} while (!done);

		type = CL_SLAVE;
		/* beginning of peer group among the slaves? */
		if (IS_MNT_SHARED(m))
			type |= CL_MAKE_SHARED;
	}
		
	/* Notice when we are propagating across user namespaces */
	if (m->mnt_ns->user_ns != user_ns)
		type |= CL_UNPRIVILEGED;
	child = copy_tree(last_source, last_source->mnt.mnt_root, type);
	if (IS_ERR(child))
		return PTR_ERR(child);
	child->mnt.mnt_flags &= ~MNT_LOCKED;
	mnt_set_mountpoint(m, mp, child);
	last_dest = m;
	last_source = child;
	if (m->mnt_master != dest_master) {
		read_seqlock_excl(&mount_lock);
		SET_MNT_MARK(m->mnt_master);
 		read_sequnlock_excl(&mount_lock);
 	}
 	hlist_add_head(&child->mnt_hash, list);
	return count_mounts(m->mnt_ns, child);
 }
","static int propagate_one(struct mount *m)
{
	struct mount *child;
	int type;
	/* skip ones added by this propagate_mnt() */
	if (IS_MNT_NEW(m))
		return 0;
	/* skip if mountpoint isn't covered by it */
	if (!is_subdir(mp->m_dentry, m->mnt.mnt_root))
		return 0;
	if (peers(m, last_dest)) {
		type = CL_MAKE_SHARED;
	} else {
		struct mount *n, *p;
		bool done;
		for (n = m; ; n = p) {
			p = n->mnt_master;
			if (p == dest_master || IS_MNT_MARKED(p))
				break;
		}
		do {
			struct mount *parent = last_source->mnt_parent;
			if (last_source == first_source)
				break;
			done = parent->mnt_master == p;
			if (done && peers(n, parent))
				break;
			last_source = last_source->mnt_master;
		} while (!done);

		type = CL_SLAVE;
		/* beginning of peer group among the slaves? */
		if (IS_MNT_SHARED(m))
			type |= CL_MAKE_SHARED;
	}
		
	/* Notice when we are propagating across user namespaces */
	if (m->mnt_ns->user_ns != user_ns)
		type |= CL_UNPRIVILEGED;
	child = copy_tree(last_source, last_source->mnt.mnt_root, type);
	if (IS_ERR(child))
		return PTR_ERR(child);
	child->mnt.mnt_flags &= ~MNT_LOCKED;
	mnt_set_mountpoint(m, mp, child);
	last_dest = m;
	last_source = child;
	if (m->mnt_master != dest_master) {
		read_seqlock_excl(&mount_lock);
		SET_MNT_MARK(m->mnt_master);
 		read_sequnlock_excl(&mount_lock);
 	}
 	hlist_add_head(&child->mnt_hash, list);
	return 0;
 }
",C,"	return count_mounts(m->mnt_ns, child);
","	return 0;
",,"@@ -259,7 +259,7 @@ static int propagate_one(struct mount *m)
 		read_sequnlock_excl(&mount_lock);
 	}
 	hlist_add_head(&child->mnt_hash, list);
-	return 0;
+	return count_mounts(m->mnt_ns, child);
 }
 
 /*",linux,d29216842a85c7970c536108e093963f02714498,2ed6afdee798658fe3c33b50c4a79d1bde45f1d8,1,"static int propagate_one(struct mount *m)
{
	struct mount *child;
	int type;
	/* skip ones added by this propagate_mnt() */
	if (IS_MNT_NEW(m))
		return 0;
	/* skip if mountpoint isn't covered by it */
	if (!is_subdir(mp->m_dentry, m->mnt.mnt_root))
		return 0;
	if (peers(m, last_dest)) {
		type = CL_MAKE_SHARED;
	} else {
		struct mount *n, *p;
		bool done;
		for (n = m; ; n = p) {
			p = n->mnt_master;
			if (p == dest_master || IS_MNT_MARKED(p))
				break;
		}
		do {
			struct mount *parent = last_source->mnt_parent;
			if (last_source == first_source)
				break;
			done = parent->mnt_master == p;
			if (done && peers(n, parent))
				break;
			last_source = last_source->mnt_master;
		} while (!done);

		type = CL_SLAVE;
		/* beginning of peer group among the slaves? */
		if (IS_MNT_SHARED(m))
			type |= CL_MAKE_SHARED;
	}
		
	/* Notice when we are propagating across user namespaces */
	if (m->mnt_ns->user_ns != user_ns)
		type |= CL_UNPRIVILEGED;
	child = copy_tree(last_source, last_source->mnt.mnt_root, type);
	if (IS_ERR(child))
		return PTR_ERR(child);
	child->mnt.mnt_flags &= ~MNT_LOCKED;
	mnt_set_mountpoint(m, mp, child);
	last_dest = m;
	last_source = child;
	if (m->mnt_master != dest_master) {
		read_seqlock_excl(&mount_lock);
		SET_MNT_MARK(m->mnt_master);
 		read_sequnlock_excl(&mount_lock);
 	}
 	hlist_add_head(&child->mnt_hash, list);
//flaw_line_below:
	return 0;
//fix_flaw_line_below:
//	return count_mounts(m->mnt_ns, child);
 }
"
3192,180928,,Remote,Not required,Complete,CVE-2017-14341,https://www.cvedetails.com/cve/CVE-2017-14341/,CWE-400,Medium,,,,2017-09-12,7.1,"ImageMagick 7.0.6-6 has a large loop vulnerability in ReadWPGImage in coders/wpg.c, causing CPU exhaustion via a crafted wpg image file.",2019-05-14,,2,https://github.com/ImageMagick/ImageMagick/commit/4eae304e773bad8a876c3c26fdffac24d4253ae4,4eae304e773bad8a876c3c26fdffac24d4253ae4,https://github.com/ImageMagick/ImageMagick/issues/654,0,coders/wpg.c,"{""sha"": ""ecd0a715034b43fee83f258710bfa9064073f1fd"", ""filename"": ""coders/wpg.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/4eae304e773bad8a876c3c26fdffac24d4253ae4/coders/wpg.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/4eae304e773bad8a876c3c26fdffac24d4253ae4/coders/wpg.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/wpg.c?ref=4eae304e773bad8a876c3c26fdffac24d4253ae4"", ""patch"": ""@@ -1045,6 +1045,8 @@ static Image *ReadWPGImage(const ImageInfo *image_info,\n           if(i==EOF)\n             break;\n           Rd_WP_DWORD(image,&Rec.RecordLength);\n+          if (Rec.RecordLength > GetBlobSize(image))\n+            ThrowReaderException(CorruptImageError,\""ImproperImageHeader\"");\n           if(EOFBlob(image))\n             break;\n ""}","static Image *ReadWPGImage(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  typedef struct
  {
    size_t FileId;
    MagickOffsetType DataOffset;
    unsigned int ProductType;
    unsigned int FileType;
    unsigned char MajorVersion;
    unsigned char MinorVersion;
    unsigned int EncryptKey;
    unsigned int Reserved;
  } WPGHeader;

  typedef struct
  {
    unsigned char RecType;
    size_t RecordLength;
  } WPGRecord;

  typedef struct
  {
    unsigned char Class;
    unsigned char RecType;
    size_t Extension;
    size_t RecordLength;
  } WPG2Record;

  typedef struct
  {
    unsigned  HorizontalUnits;
    unsigned  VerticalUnits;
    unsigned char PosSizePrecision;
  } WPG2Start;

  typedef struct
  {
    unsigned int Width;
    unsigned int Height;
    unsigned int Depth;
    unsigned int HorzRes;
    unsigned int VertRes;
  } WPGBitmapType1;

  typedef struct
  {
    unsigned int Width;
    unsigned int Height;
    unsigned char Depth;
    unsigned char Compression;
  } WPG2BitmapType1;

  typedef struct
  {
    unsigned int RotAngle;
    unsigned int LowLeftX;
    unsigned int LowLeftY;
    unsigned int UpRightX;
    unsigned int UpRightY;
    unsigned int Width;
    unsigned int Height;
    unsigned int Depth;
    unsigned int HorzRes;
    unsigned int VertRes;
  } WPGBitmapType2;

  typedef struct
  {
    unsigned int StartIndex;
    unsigned int NumOfEntries;
  } WPGColorMapRec;

  /*
  typedef struct {
    size_t PS_unknown1;
    unsigned int PS_unknown2;
    unsigned int PS_unknown3;
  } WPGPSl1Record;
  */

  Image
    *image;

  unsigned int
    status;

  WPGHeader
    Header;

  WPGRecord
    Rec;

  WPG2Record
    Rec2;

  WPG2Start StartWPG;

  WPGBitmapType1
    BitmapHeader1;

  WPG2BitmapType1
    Bitmap2Header1;

  WPGBitmapType2
    BitmapHeader2;

  WPGColorMapRec
    WPG_Palette;

  int
    i,
    bpp,
    WPG2Flags;

  ssize_t
    ldblk;

  size_t
    one;

  unsigned char
    *BImgBuff;

  tCTM CTM;         /*current transform matrix*/

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  one=1;
  image=AcquireImage(image_info);
  image->depth=8;
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read WPG image.
  */
  Header.FileId=ReadBlobLSBLong(image);
  Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image);
  Header.ProductType=ReadBlobLSBShort(image);
  Header.FileType=ReadBlobLSBShort(image);
  Header.MajorVersion=ReadBlobByte(image);
  Header.MinorVersion=ReadBlobByte(image);
  Header.EncryptKey=ReadBlobLSBShort(image);
  Header.Reserved=ReadBlobLSBShort(image);

  if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (Header.EncryptKey!=0)
    ThrowReaderException(CoderError,""EncryptedWPGImageFileNotSupported"");

  image->columns = 1;
  image->rows = 1;
  image->colors = 0;
  bpp=0;
  BitmapHeader2.RotAngle=0;
  Rec2.RecordLength = 0;

  switch(Header.FileType)
    {
    case 1:     /* WPG level 1 */
      while(!EOFBlob(image)) /* object parser loop */
        {
          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);
          if(EOFBlob(image))
            break;

          Rec.RecType=(i=ReadBlobByte(image));
           if(i==EOF)
             break;
           Rd_WP_DWORD(image,&Rec.RecordLength);
          if (Rec.RecordLength > GetBlobSize(image))
            ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
           if(EOFBlob(image))
             break;
 
          Header.DataOffset=TellBlob(image)+Rec.RecordLength;

          switch(Rec.RecType)
            {
            case 0x0B: /* bitmap type 1 */
              BitmapHeader1.Width=ReadBlobLSBShort(image);
              BitmapHeader1.Height=ReadBlobLSBShort(image);
              if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0))
                ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
              BitmapHeader1.Depth=ReadBlobLSBShort(image);
              BitmapHeader1.HorzRes=ReadBlobLSBShort(image);
              BitmapHeader1.VertRes=ReadBlobLSBShort(image);

              if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes)
                {
                  image->units=PixelsPerCentimeterResolution;
                  image->x_resolution=BitmapHeader1.HorzRes/470.0;
                  image->y_resolution=BitmapHeader1.VertRes/470.0;
                }
              image->columns=BitmapHeader1.Width;
              image->rows=BitmapHeader1.Height;
              bpp=BitmapHeader1.Depth;

              goto UnpackRaster;

            case 0x0E:  /*Color palette */
              WPG_Palette.StartIndex=ReadBlobLSBShort(image);
              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);
              if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >
                  (Rec2.RecordLength-2-2) / 3)
                ThrowReaderException(CorruptImageError,""InvalidColormapIndex"");
              image->colors=WPG_Palette.NumOfEntries;
              if (!AcquireImageColormap(image,image->colors))
                goto NoMemory;
              for (i=WPG_Palette.StartIndex;
                   i < (int)WPG_Palette.NumOfEntries; i++)
                {
                  image->colormap[i].red=ScaleCharToQuantum((unsigned char)
                    ReadBlobByte(image));
                  image->colormap[i].green=ScaleCharToQuantum((unsigned char)
                    ReadBlobByte(image));
                  image->colormap[i].blue=ScaleCharToQuantum((unsigned char)
                    ReadBlobByte(image));
                }
              break;

            case 0x11:  /* Start PS l1 */
              if(Rec.RecordLength > 8)
                image=ExtractPostscript(image,image_info,
                  TellBlob(image)+8,   /* skip PS header in the wpg */
                  (ssize_t) Rec.RecordLength-8,exception);
              break;

            case 0x14:  /* bitmap type 2 */
              BitmapHeader2.RotAngle=ReadBlobLSBShort(image);
              BitmapHeader2.LowLeftX=ReadBlobLSBShort(image);
              BitmapHeader2.LowLeftY=ReadBlobLSBShort(image);
              BitmapHeader2.UpRightX=ReadBlobLSBShort(image);
              BitmapHeader2.UpRightY=ReadBlobLSBShort(image);
              BitmapHeader2.Width=ReadBlobLSBShort(image);
              BitmapHeader2.Height=ReadBlobLSBShort(image);
              if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0))
                ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
              BitmapHeader2.Depth=ReadBlobLSBShort(image);
              BitmapHeader2.HorzRes=ReadBlobLSBShort(image);
              BitmapHeader2.VertRes=ReadBlobLSBShort(image);

              image->units=PixelsPerCentimeterResolution;
              image->page.width=(unsigned int)
                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0);
              image->page.height=(unsigned int)
                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0);
              image->page.x=(int) (BitmapHeader2.LowLeftX/470.0);
              image->page.y=(int) (BitmapHeader2.LowLeftX/470.0);
              if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes)
                {
                  image->x_resolution=BitmapHeader2.HorzRes/470.0;
                  image->y_resolution=BitmapHeader2.VertRes/470.0;
                }
              image->columns=BitmapHeader2.Width;
              image->rows=BitmapHeader2.Height;
              bpp=BitmapHeader2.Depth;

            UnpackRaster:
              status=SetImageExtent(image,image->columns,image->rows);
              if (status == MagickFalse)
                break;
              if ((image->colors == 0) && (bpp != 24))
                {
                  image->colors=one << bpp;
                  if (!AcquireImageColormap(image,image->colors))
                    {
                    NoMemory:
                      ThrowReaderException(ResourceLimitError,
                        ""MemoryAllocationFailed"");
                    }
                  /* printf(""Load default colormap \n""); */
                  for (i=0; (i < (int) image->colors) && (i < 256); i++)
                    {
                      image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red);
                      image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green);
                      image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue);
                    }
                }
              else
                {
                  if (bpp < 24)
                    if ( (image->colors < (one << bpp)) && (bpp != 24) )
                      image->colormap=(PixelPacket *) ResizeQuantumMemory(
                        image->colormap,(size_t) (one << bpp),
                        sizeof(*image->colormap));
                }

              if (bpp == 1)
                {
                  if(image->colormap[0].red==0 &&
                     image->colormap[0].green==0 &&
                     image->colormap[0].blue==0 &&
                     image->colormap[1].red==0 &&
                     image->colormap[1].green==0 &&
                     image->colormap[1].blue==0)
                    {  /* fix crippled monochrome palette */
                      image->colormap[1].red =
                        image->colormap[1].green =
                        image->colormap[1].blue = QuantumRange;
                    }
                }

              if(UnpackWPGRaster(image,bpp) < 0)
                /* The raster cannot be unpacked */
                {
                DecompressionFailed:
                  ThrowReaderException(CoderError,""UnableToDecompressImage"");
                    }

              if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping)
                {
                  /* flop command */
                  if(BitmapHeader2.RotAngle & 0x8000)
                    {
                      Image
                        *flop_image;

                      flop_image = FlopImage(image, exception);
                      if (flop_image != (Image *) NULL) {
                        DuplicateBlob(flop_image,image);
                        ReplaceImageInList(&image,flop_image);
                      }
                    }
                  /* flip command */
                  if(BitmapHeader2.RotAngle & 0x2000)
                    {
                      Image
                        *flip_image;

                      flip_image = FlipImage(image, exception);
                      if (flip_image != (Image *) NULL) {
                        DuplicateBlob(flip_image,image);
                        ReplaceImageInList(&image,flip_image);
                      }
                    }
                  /* rotate command */
                  if(BitmapHeader2.RotAngle & 0x0FFF)
                    {
                      Image
                        *rotate_image;

                      rotate_image=RotateImage(image,(BitmapHeader2.RotAngle &
                        0x0FFF), exception);
                      if (rotate_image != (Image *) NULL) {
                        DuplicateBlob(rotate_image,image);
                        ReplaceImageInList(&image,rotate_image);
                      }
                    }
                }

              /* Allocate next image structure. */
              AcquireNextImage(image_info,image);
              image->depth=8;
              if (image->next == (Image *) NULL)
                goto Finish;
              image=SyncNextImageInList(image);
              image->columns=image->rows=1;
              image->colors=0;
              break;

            case 0x1B:  /* Postscript l2 */
              if(Rec.RecordLength>0x3C)
                image=ExtractPostscript(image,image_info,
                  TellBlob(image)+0x3C,   /* skip PS l2 header in the wpg */
                  (ssize_t) Rec.RecordLength-0x3C,exception);
              break;
            }
        }
      break;

    case 2:  /* WPG level 2 */
      (void) memset(CTM,0,sizeof(CTM));
      StartWPG.PosSizePrecision = 0;
      while(!EOFBlob(image)) /* object parser loop */
        {
          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);
          if(EOFBlob(image))
            break;

          Rec2.Class=(i=ReadBlobByte(image));
          if(i==EOF)
            break;
          Rec2.RecType=(i=ReadBlobByte(image));
          if(i==EOF)
            break;
          Rd_WP_DWORD(image,&Rec2.Extension);
          Rd_WP_DWORD(image,&Rec2.RecordLength);
          if(EOFBlob(image))
            break;

          Header.DataOffset=TellBlob(image)+Rec2.RecordLength;

          switch(Rec2.RecType)
            {
      case 1:
              StartWPG.HorizontalUnits=ReadBlobLSBShort(image);
              StartWPG.VerticalUnits=ReadBlobLSBShort(image);
              StartWPG.PosSizePrecision=ReadBlobByte(image);
              break;
            case 0x0C:    /* Color palette */
              WPG_Palette.StartIndex=ReadBlobLSBShort(image);
              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);
              if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >
                  (Rec2.RecordLength-2-2) / 3)
                ThrowReaderException(CorruptImageError,""InvalidColormapIndex"");
              image->colors=WPG_Palette.NumOfEntries;
              if (AcquireImageColormap(image,image->colors) == MagickFalse)
                ThrowReaderException(ResourceLimitError,
                  ""MemoryAllocationFailed"");
              for (i=WPG_Palette.StartIndex;
                   i < (int)WPG_Palette.NumOfEntries; i++)
                {
                  image->colormap[i].red=ScaleCharToQuantum((char)
                    ReadBlobByte(image));
                  image->colormap[i].green=ScaleCharToQuantum((char)
                    ReadBlobByte(image));
                  image->colormap[i].blue=ScaleCharToQuantum((char)
                    ReadBlobByte(image));
                  (void) ReadBlobByte(image);   /*Opacity??*/
                }
              break;
            case 0x0E:
              Bitmap2Header1.Width=ReadBlobLSBShort(image);
              Bitmap2Header1.Height=ReadBlobLSBShort(image);
              if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0))
                ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
              Bitmap2Header1.Depth=ReadBlobByte(image);
              Bitmap2Header1.Compression=ReadBlobByte(image);

              if(Bitmap2Header1.Compression > 1)
                continue; /*Unknown compression method */
              switch(Bitmap2Header1.Depth)
                {
                case 1:
                  bpp=1;
                  break;
                case 2:
                  bpp=2;
                  break;
                case 3:
                  bpp=4;
                  break;
                case 4:
                  bpp=8;
                  break;
                case 8:
                  bpp=24;
                  break;
                default:
                  continue;  /*Ignore raster with unknown depth*/
                }
              image->columns=Bitmap2Header1.Width;
              image->rows=Bitmap2Header1.Height;
              status=SetImageExtent(image,image->columns,image->rows);
              if (status == MagickFalse)
                break;
              if ((image->colors == 0) && (bpp != 24))
                {
                  size_t
                    one;

                  one=1;
                  image->colors=one << bpp;
                  if (!AcquireImageColormap(image,image->colors))
                    goto NoMemory;
                }
              else
                {
                  if(bpp < 24)
                    if( image->colors<(one << bpp) && bpp!=24 )
                      image->colormap=(PixelPacket *) ResizeQuantumMemory(
                       image->colormap,(size_t) (one << bpp),
                       sizeof(*image->colormap));
                }


              switch(Bitmap2Header1.Compression)
                {
                case 0:    /*Uncompressed raster*/
                  {
                    ldblk=(ssize_t) ((bpp*image->columns+7)/8);
                    BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t)
                      ldblk+1,sizeof(*BImgBuff));
                    if (BImgBuff == (unsigned char *) NULL)
                      goto NoMemory;

                    for(i=0; i< (ssize_t) image->rows; i++)
                      {
                        (void) ReadBlob(image,ldblk,BImgBuff);
                        InsertRow(BImgBuff,i,image,bpp);
                      }

                    if(BImgBuff)
                      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);
                    break;
                  }
                case 1:    /*RLE for WPG2 */
                  {
                    if( UnpackWPG2Raster(image,bpp) < 0)
                      goto DecompressionFailed;
                    break;
                  }
                }

              if(CTM[0][0]<0 && !image_info->ping)
                {    /*?? RotAngle=360-RotAngle;*/
                  Image
                    *flop_image;

                  flop_image = FlopImage(image, exception);
                  if (flop_image != (Image *) NULL) {
                    DuplicateBlob(flop_image,image);
                    ReplaceImageInList(&image,flop_image);
                  }
                  /* Try to change CTM according to Flip - I am not sure, must be checked.
                     Tx(0,0)=-1;      Tx(1,0)=0;   Tx(2,0)=0;
                     Tx(0,1)= 0;      Tx(1,1)=1;   Tx(2,1)=0;
                     Tx(0,2)=(WPG._2Rect.X_ur+WPG._2Rect.X_ll);
                     Tx(1,2)=0;   Tx(2,2)=1; */
                }
              if(CTM[1][1]<0 && !image_info->ping)
                {    /*?? RotAngle=360-RotAngle;*/
                  Image
                    *flip_image;

                  flip_image = FlipImage(image, exception);
                  if (flip_image != (Image *) NULL) {
                    DuplicateBlob(flip_image,image);
                    ReplaceImageInList(&image,flip_image);
                  }
                  /* Try to change CTM according to Flip - I am not sure, must be checked.
                     float_matrix Tx(3,3);
                     Tx(0,0)= 1;   Tx(1,0)= 0;   Tx(2,0)=0;
                     Tx(0,1)= 0;   Tx(1,1)=-1;   Tx(2,1)=0;
                     Tx(0,2)= 0;   Tx(1,2)=(WPG._2Rect.Y_ur+WPG._2Rect.Y_ll);
                     Tx(2,2)=1; */
                }


              /* Allocate next image structure. */
              AcquireNextImage(image_info,image);
              image->depth=8;
              if (image->next == (Image *) NULL)
                goto Finish;
              image=SyncNextImageInList(image);
              image->columns=image->rows=1;
              image->colors=0;
              break;

            case 0x12:  /* Postscript WPG2*/
        i=ReadBlobLSBShort(image);
              if(Rec2.RecordLength > (unsigned int) i)
                image=ExtractPostscript(image,image_info,
                  TellBlob(image)+i,    /*skip PS header in the wpg2*/
                  (ssize_t) (Rec2.RecordLength-i-2),exception);
              break;

      case 0x1B:          /*bitmap rectangle*/
              WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM);
              (void) WPG2Flags;
              break;
            }
        }

      break;

    default:
      {
         ThrowReaderException(CoderError,""DataEncodingSchemeIsNotSupported"");
      }
   }

 Finish:
  (void) CloseBlob(image);

  {
    Image
      *p;

    ssize_t
      scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
        Image *tmp=p;
        if ((p->rows == 0) || (p->columns == 0)) {
          p=p->previous;
          DeleteImageFromList(&tmp);
        } else {
          image=p;
          p=p->previous;
        }
      }
    /*
      Fix scene numbers.
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=(size_t) scene++;
  }
  if (image == (Image *) NULL)
    ThrowReaderException(CorruptImageError,
      ""ImageFileDoesNotContainAnyImageData"");
  return(image);
}
","static Image *ReadWPGImage(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  typedef struct
  {
    size_t FileId;
    MagickOffsetType DataOffset;
    unsigned int ProductType;
    unsigned int FileType;
    unsigned char MajorVersion;
    unsigned char MinorVersion;
    unsigned int EncryptKey;
    unsigned int Reserved;
  } WPGHeader;

  typedef struct
  {
    unsigned char RecType;
    size_t RecordLength;
  } WPGRecord;

  typedef struct
  {
    unsigned char Class;
    unsigned char RecType;
    size_t Extension;
    size_t RecordLength;
  } WPG2Record;

  typedef struct
  {
    unsigned  HorizontalUnits;
    unsigned  VerticalUnits;
    unsigned char PosSizePrecision;
  } WPG2Start;

  typedef struct
  {
    unsigned int Width;
    unsigned int Height;
    unsigned int Depth;
    unsigned int HorzRes;
    unsigned int VertRes;
  } WPGBitmapType1;

  typedef struct
  {
    unsigned int Width;
    unsigned int Height;
    unsigned char Depth;
    unsigned char Compression;
  } WPG2BitmapType1;

  typedef struct
  {
    unsigned int RotAngle;
    unsigned int LowLeftX;
    unsigned int LowLeftY;
    unsigned int UpRightX;
    unsigned int UpRightY;
    unsigned int Width;
    unsigned int Height;
    unsigned int Depth;
    unsigned int HorzRes;
    unsigned int VertRes;
  } WPGBitmapType2;

  typedef struct
  {
    unsigned int StartIndex;
    unsigned int NumOfEntries;
  } WPGColorMapRec;

  /*
  typedef struct {
    size_t PS_unknown1;
    unsigned int PS_unknown2;
    unsigned int PS_unknown3;
  } WPGPSl1Record;
  */

  Image
    *image;

  unsigned int
    status;

  WPGHeader
    Header;

  WPGRecord
    Rec;

  WPG2Record
    Rec2;

  WPG2Start StartWPG;

  WPGBitmapType1
    BitmapHeader1;

  WPG2BitmapType1
    Bitmap2Header1;

  WPGBitmapType2
    BitmapHeader2;

  WPGColorMapRec
    WPG_Palette;

  int
    i,
    bpp,
    WPG2Flags;

  ssize_t
    ldblk;

  size_t
    one;

  unsigned char
    *BImgBuff;

  tCTM CTM;         /*current transform matrix*/

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  one=1;
  image=AcquireImage(image_info);
  image->depth=8;
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read WPG image.
  */
  Header.FileId=ReadBlobLSBLong(image);
  Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image);
  Header.ProductType=ReadBlobLSBShort(image);
  Header.FileType=ReadBlobLSBShort(image);
  Header.MajorVersion=ReadBlobByte(image);
  Header.MinorVersion=ReadBlobByte(image);
  Header.EncryptKey=ReadBlobLSBShort(image);
  Header.Reserved=ReadBlobLSBShort(image);

  if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (Header.EncryptKey!=0)
    ThrowReaderException(CoderError,""EncryptedWPGImageFileNotSupported"");

  image->columns = 1;
  image->rows = 1;
  image->colors = 0;
  bpp=0;
  BitmapHeader2.RotAngle=0;
  Rec2.RecordLength = 0;

  switch(Header.FileType)
    {
    case 1:     /* WPG level 1 */
      while(!EOFBlob(image)) /* object parser loop */
        {
          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);
          if(EOFBlob(image))
            break;

          Rec.RecType=(i=ReadBlobByte(image));
           if(i==EOF)
             break;
           Rd_WP_DWORD(image,&Rec.RecordLength);
           if(EOFBlob(image))
             break;
 
          Header.DataOffset=TellBlob(image)+Rec.RecordLength;

          switch(Rec.RecType)
            {
            case 0x0B: /* bitmap type 1 */
              BitmapHeader1.Width=ReadBlobLSBShort(image);
              BitmapHeader1.Height=ReadBlobLSBShort(image);
              if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0))
                ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
              BitmapHeader1.Depth=ReadBlobLSBShort(image);
              BitmapHeader1.HorzRes=ReadBlobLSBShort(image);
              BitmapHeader1.VertRes=ReadBlobLSBShort(image);

              if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes)
                {
                  image->units=PixelsPerCentimeterResolution;
                  image->x_resolution=BitmapHeader1.HorzRes/470.0;
                  image->y_resolution=BitmapHeader1.VertRes/470.0;
                }
              image->columns=BitmapHeader1.Width;
              image->rows=BitmapHeader1.Height;
              bpp=BitmapHeader1.Depth;

              goto UnpackRaster;

            case 0x0E:  /*Color palette */
              WPG_Palette.StartIndex=ReadBlobLSBShort(image);
              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);
              if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >
                  (Rec2.RecordLength-2-2) / 3)
                ThrowReaderException(CorruptImageError,""InvalidColormapIndex"");
              image->colors=WPG_Palette.NumOfEntries;
              if (!AcquireImageColormap(image,image->colors))
                goto NoMemory;
              for (i=WPG_Palette.StartIndex;
                   i < (int)WPG_Palette.NumOfEntries; i++)
                {
                  image->colormap[i].red=ScaleCharToQuantum((unsigned char)
                    ReadBlobByte(image));
                  image->colormap[i].green=ScaleCharToQuantum((unsigned char)
                    ReadBlobByte(image));
                  image->colormap[i].blue=ScaleCharToQuantum((unsigned char)
                    ReadBlobByte(image));
                }
              break;

            case 0x11:  /* Start PS l1 */
              if(Rec.RecordLength > 8)
                image=ExtractPostscript(image,image_info,
                  TellBlob(image)+8,   /* skip PS header in the wpg */
                  (ssize_t) Rec.RecordLength-8,exception);
              break;

            case 0x14:  /* bitmap type 2 */
              BitmapHeader2.RotAngle=ReadBlobLSBShort(image);
              BitmapHeader2.LowLeftX=ReadBlobLSBShort(image);
              BitmapHeader2.LowLeftY=ReadBlobLSBShort(image);
              BitmapHeader2.UpRightX=ReadBlobLSBShort(image);
              BitmapHeader2.UpRightY=ReadBlobLSBShort(image);
              BitmapHeader2.Width=ReadBlobLSBShort(image);
              BitmapHeader2.Height=ReadBlobLSBShort(image);
              if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0))
                ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
              BitmapHeader2.Depth=ReadBlobLSBShort(image);
              BitmapHeader2.HorzRes=ReadBlobLSBShort(image);
              BitmapHeader2.VertRes=ReadBlobLSBShort(image);

              image->units=PixelsPerCentimeterResolution;
              image->page.width=(unsigned int)
                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0);
              image->page.height=(unsigned int)
                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0);
              image->page.x=(int) (BitmapHeader2.LowLeftX/470.0);
              image->page.y=(int) (BitmapHeader2.LowLeftX/470.0);
              if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes)
                {
                  image->x_resolution=BitmapHeader2.HorzRes/470.0;
                  image->y_resolution=BitmapHeader2.VertRes/470.0;
                }
              image->columns=BitmapHeader2.Width;
              image->rows=BitmapHeader2.Height;
              bpp=BitmapHeader2.Depth;

            UnpackRaster:
              status=SetImageExtent(image,image->columns,image->rows);
              if (status == MagickFalse)
                break;
              if ((image->colors == 0) && (bpp != 24))
                {
                  image->colors=one << bpp;
                  if (!AcquireImageColormap(image,image->colors))
                    {
                    NoMemory:
                      ThrowReaderException(ResourceLimitError,
                        ""MemoryAllocationFailed"");
                    }
                  /* printf(""Load default colormap \n""); */
                  for (i=0; (i < (int) image->colors) && (i < 256); i++)
                    {
                      image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red);
                      image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green);
                      image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue);
                    }
                }
              else
                {
                  if (bpp < 24)
                    if ( (image->colors < (one << bpp)) && (bpp != 24) )
                      image->colormap=(PixelPacket *) ResizeQuantumMemory(
                        image->colormap,(size_t) (one << bpp),
                        sizeof(*image->colormap));
                }

              if (bpp == 1)
                {
                  if(image->colormap[0].red==0 &&
                     image->colormap[0].green==0 &&
                     image->colormap[0].blue==0 &&
                     image->colormap[1].red==0 &&
                     image->colormap[1].green==0 &&
                     image->colormap[1].blue==0)
                    {  /* fix crippled monochrome palette */
                      image->colormap[1].red =
                        image->colormap[1].green =
                        image->colormap[1].blue = QuantumRange;
                    }
                }

              if(UnpackWPGRaster(image,bpp) < 0)
                /* The raster cannot be unpacked */
                {
                DecompressionFailed:
                  ThrowReaderException(CoderError,""UnableToDecompressImage"");
                    }

              if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping)
                {
                  /* flop command */
                  if(BitmapHeader2.RotAngle & 0x8000)
                    {
                      Image
                        *flop_image;

                      flop_image = FlopImage(image, exception);
                      if (flop_image != (Image *) NULL) {
                        DuplicateBlob(flop_image,image);
                        ReplaceImageInList(&image,flop_image);
                      }
                    }
                  /* flip command */
                  if(BitmapHeader2.RotAngle & 0x2000)
                    {
                      Image
                        *flip_image;

                      flip_image = FlipImage(image, exception);
                      if (flip_image != (Image *) NULL) {
                        DuplicateBlob(flip_image,image);
                        ReplaceImageInList(&image,flip_image);
                      }
                    }
                  /* rotate command */
                  if(BitmapHeader2.RotAngle & 0x0FFF)
                    {
                      Image
                        *rotate_image;

                      rotate_image=RotateImage(image,(BitmapHeader2.RotAngle &
                        0x0FFF), exception);
                      if (rotate_image != (Image *) NULL) {
                        DuplicateBlob(rotate_image,image);
                        ReplaceImageInList(&image,rotate_image);
                      }
                    }
                }

              /* Allocate next image structure. */
              AcquireNextImage(image_info,image);
              image->depth=8;
              if (image->next == (Image *) NULL)
                goto Finish;
              image=SyncNextImageInList(image);
              image->columns=image->rows=1;
              image->colors=0;
              break;

            case 0x1B:  /* Postscript l2 */
              if(Rec.RecordLength>0x3C)
                image=ExtractPostscript(image,image_info,
                  TellBlob(image)+0x3C,   /* skip PS l2 header in the wpg */
                  (ssize_t) Rec.RecordLength-0x3C,exception);
              break;
            }
        }
      break;

    case 2:  /* WPG level 2 */
      (void) memset(CTM,0,sizeof(CTM));
      StartWPG.PosSizePrecision = 0;
      while(!EOFBlob(image)) /* object parser loop */
        {
          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);
          if(EOFBlob(image))
            break;

          Rec2.Class=(i=ReadBlobByte(image));
          if(i==EOF)
            break;
          Rec2.RecType=(i=ReadBlobByte(image));
          if(i==EOF)
            break;
          Rd_WP_DWORD(image,&Rec2.Extension);
          Rd_WP_DWORD(image,&Rec2.RecordLength);
          if(EOFBlob(image))
            break;

          Header.DataOffset=TellBlob(image)+Rec2.RecordLength;

          switch(Rec2.RecType)
            {
      case 1:
              StartWPG.HorizontalUnits=ReadBlobLSBShort(image);
              StartWPG.VerticalUnits=ReadBlobLSBShort(image);
              StartWPG.PosSizePrecision=ReadBlobByte(image);
              break;
            case 0x0C:    /* Color palette */
              WPG_Palette.StartIndex=ReadBlobLSBShort(image);
              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);
              if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >
                  (Rec2.RecordLength-2-2) / 3)
                ThrowReaderException(CorruptImageError,""InvalidColormapIndex"");
              image->colors=WPG_Palette.NumOfEntries;
              if (AcquireImageColormap(image,image->colors) == MagickFalse)
                ThrowReaderException(ResourceLimitError,
                  ""MemoryAllocationFailed"");
              for (i=WPG_Palette.StartIndex;
                   i < (int)WPG_Palette.NumOfEntries; i++)
                {
                  image->colormap[i].red=ScaleCharToQuantum((char)
                    ReadBlobByte(image));
                  image->colormap[i].green=ScaleCharToQuantum((char)
                    ReadBlobByte(image));
                  image->colormap[i].blue=ScaleCharToQuantum((char)
                    ReadBlobByte(image));
                  (void) ReadBlobByte(image);   /*Opacity??*/
                }
              break;
            case 0x0E:
              Bitmap2Header1.Width=ReadBlobLSBShort(image);
              Bitmap2Header1.Height=ReadBlobLSBShort(image);
              if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0))
                ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
              Bitmap2Header1.Depth=ReadBlobByte(image);
              Bitmap2Header1.Compression=ReadBlobByte(image);

              if(Bitmap2Header1.Compression > 1)
                continue; /*Unknown compression method */
              switch(Bitmap2Header1.Depth)
                {
                case 1:
                  bpp=1;
                  break;
                case 2:
                  bpp=2;
                  break;
                case 3:
                  bpp=4;
                  break;
                case 4:
                  bpp=8;
                  break;
                case 8:
                  bpp=24;
                  break;
                default:
                  continue;  /*Ignore raster with unknown depth*/
                }
              image->columns=Bitmap2Header1.Width;
              image->rows=Bitmap2Header1.Height;
              status=SetImageExtent(image,image->columns,image->rows);
              if (status == MagickFalse)
                break;
              if ((image->colors == 0) && (bpp != 24))
                {
                  size_t
                    one;

                  one=1;
                  image->colors=one << bpp;
                  if (!AcquireImageColormap(image,image->colors))
                    goto NoMemory;
                }
              else
                {
                  if(bpp < 24)
                    if( image->colors<(one << bpp) && bpp!=24 )
                      image->colormap=(PixelPacket *) ResizeQuantumMemory(
                       image->colormap,(size_t) (one << bpp),
                       sizeof(*image->colormap));
                }


              switch(Bitmap2Header1.Compression)
                {
                case 0:    /*Uncompressed raster*/
                  {
                    ldblk=(ssize_t) ((bpp*image->columns+7)/8);
                    BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t)
                      ldblk+1,sizeof(*BImgBuff));
                    if (BImgBuff == (unsigned char *) NULL)
                      goto NoMemory;

                    for(i=0; i< (ssize_t) image->rows; i++)
                      {
                        (void) ReadBlob(image,ldblk,BImgBuff);
                        InsertRow(BImgBuff,i,image,bpp);
                      }

                    if(BImgBuff)
                      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);
                    break;
                  }
                case 1:    /*RLE for WPG2 */
                  {
                    if( UnpackWPG2Raster(image,bpp) < 0)
                      goto DecompressionFailed;
                    break;
                  }
                }

              if(CTM[0][0]<0 && !image_info->ping)
                {    /*?? RotAngle=360-RotAngle;*/
                  Image
                    *flop_image;

                  flop_image = FlopImage(image, exception);
                  if (flop_image != (Image *) NULL) {
                    DuplicateBlob(flop_image,image);
                    ReplaceImageInList(&image,flop_image);
                  }
                  /* Try to change CTM according to Flip - I am not sure, must be checked.
                     Tx(0,0)=-1;      Tx(1,0)=0;   Tx(2,0)=0;
                     Tx(0,1)= 0;      Tx(1,1)=1;   Tx(2,1)=0;
                     Tx(0,2)=(WPG._2Rect.X_ur+WPG._2Rect.X_ll);
                     Tx(1,2)=0;   Tx(2,2)=1; */
                }
              if(CTM[1][1]<0 && !image_info->ping)
                {    /*?? RotAngle=360-RotAngle;*/
                  Image
                    *flip_image;

                  flip_image = FlipImage(image, exception);
                  if (flip_image != (Image *) NULL) {
                    DuplicateBlob(flip_image,image);
                    ReplaceImageInList(&image,flip_image);
                  }
                  /* Try to change CTM according to Flip - I am not sure, must be checked.
                     float_matrix Tx(3,3);
                     Tx(0,0)= 1;   Tx(1,0)= 0;   Tx(2,0)=0;
                     Tx(0,1)= 0;   Tx(1,1)=-1;   Tx(2,1)=0;
                     Tx(0,2)= 0;   Tx(1,2)=(WPG._2Rect.Y_ur+WPG._2Rect.Y_ll);
                     Tx(2,2)=1; */
                }


              /* Allocate next image structure. */
              AcquireNextImage(image_info,image);
              image->depth=8;
              if (image->next == (Image *) NULL)
                goto Finish;
              image=SyncNextImageInList(image);
              image->columns=image->rows=1;
              image->colors=0;
              break;

            case 0x12:  /* Postscript WPG2*/
        i=ReadBlobLSBShort(image);
              if(Rec2.RecordLength > (unsigned int) i)
                image=ExtractPostscript(image,image_info,
                  TellBlob(image)+i,    /*skip PS header in the wpg2*/
                  (ssize_t) (Rec2.RecordLength-i-2),exception);
              break;

      case 0x1B:          /*bitmap rectangle*/
              WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM);
              (void) WPG2Flags;
              break;
            }
        }

      break;

    default:
      {
         ThrowReaderException(CoderError,""DataEncodingSchemeIsNotSupported"");
      }
   }

 Finish:
  (void) CloseBlob(image);

  {
    Image
      *p;

    ssize_t
      scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
        Image *tmp=p;
        if ((p->rows == 0) || (p->columns == 0)) {
          p=p->previous;
          DeleteImageFromList(&tmp);
        } else {
          image=p;
          p=p->previous;
        }
      }
    /*
      Fix scene numbers.
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=(size_t) scene++;
  }
  if (image == (Image *) NULL)
    ThrowReaderException(CorruptImageError,
      ""ImageFileDoesNotContainAnyImageData"");
  return(image);
}
",C,"          if (Rec.RecordLength > GetBlobSize(image))
            ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
",,,"@@ -1045,6 +1045,8 @@ static Image *ReadWPGImage(const ImageInfo *image_info,
           if(i==EOF)
             break;
           Rd_WP_DWORD(image,&Rec.RecordLength);
+          if (Rec.RecordLength > GetBlobSize(image))
+            ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
           if(EOFBlob(image))
             break;
 ",ImageMagick,4eae304e773bad8a876c3c26fdffac24d4253ae4,68bbe7b8b226ed79e339296793f68f1b2bebc519,1,"static Image *ReadWPGImage(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  typedef struct
  {
    size_t FileId;
    MagickOffsetType DataOffset;
    unsigned int ProductType;
    unsigned int FileType;
    unsigned char MajorVersion;
    unsigned char MinorVersion;
    unsigned int EncryptKey;
    unsigned int Reserved;
  } WPGHeader;

  typedef struct
  {
    unsigned char RecType;
    size_t RecordLength;
  } WPGRecord;

  typedef struct
  {
    unsigned char Class;
    unsigned char RecType;
    size_t Extension;
    size_t RecordLength;
  } WPG2Record;

  typedef struct
  {
    unsigned  HorizontalUnits;
    unsigned  VerticalUnits;
    unsigned char PosSizePrecision;
  } WPG2Start;

  typedef struct
  {
    unsigned int Width;
    unsigned int Height;
    unsigned int Depth;
    unsigned int HorzRes;
    unsigned int VertRes;
  } WPGBitmapType1;

  typedef struct
  {
    unsigned int Width;
    unsigned int Height;
    unsigned char Depth;
    unsigned char Compression;
  } WPG2BitmapType1;

  typedef struct
  {
    unsigned int RotAngle;
    unsigned int LowLeftX;
    unsigned int LowLeftY;
    unsigned int UpRightX;
    unsigned int UpRightY;
    unsigned int Width;
    unsigned int Height;
    unsigned int Depth;
    unsigned int HorzRes;
    unsigned int VertRes;
  } WPGBitmapType2;

  typedef struct
  {
    unsigned int StartIndex;
    unsigned int NumOfEntries;
  } WPGColorMapRec;

  /*
  typedef struct {
    size_t PS_unknown1;
    unsigned int PS_unknown2;
    unsigned int PS_unknown3;
  } WPGPSl1Record;
  */

  Image
    *image;

  unsigned int
    status;

  WPGHeader
    Header;

  WPGRecord
    Rec;

  WPG2Record
    Rec2;

  WPG2Start StartWPG;

  WPGBitmapType1
    BitmapHeader1;

  WPG2BitmapType1
    Bitmap2Header1;

  WPGBitmapType2
    BitmapHeader2;

  WPGColorMapRec
    WPG_Palette;

  int
    i,
    bpp,
    WPG2Flags;

  ssize_t
    ldblk;

  size_t
    one;

  unsigned char
    *BImgBuff;

  tCTM CTM;         /*current transform matrix*/

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  one=1;
  image=AcquireImage(image_info);
  image->depth=8;
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read WPG image.
  */
  Header.FileId=ReadBlobLSBLong(image);
  Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image);
  Header.ProductType=ReadBlobLSBShort(image);
  Header.FileType=ReadBlobLSBShort(image);
  Header.MajorVersion=ReadBlobByte(image);
  Header.MinorVersion=ReadBlobByte(image);
  Header.EncryptKey=ReadBlobLSBShort(image);
  Header.Reserved=ReadBlobLSBShort(image);

  if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (Header.EncryptKey!=0)
    ThrowReaderException(CoderError,""EncryptedWPGImageFileNotSupported"");

  image->columns = 1;
  image->rows = 1;
  image->colors = 0;
  bpp=0;
  BitmapHeader2.RotAngle=0;
  Rec2.RecordLength = 0;

  switch(Header.FileType)
    {
    case 1:     /* WPG level 1 */
      while(!EOFBlob(image)) /* object parser loop */
        {
          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);
          if(EOFBlob(image))
            break;

          Rec.RecType=(i=ReadBlobByte(image));
           if(i==EOF)
             break;
           Rd_WP_DWORD(image,&Rec.RecordLength);
//fix_flaw_line_below:
//          if (Rec.RecordLength > GetBlobSize(image))
//fix_flaw_line_below:
//            ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
           if(EOFBlob(image))
             break;
 
          Header.DataOffset=TellBlob(image)+Rec.RecordLength;

          switch(Rec.RecType)
            {
            case 0x0B: /* bitmap type 1 */
              BitmapHeader1.Width=ReadBlobLSBShort(image);
              BitmapHeader1.Height=ReadBlobLSBShort(image);
              if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0))
                ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
              BitmapHeader1.Depth=ReadBlobLSBShort(image);
              BitmapHeader1.HorzRes=ReadBlobLSBShort(image);
              BitmapHeader1.VertRes=ReadBlobLSBShort(image);

              if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes)
                {
                  image->units=PixelsPerCentimeterResolution;
                  image->x_resolution=BitmapHeader1.HorzRes/470.0;
                  image->y_resolution=BitmapHeader1.VertRes/470.0;
                }
              image->columns=BitmapHeader1.Width;
              image->rows=BitmapHeader1.Height;
              bpp=BitmapHeader1.Depth;

              goto UnpackRaster;

            case 0x0E:  /*Color palette */
              WPG_Palette.StartIndex=ReadBlobLSBShort(image);
              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);
              if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >
                  (Rec2.RecordLength-2-2) / 3)
                ThrowReaderException(CorruptImageError,""InvalidColormapIndex"");
              image->colors=WPG_Palette.NumOfEntries;
              if (!AcquireImageColormap(image,image->colors))
                goto NoMemory;
              for (i=WPG_Palette.StartIndex;
                   i < (int)WPG_Palette.NumOfEntries; i++)
                {
                  image->colormap[i].red=ScaleCharToQuantum((unsigned char)
                    ReadBlobByte(image));
                  image->colormap[i].green=ScaleCharToQuantum((unsigned char)
                    ReadBlobByte(image));
                  image->colormap[i].blue=ScaleCharToQuantum((unsigned char)
                    ReadBlobByte(image));
                }
              break;

            case 0x11:  /* Start PS l1 */
              if(Rec.RecordLength > 8)
                image=ExtractPostscript(image,image_info,
                  TellBlob(image)+8,   /* skip PS header in the wpg */
                  (ssize_t) Rec.RecordLength-8,exception);
              break;

            case 0x14:  /* bitmap type 2 */
              BitmapHeader2.RotAngle=ReadBlobLSBShort(image);
              BitmapHeader2.LowLeftX=ReadBlobLSBShort(image);
              BitmapHeader2.LowLeftY=ReadBlobLSBShort(image);
              BitmapHeader2.UpRightX=ReadBlobLSBShort(image);
              BitmapHeader2.UpRightY=ReadBlobLSBShort(image);
              BitmapHeader2.Width=ReadBlobLSBShort(image);
              BitmapHeader2.Height=ReadBlobLSBShort(image);
              if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0))
                ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
              BitmapHeader2.Depth=ReadBlobLSBShort(image);
              BitmapHeader2.HorzRes=ReadBlobLSBShort(image);
              BitmapHeader2.VertRes=ReadBlobLSBShort(image);

              image->units=PixelsPerCentimeterResolution;
              image->page.width=(unsigned int)
                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0);
              image->page.height=(unsigned int)
                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0);
              image->page.x=(int) (BitmapHeader2.LowLeftX/470.0);
              image->page.y=(int) (BitmapHeader2.LowLeftX/470.0);
              if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes)
                {
                  image->x_resolution=BitmapHeader2.HorzRes/470.0;
                  image->y_resolution=BitmapHeader2.VertRes/470.0;
                }
              image->columns=BitmapHeader2.Width;
              image->rows=BitmapHeader2.Height;
              bpp=BitmapHeader2.Depth;

            UnpackRaster:
              status=SetImageExtent(image,image->columns,image->rows);
              if (status == MagickFalse)
                break;
              if ((image->colors == 0) && (bpp != 24))
                {
                  image->colors=one << bpp;
                  if (!AcquireImageColormap(image,image->colors))
                    {
                    NoMemory:
                      ThrowReaderException(ResourceLimitError,
                        ""MemoryAllocationFailed"");
                    }
                  /* printf(""Load default colormap \n""); */
                  for (i=0; (i < (int) image->colors) && (i < 256); i++)
                    {
                      image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red);
                      image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green);
                      image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue);
                    }
                }
              else
                {
                  if (bpp < 24)
                    if ( (image->colors < (one << bpp)) && (bpp != 24) )
                      image->colormap=(PixelPacket *) ResizeQuantumMemory(
                        image->colormap,(size_t) (one << bpp),
                        sizeof(*image->colormap));
                }

              if (bpp == 1)
                {
                  if(image->colormap[0].red==0 &&
                     image->colormap[0].green==0 &&
                     image->colormap[0].blue==0 &&
                     image->colormap[1].red==0 &&
                     image->colormap[1].green==0 &&
                     image->colormap[1].blue==0)
                    {  /* fix crippled monochrome palette */
                      image->colormap[1].red =
                        image->colormap[1].green =
                        image->colormap[1].blue = QuantumRange;
                    }
                }

              if(UnpackWPGRaster(image,bpp) < 0)
                /* The raster cannot be unpacked */
                {
                DecompressionFailed:
                  ThrowReaderException(CoderError,""UnableToDecompressImage"");
                    }

              if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping)
                {
                  /* flop command */
                  if(BitmapHeader2.RotAngle & 0x8000)
                    {
                      Image
                        *flop_image;

                      flop_image = FlopImage(image, exception);
                      if (flop_image != (Image *) NULL) {
                        DuplicateBlob(flop_image,image);
                        ReplaceImageInList(&image,flop_image);
                      }
                    }
                  /* flip command */
                  if(BitmapHeader2.RotAngle & 0x2000)
                    {
                      Image
                        *flip_image;

                      flip_image = FlipImage(image, exception);
                      if (flip_image != (Image *) NULL) {
                        DuplicateBlob(flip_image,image);
                        ReplaceImageInList(&image,flip_image);
                      }
                    }
                  /* rotate command */
                  if(BitmapHeader2.RotAngle & 0x0FFF)
                    {
                      Image
                        *rotate_image;

                      rotate_image=RotateImage(image,(BitmapHeader2.RotAngle &
                        0x0FFF), exception);
                      if (rotate_image != (Image *) NULL) {
                        DuplicateBlob(rotate_image,image);
                        ReplaceImageInList(&image,rotate_image);
                      }
                    }
                }

              /* Allocate next image structure. */
              AcquireNextImage(image_info,image);
              image->depth=8;
              if (image->next == (Image *) NULL)
                goto Finish;
              image=SyncNextImageInList(image);
              image->columns=image->rows=1;
              image->colors=0;
              break;

            case 0x1B:  /* Postscript l2 */
              if(Rec.RecordLength>0x3C)
                image=ExtractPostscript(image,image_info,
                  TellBlob(image)+0x3C,   /* skip PS l2 header in the wpg */
                  (ssize_t) Rec.RecordLength-0x3C,exception);
              break;
            }
        }
      break;

    case 2:  /* WPG level 2 */
      (void) memset(CTM,0,sizeof(CTM));
      StartWPG.PosSizePrecision = 0;
      while(!EOFBlob(image)) /* object parser loop */
        {
          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);
          if(EOFBlob(image))
            break;

          Rec2.Class=(i=ReadBlobByte(image));
          if(i==EOF)
            break;
          Rec2.RecType=(i=ReadBlobByte(image));
          if(i==EOF)
            break;
          Rd_WP_DWORD(image,&Rec2.Extension);
          Rd_WP_DWORD(image,&Rec2.RecordLength);
          if(EOFBlob(image))
            break;

          Header.DataOffset=TellBlob(image)+Rec2.RecordLength;

          switch(Rec2.RecType)
            {
      case 1:
              StartWPG.HorizontalUnits=ReadBlobLSBShort(image);
              StartWPG.VerticalUnits=ReadBlobLSBShort(image);
              StartWPG.PosSizePrecision=ReadBlobByte(image);
              break;
            case 0x0C:    /* Color palette */
              WPG_Palette.StartIndex=ReadBlobLSBShort(image);
              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);
              if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >
                  (Rec2.RecordLength-2-2) / 3)
                ThrowReaderException(CorruptImageError,""InvalidColormapIndex"");
              image->colors=WPG_Palette.NumOfEntries;
              if (AcquireImageColormap(image,image->colors) == MagickFalse)
                ThrowReaderException(ResourceLimitError,
                  ""MemoryAllocationFailed"");
              for (i=WPG_Palette.StartIndex;
                   i < (int)WPG_Palette.NumOfEntries; i++)
                {
                  image->colormap[i].red=ScaleCharToQuantum((char)
                    ReadBlobByte(image));
                  image->colormap[i].green=ScaleCharToQuantum((char)
                    ReadBlobByte(image));
                  image->colormap[i].blue=ScaleCharToQuantum((char)
                    ReadBlobByte(image));
                  (void) ReadBlobByte(image);   /*Opacity??*/
                }
              break;
            case 0x0E:
              Bitmap2Header1.Width=ReadBlobLSBShort(image);
              Bitmap2Header1.Height=ReadBlobLSBShort(image);
              if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0))
                ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
              Bitmap2Header1.Depth=ReadBlobByte(image);
              Bitmap2Header1.Compression=ReadBlobByte(image);

              if(Bitmap2Header1.Compression > 1)
                continue; /*Unknown compression method */
              switch(Bitmap2Header1.Depth)
                {
                case 1:
                  bpp=1;
                  break;
                case 2:
                  bpp=2;
                  break;
                case 3:
                  bpp=4;
                  break;
                case 4:
                  bpp=8;
                  break;
                case 8:
                  bpp=24;
                  break;
                default:
                  continue;  /*Ignore raster with unknown depth*/
                }
              image->columns=Bitmap2Header1.Width;
              image->rows=Bitmap2Header1.Height;
              status=SetImageExtent(image,image->columns,image->rows);
              if (status == MagickFalse)
                break;
              if ((image->colors == 0) && (bpp != 24))
                {
                  size_t
                    one;

                  one=1;
                  image->colors=one << bpp;
                  if (!AcquireImageColormap(image,image->colors))
                    goto NoMemory;
                }
              else
                {
                  if(bpp < 24)
                    if( image->colors<(one << bpp) && bpp!=24 )
                      image->colormap=(PixelPacket *) ResizeQuantumMemory(
                       image->colormap,(size_t) (one << bpp),
                       sizeof(*image->colormap));
                }


              switch(Bitmap2Header1.Compression)
                {
                case 0:    /*Uncompressed raster*/
                  {
                    ldblk=(ssize_t) ((bpp*image->columns+7)/8);
                    BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t)
                      ldblk+1,sizeof(*BImgBuff));
                    if (BImgBuff == (unsigned char *) NULL)
                      goto NoMemory;

                    for(i=0; i< (ssize_t) image->rows; i++)
                      {
                        (void) ReadBlob(image,ldblk,BImgBuff);
                        InsertRow(BImgBuff,i,image,bpp);
                      }

                    if(BImgBuff)
                      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);
                    break;
                  }
                case 1:    /*RLE for WPG2 */
                  {
                    if( UnpackWPG2Raster(image,bpp) < 0)
                      goto DecompressionFailed;
                    break;
                  }
                }

              if(CTM[0][0]<0 && !image_info->ping)
                {    /*?? RotAngle=360-RotAngle;*/
                  Image
                    *flop_image;

                  flop_image = FlopImage(image, exception);
                  if (flop_image != (Image *) NULL) {
                    DuplicateBlob(flop_image,image);
                    ReplaceImageInList(&image,flop_image);
                  }
                  /* Try to change CTM according to Flip - I am not sure, must be checked.
                     Tx(0,0)=-1;      Tx(1,0)=0;   Tx(2,0)=0;
                     Tx(0,1)= 0;      Tx(1,1)=1;   Tx(2,1)=0;
                     Tx(0,2)=(WPG._2Rect.X_ur+WPG._2Rect.X_ll);
                     Tx(1,2)=0;   Tx(2,2)=1; */
                }
              if(CTM[1][1]<0 && !image_info->ping)
                {    /*?? RotAngle=360-RotAngle;*/
                  Image
                    *flip_image;

                  flip_image = FlipImage(image, exception);
                  if (flip_image != (Image *) NULL) {
                    DuplicateBlob(flip_image,image);
                    ReplaceImageInList(&image,flip_image);
                  }
                  /* Try to change CTM according to Flip - I am not sure, must be checked.
                     float_matrix Tx(3,3);
                     Tx(0,0)= 1;   Tx(1,0)= 0;   Tx(2,0)=0;
                     Tx(0,1)= 0;   Tx(1,1)=-1;   Tx(2,1)=0;
                     Tx(0,2)= 0;   Tx(1,2)=(WPG._2Rect.Y_ur+WPG._2Rect.Y_ll);
                     Tx(2,2)=1; */
                }


              /* Allocate next image structure. */
              AcquireNextImage(image_info,image);
              image->depth=8;
              if (image->next == (Image *) NULL)
                goto Finish;
              image=SyncNextImageInList(image);
              image->columns=image->rows=1;
              image->colors=0;
              break;

            case 0x12:  /* Postscript WPG2*/
        i=ReadBlobLSBShort(image);
              if(Rec2.RecordLength > (unsigned int) i)
                image=ExtractPostscript(image,image_info,
                  TellBlob(image)+i,    /*skip PS header in the wpg2*/
                  (ssize_t) (Rec2.RecordLength-i-2),exception);
              break;

      case 0x1B:          /*bitmap rectangle*/
              WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM);
              (void) WPG2Flags;
              break;
            }
        }

      break;

    default:
      {
         ThrowReaderException(CoderError,""DataEncodingSchemeIsNotSupported"");
      }
   }

 Finish:
  (void) CloseBlob(image);

  {
    Image
      *p;

    ssize_t
      scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
        Image *tmp=p;
        if ((p->rows == 0) || (p->columns == 0)) {
          p=p->previous;
          DeleteImageFromList(&tmp);
        } else {
          image=p;
          p=p->previous;
        }
      }
    /*
      Fix scene numbers.
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=(size_t) scene++;
  }
  if (image == (Image *) NULL)
    ThrowReaderException(CorruptImageError,
      ""ImageFileDoesNotContainAnyImageData"");
  return(image);
}
"
3490,181226,,Remote,Not required,Complete,CVE-2017-11142,https://www.cvedetails.com/cve/CVE-2017-11142/,CWE-400,Low,,,,2017-07-10,7.8,"In PHP before 5.6.31, 7.x before 7.0.17, and 7.1.x before 7.1.3, remote attackers could cause a CPU consumption denial of service attack by injecting long form variables, related to main/php_variables.c.",2018-01-13,DoS ,5,https://github.com/php/php-src/commit/0f8cf3b8497dc45c010c44ed9e96518e11e19fc3,0f8cf3b8497dc45c010c44ed9e96518e11e19fc3,Fix bug #73807,2,main/php_variables.c,"{""sha"": ""6da79bddc334f8f732185c2139c10908ca7b1383"", ""filename"": ""main/php_variables.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 3, ""changes"": 12, ""blob_url"": ""https://github.com/php/php-src/blob/0f8cf3b8497dc45c010c44ed9e96518e11e19fc3/main/php_variables.c"", ""raw_url"": ""https://github.com/php/php-src/raw/0f8cf3b8497dc45c010c44ed9e96518e11e19fc3/main/php_variables.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/main/php_variables.c?ref=0f8cf3b8497dc45c010c44ed9e96518e11e19fc3"", ""patch"": ""@@ -237,11 +237,14 @@ typedef struct post_var_data {\n \tchar *ptr;\n \tchar *end;\n \tuint64_t cnt;\n+\n+\t/* Bytes in ptr that have already been scanned for '&' */\n+\tsize_t already_scanned;\n } post_var_data_t;\n \n static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC)\n {\n-\tchar *ksep, *vsep, *val;\n+\tchar *start, *ksep, *vsep, *val;\n \tsize_t klen, vlen;\n \t/* FIXME: string-size_t */\n \tunsigned int new_vlen;\n@@ -250,9 +253,11 @@ static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSR\n \t\treturn 0;\n \t}\n \n-\tvsep = memchr(var->ptr, '&', var->end - var->ptr);\n+\tstart = var->ptr + var->already_scanned;\n+\tvsep = memchr(start, '&', var->end - start);\n \tif (!vsep) {\n \t\tif (!eof) {\n+\t\t\tvar->already_scanned = var->end - var->ptr;\n \t\t\treturn 0;\n \t\t} else {\n \t\t\tvsep = var->end;\n@@ -285,6 +290,7 @@ static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSR\n \tefree(val);\n \n \tvar->ptr = vsep + (vsep != var->end);\n+\tvar->already_scanned = 0;\n \treturn 1;\n }\n \n@@ -304,7 +310,7 @@ static inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof\n \t\t}\n \t}\n \n-\tif (!eof) {\n+\tif (!eof && vars->str.c != vars->ptr) {\n \t\tmemmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);\n \t}\n \treturn SUCCESS;""}"," static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC)
 {
	char *start, *ksep, *vsep, *val;
 	size_t klen, vlen;
 	/* FIXME: string-size_t */
 	unsigned int new_vlen;

	if (var->ptr >= var->end) {
 		return 0;
 	}
 
	start = var->ptr + var->already_scanned;
	vsep = memchr(start, '&', var->end - start);
 	if (!vsep) {
 		if (!eof) {
			var->already_scanned = var->end - var->ptr;
 			return 0;
 		} else {
 			vsep = var->end;
		}
	}

	ksep = memchr(var->ptr, '=', vsep - var->ptr);
	if (ksep) {
		*ksep = '\0';
		/* ""foo=bar&"" or ""foo=&"" */
		klen = ksep - var->ptr;
		vlen = vsep - ++ksep;
	} else {
		ksep = """";
		/* ""foo&"" */
		klen = vsep - var->ptr;
		vlen = 0;
	}

	php_url_decode(var->ptr, klen);

	val = estrndup(ksep, vlen);
	if (vlen) {
		vlen = php_url_decode(val, vlen);
	}

	if (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen TSRMLS_CC)) {
		php_register_variable_safe(var->ptr, val, new_vlen, arr TSRMLS_CC);
	}
 	efree(val);
 
 	var->ptr = vsep + (vsep != var->end);
	var->already_scanned = 0;
 	return 1;
 }
"," static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC)
 {
	char *ksep, *vsep, *val;
 	size_t klen, vlen;
 	/* FIXME: string-size_t */
 	unsigned int new_vlen;

	if (var->ptr >= var->end) {
 		return 0;
 	}
 
	vsep = memchr(var->ptr, '&', var->end - var->ptr);
 	if (!vsep) {
 		if (!eof) {
 			return 0;
 		} else {
 			vsep = var->end;
		}
	}

	ksep = memchr(var->ptr, '=', vsep - var->ptr);
	if (ksep) {
		*ksep = '\0';
		/* ""foo=bar&"" or ""foo=&"" */
		klen = ksep - var->ptr;
		vlen = vsep - ++ksep;
	} else {
		ksep = """";
		/* ""foo&"" */
		klen = vsep - var->ptr;
		vlen = 0;
	}

	php_url_decode(var->ptr, klen);

	val = estrndup(ksep, vlen);
	if (vlen) {
		vlen = php_url_decode(val, vlen);
	}

	if (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen TSRMLS_CC)) {
		php_register_variable_safe(var->ptr, val, new_vlen, arr TSRMLS_CC);
	}
 	efree(val);
 
 	var->ptr = vsep + (vsep != var->end);
 	return 1;
 }
",C,"	char *start, *ksep, *vsep, *val;
	start = var->ptr + var->already_scanned;
	vsep = memchr(start, '&', var->end - start);
			var->already_scanned = var->end - var->ptr;
	var->already_scanned = 0;
","	char *ksep, *vsep, *val;
	vsep = memchr(var->ptr, '&', var->end - var->ptr);
",,"@@ -237,11 +237,14 @@ typedef struct post_var_data {
 	char *ptr;
 	char *end;
 	uint64_t cnt;
+
+	/* Bytes in ptr that have already been scanned for '&' */
+	size_t already_scanned;
 } post_var_data_t;
 
 static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC)
 {
-	char *ksep, *vsep, *val;
+	char *start, *ksep, *vsep, *val;
 	size_t klen, vlen;
 	/* FIXME: string-size_t */
 	unsigned int new_vlen;
@@ -250,9 +253,11 @@ static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSR
 		return 0;
 	}
 
-	vsep = memchr(var->ptr, '&', var->end - var->ptr);
+	start = var->ptr + var->already_scanned;
+	vsep = memchr(start, '&', var->end - start);
 	if (!vsep) {
 		if (!eof) {
+			var->already_scanned = var->end - var->ptr;
 			return 0;
 		} else {
 			vsep = var->end;
@@ -285,6 +290,7 @@ static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSR
 	efree(val);
 
 	var->ptr = vsep + (vsep != var->end);
+	var->already_scanned = 0;
 	return 1;
 }
 
@@ -304,7 +310,7 @@ static inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof
 		}
 	}
 
-	if (!eof) {
+	if (!eof && vars->str.c != vars->ptr) {
 		memmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);
 	}
 	return SUCCESS;",php-src,0f8cf3b8497dc45c010c44ed9e96518e11e19fc3,0e21d8066b940e1228fa840a1539ca3434dc3a3f,1," static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC)
 {
//flaw_line_below:
	char *ksep, *vsep, *val;
//fix_flaw_line_below:
//	char *start, *ksep, *vsep, *val;
 	size_t klen, vlen;
 	/* FIXME: string-size_t */
 	unsigned int new_vlen;

	if (var->ptr >= var->end) {
 		return 0;
 	}
 
//flaw_line_below:
	vsep = memchr(var->ptr, '&', var->end - var->ptr);
//fix_flaw_line_below:
//	start = var->ptr + var->already_scanned;
//fix_flaw_line_below:
//	vsep = memchr(start, '&', var->end - start);
 	if (!vsep) {
 		if (!eof) {
//fix_flaw_line_below:
//			var->already_scanned = var->end - var->ptr;
 			return 0;
 		} else {
 			vsep = var->end;
		}
	}

	ksep = memchr(var->ptr, '=', vsep - var->ptr);
	if (ksep) {
		*ksep = '\0';
		/* ""foo=bar&"" or ""foo=&"" */
		klen = ksep - var->ptr;
		vlen = vsep - ++ksep;
	} else {
		ksep = """";
		/* ""foo&"" */
		klen = vsep - var->ptr;
		vlen = 0;
	}

	php_url_decode(var->ptr, klen);

	val = estrndup(ksep, vlen);
	if (vlen) {
		vlen = php_url_decode(val, vlen);
	}

	if (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen TSRMLS_CC)) {
		php_register_variable_safe(var->ptr, val, new_vlen, arr TSRMLS_CC);
	}
 	efree(val);
 
 	var->ptr = vsep + (vsep != var->end);
//fix_flaw_line_below:
//	var->already_scanned = 0;
 	return 1;
 }
"
3491,181227,,Remote,Not required,Complete,CVE-2017-11142,https://www.cvedetails.com/cve/CVE-2017-11142/,CWE-400,Low,,,,2017-07-10,7.8,"In PHP before 5.6.31, 7.x before 7.0.17, and 7.1.x before 7.1.3, remote attackers could cause a CPU consumption denial of service attack by injecting long form variables, related to main/php_variables.c.",2018-01-13,DoS ,1,https://github.com/php/php-src/commit/0f8cf3b8497dc45c010c44ed9e96518e11e19fc3,0f8cf3b8497dc45c010c44ed9e96518e11e19fc3,Fix bug #73807,1,main/php_variables.c,"{""sha"": ""6da79bddc334f8f732185c2139c10908ca7b1383"", ""filename"": ""main/php_variables.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 3, ""changes"": 12, ""blob_url"": ""https://github.com/php/php-src/blob/0f8cf3b8497dc45c010c44ed9e96518e11e19fc3/main/php_variables.c"", ""raw_url"": ""https://github.com/php/php-src/raw/0f8cf3b8497dc45c010c44ed9e96518e11e19fc3/main/php_variables.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/main/php_variables.c?ref=0f8cf3b8497dc45c010c44ed9e96518e11e19fc3"", ""patch"": ""@@ -237,11 +237,14 @@ typedef struct post_var_data {\n \tchar *ptr;\n \tchar *end;\n \tuint64_t cnt;\n+\n+\t/* Bytes in ptr that have already been scanned for '&' */\n+\tsize_t already_scanned;\n } post_var_data_t;\n \n static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC)\n {\n-\tchar *ksep, *vsep, *val;\n+\tchar *start, *ksep, *vsep, *val;\n \tsize_t klen, vlen;\n \t/* FIXME: string-size_t */\n \tunsigned int new_vlen;\n@@ -250,9 +253,11 @@ static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSR\n \t\treturn 0;\n \t}\n \n-\tvsep = memchr(var->ptr, '&', var->end - var->ptr);\n+\tstart = var->ptr + var->already_scanned;\n+\tvsep = memchr(start, '&', var->end - start);\n \tif (!vsep) {\n \t\tif (!eof) {\n+\t\t\tvar->already_scanned = var->end - var->ptr;\n \t\t\treturn 0;\n \t\t} else {\n \t\t\tvsep = var->end;\n@@ -285,6 +290,7 @@ static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSR\n \tefree(val);\n \n \tvar->ptr = vsep + (vsep != var->end);\n+\tvar->already_scanned = 0;\n \treturn 1;\n }\n \n@@ -304,7 +310,7 @@ static inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof\n \t\t}\n \t}\n \n-\tif (!eof) {\n+\tif (!eof && vars->str.c != vars->ptr) {\n \t\tmemmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);\n \t}\n \treturn SUCCESS;""}","static inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof TSRMLS_DC)
{
	uint64_t max_vars = PG(max_input_vars);

	vars->ptr = vars->str.c;
	vars->end = vars->str.c + vars->str.len;
	while (add_post_var(arr, vars, eof TSRMLS_CC)) {
		if (++vars->cnt > max_vars) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING,
					""Input variables exceeded %"" PRIu64 "". ""
					""To increase the limit change max_input_vars in php.ini."",
					max_vars);
			return FAILURE;
 		}
 	}
 
	if (!eof && vars->str.c != vars->ptr) {
 		memmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);
 	}
 	return SUCCESS;
}
","static inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof TSRMLS_DC)
{
	uint64_t max_vars = PG(max_input_vars);

	vars->ptr = vars->str.c;
	vars->end = vars->str.c + vars->str.len;
	while (add_post_var(arr, vars, eof TSRMLS_CC)) {
		if (++vars->cnt > max_vars) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING,
					""Input variables exceeded %"" PRIu64 "". ""
					""To increase the limit change max_input_vars in php.ini."",
					max_vars);
			return FAILURE;
 		}
 	}
 
	if (!eof) {
 		memmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);
 	}
 	return SUCCESS;
}
",C,"	if (!eof && vars->str.c != vars->ptr) {
","	if (!eof) {
",,"@@ -237,11 +237,14 @@ typedef struct post_var_data {
 	char *ptr;
 	char *end;
 	uint64_t cnt;
+
+	/* Bytes in ptr that have already been scanned for '&' */
+	size_t already_scanned;
 } post_var_data_t;
 
 static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC)
 {
-	char *ksep, *vsep, *val;
+	char *start, *ksep, *vsep, *val;
 	size_t klen, vlen;
 	/* FIXME: string-size_t */
 	unsigned int new_vlen;
@@ -250,9 +253,11 @@ static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSR
 		return 0;
 	}
 
-	vsep = memchr(var->ptr, '&', var->end - var->ptr);
+	start = var->ptr + var->already_scanned;
+	vsep = memchr(start, '&', var->end - start);
 	if (!vsep) {
 		if (!eof) {
+			var->already_scanned = var->end - var->ptr;
 			return 0;
 		} else {
 			vsep = var->end;
@@ -285,6 +290,7 @@ static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSR
 	efree(val);
 
 	var->ptr = vsep + (vsep != var->end);
+	var->already_scanned = 0;
 	return 1;
 }
 
@@ -304,7 +310,7 @@ static inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof
 		}
 	}
 
-	if (!eof) {
+	if (!eof && vars->str.c != vars->ptr) {
 		memmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);
 	}
 	return SUCCESS;",php-src,0f8cf3b8497dc45c010c44ed9e96518e11e19fc3,0e21d8066b940e1228fa840a1539ca3434dc3a3f,1,"static inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof TSRMLS_DC)
{
	uint64_t max_vars = PG(max_input_vars);

	vars->ptr = vars->str.c;
	vars->end = vars->str.c + vars->str.len;
	while (add_post_var(arr, vars, eof TSRMLS_CC)) {
		if (++vars->cnt > max_vars) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING,
					""Input variables exceeded %"" PRIu64 "". ""
					""To increase the limit change max_input_vars in php.ini."",
					max_vars);
			return FAILURE;
 		}
 	}
 
//flaw_line_below:
	if (!eof) {
//fix_flaw_line_below:
//	if (!eof && vars->str.c != vars->ptr) {
 		memmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);
 	}
 	return SUCCESS;
}
"
4067,181803,,Remote,Not required,Complete,CVE-2016-10058,https://www.cvedetails.com/cve/CVE-2016-10058/,CWE-400,Medium,,,,2017-03-23,7.1,Memory leak in the ReadPSDLayers function in coders/psd.c in ImageMagick before 6.9.6-3 allows remote attackers to cause a denial of service (memory consumption) via a crafted image file.,2017-03-24,DoS ,2,https://github.com/ImageMagick/ImageMagick/commit/4ec444f4eab88cf4bec664fafcf9cab50bc5ff6a,4ec444f4eab88cf4bec664fafcf9cab50bc5ff6a,Fixed memory leak.,0,coders/psd.c,"{""sha"": ""e936a7d669c80c433790a46c5f7f9b9d1bfa1470"", ""filename"": ""coders/psd.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/4ec444f4eab88cf4bec664fafcf9cab50bc5ff6a/coders/psd.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/4ec444f4eab88cf4bec664fafcf9cab50bc5ff6a/coders/psd.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/psd.c?ref=4ec444f4eab88cf4bec664fafcf9cab50bc5ff6a"", ""patch"": ""@@ -1719,6 +1719,8 @@ ModuleExport MagickBooleanType ReadPSDLayers(Image *image,\n             if (image->debug != MagickFalse)\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \""      layer data is empty\"");\n+            if (layer_info[i].info != (StringInfo *) NULL)\n+              layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n             continue;\n           }\n ""}","ModuleExport MagickBooleanType ReadPSDLayers(Image *image,
  const ImageInfo *image_info,const PSDInfo *psd_info,
  const MagickBooleanType skip_layers,ExceptionInfo *exception)
{
  char
    type[4];

  LayerInfo
    *layer_info;

  MagickSizeType
    size;

  MagickBooleanType
    status;

  register ssize_t
    i;

  ssize_t
    count,
    j,
    number_layers;

  size=GetPSDSize(psd_info,image);
  if (size == 0)
    {
      /*
        Skip layers & masks.
      */
      (void) ReadBlobLong(image);
      count=ReadBlob(image,4,(unsigned char *) type);
      ReversePSDString(image,type,4);
      status=MagickFalse;
      if ((count == 0) || (LocaleNCompare(type,""8BIM"",4) != 0))
        return(MagickTrue);
      else
        {
          count=ReadBlob(image,4,(unsigned char *) type);
          ReversePSDString(image,type,4);
          if ((count != 0) && (LocaleNCompare(type,""Lr16"",4) == 0))
            size=GetPSDSize(psd_info,image);
          else
            return(MagickTrue);
        }
    }
  status=MagickTrue;
  if (size != 0)
    {
      layer_info=(LayerInfo *) NULL;
      number_layers=(short) ReadBlobShort(image);

      if (number_layers < 0)
        {
          /*
            The first alpha channel in the merged result contains the
            transparency data for the merged result.
          */
          number_layers=MagickAbsoluteValue(number_layers);
          if (image->debug != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  negative layer count corrected for"");
          image->matte=MagickTrue;
        }

      /*
        We only need to know if the image has an alpha channel
      */
      if (skip_layers != MagickFalse)
        return(MagickTrue);

      if (image->debug != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""  image contains %.20g layers"",(double) number_layers);

      if (number_layers == 0)
        ThrowBinaryException(CorruptImageError,""InvalidNumberOfLayers"",
          image->filename);

      layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,
        sizeof(*layer_info));
      if (layer_info == (LayerInfo *) NULL)
        {
          if (image->debug != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  allocation of LayerInfo failed"");
          ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
            image->filename);
        }
      (void) ResetMagickMemory(layer_info,0,(size_t) number_layers*
        sizeof(*layer_info));

      for (i=0; i < number_layers; i++)
      {
        ssize_t
          x,
          y;

        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  reading layer #%.20g"",(double) i+1);
        layer_info[i].page.y=ReadBlobSignedLong(image);
        layer_info[i].page.x=ReadBlobSignedLong(image);
        y=ReadBlobSignedLong(image);
        x=ReadBlobSignedLong(image);
        layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);
        layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);
        layer_info[i].channels=ReadBlobShort(image);
        if (layer_info[i].channels > MaxPSDChannels)
          {
            layer_info=DestroyLayerInfo(layer_info,number_layers);
            ThrowBinaryException(CorruptImageError,""MaximumChannelsExceeded"",
              image->filename);
          }
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g"",
            (double) layer_info[i].page.x,(double) layer_info[i].page.y,
            (double) layer_info[i].page.height,(double)
            layer_info[i].page.width,(double) layer_info[i].channels);
        for (j=0; j < (ssize_t) layer_info[i].channels; j++)
        {
          layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);
          layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,
            image);
          if (image->debug != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    channel[%.20g]: type=%.20g, size=%.20g"",(double) j,
              (double) layer_info[i].channel_info[j].type,
              (double) layer_info[i].channel_info[j].size);
        }
        count=ReadBlob(image,4,(unsigned char *) type);
        ReversePSDString(image,type,4);
        if ((count == 0) || (LocaleNCompare(type,""8BIM"",4) != 0))
          {
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  layer type was %.4s instead of 8BIM"", type);
            layer_info=DestroyLayerInfo(layer_info,number_layers);
            ThrowBinaryException(CorruptImageError,""ImproperImageHeader"",
              image->filename);
          }
        (void) ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);
        ReversePSDString(image,layer_info[i].blendkey,4);
        layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)
          ReadBlobByte(image));
        layer_info[i].clipping=(unsigned char) ReadBlobByte(image);
        layer_info[i].flags=(unsigned char) ReadBlobByte(image);
        layer_info[i].visible=!(layer_info[i].flags & 0x02);
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s"",
            layer_info[i].blendkey,(double) layer_info[i].opacity,
            layer_info[i].clipping ? ""true"" : ""false"",layer_info[i].flags,
            layer_info[i].visible ? ""true"" : ""false"");
        (void) ReadBlobByte(image);  /* filler */

        size=ReadBlobLong(image);
        if (size != 0)
          {
            MagickSizeType
              combined_length,
              length;

            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""    layer contains additional info"");
            length=ReadBlobLong(image);
            combined_length=length+4;
            if (length != 0)
              {
                /*
                  Layer mask info.
                */
                layer_info[i].mask.page.y=ReadBlobSignedLong(image);
                layer_info[i].mask.page.x=ReadBlobSignedLong(image);
                layer_info[i].mask.page.height=(size_t) (ReadBlobLong(image)-
                  layer_info[i].mask.page.y);
                layer_info[i].mask.page.width=(size_t) (ReadBlobLong(image)-
                  layer_info[i].mask.page.x);
                layer_info[i].mask.background=(unsigned char) ReadBlobByte(
                  image);
                layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);
                if (!(layer_info[i].mask.flags & 0x01))
                  {
                    layer_info[i].mask.page.y=layer_info[i].mask.page.y-
                      layer_info[i].page.y;
                    layer_info[i].mask.page.x=layer_info[i].mask.page.x-
                      layer_info[i].page.x;
                  }
                if (image->debug != MagickFalse)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g"",
                    (double) layer_info[i].mask.page.x,(double)
                    layer_info[i].mask.page.y,(double) layer_info[i].mask.page.width,
                    (double) layer_info[i].mask.page.height,(double)
                    ((MagickOffsetType) length)-18);
                /*
                  Skip over the rest of the layer mask information.
                */
                if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)
                  {
                    layer_info=DestroyLayerInfo(layer_info,number_layers);
                    ThrowBinaryException(CorruptImageError,""UnexpectedEndOfFile"",
                      image->filename);
                  }
              }
            length=ReadBlobLong(image);
            combined_length+=length+4;
            if (length != 0)
              {
                /*
                  Layer blending ranges info.
                */
                if (image->debug != MagickFalse)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      layer blending ranges: length=%.20g"",(double)
                    ((MagickOffsetType) length));
                /*
                  We read it, but don't use it...
                */
                for (j=0; j < (ssize_t) length; j+=8)
                {
                  size_t blend_source=ReadBlobLong(image);
                  size_t blend_dest=ReadBlobLong(image);
                  if (image->debug != MagickFalse)
                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                      ""        source(%x), dest(%x)"",(unsigned int)
                      blend_source,(unsigned int) blend_dest);
                }
              }
            /*
              Layer name.
            */
            length=(MagickSizeType) ReadBlobByte(image);
            combined_length+=length+1;
            if (length > 0)
              (void) ReadBlob(image,(size_t) length++,layer_info[i].name);
            layer_info[i].name[length]='\0';
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""      layer name: %s"",layer_info[i].name);
            if ((length % 4) != 0)
              {
                length=4-(length % 4);
                combined_length+=length;
                /* Skip over the padding of the layer name */
                if (DiscardBlobBytes(image,length) == MagickFalse)
                  {
                    layer_info=DestroyLayerInfo(layer_info,number_layers);
                    ThrowBinaryException(CorruptImageError,
                      ""UnexpectedEndOfFile"",image->filename);
                  }
              }
            length=(MagickSizeType) size-combined_length;
            if (length > 0)
              {
                unsigned char
                  *info;

                layer_info[i].info=AcquireStringInfo((const size_t) length);
                info=GetStringInfoDatum(layer_info[i].info);
                (void) ReadBlob(image,(const size_t) length,info);
              }
          }
      }

      for (i=0; i < number_layers; i++)
      {
        if ((layer_info[i].page.width == 0) ||
              (layer_info[i].page.height == 0))
          {
             if (image->debug != MagickFalse)
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""      layer data is empty"");
            if (layer_info[i].info != (StringInfo *) NULL)
              layer_info[i].info=DestroyStringInfo(layer_info[i].info);
             continue;
           }
 
        /*
          Allocate layered image.
        */
        layer_info[i].image=CloneImage(image,layer_info[i].page.width,
          layer_info[i].page.height,MagickFalse,exception);
        if (layer_info[i].image == (Image *) NULL)
          {
            layer_info=DestroyLayerInfo(layer_info,number_layers);
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  allocation of image for layer %.20g failed"",(double) i);
            ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
              image->filename);
          }

        if (layer_info[i].info != (StringInfo *) NULL)
          {
            (void) SetImageProfile(layer_info[i].image,""psd:additional-info"",
              layer_info[i].info);
            layer_info[i].info=DestroyStringInfo(layer_info[i].info);
          }
      }

      if (image_info->ping == MagickFalse)
        {
          for (i=0; i < number_layers; i++)
          {
            if (layer_info[i].image == (Image *) NULL)
              {
                for (j=0; j < layer_info[i].channels; j++)
                {
                  if (DiscardBlobBytes(image,(MagickSizeType)
                      layer_info[i].channel_info[j].size) == MagickFalse)
                    {
                      layer_info=DestroyLayerInfo(layer_info,number_layers);
                      ThrowBinaryException(CorruptImageError,
                        ""UnexpectedEndOfFile"",image->filename);
                    }
                }
                continue;
              }

            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  reading data for layer %.20g"",(double) i);
            status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],
              exception);
            if (status == MagickFalse)
              break;

            status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)
              number_layers);
            if (status == MagickFalse)
              break;
          }
        }

      if (status != MagickFalse)
        {
          for (i=0; i < number_layers; i++)
          {
            if (layer_info[i].image == (Image *) NULL)
              {
                for (j=i; j < number_layers - 1; j++)
                  layer_info[j] = layer_info[j+1];
                number_layers--;
                i--;
              }
          }

          if (number_layers > 0)
            {
              for (i=0; i < number_layers; i++)
              {
                if (i > 0)
                  layer_info[i].image->previous=layer_info[i-1].image;
                if (i < (number_layers-1))
                  layer_info[i].image->next=layer_info[i+1].image;
                layer_info[i].image->page=layer_info[i].page;
              }
              image->next=layer_info[0].image;
              layer_info[0].image->previous=image;
            }
          layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);
        }
      else
        layer_info=DestroyLayerInfo(layer_info,number_layers);
    }

  return(status);
}
","ModuleExport MagickBooleanType ReadPSDLayers(Image *image,
  const ImageInfo *image_info,const PSDInfo *psd_info,
  const MagickBooleanType skip_layers,ExceptionInfo *exception)
{
  char
    type[4];

  LayerInfo
    *layer_info;

  MagickSizeType
    size;

  MagickBooleanType
    status;

  register ssize_t
    i;

  ssize_t
    count,
    j,
    number_layers;

  size=GetPSDSize(psd_info,image);
  if (size == 0)
    {
      /*
        Skip layers & masks.
      */
      (void) ReadBlobLong(image);
      count=ReadBlob(image,4,(unsigned char *) type);
      ReversePSDString(image,type,4);
      status=MagickFalse;
      if ((count == 0) || (LocaleNCompare(type,""8BIM"",4) != 0))
        return(MagickTrue);
      else
        {
          count=ReadBlob(image,4,(unsigned char *) type);
          ReversePSDString(image,type,4);
          if ((count != 0) && (LocaleNCompare(type,""Lr16"",4) == 0))
            size=GetPSDSize(psd_info,image);
          else
            return(MagickTrue);
        }
    }
  status=MagickTrue;
  if (size != 0)
    {
      layer_info=(LayerInfo *) NULL;
      number_layers=(short) ReadBlobShort(image);

      if (number_layers < 0)
        {
          /*
            The first alpha channel in the merged result contains the
            transparency data for the merged result.
          */
          number_layers=MagickAbsoluteValue(number_layers);
          if (image->debug != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  negative layer count corrected for"");
          image->matte=MagickTrue;
        }

      /*
        We only need to know if the image has an alpha channel
      */
      if (skip_layers != MagickFalse)
        return(MagickTrue);

      if (image->debug != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""  image contains %.20g layers"",(double) number_layers);

      if (number_layers == 0)
        ThrowBinaryException(CorruptImageError,""InvalidNumberOfLayers"",
          image->filename);

      layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,
        sizeof(*layer_info));
      if (layer_info == (LayerInfo *) NULL)
        {
          if (image->debug != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  allocation of LayerInfo failed"");
          ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
            image->filename);
        }
      (void) ResetMagickMemory(layer_info,0,(size_t) number_layers*
        sizeof(*layer_info));

      for (i=0; i < number_layers; i++)
      {
        ssize_t
          x,
          y;

        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  reading layer #%.20g"",(double) i+1);
        layer_info[i].page.y=ReadBlobSignedLong(image);
        layer_info[i].page.x=ReadBlobSignedLong(image);
        y=ReadBlobSignedLong(image);
        x=ReadBlobSignedLong(image);
        layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);
        layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);
        layer_info[i].channels=ReadBlobShort(image);
        if (layer_info[i].channels > MaxPSDChannels)
          {
            layer_info=DestroyLayerInfo(layer_info,number_layers);
            ThrowBinaryException(CorruptImageError,""MaximumChannelsExceeded"",
              image->filename);
          }
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g"",
            (double) layer_info[i].page.x,(double) layer_info[i].page.y,
            (double) layer_info[i].page.height,(double)
            layer_info[i].page.width,(double) layer_info[i].channels);
        for (j=0; j < (ssize_t) layer_info[i].channels; j++)
        {
          layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);
          layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,
            image);
          if (image->debug != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    channel[%.20g]: type=%.20g, size=%.20g"",(double) j,
              (double) layer_info[i].channel_info[j].type,
              (double) layer_info[i].channel_info[j].size);
        }
        count=ReadBlob(image,4,(unsigned char *) type);
        ReversePSDString(image,type,4);
        if ((count == 0) || (LocaleNCompare(type,""8BIM"",4) != 0))
          {
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  layer type was %.4s instead of 8BIM"", type);
            layer_info=DestroyLayerInfo(layer_info,number_layers);
            ThrowBinaryException(CorruptImageError,""ImproperImageHeader"",
              image->filename);
          }
        (void) ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);
        ReversePSDString(image,layer_info[i].blendkey,4);
        layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)
          ReadBlobByte(image));
        layer_info[i].clipping=(unsigned char) ReadBlobByte(image);
        layer_info[i].flags=(unsigned char) ReadBlobByte(image);
        layer_info[i].visible=!(layer_info[i].flags & 0x02);
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s"",
            layer_info[i].blendkey,(double) layer_info[i].opacity,
            layer_info[i].clipping ? ""true"" : ""false"",layer_info[i].flags,
            layer_info[i].visible ? ""true"" : ""false"");
        (void) ReadBlobByte(image);  /* filler */

        size=ReadBlobLong(image);
        if (size != 0)
          {
            MagickSizeType
              combined_length,
              length;

            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""    layer contains additional info"");
            length=ReadBlobLong(image);
            combined_length=length+4;
            if (length != 0)
              {
                /*
                  Layer mask info.
                */
                layer_info[i].mask.page.y=ReadBlobSignedLong(image);
                layer_info[i].mask.page.x=ReadBlobSignedLong(image);
                layer_info[i].mask.page.height=(size_t) (ReadBlobLong(image)-
                  layer_info[i].mask.page.y);
                layer_info[i].mask.page.width=(size_t) (ReadBlobLong(image)-
                  layer_info[i].mask.page.x);
                layer_info[i].mask.background=(unsigned char) ReadBlobByte(
                  image);
                layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);
                if (!(layer_info[i].mask.flags & 0x01))
                  {
                    layer_info[i].mask.page.y=layer_info[i].mask.page.y-
                      layer_info[i].page.y;
                    layer_info[i].mask.page.x=layer_info[i].mask.page.x-
                      layer_info[i].page.x;
                  }
                if (image->debug != MagickFalse)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g"",
                    (double) layer_info[i].mask.page.x,(double)
                    layer_info[i].mask.page.y,(double) layer_info[i].mask.page.width,
                    (double) layer_info[i].mask.page.height,(double)
                    ((MagickOffsetType) length)-18);
                /*
                  Skip over the rest of the layer mask information.
                */
                if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)
                  {
                    layer_info=DestroyLayerInfo(layer_info,number_layers);
                    ThrowBinaryException(CorruptImageError,""UnexpectedEndOfFile"",
                      image->filename);
                  }
              }
            length=ReadBlobLong(image);
            combined_length+=length+4;
            if (length != 0)
              {
                /*
                  Layer blending ranges info.
                */
                if (image->debug != MagickFalse)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      layer blending ranges: length=%.20g"",(double)
                    ((MagickOffsetType) length));
                /*
                  We read it, but don't use it...
                */
                for (j=0; j < (ssize_t) length; j+=8)
                {
                  size_t blend_source=ReadBlobLong(image);
                  size_t blend_dest=ReadBlobLong(image);
                  if (image->debug != MagickFalse)
                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                      ""        source(%x), dest(%x)"",(unsigned int)
                      blend_source,(unsigned int) blend_dest);
                }
              }
            /*
              Layer name.
            */
            length=(MagickSizeType) ReadBlobByte(image);
            combined_length+=length+1;
            if (length > 0)
              (void) ReadBlob(image,(size_t) length++,layer_info[i].name);
            layer_info[i].name[length]='\0';
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""      layer name: %s"",layer_info[i].name);
            if ((length % 4) != 0)
              {
                length=4-(length % 4);
                combined_length+=length;
                /* Skip over the padding of the layer name */
                if (DiscardBlobBytes(image,length) == MagickFalse)
                  {
                    layer_info=DestroyLayerInfo(layer_info,number_layers);
                    ThrowBinaryException(CorruptImageError,
                      ""UnexpectedEndOfFile"",image->filename);
                  }
              }
            length=(MagickSizeType) size-combined_length;
            if (length > 0)
              {
                unsigned char
                  *info;

                layer_info[i].info=AcquireStringInfo((const size_t) length);
                info=GetStringInfoDatum(layer_info[i].info);
                (void) ReadBlob(image,(const size_t) length,info);
              }
          }
      }

      for (i=0; i < number_layers; i++)
      {
        if ((layer_info[i].page.width == 0) ||
              (layer_info[i].page.height == 0))
          {
             if (image->debug != MagickFalse)
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""      layer data is empty"");
             continue;
           }
 
        /*
          Allocate layered image.
        */
        layer_info[i].image=CloneImage(image,layer_info[i].page.width,
          layer_info[i].page.height,MagickFalse,exception);
        if (layer_info[i].image == (Image *) NULL)
          {
            layer_info=DestroyLayerInfo(layer_info,number_layers);
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  allocation of image for layer %.20g failed"",(double) i);
            ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
              image->filename);
          }

        if (layer_info[i].info != (StringInfo *) NULL)
          {
            (void) SetImageProfile(layer_info[i].image,""psd:additional-info"",
              layer_info[i].info);
            layer_info[i].info=DestroyStringInfo(layer_info[i].info);
          }
      }

      if (image_info->ping == MagickFalse)
        {
          for (i=0; i < number_layers; i++)
          {
            if (layer_info[i].image == (Image *) NULL)
              {
                for (j=0; j < layer_info[i].channels; j++)
                {
                  if (DiscardBlobBytes(image,(MagickSizeType)
                      layer_info[i].channel_info[j].size) == MagickFalse)
                    {
                      layer_info=DestroyLayerInfo(layer_info,number_layers);
                      ThrowBinaryException(CorruptImageError,
                        ""UnexpectedEndOfFile"",image->filename);
                    }
                }
                continue;
              }

            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  reading data for layer %.20g"",(double) i);
            status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],
              exception);
            if (status == MagickFalse)
              break;

            status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)
              number_layers);
            if (status == MagickFalse)
              break;
          }
        }

      if (status != MagickFalse)
        {
          for (i=0; i < number_layers; i++)
          {
            if (layer_info[i].image == (Image *) NULL)
              {
                for (j=i; j < number_layers - 1; j++)
                  layer_info[j] = layer_info[j+1];
                number_layers--;
                i--;
              }
          }

          if (number_layers > 0)
            {
              for (i=0; i < number_layers; i++)
              {
                if (i > 0)
                  layer_info[i].image->previous=layer_info[i-1].image;
                if (i < (number_layers-1))
                  layer_info[i].image->next=layer_info[i+1].image;
                layer_info[i].image->page=layer_info[i].page;
              }
              image->next=layer_info[0].image;
              layer_info[0].image->previous=image;
            }
          layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);
        }
      else
        layer_info=DestroyLayerInfo(layer_info,number_layers);
    }

  return(status);
}
",C,"            if (layer_info[i].info != (StringInfo *) NULL)
              layer_info[i].info=DestroyStringInfo(layer_info[i].info);
",,,"@@ -1719,6 +1719,8 @@ ModuleExport MagickBooleanType ReadPSDLayers(Image *image,
             if (image->debug != MagickFalse)
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""      layer data is empty"");
+            if (layer_info[i].info != (StringInfo *) NULL)
+              layer_info[i].info=DestroyStringInfo(layer_info[i].info);
             continue;
           }
 ",ImageMagick,4ec444f4eab88cf4bec664fafcf9cab50bc5ff6a,a308dc38a164c638f4cf87c8c347c3ac91062c6b,1,"ModuleExport MagickBooleanType ReadPSDLayers(Image *image,
  const ImageInfo *image_info,const PSDInfo *psd_info,
  const MagickBooleanType skip_layers,ExceptionInfo *exception)
{
  char
    type[4];

  LayerInfo
    *layer_info;

  MagickSizeType
    size;

  MagickBooleanType
    status;

  register ssize_t
    i;

  ssize_t
    count,
    j,
    number_layers;

  size=GetPSDSize(psd_info,image);
  if (size == 0)
    {
      /*
        Skip layers & masks.
      */
      (void) ReadBlobLong(image);
      count=ReadBlob(image,4,(unsigned char *) type);
      ReversePSDString(image,type,4);
      status=MagickFalse;
      if ((count == 0) || (LocaleNCompare(type,""8BIM"",4) != 0))
        return(MagickTrue);
      else
        {
          count=ReadBlob(image,4,(unsigned char *) type);
          ReversePSDString(image,type,4);
          if ((count != 0) && (LocaleNCompare(type,""Lr16"",4) == 0))
            size=GetPSDSize(psd_info,image);
          else
            return(MagickTrue);
        }
    }
  status=MagickTrue;
  if (size != 0)
    {
      layer_info=(LayerInfo *) NULL;
      number_layers=(short) ReadBlobShort(image);

      if (number_layers < 0)
        {
          /*
            The first alpha channel in the merged result contains the
            transparency data for the merged result.
          */
          number_layers=MagickAbsoluteValue(number_layers);
          if (image->debug != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  negative layer count corrected for"");
          image->matte=MagickTrue;
        }

      /*
        We only need to know if the image has an alpha channel
      */
      if (skip_layers != MagickFalse)
        return(MagickTrue);

      if (image->debug != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""  image contains %.20g layers"",(double) number_layers);

      if (number_layers == 0)
        ThrowBinaryException(CorruptImageError,""InvalidNumberOfLayers"",
          image->filename);

      layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,
        sizeof(*layer_info));
      if (layer_info == (LayerInfo *) NULL)
        {
          if (image->debug != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  allocation of LayerInfo failed"");
          ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
            image->filename);
        }
      (void) ResetMagickMemory(layer_info,0,(size_t) number_layers*
        sizeof(*layer_info));

      for (i=0; i < number_layers; i++)
      {
        ssize_t
          x,
          y;

        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  reading layer #%.20g"",(double) i+1);
        layer_info[i].page.y=ReadBlobSignedLong(image);
        layer_info[i].page.x=ReadBlobSignedLong(image);
        y=ReadBlobSignedLong(image);
        x=ReadBlobSignedLong(image);
        layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);
        layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);
        layer_info[i].channels=ReadBlobShort(image);
        if (layer_info[i].channels > MaxPSDChannels)
          {
            layer_info=DestroyLayerInfo(layer_info,number_layers);
            ThrowBinaryException(CorruptImageError,""MaximumChannelsExceeded"",
              image->filename);
          }
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g"",
            (double) layer_info[i].page.x,(double) layer_info[i].page.y,
            (double) layer_info[i].page.height,(double)
            layer_info[i].page.width,(double) layer_info[i].channels);
        for (j=0; j < (ssize_t) layer_info[i].channels; j++)
        {
          layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);
          layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,
            image);
          if (image->debug != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    channel[%.20g]: type=%.20g, size=%.20g"",(double) j,
              (double) layer_info[i].channel_info[j].type,
              (double) layer_info[i].channel_info[j].size);
        }
        count=ReadBlob(image,4,(unsigned char *) type);
        ReversePSDString(image,type,4);
        if ((count == 0) || (LocaleNCompare(type,""8BIM"",4) != 0))
          {
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  layer type was %.4s instead of 8BIM"", type);
            layer_info=DestroyLayerInfo(layer_info,number_layers);
            ThrowBinaryException(CorruptImageError,""ImproperImageHeader"",
              image->filename);
          }
        (void) ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);
        ReversePSDString(image,layer_info[i].blendkey,4);
        layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)
          ReadBlobByte(image));
        layer_info[i].clipping=(unsigned char) ReadBlobByte(image);
        layer_info[i].flags=(unsigned char) ReadBlobByte(image);
        layer_info[i].visible=!(layer_info[i].flags & 0x02);
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s"",
            layer_info[i].blendkey,(double) layer_info[i].opacity,
            layer_info[i].clipping ? ""true"" : ""false"",layer_info[i].flags,
            layer_info[i].visible ? ""true"" : ""false"");
        (void) ReadBlobByte(image);  /* filler */

        size=ReadBlobLong(image);
        if (size != 0)
          {
            MagickSizeType
              combined_length,
              length;

            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""    layer contains additional info"");
            length=ReadBlobLong(image);
            combined_length=length+4;
            if (length != 0)
              {
                /*
                  Layer mask info.
                */
                layer_info[i].mask.page.y=ReadBlobSignedLong(image);
                layer_info[i].mask.page.x=ReadBlobSignedLong(image);
                layer_info[i].mask.page.height=(size_t) (ReadBlobLong(image)-
                  layer_info[i].mask.page.y);
                layer_info[i].mask.page.width=(size_t) (ReadBlobLong(image)-
                  layer_info[i].mask.page.x);
                layer_info[i].mask.background=(unsigned char) ReadBlobByte(
                  image);
                layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);
                if (!(layer_info[i].mask.flags & 0x01))
                  {
                    layer_info[i].mask.page.y=layer_info[i].mask.page.y-
                      layer_info[i].page.y;
                    layer_info[i].mask.page.x=layer_info[i].mask.page.x-
                      layer_info[i].page.x;
                  }
                if (image->debug != MagickFalse)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g"",
                    (double) layer_info[i].mask.page.x,(double)
                    layer_info[i].mask.page.y,(double) layer_info[i].mask.page.width,
                    (double) layer_info[i].mask.page.height,(double)
                    ((MagickOffsetType) length)-18);
                /*
                  Skip over the rest of the layer mask information.
                */
                if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)
                  {
                    layer_info=DestroyLayerInfo(layer_info,number_layers);
                    ThrowBinaryException(CorruptImageError,""UnexpectedEndOfFile"",
                      image->filename);
                  }
              }
            length=ReadBlobLong(image);
            combined_length+=length+4;
            if (length != 0)
              {
                /*
                  Layer blending ranges info.
                */
                if (image->debug != MagickFalse)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      layer blending ranges: length=%.20g"",(double)
                    ((MagickOffsetType) length));
                /*
                  We read it, but don't use it...
                */
                for (j=0; j < (ssize_t) length; j+=8)
                {
                  size_t blend_source=ReadBlobLong(image);
                  size_t blend_dest=ReadBlobLong(image);
                  if (image->debug != MagickFalse)
                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                      ""        source(%x), dest(%x)"",(unsigned int)
                      blend_source,(unsigned int) blend_dest);
                }
              }
            /*
              Layer name.
            */
            length=(MagickSizeType) ReadBlobByte(image);
            combined_length+=length+1;
            if (length > 0)
              (void) ReadBlob(image,(size_t) length++,layer_info[i].name);
            layer_info[i].name[length]='\0';
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""      layer name: %s"",layer_info[i].name);
            if ((length % 4) != 0)
              {
                length=4-(length % 4);
                combined_length+=length;
                /* Skip over the padding of the layer name */
                if (DiscardBlobBytes(image,length) == MagickFalse)
                  {
                    layer_info=DestroyLayerInfo(layer_info,number_layers);
                    ThrowBinaryException(CorruptImageError,
                      ""UnexpectedEndOfFile"",image->filename);
                  }
              }
            length=(MagickSizeType) size-combined_length;
            if (length > 0)
              {
                unsigned char
                  *info;

                layer_info[i].info=AcquireStringInfo((const size_t) length);
                info=GetStringInfoDatum(layer_info[i].info);
                (void) ReadBlob(image,(const size_t) length,info);
              }
          }
      }

      for (i=0; i < number_layers; i++)
      {
        if ((layer_info[i].page.width == 0) ||
              (layer_info[i].page.height == 0))
          {
             if (image->debug != MagickFalse)
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""      layer data is empty"");
//fix_flaw_line_below:
//            if (layer_info[i].info != (StringInfo *) NULL)
//fix_flaw_line_below:
//              layer_info[i].info=DestroyStringInfo(layer_info[i].info);
             continue;
           }
 
        /*
          Allocate layered image.
        */
        layer_info[i].image=CloneImage(image,layer_info[i].page.width,
          layer_info[i].page.height,MagickFalse,exception);
        if (layer_info[i].image == (Image *) NULL)
          {
            layer_info=DestroyLayerInfo(layer_info,number_layers);
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  allocation of image for layer %.20g failed"",(double) i);
            ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
              image->filename);
          }

        if (layer_info[i].info != (StringInfo *) NULL)
          {
            (void) SetImageProfile(layer_info[i].image,""psd:additional-info"",
              layer_info[i].info);
            layer_info[i].info=DestroyStringInfo(layer_info[i].info);
          }
      }

      if (image_info->ping == MagickFalse)
        {
          for (i=0; i < number_layers; i++)
          {
            if (layer_info[i].image == (Image *) NULL)
              {
                for (j=0; j < layer_info[i].channels; j++)
                {
                  if (DiscardBlobBytes(image,(MagickSizeType)
                      layer_info[i].channel_info[j].size) == MagickFalse)
                    {
                      layer_info=DestroyLayerInfo(layer_info,number_layers);
                      ThrowBinaryException(CorruptImageError,
                        ""UnexpectedEndOfFile"",image->filename);
                    }
                }
                continue;
              }

            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  reading data for layer %.20g"",(double) i);
            status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],
              exception);
            if (status == MagickFalse)
              break;

            status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)
              number_layers);
            if (status == MagickFalse)
              break;
          }
        }

      if (status != MagickFalse)
        {
          for (i=0; i < number_layers; i++)
          {
            if (layer_info[i].image == (Image *) NULL)
              {
                for (j=i; j < number_layers - 1; j++)
                  layer_info[j] = layer_info[j+1];
                number_layers--;
                i--;
              }
          }

          if (number_layers > 0)
            {
              for (i=0; i < number_layers; i++)
              {
                if (i > 0)
                  layer_info[i].image->previous=layer_info[i-1].image;
                if (i < (number_layers-1))
                  layer_info[i].image->next=layer_info[i+1].image;
                layer_info[i].image->page=layer_info[i].page;
              }
              image->next=layer_info[0].image;
              layer_info[0].image->previous=image;
            }
          layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);
        }
      else
        layer_info=DestroyLayerInfo(layer_info,number_layers);
    }

  return(status);
}
"
4395,182131,,Local,Not required,Complete,CVE-2018-20169,https://www.cvedetails.com/cve/CVE-2018-20169/,CWE-400,Low,Complete,Complete,,2018-12-17,7.2,"An issue was discovered in the Linux kernel before 4.19.9. The USB subsystem mishandles size checks during the reading of an extra descriptor, related to __usb_get_extra_descriptor in drivers/usb/core/usb.c.",2019-08-13,,1,https://github.com/torvalds/linux/commit/704620afc70cf47abb9d6a1a57f3825d2bca49cf,704620afc70cf47abb9d6a1a57f3825d2bca49cf,"USB: check usb_get_extra_descriptor for proper size

When reading an extra descriptor, we need to properly check the minimum
and maximum size allowed, to prevent from invalid data being sent by a
device.

Reported-by: Hui Peng <benquike@gmail.com>
Reported-by: Mathias Payer <mathias.payer@nebelwelt.net>
Co-developed-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Hui Peng <benquike@gmail.com>
Signed-off-by: Mathias Payer <mathias.payer@nebelwelt.net>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Cc: stable <stable@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",1,drivers/usb/core/hub.c,"{""sha"": ""f76b2e0aba9d5f11d994cd06ebe217f283bada16"", ""filename"": ""drivers/usb/core/hub.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/704620afc70cf47abb9d6a1a57f3825d2bca49cf/drivers/usb/core/hub.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/704620afc70cf47abb9d6a1a57f3825d2bca49cf/drivers/usb/core/hub.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/core/hub.c?ref=704620afc70cf47abb9d6a1a57f3825d2bca49cf"", ""patch"": ""@@ -2251,7 +2251,7 @@ static int usb_enumerate_device_otg(struct usb_device *udev)\n \t\t/* descriptor may appear anywhere in config */\n \t\terr = __usb_get_extra_descriptor(udev->rawdescriptors[0],\n \t\t\t\tle16_to_cpu(udev->config[0].desc.wTotalLength),\n-\t\t\t\tUSB_DT_OTG, (void **) &desc);\n+\t\t\t\tUSB_DT_OTG, (void **) &desc, sizeof(*desc));\n \t\tif (err || !(desc->bmAttributes & USB_OTG_HNP))\n \t\t\treturn 0;\n ""}<_**next**_>{""sha"": ""4ebfbd737905169d1b96904952576defbd01e8f1"", ""filename"": ""drivers/usb/core/usb.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/704620afc70cf47abb9d6a1a57f3825d2bca49cf/drivers/usb/core/usb.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/704620afc70cf47abb9d6a1a57f3825d2bca49cf/drivers/usb/core/usb.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/core/usb.c?ref=704620afc70cf47abb9d6a1a57f3825d2bca49cf"", ""patch"": ""@@ -832,14 +832,14 @@ EXPORT_SYMBOL_GPL(usb_get_current_frame_number);\n  */\n \n int __usb_get_extra_descriptor(char *buffer, unsigned size,\n-\t\t\t       unsigned char type, void **ptr)\n+\t\t\t       unsigned char type, void **ptr, size_t minsize)\n {\n \tstruct usb_descriptor_header *header;\n \n \twhile (size >= sizeof(struct usb_descriptor_header)) {\n \t\theader = (struct usb_descriptor_header *)buffer;\n \n-\t\tif (header->bLength < 2) {\n+\t\tif (header->bLength < 2 || header->bLength > size) {\n \t\t\tprintk(KERN_ERR\n \t\t\t\t\""%s: bogus descriptor, type %d length %d\\n\"",\n \t\t\t\tusbcore_name,\n@@ -848,7 +848,7 @@ int __usb_get_extra_descriptor(char *buffer, unsigned size,\n \t\t\treturn -1;\n \t\t}\n \n-\t\tif (header->bDescriptorType == type) {\n+\t\tif (header->bDescriptorType == type && header->bLength >= minsize) {\n \t\t\t*ptr = header;\n \t\t\treturn 0;\n \t\t}""}<_**next**_>{""sha"": ""09a8ebd955888d6d375d7cee3d0fc53fd1cf0d9c"", ""filename"": ""drivers/usb/host/hwa-hc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/704620afc70cf47abb9d6a1a57f3825d2bca49cf/drivers/usb/host/hwa-hc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/704620afc70cf47abb9d6a1a57f3825d2bca49cf/drivers/usb/host/hwa-hc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/host/hwa-hc.c?ref=704620afc70cf47abb9d6a1a57f3825d2bca49cf"", ""patch"": ""@@ -640,7 +640,7 @@ static int hwahc_security_create(struct hwahc *hwahc)\n \ttop = itr + itr_size;\n \tresult = __usb_get_extra_descriptor(usb_dev->rawdescriptors[index],\n \t\t\tle16_to_cpu(usb_dev->actconfig->desc.wTotalLength),\n-\t\t\tUSB_DT_SECURITY, (void **) &secd);\n+\t\t\tUSB_DT_SECURITY, (void **) &secd, sizeof(*secd));\n \tif (result == -1) {\n \t\tdev_warn(dev, \""BUG? WUSB host has no security descriptors\\n\"");\n \t\treturn 0;""}<_**next**_>{""sha"": ""5e49e82c43684854c379e18a1d698d79ac4ef347"", ""filename"": ""include/linux/usb.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/704620afc70cf47abb9d6a1a57f3825d2bca49cf/include/linux/usb.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/704620afc70cf47abb9d6a1a57f3825d2bca49cf/include/linux/usb.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/usb.h?ref=704620afc70cf47abb9d6a1a57f3825d2bca49cf"", ""patch"": ""@@ -407,11 +407,11 @@ struct usb_host_bos {\n };\n \n int __usb_get_extra_descriptor(char *buffer, unsigned size,\n-\tunsigned char type, void **ptr);\n+\tunsigned char type, void **ptr, size_t min);\n #define usb_get_extra_descriptor(ifpoint, type, ptr) \\\n \t\t\t\t__usb_get_extra_descriptor((ifpoint)->extra, \\\n \t\t\t\t(ifpoint)->extralen, \\\n-\t\t\t\ttype, (void **)ptr)\n+\t\t\t\ttype, (void **)ptr, sizeof(**(ptr)))\n \n /* ----------------------------------------------------------------------- */\n ""}","static int usb_enumerate_device_otg(struct usb_device *udev)
{
	int err = 0;

#ifdef	CONFIG_USB_OTG
	/*
	 * OTG-aware devices on OTG-capable root hubs may be able to use SRP,
	 * to wake us after we've powered off VBUS; and HNP, switching roles
	 * ""host"" to ""peripheral"".  The OTG descriptor helps figure this out.
	 */
	if (!udev->bus->is_b_host
			&& udev->config
			&& udev->parent == udev->bus->root_hub) {
		struct usb_otg_descriptor	*desc = NULL;
		struct usb_bus			*bus = udev->bus;
		unsigned			port1 = udev->portnum;

 		/* descriptor may appear anywhere in config */
 		err = __usb_get_extra_descriptor(udev->rawdescriptors[0],
 				le16_to_cpu(udev->config[0].desc.wTotalLength),
				USB_DT_OTG, (void **) &desc, sizeof(*desc));
 		if (err || !(desc->bmAttributes & USB_OTG_HNP))
 			return 0;
 
		dev_info(&udev->dev, ""Dual-Role OTG device on %sHNP port\n"",
					(port1 == bus->otg_port) ? """" : ""non-"");

		/* enable HNP before suspend, it's simpler */
		if (port1 == bus->otg_port) {
			bus->b_hnp_enable = 1;
			err = usb_control_msg(udev,
				usb_sndctrlpipe(udev, 0),
				USB_REQ_SET_FEATURE, 0,
				USB_DEVICE_B_HNP_ENABLE,
				0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
			if (err < 0) {
				/*
				 * OTG MESSAGE: report errors here,
				 * customize to match your product.
				 */
				dev_err(&udev->dev, ""can't set HNP mode: %d\n"",
									err);
				bus->b_hnp_enable = 0;
			}
		} else if (desc->bLength == sizeof
				(struct usb_otg_descriptor)) {
			/* Set a_alt_hnp_support for legacy otg device */
			err = usb_control_msg(udev,
				usb_sndctrlpipe(udev, 0),
				USB_REQ_SET_FEATURE, 0,
				USB_DEVICE_A_ALT_HNP_SUPPORT,
				0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
			if (err < 0)
				dev_err(&udev->dev,
					""set a_alt_hnp_support failed: %d\n"",
					err);
		}
	}
#endif
	return err;
}
","static int usb_enumerate_device_otg(struct usb_device *udev)
{
	int err = 0;

#ifdef	CONFIG_USB_OTG
	/*
	 * OTG-aware devices on OTG-capable root hubs may be able to use SRP,
	 * to wake us after we've powered off VBUS; and HNP, switching roles
	 * ""host"" to ""peripheral"".  The OTG descriptor helps figure this out.
	 */
	if (!udev->bus->is_b_host
			&& udev->config
			&& udev->parent == udev->bus->root_hub) {
		struct usb_otg_descriptor	*desc = NULL;
		struct usb_bus			*bus = udev->bus;
		unsigned			port1 = udev->portnum;

 		/* descriptor may appear anywhere in config */
 		err = __usb_get_extra_descriptor(udev->rawdescriptors[0],
 				le16_to_cpu(udev->config[0].desc.wTotalLength),
				USB_DT_OTG, (void **) &desc);
 		if (err || !(desc->bmAttributes & USB_OTG_HNP))
 			return 0;
 
		dev_info(&udev->dev, ""Dual-Role OTG device on %sHNP port\n"",
					(port1 == bus->otg_port) ? """" : ""non-"");

		/* enable HNP before suspend, it's simpler */
		if (port1 == bus->otg_port) {
			bus->b_hnp_enable = 1;
			err = usb_control_msg(udev,
				usb_sndctrlpipe(udev, 0),
				USB_REQ_SET_FEATURE, 0,
				USB_DEVICE_B_HNP_ENABLE,
				0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
			if (err < 0) {
				/*
				 * OTG MESSAGE: report errors here,
				 * customize to match your product.
				 */
				dev_err(&udev->dev, ""can't set HNP mode: %d\n"",
									err);
				bus->b_hnp_enable = 0;
			}
		} else if (desc->bLength == sizeof
				(struct usb_otg_descriptor)) {
			/* Set a_alt_hnp_support for legacy otg device */
			err = usb_control_msg(udev,
				usb_sndctrlpipe(udev, 0),
				USB_REQ_SET_FEATURE, 0,
				USB_DEVICE_A_ALT_HNP_SUPPORT,
				0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
			if (err < 0)
				dev_err(&udev->dev,
					""set a_alt_hnp_support failed: %d\n"",
					err);
		}
	}
#endif
	return err;
}
",C,"				USB_DT_OTG, (void **) &desc, sizeof(*desc));
","				USB_DT_OTG, (void **) &desc);
",,"@@ -2251,7 +2251,7 @@ static int usb_enumerate_device_otg(struct usb_device *udev)
 		/* descriptor may appear anywhere in config */
 		err = __usb_get_extra_descriptor(udev->rawdescriptors[0],
 				le16_to_cpu(udev->config[0].desc.wTotalLength),
-				USB_DT_OTG, (void **) &desc);
+				USB_DT_OTG, (void **) &desc, sizeof(*desc));
 		if (err || !(desc->bmAttributes & USB_OTG_HNP))
 			return 0;
 ",linux,704620afc70cf47abb9d6a1a57f3825d2bca49cf,2f2dde6ba89b1ef1fe23c1138131b315d9aa4019,1,"static int usb_enumerate_device_otg(struct usb_device *udev)
{
	int err = 0;

#ifdef	CONFIG_USB_OTG
	/*
	 * OTG-aware devices on OTG-capable root hubs may be able to use SRP,
	 * to wake us after we've powered off VBUS; and HNP, switching roles
	 * ""host"" to ""peripheral"".  The OTG descriptor helps figure this out.
	 */
	if (!udev->bus->is_b_host
			&& udev->config
			&& udev->parent == udev->bus->root_hub) {
		struct usb_otg_descriptor	*desc = NULL;
		struct usb_bus			*bus = udev->bus;
		unsigned			port1 = udev->portnum;

 		/* descriptor may appear anywhere in config */
 		err = __usb_get_extra_descriptor(udev->rawdescriptors[0],
 				le16_to_cpu(udev->config[0].desc.wTotalLength),
//flaw_line_below:
				USB_DT_OTG, (void **) &desc);
//fix_flaw_line_below:
//				USB_DT_OTG, (void **) &desc, sizeof(*desc));
 		if (err || !(desc->bmAttributes & USB_OTG_HNP))
 			return 0;
 
		dev_info(&udev->dev, ""Dual-Role OTG device on %sHNP port\n"",
					(port1 == bus->otg_port) ? """" : ""non-"");

		/* enable HNP before suspend, it's simpler */
		if (port1 == bus->otg_port) {
			bus->b_hnp_enable = 1;
			err = usb_control_msg(udev,
				usb_sndctrlpipe(udev, 0),
				USB_REQ_SET_FEATURE, 0,
				USB_DEVICE_B_HNP_ENABLE,
				0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
			if (err < 0) {
				/*
				 * OTG MESSAGE: report errors here,
				 * customize to match your product.
				 */
				dev_err(&udev->dev, ""can't set HNP mode: %d\n"",
									err);
				bus->b_hnp_enable = 0;
			}
		} else if (desc->bLength == sizeof
				(struct usb_otg_descriptor)) {
			/* Set a_alt_hnp_support for legacy otg device */
			err = usb_control_msg(udev,
				usb_sndctrlpipe(udev, 0),
				USB_REQ_SET_FEATURE, 0,
				USB_DEVICE_A_ALT_HNP_SUPPORT,
				0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
			if (err < 0)
				dev_err(&udev->dev,
					""set a_alt_hnp_support failed: %d\n"",
					err);
		}
	}
#endif
	return err;
}
"
4396,182132,,Local,Not required,Complete,CVE-2018-20169,https://www.cvedetails.com/cve/CVE-2018-20169/,CWE-400,Low,Complete,Complete,,2018-12-17,7.2,"An issue was discovered in the Linux kernel before 4.19.9. The USB subsystem mishandles size checks during the reading of an extra descriptor, related to __usb_get_extra_descriptor in drivers/usb/core/usb.c.",2019-08-13,,3,https://github.com/torvalds/linux/commit/704620afc70cf47abb9d6a1a57f3825d2bca49cf,704620afc70cf47abb9d6a1a57f3825d2bca49cf,"USB: check usb_get_extra_descriptor for proper size

When reading an extra descriptor, we need to properly check the minimum
and maximum size allowed, to prevent from invalid data being sent by a
device.

Reported-by: Hui Peng <benquike@gmail.com>
Reported-by: Mathias Payer <mathias.payer@nebelwelt.net>
Co-developed-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Hui Peng <benquike@gmail.com>
Signed-off-by: Mathias Payer <mathias.payer@nebelwelt.net>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Cc: stable <stable@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",3,drivers/usb/core/usb.c,"{""sha"": ""f76b2e0aba9d5f11d994cd06ebe217f283bada16"", ""filename"": ""drivers/usb/core/hub.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/704620afc70cf47abb9d6a1a57f3825d2bca49cf/drivers/usb/core/hub.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/704620afc70cf47abb9d6a1a57f3825d2bca49cf/drivers/usb/core/hub.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/core/hub.c?ref=704620afc70cf47abb9d6a1a57f3825d2bca49cf"", ""patch"": ""@@ -2251,7 +2251,7 @@ static int usb_enumerate_device_otg(struct usb_device *udev)\n \t\t/* descriptor may appear anywhere in config */\n \t\terr = __usb_get_extra_descriptor(udev->rawdescriptors[0],\n \t\t\t\tle16_to_cpu(udev->config[0].desc.wTotalLength),\n-\t\t\t\tUSB_DT_OTG, (void **) &desc);\n+\t\t\t\tUSB_DT_OTG, (void **) &desc, sizeof(*desc));\n \t\tif (err || !(desc->bmAttributes & USB_OTG_HNP))\n \t\t\treturn 0;\n ""}<_**next**_>{""sha"": ""4ebfbd737905169d1b96904952576defbd01e8f1"", ""filename"": ""drivers/usb/core/usb.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/704620afc70cf47abb9d6a1a57f3825d2bca49cf/drivers/usb/core/usb.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/704620afc70cf47abb9d6a1a57f3825d2bca49cf/drivers/usb/core/usb.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/core/usb.c?ref=704620afc70cf47abb9d6a1a57f3825d2bca49cf"", ""patch"": ""@@ -832,14 +832,14 @@ EXPORT_SYMBOL_GPL(usb_get_current_frame_number);\n  */\n \n int __usb_get_extra_descriptor(char *buffer, unsigned size,\n-\t\t\t       unsigned char type, void **ptr)\n+\t\t\t       unsigned char type, void **ptr, size_t minsize)\n {\n \tstruct usb_descriptor_header *header;\n \n \twhile (size >= sizeof(struct usb_descriptor_header)) {\n \t\theader = (struct usb_descriptor_header *)buffer;\n \n-\t\tif (header->bLength < 2) {\n+\t\tif (header->bLength < 2 || header->bLength > size) {\n \t\t\tprintk(KERN_ERR\n \t\t\t\t\""%s: bogus descriptor, type %d length %d\\n\"",\n \t\t\t\tusbcore_name,\n@@ -848,7 +848,7 @@ int __usb_get_extra_descriptor(char *buffer, unsigned size,\n \t\t\treturn -1;\n \t\t}\n \n-\t\tif (header->bDescriptorType == type) {\n+\t\tif (header->bDescriptorType == type && header->bLength >= minsize) {\n \t\t\t*ptr = header;\n \t\t\treturn 0;\n \t\t}""}<_**next**_>{""sha"": ""09a8ebd955888d6d375d7cee3d0fc53fd1cf0d9c"", ""filename"": ""drivers/usb/host/hwa-hc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/704620afc70cf47abb9d6a1a57f3825d2bca49cf/drivers/usb/host/hwa-hc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/704620afc70cf47abb9d6a1a57f3825d2bca49cf/drivers/usb/host/hwa-hc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/host/hwa-hc.c?ref=704620afc70cf47abb9d6a1a57f3825d2bca49cf"", ""patch"": ""@@ -640,7 +640,7 @@ static int hwahc_security_create(struct hwahc *hwahc)\n \ttop = itr + itr_size;\n \tresult = __usb_get_extra_descriptor(usb_dev->rawdescriptors[index],\n \t\t\tle16_to_cpu(usb_dev->actconfig->desc.wTotalLength),\n-\t\t\tUSB_DT_SECURITY, (void **) &secd);\n+\t\t\tUSB_DT_SECURITY, (void **) &secd, sizeof(*secd));\n \tif (result == -1) {\n \t\tdev_warn(dev, \""BUG? WUSB host has no security descriptors\\n\"");\n \t\treturn 0;""}<_**next**_>{""sha"": ""5e49e82c43684854c379e18a1d698d79ac4ef347"", ""filename"": ""include/linux/usb.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/704620afc70cf47abb9d6a1a57f3825d2bca49cf/include/linux/usb.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/704620afc70cf47abb9d6a1a57f3825d2bca49cf/include/linux/usb.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/usb.h?ref=704620afc70cf47abb9d6a1a57f3825d2bca49cf"", ""patch"": ""@@ -407,11 +407,11 @@ struct usb_host_bos {\n };\n \n int __usb_get_extra_descriptor(char *buffer, unsigned size,\n-\tunsigned char type, void **ptr);\n+\tunsigned char type, void **ptr, size_t min);\n #define usb_get_extra_descriptor(ifpoint, type, ptr) \\\n \t\t\t\t__usb_get_extra_descriptor((ifpoint)->extra, \\\n \t\t\t\t(ifpoint)->extralen, \\\n-\t\t\t\ttype, (void **)ptr)\n+\t\t\t\ttype, (void **)ptr, sizeof(**(ptr)))\n \n /* ----------------------------------------------------------------------- */\n ""}"," int __usb_get_extra_descriptor(char *buffer, unsigned size,
			       unsigned char type, void **ptr, size_t minsize)
 {
 	struct usb_descriptor_header *header;
 
 	while (size >= sizeof(struct usb_descriptor_header)) {
 		header = (struct usb_descriptor_header *)buffer;
 
		if (header->bLength < 2 || header->bLength > size) {
 			printk(KERN_ERR
 				""%s: bogus descriptor, type %d length %d\n"",
 				usbcore_name,
				header->bDescriptorType,
				header->bLength);
 			return -1;
 		}
 
		if (header->bDescriptorType == type && header->bLength >= minsize) {
 			*ptr = header;
 			return 0;
 		}

		buffer += header->bLength;
		size -= header->bLength;
	}
	return -1;
}
"," int __usb_get_extra_descriptor(char *buffer, unsigned size,
			       unsigned char type, void **ptr)
 {
 	struct usb_descriptor_header *header;
 
 	while (size >= sizeof(struct usb_descriptor_header)) {
 		header = (struct usb_descriptor_header *)buffer;
 
		if (header->bLength < 2) {
 			printk(KERN_ERR
 				""%s: bogus descriptor, type %d length %d\n"",
 				usbcore_name,
				header->bDescriptorType,
				header->bLength);
 			return -1;
 		}
 
		if (header->bDescriptorType == type) {
 			*ptr = header;
 			return 0;
 		}

		buffer += header->bLength;
		size -= header->bLength;
	}
	return -1;
}
",C,"			       unsigned char type, void **ptr, size_t minsize)
		if (header->bLength < 2 || header->bLength > size) {
		if (header->bDescriptorType == type && header->bLength >= minsize) {
","			       unsigned char type, void **ptr)
		if (header->bLength < 2) {
		if (header->bDescriptorType == type) {
",,"@@ -832,14 +832,14 @@ EXPORT_SYMBOL_GPL(usb_get_current_frame_number);
  */
 
 int __usb_get_extra_descriptor(char *buffer, unsigned size,
-			       unsigned char type, void **ptr)
+			       unsigned char type, void **ptr, size_t minsize)
 {
 	struct usb_descriptor_header *header;
 
 	while (size >= sizeof(struct usb_descriptor_header)) {
 		header = (struct usb_descriptor_header *)buffer;
 
-		if (header->bLength < 2) {
+		if (header->bLength < 2 || header->bLength > size) {
 			printk(KERN_ERR
 				""%s: bogus descriptor, type %d length %d\n"",
 				usbcore_name,
@@ -848,7 +848,7 @@ int __usb_get_extra_descriptor(char *buffer, unsigned size,
 			return -1;
 		}
 
-		if (header->bDescriptorType == type) {
+		if (header->bDescriptorType == type && header->bLength >= minsize) {
 			*ptr = header;
 			return 0;
 		}",linux,704620afc70cf47abb9d6a1a57f3825d2bca49cf,2f2dde6ba89b1ef1fe23c1138131b315d9aa4019,1," int __usb_get_extra_descriptor(char *buffer, unsigned size,
//flaw_line_below:
			       unsigned char type, void **ptr)
//fix_flaw_line_below:
//			       unsigned char type, void **ptr, size_t minsize)
 {
 	struct usb_descriptor_header *header;
 
 	while (size >= sizeof(struct usb_descriptor_header)) {
 		header = (struct usb_descriptor_header *)buffer;
 
//flaw_line_below:
		if (header->bLength < 2) {
//fix_flaw_line_below:
//		if (header->bLength < 2 || header->bLength > size) {
 			printk(KERN_ERR
 				""%s: bogus descriptor, type %d length %d\n"",
 				usbcore_name,
				header->bDescriptorType,
				header->bLength);
 			return -1;
 		}
 
//flaw_line_below:
		if (header->bDescriptorType == type) {
//fix_flaw_line_below:
//		if (header->bDescriptorType == type && header->bLength >= minsize) {
 			*ptr = header;
 			return 0;
 		}

		buffer += header->bLength;
		size -= header->bLength;
	}
	return -1;
}
"
4397,182133,,Local,Not required,Complete,CVE-2018-20169,https://www.cvedetails.com/cve/CVE-2018-20169/,CWE-400,Low,Complete,Complete,,2018-12-17,7.2,"An issue was discovered in the Linux kernel before 4.19.9. The USB subsystem mishandles size checks during the reading of an extra descriptor, related to __usb_get_extra_descriptor in drivers/usb/core/usb.c.",2019-08-13,,1,https://github.com/torvalds/linux/commit/704620afc70cf47abb9d6a1a57f3825d2bca49cf,704620afc70cf47abb9d6a1a57f3825d2bca49cf,"USB: check usb_get_extra_descriptor for proper size

When reading an extra descriptor, we need to properly check the minimum
and maximum size allowed, to prevent from invalid data being sent by a
device.

Reported-by: Hui Peng <benquike@gmail.com>
Reported-by: Mathias Payer <mathias.payer@nebelwelt.net>
Co-developed-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Hui Peng <benquike@gmail.com>
Signed-off-by: Mathias Payer <mathias.payer@nebelwelt.net>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Cc: stable <stable@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",1,drivers/usb/host/hwa-hc.c,"{""sha"": ""f76b2e0aba9d5f11d994cd06ebe217f283bada16"", ""filename"": ""drivers/usb/core/hub.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/704620afc70cf47abb9d6a1a57f3825d2bca49cf/drivers/usb/core/hub.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/704620afc70cf47abb9d6a1a57f3825d2bca49cf/drivers/usb/core/hub.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/core/hub.c?ref=704620afc70cf47abb9d6a1a57f3825d2bca49cf"", ""patch"": ""@@ -2251,7 +2251,7 @@ static int usb_enumerate_device_otg(struct usb_device *udev)\n \t\t/* descriptor may appear anywhere in config */\n \t\terr = __usb_get_extra_descriptor(udev->rawdescriptors[0],\n \t\t\t\tle16_to_cpu(udev->config[0].desc.wTotalLength),\n-\t\t\t\tUSB_DT_OTG, (void **) &desc);\n+\t\t\t\tUSB_DT_OTG, (void **) &desc, sizeof(*desc));\n \t\tif (err || !(desc->bmAttributes & USB_OTG_HNP))\n \t\t\treturn 0;\n ""}<_**next**_>{""sha"": ""4ebfbd737905169d1b96904952576defbd01e8f1"", ""filename"": ""drivers/usb/core/usb.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/704620afc70cf47abb9d6a1a57f3825d2bca49cf/drivers/usb/core/usb.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/704620afc70cf47abb9d6a1a57f3825d2bca49cf/drivers/usb/core/usb.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/core/usb.c?ref=704620afc70cf47abb9d6a1a57f3825d2bca49cf"", ""patch"": ""@@ -832,14 +832,14 @@ EXPORT_SYMBOL_GPL(usb_get_current_frame_number);\n  */\n \n int __usb_get_extra_descriptor(char *buffer, unsigned size,\n-\t\t\t       unsigned char type, void **ptr)\n+\t\t\t       unsigned char type, void **ptr, size_t minsize)\n {\n \tstruct usb_descriptor_header *header;\n \n \twhile (size >= sizeof(struct usb_descriptor_header)) {\n \t\theader = (struct usb_descriptor_header *)buffer;\n \n-\t\tif (header->bLength < 2) {\n+\t\tif (header->bLength < 2 || header->bLength > size) {\n \t\t\tprintk(KERN_ERR\n \t\t\t\t\""%s: bogus descriptor, type %d length %d\\n\"",\n \t\t\t\tusbcore_name,\n@@ -848,7 +848,7 @@ int __usb_get_extra_descriptor(char *buffer, unsigned size,\n \t\t\treturn -1;\n \t\t}\n \n-\t\tif (header->bDescriptorType == type) {\n+\t\tif (header->bDescriptorType == type && header->bLength >= minsize) {\n \t\t\t*ptr = header;\n \t\t\treturn 0;\n \t\t}""}<_**next**_>{""sha"": ""09a8ebd955888d6d375d7cee3d0fc53fd1cf0d9c"", ""filename"": ""drivers/usb/host/hwa-hc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/704620afc70cf47abb9d6a1a57f3825d2bca49cf/drivers/usb/host/hwa-hc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/704620afc70cf47abb9d6a1a57f3825d2bca49cf/drivers/usb/host/hwa-hc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/usb/host/hwa-hc.c?ref=704620afc70cf47abb9d6a1a57f3825d2bca49cf"", ""patch"": ""@@ -640,7 +640,7 @@ static int hwahc_security_create(struct hwahc *hwahc)\n \ttop = itr + itr_size;\n \tresult = __usb_get_extra_descriptor(usb_dev->rawdescriptors[index],\n \t\t\tle16_to_cpu(usb_dev->actconfig->desc.wTotalLength),\n-\t\t\tUSB_DT_SECURITY, (void **) &secd);\n+\t\t\tUSB_DT_SECURITY, (void **) &secd, sizeof(*secd));\n \tif (result == -1) {\n \t\tdev_warn(dev, \""BUG? WUSB host has no security descriptors\\n\"");\n \t\treturn 0;""}<_**next**_>{""sha"": ""5e49e82c43684854c379e18a1d698d79ac4ef347"", ""filename"": ""include/linux/usb.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/704620afc70cf47abb9d6a1a57f3825d2bca49cf/include/linux/usb.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/704620afc70cf47abb9d6a1a57f3825d2bca49cf/include/linux/usb.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/usb.h?ref=704620afc70cf47abb9d6a1a57f3825d2bca49cf"", ""patch"": ""@@ -407,11 +407,11 @@ struct usb_host_bos {\n };\n \n int __usb_get_extra_descriptor(char *buffer, unsigned size,\n-\tunsigned char type, void **ptr);\n+\tunsigned char type, void **ptr, size_t min);\n #define usb_get_extra_descriptor(ifpoint, type, ptr) \\\n \t\t\t\t__usb_get_extra_descriptor((ifpoint)->extra, \\\n \t\t\t\t(ifpoint)->extralen, \\\n-\t\t\t\ttype, (void **)ptr)\n+\t\t\t\ttype, (void **)ptr, sizeof(**(ptr)))\n \n /* ----------------------------------------------------------------------- */\n ""}","static int hwahc_security_create(struct hwahc *hwahc)
{
	int result;
	struct wusbhc *wusbhc = &hwahc->wusbhc;
	struct usb_device *usb_dev = hwahc->wa.usb_dev;
	struct device *dev = &usb_dev->dev;
	struct usb_security_descriptor *secd;
	struct usb_encryption_descriptor *etd;
	void *itr, *top;
	size_t itr_size, needed, bytes;
	u8 index;
	char buf[64];

	/* Find the host's security descriptors in the config descr bundle */
	index = (usb_dev->actconfig - usb_dev->config) /
		sizeof(usb_dev->config[0]);
	itr = usb_dev->rawdescriptors[index];
	itr_size = le16_to_cpu(usb_dev->actconfig->desc.wTotalLength);
 	top = itr + itr_size;
 	result = __usb_get_extra_descriptor(usb_dev->rawdescriptors[index],
 			le16_to_cpu(usb_dev->actconfig->desc.wTotalLength),
			USB_DT_SECURITY, (void **) &secd, sizeof(*secd));
 	if (result == -1) {
 		dev_warn(dev, ""BUG? WUSB host has no security descriptors\n"");
 		return 0;
	}
	needed = sizeof(*secd);
	if (top - (void *)secd < needed) {
		dev_err(dev, ""BUG? Not enough data to process security ""
			""descriptor header (%zu bytes left vs %zu needed)\n"",
			top - (void *) secd, needed);
		return 0;
	}
	needed = le16_to_cpu(secd->wTotalLength);
	if (top - (void *)secd < needed) {
		dev_err(dev, ""BUG? Not enough data to process security ""
			""descriptors (%zu bytes left vs %zu needed)\n"",
			top - (void *) secd, needed);
		return 0;
	}
	/* Walk over the sec descriptors and store CCM1's on wusbhc */
	itr = (void *) secd + sizeof(*secd);
	top = (void *) secd + le16_to_cpu(secd->wTotalLength);
	index = 0;
	bytes = 0;
	while (itr < top) {
		etd = itr;
		if (top - itr < sizeof(*etd)) {
			dev_err(dev, ""BUG: bad host security descriptor; ""
				""not enough data (%zu vs %zu left)\n"",
				top - itr, sizeof(*etd));
			break;
		}
		if (etd->bLength < sizeof(*etd)) {
			dev_err(dev, ""BUG: bad host encryption descriptor; ""
				""descriptor is too short ""
				""(%zu vs %zu needed)\n"",
				(size_t)etd->bLength, sizeof(*etd));
			break;
		}
		itr += etd->bLength;
		bytes += snprintf(buf + bytes, sizeof(buf) - bytes,
				  ""%s (0x%02x) "",
				  wusb_et_name(etd->bEncryptionType),
				  etd->bEncryptionValue);
		wusbhc->ccm1_etd = etd;
	}
	dev_info(dev, ""supported encryption types: %s\n"", buf);
	if (wusbhc->ccm1_etd == NULL) {
		dev_err(dev, ""E: host doesn't support CCM-1 crypto\n"");
		return 0;
	}
	/* Pretty print what we support */
	return 0;
}
","static int hwahc_security_create(struct hwahc *hwahc)
{
	int result;
	struct wusbhc *wusbhc = &hwahc->wusbhc;
	struct usb_device *usb_dev = hwahc->wa.usb_dev;
	struct device *dev = &usb_dev->dev;
	struct usb_security_descriptor *secd;
	struct usb_encryption_descriptor *etd;
	void *itr, *top;
	size_t itr_size, needed, bytes;
	u8 index;
	char buf[64];

	/* Find the host's security descriptors in the config descr bundle */
	index = (usb_dev->actconfig - usb_dev->config) /
		sizeof(usb_dev->config[0]);
	itr = usb_dev->rawdescriptors[index];
	itr_size = le16_to_cpu(usb_dev->actconfig->desc.wTotalLength);
 	top = itr + itr_size;
 	result = __usb_get_extra_descriptor(usb_dev->rawdescriptors[index],
 			le16_to_cpu(usb_dev->actconfig->desc.wTotalLength),
			USB_DT_SECURITY, (void **) &secd);
 	if (result == -1) {
 		dev_warn(dev, ""BUG? WUSB host has no security descriptors\n"");
 		return 0;
	}
	needed = sizeof(*secd);
	if (top - (void *)secd < needed) {
		dev_err(dev, ""BUG? Not enough data to process security ""
			""descriptor header (%zu bytes left vs %zu needed)\n"",
			top - (void *) secd, needed);
		return 0;
	}
	needed = le16_to_cpu(secd->wTotalLength);
	if (top - (void *)secd < needed) {
		dev_err(dev, ""BUG? Not enough data to process security ""
			""descriptors (%zu bytes left vs %zu needed)\n"",
			top - (void *) secd, needed);
		return 0;
	}
	/* Walk over the sec descriptors and store CCM1's on wusbhc */
	itr = (void *) secd + sizeof(*secd);
	top = (void *) secd + le16_to_cpu(secd->wTotalLength);
	index = 0;
	bytes = 0;
	while (itr < top) {
		etd = itr;
		if (top - itr < sizeof(*etd)) {
			dev_err(dev, ""BUG: bad host security descriptor; ""
				""not enough data (%zu vs %zu left)\n"",
				top - itr, sizeof(*etd));
			break;
		}
		if (etd->bLength < sizeof(*etd)) {
			dev_err(dev, ""BUG: bad host encryption descriptor; ""
				""descriptor is too short ""
				""(%zu vs %zu needed)\n"",
				(size_t)etd->bLength, sizeof(*etd));
			break;
		}
		itr += etd->bLength;
		bytes += snprintf(buf + bytes, sizeof(buf) - bytes,
				  ""%s (0x%02x) "",
				  wusb_et_name(etd->bEncryptionType),
				  etd->bEncryptionValue);
		wusbhc->ccm1_etd = etd;
	}
	dev_info(dev, ""supported encryption types: %s\n"", buf);
	if (wusbhc->ccm1_etd == NULL) {
		dev_err(dev, ""E: host doesn't support CCM-1 crypto\n"");
		return 0;
	}
	/* Pretty print what we support */
	return 0;
}
",C,"			USB_DT_SECURITY, (void **) &secd, sizeof(*secd));
","			USB_DT_SECURITY, (void **) &secd);
",,"@@ -640,7 +640,7 @@ static int hwahc_security_create(struct hwahc *hwahc)
 	top = itr + itr_size;
 	result = __usb_get_extra_descriptor(usb_dev->rawdescriptors[index],
 			le16_to_cpu(usb_dev->actconfig->desc.wTotalLength),
-			USB_DT_SECURITY, (void **) &secd);
+			USB_DT_SECURITY, (void **) &secd, sizeof(*secd));
 	if (result == -1) {
 		dev_warn(dev, ""BUG? WUSB host has no security descriptors\n"");
 		return 0;",linux,704620afc70cf47abb9d6a1a57f3825d2bca49cf,2f2dde6ba89b1ef1fe23c1138131b315d9aa4019,1,"static int hwahc_security_create(struct hwahc *hwahc)
{
	int result;
	struct wusbhc *wusbhc = &hwahc->wusbhc;
	struct usb_device *usb_dev = hwahc->wa.usb_dev;
	struct device *dev = &usb_dev->dev;
	struct usb_security_descriptor *secd;
	struct usb_encryption_descriptor *etd;
	void *itr, *top;
	size_t itr_size, needed, bytes;
	u8 index;
	char buf[64];

	/* Find the host's security descriptors in the config descr bundle */
	index = (usb_dev->actconfig - usb_dev->config) /
		sizeof(usb_dev->config[0]);
	itr = usb_dev->rawdescriptors[index];
	itr_size = le16_to_cpu(usb_dev->actconfig->desc.wTotalLength);
 	top = itr + itr_size;
 	result = __usb_get_extra_descriptor(usb_dev->rawdescriptors[index],
 			le16_to_cpu(usb_dev->actconfig->desc.wTotalLength),
//flaw_line_below:
			USB_DT_SECURITY, (void **) &secd);
//fix_flaw_line_below:
//			USB_DT_SECURITY, (void **) &secd, sizeof(*secd));
 	if (result == -1) {
 		dev_warn(dev, ""BUG? WUSB host has no security descriptors\n"");
 		return 0;
	}
	needed = sizeof(*secd);
	if (top - (void *)secd < needed) {
		dev_err(dev, ""BUG? Not enough data to process security ""
			""descriptor header (%zu bytes left vs %zu needed)\n"",
			top - (void *) secd, needed);
		return 0;
	}
	needed = le16_to_cpu(secd->wTotalLength);
	if (top - (void *)secd < needed) {
		dev_err(dev, ""BUG? Not enough data to process security ""
			""descriptors (%zu bytes left vs %zu needed)\n"",
			top - (void *) secd, needed);
		return 0;
	}
	/* Walk over the sec descriptors and store CCM1's on wusbhc */
	itr = (void *) secd + sizeof(*secd);
	top = (void *) secd + le16_to_cpu(secd->wTotalLength);
	index = 0;
	bytes = 0;
	while (itr < top) {
		etd = itr;
		if (top - itr < sizeof(*etd)) {
			dev_err(dev, ""BUG: bad host security descriptor; ""
				""not enough data (%zu vs %zu left)\n"",
				top - itr, sizeof(*etd));
			break;
		}
		if (etd->bLength < sizeof(*etd)) {
			dev_err(dev, ""BUG: bad host encryption descriptor; ""
				""descriptor is too short ""
				""(%zu vs %zu needed)\n"",
				(size_t)etd->bLength, sizeof(*etd));
			break;
		}
		itr += etd->bLength;
		bytes += snprintf(buf + bytes, sizeof(buf) - bytes,
				  ""%s (0x%02x) "",
				  wusb_et_name(etd->bEncryptionType),
				  etd->bEncryptionValue);
		wusbhc->ccm1_etd = etd;
	}
	dev_info(dev, ""supported encryption types: %s\n"", buf);
	if (wusbhc->ccm1_etd == NULL) {
		dev_err(dev, ""E: host doesn't support CCM-1 crypto\n"");
		return 0;
	}
	/* Pretty print what we support */
	return 0;
}
"
4532,182268,,Local,Not required,Partial,CVE-2018-15853,https://www.cvedetails.com/cve/CVE-2018-15853/,CWE-400,Low,,,,2018-08-25,2.1,"Endless recursion exists in xkbcomp/expr.c in xkbcommon and libxkbcommon before 0.8.1, which could be used by local attackers to crash xkbcommon users by supplying a crafted keymap file that triggers boolean negation.",2019-08-06,,1,https://github.com/xkbcommon/libxkbcommon/commit/1f9d1248c07cda8aaff762429c0dce146de8632a,1f9d1248c07cda8aaff762429c0dce146de8632a,"xkbcomp: fix stack overflow when evaluating boolean negation

The expression evaluator would go into an infinite recursion when
evaluating something like this as a boolean: `!True`. Instead of
recursing to just `True` and negating, it recursed to `!True` itself
again.

Bug inherited from xkbcomp.

Caught with the afl fuzzer.

Signed-off-by: Ran Benita <ran234@gmail.com>",1,src/xkbcomp/expr.c,"{""sha"": ""5d43cbaa9b8536893f5ed2bc1106371a9e5aab20"", ""filename"": ""src/xkbcomp/expr.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/xkbcommon/libxkbcommon/blob/1f9d1248c07cda8aaff762429c0dce146de8632a/src/xkbcomp/expr.c"", ""raw_url"": ""https://github.com/xkbcommon/libxkbcommon/raw/1f9d1248c07cda8aaff762429c0dce146de8632a/src/xkbcomp/expr.c"", ""contents_url"": ""https://api.github.com/repos/xkbcommon/libxkbcommon/contents/src/xkbcomp/expr.c?ref=1f9d1248c07cda8aaff762429c0dce146de8632a"", ""patch"": ""@@ -165,7 +165,7 @@ ExprResolveBoolean(struct xkb_context *ctx, const ExprDef *expr,\n \n     case EXPR_INVERT:\n     case EXPR_NOT:\n-        ok = ExprResolveBoolean(ctx, expr, set_rtrn);\n+        ok = ExprResolveBoolean(ctx, expr->unary.child, set_rtrn);\n         if (ok)\n             *set_rtrn = !*set_rtrn;\n         return ok;""}","ExprResolveBoolean(struct xkb_context *ctx, const ExprDef *expr,
                   bool *set_rtrn)
{
    bool ok = false;
    const char *ident;

    switch (expr->expr.op) {
    case EXPR_VALUE:
        if (expr->expr.value_type != EXPR_TYPE_BOOLEAN) {
            log_err(ctx,
                    ""Found constant of type %s where boolean was expected\n"",
                    expr_value_type_to_string(expr->expr.value_type));
            return false;
        }
        *set_rtrn = expr->boolean.set;
        return true;

    case EXPR_IDENT:
        ident = xkb_atom_text(ctx, expr->ident.ident);
        if (ident) {
            if (istreq(ident, ""true"") ||
                istreq(ident, ""yes"") ||
                istreq(ident, ""on"")) {
                *set_rtrn = true;
                return true;
            }
            else if (istreq(ident, ""false"") ||
                     istreq(ident, ""no"") ||
                     istreq(ident, ""off"")) {
                *set_rtrn = false;
                return true;
            }
        }
        log_err(ctx, ""Identifier \""%s\"" of type boolean is unknown\n"", ident);
        return false;

    case EXPR_FIELD_REF:
        log_err(ctx, ""Default \""%s.%s\"" of type boolean is unknown\n"",
                xkb_atom_text(ctx, expr->field_ref.element),
                xkb_atom_text(ctx, expr->field_ref.field));
        return false;
 
     case EXPR_INVERT:
     case EXPR_NOT:
        ok = ExprResolveBoolean(ctx, expr->unary.child, set_rtrn);
         if (ok)
             *set_rtrn = !*set_rtrn;
         return ok;
    case EXPR_ADD:
    case EXPR_SUBTRACT:
    case EXPR_MULTIPLY:
    case EXPR_DIVIDE:
    case EXPR_ASSIGN:
    case EXPR_NEGATE:
    case EXPR_UNARY_PLUS:
        log_err(ctx, ""%s of boolean values not permitted\n"",
                expr_op_type_to_string(expr->expr.op));
        break;

    default:
        log_wsgo(ctx, ""Unknown operator %d in ResolveBoolean\n"",
                 expr->expr.op);
        break;
    }

    return false;
}
","ExprResolveBoolean(struct xkb_context *ctx, const ExprDef *expr,
                   bool *set_rtrn)
{
    bool ok = false;
    const char *ident;

    switch (expr->expr.op) {
    case EXPR_VALUE:
        if (expr->expr.value_type != EXPR_TYPE_BOOLEAN) {
            log_err(ctx,
                    ""Found constant of type %s where boolean was expected\n"",
                    expr_value_type_to_string(expr->expr.value_type));
            return false;
        }
        *set_rtrn = expr->boolean.set;
        return true;

    case EXPR_IDENT:
        ident = xkb_atom_text(ctx, expr->ident.ident);
        if (ident) {
            if (istreq(ident, ""true"") ||
                istreq(ident, ""yes"") ||
                istreq(ident, ""on"")) {
                *set_rtrn = true;
                return true;
            }
            else if (istreq(ident, ""false"") ||
                     istreq(ident, ""no"") ||
                     istreq(ident, ""off"")) {
                *set_rtrn = false;
                return true;
            }
        }
        log_err(ctx, ""Identifier \""%s\"" of type boolean is unknown\n"", ident);
        return false;

    case EXPR_FIELD_REF:
        log_err(ctx, ""Default \""%s.%s\"" of type boolean is unknown\n"",
                xkb_atom_text(ctx, expr->field_ref.element),
                xkb_atom_text(ctx, expr->field_ref.field));
        return false;
 
     case EXPR_INVERT:
     case EXPR_NOT:
        ok = ExprResolveBoolean(ctx, expr, set_rtrn);
         if (ok)
             *set_rtrn = !*set_rtrn;
         return ok;
    case EXPR_ADD:
    case EXPR_SUBTRACT:
    case EXPR_MULTIPLY:
    case EXPR_DIVIDE:
    case EXPR_ASSIGN:
    case EXPR_NEGATE:
    case EXPR_UNARY_PLUS:
        log_err(ctx, ""%s of boolean values not permitted\n"",
                expr_op_type_to_string(expr->expr.op));
        break;

    default:
        log_wsgo(ctx, ""Unknown operator %d in ResolveBoolean\n"",
                 expr->expr.op);
        break;
    }

    return false;
}
",C,"        ok = ExprResolveBoolean(ctx, expr->unary.child, set_rtrn);
","        ok = ExprResolveBoolean(ctx, expr, set_rtrn);
",,"@@ -165,7 +165,7 @@ ExprResolveBoolean(struct xkb_context *ctx, const ExprDef *expr,
 
     case EXPR_INVERT:
     case EXPR_NOT:
-        ok = ExprResolveBoolean(ctx, expr, set_rtrn);
+        ok = ExprResolveBoolean(ctx, expr->unary.child, set_rtrn);
         if (ok)
             *set_rtrn = !*set_rtrn;
         return ok;",libxkbcommon,1f9d1248c07cda8aaff762429c0dce146de8632a,2cb5c2a3f3a74fb7478648a7811ca2b6e6272311,1,"ExprResolveBoolean(struct xkb_context *ctx, const ExprDef *expr,
                   bool *set_rtrn)
{
    bool ok = false;
    const char *ident;

    switch (expr->expr.op) {
    case EXPR_VALUE:
        if (expr->expr.value_type != EXPR_TYPE_BOOLEAN) {
            log_err(ctx,
                    ""Found constant of type %s where boolean was expected\n"",
                    expr_value_type_to_string(expr->expr.value_type));
            return false;
        }
        *set_rtrn = expr->boolean.set;
        return true;

    case EXPR_IDENT:
        ident = xkb_atom_text(ctx, expr->ident.ident);
        if (ident) {
            if (istreq(ident, ""true"") ||
                istreq(ident, ""yes"") ||
                istreq(ident, ""on"")) {
                *set_rtrn = true;
                return true;
            }
            else if (istreq(ident, ""false"") ||
                     istreq(ident, ""no"") ||
                     istreq(ident, ""off"")) {
                *set_rtrn = false;
                return true;
            }
        }
        log_err(ctx, ""Identifier \""%s\"" of type boolean is unknown\n"", ident);
        return false;

    case EXPR_FIELD_REF:
        log_err(ctx, ""Default \""%s.%s\"" of type boolean is unknown\n"",
                xkb_atom_text(ctx, expr->field_ref.element),
                xkb_atom_text(ctx, expr->field_ref.field));
        return false;
 
     case EXPR_INVERT:
     case EXPR_NOT:
//flaw_line_below:
        ok = ExprResolveBoolean(ctx, expr, set_rtrn);
//fix_flaw_line_below:
//        ok = ExprResolveBoolean(ctx, expr->unary.child, set_rtrn);
         if (ok)
             *set_rtrn = !*set_rtrn;
         return ok;
    case EXPR_ADD:
    case EXPR_SUBTRACT:
    case EXPR_MULTIPLY:
    case EXPR_DIVIDE:
    case EXPR_ASSIGN:
    case EXPR_NEGATE:
    case EXPR_UNARY_PLUS:
        log_err(ctx, ""%s of boolean values not permitted\n"",
                expr_op_type_to_string(expr->expr.op));
        break;

    default:
        log_wsgo(ctx, ""Unknown operator %d in ResolveBoolean\n"",
                 expr->expr.op);
        break;
    }

    return false;
}
"
4868,182604,,Remote,Not required,Partial,CVE-2017-9732,https://www.cvedetails.com/cve/CVE-2017-9732/,CWE-400,Low,,,,2018-12-20,5.0,"The read_packet function in knc (Kerberised NetCat) before 1.11-1 is vulnerable to denial of service (memory exhaustion) that can be exploited remotely without authentication, possibly affecting another services running on the targeted host.",2019-01-11,DoS ,3,https://github.com/elric1/knc/commit/f237f3e09ecbaf59c897f5046538a7b1a3fa40c1,f237f3e09ecbaf59c897f5046538a7b1a3fa40c1,"knc: fix a couple of memory leaks.

One of these can be remotely triggered during the authentication
phase which leads to a remote DoS possibility.

Pointed out by: Imre Rad <radimre83@gmail.com>",0,bin/gssstdio.c,"{""sha"": ""01199fef373455390bfa319fddf1c748f133e1a5"", ""filename"": ""bin/gssstdio.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 6, ""changes"": 22, ""blob_url"": ""https://github.com/elric1/knc/blob/f237f3e09ecbaf59c897f5046538a7b1a3fa40c1/bin/gssstdio.c"", ""raw_url"": ""https://github.com/elric1/knc/raw/f237f3e09ecbaf59c897f5046538a7b1a3fa40c1/bin/gssstdio.c"", ""contents_url"": ""https://api.github.com/repos/elric1/knc/contents/bin/gssstdio.c?ref=f237f3e09ecbaf59c897f5046538a7b1a3fa40c1"", ""patch"": ""@@ -220,10 +220,13 @@ gstd_accept(int fd, char **display_creds, char **export_name, char **mech)\n \t    &in, GSS_C_NO_CHANNEL_BINDINGS, &client, &mech_oid, &out, NULL,\n \t    NULL, NULL);\n \n+\tgss_release_buffer(&min, &in);\n+\n \tif (out.length && write_packet(fd, &out)) {\n \t\tgss_release_buffer(&min, &out);\n \t\treturn NULL;\n \t}\n+\tgss_release_buffer(&min, &out);\n \n \tGSTD_GSS_ERROR(maj, min, NULL, \""gss_accept_sec_context\"");\n \n@@ -473,7 +476,7 @@ read_packet(int fd, gss_buffer_t buf, int timeout, int first)\n \t\t\t\treturn -2;\n \n \t\t\tLOG(LOG_ERR, (\""%s\"", strerror(errno)));\n-\t\t\treturn -1;\n+\t\t\tgoto bail;\n \t\t}\n \n \t\tif (ret == 0) {\t\t/* EOF */\n@@ -486,7 +489,7 @@ read_packet(int fd, gss_buffer_t buf, int timeout, int first)\n \t\t\t * a protocol error.\n \t\t\t */\n \t\t\tLOG(LOG_INFO, (\""EOF reading packet len\""));\n-\t\t\treturn -1;\n+\t\t\tgoto bail;\n \t\t}\n \n \t\tlen_buf_pos += ret;\n@@ -506,28 +509,29 @@ read_packet(int fd, gss_buffer_t buf, int timeout, int first)\n \t */\n \tif (len > GSTD_MAXPACKETCONTENTS + 512) {\n \t\tLOG(LOG_ERR, (\""ridiculous length, %ld\"", len));\n-\t\treturn -1;\n+\t\tgoto bail;\n \t}\n \n \tif (!tmpbuf) {\n \t\tif ((tmpbuf = malloc(len)) == NULL) {\n \t\t\tLOG(LOG_CRIT, (\""malloc failure, %ld bytes\"", len));\n-\t\t\treturn -1;\n+\t\t\tgoto bail;\n \t\t}\n \t}\n \n \tret = timed_read(fd, tmpbuf + tmpbuf_pos, len - tmpbuf_pos, timeout);\n \tif (ret == -1) {\n+\n \t\tif (errno == EINTR || errno == EAGAIN)\n \t\t\treturn -2;\n \n \t\tLOG(LOG_ERR, (\""%s\"", strerror(errno)));\n-\t\treturn -1;\n+\t\tgoto bail;\n \t}\n \n \tif (ret == 0) {\n \t\tLOG(LOG_ERR, (\""EOF while reading packet (len=%d)\"", len));\n-\t\treturn -1;\n+\t\tgoto bail;\n \t}\n \n \ttmpbuf_pos += ret;\n@@ -543,6 +547,12 @@ read_packet(int fd, gss_buffer_t buf, int timeout, int first)\n \t}\n \n \treturn -2;\n+\n+bail:\n+\tfree(tmpbuf);\n+\ttmpbuf = NULL;\n+\n+\treturn -1;\n }\n \n static int""}","gstd_accept(int fd, char **display_creds, char **export_name, char **mech)
{
	gss_name_t	 client;
	gss_OID		 mech_oid;
	struct gstd_tok *tok;
	gss_ctx_id_t	 ctx = GSS_C_NO_CONTEXT;
	gss_buffer_desc	 in, out;
	OM_uint32	 maj, min;
	int		 ret;

	*display_creds = NULL;
	*export_name = NULL;
	out.length = 0;
	in.length = 0;
	read_packet(fd, &in, 60000, 1);
again:
	while ((ret = read_packet(fd, &in, 60000, 0)) == -2)
		;

	if (ret < 1)
		return NULL;

	maj = gss_accept_sec_context(&min, &ctx, GSS_C_NO_CREDENTIAL,
 	    &in, GSS_C_NO_CHANNEL_BINDINGS, &client, &mech_oid, &out, NULL,
 	    NULL, NULL);
 
	gss_release_buffer(&min, &in);

 	if (out.length && write_packet(fd, &out)) {
 		gss_release_buffer(&min, &out);
 		return NULL;
 	}
	gss_release_buffer(&min, &out);
 
 	GSTD_GSS_ERROR(maj, min, NULL, ""gss_accept_sec_context"");
 
	if (maj & GSS_S_CONTINUE_NEEDED)
		goto again;

	*display_creds = gstd_get_display_name(client);
	*export_name = gstd_get_export_name(client);
	*mech = gstd_get_mech(mech_oid);

	gss_release_name(&min, &client);
	SETUP_GSTD_TOK(tok, ctx, fd, ""gstd_accept"");
	return tok;
}
","gstd_accept(int fd, char **display_creds, char **export_name, char **mech)
{
	gss_name_t	 client;
	gss_OID		 mech_oid;
	struct gstd_tok *tok;
	gss_ctx_id_t	 ctx = GSS_C_NO_CONTEXT;
	gss_buffer_desc	 in, out;
	OM_uint32	 maj, min;
	int		 ret;

	*display_creds = NULL;
	*export_name = NULL;
	out.length = 0;
	in.length = 0;
	read_packet(fd, &in, 60000, 1);
again:
	while ((ret = read_packet(fd, &in, 60000, 0)) == -2)
		;

	if (ret < 1)
		return NULL;

	maj = gss_accept_sec_context(&min, &ctx, GSS_C_NO_CREDENTIAL,
 	    &in, GSS_C_NO_CHANNEL_BINDINGS, &client, &mech_oid, &out, NULL,
 	    NULL, NULL);
 
 	if (out.length && write_packet(fd, &out)) {
 		gss_release_buffer(&min, &out);
 		return NULL;
 	}
 
 	GSTD_GSS_ERROR(maj, min, NULL, ""gss_accept_sec_context"");
 
	if (maj & GSS_S_CONTINUE_NEEDED)
		goto again;

	*display_creds = gstd_get_display_name(client);
	*export_name = gstd_get_export_name(client);
	*mech = gstd_get_mech(mech_oid);

	gss_release_name(&min, &client);
	SETUP_GSTD_TOK(tok, ctx, fd, ""gstd_accept"");
	return tok;
}
",C,"	gss_release_buffer(&min, &in);

	gss_release_buffer(&min, &out);
",,,"@@ -220,10 +220,13 @@ gstd_accept(int fd, char **display_creds, char **export_name, char **mech)
 	    &in, GSS_C_NO_CHANNEL_BINDINGS, &client, &mech_oid, &out, NULL,
 	    NULL, NULL);
 
+	gss_release_buffer(&min, &in);
+
 	if (out.length && write_packet(fd, &out)) {
 		gss_release_buffer(&min, &out);
 		return NULL;
 	}
+	gss_release_buffer(&min, &out);
 
 	GSTD_GSS_ERROR(maj, min, NULL, ""gss_accept_sec_context"");
 
@@ -473,7 +476,7 @@ read_packet(int fd, gss_buffer_t buf, int timeout, int first)
 				return -2;
 
 			LOG(LOG_ERR, (""%s"", strerror(errno)));
-			return -1;
+			goto bail;
 		}
 
 		if (ret == 0) {		/* EOF */
@@ -486,7 +489,7 @@ read_packet(int fd, gss_buffer_t buf, int timeout, int first)
 			 * a protocol error.
 			 */
 			LOG(LOG_INFO, (""EOF reading packet len""));
-			return -1;
+			goto bail;
 		}
 
 		len_buf_pos += ret;
@@ -506,28 +509,29 @@ read_packet(int fd, gss_buffer_t buf, int timeout, int first)
 	 */
 	if (len > GSTD_MAXPACKETCONTENTS + 512) {
 		LOG(LOG_ERR, (""ridiculous length, %ld"", len));
-		return -1;
+		goto bail;
 	}
 
 	if (!tmpbuf) {
 		if ((tmpbuf = malloc(len)) == NULL) {
 			LOG(LOG_CRIT, (""malloc failure, %ld bytes"", len));
-			return -1;
+			goto bail;
 		}
 	}
 
 	ret = timed_read(fd, tmpbuf + tmpbuf_pos, len - tmpbuf_pos, timeout);
 	if (ret == -1) {
+
 		if (errno == EINTR || errno == EAGAIN)
 			return -2;
 
 		LOG(LOG_ERR, (""%s"", strerror(errno)));
-		return -1;
+		goto bail;
 	}
 
 	if (ret == 0) {
 		LOG(LOG_ERR, (""EOF while reading packet (len=%d)"", len));
-		return -1;
+		goto bail;
 	}
 
 	tmpbuf_pos += ret;
@@ -543,6 +547,12 @@ read_packet(int fd, gss_buffer_t buf, int timeout, int first)
 	}
 
 	return -2;
+
+bail:
+	free(tmpbuf);
+	tmpbuf = NULL;
+
+	return -1;
 }
 
 static int",knc,f237f3e09ecbaf59c897f5046538a7b1a3fa40c1,c78303f9f657a57b7b89b4356de5dd5d0561a257,1,"gstd_accept(int fd, char **display_creds, char **export_name, char **mech)
{
	gss_name_t	 client;
	gss_OID		 mech_oid;
	struct gstd_tok *tok;
	gss_ctx_id_t	 ctx = GSS_C_NO_CONTEXT;
	gss_buffer_desc	 in, out;
	OM_uint32	 maj, min;
	int		 ret;

	*display_creds = NULL;
	*export_name = NULL;
	out.length = 0;
	in.length = 0;
	read_packet(fd, &in, 60000, 1);
again:
	while ((ret = read_packet(fd, &in, 60000, 0)) == -2)
		;

	if (ret < 1)
		return NULL;

	maj = gss_accept_sec_context(&min, &ctx, GSS_C_NO_CREDENTIAL,
 	    &in, GSS_C_NO_CHANNEL_BINDINGS, &client, &mech_oid, &out, NULL,
 	    NULL, NULL);
 
//fix_flaw_line_below:
//	gss_release_buffer(&min, &in);
//fix_flaw_line_below:
//
 	if (out.length && write_packet(fd, &out)) {
 		gss_release_buffer(&min, &out);
 		return NULL;
 	}
//fix_flaw_line_below:
//	gss_release_buffer(&min, &out);
 
 	GSTD_GSS_ERROR(maj, min, NULL, ""gss_accept_sec_context"");
 
	if (maj & GSS_S_CONTINUE_NEEDED)
		goto again;

	*display_creds = gstd_get_display_name(client);
	*export_name = gstd_get_export_name(client);
	*mech = gstd_get_mech(mech_oid);

	gss_release_name(&min, &client);
	SETUP_GSTD_TOK(tok, ctx, fd, ""gstd_accept"");
	return tok;
}
"
4869,182605,,Remote,Not required,Partial,CVE-2017-9732,https://www.cvedetails.com/cve/CVE-2017-9732/,CWE-400,Low,,,,2018-12-20,5.0,"The read_packet function in knc (Kerberised NetCat) before 1.11-1 is vulnerable to denial of service (memory exhaustion) that can be exploited remotely without authentication, possibly affecting another services running on the targeted host.",2019-01-11,DoS ,13,https://github.com/elric1/knc/commit/f237f3e09ecbaf59c897f5046538a7b1a3fa40c1,f237f3e09ecbaf59c897f5046538a7b1a3fa40c1,"knc: fix a couple of memory leaks.

One of these can be remotely triggered during the authentication
phase which leads to a remote DoS possibility.

Pointed out by: Imre Rad <radimre83@gmail.com>",6,bin/gssstdio.c,"{""sha"": ""01199fef373455390bfa319fddf1c748f133e1a5"", ""filename"": ""bin/gssstdio.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 6, ""changes"": 22, ""blob_url"": ""https://github.com/elric1/knc/blob/f237f3e09ecbaf59c897f5046538a7b1a3fa40c1/bin/gssstdio.c"", ""raw_url"": ""https://github.com/elric1/knc/raw/f237f3e09ecbaf59c897f5046538a7b1a3fa40c1/bin/gssstdio.c"", ""contents_url"": ""https://api.github.com/repos/elric1/knc/contents/bin/gssstdio.c?ref=f237f3e09ecbaf59c897f5046538a7b1a3fa40c1"", ""patch"": ""@@ -220,10 +220,13 @@ gstd_accept(int fd, char **display_creds, char **export_name, char **mech)\n \t    &in, GSS_C_NO_CHANNEL_BINDINGS, &client, &mech_oid, &out, NULL,\n \t    NULL, NULL);\n \n+\tgss_release_buffer(&min, &in);\n+\n \tif (out.length && write_packet(fd, &out)) {\n \t\tgss_release_buffer(&min, &out);\n \t\treturn NULL;\n \t}\n+\tgss_release_buffer(&min, &out);\n \n \tGSTD_GSS_ERROR(maj, min, NULL, \""gss_accept_sec_context\"");\n \n@@ -473,7 +476,7 @@ read_packet(int fd, gss_buffer_t buf, int timeout, int first)\n \t\t\t\treturn -2;\n \n \t\t\tLOG(LOG_ERR, (\""%s\"", strerror(errno)));\n-\t\t\treturn -1;\n+\t\t\tgoto bail;\n \t\t}\n \n \t\tif (ret == 0) {\t\t/* EOF */\n@@ -486,7 +489,7 @@ read_packet(int fd, gss_buffer_t buf, int timeout, int first)\n \t\t\t * a protocol error.\n \t\t\t */\n \t\t\tLOG(LOG_INFO, (\""EOF reading packet len\""));\n-\t\t\treturn -1;\n+\t\t\tgoto bail;\n \t\t}\n \n \t\tlen_buf_pos += ret;\n@@ -506,28 +509,29 @@ read_packet(int fd, gss_buffer_t buf, int timeout, int first)\n \t */\n \tif (len > GSTD_MAXPACKETCONTENTS + 512) {\n \t\tLOG(LOG_ERR, (\""ridiculous length, %ld\"", len));\n-\t\treturn -1;\n+\t\tgoto bail;\n \t}\n \n \tif (!tmpbuf) {\n \t\tif ((tmpbuf = malloc(len)) == NULL) {\n \t\t\tLOG(LOG_CRIT, (\""malloc failure, %ld bytes\"", len));\n-\t\t\treturn -1;\n+\t\t\tgoto bail;\n \t\t}\n \t}\n \n \tret = timed_read(fd, tmpbuf + tmpbuf_pos, len - tmpbuf_pos, timeout);\n \tif (ret == -1) {\n+\n \t\tif (errno == EINTR || errno == EAGAIN)\n \t\t\treturn -2;\n \n \t\tLOG(LOG_ERR, (\""%s\"", strerror(errno)));\n-\t\treturn -1;\n+\t\tgoto bail;\n \t}\n \n \tif (ret == 0) {\n \t\tLOG(LOG_ERR, (\""EOF while reading packet (len=%d)\"", len));\n-\t\treturn -1;\n+\t\tgoto bail;\n \t}\n \n \ttmpbuf_pos += ret;\n@@ -543,6 +547,12 @@ read_packet(int fd, gss_buffer_t buf, int timeout, int first)\n \t}\n \n \treturn -2;\n+\n+bail:\n+\tfree(tmpbuf);\n+\ttmpbuf = NULL;\n+\n+\treturn -1;\n }\n \n static int""}","read_packet(int fd, gss_buffer_t buf, int timeout, int first)
{
	int	  ret;

	static uint32_t		len = 0;
	static char		len_buf[4];
	static int		len_buf_pos = 0;
	static char *		tmpbuf = 0;
	static int		tmpbuf_pos = 0;

	if (first) {
		len_buf_pos = 0;
		return -2;
	}

	if (len_buf_pos < 4) {
		ret = timed_read(fd, &len_buf[len_buf_pos], 4 - len_buf_pos,
		    timeout);

		if (ret == -1) {
			if (errno == EINTR || errno == EAGAIN)
 				return -2;
 
 			LOG(LOG_ERR, (""%s"", strerror(errno)));
			goto bail;
 		}
 
 		if (ret == 0) {		/* EOF */
			/* Failure to read ANY length just means we're done */
			if (len_buf_pos == 0)
				return 0;

			/*
			 * Otherwise, we got EOF mid-length, and that's
 			 * a protocol error.
 			 */
 			LOG(LOG_INFO, (""EOF reading packet len""));
			goto bail;
 		}
 
 		len_buf_pos += ret;
	}

	/* Not done reading the length? */
	if (len_buf_pos != 4)
		return -2;

	/* We have the complete length */
	len = ntohl(*(uint32_t *)len_buf);

	/*
	 * We make sure recvd length is reasonable, allowing for some
	 * slop in enc overhead, beyond the actual maximum number of
	 * bytes of decrypted payload.
 	 */
 	if (len > GSTD_MAXPACKETCONTENTS + 512) {
 		LOG(LOG_ERR, (""ridiculous length, %ld"", len));
		goto bail;
 	}
 
 	if (!tmpbuf) {
 		if ((tmpbuf = malloc(len)) == NULL) {
 			LOG(LOG_CRIT, (""malloc failure, %ld bytes"", len));
			goto bail;
 		}
 	}
 
 	ret = timed_read(fd, tmpbuf + tmpbuf_pos, len - tmpbuf_pos, timeout);
 	if (ret == -1) {

 		if (errno == EINTR || errno == EAGAIN)
 			return -2;
 
 		LOG(LOG_ERR, (""%s"", strerror(errno)));
		goto bail;
 	}
 
 	if (ret == 0) {
 		LOG(LOG_ERR, (""EOF while reading packet (len=%d)"", len));
		goto bail;
 	}
 
 	tmpbuf_pos += ret;

	if (tmpbuf_pos == len) {
		buf->length = len;
		buf->value = tmpbuf;
		len = len_buf_pos = tmpbuf_pos = 0;
		tmpbuf = NULL;

		LOG(LOG_DEBUG, (""read packet of length %d"", buf->length));
		return 1;
 	}
 
 	return -2;

bail:
	free(tmpbuf);
	tmpbuf = NULL;

	return -1;
 }
","read_packet(int fd, gss_buffer_t buf, int timeout, int first)
{
	int	  ret;

	static uint32_t		len = 0;
	static char		len_buf[4];
	static int		len_buf_pos = 0;
	static char *		tmpbuf = 0;
	static int		tmpbuf_pos = 0;

	if (first) {
		len_buf_pos = 0;
		return -2;
	}

	if (len_buf_pos < 4) {
		ret = timed_read(fd, &len_buf[len_buf_pos], 4 - len_buf_pos,
		    timeout);

		if (ret == -1) {
			if (errno == EINTR || errno == EAGAIN)
 				return -2;
 
 			LOG(LOG_ERR, (""%s"", strerror(errno)));
			return -1;
 		}
 
 		if (ret == 0) {		/* EOF */
			/* Failure to read ANY length just means we're done */
			if (len_buf_pos == 0)
				return 0;

			/*
			 * Otherwise, we got EOF mid-length, and that's
 			 * a protocol error.
 			 */
 			LOG(LOG_INFO, (""EOF reading packet len""));
			return -1;
 		}
 
 		len_buf_pos += ret;
	}

	/* Not done reading the length? */
	if (len_buf_pos != 4)
		return -2;

	/* We have the complete length */
	len = ntohl(*(uint32_t *)len_buf);

	/*
	 * We make sure recvd length is reasonable, allowing for some
	 * slop in enc overhead, beyond the actual maximum number of
	 * bytes of decrypted payload.
 	 */
 	if (len > GSTD_MAXPACKETCONTENTS + 512) {
 		LOG(LOG_ERR, (""ridiculous length, %ld"", len));
		return -1;
 	}
 
 	if (!tmpbuf) {
 		if ((tmpbuf = malloc(len)) == NULL) {
 			LOG(LOG_CRIT, (""malloc failure, %ld bytes"", len));
			return -1;
 		}
 	}
 
 	ret = timed_read(fd, tmpbuf + tmpbuf_pos, len - tmpbuf_pos, timeout);
 	if (ret == -1) {
 		if (errno == EINTR || errno == EAGAIN)
 			return -2;
 
 		LOG(LOG_ERR, (""%s"", strerror(errno)));
		return -1;
 	}
 
 	if (ret == 0) {
 		LOG(LOG_ERR, (""EOF while reading packet (len=%d)"", len));
		return -1;
 	}
 
 	tmpbuf_pos += ret;

	if (tmpbuf_pos == len) {
		buf->length = len;
		buf->value = tmpbuf;
		len = len_buf_pos = tmpbuf_pos = 0;
		tmpbuf = NULL;

		LOG(LOG_DEBUG, (""read packet of length %d"", buf->length));
		return 1;
 	}
 
 	return -2;
 }
",C,"			goto bail;
			goto bail;
		goto bail;
			goto bail;

		goto bail;
		goto bail;

bail:
	free(tmpbuf);
	tmpbuf = NULL;

	return -1;
","			return -1;
			return -1;
		return -1;
			return -1;
		return -1;
		return -1;
",,"@@ -220,10 +220,13 @@ gstd_accept(int fd, char **display_creds, char **export_name, char **mech)
 	    &in, GSS_C_NO_CHANNEL_BINDINGS, &client, &mech_oid, &out, NULL,
 	    NULL, NULL);
 
+	gss_release_buffer(&min, &in);
+
 	if (out.length && write_packet(fd, &out)) {
 		gss_release_buffer(&min, &out);
 		return NULL;
 	}
+	gss_release_buffer(&min, &out);
 
 	GSTD_GSS_ERROR(maj, min, NULL, ""gss_accept_sec_context"");
 
@@ -473,7 +476,7 @@ read_packet(int fd, gss_buffer_t buf, int timeout, int first)
 				return -2;
 
 			LOG(LOG_ERR, (""%s"", strerror(errno)));
-			return -1;
+			goto bail;
 		}
 
 		if (ret == 0) {		/* EOF */
@@ -486,7 +489,7 @@ read_packet(int fd, gss_buffer_t buf, int timeout, int first)
 			 * a protocol error.
 			 */
 			LOG(LOG_INFO, (""EOF reading packet len""));
-			return -1;
+			goto bail;
 		}
 
 		len_buf_pos += ret;
@@ -506,28 +509,29 @@ read_packet(int fd, gss_buffer_t buf, int timeout, int first)
 	 */
 	if (len > GSTD_MAXPACKETCONTENTS + 512) {
 		LOG(LOG_ERR, (""ridiculous length, %ld"", len));
-		return -1;
+		goto bail;
 	}
 
 	if (!tmpbuf) {
 		if ((tmpbuf = malloc(len)) == NULL) {
 			LOG(LOG_CRIT, (""malloc failure, %ld bytes"", len));
-			return -1;
+			goto bail;
 		}
 	}
 
 	ret = timed_read(fd, tmpbuf + tmpbuf_pos, len - tmpbuf_pos, timeout);
 	if (ret == -1) {
+
 		if (errno == EINTR || errno == EAGAIN)
 			return -2;
 
 		LOG(LOG_ERR, (""%s"", strerror(errno)));
-		return -1;
+		goto bail;
 	}
 
 	if (ret == 0) {
 		LOG(LOG_ERR, (""EOF while reading packet (len=%d)"", len));
-		return -1;
+		goto bail;
 	}
 
 	tmpbuf_pos += ret;
@@ -543,6 +547,12 @@ read_packet(int fd, gss_buffer_t buf, int timeout, int first)
 	}
 
 	return -2;
+
+bail:
+	free(tmpbuf);
+	tmpbuf = NULL;
+
+	return -1;
 }
 
 static int",knc,f237f3e09ecbaf59c897f5046538a7b1a3fa40c1,c78303f9f657a57b7b89b4356de5dd5d0561a257,1,"read_packet(int fd, gss_buffer_t buf, int timeout, int first)
{
	int	  ret;

	static uint32_t		len = 0;
	static char		len_buf[4];
	static int		len_buf_pos = 0;
	static char *		tmpbuf = 0;
	static int		tmpbuf_pos = 0;

	if (first) {
		len_buf_pos = 0;
		return -2;
	}

	if (len_buf_pos < 4) {
		ret = timed_read(fd, &len_buf[len_buf_pos], 4 - len_buf_pos,
		    timeout);

		if (ret == -1) {
			if (errno == EINTR || errno == EAGAIN)
 				return -2;
 
 			LOG(LOG_ERR, (""%s"", strerror(errno)));
//flaw_line_below:
			return -1;
//fix_flaw_line_below:
//			goto bail;
 		}
 
 		if (ret == 0) {		/* EOF */
			/* Failure to read ANY length just means we're done */
			if (len_buf_pos == 0)
				return 0;

			/*
			 * Otherwise, we got EOF mid-length, and that's
 			 * a protocol error.
 			 */
 			LOG(LOG_INFO, (""EOF reading packet len""));
//flaw_line_below:
			return -1;
//fix_flaw_line_below:
//			goto bail;
 		}
 
 		len_buf_pos += ret;
	}

	/* Not done reading the length? */
	if (len_buf_pos != 4)
		return -2;

	/* We have the complete length */
	len = ntohl(*(uint32_t *)len_buf);

	/*
	 * We make sure recvd length is reasonable, allowing for some
	 * slop in enc overhead, beyond the actual maximum number of
	 * bytes of decrypted payload.
 	 */
 	if (len > GSTD_MAXPACKETCONTENTS + 512) {
 		LOG(LOG_ERR, (""ridiculous length, %ld"", len));
//flaw_line_below:
		return -1;
//fix_flaw_line_below:
//		goto bail;
 	}
 
 	if (!tmpbuf) {
 		if ((tmpbuf = malloc(len)) == NULL) {
 			LOG(LOG_CRIT, (""malloc failure, %ld bytes"", len));
//flaw_line_below:
			return -1;
//fix_flaw_line_below:
//			goto bail;
 		}
 	}
 
 	ret = timed_read(fd, tmpbuf + tmpbuf_pos, len - tmpbuf_pos, timeout);
 	if (ret == -1) {
//fix_flaw_line_below:
//
 		if (errno == EINTR || errno == EAGAIN)
 			return -2;
 
 		LOG(LOG_ERR, (""%s"", strerror(errno)));
//flaw_line_below:
		return -1;
//fix_flaw_line_below:
//		goto bail;
 	}
 
 	if (ret == 0) {
 		LOG(LOG_ERR, (""EOF while reading packet (len=%d)"", len));
//flaw_line_below:
		return -1;
//fix_flaw_line_below:
//		goto bail;
 	}
 
 	tmpbuf_pos += ret;

	if (tmpbuf_pos == len) {
		buf->length = len;
		buf->value = tmpbuf;
		len = len_buf_pos = tmpbuf_pos = 0;
		tmpbuf = NULL;

		LOG(LOG_DEBUG, (""read packet of length %d"", buf->length));
		return 1;
 	}
 
 	return -2;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//bail:
//fix_flaw_line_below:
//	free(tmpbuf);
//fix_flaw_line_below:
//	tmpbuf = NULL;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	return -1;
 }
"
4887,182623,,Remote,Single system,Complete,CVE-2015-9253,https://www.cvedetails.com/cve/CVE-2015-9253/,CWE-400,Low,,,,2018-02-19,6.8,"An issue was discovered in PHP 7.3.x before 7.3.0alpha3, 7.2.x before 7.2.8, and before 7.1.20. The php-fpm master process restarts a child process in an endless loop when using program execution functions (e.g., passthru, exec, shell_exec, or system) with a non-blocking STDIN stream, causing this master process to consume 100% of the CPU, and consume disk space with a large volume of error logs, as demonstrated by an attack by a customer of a shared-hosting facility.",2019-04-26,,1,https://github.com/php/php-src/commit/69dee5c732fe982c82edb17d0dbc3e79a47748d8,69dee5c732fe982c82edb17d0dbc3e79a47748d8,"Fixed bug #73342

Directly listen on socket, instead of duping it to STDIN and
listening on that.",0,sapi/fpm/fpm/fpm_children.c,"{""sha"": ""c0e391cb6e246a03c7ba8a840a662fb67a6950c3"", ""filename"": ""NEWS"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/php/php-src/blob/69dee5c732fe982c82edb17d0dbc3e79a47748d8/NEWS"", ""raw_url"": ""https://github.com/php/php-src/raw/69dee5c732fe982c82edb17d0dbc3e79a47748d8/NEWS"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/NEWS?ref=69dee5c732fe982c82edb17d0dbc3e79a47748d8"", ""patch"": ""@@ -5,6 +5,10 @@ PHP                                                                        NEWS\n - Date:\n   . Fixed bug #76462 (Undefined property: DateInterval::$f). (Anatol)\n \n+- FPM:\n+  . Fixed bug #73342 (Vulnerability in php-fpm by changing stdin to\n+    non-blocking). (Nikita)\n+\n 22 Jun 2019, PHP 7.1.19\n \n - CLI Server:""}<_**next**_>{""sha"": ""4ee316ba1b927d5bc5a80911319c759a6e04e814"", ""filename"": ""sapi/fpm/fpm/fpm_children.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/php/php-src/blob/69dee5c732fe982c82edb17d0dbc3e79a47748d8/sapi/fpm/fpm/fpm_children.c"", ""raw_url"": ""https://github.com/php/php-src/raw/69dee5c732fe982c82edb17d0dbc3e79a47748d8/sapi/fpm/fpm/fpm_children.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/sapi/fpm/fpm/fpm_children.c?ref=69dee5c732fe982c82edb17d0dbc3e79a47748d8"", ""patch"": ""@@ -146,6 +146,7 @@ static struct fpm_child_s *fpm_child_find(pid_t pid) /* {{{ */\n static void fpm_child_init(struct fpm_worker_pool_s *wp) /* {{{ */\n {\n \tfpm_globals.max_requests = wp->config->pm_max_requests;\n+\tfpm_globals.listening_socket = dup(wp->listening_socket);\n \n \tif (0 > fpm_stdio_init_child(wp)  ||\n \t    0 > fpm_log_init_child(wp)    ||""}<_**next**_>{""sha"": ""76e8b324df6332f19f83a0d818073f423c56ac49"", ""filename"": ""sapi/fpm/fpm/fpm_stdio.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 6, ""changes"": 6, ""blob_url"": ""https://github.com/php/php-src/blob/69dee5c732fe982c82edb17d0dbc3e79a47748d8/sapi/fpm/fpm/fpm_stdio.c"", ""raw_url"": ""https://github.com/php/php-src/raw/69dee5c732fe982c82edb17d0dbc3e79a47748d8/sapi/fpm/fpm/fpm_stdio.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/sapi/fpm/fpm/fpm_stdio.c?ref=69dee5c732fe982c82edb17d0dbc3e79a47748d8"", ""patch"": ""@@ -103,12 +103,6 @@ int fpm_stdio_init_child(struct fpm_worker_pool_s *wp) /* {{{ */\n \tfpm_globals.error_log_fd = -1;\n \tzlog_set_fd(-1);\n \n-\tif (wp->listening_socket != STDIN_FILENO) {\n-\t\tif (0 > dup2(wp->listening_socket, STDIN_FILENO)) {\n-\t\t\tzlog(ZLOG_SYSERROR, \""failed to init child stdio: dup2()\"");\n-\t\t\treturn -1;\n-\t\t}\n-\t}\n \treturn 0;\n }\n /* }}} */""}<_**next**_>{""sha"": ""3cf44d11ffabc85bda71884153a6874ad6022d32"", ""filename"": ""sapi/fpm/tests/bug73342-nonblocking-stdio.phpt"", ""status"": ""added"", ""additions"": 46, ""deletions"": 0, ""changes"": 46, ""blob_url"": ""https://github.com/php/php-src/blob/69dee5c732fe982c82edb17d0dbc3e79a47748d8/sapi/fpm/tests/bug73342-nonblocking-stdio.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/69dee5c732fe982c82edb17d0dbc3e79a47748d8/sapi/fpm/tests/bug73342-nonblocking-stdio.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/sapi/fpm/tests/bug73342-nonblocking-stdio.phpt?ref=69dee5c732fe982c82edb17d0dbc3e79a47748d8"", ""patch"": ""@@ -0,0 +1,46 @@\n+--TEST--\n+FPM: bug73342 - Non-blocking stdin\n+--SKIPIF--\n+<?php include \""skipif.inc\""; ?>\n+--FILE--\n+<?php\n+\n+require_once \""tester.inc\"";\n+\n+$cfg = <<<EOT\n+[global]\n+error_log = {{FILE:LOG}}\n+[unconfined]\n+listen = {{ADDR}}\n+pm = dynamic\n+pm.max_children = 5\n+pm.start_servers = 1\n+pm.min_spare_servers = 1\n+pm.max_spare_servers = 3\n+EOT;\n+\n+$code = <<<EOT\n+<?php\n+echo \""Before\\n\"";\n+stream_set_blocking(fopen('php://stdin', 'r'), false);\n+echo \""After\\n\"";\n+EOT;\n+\n+$tester = new FPM\\Tester($cfg, $code);\n+$tester->start();\n+$tester->expectLogStartNotices();\n+$tester->request()->expectBody(\""Before\\nAfter\"");\n+$tester->request()->expectBody(\""Before\\nAfter\"");\n+$tester->terminate();\n+$tester->expectLogTerminatingNotices();\n+$tester->close();\n+\n+?>\n+Done\n+--EXPECT--\n+Done\n+--CLEAN--\n+<?php\n+require_once \""tester.inc\"";\n+FPM\\Tester::clean();\n+?>""}"," static void fpm_child_init(struct fpm_worker_pool_s *wp) /* {{{ */
 {
 	fpm_globals.max_requests = wp->config->pm_max_requests;
	fpm_globals.listening_socket = dup(wp->listening_socket);
 
 	if (0 > fpm_stdio_init_child(wp)  ||
 	    0 > fpm_log_init_child(wp)    ||
	    0 > fpm_status_init_child(wp) ||
	    0 > fpm_unix_init_child(wp)   ||
	    0 > fpm_signals_init_child()  ||
	    0 > fpm_env_init_child(wp)    ||
	    0 > fpm_php_init_child(wp)) {

		zlog(ZLOG_ERROR, ""[pool %s] child failed to initialize"", wp->config->name);
		exit(FPM_EXIT_SOFTWARE);
	}
}
/* }}} */
"," static void fpm_child_init(struct fpm_worker_pool_s *wp) /* {{{ */
 {
 	fpm_globals.max_requests = wp->config->pm_max_requests;
 
 	if (0 > fpm_stdio_init_child(wp)  ||
 	    0 > fpm_log_init_child(wp)    ||
	    0 > fpm_status_init_child(wp) ||
	    0 > fpm_unix_init_child(wp)   ||
	    0 > fpm_signals_init_child()  ||
	    0 > fpm_env_init_child(wp)    ||
	    0 > fpm_php_init_child(wp)) {

		zlog(ZLOG_ERROR, ""[pool %s] child failed to initialize"", wp->config->name);
		exit(FPM_EXIT_SOFTWARE);
	}
}
/* }}} */
",C,"	fpm_globals.listening_socket = dup(wp->listening_socket);
",,,"@@ -146,6 +146,7 @@ static struct fpm_child_s *fpm_child_find(pid_t pid) /* {{{ */
 static void fpm_child_init(struct fpm_worker_pool_s *wp) /* {{{ */
 {
 	fpm_globals.max_requests = wp->config->pm_max_requests;
+	fpm_globals.listening_socket = dup(wp->listening_socket);
 
 	if (0 > fpm_stdio_init_child(wp)  ||
 	    0 > fpm_log_init_child(wp)    ||",php-src,69dee5c732fe982c82edb17d0dbc3e79a47748d8,5dd1ef90caec3021e6ce55c8554e695edf641eaf,1," static void fpm_child_init(struct fpm_worker_pool_s *wp) /* {{{ */
 {
 	fpm_globals.max_requests = wp->config->pm_max_requests;
//fix_flaw_line_below:
//	fpm_globals.listening_socket = dup(wp->listening_socket);
 
 	if (0 > fpm_stdio_init_child(wp)  ||
 	    0 > fpm_log_init_child(wp)    ||
	    0 > fpm_status_init_child(wp) ||
	    0 > fpm_unix_init_child(wp)   ||
	    0 > fpm_signals_init_child()  ||
	    0 > fpm_env_init_child(wp)    ||
	    0 > fpm_php_init_child(wp)) {

		zlog(ZLOG_ERROR, ""[pool %s] child failed to initialize"", wp->config->name);
		exit(FPM_EXIT_SOFTWARE);
	}
}
/* }}} */
"
4888,182624,,Remote,Single system,Complete,CVE-2015-9253,https://www.cvedetails.com/cve/CVE-2015-9253/,CWE-400,Low,,,,2018-02-19,6.8,"An issue was discovered in PHP 7.3.x before 7.3.0alpha3, 7.2.x before 7.2.8, and before 7.1.20. The php-fpm master process restarts a child process in an endless loop when using program execution functions (e.g., passthru, exec, shell_exec, or system) with a non-blocking STDIN stream, causing this master process to consume 100% of the CPU, and consume disk space with a large volume of error logs, as demonstrated by an attack by a customer of a shared-hosting facility.",2019-04-26,,0,https://github.com/php/php-src/commit/69dee5c732fe982c82edb17d0dbc3e79a47748d8,69dee5c732fe982c82edb17d0dbc3e79a47748d8,"Fixed bug #73342

Directly listen on socket, instead of duping it to STDIN and
listening on that.",6,sapi/fpm/fpm/fpm_stdio.c,"{""sha"": ""c0e391cb6e246a03c7ba8a840a662fb67a6950c3"", ""filename"": ""NEWS"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/php/php-src/blob/69dee5c732fe982c82edb17d0dbc3e79a47748d8/NEWS"", ""raw_url"": ""https://github.com/php/php-src/raw/69dee5c732fe982c82edb17d0dbc3e79a47748d8/NEWS"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/NEWS?ref=69dee5c732fe982c82edb17d0dbc3e79a47748d8"", ""patch"": ""@@ -5,6 +5,10 @@ PHP                                                                        NEWS\n - Date:\n   . Fixed bug #76462 (Undefined property: DateInterval::$f). (Anatol)\n \n+- FPM:\n+  . Fixed bug #73342 (Vulnerability in php-fpm by changing stdin to\n+    non-blocking). (Nikita)\n+\n 22 Jun 2019, PHP 7.1.19\n \n - CLI Server:""}<_**next**_>{""sha"": ""4ee316ba1b927d5bc5a80911319c759a6e04e814"", ""filename"": ""sapi/fpm/fpm/fpm_children.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/php/php-src/blob/69dee5c732fe982c82edb17d0dbc3e79a47748d8/sapi/fpm/fpm/fpm_children.c"", ""raw_url"": ""https://github.com/php/php-src/raw/69dee5c732fe982c82edb17d0dbc3e79a47748d8/sapi/fpm/fpm/fpm_children.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/sapi/fpm/fpm/fpm_children.c?ref=69dee5c732fe982c82edb17d0dbc3e79a47748d8"", ""patch"": ""@@ -146,6 +146,7 @@ static struct fpm_child_s *fpm_child_find(pid_t pid) /* {{{ */\n static void fpm_child_init(struct fpm_worker_pool_s *wp) /* {{{ */\n {\n \tfpm_globals.max_requests = wp->config->pm_max_requests;\n+\tfpm_globals.listening_socket = dup(wp->listening_socket);\n \n \tif (0 > fpm_stdio_init_child(wp)  ||\n \t    0 > fpm_log_init_child(wp)    ||""}<_**next**_>{""sha"": ""76e8b324df6332f19f83a0d818073f423c56ac49"", ""filename"": ""sapi/fpm/fpm/fpm_stdio.c"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 6, ""changes"": 6, ""blob_url"": ""https://github.com/php/php-src/blob/69dee5c732fe982c82edb17d0dbc3e79a47748d8/sapi/fpm/fpm/fpm_stdio.c"", ""raw_url"": ""https://github.com/php/php-src/raw/69dee5c732fe982c82edb17d0dbc3e79a47748d8/sapi/fpm/fpm/fpm_stdio.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/sapi/fpm/fpm/fpm_stdio.c?ref=69dee5c732fe982c82edb17d0dbc3e79a47748d8"", ""patch"": ""@@ -103,12 +103,6 @@ int fpm_stdio_init_child(struct fpm_worker_pool_s *wp) /* {{{ */\n \tfpm_globals.error_log_fd = -1;\n \tzlog_set_fd(-1);\n \n-\tif (wp->listening_socket != STDIN_FILENO) {\n-\t\tif (0 > dup2(wp->listening_socket, STDIN_FILENO)) {\n-\t\t\tzlog(ZLOG_SYSERROR, \""failed to init child stdio: dup2()\"");\n-\t\t\treturn -1;\n-\t\t}\n-\t}\n \treturn 0;\n }\n /* }}} */""}<_**next**_>{""sha"": ""3cf44d11ffabc85bda71884153a6874ad6022d32"", ""filename"": ""sapi/fpm/tests/bug73342-nonblocking-stdio.phpt"", ""status"": ""added"", ""additions"": 46, ""deletions"": 0, ""changes"": 46, ""blob_url"": ""https://github.com/php/php-src/blob/69dee5c732fe982c82edb17d0dbc3e79a47748d8/sapi/fpm/tests/bug73342-nonblocking-stdio.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/69dee5c732fe982c82edb17d0dbc3e79a47748d8/sapi/fpm/tests/bug73342-nonblocking-stdio.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/sapi/fpm/tests/bug73342-nonblocking-stdio.phpt?ref=69dee5c732fe982c82edb17d0dbc3e79a47748d8"", ""patch"": ""@@ -0,0 +1,46 @@\n+--TEST--\n+FPM: bug73342 - Non-blocking stdin\n+--SKIPIF--\n+<?php include \""skipif.inc\""; ?>\n+--FILE--\n+<?php\n+\n+require_once \""tester.inc\"";\n+\n+$cfg = <<<EOT\n+[global]\n+error_log = {{FILE:LOG}}\n+[unconfined]\n+listen = {{ADDR}}\n+pm = dynamic\n+pm.max_children = 5\n+pm.start_servers = 1\n+pm.min_spare_servers = 1\n+pm.max_spare_servers = 3\n+EOT;\n+\n+$code = <<<EOT\n+<?php\n+echo \""Before\\n\"";\n+stream_set_blocking(fopen('php://stdin', 'r'), false);\n+echo \""After\\n\"";\n+EOT;\n+\n+$tester = new FPM\\Tester($cfg, $code);\n+$tester->start();\n+$tester->expectLogStartNotices();\n+$tester->request()->expectBody(\""Before\\nAfter\"");\n+$tester->request()->expectBody(\""Before\\nAfter\"");\n+$tester->terminate();\n+$tester->expectLogTerminatingNotices();\n+$tester->close();\n+\n+?>\n+Done\n+--EXPECT--\n+Done\n+--CLEAN--\n+<?php\n+require_once \""tester.inc\"";\n+FPM\\Tester::clean();\n+?>""}","int fpm_stdio_init_child(struct fpm_worker_pool_s *wp) /* {{{ */
{
#ifdef HAVE_SYSLOG_H
	if (fpm_globals.error_log_fd == ZLOG_SYSLOG) {
		closelog(); /* ensure to close syslog not to interrupt with PHP syslog code */
	} else
#endif

	/* Notice: child cannot use master error_log
	 * because not aware when being reopen
	 * else, should use if (!fpm_use_error_log())
	 */
	if (fpm_globals.error_log_fd > 0) {
		close(fpm_globals.error_log_fd);
	}
 	fpm_globals.error_log_fd = -1;
 	zlog_set_fd(-1);
 
 	return 0;
 }
 /* }}} */
","int fpm_stdio_init_child(struct fpm_worker_pool_s *wp) /* {{{ */
{
#ifdef HAVE_SYSLOG_H
	if (fpm_globals.error_log_fd == ZLOG_SYSLOG) {
		closelog(); /* ensure to close syslog not to interrupt with PHP syslog code */
	} else
#endif

	/* Notice: child cannot use master error_log
	 * because not aware when being reopen
	 * else, should use if (!fpm_use_error_log())
	 */
	if (fpm_globals.error_log_fd > 0) {
		close(fpm_globals.error_log_fd);
	}
 	fpm_globals.error_log_fd = -1;
 	zlog_set_fd(-1);
 
	if (wp->listening_socket != STDIN_FILENO) {
		if (0 > dup2(wp->listening_socket, STDIN_FILENO)) {
			zlog(ZLOG_SYSERROR, ""failed to init child stdio: dup2()"");
			return -1;
		}
	}
 	return 0;
 }
 /* }}} */
",C,,"	if (wp->listening_socket != STDIN_FILENO) {
		if (0 > dup2(wp->listening_socket, STDIN_FILENO)) {
			zlog(ZLOG_SYSERROR, ""failed to init child stdio: dup2()"");
			return -1;
		}
	}
",,"@@ -103,12 +103,6 @@ int fpm_stdio_init_child(struct fpm_worker_pool_s *wp) /* {{{ */
 	fpm_globals.error_log_fd = -1;
 	zlog_set_fd(-1);
 
-	if (wp->listening_socket != STDIN_FILENO) {
-		if (0 > dup2(wp->listening_socket, STDIN_FILENO)) {
-			zlog(ZLOG_SYSERROR, ""failed to init child stdio: dup2()"");
-			return -1;
-		}
-	}
 	return 0;
 }
 /* }}} */",php-src,69dee5c732fe982c82edb17d0dbc3e79a47748d8,5dd1ef90caec3021e6ce55c8554e695edf641eaf,1,"int fpm_stdio_init_child(struct fpm_worker_pool_s *wp) /* {{{ */
{
#ifdef HAVE_SYSLOG_H
	if (fpm_globals.error_log_fd == ZLOG_SYSLOG) {
		closelog(); /* ensure to close syslog not to interrupt with PHP syslog code */
	} else
#endif

	/* Notice: child cannot use master error_log
	 * because not aware when being reopen
	 * else, should use if (!fpm_use_error_log())
	 */
	if (fpm_globals.error_log_fd > 0) {
		close(fpm_globals.error_log_fd);
	}
 	fpm_globals.error_log_fd = -1;
 	zlog_set_fd(-1);
 
//flaw_line_below:
	if (wp->listening_socket != STDIN_FILENO) {
//flaw_line_below:
		if (0 > dup2(wp->listening_socket, STDIN_FILENO)) {
//flaw_line_below:
			zlog(ZLOG_SYSERROR, ""failed to init child stdio: dup2()"");
//flaw_line_below:
			return -1;
//flaw_line_below:
		}
//flaw_line_below:
	}
 	return 0;
 }
 /* }}} */
"
4919,182655,,Remote,Not required,Partial,CVE-2019-1000020,https://www.cvedetails.com/cve/CVE-2019-1000020/,CWE-400,Medium,,,,2019-02-04,4.3,"libarchive version commit 5a98dcf8a86364b3c2c469c85b93647dfb139961 onwards (version v2.8.0 onwards) contains a CWE-835: Loop with Unreachable Exit Condition ('Infinite Loop') vulnerability in ISO9660 parser, archive_read_support_format_iso9660.c, read_CE()/parse_rockridge() that can result in DoS by infinite loop. This attack appears to be exploitable via the victim opening a specially crafted ISO9660 file.",2019-04-12,,10,https://github.com/libarchive/libarchive/pull/1120/commits/8312eaa576014cd9b965012af51bc1f967b12423,8312eaa576014cd9b965012af51bc1f967b12423,"iso9660: Fail when expected Rockridge extensions is missing

A corrupted or malicious ISO9660 image can cause read_CE() to loop
forever.

read_CE() calls parse_rockridge(), expecting a Rockridge extension
to be read. However, parse_rockridge() is structured as a while
loop starting with a sanity check, and if the sanity check fails
before the loop has run, the function returns ARCHIVE_OK without
advancing the position in the file. This causes read_CE() to retry
indefinitely.

Make parse_rockridge() return ARCHIVE_WARN if it didn't read an
extension. As someone with no real knowledge of the format, this
seems more apt than ARCHIVE_FATAL, but both the call-sites escalate
it to a fatal error immediately anyway.

Found with a combination of AFL, afl-rb (FairFuzz) and qsym.",1,libarchive/archive_read_support_format_iso9660.c,"{""sha"": ""bad8f1dfef3a8b59a6eccd99c909b74a9741c5b0"", ""filename"": ""libarchive/archive_read_support_format_iso9660.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 1, ""changes"": 11, ""blob_url"": ""https://github.com/libarchive/libarchive/blob/8312eaa576014cd9b965012af51bc1f967b12423/libarchive/archive_read_support_format_iso9660.c"", ""raw_url"": ""https://github.com/libarchive/libarchive/raw/8312eaa576014cd9b965012af51bc1f967b12423/libarchive/archive_read_support_format_iso9660.c"", ""contents_url"": ""https://api.github.com/repos/libarchive/libarchive/contents/libarchive/archive_read_support_format_iso9660.c?ref=8312eaa576014cd9b965012af51bc1f967b12423"", ""patch"": ""@@ -2102,6 +2102,7 @@ parse_rockridge(struct archive_read *a, struct file_info *file,\n     const unsigned char *p, const unsigned char *end)\n {\n \tstruct iso9660 *iso9660;\n+\tint entry_seen = 0;\n \n \tiso9660 = (struct iso9660 *)(a->format->data);\n \n@@ -2257,8 +2258,16 @@ parse_rockridge(struct archive_read *a, struct file_info *file,\n \t\t}\n \n \t\tp += p[2];\n+\t\tentry_seen = 1;\n+\t}\n+\n+\tif (entry_seen)\n+\t\treturn (ARCHIVE_OK);\n+\telse {\n+\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n+\t\t\t\t  \""Tried to parse Rockridge extensions, but none found\"");\n+\t\treturn (ARCHIVE_WARN);\n \t}\n-\treturn (ARCHIVE_OK);\n }\n \n static int""}","parse_rockridge(struct archive_read *a, struct file_info *file,
     const unsigned char *p, const unsigned char *end)
 {
 	struct iso9660 *iso9660;
	int entry_seen = 0;
 
 	iso9660 = (struct iso9660 *)(a->format->data);
 
	while (p + 4 <= end  /* Enough space for another entry. */
	    && p[0] >= 'A' && p[0] <= 'Z' /* Sanity-check 1st char of name. */
	    && p[1] >= 'A' && p[1] <= 'Z' /* Sanity-check 2nd char of name. */
	    && p[2] >= 4 /* Sanity-check length. */
	    && p + p[2] <= end) { /* Sanity-check length. */
		const unsigned char *data = p + 4;
		int data_length = p[2] - 4;
		int version = p[3];

		switch(p[0]) {
		case 'C':
			if (p[1] == 'E') {
				if (version == 1 && data_length == 24) {
					/*
					 * CE extension comprises:
					 *   8 byte sector containing extension
					 *   8 byte offset w/in above sector
					 *   8 byte length of continuation
					 */
					int32_t location =
					    archive_le32dec(data);
					file->ce_offset =
					    archive_le32dec(data+8);
					file->ce_size =
					    archive_le32dec(data+16);
					if (register_CE(a, location, file)
					    != ARCHIVE_OK)
						return (ARCHIVE_FATAL);
				}
			}
			else if (p[1] == 'L') {
				if (version == 1 && data_length == 8) {
					file->cl_offset = (uint64_t)
					    iso9660->logical_block_size *
					    (uint64_t)archive_le32dec(data);
					iso9660->seenRockridge = 1;
				}
			}
			break;
		case 'N':
			if (p[1] == 'M') {
				if (version == 1) {
					parse_rockridge_NM1(file,
					    data, data_length);
					iso9660->seenRockridge = 1;
				}
			}
			break;
		case 'P':
			/*
			 * PD extension is padding;
			 * contents are always ignored.
			 *
			 * PL extension won't appear;
			 * contents are always ignored.
			 */
			if (p[1] == 'N') {
				if (version == 1 && data_length == 16) {
					file->rdev = toi(data,4);
					file->rdev <<= 32;
					file->rdev |= toi(data + 8, 4);
					iso9660->seenRockridge = 1;
				}
			}
			else if (p[1] == 'X') {
				/*
				 * PX extension comprises:
				 *   8 bytes for mode,
				 *   8 bytes for nlinks,
				 *   8 bytes for uid,
				 *   8 bytes for gid,
				 *   8 bytes for inode.
				 */
				if (version == 1) {
					if (data_length >= 8)
						file->mode
						    = toi(data, 4);
					if (data_length >= 16)
						file->nlinks
						    = toi(data + 8, 4);
					if (data_length >= 24)
						file->uid
						    = toi(data + 16, 4);
					if (data_length >= 32)
						file->gid
						    = toi(data + 24, 4);
					if (data_length >= 40)
						file->number
						    = toi(data + 32, 4);
					iso9660->seenRockridge = 1;
				}
			}
			break;
		case 'R':
			if (p[1] == 'E' && version == 1) {
				file->re = 1;
				iso9660->seenRockridge = 1;
			}
			else if (p[1] == 'R' && version == 1) {
				/*
				 * RR extension comprises:
				 *    one byte flag value
				 * This extension is obsolete,
				 * so contents are always ignored.
				 */
			}
			break;
		case 'S':
			if (p[1] == 'L') {
				if (version == 1) {
					parse_rockridge_SL1(file,
					    data, data_length);
					iso9660->seenRockridge = 1;
				}
			}
			else if (p[1] == 'T'
			    && data_length == 0 && version == 1) {
				/*
				 * ST extension marks end of this
				 * block of SUSP entries.
				 *
				 * It allows SUSP to coexist with
				 * non-SUSP uses of the System
				 * Use Area by placing non-SUSP data
				 * after SUSP data.
				 */
				iso9660->seenSUSP = 0;
				iso9660->seenRockridge = 0;
				return (ARCHIVE_OK);
			}
			break;
		case 'T':
			if (p[1] == 'F') {
				if (version == 1) {
					parse_rockridge_TF1(file,
					    data, data_length);
					iso9660->seenRockridge = 1;
				}
			}
			break;
		case 'Z':
			if (p[1] == 'F') {
				if (version == 1)
					parse_rockridge_ZF1(file,
					    data, data_length);
			}
			break;
		default:
			break;
 		}
 
 		p += p[2];
		entry_seen = 1;
	}

	if (entry_seen)
		return (ARCHIVE_OK);
	else {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
				  ""Tried to parse Rockridge extensions, but none found"");
		return (ARCHIVE_WARN);
 	}
 }
","parse_rockridge(struct archive_read *a, struct file_info *file,
     const unsigned char *p, const unsigned char *end)
 {
 	struct iso9660 *iso9660;
 
 	iso9660 = (struct iso9660 *)(a->format->data);
 
	while (p + 4 <= end  /* Enough space for another entry. */
	    && p[0] >= 'A' && p[0] <= 'Z' /* Sanity-check 1st char of name. */
	    && p[1] >= 'A' && p[1] <= 'Z' /* Sanity-check 2nd char of name. */
	    && p[2] >= 4 /* Sanity-check length. */
	    && p + p[2] <= end) { /* Sanity-check length. */
		const unsigned char *data = p + 4;
		int data_length = p[2] - 4;
		int version = p[3];

		switch(p[0]) {
		case 'C':
			if (p[1] == 'E') {
				if (version == 1 && data_length == 24) {
					/*
					 * CE extension comprises:
					 *   8 byte sector containing extension
					 *   8 byte offset w/in above sector
					 *   8 byte length of continuation
					 */
					int32_t location =
					    archive_le32dec(data);
					file->ce_offset =
					    archive_le32dec(data+8);
					file->ce_size =
					    archive_le32dec(data+16);
					if (register_CE(a, location, file)
					    != ARCHIVE_OK)
						return (ARCHIVE_FATAL);
				}
			}
			else if (p[1] == 'L') {
				if (version == 1 && data_length == 8) {
					file->cl_offset = (uint64_t)
					    iso9660->logical_block_size *
					    (uint64_t)archive_le32dec(data);
					iso9660->seenRockridge = 1;
				}
			}
			break;
		case 'N':
			if (p[1] == 'M') {
				if (version == 1) {
					parse_rockridge_NM1(file,
					    data, data_length);
					iso9660->seenRockridge = 1;
				}
			}
			break;
		case 'P':
			/*
			 * PD extension is padding;
			 * contents are always ignored.
			 *
			 * PL extension won't appear;
			 * contents are always ignored.
			 */
			if (p[1] == 'N') {
				if (version == 1 && data_length == 16) {
					file->rdev = toi(data,4);
					file->rdev <<= 32;
					file->rdev |= toi(data + 8, 4);
					iso9660->seenRockridge = 1;
				}
			}
			else if (p[1] == 'X') {
				/*
				 * PX extension comprises:
				 *   8 bytes for mode,
				 *   8 bytes for nlinks,
				 *   8 bytes for uid,
				 *   8 bytes for gid,
				 *   8 bytes for inode.
				 */
				if (version == 1) {
					if (data_length >= 8)
						file->mode
						    = toi(data, 4);
					if (data_length >= 16)
						file->nlinks
						    = toi(data + 8, 4);
					if (data_length >= 24)
						file->uid
						    = toi(data + 16, 4);
					if (data_length >= 32)
						file->gid
						    = toi(data + 24, 4);
					if (data_length >= 40)
						file->number
						    = toi(data + 32, 4);
					iso9660->seenRockridge = 1;
				}
			}
			break;
		case 'R':
			if (p[1] == 'E' && version == 1) {
				file->re = 1;
				iso9660->seenRockridge = 1;
			}
			else if (p[1] == 'R' && version == 1) {
				/*
				 * RR extension comprises:
				 *    one byte flag value
				 * This extension is obsolete,
				 * so contents are always ignored.
				 */
			}
			break;
		case 'S':
			if (p[1] == 'L') {
				if (version == 1) {
					parse_rockridge_SL1(file,
					    data, data_length);
					iso9660->seenRockridge = 1;
				}
			}
			else if (p[1] == 'T'
			    && data_length == 0 && version == 1) {
				/*
				 * ST extension marks end of this
				 * block of SUSP entries.
				 *
				 * It allows SUSP to coexist with
				 * non-SUSP uses of the System
				 * Use Area by placing non-SUSP data
				 * after SUSP data.
				 */
				iso9660->seenSUSP = 0;
				iso9660->seenRockridge = 0;
				return (ARCHIVE_OK);
			}
			break;
		case 'T':
			if (p[1] == 'F') {
				if (version == 1) {
					parse_rockridge_TF1(file,
					    data, data_length);
					iso9660->seenRockridge = 1;
				}
			}
			break;
		case 'Z':
			if (p[1] == 'F') {
				if (version == 1)
					parse_rockridge_ZF1(file,
					    data, data_length);
			}
			break;
		default:
			break;
 		}
 
 		p += p[2];
 	}
	return (ARCHIVE_OK);
 }
",C,"	int entry_seen = 0;
		entry_seen = 1;
	}

	if (entry_seen)
		return (ARCHIVE_OK);
	else {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
				  ""Tried to parse Rockridge extensions, but none found"");
		return (ARCHIVE_WARN);
","	return (ARCHIVE_OK);
",,"@@ -2102,6 +2102,7 @@ parse_rockridge(struct archive_read *a, struct file_info *file,
     const unsigned char *p, const unsigned char *end)
 {
 	struct iso9660 *iso9660;
+	int entry_seen = 0;
 
 	iso9660 = (struct iso9660 *)(a->format->data);
 
@@ -2257,8 +2258,16 @@ parse_rockridge(struct archive_read *a, struct file_info *file,
 		}
 
 		p += p[2];
+		entry_seen = 1;
+	}
+
+	if (entry_seen)
+		return (ARCHIVE_OK);
+	else {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+				  ""Tried to parse Rockridge extensions, but none found"");
+		return (ARCHIVE_WARN);
 	}
-	return (ARCHIVE_OK);
 }
 
 static int",libarchive,8312eaa576014cd9b965012af51bc1f967b12423,ce8ddb0ae1ea6b92e4ccac827e1cb79b76e6df80,1,"parse_rockridge(struct archive_read *a, struct file_info *file,
     const unsigned char *p, const unsigned char *end)
 {
 	struct iso9660 *iso9660;
//fix_flaw_line_below:
//	int entry_seen = 0;
 
 	iso9660 = (struct iso9660 *)(a->format->data);
 
	while (p + 4 <= end  /* Enough space for another entry. */
	    && p[0] >= 'A' && p[0] <= 'Z' /* Sanity-check 1st char of name. */
	    && p[1] >= 'A' && p[1] <= 'Z' /* Sanity-check 2nd char of name. */
	    && p[2] >= 4 /* Sanity-check length. */
	    && p + p[2] <= end) { /* Sanity-check length. */
		const unsigned char *data = p + 4;
		int data_length = p[2] - 4;
		int version = p[3];

		switch(p[0]) {
		case 'C':
			if (p[1] == 'E') {
				if (version == 1 && data_length == 24) {
					/*
					 * CE extension comprises:
					 *   8 byte sector containing extension
					 *   8 byte offset w/in above sector
					 *   8 byte length of continuation
					 */
					int32_t location =
					    archive_le32dec(data);
					file->ce_offset =
					    archive_le32dec(data+8);
					file->ce_size =
					    archive_le32dec(data+16);
					if (register_CE(a, location, file)
					    != ARCHIVE_OK)
						return (ARCHIVE_FATAL);
				}
			}
			else if (p[1] == 'L') {
				if (version == 1 && data_length == 8) {
					file->cl_offset = (uint64_t)
					    iso9660->logical_block_size *
					    (uint64_t)archive_le32dec(data);
					iso9660->seenRockridge = 1;
				}
			}
			break;
		case 'N':
			if (p[1] == 'M') {
				if (version == 1) {
					parse_rockridge_NM1(file,
					    data, data_length);
					iso9660->seenRockridge = 1;
				}
			}
			break;
		case 'P':
			/*
			 * PD extension is padding;
			 * contents are always ignored.
			 *
			 * PL extension won't appear;
			 * contents are always ignored.
			 */
			if (p[1] == 'N') {
				if (version == 1 && data_length == 16) {
					file->rdev = toi(data,4);
					file->rdev <<= 32;
					file->rdev |= toi(data + 8, 4);
					iso9660->seenRockridge = 1;
				}
			}
			else if (p[1] == 'X') {
				/*
				 * PX extension comprises:
				 *   8 bytes for mode,
				 *   8 bytes for nlinks,
				 *   8 bytes for uid,
				 *   8 bytes for gid,
				 *   8 bytes for inode.
				 */
				if (version == 1) {
					if (data_length >= 8)
						file->mode
						    = toi(data, 4);
					if (data_length >= 16)
						file->nlinks
						    = toi(data + 8, 4);
					if (data_length >= 24)
						file->uid
						    = toi(data + 16, 4);
					if (data_length >= 32)
						file->gid
						    = toi(data + 24, 4);
					if (data_length >= 40)
						file->number
						    = toi(data + 32, 4);
					iso9660->seenRockridge = 1;
				}
			}
			break;
		case 'R':
			if (p[1] == 'E' && version == 1) {
				file->re = 1;
				iso9660->seenRockridge = 1;
			}
			else if (p[1] == 'R' && version == 1) {
				/*
				 * RR extension comprises:
				 *    one byte flag value
				 * This extension is obsolete,
				 * so contents are always ignored.
				 */
			}
			break;
		case 'S':
			if (p[1] == 'L') {
				if (version == 1) {
					parse_rockridge_SL1(file,
					    data, data_length);
					iso9660->seenRockridge = 1;
				}
			}
			else if (p[1] == 'T'
			    && data_length == 0 && version == 1) {
				/*
				 * ST extension marks end of this
				 * block of SUSP entries.
				 *
				 * It allows SUSP to coexist with
				 * non-SUSP uses of the System
				 * Use Area by placing non-SUSP data
				 * after SUSP data.
				 */
				iso9660->seenSUSP = 0;
				iso9660->seenRockridge = 0;
				return (ARCHIVE_OK);
			}
			break;
		case 'T':
			if (p[1] == 'F') {
				if (version == 1) {
					parse_rockridge_TF1(file,
					    data, data_length);
					iso9660->seenRockridge = 1;
				}
			}
			break;
		case 'Z':
			if (p[1] == 'F') {
				if (version == 1)
					parse_rockridge_ZF1(file,
					    data, data_length);
			}
			break;
		default:
			break;
 		}
 
 		p += p[2];
//fix_flaw_line_below:
//		entry_seen = 1;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (entry_seen)
//fix_flaw_line_below:
//		return (ARCHIVE_OK);
//fix_flaw_line_below:
//	else {
//fix_flaw_line_below:
//		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
//fix_flaw_line_below:
//				  ""Tried to parse Rockridge extensions, but none found"");
//fix_flaw_line_below:
//		return (ARCHIVE_WARN);
 	}
//flaw_line_below:
	return (ARCHIVE_OK);
 }
"
4928,182664,,Local,Not required,Complete,CVE-2019-17351,https://www.cvedetails.com/cve/CVE-2019-17351/,CWE-400,Low,,,,2019-10-07,4.9,"An issue was discovered in drivers/xen/balloon.c in the Linux kernel before 5.2.3, as used in Xen through 4.12.x, allowing guest OS users to cause a denial of service because of unrestricted resource consumption during the mapping of guest memory, aka CID-6ef36ab967c7.",2019-10-11,DoS ,3,https://github.com/torvalds/linux/commit/6ef36ab967c71690ebe7e5ef997a8be4da3bc844,6ef36ab967c71690ebe7e5ef997a8be4da3bc844,"xen: let alloc_xenballooned_pages() fail if not enough memory free

commit a1078e821b605813b63bf6bca414a85f804d5c66 upstream.

Instead of trying to allocate pages with GFP_USER in
add_ballooned_pages() check the available free memory via
si_mem_available(). GFP_USER is far less limiting memory exhaustion
than the test via si_mem_available().

This will avoid dom0 running out of memory due to excessive foreign
page mappings especially on ARM and on x86 in PVH mode, as those don't
have a pre-ballooned area which can be used for foreign mappings.

As the normal ballooning suffers from the same problem don't balloon
down more than si_mem_available() pages in one iteration. At the same
time limit the default maximum number of retries.

This is part of XSA-300.

Signed-off-by: Juergen Gross <jgross@suse.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",0,drivers/xen/balloon.c,"{""sha"": ""559768dc2567b8e35ed4b0b52ed468c33a67eec2"", ""filename"": ""drivers/xen/balloon.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 3, ""changes"": 16, ""blob_url"": ""https://github.com/torvalds/linux/blob/6ef36ab967c71690ebe7e5ef997a8be4da3bc844/drivers/xen/balloon.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/6ef36ab967c71690ebe7e5ef997a8be4da3bc844/drivers/xen/balloon.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/xen/balloon.c?ref=6ef36ab967c71690ebe7e5ef997a8be4da3bc844"", ""patch"": ""@@ -538,8 +538,15 @@ static void balloon_process(struct work_struct *work)\n \t\t\t\tstate = reserve_additional_memory();\n \t\t}\n \n-\t\tif (credit < 0)\n-\t\t\tstate = decrease_reservation(-credit, GFP_BALLOON);\n+\t\tif (credit < 0) {\n+\t\t\tlong n_pages;\n+\n+\t\t\tn_pages = min(-credit, si_mem_available());\n+\t\t\tstate = decrease_reservation(n_pages, GFP_BALLOON);\n+\t\t\tif (state == BP_DONE && n_pages != -credit &&\n+\t\t\t    n_pages < totalreserve_pages)\n+\t\t\t\tstate = BP_EAGAIN;\n+\t\t}\n \n \t\tstate = update_schedule(state);\n \n@@ -578,6 +585,9 @@ static int add_ballooned_pages(int nr_pages)\n \t\t}\n \t}\n \n+\tif (si_mem_available() < nr_pages)\n+\t\treturn -ENOMEM;\n+\n \tst = decrease_reservation(nr_pages, GFP_USER);\n \tif (st != BP_DONE)\n \t\treturn -ENOMEM;\n@@ -710,7 +720,7 @@ static int __init balloon_init(void)\n \tballoon_stats.schedule_delay = 1;\n \tballoon_stats.max_schedule_delay = 32;\n \tballoon_stats.retry_count = 1;\n-\tballoon_stats.max_retry_count = RETRY_UNLIMITED;\n+\tballoon_stats.max_retry_count = 4;\n \n #ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG\n \tset_online_page_callback(&xen_online_page);""}","static int add_ballooned_pages(int nr_pages)
{
	enum bp_state st;

	if (xen_hotplug_unpopulated) {
		st = reserve_additional_memory();
		if (st != BP_ECANCELED) {
			mutex_unlock(&balloon_mutex);
			wait_event(balloon_wq,
				   !list_empty(&ballooned_pages));
			mutex_lock(&balloon_mutex);
			return 0;
 		}
 	}
 
	if (si_mem_available() < nr_pages)
		return -ENOMEM;

 	st = decrease_reservation(nr_pages, GFP_USER);
 	if (st != BP_DONE)
 		return -ENOMEM;

	return 0;
}
","static int add_ballooned_pages(int nr_pages)
{
	enum bp_state st;

	if (xen_hotplug_unpopulated) {
		st = reserve_additional_memory();
		if (st != BP_ECANCELED) {
			mutex_unlock(&balloon_mutex);
			wait_event(balloon_wq,
				   !list_empty(&ballooned_pages));
			mutex_lock(&balloon_mutex);
			return 0;
 		}
 	}
 
 	st = decrease_reservation(nr_pages, GFP_USER);
 	if (st != BP_DONE)
 		return -ENOMEM;

	return 0;
}
",C,"	if (si_mem_available() < nr_pages)
		return -ENOMEM;

",,,"@@ -538,8 +538,15 @@ static void balloon_process(struct work_struct *work)
 				state = reserve_additional_memory();
 		}
 
-		if (credit < 0)
-			state = decrease_reservation(-credit, GFP_BALLOON);
+		if (credit < 0) {
+			long n_pages;
+
+			n_pages = min(-credit, si_mem_available());
+			state = decrease_reservation(n_pages, GFP_BALLOON);
+			if (state == BP_DONE && n_pages != -credit &&
+			    n_pages < totalreserve_pages)
+				state = BP_EAGAIN;
+		}
 
 		state = update_schedule(state);
 
@@ -578,6 +585,9 @@ static int add_ballooned_pages(int nr_pages)
 		}
 	}
 
+	if (si_mem_available() < nr_pages)
+		return -ENOMEM;
+
 	st = decrease_reservation(nr_pages, GFP_USER);
 	if (st != BP_DONE)
 		return -ENOMEM;
@@ -710,7 +720,7 @@ static int __init balloon_init(void)
 	balloon_stats.schedule_delay = 1;
 	balloon_stats.max_schedule_delay = 32;
 	balloon_stats.retry_count = 1;
-	balloon_stats.max_retry_count = RETRY_UNLIMITED;
+	balloon_stats.max_retry_count = 4;
 
 #ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG
 	set_online_page_callback(&xen_online_page);",linux,6ef36ab967c71690ebe7e5ef997a8be4da3bc844,d39c2e97277229970fe2ae56dcbf67a535e14873,1,"static int add_ballooned_pages(int nr_pages)
{
	enum bp_state st;

	if (xen_hotplug_unpopulated) {
		st = reserve_additional_memory();
		if (st != BP_ECANCELED) {
			mutex_unlock(&balloon_mutex);
			wait_event(balloon_wq,
				   !list_empty(&ballooned_pages));
			mutex_lock(&balloon_mutex);
			return 0;
 		}
 	}
 
//fix_flaw_line_below:
//	if (si_mem_available() < nr_pages)
//fix_flaw_line_below:
//		return -ENOMEM;
//fix_flaw_line_below:
//
 	st = decrease_reservation(nr_pages, GFP_USER);
 	if (st != BP_DONE)
 		return -ENOMEM;

	return 0;
}
"
4929,182665,,Local,Not required,Complete,CVE-2019-17351,https://www.cvedetails.com/cve/CVE-2019-17351/,CWE-400,Low,,,,2019-10-07,4.9,"An issue was discovered in drivers/xen/balloon.c in the Linux kernel before 5.2.3, as used in Xen through 4.12.x, allowing guest OS users to cause a denial of service because of unrestricted resource consumption during the mapping of guest memory, aka CID-6ef36ab967c7.",2019-10-11,DoS ,1,https://github.com/torvalds/linux/commit/6ef36ab967c71690ebe7e5ef997a8be4da3bc844,6ef36ab967c71690ebe7e5ef997a8be4da3bc844,"xen: let alloc_xenballooned_pages() fail if not enough memory free

commit a1078e821b605813b63bf6bca414a85f804d5c66 upstream.

Instead of trying to allocate pages with GFP_USER in
add_ballooned_pages() check the available free memory via
si_mem_available(). GFP_USER is far less limiting memory exhaustion
than the test via si_mem_available().

This will avoid dom0 running out of memory due to excessive foreign
page mappings especially on ARM and on x86 in PVH mode, as those don't
have a pre-ballooned area which can be used for foreign mappings.

As the normal ballooning suffers from the same problem don't balloon
down more than si_mem_available() pages in one iteration. At the same
time limit the default maximum number of retries.

This is part of XSA-300.

Signed-off-by: Juergen Gross <jgross@suse.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",1,drivers/xen/balloon.c,"{""sha"": ""559768dc2567b8e35ed4b0b52ed468c33a67eec2"", ""filename"": ""drivers/xen/balloon.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 3, ""changes"": 16, ""blob_url"": ""https://github.com/torvalds/linux/blob/6ef36ab967c71690ebe7e5ef997a8be4da3bc844/drivers/xen/balloon.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/6ef36ab967c71690ebe7e5ef997a8be4da3bc844/drivers/xen/balloon.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/xen/balloon.c?ref=6ef36ab967c71690ebe7e5ef997a8be4da3bc844"", ""patch"": ""@@ -538,8 +538,15 @@ static void balloon_process(struct work_struct *work)\n \t\t\t\tstate = reserve_additional_memory();\n \t\t}\n \n-\t\tif (credit < 0)\n-\t\t\tstate = decrease_reservation(-credit, GFP_BALLOON);\n+\t\tif (credit < 0) {\n+\t\t\tlong n_pages;\n+\n+\t\t\tn_pages = min(-credit, si_mem_available());\n+\t\t\tstate = decrease_reservation(n_pages, GFP_BALLOON);\n+\t\t\tif (state == BP_DONE && n_pages != -credit &&\n+\t\t\t    n_pages < totalreserve_pages)\n+\t\t\t\tstate = BP_EAGAIN;\n+\t\t}\n \n \t\tstate = update_schedule(state);\n \n@@ -578,6 +585,9 @@ static int add_ballooned_pages(int nr_pages)\n \t\t}\n \t}\n \n+\tif (si_mem_available() < nr_pages)\n+\t\treturn -ENOMEM;\n+\n \tst = decrease_reservation(nr_pages, GFP_USER);\n \tif (st != BP_DONE)\n \t\treturn -ENOMEM;\n@@ -710,7 +720,7 @@ static int __init balloon_init(void)\n \tballoon_stats.schedule_delay = 1;\n \tballoon_stats.max_schedule_delay = 32;\n \tballoon_stats.retry_count = 1;\n-\tballoon_stats.max_retry_count = RETRY_UNLIMITED;\n+\tballoon_stats.max_retry_count = 4;\n \n #ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG\n \tset_online_page_callback(&xen_online_page);""}","static int __init balloon_init(void)
{
	if (!xen_domain())
		return -ENODEV;

	pr_info(""Initialising balloon driver\n"");

#ifdef CONFIG_XEN_PV
	balloon_stats.current_pages = xen_pv_domain()
		? min(xen_start_info->nr_pages - xen_released_pages, max_pfn)
		: get_num_physpages();
#else
	balloon_stats.current_pages = get_num_physpages();
#endif
	balloon_stats.target_pages  = balloon_stats.current_pages;
	balloon_stats.balloon_low   = 0;
	balloon_stats.balloon_high  = 0;
	balloon_stats.total_pages   = balloon_stats.current_pages;

 	balloon_stats.schedule_delay = 1;
 	balloon_stats.max_schedule_delay = 32;
 	balloon_stats.retry_count = 1;
	balloon_stats.max_retry_count = 4;
 
 #ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG
 	set_online_page_callback(&xen_online_page);
	register_memory_notifier(&xen_memory_nb);
	register_sysctl_table(xen_root);
#endif

#ifdef CONFIG_XEN_PV
	{
		int i;

		/*
		 * Initialize the balloon with pages from the extra memory
		 * regions (see arch/x86/xen/setup.c).
		 */
		for (i = 0; i < XEN_EXTRA_MEM_MAX_REGIONS; i++)
			if (xen_extra_mem[i].n_pfns)
				balloon_add_region(xen_extra_mem[i].start_pfn,
						   xen_extra_mem[i].n_pfns);
	}
#endif

	/* Init the xen-balloon driver. */
	xen_balloon_init();

	return 0;
}
","static int __init balloon_init(void)
{
	if (!xen_domain())
		return -ENODEV;

	pr_info(""Initialising balloon driver\n"");

#ifdef CONFIG_XEN_PV
	balloon_stats.current_pages = xen_pv_domain()
		? min(xen_start_info->nr_pages - xen_released_pages, max_pfn)
		: get_num_physpages();
#else
	balloon_stats.current_pages = get_num_physpages();
#endif
	balloon_stats.target_pages  = balloon_stats.current_pages;
	balloon_stats.balloon_low   = 0;
	balloon_stats.balloon_high  = 0;
	balloon_stats.total_pages   = balloon_stats.current_pages;

 	balloon_stats.schedule_delay = 1;
 	balloon_stats.max_schedule_delay = 32;
 	balloon_stats.retry_count = 1;
	balloon_stats.max_retry_count = RETRY_UNLIMITED;
 
 #ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG
 	set_online_page_callback(&xen_online_page);
	register_memory_notifier(&xen_memory_nb);
	register_sysctl_table(xen_root);
#endif

#ifdef CONFIG_XEN_PV
	{
		int i;

		/*
		 * Initialize the balloon with pages from the extra memory
		 * regions (see arch/x86/xen/setup.c).
		 */
		for (i = 0; i < XEN_EXTRA_MEM_MAX_REGIONS; i++)
			if (xen_extra_mem[i].n_pfns)
				balloon_add_region(xen_extra_mem[i].start_pfn,
						   xen_extra_mem[i].n_pfns);
	}
#endif

	/* Init the xen-balloon driver. */
	xen_balloon_init();

	return 0;
}
",C,"	balloon_stats.max_retry_count = 4;
","	balloon_stats.max_retry_count = RETRY_UNLIMITED;
",,"@@ -538,8 +538,15 @@ static void balloon_process(struct work_struct *work)
 				state = reserve_additional_memory();
 		}
 
-		if (credit < 0)
-			state = decrease_reservation(-credit, GFP_BALLOON);
+		if (credit < 0) {
+			long n_pages;
+
+			n_pages = min(-credit, si_mem_available());
+			state = decrease_reservation(n_pages, GFP_BALLOON);
+			if (state == BP_DONE && n_pages != -credit &&
+			    n_pages < totalreserve_pages)
+				state = BP_EAGAIN;
+		}
 
 		state = update_schedule(state);
 
@@ -578,6 +585,9 @@ static int add_ballooned_pages(int nr_pages)
 		}
 	}
 
+	if (si_mem_available() < nr_pages)
+		return -ENOMEM;
+
 	st = decrease_reservation(nr_pages, GFP_USER);
 	if (st != BP_DONE)
 		return -ENOMEM;
@@ -710,7 +720,7 @@ static int __init balloon_init(void)
 	balloon_stats.schedule_delay = 1;
 	balloon_stats.max_schedule_delay = 32;
 	balloon_stats.retry_count = 1;
-	balloon_stats.max_retry_count = RETRY_UNLIMITED;
+	balloon_stats.max_retry_count = 4;
 
 #ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG
 	set_online_page_callback(&xen_online_page);",linux,6ef36ab967c71690ebe7e5ef997a8be4da3bc844,d39c2e97277229970fe2ae56dcbf67a535e14873,1,"static int __init balloon_init(void)
{
	if (!xen_domain())
		return -ENODEV;

	pr_info(""Initialising balloon driver\n"");

#ifdef CONFIG_XEN_PV
	balloon_stats.current_pages = xen_pv_domain()
		? min(xen_start_info->nr_pages - xen_released_pages, max_pfn)
		: get_num_physpages();
#else
	balloon_stats.current_pages = get_num_physpages();
#endif
	balloon_stats.target_pages  = balloon_stats.current_pages;
	balloon_stats.balloon_low   = 0;
	balloon_stats.balloon_high  = 0;
	balloon_stats.total_pages   = balloon_stats.current_pages;

 	balloon_stats.schedule_delay = 1;
 	balloon_stats.max_schedule_delay = 32;
 	balloon_stats.retry_count = 1;
//flaw_line_below:
	balloon_stats.max_retry_count = RETRY_UNLIMITED;
//fix_flaw_line_below:
//	balloon_stats.max_retry_count = 4;
 
 #ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG
 	set_online_page_callback(&xen_online_page);
	register_memory_notifier(&xen_memory_nb);
	register_sysctl_table(xen_root);
#endif

#ifdef CONFIG_XEN_PV
	{
		int i;

		/*
		 * Initialize the balloon with pages from the extra memory
		 * regions (see arch/x86/xen/setup.c).
		 */
		for (i = 0; i < XEN_EXTRA_MEM_MAX_REGIONS; i++)
			if (xen_extra_mem[i].n_pfns)
				balloon_add_region(xen_extra_mem[i].start_pfn,
						   xen_extra_mem[i].n_pfns);
	}
#endif

	/* Init the xen-balloon driver. */
	xen_balloon_init();

	return 0;
}
"
4930,182666,,Local,Not required,Complete,CVE-2019-17351,https://www.cvedetails.com/cve/CVE-2019-17351/,CWE-400,Low,,,,2019-10-07,4.9,"An issue was discovered in drivers/xen/balloon.c in the Linux kernel before 5.2.3, as used in Xen through 4.12.x, allowing guest OS users to cause a denial of service because of unrestricted resource consumption during the mapping of guest memory, aka CID-6ef36ab967c7.",2019-10-11,DoS ,9,https://github.com/torvalds/linux/commit/6ef36ab967c71690ebe7e5ef997a8be4da3bc844,6ef36ab967c71690ebe7e5ef997a8be4da3bc844,"xen: let alloc_xenballooned_pages() fail if not enough memory free

commit a1078e821b605813b63bf6bca414a85f804d5c66 upstream.

Instead of trying to allocate pages with GFP_USER in
add_ballooned_pages() check the available free memory via
si_mem_available(). GFP_USER is far less limiting memory exhaustion
than the test via si_mem_available().

This will avoid dom0 running out of memory due to excessive foreign
page mappings especially on ARM and on x86 in PVH mode, as those don't
have a pre-ballooned area which can be used for foreign mappings.

As the normal ballooning suffers from the same problem don't balloon
down more than si_mem_available() pages in one iteration. At the same
time limit the default maximum number of retries.

This is part of XSA-300.

Signed-off-by: Juergen Gross <jgross@suse.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",2,drivers/xen/balloon.c,"{""sha"": ""559768dc2567b8e35ed4b0b52ed468c33a67eec2"", ""filename"": ""drivers/xen/balloon.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 3, ""changes"": 16, ""blob_url"": ""https://github.com/torvalds/linux/blob/6ef36ab967c71690ebe7e5ef997a8be4da3bc844/drivers/xen/balloon.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/6ef36ab967c71690ebe7e5ef997a8be4da3bc844/drivers/xen/balloon.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/xen/balloon.c?ref=6ef36ab967c71690ebe7e5ef997a8be4da3bc844"", ""patch"": ""@@ -538,8 +538,15 @@ static void balloon_process(struct work_struct *work)\n \t\t\t\tstate = reserve_additional_memory();\n \t\t}\n \n-\t\tif (credit < 0)\n-\t\t\tstate = decrease_reservation(-credit, GFP_BALLOON);\n+\t\tif (credit < 0) {\n+\t\t\tlong n_pages;\n+\n+\t\t\tn_pages = min(-credit, si_mem_available());\n+\t\t\tstate = decrease_reservation(n_pages, GFP_BALLOON);\n+\t\t\tif (state == BP_DONE && n_pages != -credit &&\n+\t\t\t    n_pages < totalreserve_pages)\n+\t\t\t\tstate = BP_EAGAIN;\n+\t\t}\n \n \t\tstate = update_schedule(state);\n \n@@ -578,6 +585,9 @@ static int add_ballooned_pages(int nr_pages)\n \t\t}\n \t}\n \n+\tif (si_mem_available() < nr_pages)\n+\t\treturn -ENOMEM;\n+\n \tst = decrease_reservation(nr_pages, GFP_USER);\n \tif (st != BP_DONE)\n \t\treturn -ENOMEM;\n@@ -710,7 +720,7 @@ static int __init balloon_init(void)\n \tballoon_stats.schedule_delay = 1;\n \tballoon_stats.max_schedule_delay = 32;\n \tballoon_stats.retry_count = 1;\n-\tballoon_stats.max_retry_count = RETRY_UNLIMITED;\n+\tballoon_stats.max_retry_count = 4;\n \n #ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG\n \tset_online_page_callback(&xen_online_page);""}","static void balloon_process(struct work_struct *work)
{
	enum bp_state state = BP_DONE;
	long credit;


	do {
		mutex_lock(&balloon_mutex);

		credit = current_credit();

		if (credit > 0) {
			if (balloon_is_inflated())
				state = increase_reservation(credit);
			else
 				state = reserve_additional_memory();
 		}
 
		if (credit < 0) {
			long n_pages;

			n_pages = min(-credit, si_mem_available());
			state = decrease_reservation(n_pages, GFP_BALLOON);
			if (state == BP_DONE && n_pages != -credit &&
			    n_pages < totalreserve_pages)
				state = BP_EAGAIN;
		}
 
 		state = update_schedule(state);
 
		mutex_unlock(&balloon_mutex);

		cond_resched();

	} while (credit && state == BP_DONE);

	/* Schedule more work if there is some still to be done. */
	if (state == BP_EAGAIN)
		schedule_delayed_work(&balloon_worker, balloon_stats.schedule_delay * HZ);
}
","static void balloon_process(struct work_struct *work)
{
	enum bp_state state = BP_DONE;
	long credit;


	do {
		mutex_lock(&balloon_mutex);

		credit = current_credit();

		if (credit > 0) {
			if (balloon_is_inflated())
				state = increase_reservation(credit);
			else
 				state = reserve_additional_memory();
 		}
 
		if (credit < 0)
			state = decrease_reservation(-credit, GFP_BALLOON);
 
 		state = update_schedule(state);
 
		mutex_unlock(&balloon_mutex);

		cond_resched();

	} while (credit && state == BP_DONE);

	/* Schedule more work if there is some still to be done. */
	if (state == BP_EAGAIN)
		schedule_delayed_work(&balloon_worker, balloon_stats.schedule_delay * HZ);
}
",C,"		if (credit < 0) {
			long n_pages;

			n_pages = min(-credit, si_mem_available());
			state = decrease_reservation(n_pages, GFP_BALLOON);
			if (state == BP_DONE && n_pages != -credit &&
			    n_pages < totalreserve_pages)
				state = BP_EAGAIN;
		}
","		if (credit < 0)
			state = decrease_reservation(-credit, GFP_BALLOON);
",,"@@ -538,8 +538,15 @@ static void balloon_process(struct work_struct *work)
 				state = reserve_additional_memory();
 		}
 
-		if (credit < 0)
-			state = decrease_reservation(-credit, GFP_BALLOON);
+		if (credit < 0) {
+			long n_pages;
+
+			n_pages = min(-credit, si_mem_available());
+			state = decrease_reservation(n_pages, GFP_BALLOON);
+			if (state == BP_DONE && n_pages != -credit &&
+			    n_pages < totalreserve_pages)
+				state = BP_EAGAIN;
+		}
 
 		state = update_schedule(state);
 
@@ -578,6 +585,9 @@ static int add_ballooned_pages(int nr_pages)
 		}
 	}
 
+	if (si_mem_available() < nr_pages)
+		return -ENOMEM;
+
 	st = decrease_reservation(nr_pages, GFP_USER);
 	if (st != BP_DONE)
 		return -ENOMEM;
@@ -710,7 +720,7 @@ static int __init balloon_init(void)
 	balloon_stats.schedule_delay = 1;
 	balloon_stats.max_schedule_delay = 32;
 	balloon_stats.retry_count = 1;
-	balloon_stats.max_retry_count = RETRY_UNLIMITED;
+	balloon_stats.max_retry_count = 4;
 
 #ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG
 	set_online_page_callback(&xen_online_page);",linux,6ef36ab967c71690ebe7e5ef997a8be4da3bc844,d39c2e97277229970fe2ae56dcbf67a535e14873,1,"static void balloon_process(struct work_struct *work)
{
	enum bp_state state = BP_DONE;
	long credit;


	do {
		mutex_lock(&balloon_mutex);

		credit = current_credit();

		if (credit > 0) {
			if (balloon_is_inflated())
				state = increase_reservation(credit);
			else
 				state = reserve_additional_memory();
 		}
 
//flaw_line_below:
		if (credit < 0)
//flaw_line_below:
			state = decrease_reservation(-credit, GFP_BALLOON);
//fix_flaw_line_below:
//		if (credit < 0) {
//fix_flaw_line_below:
//			long n_pages;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//			n_pages = min(-credit, si_mem_available());
//fix_flaw_line_below:
//			state = decrease_reservation(n_pages, GFP_BALLOON);
//fix_flaw_line_below:
//			if (state == BP_DONE && n_pages != -credit &&
//fix_flaw_line_below:
//			    n_pages < totalreserve_pages)
//fix_flaw_line_below:
//				state = BP_EAGAIN;
//fix_flaw_line_below:
//		}
 
 		state = update_schedule(state);
 
		mutex_unlock(&balloon_mutex);

		cond_resched();

	} while (credit && state == BP_DONE);

	/* Schedule more work if there is some still to be done. */
	if (state == BP_EAGAIN)
		schedule_delayed_work(&balloon_worker, balloon_stats.schedule_delay * HZ);
}
"
5085,182821,,Remote,Not required,Partial,CVE-2019-12973,https://www.cvedetails.com/cve/CVE-2019-12973/,CWE-400,Medium,,,,2019-06-26,4.3,"In OpenJPEG 2.3.1, there is excessive iteration in the opj_t1_encode_cblks function of openjp2/t1.c. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted bmp file. This issue is similar to CVE-2018-6616.",2019-09-30,DoS ,10,https://github.com/uclouvain/openjpeg/commit/8ee335227bbcaf1614124046aa25e53d67b11ec3,8ee335227bbcaf1614124046aa25e53d67b11ec3,"convertbmp: detect invalid file dimensions early

width/length dimensions read from bmp headers are not necessarily
valid. For instance they may have been maliciously set to very large
values with the intention to cause DoS (large memory allocation, stack
overflow). In these cases we want to detect the invalid size as early
as possible.

This commit introduces a counter which verifies that the number of
written bytes corresponds to the advertized width/length.

Fixes #1059 (CVE-2018-6616).",2,src/bin/jp2/convertbmp.c,"{""sha"": ""0af52f816ba50ddb3e1e7ff9929b90f8a199643d"", ""filename"": ""src/bin/jp2/convertbmp.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 2, ""changes"": 12, ""blob_url"": ""https://github.com/uclouvain/openjpeg/blob/8ee335227bbcaf1614124046aa25e53d67b11ec3/src/bin/jp2/convertbmp.c"", ""raw_url"": ""https://github.com/uclouvain/openjpeg/raw/8ee335227bbcaf1614124046aa25e53d67b11ec3/src/bin/jp2/convertbmp.c"", ""contents_url"": ""https://api.github.com/repos/uclouvain/openjpeg/contents/src/bin/jp2/convertbmp.c?ref=8ee335227bbcaf1614124046aa25e53d67b11ec3"", ""patch"": ""@@ -534,14 +534,14 @@ static OPJ_BOOL bmp_read_raw_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride,\n static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,\n                                    OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n {\n-    OPJ_UINT32 x, y;\n+    OPJ_UINT32 x, y, written;\n     OPJ_UINT8 *pix;\n     const OPJ_UINT8 *beyond;\n \n     beyond = pData + stride * height;\n     pix = pData;\n \n-    x = y = 0U;\n+    x = y = written = 0U;\n     while (y < height) {\n         int c = getc(IN);\n         if (c == EOF) {\n@@ -561,6 +561,7 @@ static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,\n             for (j = 0; (j < c) && (x < width) &&\n                     ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                 *pix = c1;\n+                written++;\n             }\n         } else {\n             c = getc(IN);\n@@ -598,6 +599,7 @@ static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,\n                     }\n                     c1 = (OPJ_UINT8)c1_int;\n                     *pix = c1;\n+                    written++;\n                 }\n                 if ((OPJ_UINT32)c & 1U) { /* skip padding byte */\n                     c = getc(IN);\n@@ -608,6 +610,12 @@ static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,\n             }\n         }\n     }/* while() */\n+\n+    if (written != width * height) {\n+        fprintf(stderr, \""warning, image's actual size does not match advertized one\\n\"");\n+        return OPJ_FALSE;\n+    }\n+\n     return OPJ_TRUE;\n }\n ""}"," static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,
                                    OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)
 {
    OPJ_UINT32 x, y, written;
     OPJ_UINT8 *pix;
     const OPJ_UINT8 *beyond;
 
     beyond = pData + stride * height;
     pix = pData;
 
    x = y = written = 0U;
     while (y < height) {
         int c = getc(IN);
         if (c == EOF) {
            return OPJ_FALSE;
        }

        if (c) {
            int j, c1_int;
            OPJ_UINT8 c1;

            c1_int = getc(IN);
            if (c1_int == EOF) {
                return OPJ_FALSE;
            }
            c1 = (OPJ_UINT8)c1_int;

             for (j = 0; (j < c) && (x < width) &&
                     ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {
                 *pix = c1;
                written++;
             }
         } else {
             c = getc(IN);
            if (c == EOF) {
                return OPJ_FALSE;
            }

            if (c == 0x00) { /* EOL */
                x = 0;
                ++y;
                pix = pData + y * stride + x;
            } else if (c == 0x01) { /* EOP */
                break;
            } else if (c == 0x02) { /* MOVE by dxdy */
                c = getc(IN);
                if (c == EOF) {
                    return OPJ_FALSE;
                }
                x += (OPJ_UINT32)c;
                c = getc(IN);
                if (c == EOF) {
                    return OPJ_FALSE;
                }
                y += (OPJ_UINT32)c;
                pix = pData + y * stride + x;
            } else { /* 03 .. 255 */
                int j;
                for (j = 0; (j < c) && (x < width) &&
                        ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {
                    int c1_int;
                    OPJ_UINT8 c1;
                    c1_int = getc(IN);
                    if (c1_int == EOF) {
                        return OPJ_FALSE;
                     }
                     c1 = (OPJ_UINT8)c1_int;
                     *pix = c1;
                    written++;
                 }
                 if ((OPJ_UINT32)c & 1U) { /* skip padding byte */
                     c = getc(IN);
                    if (c == EOF) {
                        return OPJ_FALSE;
                    }
                }
             }
         }
     }/* while() */

    if (written != width * height) {
        fprintf(stderr, ""warning, image's actual size does not match advertized one\n"");
        return OPJ_FALSE;
    }

     return OPJ_TRUE;
 }
"," static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,
                                    OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)
 {
    OPJ_UINT32 x, y;
     OPJ_UINT8 *pix;
     const OPJ_UINT8 *beyond;
 
     beyond = pData + stride * height;
     pix = pData;
 
    x = y = 0U;
     while (y < height) {
         int c = getc(IN);
         if (c == EOF) {
            return OPJ_FALSE;
        }

        if (c) {
            int j, c1_int;
            OPJ_UINT8 c1;

            c1_int = getc(IN);
            if (c1_int == EOF) {
                return OPJ_FALSE;
            }
            c1 = (OPJ_UINT8)c1_int;

             for (j = 0; (j < c) && (x < width) &&
                     ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {
                 *pix = c1;
             }
         } else {
             c = getc(IN);
            if (c == EOF) {
                return OPJ_FALSE;
            }

            if (c == 0x00) { /* EOL */
                x = 0;
                ++y;
                pix = pData + y * stride + x;
            } else if (c == 0x01) { /* EOP */
                break;
            } else if (c == 0x02) { /* MOVE by dxdy */
                c = getc(IN);
                if (c == EOF) {
                    return OPJ_FALSE;
                }
                x += (OPJ_UINT32)c;
                c = getc(IN);
                if (c == EOF) {
                    return OPJ_FALSE;
                }
                y += (OPJ_UINT32)c;
                pix = pData + y * stride + x;
            } else { /* 03 .. 255 */
                int j;
                for (j = 0; (j < c) && (x < width) &&
                        ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {
                    int c1_int;
                    OPJ_UINT8 c1;
                    c1_int = getc(IN);
                    if (c1_int == EOF) {
                        return OPJ_FALSE;
                     }
                     c1 = (OPJ_UINT8)c1_int;
                     *pix = c1;
                 }
                 if ((OPJ_UINT32)c & 1U) { /* skip padding byte */
                     c = getc(IN);
                    if (c == EOF) {
                        return OPJ_FALSE;
                    }
                }
             }
         }
     }/* while() */
     return OPJ_TRUE;
 }
",C,"    OPJ_UINT32 x, y, written;
    x = y = written = 0U;
                written++;
                    written++;

    if (written != width * height) {
        fprintf(stderr, ""warning, image's actual size does not match advertized one\n"");
        return OPJ_FALSE;
    }

","    OPJ_UINT32 x, y;
    x = y = 0U;
",,"@@ -534,14 +534,14 @@ static OPJ_BOOL bmp_read_raw_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride,
 static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,
                                    OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)
 {
-    OPJ_UINT32 x, y;
+    OPJ_UINT32 x, y, written;
     OPJ_UINT8 *pix;
     const OPJ_UINT8 *beyond;
 
     beyond = pData + stride * height;
     pix = pData;
 
-    x = y = 0U;
+    x = y = written = 0U;
     while (y < height) {
         int c = getc(IN);
         if (c == EOF) {
@@ -561,6 +561,7 @@ static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,
             for (j = 0; (j < c) && (x < width) &&
                     ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {
                 *pix = c1;
+                written++;
             }
         } else {
             c = getc(IN);
@@ -598,6 +599,7 @@ static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,
                     }
                     c1 = (OPJ_UINT8)c1_int;
                     *pix = c1;
+                    written++;
                 }
                 if ((OPJ_UINT32)c & 1U) { /* skip padding byte */
                     c = getc(IN);
@@ -608,6 +610,12 @@ static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,
             }
         }
     }/* while() */
+
+    if (written != width * height) {
+        fprintf(stderr, ""warning, image's actual size does not match advertized one\n"");
+        return OPJ_FALSE;
+    }
+
     return OPJ_TRUE;
 }
 ",openjpeg,8ee335227bbcaf1614124046aa25e53d67b11ec3,e7640f58f122d1228f3d750864543ad4703e18fc,1," static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,
                                    OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)
 {
//flaw_line_below:
    OPJ_UINT32 x, y;
//fix_flaw_line_below:
//    OPJ_UINT32 x, y, written;
     OPJ_UINT8 *pix;
     const OPJ_UINT8 *beyond;
 
     beyond = pData + stride * height;
     pix = pData;
 
//flaw_line_below:
    x = y = 0U;
//fix_flaw_line_below:
//    x = y = written = 0U;
     while (y < height) {
         int c = getc(IN);
         if (c == EOF) {
            return OPJ_FALSE;
        }

        if (c) {
            int j, c1_int;
            OPJ_UINT8 c1;

            c1_int = getc(IN);
            if (c1_int == EOF) {
                return OPJ_FALSE;
            }
            c1 = (OPJ_UINT8)c1_int;

             for (j = 0; (j < c) && (x < width) &&
                     ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {
                 *pix = c1;
//fix_flaw_line_below:
//                written++;
             }
         } else {
             c = getc(IN);
            if (c == EOF) {
                return OPJ_FALSE;
            }

            if (c == 0x00) { /* EOL */
                x = 0;
                ++y;
                pix = pData + y * stride + x;
            } else if (c == 0x01) { /* EOP */
                break;
            } else if (c == 0x02) { /* MOVE by dxdy */
                c = getc(IN);
                if (c == EOF) {
                    return OPJ_FALSE;
                }
                x += (OPJ_UINT32)c;
                c = getc(IN);
                if (c == EOF) {
                    return OPJ_FALSE;
                }
                y += (OPJ_UINT32)c;
                pix = pData + y * stride + x;
            } else { /* 03 .. 255 */
                int j;
                for (j = 0; (j < c) && (x < width) &&
                        ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {
                    int c1_int;
                    OPJ_UINT8 c1;
                    c1_int = getc(IN);
                    if (c1_int == EOF) {
                        return OPJ_FALSE;
                     }
                     c1 = (OPJ_UINT8)c1_int;
                     *pix = c1;
//fix_flaw_line_below:
//                    written++;
                 }
                 if ((OPJ_UINT32)c & 1U) { /* skip padding byte */
                     c = getc(IN);
                    if (c == EOF) {
                        return OPJ_FALSE;
                    }
                }
             }
         }
     }/* while() */
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (written != width * height) {
//fix_flaw_line_below:
//        fprintf(stderr, ""warning, image's actual size does not match advertized one\n"");
//fix_flaw_line_below:
//        return OPJ_FALSE;
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     return OPJ_TRUE;
 }
"
5130,182866,,Remote,Not required,Complete,CVE-2019-11470,https://www.cvedetails.com/cve/CVE-2019-11470/,CWE-400,Medium,,,,2019-04-23,7.1,The cineon parsing component in ImageMagick 7.0.8-26 Q16 allows attackers to cause a denial-of-service (uncontrolled resource consumption) by crafting a Cineon image with an incorrect claimed image size. This occurs because ReadCINImage in coders/cin.c lacks a check for insufficient image data in a file.,2019-06-24,,2,https://github.com/ImageMagick/ImageMagick/commit/e3cdce6fe12193f235b8c0ae5efe6880a25eb957,e3cdce6fe12193f235b8c0ae5efe6880a25eb957,https://github.com/ImageMagick/ImageMagick/issues/1472,0,coders/cin.c,"{""sha"": ""72d6138fd9ead14dff09ffbdc954b3b66e4efd26"", ""filename"": ""coders/cin.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/e3cdce6fe12193f235b8c0ae5efe6880a25eb957/coders/cin.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/e3cdce6fe12193f235b8c0ae5efe6880a25eb957/coders/cin.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/cin.c?ref=e3cdce6fe12193f235b8c0ae5efe6880a25eb957"", ""patch"": ""@@ -726,6 +726,8 @@ static Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception)\n       (void) CloseBlob(image);\n       return(image);\n     }\n+  if (((MagickSizeType) image->columns*image->rows) > GetBlobSize(image))\n+    ThrowReaderException(CorruptImageError,\""InsufficientImageDataInFile\"");\n   for ( ; offset < (MagickOffsetType) cin.file.image_offset; offset++)\n   {\n     int""}","static Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define MonoColorType  1
#define RGBColorType  3

  char
    property[MagickPathExtent];

  CINInfo
    cin;

  const unsigned char
    *pixels;

  Image
    *image;

  MagickBooleanType
    status;

  MagickOffsetType
    offset;

  QuantumInfo
    *quantum_info;

  QuantumType
    quantum_type;

  register ssize_t
    i;

  register Quantum
    *q;

  size_t
    length;

  ssize_t
    count,
    y;

  unsigned char
    magick[4];

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    File information.
  */
  offset=0;
  count=ReadBlob(image,4,magick);
  offset+=count;
  if ((count != 4) ||
      ((LocaleNCompare((char *) magick,""\200\052\137\327"",4) != 0)))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  memset(&cin,0,sizeof(cin));
  image->endian=(magick[0] == 0x80) && (magick[1] == 0x2a) &&
    (magick[2] == 0x5f) && (magick[3] == 0xd7) ? MSBEndian : LSBEndian;
  cin.file.image_offset=ReadBlobLong(image);
  offset+=4;
  cin.file.generic_length=ReadBlobLong(image);
  offset+=4;
  cin.file.industry_length=ReadBlobLong(image);
  offset+=4;
  cin.file.user_length=ReadBlobLong(image);
  offset+=4;
  cin.file.file_size=ReadBlobLong(image);
  offset+=4;
  offset+=ReadBlob(image,sizeof(cin.file.version),(unsigned char *)
    cin.file.version);
  (void) CopyMagickString(property,cin.file.version,sizeof(cin.file.version));
  (void) SetImageProperty(image,""dpx:file.version"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.file.filename),(unsigned char *)
    cin.file.filename);
  (void) CopyMagickString(property,cin.file.filename,sizeof(cin.file.filename));
  (void) SetImageProperty(image,""dpx:file.filename"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.file.create_date),(unsigned char *)
    cin.file.create_date);
  (void) CopyMagickString(property,cin.file.create_date,
    sizeof(cin.file.create_date));
  (void) SetImageProperty(image,""dpx:file.create_date"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.file.create_time),(unsigned char *)
    cin.file.create_time);
  (void) CopyMagickString(property,cin.file.create_time,
    sizeof(cin.file.create_time));
  (void) SetImageProperty(image,""dpx:file.create_time"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.file.reserve),(unsigned char *)
    cin.file.reserve);
  /*
    Image information.
  */
  cin.image.orientation=(unsigned char) ReadBlobByte(image);
  offset++;
  if (cin.image.orientation != (unsigned char) (~0))
    (void) FormatImageProperty(image,""dpx:image.orientation"",""%d"",
      cin.image.orientation);
  switch (cin.image.orientation)
  {
    default:
    case 0: image->orientation=TopLeftOrientation; break;
    case 1: image->orientation=TopRightOrientation; break;
    case 2: image->orientation=BottomLeftOrientation; break;
    case 3: image->orientation=BottomRightOrientation; break;
    case 4: image->orientation=LeftTopOrientation; break;
    case 5: image->orientation=RightTopOrientation; break;
    case 6: image->orientation=LeftBottomOrientation; break;
    case 7: image->orientation=RightBottomOrientation; break;
  }
  cin.image.number_channels=(unsigned char) ReadBlobByte(image);
  offset++;
  offset+=ReadBlob(image,sizeof(cin.image.reserve1),(unsigned char *)
    cin.image.reserve1);
  for (i=0; i < 8; i++)
  {
    cin.image.channel[i].designator[0]=(unsigned char) ReadBlobByte(image);
    offset++;
    cin.image.channel[i].designator[1]=(unsigned char) ReadBlobByte(image);
    offset++;
    cin.image.channel[i].bits_per_pixel=(unsigned char) ReadBlobByte(image);
    offset++;
    cin.image.channel[i].reserve=(unsigned char) ReadBlobByte(image);
    offset++;
    cin.image.channel[i].pixels_per_line=ReadBlobLong(image);
    offset+=4;
    cin.image.channel[i].lines_per_image=ReadBlobLong(image);
    offset+=4;
    cin.image.channel[i].min_data=ReadBlobFloat(image);
    offset+=4;
    cin.image.channel[i].min_quantity=ReadBlobFloat(image);
    offset+=4;
    cin.image.channel[i].max_data=ReadBlobFloat(image);
    offset+=4;
    cin.image.channel[i].max_quantity=ReadBlobFloat(image);
    offset+=4;
  }
  cin.image.white_point[0]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.white_point[0]) != MagickFalse)
    image->chromaticity.white_point.x=cin.image.white_point[0];
  cin.image.white_point[1]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.white_point[1]) != MagickFalse)
    image->chromaticity.white_point.y=cin.image.white_point[1];
  cin.image.red_primary_chromaticity[0]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.red_primary_chromaticity[0]) != MagickFalse)
    image->chromaticity.red_primary.x=cin.image.red_primary_chromaticity[0];
  cin.image.red_primary_chromaticity[1]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.red_primary_chromaticity[1]) != MagickFalse)
    image->chromaticity.red_primary.y=cin.image.red_primary_chromaticity[1];
  cin.image.green_primary_chromaticity[0]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.green_primary_chromaticity[0]) != MagickFalse)
    image->chromaticity.red_primary.x=cin.image.green_primary_chromaticity[0];
  cin.image.green_primary_chromaticity[1]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.green_primary_chromaticity[1]) != MagickFalse)
    image->chromaticity.green_primary.y=cin.image.green_primary_chromaticity[1];
  cin.image.blue_primary_chromaticity[0]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.blue_primary_chromaticity[0]) != MagickFalse)
    image->chromaticity.blue_primary.x=cin.image.blue_primary_chromaticity[0];
  cin.image.blue_primary_chromaticity[1]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.blue_primary_chromaticity[1]) != MagickFalse)
    image->chromaticity.blue_primary.y=cin.image.blue_primary_chromaticity[1];
  offset+=ReadBlob(image,sizeof(cin.image.label),(unsigned char *)
    cin.image.label);
  (void) CopyMagickString(property,cin.image.label,sizeof(cin.image.label));
  (void) SetImageProperty(image,""dpx:image.label"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.image.reserve),(unsigned char *)
    cin.image.reserve);
  /*
    Image data format information.
  */
  cin.data_format.interleave=(unsigned char) ReadBlobByte(image);
  offset++;
  cin.data_format.packing=(unsigned char) ReadBlobByte(image);
  offset++;
  cin.data_format.sign=(unsigned char) ReadBlobByte(image);
  offset++;
  cin.data_format.sense=(unsigned char) ReadBlobByte(image);
  offset++;
  cin.data_format.line_pad=ReadBlobLong(image);
  offset+=4;
  cin.data_format.channel_pad=ReadBlobLong(image);
  offset+=4;
  offset+=ReadBlob(image,sizeof(cin.data_format.reserve),(unsigned char *)
    cin.data_format.reserve);
  /*
    Image origination information.
  */
  cin.origination.x_offset=ReadBlobSignedLong(image);
  offset+=4;
  if ((size_t) cin.origination.x_offset != ~0UL)
    (void) FormatImageProperty(image,""dpx:origination.x_offset"",""%.20g"",
      (double) cin.origination.x_offset);
  cin.origination.y_offset=(ssize_t) ReadBlobLong(image);
  offset+=4;
  if ((size_t) cin.origination.y_offset != ~0UL)
    (void) FormatImageProperty(image,""dpx:origination.y_offset"",""%.20g"",
      (double) cin.origination.y_offset);
  offset+=ReadBlob(image,sizeof(cin.origination.filename),(unsigned char *)
    cin.origination.filename);
  (void) CopyMagickString(property,cin.origination.filename,
    sizeof(cin.origination.filename));
  (void) SetImageProperty(image,""dpx:origination.filename"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.origination.create_date),(unsigned char *)
    cin.origination.create_date);
  (void) CopyMagickString(property,cin.origination.create_date,
    sizeof(cin.origination.create_date));
  (void) SetImageProperty(image,""dpx:origination.create_date"",property,
    exception);
  offset+=ReadBlob(image,sizeof(cin.origination.create_time),(unsigned char *)
    cin.origination.create_time);
  (void) CopyMagickString(property,cin.origination.create_time,
    sizeof(cin.origination.create_time));
  (void) SetImageProperty(image,""dpx:origination.create_time"",property,
    exception);
  offset+=ReadBlob(image,sizeof(cin.origination.device),(unsigned char *)
    cin.origination.device);
  (void) CopyMagickString(property,cin.origination.device,
    sizeof(cin.origination.device));
  (void) SetImageProperty(image,""dpx:origination.device"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.origination.model),(unsigned char *)
    cin.origination.model);
  (void) CopyMagickString(property,cin.origination.model,
    sizeof(cin.origination.model));
  (void) SetImageProperty(image,""dpx:origination.model"",property,exception);
  (void) memset(cin.origination.serial,0, 
    sizeof(cin.origination.serial));
  offset+=ReadBlob(image,sizeof(cin.origination.serial),(unsigned char *)
    cin.origination.serial);
  (void) CopyMagickString(property,cin.origination.serial,
    sizeof(cin.origination.serial));
  (void) SetImageProperty(image,""dpx:origination.serial"",property,exception);
  cin.origination.x_pitch=ReadBlobFloat(image);
  offset+=4;
  cin.origination.y_pitch=ReadBlobFloat(image);
  offset+=4;
  cin.origination.gamma=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.origination.gamma) != MagickFalse)
    image->gamma=cin.origination.gamma;
  offset+=ReadBlob(image,sizeof(cin.origination.reserve),(unsigned char *)
    cin.origination.reserve);
  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))
    {
      int
        c;

      /*
        Image film information.
      */
      cin.film.id=ReadBlobByte(image);
      offset++;
      c=cin.film.id;
      if (c != ~0)
        (void) FormatImageProperty(image,""dpx:film.id"",""%d"",cin.film.id);
      cin.film.type=ReadBlobByte(image);
      offset++;
      c=cin.film.type;
      if (c != ~0)
        (void) FormatImageProperty(image,""dpx:film.type"",""%d"",cin.film.type);
      cin.film.offset=ReadBlobByte(image);
      offset++;
      c=cin.film.offset;
      if (c != ~0)
        (void) FormatImageProperty(image,""dpx:film.offset"",""%d"",
          cin.film.offset);
      cin.film.reserve1=ReadBlobByte(image);
      offset++;
      cin.film.prefix=ReadBlobLong(image);
      offset+=4;
      if (cin.film.prefix != ~0UL)
        (void) FormatImageProperty(image,""dpx:film.prefix"",""%.20g"",(double)
          cin.film.prefix);
      cin.film.count=ReadBlobLong(image);
      offset+=4;
      offset+=ReadBlob(image,sizeof(cin.film.format),(unsigned char *)
        cin.film.format);
      (void) CopyMagickString(property,cin.film.format,sizeof(cin.film.format));
      (void) SetImageProperty(image,""dpx:film.format"",property,exception);
      cin.film.frame_position=ReadBlobLong(image);
      offset+=4;
      if (cin.film.frame_position != ~0UL)
        (void) FormatImageProperty(image,""dpx:film.frame_position"",""%.20g"",
          (double) cin.film.frame_position);
      cin.film.frame_rate=ReadBlobFloat(image);
      offset+=4;
      if (IsFloatDefined(cin.film.frame_rate) != MagickFalse)
        (void) FormatImageProperty(image,""dpx:film.frame_rate"",""%g"",
          cin.film.frame_rate);
      offset+=ReadBlob(image,sizeof(cin.film.frame_id),(unsigned char *)
        cin.film.frame_id);
      (void) CopyMagickString(property,cin.film.frame_id,
        sizeof(cin.film.frame_id));
      (void) SetImageProperty(image,""dpx:film.frame_id"",property,exception);
      offset+=ReadBlob(image,sizeof(cin.film.slate_info),(unsigned char *)
        cin.film.slate_info);
      (void) CopyMagickString(property,cin.film.slate_info,
        sizeof(cin.film.slate_info));
      (void) SetImageProperty(image,""dpx:film.slate_info"",property,exception);
      offset+=ReadBlob(image,sizeof(cin.film.reserve),(unsigned char *)
        cin.film.reserve);
    }
  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))
    {
      StringInfo
        *profile;

      /*
        User defined data.
      */
      if (cin.file.user_length > GetBlobSize(image))
        ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
      profile=BlobToStringInfo((const unsigned char *) NULL,
        cin.file.user_length);
      if (profile == (StringInfo *) NULL)
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      offset+=ReadBlob(image,GetStringInfoLength(profile),
        GetStringInfoDatum(profile));
      (void) SetImageProfile(image,""dpx:user.data"",profile,exception);
      profile=DestroyStringInfo(profile);
    }
  image->depth=cin.image.channel[0].bits_per_pixel;
  image->columns=cin.image.channel[0].pixels_per_line;
  image->rows=cin.image.channel[0].lines_per_image;
  if (image_info->ping != MagickFalse)
    {
       (void) CloseBlob(image);
       return(image);
     }
  if (((MagickSizeType) image->columns*image->rows) > GetBlobSize(image))
    ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
   for ( ; offset < (MagickOffsetType) cin.file.image_offset; offset++)
   {
     int
      c;

    c=ReadBlobByte(image);
    if (c == EOF)
      break;
  }
  if (offset < (MagickOffsetType) cin.file.image_offset)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  status=SetImageExtent(image,image->columns,image->rows,exception);
  if (status == MagickFalse)
    return(DestroyImageList(image));
  (void) SetImageBackgroundColor(image,exception);
  /*
    Convert CIN raster image to pixel packets.
  */
  quantum_info=AcquireQuantumInfo(image_info,image);
  if (quantum_info == (QuantumInfo *) NULL)
    ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
  quantum_info->quantum=32;
  quantum_info->pack=MagickFalse;
  quantum_type=RGBQuantum;
  length=GetQuantumExtent(image,quantum_info,quantum_type);
  length=GetBytesPerRow(image->columns,3,image->depth,MagickTrue);
  if (cin.image.number_channels == 1)
    {
      quantum_type=GrayQuantum;
      length=GetBytesPerRow(image->columns,1,image->depth,MagickTrue);
    }
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    pixels=(const unsigned char *) ReadBlobStream(image,length,
      GetQuantumPixels(quantum_info),&count);
    if ((size_t) count != length)
      break;
    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
      quantum_type,pixels,exception);
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  SetQuantumImageType(image,quantum_type);
  quantum_info=DestroyQuantumInfo(quantum_info);
  if (EOFBlob(image) != MagickFalse)
    ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
      image->filename);
  SetImageColorspace(image,LogColorspace,exception);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
","static Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define MonoColorType  1
#define RGBColorType  3

  char
    property[MagickPathExtent];

  CINInfo
    cin;

  const unsigned char
    *pixels;

  Image
    *image;

  MagickBooleanType
    status;

  MagickOffsetType
    offset;

  QuantumInfo
    *quantum_info;

  QuantumType
    quantum_type;

  register ssize_t
    i;

  register Quantum
    *q;

  size_t
    length;

  ssize_t
    count,
    y;

  unsigned char
    magick[4];

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    File information.
  */
  offset=0;
  count=ReadBlob(image,4,magick);
  offset+=count;
  if ((count != 4) ||
      ((LocaleNCompare((char *) magick,""\200\052\137\327"",4) != 0)))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  memset(&cin,0,sizeof(cin));
  image->endian=(magick[0] == 0x80) && (magick[1] == 0x2a) &&
    (magick[2] == 0x5f) && (magick[3] == 0xd7) ? MSBEndian : LSBEndian;
  cin.file.image_offset=ReadBlobLong(image);
  offset+=4;
  cin.file.generic_length=ReadBlobLong(image);
  offset+=4;
  cin.file.industry_length=ReadBlobLong(image);
  offset+=4;
  cin.file.user_length=ReadBlobLong(image);
  offset+=4;
  cin.file.file_size=ReadBlobLong(image);
  offset+=4;
  offset+=ReadBlob(image,sizeof(cin.file.version),(unsigned char *)
    cin.file.version);
  (void) CopyMagickString(property,cin.file.version,sizeof(cin.file.version));
  (void) SetImageProperty(image,""dpx:file.version"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.file.filename),(unsigned char *)
    cin.file.filename);
  (void) CopyMagickString(property,cin.file.filename,sizeof(cin.file.filename));
  (void) SetImageProperty(image,""dpx:file.filename"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.file.create_date),(unsigned char *)
    cin.file.create_date);
  (void) CopyMagickString(property,cin.file.create_date,
    sizeof(cin.file.create_date));
  (void) SetImageProperty(image,""dpx:file.create_date"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.file.create_time),(unsigned char *)
    cin.file.create_time);
  (void) CopyMagickString(property,cin.file.create_time,
    sizeof(cin.file.create_time));
  (void) SetImageProperty(image,""dpx:file.create_time"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.file.reserve),(unsigned char *)
    cin.file.reserve);
  /*
    Image information.
  */
  cin.image.orientation=(unsigned char) ReadBlobByte(image);
  offset++;
  if (cin.image.orientation != (unsigned char) (~0))
    (void) FormatImageProperty(image,""dpx:image.orientation"",""%d"",
      cin.image.orientation);
  switch (cin.image.orientation)
  {
    default:
    case 0: image->orientation=TopLeftOrientation; break;
    case 1: image->orientation=TopRightOrientation; break;
    case 2: image->orientation=BottomLeftOrientation; break;
    case 3: image->orientation=BottomRightOrientation; break;
    case 4: image->orientation=LeftTopOrientation; break;
    case 5: image->orientation=RightTopOrientation; break;
    case 6: image->orientation=LeftBottomOrientation; break;
    case 7: image->orientation=RightBottomOrientation; break;
  }
  cin.image.number_channels=(unsigned char) ReadBlobByte(image);
  offset++;
  offset+=ReadBlob(image,sizeof(cin.image.reserve1),(unsigned char *)
    cin.image.reserve1);
  for (i=0; i < 8; i++)
  {
    cin.image.channel[i].designator[0]=(unsigned char) ReadBlobByte(image);
    offset++;
    cin.image.channel[i].designator[1]=(unsigned char) ReadBlobByte(image);
    offset++;
    cin.image.channel[i].bits_per_pixel=(unsigned char) ReadBlobByte(image);
    offset++;
    cin.image.channel[i].reserve=(unsigned char) ReadBlobByte(image);
    offset++;
    cin.image.channel[i].pixels_per_line=ReadBlobLong(image);
    offset+=4;
    cin.image.channel[i].lines_per_image=ReadBlobLong(image);
    offset+=4;
    cin.image.channel[i].min_data=ReadBlobFloat(image);
    offset+=4;
    cin.image.channel[i].min_quantity=ReadBlobFloat(image);
    offset+=4;
    cin.image.channel[i].max_data=ReadBlobFloat(image);
    offset+=4;
    cin.image.channel[i].max_quantity=ReadBlobFloat(image);
    offset+=4;
  }
  cin.image.white_point[0]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.white_point[0]) != MagickFalse)
    image->chromaticity.white_point.x=cin.image.white_point[0];
  cin.image.white_point[1]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.white_point[1]) != MagickFalse)
    image->chromaticity.white_point.y=cin.image.white_point[1];
  cin.image.red_primary_chromaticity[0]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.red_primary_chromaticity[0]) != MagickFalse)
    image->chromaticity.red_primary.x=cin.image.red_primary_chromaticity[0];
  cin.image.red_primary_chromaticity[1]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.red_primary_chromaticity[1]) != MagickFalse)
    image->chromaticity.red_primary.y=cin.image.red_primary_chromaticity[1];
  cin.image.green_primary_chromaticity[0]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.green_primary_chromaticity[0]) != MagickFalse)
    image->chromaticity.red_primary.x=cin.image.green_primary_chromaticity[0];
  cin.image.green_primary_chromaticity[1]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.green_primary_chromaticity[1]) != MagickFalse)
    image->chromaticity.green_primary.y=cin.image.green_primary_chromaticity[1];
  cin.image.blue_primary_chromaticity[0]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.blue_primary_chromaticity[0]) != MagickFalse)
    image->chromaticity.blue_primary.x=cin.image.blue_primary_chromaticity[0];
  cin.image.blue_primary_chromaticity[1]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.blue_primary_chromaticity[1]) != MagickFalse)
    image->chromaticity.blue_primary.y=cin.image.blue_primary_chromaticity[1];
  offset+=ReadBlob(image,sizeof(cin.image.label),(unsigned char *)
    cin.image.label);
  (void) CopyMagickString(property,cin.image.label,sizeof(cin.image.label));
  (void) SetImageProperty(image,""dpx:image.label"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.image.reserve),(unsigned char *)
    cin.image.reserve);
  /*
    Image data format information.
  */
  cin.data_format.interleave=(unsigned char) ReadBlobByte(image);
  offset++;
  cin.data_format.packing=(unsigned char) ReadBlobByte(image);
  offset++;
  cin.data_format.sign=(unsigned char) ReadBlobByte(image);
  offset++;
  cin.data_format.sense=(unsigned char) ReadBlobByte(image);
  offset++;
  cin.data_format.line_pad=ReadBlobLong(image);
  offset+=4;
  cin.data_format.channel_pad=ReadBlobLong(image);
  offset+=4;
  offset+=ReadBlob(image,sizeof(cin.data_format.reserve),(unsigned char *)
    cin.data_format.reserve);
  /*
    Image origination information.
  */
  cin.origination.x_offset=ReadBlobSignedLong(image);
  offset+=4;
  if ((size_t) cin.origination.x_offset != ~0UL)
    (void) FormatImageProperty(image,""dpx:origination.x_offset"",""%.20g"",
      (double) cin.origination.x_offset);
  cin.origination.y_offset=(ssize_t) ReadBlobLong(image);
  offset+=4;
  if ((size_t) cin.origination.y_offset != ~0UL)
    (void) FormatImageProperty(image,""dpx:origination.y_offset"",""%.20g"",
      (double) cin.origination.y_offset);
  offset+=ReadBlob(image,sizeof(cin.origination.filename),(unsigned char *)
    cin.origination.filename);
  (void) CopyMagickString(property,cin.origination.filename,
    sizeof(cin.origination.filename));
  (void) SetImageProperty(image,""dpx:origination.filename"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.origination.create_date),(unsigned char *)
    cin.origination.create_date);
  (void) CopyMagickString(property,cin.origination.create_date,
    sizeof(cin.origination.create_date));
  (void) SetImageProperty(image,""dpx:origination.create_date"",property,
    exception);
  offset+=ReadBlob(image,sizeof(cin.origination.create_time),(unsigned char *)
    cin.origination.create_time);
  (void) CopyMagickString(property,cin.origination.create_time,
    sizeof(cin.origination.create_time));
  (void) SetImageProperty(image,""dpx:origination.create_time"",property,
    exception);
  offset+=ReadBlob(image,sizeof(cin.origination.device),(unsigned char *)
    cin.origination.device);
  (void) CopyMagickString(property,cin.origination.device,
    sizeof(cin.origination.device));
  (void) SetImageProperty(image,""dpx:origination.device"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.origination.model),(unsigned char *)
    cin.origination.model);
  (void) CopyMagickString(property,cin.origination.model,
    sizeof(cin.origination.model));
  (void) SetImageProperty(image,""dpx:origination.model"",property,exception);
  (void) memset(cin.origination.serial,0, 
    sizeof(cin.origination.serial));
  offset+=ReadBlob(image,sizeof(cin.origination.serial),(unsigned char *)
    cin.origination.serial);
  (void) CopyMagickString(property,cin.origination.serial,
    sizeof(cin.origination.serial));
  (void) SetImageProperty(image,""dpx:origination.serial"",property,exception);
  cin.origination.x_pitch=ReadBlobFloat(image);
  offset+=4;
  cin.origination.y_pitch=ReadBlobFloat(image);
  offset+=4;
  cin.origination.gamma=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.origination.gamma) != MagickFalse)
    image->gamma=cin.origination.gamma;
  offset+=ReadBlob(image,sizeof(cin.origination.reserve),(unsigned char *)
    cin.origination.reserve);
  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))
    {
      int
        c;

      /*
        Image film information.
      */
      cin.film.id=ReadBlobByte(image);
      offset++;
      c=cin.film.id;
      if (c != ~0)
        (void) FormatImageProperty(image,""dpx:film.id"",""%d"",cin.film.id);
      cin.film.type=ReadBlobByte(image);
      offset++;
      c=cin.film.type;
      if (c != ~0)
        (void) FormatImageProperty(image,""dpx:film.type"",""%d"",cin.film.type);
      cin.film.offset=ReadBlobByte(image);
      offset++;
      c=cin.film.offset;
      if (c != ~0)
        (void) FormatImageProperty(image,""dpx:film.offset"",""%d"",
          cin.film.offset);
      cin.film.reserve1=ReadBlobByte(image);
      offset++;
      cin.film.prefix=ReadBlobLong(image);
      offset+=4;
      if (cin.film.prefix != ~0UL)
        (void) FormatImageProperty(image,""dpx:film.prefix"",""%.20g"",(double)
          cin.film.prefix);
      cin.film.count=ReadBlobLong(image);
      offset+=4;
      offset+=ReadBlob(image,sizeof(cin.film.format),(unsigned char *)
        cin.film.format);
      (void) CopyMagickString(property,cin.film.format,sizeof(cin.film.format));
      (void) SetImageProperty(image,""dpx:film.format"",property,exception);
      cin.film.frame_position=ReadBlobLong(image);
      offset+=4;
      if (cin.film.frame_position != ~0UL)
        (void) FormatImageProperty(image,""dpx:film.frame_position"",""%.20g"",
          (double) cin.film.frame_position);
      cin.film.frame_rate=ReadBlobFloat(image);
      offset+=4;
      if (IsFloatDefined(cin.film.frame_rate) != MagickFalse)
        (void) FormatImageProperty(image,""dpx:film.frame_rate"",""%g"",
          cin.film.frame_rate);
      offset+=ReadBlob(image,sizeof(cin.film.frame_id),(unsigned char *)
        cin.film.frame_id);
      (void) CopyMagickString(property,cin.film.frame_id,
        sizeof(cin.film.frame_id));
      (void) SetImageProperty(image,""dpx:film.frame_id"",property,exception);
      offset+=ReadBlob(image,sizeof(cin.film.slate_info),(unsigned char *)
        cin.film.slate_info);
      (void) CopyMagickString(property,cin.film.slate_info,
        sizeof(cin.film.slate_info));
      (void) SetImageProperty(image,""dpx:film.slate_info"",property,exception);
      offset+=ReadBlob(image,sizeof(cin.film.reserve),(unsigned char *)
        cin.film.reserve);
    }
  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))
    {
      StringInfo
        *profile;

      /*
        User defined data.
      */
      if (cin.file.user_length > GetBlobSize(image))
        ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
      profile=BlobToStringInfo((const unsigned char *) NULL,
        cin.file.user_length);
      if (profile == (StringInfo *) NULL)
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      offset+=ReadBlob(image,GetStringInfoLength(profile),
        GetStringInfoDatum(profile));
      (void) SetImageProfile(image,""dpx:user.data"",profile,exception);
      profile=DestroyStringInfo(profile);
    }
  image->depth=cin.image.channel[0].bits_per_pixel;
  image->columns=cin.image.channel[0].pixels_per_line;
  image->rows=cin.image.channel[0].lines_per_image;
  if (image_info->ping != MagickFalse)
    {
       (void) CloseBlob(image);
       return(image);
     }
   for ( ; offset < (MagickOffsetType) cin.file.image_offset; offset++)
   {
     int
      c;

    c=ReadBlobByte(image);
    if (c == EOF)
      break;
  }
  if (offset < (MagickOffsetType) cin.file.image_offset)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  status=SetImageExtent(image,image->columns,image->rows,exception);
  if (status == MagickFalse)
    return(DestroyImageList(image));
  (void) SetImageBackgroundColor(image,exception);
  /*
    Convert CIN raster image to pixel packets.
  */
  quantum_info=AcquireQuantumInfo(image_info,image);
  if (quantum_info == (QuantumInfo *) NULL)
    ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
  quantum_info->quantum=32;
  quantum_info->pack=MagickFalse;
  quantum_type=RGBQuantum;
  length=GetQuantumExtent(image,quantum_info,quantum_type);
  length=GetBytesPerRow(image->columns,3,image->depth,MagickTrue);
  if (cin.image.number_channels == 1)
    {
      quantum_type=GrayQuantum;
      length=GetBytesPerRow(image->columns,1,image->depth,MagickTrue);
    }
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    pixels=(const unsigned char *) ReadBlobStream(image,length,
      GetQuantumPixels(quantum_info),&count);
    if ((size_t) count != length)
      break;
    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
      quantum_type,pixels,exception);
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  SetQuantumImageType(image,quantum_type);
  quantum_info=DestroyQuantumInfo(quantum_info);
  if (EOFBlob(image) != MagickFalse)
    ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
      image->filename);
  SetImageColorspace(image,LogColorspace,exception);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
",C,"  if (((MagickSizeType) image->columns*image->rows) > GetBlobSize(image))
    ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
",,,"@@ -726,6 +726,8 @@ static Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception)
       (void) CloseBlob(image);
       return(image);
     }
+  if (((MagickSizeType) image->columns*image->rows) > GetBlobSize(image))
+    ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
   for ( ; offset < (MagickOffsetType) cin.file.image_offset; offset++)
   {
     int",ImageMagick,e3cdce6fe12193f235b8c0ae5efe6880a25eb957,2b4fee3b265bd8333bea89a495e37a18a445da86,1,"static Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define MonoColorType  1
#define RGBColorType  3

  char
    property[MagickPathExtent];

  CINInfo
    cin;

  const unsigned char
    *pixels;

  Image
    *image;

  MagickBooleanType
    status;

  MagickOffsetType
    offset;

  QuantumInfo
    *quantum_info;

  QuantumType
    quantum_type;

  register ssize_t
    i;

  register Quantum
    *q;

  size_t
    length;

  ssize_t
    count,
    y;

  unsigned char
    magick[4];

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    File information.
  */
  offset=0;
  count=ReadBlob(image,4,magick);
  offset+=count;
  if ((count != 4) ||
      ((LocaleNCompare((char *) magick,""\200\052\137\327"",4) != 0)))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  memset(&cin,0,sizeof(cin));
  image->endian=(magick[0] == 0x80) && (magick[1] == 0x2a) &&
    (magick[2] == 0x5f) && (magick[3] == 0xd7) ? MSBEndian : LSBEndian;
  cin.file.image_offset=ReadBlobLong(image);
  offset+=4;
  cin.file.generic_length=ReadBlobLong(image);
  offset+=4;
  cin.file.industry_length=ReadBlobLong(image);
  offset+=4;
  cin.file.user_length=ReadBlobLong(image);
  offset+=4;
  cin.file.file_size=ReadBlobLong(image);
  offset+=4;
  offset+=ReadBlob(image,sizeof(cin.file.version),(unsigned char *)
    cin.file.version);
  (void) CopyMagickString(property,cin.file.version,sizeof(cin.file.version));
  (void) SetImageProperty(image,""dpx:file.version"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.file.filename),(unsigned char *)
    cin.file.filename);
  (void) CopyMagickString(property,cin.file.filename,sizeof(cin.file.filename));
  (void) SetImageProperty(image,""dpx:file.filename"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.file.create_date),(unsigned char *)
    cin.file.create_date);
  (void) CopyMagickString(property,cin.file.create_date,
    sizeof(cin.file.create_date));
  (void) SetImageProperty(image,""dpx:file.create_date"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.file.create_time),(unsigned char *)
    cin.file.create_time);
  (void) CopyMagickString(property,cin.file.create_time,
    sizeof(cin.file.create_time));
  (void) SetImageProperty(image,""dpx:file.create_time"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.file.reserve),(unsigned char *)
    cin.file.reserve);
  /*
    Image information.
  */
  cin.image.orientation=(unsigned char) ReadBlobByte(image);
  offset++;
  if (cin.image.orientation != (unsigned char) (~0))
    (void) FormatImageProperty(image,""dpx:image.orientation"",""%d"",
      cin.image.orientation);
  switch (cin.image.orientation)
  {
    default:
    case 0: image->orientation=TopLeftOrientation; break;
    case 1: image->orientation=TopRightOrientation; break;
    case 2: image->orientation=BottomLeftOrientation; break;
    case 3: image->orientation=BottomRightOrientation; break;
    case 4: image->orientation=LeftTopOrientation; break;
    case 5: image->orientation=RightTopOrientation; break;
    case 6: image->orientation=LeftBottomOrientation; break;
    case 7: image->orientation=RightBottomOrientation; break;
  }
  cin.image.number_channels=(unsigned char) ReadBlobByte(image);
  offset++;
  offset+=ReadBlob(image,sizeof(cin.image.reserve1),(unsigned char *)
    cin.image.reserve1);
  for (i=0; i < 8; i++)
  {
    cin.image.channel[i].designator[0]=(unsigned char) ReadBlobByte(image);
    offset++;
    cin.image.channel[i].designator[1]=(unsigned char) ReadBlobByte(image);
    offset++;
    cin.image.channel[i].bits_per_pixel=(unsigned char) ReadBlobByte(image);
    offset++;
    cin.image.channel[i].reserve=(unsigned char) ReadBlobByte(image);
    offset++;
    cin.image.channel[i].pixels_per_line=ReadBlobLong(image);
    offset+=4;
    cin.image.channel[i].lines_per_image=ReadBlobLong(image);
    offset+=4;
    cin.image.channel[i].min_data=ReadBlobFloat(image);
    offset+=4;
    cin.image.channel[i].min_quantity=ReadBlobFloat(image);
    offset+=4;
    cin.image.channel[i].max_data=ReadBlobFloat(image);
    offset+=4;
    cin.image.channel[i].max_quantity=ReadBlobFloat(image);
    offset+=4;
  }
  cin.image.white_point[0]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.white_point[0]) != MagickFalse)
    image->chromaticity.white_point.x=cin.image.white_point[0];
  cin.image.white_point[1]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.white_point[1]) != MagickFalse)
    image->chromaticity.white_point.y=cin.image.white_point[1];
  cin.image.red_primary_chromaticity[0]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.red_primary_chromaticity[0]) != MagickFalse)
    image->chromaticity.red_primary.x=cin.image.red_primary_chromaticity[0];
  cin.image.red_primary_chromaticity[1]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.red_primary_chromaticity[1]) != MagickFalse)
    image->chromaticity.red_primary.y=cin.image.red_primary_chromaticity[1];
  cin.image.green_primary_chromaticity[0]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.green_primary_chromaticity[0]) != MagickFalse)
    image->chromaticity.red_primary.x=cin.image.green_primary_chromaticity[0];
  cin.image.green_primary_chromaticity[1]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.green_primary_chromaticity[1]) != MagickFalse)
    image->chromaticity.green_primary.y=cin.image.green_primary_chromaticity[1];
  cin.image.blue_primary_chromaticity[0]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.blue_primary_chromaticity[0]) != MagickFalse)
    image->chromaticity.blue_primary.x=cin.image.blue_primary_chromaticity[0];
  cin.image.blue_primary_chromaticity[1]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.blue_primary_chromaticity[1]) != MagickFalse)
    image->chromaticity.blue_primary.y=cin.image.blue_primary_chromaticity[1];
  offset+=ReadBlob(image,sizeof(cin.image.label),(unsigned char *)
    cin.image.label);
  (void) CopyMagickString(property,cin.image.label,sizeof(cin.image.label));
  (void) SetImageProperty(image,""dpx:image.label"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.image.reserve),(unsigned char *)
    cin.image.reserve);
  /*
    Image data format information.
  */
  cin.data_format.interleave=(unsigned char) ReadBlobByte(image);
  offset++;
  cin.data_format.packing=(unsigned char) ReadBlobByte(image);
  offset++;
  cin.data_format.sign=(unsigned char) ReadBlobByte(image);
  offset++;
  cin.data_format.sense=(unsigned char) ReadBlobByte(image);
  offset++;
  cin.data_format.line_pad=ReadBlobLong(image);
  offset+=4;
  cin.data_format.channel_pad=ReadBlobLong(image);
  offset+=4;
  offset+=ReadBlob(image,sizeof(cin.data_format.reserve),(unsigned char *)
    cin.data_format.reserve);
  /*
    Image origination information.
  */
  cin.origination.x_offset=ReadBlobSignedLong(image);
  offset+=4;
  if ((size_t) cin.origination.x_offset != ~0UL)
    (void) FormatImageProperty(image,""dpx:origination.x_offset"",""%.20g"",
      (double) cin.origination.x_offset);
  cin.origination.y_offset=(ssize_t) ReadBlobLong(image);
  offset+=4;
  if ((size_t) cin.origination.y_offset != ~0UL)
    (void) FormatImageProperty(image,""dpx:origination.y_offset"",""%.20g"",
      (double) cin.origination.y_offset);
  offset+=ReadBlob(image,sizeof(cin.origination.filename),(unsigned char *)
    cin.origination.filename);
  (void) CopyMagickString(property,cin.origination.filename,
    sizeof(cin.origination.filename));
  (void) SetImageProperty(image,""dpx:origination.filename"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.origination.create_date),(unsigned char *)
    cin.origination.create_date);
  (void) CopyMagickString(property,cin.origination.create_date,
    sizeof(cin.origination.create_date));
  (void) SetImageProperty(image,""dpx:origination.create_date"",property,
    exception);
  offset+=ReadBlob(image,sizeof(cin.origination.create_time),(unsigned char *)
    cin.origination.create_time);
  (void) CopyMagickString(property,cin.origination.create_time,
    sizeof(cin.origination.create_time));
  (void) SetImageProperty(image,""dpx:origination.create_time"",property,
    exception);
  offset+=ReadBlob(image,sizeof(cin.origination.device),(unsigned char *)
    cin.origination.device);
  (void) CopyMagickString(property,cin.origination.device,
    sizeof(cin.origination.device));
  (void) SetImageProperty(image,""dpx:origination.device"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.origination.model),(unsigned char *)
    cin.origination.model);
  (void) CopyMagickString(property,cin.origination.model,
    sizeof(cin.origination.model));
  (void) SetImageProperty(image,""dpx:origination.model"",property,exception);
  (void) memset(cin.origination.serial,0, 
    sizeof(cin.origination.serial));
  offset+=ReadBlob(image,sizeof(cin.origination.serial),(unsigned char *)
    cin.origination.serial);
  (void) CopyMagickString(property,cin.origination.serial,
    sizeof(cin.origination.serial));
  (void) SetImageProperty(image,""dpx:origination.serial"",property,exception);
  cin.origination.x_pitch=ReadBlobFloat(image);
  offset+=4;
  cin.origination.y_pitch=ReadBlobFloat(image);
  offset+=4;
  cin.origination.gamma=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.origination.gamma) != MagickFalse)
    image->gamma=cin.origination.gamma;
  offset+=ReadBlob(image,sizeof(cin.origination.reserve),(unsigned char *)
    cin.origination.reserve);
  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))
    {
      int
        c;

      /*
        Image film information.
      */
      cin.film.id=ReadBlobByte(image);
      offset++;
      c=cin.film.id;
      if (c != ~0)
        (void) FormatImageProperty(image,""dpx:film.id"",""%d"",cin.film.id);
      cin.film.type=ReadBlobByte(image);
      offset++;
      c=cin.film.type;
      if (c != ~0)
        (void) FormatImageProperty(image,""dpx:film.type"",""%d"",cin.film.type);
      cin.film.offset=ReadBlobByte(image);
      offset++;
      c=cin.film.offset;
      if (c != ~0)
        (void) FormatImageProperty(image,""dpx:film.offset"",""%d"",
          cin.film.offset);
      cin.film.reserve1=ReadBlobByte(image);
      offset++;
      cin.film.prefix=ReadBlobLong(image);
      offset+=4;
      if (cin.film.prefix != ~0UL)
        (void) FormatImageProperty(image,""dpx:film.prefix"",""%.20g"",(double)
          cin.film.prefix);
      cin.film.count=ReadBlobLong(image);
      offset+=4;
      offset+=ReadBlob(image,sizeof(cin.film.format),(unsigned char *)
        cin.film.format);
      (void) CopyMagickString(property,cin.film.format,sizeof(cin.film.format));
      (void) SetImageProperty(image,""dpx:film.format"",property,exception);
      cin.film.frame_position=ReadBlobLong(image);
      offset+=4;
      if (cin.film.frame_position != ~0UL)
        (void) FormatImageProperty(image,""dpx:film.frame_position"",""%.20g"",
          (double) cin.film.frame_position);
      cin.film.frame_rate=ReadBlobFloat(image);
      offset+=4;
      if (IsFloatDefined(cin.film.frame_rate) != MagickFalse)
        (void) FormatImageProperty(image,""dpx:film.frame_rate"",""%g"",
          cin.film.frame_rate);
      offset+=ReadBlob(image,sizeof(cin.film.frame_id),(unsigned char *)
        cin.film.frame_id);
      (void) CopyMagickString(property,cin.film.frame_id,
        sizeof(cin.film.frame_id));
      (void) SetImageProperty(image,""dpx:film.frame_id"",property,exception);
      offset+=ReadBlob(image,sizeof(cin.film.slate_info),(unsigned char *)
        cin.film.slate_info);
      (void) CopyMagickString(property,cin.film.slate_info,
        sizeof(cin.film.slate_info));
      (void) SetImageProperty(image,""dpx:film.slate_info"",property,exception);
      offset+=ReadBlob(image,sizeof(cin.film.reserve),(unsigned char *)
        cin.film.reserve);
    }
  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))
    {
      StringInfo
        *profile;

      /*
        User defined data.
      */
      if (cin.file.user_length > GetBlobSize(image))
        ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
      profile=BlobToStringInfo((const unsigned char *) NULL,
        cin.file.user_length);
      if (profile == (StringInfo *) NULL)
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      offset+=ReadBlob(image,GetStringInfoLength(profile),
        GetStringInfoDatum(profile));
      (void) SetImageProfile(image,""dpx:user.data"",profile,exception);
      profile=DestroyStringInfo(profile);
    }
  image->depth=cin.image.channel[0].bits_per_pixel;
  image->columns=cin.image.channel[0].pixels_per_line;
  image->rows=cin.image.channel[0].lines_per_image;
  if (image_info->ping != MagickFalse)
    {
       (void) CloseBlob(image);
       return(image);
     }
//fix_flaw_line_below:
//  if (((MagickSizeType) image->columns*image->rows) > GetBlobSize(image))
//fix_flaw_line_below:
//    ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
   for ( ; offset < (MagickOffsetType) cin.file.image_offset; offset++)
   {
     int
      c;

    c=ReadBlobByte(image);
    if (c == EOF)
      break;
  }
  if (offset < (MagickOffsetType) cin.file.image_offset)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  status=SetImageExtent(image,image->columns,image->rows,exception);
  if (status == MagickFalse)
    return(DestroyImageList(image));
  (void) SetImageBackgroundColor(image,exception);
  /*
    Convert CIN raster image to pixel packets.
  */
  quantum_info=AcquireQuantumInfo(image_info,image);
  if (quantum_info == (QuantumInfo *) NULL)
    ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
  quantum_info->quantum=32;
  quantum_info->pack=MagickFalse;
  quantum_type=RGBQuantum;
  length=GetQuantumExtent(image,quantum_info,quantum_type);
  length=GetBytesPerRow(image->columns,3,image->depth,MagickTrue);
  if (cin.image.number_channels == 1)
    {
      quantum_type=GrayQuantum;
      length=GetBytesPerRow(image->columns,1,image->depth,MagickTrue);
    }
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    pixels=(const unsigned char *) ReadBlobStream(image,length,
      GetQuantumPixels(quantum_info),&count);
    if ((size_t) count != length)
      break;
    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
      quantum_type,pixels,exception);
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  SetQuantumImageType(image,quantum_type);
  quantum_info=DestroyQuantumInfo(quantum_info);
  if (EOFBlob(image) != MagickFalse)
    ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
      image->filename);
  SetImageColorspace(image,LogColorspace,exception);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
"
5132,182868,,Remote,Not required,Partial,CVE-2019-11413,https://www.cvedetails.com/cve/CVE-2019-11413/,CWE-400,Low,,,,2019-04-22,5.0,An issue was discovered in Artifex MuJS 1.0.5. It has unlimited recursion because the match function in regexp.c lacks a depth check.,2019-04-30,,5,https://github.com/ccxvii/mujs/commit/00d4606c3baf813b7b1c176823b2729bf51002a2,00d4606c3baf813b7b1c176823b2729bf51002a2,"Bug 700937: Limit recursion in regexp matcher.

Also handle negative return code as an error in the JS bindings.",1,jsregexp.c,"{""sha"": ""98b2a869c2cda0a0f19eb0a0ec41adfaaa90a3e0"", ""filename"": ""jsregexp.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 2, ""changes"": 12, ""blob_url"": ""https://github.com/ccxvii/mujs/blob/00d4606c3baf813b7b1c176823b2729bf51002a2/jsregexp.c"", ""raw_url"": ""https://github.com/ccxvii/mujs/raw/00d4606c3baf813b7b1c176823b2729bf51002a2/jsregexp.c"", ""contents_url"": ""https://api.github.com/repos/ccxvii/mujs/contents/jsregexp.c?ref=00d4606c3baf813b7b1c176823b2729bf51002a2"", ""patch"": ""@@ -29,6 +29,7 @@ void js_newregexp(js_State *J, const char *pattern, int flags)\n \n void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)\n {\n+\tint result;\n \tint i;\n \tint opts;\n \tResub m;\n@@ -46,7 +47,10 @@ void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)\n \t\t}\n \t}\n \n-\tif (!js_regexec(re->prog, text, &m, opts)) {\n+\tresult = js_regexec(re->prog, text, &m, opts);\n+\tif (result < 0)\n+\t\tjs_error(J, \""regexec failed\"");\n+\tif (result == 0) {\n \t\tjs_newarray(J);\n \t\tjs_pushstring(J, text);\n \t\tjs_setproperty(J, -2, \""input\"");\n@@ -71,6 +75,7 @@ static void Rp_test(js_State *J)\n {\n \tjs_Regexp *re;\n \tconst char *text;\n+\tint result;\n \tint opts;\n \tResub m;\n \n@@ -90,7 +95,10 @@ static void Rp_test(js_State *J)\n \t\t}\n \t}\n \n-\tif (!js_regexec(re->prog, text, &m, opts)) {\n+\tresult = js_regexec(re->prog, text, &m, opts);\n+\tif (result < 0)\n+\t\tjs_error(J, \""regexec failed\"");\n+\tif (result == 0) {\n \t\tif (re->flags & JS_REGEXP_G)\n \t\t\tre->last = re->last + (m.sub[0].ep - text);\n \t\tjs_pushboolean(J, 1);""}<_**next**_>{""sha"": ""29d2b8a56e95155a130c6eef25543fe0fb690ce8"", ""filename"": ""jsstring.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 6, ""changes"": 20, ""blob_url"": ""https://github.com/ccxvii/mujs/blob/00d4606c3baf813b7b1c176823b2729bf51002a2/jsstring.c"", ""raw_url"": ""https://github.com/ccxvii/mujs/raw/00d4606c3baf813b7b1c176823b2729bf51002a2/jsstring.c"", ""contents_url"": ""https://api.github.com/repos/ccxvii/mujs/contents/jsstring.c?ref=00d4606c3baf813b7b1c176823b2729bf51002a2"", ""patch"": ""@@ -4,6 +4,14 @@\n #include \""utf.h\""\n #include \""regexp.h\""\n \n+static int js_doregexec(js_State *J, Reprog *prog, const char *string, Resub *sub, int eflags)\n+{\n+\tint result = js_regexec(prog, string, sub, eflags);\n+\tif (result < 0)\n+\t\tjs_error(J, \""regexec failed\"");\n+\treturn result;\n+}\n+\n static const char *checkstring(js_State *J, int idx)\n {\n \tif (!js_iscoercible(J, idx))\n@@ -343,7 +351,7 @@ static void Sp_match(js_State *J)\n \ta = text;\n \te = text + strlen(text);\n \twhile (a <= e) {\n-\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n+\t\tif (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n \t\t\tbreak;\n \n \t\tb = m.sub[0].sp;\n@@ -380,7 +388,7 @@ static void Sp_search(js_State *J)\n \n \tre = js_toregexp(J, -1);\n \n-\tif (!js_regexec(re->prog, text, &m, 0))\n+\tif (!js_doregexec(J, re->prog, text, &m, 0))\n \t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n \telse\n \t\tjs_pushnumber(J, -1);\n@@ -397,7 +405,7 @@ static void Sp_replace_regexp(js_State *J)\n \tsource = checkstring(J, 0);\n \tre = js_toregexp(J, 1);\n \n-\tif (js_regexec(re->prog, source, &m, 0)) {\n+\tif (js_doregexec(J, re->prog, source, &m, 0)) {\n \t\tjs_copy(J, 0);\n \t\treturn;\n \t}\n@@ -471,7 +479,7 @@ static void Sp_replace_regexp(js_State *J)\n \t\t\telse\n \t\t\t\tgoto end;\n \t\t}\n-\t\tif (!js_regexec(re->prog, source, &m, REG_NOTBOL))\n+\t\tif (!js_doregexec(J, re->prog, source, &m, REG_NOTBOL))\n \t\t\tgoto loop;\n \t}\n \n@@ -576,7 +584,7 @@ static void Sp_split_regexp(js_State *J)\n \n \t/* splitting the empty string */\n \tif (e == text) {\n-\t\tif (js_regexec(re->prog, text, &m, 0)) {\n+\t\tif (js_doregexec(J, re->prog, text, &m, 0)) {\n \t\t\tif (len == limit) return;\n \t\t\tjs_pushliteral(J, \""\"");\n \t\t\tjs_setindex(J, -2, 0);\n@@ -586,7 +594,7 @@ static void Sp_split_regexp(js_State *J)\n \n \tp = a = text;\n \twhile (a < e) {\n-\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n+\t\tif (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n \t\t\tbreak; /* no match */\n \n \t\tb = m.sub[0].sp;""}<_**next**_>{""sha"": ""3f800e3bd275fd17ad95a9d5b82c5c1635f9c39d"", ""filename"": ""regexp.c"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 27, ""changes"": 69, ""blob_url"": ""https://github.com/ccxvii/mujs/blob/00d4606c3baf813b7b1c176823b2729bf51002a2/regexp.c"", ""raw_url"": ""https://github.com/ccxvii/mujs/raw/00d4606c3baf813b7b1c176823b2729bf51002a2/regexp.c"", ""contents_url"": ""https://api.github.com/repos/ccxvii/mujs/contents/regexp.c?ref=00d4606c3baf813b7b1c176823b2729bf51002a2"", ""patch"": ""@@ -16,6 +16,7 @@\n #define REPINF 255\n #define MAXSUB REG_MAXSUB\n #define MAXPROG (32 << 10)\n+#define MAXREC 1024\n \n typedef struct Reclass Reclass;\n typedef struct Renode Renode;\n@@ -967,98 +968,112 @@ static int strncmpcanon(const char *a, const char *b, int n)\n \treturn 0;\n }\n \n-static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *out)\n+static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *out, int depth)\n {\n \tResub scratch;\n+\tint result;\n \tint i;\n \tRune c;\n \n+\t/* stack overflow */\n+\tif (depth > MAXREC)\n+\t\treturn -1;\n+\n \tfor (;;) {\n \t\tswitch (pc->opcode) {\n \t\tcase I_END:\n-\t\t\treturn 1;\n+\t\t\treturn 0;\n \t\tcase I_JUMP:\n \t\t\tpc = pc->x;\n \t\t\tbreak;\n \t\tcase I_SPLIT:\n \t\t\tscratch = *out;\n-\t\t\tif (match(pc->x, sp, bol, flags, &scratch)) {\n+\t\t\tresult = match(pc->x, sp, bol, flags, &scratch, depth+1);\n+\t\t\tif (result == -1)\n+\t\t\t\treturn -1;\n+\t\t\tif (result == 0) {\n \t\t\t\t*out = scratch;\n-\t\t\t\treturn 1;\n+\t\t\t\treturn 0;\n \t\t\t}\n \t\t\tpc = pc->y;\n \t\t\tbreak;\n \n \t\tcase I_PLA:\n-\t\t\tif (!match(pc->x, sp, bol, flags, out))\n-\t\t\t\treturn 0;\n+\t\t\tresult = match(pc->x, sp, bol, flags, out, depth+1);\n+\t\t\tif (result == -1)\n+\t\t\t\treturn -1;\n+\t\t\tif (result == 1)\n+\t\t\t\treturn 1;\n \t\t\tpc = pc->y;\n \t\t\tbreak;\n \t\tcase I_NLA:\n \t\t\tscratch = *out;\n-\t\t\tif (match(pc->x, sp, bol, flags, &scratch))\n-\t\t\t\treturn 0;\n+\t\t\tresult = match(pc->x, sp, bol, flags, &scratch, depth+1);\n+\t\t\tif (result == -1)\n+\t\t\t\treturn -1;\n+\t\t\tif (result == 0)\n+\t\t\t\treturn 1;\n \t\t\tpc = pc->y;\n \t\t\tbreak;\n \n \t\tcase I_ANYNL:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_ANY:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (isnewline(c))\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_CHAR:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (flags & REG_ICASE)\n \t\t\t\tc = canon(c);\n \t\t\tif (c != pc->c)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_CCLASS:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (flags & REG_ICASE) {\n \t\t\t\tif (!incclasscanon(pc->cc, canon(c)))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t} else {\n \t\t\t\tif (!incclass(pc->cc, c))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t}\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_NCCLASS:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (flags & REG_ICASE) {\n \t\t\t\tif (incclasscanon(pc->cc, canon(c)))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t} else {\n \t\t\t\tif (incclass(pc->cc, c))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t}\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_REF:\n \t\t\ti = out->sub[pc->n].ep - out->sub[pc->n].sp;\n \t\t\tif (flags & REG_ICASE) {\n \t\t\t\tif (strncmpcanon(sp, out->sub[pc->n].sp, i))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t} else {\n \t\t\t\tif (strncmp(sp, out->sub[pc->n].sp, i))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t}\n \t\t\tif (i > 0)\n \t\t\t\tsp += i;\n@@ -1076,7 +1091,7 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n-\t\t\treturn 0;\n+\t\t\treturn 1;\n \t\tcase I_EOL:\n \t\t\tif (*sp == 0) {\n \t\t\t\tpc = pc + 1;\n@@ -1088,19 +1103,19 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n-\t\t\treturn 0;\n+\t\t\treturn 1;\n \t\tcase I_WORD:\n \t\t\ti = sp > bol && iswordchar(sp[-1]);\n \t\t\ti ^= iswordchar(sp[0]);\n \t\t\tif (!i)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_NWORD:\n \t\t\ti = sp > bol && iswordchar(sp[-1]);\n \t\t\ti ^= iswordchar(sp[0]);\n \t\t\tif (i)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \n@@ -1113,7 +1128,7 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tdefault:\n-\t\t\treturn 0;\n+\t\t\treturn 1;\n \t\t}\n \t}\n }\n@@ -1130,7 +1145,7 @@ int regexec(Reprog *prog, const char *sp, Resub *sub, int eflags)\n \tfor (i = 0; i < MAXSUB; ++i)\n \t\tsub->sub[i].sp = sub->sub[i].ep = NULL;\n \n-\treturn !match(prog->start, sp, sp, prog->flags | eflags, sub);\n+\treturn match(prog->start, sp, sp, prog->flags | eflags, sub, 0);\n }\n \n #ifdef TEST""}","static void Rp_test(js_State *J)
 {
 	js_Regexp *re;
 	const char *text;
	int result;
 	int opts;
 	Resub m;
 
	re = js_toregexp(J, 0);
	text = js_tostring(J, 1);

	opts = 0;
	if (re->flags & JS_REGEXP_G) {
		if (re->last > strlen(text)) {
			re->last = 0;
			js_pushboolean(J, 0);
			return;
		}
		if (re->last > 0) {
			text += re->last;
			opts |= REG_NOTBOL;
 		}
 	}
 
	result = js_regexec(re->prog, text, &m, opts);
	if (result < 0)
		js_error(J, ""regexec failed"");
	if (result == 0) {
 		if (re->flags & JS_REGEXP_G)
 			re->last = re->last + (m.sub[0].ep - text);
 		js_pushboolean(J, 1);
		return;
	}

	if (re->flags & JS_REGEXP_G)
		re->last = 0;

	js_pushboolean(J, 0);
}
","static void Rp_test(js_State *J)
 {
 	js_Regexp *re;
 	const char *text;
 	int opts;
 	Resub m;
 
	re = js_toregexp(J, 0);
	text = js_tostring(J, 1);

	opts = 0;
	if (re->flags & JS_REGEXP_G) {
		if (re->last > strlen(text)) {
			re->last = 0;
			js_pushboolean(J, 0);
			return;
		}
		if (re->last > 0) {
			text += re->last;
			opts |= REG_NOTBOL;
 		}
 	}
 
	if (!js_regexec(re->prog, text, &m, opts)) {
 		if (re->flags & JS_REGEXP_G)
 			re->last = re->last + (m.sub[0].ep - text);
 		js_pushboolean(J, 1);
		return;
	}

	if (re->flags & JS_REGEXP_G)
		re->last = 0;

	js_pushboolean(J, 0);
}
",C,"	int result;
	result = js_regexec(re->prog, text, &m, opts);
	if (result < 0)
		js_error(J, ""regexec failed"");
	if (result == 0) {
","	if (!js_regexec(re->prog, text, &m, opts)) {
",,"@@ -29,6 +29,7 @@ void js_newregexp(js_State *J, const char *pattern, int flags)
 
 void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)
 {
+	int result;
 	int i;
 	int opts;
 	Resub m;
@@ -46,7 +47,10 @@ void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)
 		}
 	}
 
-	if (!js_regexec(re->prog, text, &m, opts)) {
+	result = js_regexec(re->prog, text, &m, opts);
+	if (result < 0)
+		js_error(J, ""regexec failed"");
+	if (result == 0) {
 		js_newarray(J);
 		js_pushstring(J, text);
 		js_setproperty(J, -2, ""input"");
@@ -71,6 +75,7 @@ static void Rp_test(js_State *J)
 {
 	js_Regexp *re;
 	const char *text;
+	int result;
 	int opts;
 	Resub m;
 
@@ -90,7 +95,10 @@ static void Rp_test(js_State *J)
 		}
 	}
 
-	if (!js_regexec(re->prog, text, &m, opts)) {
+	result = js_regexec(re->prog, text, &m, opts);
+	if (result < 0)
+		js_error(J, ""regexec failed"");
+	if (result == 0) {
 		if (re->flags & JS_REGEXP_G)
 			re->last = re->last + (m.sub[0].ep - text);
 		js_pushboolean(J, 1);",mujs,00d4606c3baf813b7b1c176823b2729bf51002a2,1e5479084bc9852854feb1ba9bf68b52cd127e02,1,"static void Rp_test(js_State *J)
 {
 	js_Regexp *re;
 	const char *text;
//fix_flaw_line_below:
//	int result;
 	int opts;
 	Resub m;
 
	re = js_toregexp(J, 0);
	text = js_tostring(J, 1);

	opts = 0;
	if (re->flags & JS_REGEXP_G) {
		if (re->last > strlen(text)) {
			re->last = 0;
			js_pushboolean(J, 0);
			return;
		}
		if (re->last > 0) {
			text += re->last;
			opts |= REG_NOTBOL;
 		}
 	}
 
//flaw_line_below:
	if (!js_regexec(re->prog, text, &m, opts)) {
//fix_flaw_line_below:
//	result = js_regexec(re->prog, text, &m, opts);
//fix_flaw_line_below:
//	if (result < 0)
//fix_flaw_line_below:
//		js_error(J, ""regexec failed"");
//fix_flaw_line_below:
//	if (result == 0) {
 		if (re->flags & JS_REGEXP_G)
 			re->last = re->last + (m.sub[0].ep - text);
 		js_pushboolean(J, 1);
		return;
	}

	if (re->flags & JS_REGEXP_G)
		re->last = 0;

	js_pushboolean(J, 0);
}
"
5133,182869,,Remote,Not required,Partial,CVE-2019-11413,https://www.cvedetails.com/cve/CVE-2019-11413/,CWE-400,Low,,,,2019-04-22,5.0,An issue was discovered in Artifex MuJS 1.0.5. It has unlimited recursion because the match function in regexp.c lacks a depth check.,2019-04-30,,5,https://github.com/ccxvii/mujs/commit/00d4606c3baf813b7b1c176823b2729bf51002a2,00d4606c3baf813b7b1c176823b2729bf51002a2,"Bug 700937: Limit recursion in regexp matcher.

Also handle negative return code as an error in the JS bindings.",1,jsregexp.c,"{""sha"": ""98b2a869c2cda0a0f19eb0a0ec41adfaaa90a3e0"", ""filename"": ""jsregexp.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 2, ""changes"": 12, ""blob_url"": ""https://github.com/ccxvii/mujs/blob/00d4606c3baf813b7b1c176823b2729bf51002a2/jsregexp.c"", ""raw_url"": ""https://github.com/ccxvii/mujs/raw/00d4606c3baf813b7b1c176823b2729bf51002a2/jsregexp.c"", ""contents_url"": ""https://api.github.com/repos/ccxvii/mujs/contents/jsregexp.c?ref=00d4606c3baf813b7b1c176823b2729bf51002a2"", ""patch"": ""@@ -29,6 +29,7 @@ void js_newregexp(js_State *J, const char *pattern, int flags)\n \n void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)\n {\n+\tint result;\n \tint i;\n \tint opts;\n \tResub m;\n@@ -46,7 +47,10 @@ void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)\n \t\t}\n \t}\n \n-\tif (!js_regexec(re->prog, text, &m, opts)) {\n+\tresult = js_regexec(re->prog, text, &m, opts);\n+\tif (result < 0)\n+\t\tjs_error(J, \""regexec failed\"");\n+\tif (result == 0) {\n \t\tjs_newarray(J);\n \t\tjs_pushstring(J, text);\n \t\tjs_setproperty(J, -2, \""input\"");\n@@ -71,6 +75,7 @@ static void Rp_test(js_State *J)\n {\n \tjs_Regexp *re;\n \tconst char *text;\n+\tint result;\n \tint opts;\n \tResub m;\n \n@@ -90,7 +95,10 @@ static void Rp_test(js_State *J)\n \t\t}\n \t}\n \n-\tif (!js_regexec(re->prog, text, &m, opts)) {\n+\tresult = js_regexec(re->prog, text, &m, opts);\n+\tif (result < 0)\n+\t\tjs_error(J, \""regexec failed\"");\n+\tif (result == 0) {\n \t\tif (re->flags & JS_REGEXP_G)\n \t\t\tre->last = re->last + (m.sub[0].ep - text);\n \t\tjs_pushboolean(J, 1);""}<_**next**_>{""sha"": ""29d2b8a56e95155a130c6eef25543fe0fb690ce8"", ""filename"": ""jsstring.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 6, ""changes"": 20, ""blob_url"": ""https://github.com/ccxvii/mujs/blob/00d4606c3baf813b7b1c176823b2729bf51002a2/jsstring.c"", ""raw_url"": ""https://github.com/ccxvii/mujs/raw/00d4606c3baf813b7b1c176823b2729bf51002a2/jsstring.c"", ""contents_url"": ""https://api.github.com/repos/ccxvii/mujs/contents/jsstring.c?ref=00d4606c3baf813b7b1c176823b2729bf51002a2"", ""patch"": ""@@ -4,6 +4,14 @@\n #include \""utf.h\""\n #include \""regexp.h\""\n \n+static int js_doregexec(js_State *J, Reprog *prog, const char *string, Resub *sub, int eflags)\n+{\n+\tint result = js_regexec(prog, string, sub, eflags);\n+\tif (result < 0)\n+\t\tjs_error(J, \""regexec failed\"");\n+\treturn result;\n+}\n+\n static const char *checkstring(js_State *J, int idx)\n {\n \tif (!js_iscoercible(J, idx))\n@@ -343,7 +351,7 @@ static void Sp_match(js_State *J)\n \ta = text;\n \te = text + strlen(text);\n \twhile (a <= e) {\n-\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n+\t\tif (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n \t\t\tbreak;\n \n \t\tb = m.sub[0].sp;\n@@ -380,7 +388,7 @@ static void Sp_search(js_State *J)\n \n \tre = js_toregexp(J, -1);\n \n-\tif (!js_regexec(re->prog, text, &m, 0))\n+\tif (!js_doregexec(J, re->prog, text, &m, 0))\n \t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n \telse\n \t\tjs_pushnumber(J, -1);\n@@ -397,7 +405,7 @@ static void Sp_replace_regexp(js_State *J)\n \tsource = checkstring(J, 0);\n \tre = js_toregexp(J, 1);\n \n-\tif (js_regexec(re->prog, source, &m, 0)) {\n+\tif (js_doregexec(J, re->prog, source, &m, 0)) {\n \t\tjs_copy(J, 0);\n \t\treturn;\n \t}\n@@ -471,7 +479,7 @@ static void Sp_replace_regexp(js_State *J)\n \t\t\telse\n \t\t\t\tgoto end;\n \t\t}\n-\t\tif (!js_regexec(re->prog, source, &m, REG_NOTBOL))\n+\t\tif (!js_doregexec(J, re->prog, source, &m, REG_NOTBOL))\n \t\t\tgoto loop;\n \t}\n \n@@ -576,7 +584,7 @@ static void Sp_split_regexp(js_State *J)\n \n \t/* splitting the empty string */\n \tif (e == text) {\n-\t\tif (js_regexec(re->prog, text, &m, 0)) {\n+\t\tif (js_doregexec(J, re->prog, text, &m, 0)) {\n \t\t\tif (len == limit) return;\n \t\t\tjs_pushliteral(J, \""\"");\n \t\t\tjs_setindex(J, -2, 0);\n@@ -586,7 +594,7 @@ static void Sp_split_regexp(js_State *J)\n \n \tp = a = text;\n \twhile (a < e) {\n-\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n+\t\tif (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n \t\t\tbreak; /* no match */\n \n \t\tb = m.sub[0].sp;""}<_**next**_>{""sha"": ""3f800e3bd275fd17ad95a9d5b82c5c1635f9c39d"", ""filename"": ""regexp.c"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 27, ""changes"": 69, ""blob_url"": ""https://github.com/ccxvii/mujs/blob/00d4606c3baf813b7b1c176823b2729bf51002a2/regexp.c"", ""raw_url"": ""https://github.com/ccxvii/mujs/raw/00d4606c3baf813b7b1c176823b2729bf51002a2/regexp.c"", ""contents_url"": ""https://api.github.com/repos/ccxvii/mujs/contents/regexp.c?ref=00d4606c3baf813b7b1c176823b2729bf51002a2"", ""patch"": ""@@ -16,6 +16,7 @@\n #define REPINF 255\n #define MAXSUB REG_MAXSUB\n #define MAXPROG (32 << 10)\n+#define MAXREC 1024\n \n typedef struct Reclass Reclass;\n typedef struct Renode Renode;\n@@ -967,98 +968,112 @@ static int strncmpcanon(const char *a, const char *b, int n)\n \treturn 0;\n }\n \n-static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *out)\n+static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *out, int depth)\n {\n \tResub scratch;\n+\tint result;\n \tint i;\n \tRune c;\n \n+\t/* stack overflow */\n+\tif (depth > MAXREC)\n+\t\treturn -1;\n+\n \tfor (;;) {\n \t\tswitch (pc->opcode) {\n \t\tcase I_END:\n-\t\t\treturn 1;\n+\t\t\treturn 0;\n \t\tcase I_JUMP:\n \t\t\tpc = pc->x;\n \t\t\tbreak;\n \t\tcase I_SPLIT:\n \t\t\tscratch = *out;\n-\t\t\tif (match(pc->x, sp, bol, flags, &scratch)) {\n+\t\t\tresult = match(pc->x, sp, bol, flags, &scratch, depth+1);\n+\t\t\tif (result == -1)\n+\t\t\t\treturn -1;\n+\t\t\tif (result == 0) {\n \t\t\t\t*out = scratch;\n-\t\t\t\treturn 1;\n+\t\t\t\treturn 0;\n \t\t\t}\n \t\t\tpc = pc->y;\n \t\t\tbreak;\n \n \t\tcase I_PLA:\n-\t\t\tif (!match(pc->x, sp, bol, flags, out))\n-\t\t\t\treturn 0;\n+\t\t\tresult = match(pc->x, sp, bol, flags, out, depth+1);\n+\t\t\tif (result == -1)\n+\t\t\t\treturn -1;\n+\t\t\tif (result == 1)\n+\t\t\t\treturn 1;\n \t\t\tpc = pc->y;\n \t\t\tbreak;\n \t\tcase I_NLA:\n \t\t\tscratch = *out;\n-\t\t\tif (match(pc->x, sp, bol, flags, &scratch))\n-\t\t\t\treturn 0;\n+\t\t\tresult = match(pc->x, sp, bol, flags, &scratch, depth+1);\n+\t\t\tif (result == -1)\n+\t\t\t\treturn -1;\n+\t\t\tif (result == 0)\n+\t\t\t\treturn 1;\n \t\t\tpc = pc->y;\n \t\t\tbreak;\n \n \t\tcase I_ANYNL:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_ANY:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (isnewline(c))\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_CHAR:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (flags & REG_ICASE)\n \t\t\t\tc = canon(c);\n \t\t\tif (c != pc->c)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_CCLASS:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (flags & REG_ICASE) {\n \t\t\t\tif (!incclasscanon(pc->cc, canon(c)))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t} else {\n \t\t\t\tif (!incclass(pc->cc, c))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t}\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_NCCLASS:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (flags & REG_ICASE) {\n \t\t\t\tif (incclasscanon(pc->cc, canon(c)))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t} else {\n \t\t\t\tif (incclass(pc->cc, c))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t}\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_REF:\n \t\t\ti = out->sub[pc->n].ep - out->sub[pc->n].sp;\n \t\t\tif (flags & REG_ICASE) {\n \t\t\t\tif (strncmpcanon(sp, out->sub[pc->n].sp, i))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t} else {\n \t\t\t\tif (strncmp(sp, out->sub[pc->n].sp, i))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t}\n \t\t\tif (i > 0)\n \t\t\t\tsp += i;\n@@ -1076,7 +1091,7 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n-\t\t\treturn 0;\n+\t\t\treturn 1;\n \t\tcase I_EOL:\n \t\t\tif (*sp == 0) {\n \t\t\t\tpc = pc + 1;\n@@ -1088,19 +1103,19 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n-\t\t\treturn 0;\n+\t\t\treturn 1;\n \t\tcase I_WORD:\n \t\t\ti = sp > bol && iswordchar(sp[-1]);\n \t\t\ti ^= iswordchar(sp[0]);\n \t\t\tif (!i)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_NWORD:\n \t\t\ti = sp > bol && iswordchar(sp[-1]);\n \t\t\ti ^= iswordchar(sp[0]);\n \t\t\tif (i)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \n@@ -1113,7 +1128,7 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tdefault:\n-\t\t\treturn 0;\n+\t\t\treturn 1;\n \t\t}\n \t}\n }\n@@ -1130,7 +1145,7 @@ int regexec(Reprog *prog, const char *sp, Resub *sub, int eflags)\n \tfor (i = 0; i < MAXSUB; ++i)\n \t\tsub->sub[i].sp = sub->sub[i].ep = NULL;\n \n-\treturn !match(prog->start, sp, sp, prog->flags | eflags, sub);\n+\treturn match(prog->start, sp, sp, prog->flags | eflags, sub, 0);\n }\n \n #ifdef TEST""}"," void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)
 {
	int result;
 	int i;
 	int opts;
 	Resub m;

	opts = 0;
	if (re->flags & JS_REGEXP_G) {
		if (re->last > strlen(text)) {
			re->last = 0;
			js_pushnull(J);
			return;
		}
		if (re->last > 0) {
			text += re->last;
			opts |= REG_NOTBOL;
 		}
 	}
 
	result = js_regexec(re->prog, text, &m, opts);
	if (result < 0)
		js_error(J, ""regexec failed"");
	if (result == 0) {
 		js_newarray(J);
 		js_pushstring(J, text);
 		js_setproperty(J, -2, ""input"");
		js_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));
		js_setproperty(J, -2, ""index"");
		for (i = 0; i < m.nsub; ++i) {
			js_pushlstring(J, m.sub[i].sp, m.sub[i].ep - m.sub[i].sp);
			js_setindex(J, -2, i);
		}
		if (re->flags & JS_REGEXP_G)
			re->last = re->last + (m.sub[0].ep - text);
		return;
	}

	if (re->flags & JS_REGEXP_G)
		re->last = 0;

	js_pushnull(J);
}
"," void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)
 {
 	int i;
 	int opts;
 	Resub m;

	opts = 0;
	if (re->flags & JS_REGEXP_G) {
		if (re->last > strlen(text)) {
			re->last = 0;
			js_pushnull(J);
			return;
		}
		if (re->last > 0) {
			text += re->last;
			opts |= REG_NOTBOL;
 		}
 	}
 
	if (!js_regexec(re->prog, text, &m, opts)) {
 		js_newarray(J);
 		js_pushstring(J, text);
 		js_setproperty(J, -2, ""input"");
		js_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));
		js_setproperty(J, -2, ""index"");
		for (i = 0; i < m.nsub; ++i) {
			js_pushlstring(J, m.sub[i].sp, m.sub[i].ep - m.sub[i].sp);
			js_setindex(J, -2, i);
		}
		if (re->flags & JS_REGEXP_G)
			re->last = re->last + (m.sub[0].ep - text);
		return;
	}

	if (re->flags & JS_REGEXP_G)
		re->last = 0;

	js_pushnull(J);
}
",C,"	int result;
	result = js_regexec(re->prog, text, &m, opts);
	if (result < 0)
		js_error(J, ""regexec failed"");
	if (result == 0) {
","	if (!js_regexec(re->prog, text, &m, opts)) {
",,"@@ -29,6 +29,7 @@ void js_newregexp(js_State *J, const char *pattern, int flags)
 
 void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)
 {
+	int result;
 	int i;
 	int opts;
 	Resub m;
@@ -46,7 +47,10 @@ void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)
 		}
 	}
 
-	if (!js_regexec(re->prog, text, &m, opts)) {
+	result = js_regexec(re->prog, text, &m, opts);
+	if (result < 0)
+		js_error(J, ""regexec failed"");
+	if (result == 0) {
 		js_newarray(J);
 		js_pushstring(J, text);
 		js_setproperty(J, -2, ""input"");
@@ -71,6 +75,7 @@ static void Rp_test(js_State *J)
 {
 	js_Regexp *re;
 	const char *text;
+	int result;
 	int opts;
 	Resub m;
 
@@ -90,7 +95,10 @@ static void Rp_test(js_State *J)
 		}
 	}
 
-	if (!js_regexec(re->prog, text, &m, opts)) {
+	result = js_regexec(re->prog, text, &m, opts);
+	if (result < 0)
+		js_error(J, ""regexec failed"");
+	if (result == 0) {
 		if (re->flags & JS_REGEXP_G)
 			re->last = re->last + (m.sub[0].ep - text);
 		js_pushboolean(J, 1);",mujs,00d4606c3baf813b7b1c176823b2729bf51002a2,1e5479084bc9852854feb1ba9bf68b52cd127e02,1," void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)
 {
//fix_flaw_line_below:
//	int result;
 	int i;
 	int opts;
 	Resub m;

	opts = 0;
	if (re->flags & JS_REGEXP_G) {
		if (re->last > strlen(text)) {
			re->last = 0;
			js_pushnull(J);
			return;
		}
		if (re->last > 0) {
			text += re->last;
			opts |= REG_NOTBOL;
 		}
 	}
 
//flaw_line_below:
	if (!js_regexec(re->prog, text, &m, opts)) {
//fix_flaw_line_below:
//	result = js_regexec(re->prog, text, &m, opts);
//fix_flaw_line_below:
//	if (result < 0)
//fix_flaw_line_below:
//		js_error(J, ""regexec failed"");
//fix_flaw_line_below:
//	if (result == 0) {
 		js_newarray(J);
 		js_pushstring(J, text);
 		js_setproperty(J, -2, ""input"");
		js_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));
		js_setproperty(J, -2, ""index"");
		for (i = 0; i < m.nsub; ++i) {
			js_pushlstring(J, m.sub[i].sp, m.sub[i].ep - m.sub[i].sp);
			js_setindex(J, -2, i);
		}
		if (re->flags & JS_REGEXP_G)
			re->last = re->last + (m.sub[0].ep - text);
		return;
	}

	if (re->flags & JS_REGEXP_G)
		re->last = 0;

	js_pushnull(J);
}
"
5134,182870,,Remote,Not required,Partial,CVE-2019-11413,https://www.cvedetails.com/cve/CVE-2019-11413/,CWE-400,Low,,,,2019-04-22,5.0,An issue was discovered in Artifex MuJS 1.0.5. It has unlimited recursion because the match function in regexp.c lacks a depth check.,2019-04-30,,1,https://github.com/ccxvii/mujs/commit/00d4606c3baf813b7b1c176823b2729bf51002a2,00d4606c3baf813b7b1c176823b2729bf51002a2,"Bug 700937: Limit recursion in regexp matcher.

Also handle negative return code as an error in the JS bindings.",1,jsstring.c,"{""sha"": ""98b2a869c2cda0a0f19eb0a0ec41adfaaa90a3e0"", ""filename"": ""jsregexp.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 2, ""changes"": 12, ""blob_url"": ""https://github.com/ccxvii/mujs/blob/00d4606c3baf813b7b1c176823b2729bf51002a2/jsregexp.c"", ""raw_url"": ""https://github.com/ccxvii/mujs/raw/00d4606c3baf813b7b1c176823b2729bf51002a2/jsregexp.c"", ""contents_url"": ""https://api.github.com/repos/ccxvii/mujs/contents/jsregexp.c?ref=00d4606c3baf813b7b1c176823b2729bf51002a2"", ""patch"": ""@@ -29,6 +29,7 @@ void js_newregexp(js_State *J, const char *pattern, int flags)\n \n void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)\n {\n+\tint result;\n \tint i;\n \tint opts;\n \tResub m;\n@@ -46,7 +47,10 @@ void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)\n \t\t}\n \t}\n \n-\tif (!js_regexec(re->prog, text, &m, opts)) {\n+\tresult = js_regexec(re->prog, text, &m, opts);\n+\tif (result < 0)\n+\t\tjs_error(J, \""regexec failed\"");\n+\tif (result == 0) {\n \t\tjs_newarray(J);\n \t\tjs_pushstring(J, text);\n \t\tjs_setproperty(J, -2, \""input\"");\n@@ -71,6 +75,7 @@ static void Rp_test(js_State *J)\n {\n \tjs_Regexp *re;\n \tconst char *text;\n+\tint result;\n \tint opts;\n \tResub m;\n \n@@ -90,7 +95,10 @@ static void Rp_test(js_State *J)\n \t\t}\n \t}\n \n-\tif (!js_regexec(re->prog, text, &m, opts)) {\n+\tresult = js_regexec(re->prog, text, &m, opts);\n+\tif (result < 0)\n+\t\tjs_error(J, \""regexec failed\"");\n+\tif (result == 0) {\n \t\tif (re->flags & JS_REGEXP_G)\n \t\t\tre->last = re->last + (m.sub[0].ep - text);\n \t\tjs_pushboolean(J, 1);""}<_**next**_>{""sha"": ""29d2b8a56e95155a130c6eef25543fe0fb690ce8"", ""filename"": ""jsstring.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 6, ""changes"": 20, ""blob_url"": ""https://github.com/ccxvii/mujs/blob/00d4606c3baf813b7b1c176823b2729bf51002a2/jsstring.c"", ""raw_url"": ""https://github.com/ccxvii/mujs/raw/00d4606c3baf813b7b1c176823b2729bf51002a2/jsstring.c"", ""contents_url"": ""https://api.github.com/repos/ccxvii/mujs/contents/jsstring.c?ref=00d4606c3baf813b7b1c176823b2729bf51002a2"", ""patch"": ""@@ -4,6 +4,14 @@\n #include \""utf.h\""\n #include \""regexp.h\""\n \n+static int js_doregexec(js_State *J, Reprog *prog, const char *string, Resub *sub, int eflags)\n+{\n+\tint result = js_regexec(prog, string, sub, eflags);\n+\tif (result < 0)\n+\t\tjs_error(J, \""regexec failed\"");\n+\treturn result;\n+}\n+\n static const char *checkstring(js_State *J, int idx)\n {\n \tif (!js_iscoercible(J, idx))\n@@ -343,7 +351,7 @@ static void Sp_match(js_State *J)\n \ta = text;\n \te = text + strlen(text);\n \twhile (a <= e) {\n-\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n+\t\tif (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n \t\t\tbreak;\n \n \t\tb = m.sub[0].sp;\n@@ -380,7 +388,7 @@ static void Sp_search(js_State *J)\n \n \tre = js_toregexp(J, -1);\n \n-\tif (!js_regexec(re->prog, text, &m, 0))\n+\tif (!js_doregexec(J, re->prog, text, &m, 0))\n \t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n \telse\n \t\tjs_pushnumber(J, -1);\n@@ -397,7 +405,7 @@ static void Sp_replace_regexp(js_State *J)\n \tsource = checkstring(J, 0);\n \tre = js_toregexp(J, 1);\n \n-\tif (js_regexec(re->prog, source, &m, 0)) {\n+\tif (js_doregexec(J, re->prog, source, &m, 0)) {\n \t\tjs_copy(J, 0);\n \t\treturn;\n \t}\n@@ -471,7 +479,7 @@ static void Sp_replace_regexp(js_State *J)\n \t\t\telse\n \t\t\t\tgoto end;\n \t\t}\n-\t\tif (!js_regexec(re->prog, source, &m, REG_NOTBOL))\n+\t\tif (!js_doregexec(J, re->prog, source, &m, REG_NOTBOL))\n \t\t\tgoto loop;\n \t}\n \n@@ -576,7 +584,7 @@ static void Sp_split_regexp(js_State *J)\n \n \t/* splitting the empty string */\n \tif (e == text) {\n-\t\tif (js_regexec(re->prog, text, &m, 0)) {\n+\t\tif (js_doregexec(J, re->prog, text, &m, 0)) {\n \t\t\tif (len == limit) return;\n \t\t\tjs_pushliteral(J, \""\"");\n \t\t\tjs_setindex(J, -2, 0);\n@@ -586,7 +594,7 @@ static void Sp_split_regexp(js_State *J)\n \n \tp = a = text;\n \twhile (a < e) {\n-\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n+\t\tif (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n \t\t\tbreak; /* no match */\n \n \t\tb = m.sub[0].sp;""}<_**next**_>{""sha"": ""3f800e3bd275fd17ad95a9d5b82c5c1635f9c39d"", ""filename"": ""regexp.c"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 27, ""changes"": 69, ""blob_url"": ""https://github.com/ccxvii/mujs/blob/00d4606c3baf813b7b1c176823b2729bf51002a2/regexp.c"", ""raw_url"": ""https://github.com/ccxvii/mujs/raw/00d4606c3baf813b7b1c176823b2729bf51002a2/regexp.c"", ""contents_url"": ""https://api.github.com/repos/ccxvii/mujs/contents/regexp.c?ref=00d4606c3baf813b7b1c176823b2729bf51002a2"", ""patch"": ""@@ -16,6 +16,7 @@\n #define REPINF 255\n #define MAXSUB REG_MAXSUB\n #define MAXPROG (32 << 10)\n+#define MAXREC 1024\n \n typedef struct Reclass Reclass;\n typedef struct Renode Renode;\n@@ -967,98 +968,112 @@ static int strncmpcanon(const char *a, const char *b, int n)\n \treturn 0;\n }\n \n-static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *out)\n+static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *out, int depth)\n {\n \tResub scratch;\n+\tint result;\n \tint i;\n \tRune c;\n \n+\t/* stack overflow */\n+\tif (depth > MAXREC)\n+\t\treturn -1;\n+\n \tfor (;;) {\n \t\tswitch (pc->opcode) {\n \t\tcase I_END:\n-\t\t\treturn 1;\n+\t\t\treturn 0;\n \t\tcase I_JUMP:\n \t\t\tpc = pc->x;\n \t\t\tbreak;\n \t\tcase I_SPLIT:\n \t\t\tscratch = *out;\n-\t\t\tif (match(pc->x, sp, bol, flags, &scratch)) {\n+\t\t\tresult = match(pc->x, sp, bol, flags, &scratch, depth+1);\n+\t\t\tif (result == -1)\n+\t\t\t\treturn -1;\n+\t\t\tif (result == 0) {\n \t\t\t\t*out = scratch;\n-\t\t\t\treturn 1;\n+\t\t\t\treturn 0;\n \t\t\t}\n \t\t\tpc = pc->y;\n \t\t\tbreak;\n \n \t\tcase I_PLA:\n-\t\t\tif (!match(pc->x, sp, bol, flags, out))\n-\t\t\t\treturn 0;\n+\t\t\tresult = match(pc->x, sp, bol, flags, out, depth+1);\n+\t\t\tif (result == -1)\n+\t\t\t\treturn -1;\n+\t\t\tif (result == 1)\n+\t\t\t\treturn 1;\n \t\t\tpc = pc->y;\n \t\t\tbreak;\n \t\tcase I_NLA:\n \t\t\tscratch = *out;\n-\t\t\tif (match(pc->x, sp, bol, flags, &scratch))\n-\t\t\t\treturn 0;\n+\t\t\tresult = match(pc->x, sp, bol, flags, &scratch, depth+1);\n+\t\t\tif (result == -1)\n+\t\t\t\treturn -1;\n+\t\t\tif (result == 0)\n+\t\t\t\treturn 1;\n \t\t\tpc = pc->y;\n \t\t\tbreak;\n \n \t\tcase I_ANYNL:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_ANY:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (isnewline(c))\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_CHAR:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (flags & REG_ICASE)\n \t\t\t\tc = canon(c);\n \t\t\tif (c != pc->c)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_CCLASS:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (flags & REG_ICASE) {\n \t\t\t\tif (!incclasscanon(pc->cc, canon(c)))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t} else {\n \t\t\t\tif (!incclass(pc->cc, c))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t}\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_NCCLASS:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (flags & REG_ICASE) {\n \t\t\t\tif (incclasscanon(pc->cc, canon(c)))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t} else {\n \t\t\t\tif (incclass(pc->cc, c))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t}\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_REF:\n \t\t\ti = out->sub[pc->n].ep - out->sub[pc->n].sp;\n \t\t\tif (flags & REG_ICASE) {\n \t\t\t\tif (strncmpcanon(sp, out->sub[pc->n].sp, i))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t} else {\n \t\t\t\tif (strncmp(sp, out->sub[pc->n].sp, i))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t}\n \t\t\tif (i > 0)\n \t\t\t\tsp += i;\n@@ -1076,7 +1091,7 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n-\t\t\treturn 0;\n+\t\t\treturn 1;\n \t\tcase I_EOL:\n \t\t\tif (*sp == 0) {\n \t\t\t\tpc = pc + 1;\n@@ -1088,19 +1103,19 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n-\t\t\treturn 0;\n+\t\t\treturn 1;\n \t\tcase I_WORD:\n \t\t\ti = sp > bol && iswordchar(sp[-1]);\n \t\t\ti ^= iswordchar(sp[0]);\n \t\t\tif (!i)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_NWORD:\n \t\t\ti = sp > bol && iswordchar(sp[-1]);\n \t\t\ti ^= iswordchar(sp[0]);\n \t\t\tif (i)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \n@@ -1113,7 +1128,7 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tdefault:\n-\t\t\treturn 0;\n+\t\t\treturn 1;\n \t\t}\n \t}\n }\n@@ -1130,7 +1145,7 @@ int regexec(Reprog *prog, const char *sp, Resub *sub, int eflags)\n \tfor (i = 0; i < MAXSUB; ++i)\n \t\tsub->sub[i].sp = sub->sub[i].ep = NULL;\n \n-\treturn !match(prog->start, sp, sp, prog->flags | eflags, sub);\n+\treturn match(prog->start, sp, sp, prog->flags | eflags, sub, 0);\n }\n \n #ifdef TEST""}","static void Sp_match(js_State *J)
{
	js_Regexp *re;
	const char *text;
	int len;
	const char *a, *b, *c, *e;
	Resub m;

	text = checkstring(J, 0);

	if (js_isregexp(J, 1))
		js_copy(J, 1);
	else if (js_isundefined(J, 1))
		js_newregexp(J, """", 0);
	else
		js_newregexp(J, js_tostring(J, 1), 0);

	re = js_toregexp(J, -1);
	if (!(re->flags & JS_REGEXP_G)) {
		js_RegExp_prototype_exec(J, re, text);
		return;
	}

	re->last = 0;

	js_newarray(J);

	len = 0;
 	a = text;
 	e = text + strlen(text);
 	while (a <= e) {
		if (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))
 			break;
 
 		b = m.sub[0].sp;
		c = m.sub[0].ep;

		js_pushlstring(J, b, c - b);
		js_setindex(J, -2, len++);

		a = c;
		if (c - b == 0)
			++a;
	}

	if (len == 0) {
		js_pop(J, 1);
		js_pushnull(J);
	}
}
","static void Sp_match(js_State *J)
{
	js_Regexp *re;
	const char *text;
	int len;
	const char *a, *b, *c, *e;
	Resub m;

	text = checkstring(J, 0);

	if (js_isregexp(J, 1))
		js_copy(J, 1);
	else if (js_isundefined(J, 1))
		js_newregexp(J, """", 0);
	else
		js_newregexp(J, js_tostring(J, 1), 0);

	re = js_toregexp(J, -1);
	if (!(re->flags & JS_REGEXP_G)) {
		js_RegExp_prototype_exec(J, re, text);
		return;
	}

	re->last = 0;

	js_newarray(J);

	len = 0;
 	a = text;
 	e = text + strlen(text);
 	while (a <= e) {
		if (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))
 			break;
 
 		b = m.sub[0].sp;
		c = m.sub[0].ep;

		js_pushlstring(J, b, c - b);
		js_setindex(J, -2, len++);

		a = c;
		if (c - b == 0)
			++a;
	}

	if (len == 0) {
		js_pop(J, 1);
		js_pushnull(J);
	}
}
",C,"		if (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))
","		if (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))
",,"@@ -4,6 +4,14 @@
 #include ""utf.h""
 #include ""regexp.h""
 
+static int js_doregexec(js_State *J, Reprog *prog, const char *string, Resub *sub, int eflags)
+{
+	int result = js_regexec(prog, string, sub, eflags);
+	if (result < 0)
+		js_error(J, ""regexec failed"");
+	return result;
+}
+
 static const char *checkstring(js_State *J, int idx)
 {
 	if (!js_iscoercible(J, idx))
@@ -343,7 +351,7 @@ static void Sp_match(js_State *J)
 	a = text;
 	e = text + strlen(text);
 	while (a <= e) {
-		if (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))
+		if (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))
 			break;
 
 		b = m.sub[0].sp;
@@ -380,7 +388,7 @@ static void Sp_search(js_State *J)
 
 	re = js_toregexp(J, -1);
 
-	if (!js_regexec(re->prog, text, &m, 0))
+	if (!js_doregexec(J, re->prog, text, &m, 0))
 		js_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));
 	else
 		js_pushnumber(J, -1);
@@ -397,7 +405,7 @@ static void Sp_replace_regexp(js_State *J)
 	source = checkstring(J, 0);
 	re = js_toregexp(J, 1);
 
-	if (js_regexec(re->prog, source, &m, 0)) {
+	if (js_doregexec(J, re->prog, source, &m, 0)) {
 		js_copy(J, 0);
 		return;
 	}
@@ -471,7 +479,7 @@ static void Sp_replace_regexp(js_State *J)
 			else
 				goto end;
 		}
-		if (!js_regexec(re->prog, source, &m, REG_NOTBOL))
+		if (!js_doregexec(J, re->prog, source, &m, REG_NOTBOL))
 			goto loop;
 	}
 
@@ -576,7 +584,7 @@ static void Sp_split_regexp(js_State *J)
 
 	/* splitting the empty string */
 	if (e == text) {
-		if (js_regexec(re->prog, text, &m, 0)) {
+		if (js_doregexec(J, re->prog, text, &m, 0)) {
 			if (len == limit) return;
 			js_pushliteral(J, """");
 			js_setindex(J, -2, 0);
@@ -586,7 +594,7 @@ static void Sp_split_regexp(js_State *J)
 
 	p = a = text;
 	while (a < e) {
-		if (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))
+		if (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))
 			break; /* no match */
 
 		b = m.sub[0].sp;",mujs,00d4606c3baf813b7b1c176823b2729bf51002a2,1e5479084bc9852854feb1ba9bf68b52cd127e02,1,"static void Sp_match(js_State *J)
{
	js_Regexp *re;
	const char *text;
	int len;
	const char *a, *b, *c, *e;
	Resub m;

	text = checkstring(J, 0);

	if (js_isregexp(J, 1))
		js_copy(J, 1);
	else if (js_isundefined(J, 1))
		js_newregexp(J, """", 0);
	else
		js_newregexp(J, js_tostring(J, 1), 0);

	re = js_toregexp(J, -1);
	if (!(re->flags & JS_REGEXP_G)) {
		js_RegExp_prototype_exec(J, re, text);
		return;
	}

	re->last = 0;

	js_newarray(J);

	len = 0;
 	a = text;
 	e = text + strlen(text);
 	while (a <= e) {
//flaw_line_below:
		if (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))
//fix_flaw_line_below:
//		if (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))
 			break;
 
 		b = m.sub[0].sp;
		c = m.sub[0].ep;

		js_pushlstring(J, b, c - b);
		js_setindex(J, -2, len++);

		a = c;
		if (c - b == 0)
			++a;
	}

	if (len == 0) {
		js_pop(J, 1);
		js_pushnull(J);
	}
}
"
5135,182871,,Remote,Not required,Partial,CVE-2019-11413,https://www.cvedetails.com/cve/CVE-2019-11413/,CWE-400,Low,,,,2019-04-22,5.0,An issue was discovered in Artifex MuJS 1.0.5. It has unlimited recursion because the match function in regexp.c lacks a depth check.,2019-04-30,,2,https://github.com/ccxvii/mujs/commit/00d4606c3baf813b7b1c176823b2729bf51002a2,00d4606c3baf813b7b1c176823b2729bf51002a2,"Bug 700937: Limit recursion in regexp matcher.

Also handle negative return code as an error in the JS bindings.",2,jsstring.c,"{""sha"": ""98b2a869c2cda0a0f19eb0a0ec41adfaaa90a3e0"", ""filename"": ""jsregexp.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 2, ""changes"": 12, ""blob_url"": ""https://github.com/ccxvii/mujs/blob/00d4606c3baf813b7b1c176823b2729bf51002a2/jsregexp.c"", ""raw_url"": ""https://github.com/ccxvii/mujs/raw/00d4606c3baf813b7b1c176823b2729bf51002a2/jsregexp.c"", ""contents_url"": ""https://api.github.com/repos/ccxvii/mujs/contents/jsregexp.c?ref=00d4606c3baf813b7b1c176823b2729bf51002a2"", ""patch"": ""@@ -29,6 +29,7 @@ void js_newregexp(js_State *J, const char *pattern, int flags)\n \n void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)\n {\n+\tint result;\n \tint i;\n \tint opts;\n \tResub m;\n@@ -46,7 +47,10 @@ void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)\n \t\t}\n \t}\n \n-\tif (!js_regexec(re->prog, text, &m, opts)) {\n+\tresult = js_regexec(re->prog, text, &m, opts);\n+\tif (result < 0)\n+\t\tjs_error(J, \""regexec failed\"");\n+\tif (result == 0) {\n \t\tjs_newarray(J);\n \t\tjs_pushstring(J, text);\n \t\tjs_setproperty(J, -2, \""input\"");\n@@ -71,6 +75,7 @@ static void Rp_test(js_State *J)\n {\n \tjs_Regexp *re;\n \tconst char *text;\n+\tint result;\n \tint opts;\n \tResub m;\n \n@@ -90,7 +95,10 @@ static void Rp_test(js_State *J)\n \t\t}\n \t}\n \n-\tif (!js_regexec(re->prog, text, &m, opts)) {\n+\tresult = js_regexec(re->prog, text, &m, opts);\n+\tif (result < 0)\n+\t\tjs_error(J, \""regexec failed\"");\n+\tif (result == 0) {\n \t\tif (re->flags & JS_REGEXP_G)\n \t\t\tre->last = re->last + (m.sub[0].ep - text);\n \t\tjs_pushboolean(J, 1);""}<_**next**_>{""sha"": ""29d2b8a56e95155a130c6eef25543fe0fb690ce8"", ""filename"": ""jsstring.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 6, ""changes"": 20, ""blob_url"": ""https://github.com/ccxvii/mujs/blob/00d4606c3baf813b7b1c176823b2729bf51002a2/jsstring.c"", ""raw_url"": ""https://github.com/ccxvii/mujs/raw/00d4606c3baf813b7b1c176823b2729bf51002a2/jsstring.c"", ""contents_url"": ""https://api.github.com/repos/ccxvii/mujs/contents/jsstring.c?ref=00d4606c3baf813b7b1c176823b2729bf51002a2"", ""patch"": ""@@ -4,6 +4,14 @@\n #include \""utf.h\""\n #include \""regexp.h\""\n \n+static int js_doregexec(js_State *J, Reprog *prog, const char *string, Resub *sub, int eflags)\n+{\n+\tint result = js_regexec(prog, string, sub, eflags);\n+\tif (result < 0)\n+\t\tjs_error(J, \""regexec failed\"");\n+\treturn result;\n+}\n+\n static const char *checkstring(js_State *J, int idx)\n {\n \tif (!js_iscoercible(J, idx))\n@@ -343,7 +351,7 @@ static void Sp_match(js_State *J)\n \ta = text;\n \te = text + strlen(text);\n \twhile (a <= e) {\n-\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n+\t\tif (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n \t\t\tbreak;\n \n \t\tb = m.sub[0].sp;\n@@ -380,7 +388,7 @@ static void Sp_search(js_State *J)\n \n \tre = js_toregexp(J, -1);\n \n-\tif (!js_regexec(re->prog, text, &m, 0))\n+\tif (!js_doregexec(J, re->prog, text, &m, 0))\n \t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n \telse\n \t\tjs_pushnumber(J, -1);\n@@ -397,7 +405,7 @@ static void Sp_replace_regexp(js_State *J)\n \tsource = checkstring(J, 0);\n \tre = js_toregexp(J, 1);\n \n-\tif (js_regexec(re->prog, source, &m, 0)) {\n+\tif (js_doregexec(J, re->prog, source, &m, 0)) {\n \t\tjs_copy(J, 0);\n \t\treturn;\n \t}\n@@ -471,7 +479,7 @@ static void Sp_replace_regexp(js_State *J)\n \t\t\telse\n \t\t\t\tgoto end;\n \t\t}\n-\t\tif (!js_regexec(re->prog, source, &m, REG_NOTBOL))\n+\t\tif (!js_doregexec(J, re->prog, source, &m, REG_NOTBOL))\n \t\t\tgoto loop;\n \t}\n \n@@ -576,7 +584,7 @@ static void Sp_split_regexp(js_State *J)\n \n \t/* splitting the empty string */\n \tif (e == text) {\n-\t\tif (js_regexec(re->prog, text, &m, 0)) {\n+\t\tif (js_doregexec(J, re->prog, text, &m, 0)) {\n \t\t\tif (len == limit) return;\n \t\t\tjs_pushliteral(J, \""\"");\n \t\t\tjs_setindex(J, -2, 0);\n@@ -586,7 +594,7 @@ static void Sp_split_regexp(js_State *J)\n \n \tp = a = text;\n \twhile (a < e) {\n-\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n+\t\tif (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n \t\t\tbreak; /* no match */\n \n \t\tb = m.sub[0].sp;""}<_**next**_>{""sha"": ""3f800e3bd275fd17ad95a9d5b82c5c1635f9c39d"", ""filename"": ""regexp.c"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 27, ""changes"": 69, ""blob_url"": ""https://github.com/ccxvii/mujs/blob/00d4606c3baf813b7b1c176823b2729bf51002a2/regexp.c"", ""raw_url"": ""https://github.com/ccxvii/mujs/raw/00d4606c3baf813b7b1c176823b2729bf51002a2/regexp.c"", ""contents_url"": ""https://api.github.com/repos/ccxvii/mujs/contents/regexp.c?ref=00d4606c3baf813b7b1c176823b2729bf51002a2"", ""patch"": ""@@ -16,6 +16,7 @@\n #define REPINF 255\n #define MAXSUB REG_MAXSUB\n #define MAXPROG (32 << 10)\n+#define MAXREC 1024\n \n typedef struct Reclass Reclass;\n typedef struct Renode Renode;\n@@ -967,98 +968,112 @@ static int strncmpcanon(const char *a, const char *b, int n)\n \treturn 0;\n }\n \n-static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *out)\n+static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *out, int depth)\n {\n \tResub scratch;\n+\tint result;\n \tint i;\n \tRune c;\n \n+\t/* stack overflow */\n+\tif (depth > MAXREC)\n+\t\treturn -1;\n+\n \tfor (;;) {\n \t\tswitch (pc->opcode) {\n \t\tcase I_END:\n-\t\t\treturn 1;\n+\t\t\treturn 0;\n \t\tcase I_JUMP:\n \t\t\tpc = pc->x;\n \t\t\tbreak;\n \t\tcase I_SPLIT:\n \t\t\tscratch = *out;\n-\t\t\tif (match(pc->x, sp, bol, flags, &scratch)) {\n+\t\t\tresult = match(pc->x, sp, bol, flags, &scratch, depth+1);\n+\t\t\tif (result == -1)\n+\t\t\t\treturn -1;\n+\t\t\tif (result == 0) {\n \t\t\t\t*out = scratch;\n-\t\t\t\treturn 1;\n+\t\t\t\treturn 0;\n \t\t\t}\n \t\t\tpc = pc->y;\n \t\t\tbreak;\n \n \t\tcase I_PLA:\n-\t\t\tif (!match(pc->x, sp, bol, flags, out))\n-\t\t\t\treturn 0;\n+\t\t\tresult = match(pc->x, sp, bol, flags, out, depth+1);\n+\t\t\tif (result == -1)\n+\t\t\t\treturn -1;\n+\t\t\tif (result == 1)\n+\t\t\t\treturn 1;\n \t\t\tpc = pc->y;\n \t\t\tbreak;\n \t\tcase I_NLA:\n \t\t\tscratch = *out;\n-\t\t\tif (match(pc->x, sp, bol, flags, &scratch))\n-\t\t\t\treturn 0;\n+\t\t\tresult = match(pc->x, sp, bol, flags, &scratch, depth+1);\n+\t\t\tif (result == -1)\n+\t\t\t\treturn -1;\n+\t\t\tif (result == 0)\n+\t\t\t\treturn 1;\n \t\t\tpc = pc->y;\n \t\t\tbreak;\n \n \t\tcase I_ANYNL:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_ANY:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (isnewline(c))\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_CHAR:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (flags & REG_ICASE)\n \t\t\t\tc = canon(c);\n \t\t\tif (c != pc->c)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_CCLASS:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (flags & REG_ICASE) {\n \t\t\t\tif (!incclasscanon(pc->cc, canon(c)))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t} else {\n \t\t\t\tif (!incclass(pc->cc, c))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t}\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_NCCLASS:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (flags & REG_ICASE) {\n \t\t\t\tif (incclasscanon(pc->cc, canon(c)))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t} else {\n \t\t\t\tif (incclass(pc->cc, c))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t}\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_REF:\n \t\t\ti = out->sub[pc->n].ep - out->sub[pc->n].sp;\n \t\t\tif (flags & REG_ICASE) {\n \t\t\t\tif (strncmpcanon(sp, out->sub[pc->n].sp, i))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t} else {\n \t\t\t\tif (strncmp(sp, out->sub[pc->n].sp, i))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t}\n \t\t\tif (i > 0)\n \t\t\t\tsp += i;\n@@ -1076,7 +1091,7 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n-\t\t\treturn 0;\n+\t\t\treturn 1;\n \t\tcase I_EOL:\n \t\t\tif (*sp == 0) {\n \t\t\t\tpc = pc + 1;\n@@ -1088,19 +1103,19 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n-\t\t\treturn 0;\n+\t\t\treturn 1;\n \t\tcase I_WORD:\n \t\t\ti = sp > bol && iswordchar(sp[-1]);\n \t\t\ti ^= iswordchar(sp[0]);\n \t\t\tif (!i)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_NWORD:\n \t\t\ti = sp > bol && iswordchar(sp[-1]);\n \t\t\ti ^= iswordchar(sp[0]);\n \t\t\tif (i)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \n@@ -1113,7 +1128,7 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tdefault:\n-\t\t\treturn 0;\n+\t\t\treturn 1;\n \t\t}\n \t}\n }\n@@ -1130,7 +1145,7 @@ int regexec(Reprog *prog, const char *sp, Resub *sub, int eflags)\n \tfor (i = 0; i < MAXSUB; ++i)\n \t\tsub->sub[i].sp = sub->sub[i].ep = NULL;\n \n-\treturn !match(prog->start, sp, sp, prog->flags | eflags, sub);\n+\treturn match(prog->start, sp, sp, prog->flags | eflags, sub, 0);\n }\n \n #ifdef TEST""}","static void Sp_replace_regexp(js_State *J)
{
	js_Regexp *re;
	const char *source, *s, *r;
	js_Buffer *sb = NULL;
	int n, x;
	Resub m;

 	source = checkstring(J, 0);
 	re = js_toregexp(J, 1);
 
	if (js_doregexec(J, re->prog, source, &m, 0)) {
 		js_copy(J, 0);
 		return;
 	}

	re->last = 0;

loop:
	s = m.sub[0].sp;
	n = m.sub[0].ep - m.sub[0].sp;

	if (js_iscallable(J, 2)) {
		js_copy(J, 2);
		js_pushundefined(J);
		for (x = 0; m.sub[x].sp; ++x) /* arg 0..x: substring and subexps that matched */
			js_pushlstring(J, m.sub[x].sp, m.sub[x].ep - m.sub[x].sp);
		js_pushnumber(J, s - source); /* arg x+2: offset within search string */
		js_copy(J, 0); /* arg x+3: search string */
		js_call(J, 2 + x);
		r = js_tostring(J, -1);
		js_putm(J, &sb, source, s);
		js_puts(J, &sb, r);
		js_pop(J, 1);
	} else {
		r = js_tostring(J, 2);
		js_putm(J, &sb, source, s);
		while (*r) {
			if (*r == '$') {
				switch (*(++r)) {
				case 0: --r; /* end of string; back up */
				/* fallthrough */
				case '$': js_putc(J, &sb, '$'); break;
				case '`': js_putm(J, &sb, source, s); break;
				case '\'': js_puts(J, &sb, s + n); break;
				case '&':
					js_putm(J, &sb, s, s + n);
					break;
				case '0': case '1': case '2': case '3': case '4':
				case '5': case '6': case '7': case '8': case '9':
					x = *r - '0';
					if (r[1] >= '0' && r[1] <= '9')
						x = x * 10 + *(++r) - '0';
					if (x > 0 && x < m.nsub) {
						js_putm(J, &sb, m.sub[x].sp, m.sub[x].ep);
					} else {
						js_putc(J, &sb, '$');
						if (x > 10) {
							js_putc(J, &sb, '0' + x / 10);
							js_putc(J, &sb, '0' + x % 10);
						} else {
							js_putc(J, &sb, '0' + x);
						}
					}
					break;
				default:
					js_putc(J, &sb, '$');
					js_putc(J, &sb, *r);
					break;
				}
				++r;
			} else {
				js_putc(J, &sb, *r++);
			}
		}
	}

	if (re->flags & JS_REGEXP_G) {
		source = m.sub[0].ep;
		if (n == 0) {
			if (*source)
				js_putc(J, &sb, *source++);
 			else
 				goto end;
 		}
		if (!js_doregexec(J, re->prog, source, &m, REG_NOTBOL))
 			goto loop;
 	}
 
end:
	js_puts(J, &sb, s + n);
	js_putc(J, &sb, 0);

	if (js_try(J)) {
		js_free(J, sb);
		js_throw(J);
	}
	js_pushstring(J, sb ? sb->s : """");
	js_endtry(J);
	js_free(J, sb);
}
","static void Sp_replace_regexp(js_State *J)
{
	js_Regexp *re;
	const char *source, *s, *r;
	js_Buffer *sb = NULL;
	int n, x;
	Resub m;

 	source = checkstring(J, 0);
 	re = js_toregexp(J, 1);
 
	if (js_regexec(re->prog, source, &m, 0)) {
 		js_copy(J, 0);
 		return;
 	}

	re->last = 0;

loop:
	s = m.sub[0].sp;
	n = m.sub[0].ep - m.sub[0].sp;

	if (js_iscallable(J, 2)) {
		js_copy(J, 2);
		js_pushundefined(J);
		for (x = 0; m.sub[x].sp; ++x) /* arg 0..x: substring and subexps that matched */
			js_pushlstring(J, m.sub[x].sp, m.sub[x].ep - m.sub[x].sp);
		js_pushnumber(J, s - source); /* arg x+2: offset within search string */
		js_copy(J, 0); /* arg x+3: search string */
		js_call(J, 2 + x);
		r = js_tostring(J, -1);
		js_putm(J, &sb, source, s);
		js_puts(J, &sb, r);
		js_pop(J, 1);
	} else {
		r = js_tostring(J, 2);
		js_putm(J, &sb, source, s);
		while (*r) {
			if (*r == '$') {
				switch (*(++r)) {
				case 0: --r; /* end of string; back up */
				/* fallthrough */
				case '$': js_putc(J, &sb, '$'); break;
				case '`': js_putm(J, &sb, source, s); break;
				case '\'': js_puts(J, &sb, s + n); break;
				case '&':
					js_putm(J, &sb, s, s + n);
					break;
				case '0': case '1': case '2': case '3': case '4':
				case '5': case '6': case '7': case '8': case '9':
					x = *r - '0';
					if (r[1] >= '0' && r[1] <= '9')
						x = x * 10 + *(++r) - '0';
					if (x > 0 && x < m.nsub) {
						js_putm(J, &sb, m.sub[x].sp, m.sub[x].ep);
					} else {
						js_putc(J, &sb, '$');
						if (x > 10) {
							js_putc(J, &sb, '0' + x / 10);
							js_putc(J, &sb, '0' + x % 10);
						} else {
							js_putc(J, &sb, '0' + x);
						}
					}
					break;
				default:
					js_putc(J, &sb, '$');
					js_putc(J, &sb, *r);
					break;
				}
				++r;
			} else {
				js_putc(J, &sb, *r++);
			}
		}
	}

	if (re->flags & JS_REGEXP_G) {
		source = m.sub[0].ep;
		if (n == 0) {
			if (*source)
				js_putc(J, &sb, *source++);
 			else
 				goto end;
 		}
		if (!js_regexec(re->prog, source, &m, REG_NOTBOL))
 			goto loop;
 	}
 
end:
	js_puts(J, &sb, s + n);
	js_putc(J, &sb, 0);

	if (js_try(J)) {
		js_free(J, sb);
		js_throw(J);
	}
	js_pushstring(J, sb ? sb->s : """");
	js_endtry(J);
	js_free(J, sb);
}
",C,"	if (js_doregexec(J, re->prog, source, &m, 0)) {
		if (!js_doregexec(J, re->prog, source, &m, REG_NOTBOL))
","	if (js_regexec(re->prog, source, &m, 0)) {
		if (!js_regexec(re->prog, source, &m, REG_NOTBOL))
",,"@@ -4,6 +4,14 @@
 #include ""utf.h""
 #include ""regexp.h""
 
+static int js_doregexec(js_State *J, Reprog *prog, const char *string, Resub *sub, int eflags)
+{
+	int result = js_regexec(prog, string, sub, eflags);
+	if (result < 0)
+		js_error(J, ""regexec failed"");
+	return result;
+}
+
 static const char *checkstring(js_State *J, int idx)
 {
 	if (!js_iscoercible(J, idx))
@@ -343,7 +351,7 @@ static void Sp_match(js_State *J)
 	a = text;
 	e = text + strlen(text);
 	while (a <= e) {
-		if (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))
+		if (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))
 			break;
 
 		b = m.sub[0].sp;
@@ -380,7 +388,7 @@ static void Sp_search(js_State *J)
 
 	re = js_toregexp(J, -1);
 
-	if (!js_regexec(re->prog, text, &m, 0))
+	if (!js_doregexec(J, re->prog, text, &m, 0))
 		js_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));
 	else
 		js_pushnumber(J, -1);
@@ -397,7 +405,7 @@ static void Sp_replace_regexp(js_State *J)
 	source = checkstring(J, 0);
 	re = js_toregexp(J, 1);
 
-	if (js_regexec(re->prog, source, &m, 0)) {
+	if (js_doregexec(J, re->prog, source, &m, 0)) {
 		js_copy(J, 0);
 		return;
 	}
@@ -471,7 +479,7 @@ static void Sp_replace_regexp(js_State *J)
 			else
 				goto end;
 		}
-		if (!js_regexec(re->prog, source, &m, REG_NOTBOL))
+		if (!js_doregexec(J, re->prog, source, &m, REG_NOTBOL))
 			goto loop;
 	}
 
@@ -576,7 +584,7 @@ static void Sp_split_regexp(js_State *J)
 
 	/* splitting the empty string */
 	if (e == text) {
-		if (js_regexec(re->prog, text, &m, 0)) {
+		if (js_doregexec(J, re->prog, text, &m, 0)) {
 			if (len == limit) return;
 			js_pushliteral(J, """");
 			js_setindex(J, -2, 0);
@@ -586,7 +594,7 @@ static void Sp_split_regexp(js_State *J)
 
 	p = a = text;
 	while (a < e) {
-		if (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))
+		if (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))
 			break; /* no match */
 
 		b = m.sub[0].sp;",mujs,00d4606c3baf813b7b1c176823b2729bf51002a2,1e5479084bc9852854feb1ba9bf68b52cd127e02,1,"static void Sp_replace_regexp(js_State *J)
{
	js_Regexp *re;
	const char *source, *s, *r;
	js_Buffer *sb = NULL;
	int n, x;
	Resub m;

 	source = checkstring(J, 0);
 	re = js_toregexp(J, 1);
 
//flaw_line_below:
	if (js_regexec(re->prog, source, &m, 0)) {
//fix_flaw_line_below:
//	if (js_doregexec(J, re->prog, source, &m, 0)) {
 		js_copy(J, 0);
 		return;
 	}

	re->last = 0;

loop:
	s = m.sub[0].sp;
	n = m.sub[0].ep - m.sub[0].sp;

	if (js_iscallable(J, 2)) {
		js_copy(J, 2);
		js_pushundefined(J);
		for (x = 0; m.sub[x].sp; ++x) /* arg 0..x: substring and subexps that matched */
			js_pushlstring(J, m.sub[x].sp, m.sub[x].ep - m.sub[x].sp);
		js_pushnumber(J, s - source); /* arg x+2: offset within search string */
		js_copy(J, 0); /* arg x+3: search string */
		js_call(J, 2 + x);
		r = js_tostring(J, -1);
		js_putm(J, &sb, source, s);
		js_puts(J, &sb, r);
		js_pop(J, 1);
	} else {
		r = js_tostring(J, 2);
		js_putm(J, &sb, source, s);
		while (*r) {
			if (*r == '$') {
				switch (*(++r)) {
				case 0: --r; /* end of string; back up */
				/* fallthrough */
				case '$': js_putc(J, &sb, '$'); break;
				case '`': js_putm(J, &sb, source, s); break;
				case '\'': js_puts(J, &sb, s + n); break;
				case '&':
					js_putm(J, &sb, s, s + n);
					break;
				case '0': case '1': case '2': case '3': case '4':
				case '5': case '6': case '7': case '8': case '9':
					x = *r - '0';
					if (r[1] >= '0' && r[1] <= '9')
						x = x * 10 + *(++r) - '0';
					if (x > 0 && x < m.nsub) {
						js_putm(J, &sb, m.sub[x].sp, m.sub[x].ep);
					} else {
						js_putc(J, &sb, '$');
						if (x > 10) {
							js_putc(J, &sb, '0' + x / 10);
							js_putc(J, &sb, '0' + x % 10);
						} else {
							js_putc(J, &sb, '0' + x);
						}
					}
					break;
				default:
					js_putc(J, &sb, '$');
					js_putc(J, &sb, *r);
					break;
				}
				++r;
			} else {
				js_putc(J, &sb, *r++);
			}
		}
	}

	if (re->flags & JS_REGEXP_G) {
		source = m.sub[0].ep;
		if (n == 0) {
			if (*source)
				js_putc(J, &sb, *source++);
 			else
 				goto end;
 		}
//flaw_line_below:
		if (!js_regexec(re->prog, source, &m, REG_NOTBOL))
//fix_flaw_line_below:
//		if (!js_doregexec(J, re->prog, source, &m, REG_NOTBOL))
 			goto loop;
 	}
 
end:
	js_puts(J, &sb, s + n);
	js_putc(J, &sb, 0);

	if (js_try(J)) {
		js_free(J, sb);
		js_throw(J);
	}
	js_pushstring(J, sb ? sb->s : """");
	js_endtry(J);
	js_free(J, sb);
}
"
5136,182872,,Remote,Not required,Partial,CVE-2019-11413,https://www.cvedetails.com/cve/CVE-2019-11413/,CWE-400,Low,,,,2019-04-22,5.0,An issue was discovered in Artifex MuJS 1.0.5. It has unlimited recursion because the match function in regexp.c lacks a depth check.,2019-04-30,,1,https://github.com/ccxvii/mujs/commit/00d4606c3baf813b7b1c176823b2729bf51002a2,00d4606c3baf813b7b1c176823b2729bf51002a2,"Bug 700937: Limit recursion in regexp matcher.

Also handle negative return code as an error in the JS bindings.",1,jsstring.c,"{""sha"": ""98b2a869c2cda0a0f19eb0a0ec41adfaaa90a3e0"", ""filename"": ""jsregexp.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 2, ""changes"": 12, ""blob_url"": ""https://github.com/ccxvii/mujs/blob/00d4606c3baf813b7b1c176823b2729bf51002a2/jsregexp.c"", ""raw_url"": ""https://github.com/ccxvii/mujs/raw/00d4606c3baf813b7b1c176823b2729bf51002a2/jsregexp.c"", ""contents_url"": ""https://api.github.com/repos/ccxvii/mujs/contents/jsregexp.c?ref=00d4606c3baf813b7b1c176823b2729bf51002a2"", ""patch"": ""@@ -29,6 +29,7 @@ void js_newregexp(js_State *J, const char *pattern, int flags)\n \n void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)\n {\n+\tint result;\n \tint i;\n \tint opts;\n \tResub m;\n@@ -46,7 +47,10 @@ void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)\n \t\t}\n \t}\n \n-\tif (!js_regexec(re->prog, text, &m, opts)) {\n+\tresult = js_regexec(re->prog, text, &m, opts);\n+\tif (result < 0)\n+\t\tjs_error(J, \""regexec failed\"");\n+\tif (result == 0) {\n \t\tjs_newarray(J);\n \t\tjs_pushstring(J, text);\n \t\tjs_setproperty(J, -2, \""input\"");\n@@ -71,6 +75,7 @@ static void Rp_test(js_State *J)\n {\n \tjs_Regexp *re;\n \tconst char *text;\n+\tint result;\n \tint opts;\n \tResub m;\n \n@@ -90,7 +95,10 @@ static void Rp_test(js_State *J)\n \t\t}\n \t}\n \n-\tif (!js_regexec(re->prog, text, &m, opts)) {\n+\tresult = js_regexec(re->prog, text, &m, opts);\n+\tif (result < 0)\n+\t\tjs_error(J, \""regexec failed\"");\n+\tif (result == 0) {\n \t\tif (re->flags & JS_REGEXP_G)\n \t\t\tre->last = re->last + (m.sub[0].ep - text);\n \t\tjs_pushboolean(J, 1);""}<_**next**_>{""sha"": ""29d2b8a56e95155a130c6eef25543fe0fb690ce8"", ""filename"": ""jsstring.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 6, ""changes"": 20, ""blob_url"": ""https://github.com/ccxvii/mujs/blob/00d4606c3baf813b7b1c176823b2729bf51002a2/jsstring.c"", ""raw_url"": ""https://github.com/ccxvii/mujs/raw/00d4606c3baf813b7b1c176823b2729bf51002a2/jsstring.c"", ""contents_url"": ""https://api.github.com/repos/ccxvii/mujs/contents/jsstring.c?ref=00d4606c3baf813b7b1c176823b2729bf51002a2"", ""patch"": ""@@ -4,6 +4,14 @@\n #include \""utf.h\""\n #include \""regexp.h\""\n \n+static int js_doregexec(js_State *J, Reprog *prog, const char *string, Resub *sub, int eflags)\n+{\n+\tint result = js_regexec(prog, string, sub, eflags);\n+\tif (result < 0)\n+\t\tjs_error(J, \""regexec failed\"");\n+\treturn result;\n+}\n+\n static const char *checkstring(js_State *J, int idx)\n {\n \tif (!js_iscoercible(J, idx))\n@@ -343,7 +351,7 @@ static void Sp_match(js_State *J)\n \ta = text;\n \te = text + strlen(text);\n \twhile (a <= e) {\n-\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n+\t\tif (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n \t\t\tbreak;\n \n \t\tb = m.sub[0].sp;\n@@ -380,7 +388,7 @@ static void Sp_search(js_State *J)\n \n \tre = js_toregexp(J, -1);\n \n-\tif (!js_regexec(re->prog, text, &m, 0))\n+\tif (!js_doregexec(J, re->prog, text, &m, 0))\n \t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n \telse\n \t\tjs_pushnumber(J, -1);\n@@ -397,7 +405,7 @@ static void Sp_replace_regexp(js_State *J)\n \tsource = checkstring(J, 0);\n \tre = js_toregexp(J, 1);\n \n-\tif (js_regexec(re->prog, source, &m, 0)) {\n+\tif (js_doregexec(J, re->prog, source, &m, 0)) {\n \t\tjs_copy(J, 0);\n \t\treturn;\n \t}\n@@ -471,7 +479,7 @@ static void Sp_replace_regexp(js_State *J)\n \t\t\telse\n \t\t\t\tgoto end;\n \t\t}\n-\t\tif (!js_regexec(re->prog, source, &m, REG_NOTBOL))\n+\t\tif (!js_doregexec(J, re->prog, source, &m, REG_NOTBOL))\n \t\t\tgoto loop;\n \t}\n \n@@ -576,7 +584,7 @@ static void Sp_split_regexp(js_State *J)\n \n \t/* splitting the empty string */\n \tif (e == text) {\n-\t\tif (js_regexec(re->prog, text, &m, 0)) {\n+\t\tif (js_doregexec(J, re->prog, text, &m, 0)) {\n \t\t\tif (len == limit) return;\n \t\t\tjs_pushliteral(J, \""\"");\n \t\t\tjs_setindex(J, -2, 0);\n@@ -586,7 +594,7 @@ static void Sp_split_regexp(js_State *J)\n \n \tp = a = text;\n \twhile (a < e) {\n-\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n+\t\tif (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n \t\t\tbreak; /* no match */\n \n \t\tb = m.sub[0].sp;""}<_**next**_>{""sha"": ""3f800e3bd275fd17ad95a9d5b82c5c1635f9c39d"", ""filename"": ""regexp.c"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 27, ""changes"": 69, ""blob_url"": ""https://github.com/ccxvii/mujs/blob/00d4606c3baf813b7b1c176823b2729bf51002a2/regexp.c"", ""raw_url"": ""https://github.com/ccxvii/mujs/raw/00d4606c3baf813b7b1c176823b2729bf51002a2/regexp.c"", ""contents_url"": ""https://api.github.com/repos/ccxvii/mujs/contents/regexp.c?ref=00d4606c3baf813b7b1c176823b2729bf51002a2"", ""patch"": ""@@ -16,6 +16,7 @@\n #define REPINF 255\n #define MAXSUB REG_MAXSUB\n #define MAXPROG (32 << 10)\n+#define MAXREC 1024\n \n typedef struct Reclass Reclass;\n typedef struct Renode Renode;\n@@ -967,98 +968,112 @@ static int strncmpcanon(const char *a, const char *b, int n)\n \treturn 0;\n }\n \n-static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *out)\n+static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *out, int depth)\n {\n \tResub scratch;\n+\tint result;\n \tint i;\n \tRune c;\n \n+\t/* stack overflow */\n+\tif (depth > MAXREC)\n+\t\treturn -1;\n+\n \tfor (;;) {\n \t\tswitch (pc->opcode) {\n \t\tcase I_END:\n-\t\t\treturn 1;\n+\t\t\treturn 0;\n \t\tcase I_JUMP:\n \t\t\tpc = pc->x;\n \t\t\tbreak;\n \t\tcase I_SPLIT:\n \t\t\tscratch = *out;\n-\t\t\tif (match(pc->x, sp, bol, flags, &scratch)) {\n+\t\t\tresult = match(pc->x, sp, bol, flags, &scratch, depth+1);\n+\t\t\tif (result == -1)\n+\t\t\t\treturn -1;\n+\t\t\tif (result == 0) {\n \t\t\t\t*out = scratch;\n-\t\t\t\treturn 1;\n+\t\t\t\treturn 0;\n \t\t\t}\n \t\t\tpc = pc->y;\n \t\t\tbreak;\n \n \t\tcase I_PLA:\n-\t\t\tif (!match(pc->x, sp, bol, flags, out))\n-\t\t\t\treturn 0;\n+\t\t\tresult = match(pc->x, sp, bol, flags, out, depth+1);\n+\t\t\tif (result == -1)\n+\t\t\t\treturn -1;\n+\t\t\tif (result == 1)\n+\t\t\t\treturn 1;\n \t\t\tpc = pc->y;\n \t\t\tbreak;\n \t\tcase I_NLA:\n \t\t\tscratch = *out;\n-\t\t\tif (match(pc->x, sp, bol, flags, &scratch))\n-\t\t\t\treturn 0;\n+\t\t\tresult = match(pc->x, sp, bol, flags, &scratch, depth+1);\n+\t\t\tif (result == -1)\n+\t\t\t\treturn -1;\n+\t\t\tif (result == 0)\n+\t\t\t\treturn 1;\n \t\t\tpc = pc->y;\n \t\t\tbreak;\n \n \t\tcase I_ANYNL:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_ANY:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (isnewline(c))\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_CHAR:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (flags & REG_ICASE)\n \t\t\t\tc = canon(c);\n \t\t\tif (c != pc->c)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_CCLASS:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (flags & REG_ICASE) {\n \t\t\t\tif (!incclasscanon(pc->cc, canon(c)))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t} else {\n \t\t\t\tif (!incclass(pc->cc, c))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t}\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_NCCLASS:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (flags & REG_ICASE) {\n \t\t\t\tif (incclasscanon(pc->cc, canon(c)))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t} else {\n \t\t\t\tif (incclass(pc->cc, c))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t}\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_REF:\n \t\t\ti = out->sub[pc->n].ep - out->sub[pc->n].sp;\n \t\t\tif (flags & REG_ICASE) {\n \t\t\t\tif (strncmpcanon(sp, out->sub[pc->n].sp, i))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t} else {\n \t\t\t\tif (strncmp(sp, out->sub[pc->n].sp, i))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t}\n \t\t\tif (i > 0)\n \t\t\t\tsp += i;\n@@ -1076,7 +1091,7 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n-\t\t\treturn 0;\n+\t\t\treturn 1;\n \t\tcase I_EOL:\n \t\t\tif (*sp == 0) {\n \t\t\t\tpc = pc + 1;\n@@ -1088,19 +1103,19 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n-\t\t\treturn 0;\n+\t\t\treturn 1;\n \t\tcase I_WORD:\n \t\t\ti = sp > bol && iswordchar(sp[-1]);\n \t\t\ti ^= iswordchar(sp[0]);\n \t\t\tif (!i)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_NWORD:\n \t\t\ti = sp > bol && iswordchar(sp[-1]);\n \t\t\ti ^= iswordchar(sp[0]);\n \t\t\tif (i)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \n@@ -1113,7 +1128,7 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tdefault:\n-\t\t\treturn 0;\n+\t\t\treturn 1;\n \t\t}\n \t}\n }\n@@ -1130,7 +1145,7 @@ int regexec(Reprog *prog, const char *sp, Resub *sub, int eflags)\n \tfor (i = 0; i < MAXSUB; ++i)\n \t\tsub->sub[i].sp = sub->sub[i].ep = NULL;\n \n-\treturn !match(prog->start, sp, sp, prog->flags | eflags, sub);\n+\treturn match(prog->start, sp, sp, prog->flags | eflags, sub, 0);\n }\n \n #ifdef TEST""}","static void Sp_search(js_State *J)
{
	js_Regexp *re;
	const char *text;
	Resub m;

	text = checkstring(J, 0);

	if (js_isregexp(J, 1))
		js_copy(J, 1);
	else if (js_isundefined(J, 1))
		js_newregexp(J, """", 0);
	else
		js_newregexp(J, js_tostring(J, 1), 0);
 
 	re = js_toregexp(J, -1);
 
	if (!js_doregexec(J, re->prog, text, &m, 0))
 		js_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));
 	else
 		js_pushnumber(J, -1);
}
","static void Sp_search(js_State *J)
{
	js_Regexp *re;
	const char *text;
	Resub m;

	text = checkstring(J, 0);

	if (js_isregexp(J, 1))
		js_copy(J, 1);
	else if (js_isundefined(J, 1))
		js_newregexp(J, """", 0);
	else
		js_newregexp(J, js_tostring(J, 1), 0);
 
 	re = js_toregexp(J, -1);
 
	if (!js_regexec(re->prog, text, &m, 0))
 		js_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));
 	else
 		js_pushnumber(J, -1);
}
",C,"	if (!js_doregexec(J, re->prog, text, &m, 0))
","	if (!js_regexec(re->prog, text, &m, 0))
",,"@@ -4,6 +4,14 @@
 #include ""utf.h""
 #include ""regexp.h""
 
+static int js_doregexec(js_State *J, Reprog *prog, const char *string, Resub *sub, int eflags)
+{
+	int result = js_regexec(prog, string, sub, eflags);
+	if (result < 0)
+		js_error(J, ""regexec failed"");
+	return result;
+}
+
 static const char *checkstring(js_State *J, int idx)
 {
 	if (!js_iscoercible(J, idx))
@@ -343,7 +351,7 @@ static void Sp_match(js_State *J)
 	a = text;
 	e = text + strlen(text);
 	while (a <= e) {
-		if (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))
+		if (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))
 			break;
 
 		b = m.sub[0].sp;
@@ -380,7 +388,7 @@ static void Sp_search(js_State *J)
 
 	re = js_toregexp(J, -1);
 
-	if (!js_regexec(re->prog, text, &m, 0))
+	if (!js_doregexec(J, re->prog, text, &m, 0))
 		js_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));
 	else
 		js_pushnumber(J, -1);
@@ -397,7 +405,7 @@ static void Sp_replace_regexp(js_State *J)
 	source = checkstring(J, 0);
 	re = js_toregexp(J, 1);
 
-	if (js_regexec(re->prog, source, &m, 0)) {
+	if (js_doregexec(J, re->prog, source, &m, 0)) {
 		js_copy(J, 0);
 		return;
 	}
@@ -471,7 +479,7 @@ static void Sp_replace_regexp(js_State *J)
 			else
 				goto end;
 		}
-		if (!js_regexec(re->prog, source, &m, REG_NOTBOL))
+		if (!js_doregexec(J, re->prog, source, &m, REG_NOTBOL))
 			goto loop;
 	}
 
@@ -576,7 +584,7 @@ static void Sp_split_regexp(js_State *J)
 
 	/* splitting the empty string */
 	if (e == text) {
-		if (js_regexec(re->prog, text, &m, 0)) {
+		if (js_doregexec(J, re->prog, text, &m, 0)) {
 			if (len == limit) return;
 			js_pushliteral(J, """");
 			js_setindex(J, -2, 0);
@@ -586,7 +594,7 @@ static void Sp_split_regexp(js_State *J)
 
 	p = a = text;
 	while (a < e) {
-		if (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))
+		if (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))
 			break; /* no match */
 
 		b = m.sub[0].sp;",mujs,00d4606c3baf813b7b1c176823b2729bf51002a2,1e5479084bc9852854feb1ba9bf68b52cd127e02,1,"static void Sp_search(js_State *J)
{
	js_Regexp *re;
	const char *text;
	Resub m;

	text = checkstring(J, 0);

	if (js_isregexp(J, 1))
		js_copy(J, 1);
	else if (js_isundefined(J, 1))
		js_newregexp(J, """", 0);
	else
		js_newregexp(J, js_tostring(J, 1), 0);
 
 	re = js_toregexp(J, -1);
 
//flaw_line_below:
	if (!js_regexec(re->prog, text, &m, 0))
//fix_flaw_line_below:
//	if (!js_doregexec(J, re->prog, text, &m, 0))
 		js_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));
 	else
 		js_pushnumber(J, -1);
}
"
5137,182873,,Remote,Not required,Partial,CVE-2019-11413,https://www.cvedetails.com/cve/CVE-2019-11413/,CWE-400,Low,,,,2019-04-22,5.0,An issue was discovered in Artifex MuJS 1.0.5. It has unlimited recursion because the match function in regexp.c lacks a depth check.,2019-04-30,,2,https://github.com/ccxvii/mujs/commit/00d4606c3baf813b7b1c176823b2729bf51002a2,00d4606c3baf813b7b1c176823b2729bf51002a2,"Bug 700937: Limit recursion in regexp matcher.

Also handle negative return code as an error in the JS bindings.",2,jsstring.c,"{""sha"": ""98b2a869c2cda0a0f19eb0a0ec41adfaaa90a3e0"", ""filename"": ""jsregexp.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 2, ""changes"": 12, ""blob_url"": ""https://github.com/ccxvii/mujs/blob/00d4606c3baf813b7b1c176823b2729bf51002a2/jsregexp.c"", ""raw_url"": ""https://github.com/ccxvii/mujs/raw/00d4606c3baf813b7b1c176823b2729bf51002a2/jsregexp.c"", ""contents_url"": ""https://api.github.com/repos/ccxvii/mujs/contents/jsregexp.c?ref=00d4606c3baf813b7b1c176823b2729bf51002a2"", ""patch"": ""@@ -29,6 +29,7 @@ void js_newregexp(js_State *J, const char *pattern, int flags)\n \n void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)\n {\n+\tint result;\n \tint i;\n \tint opts;\n \tResub m;\n@@ -46,7 +47,10 @@ void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)\n \t\t}\n \t}\n \n-\tif (!js_regexec(re->prog, text, &m, opts)) {\n+\tresult = js_regexec(re->prog, text, &m, opts);\n+\tif (result < 0)\n+\t\tjs_error(J, \""regexec failed\"");\n+\tif (result == 0) {\n \t\tjs_newarray(J);\n \t\tjs_pushstring(J, text);\n \t\tjs_setproperty(J, -2, \""input\"");\n@@ -71,6 +75,7 @@ static void Rp_test(js_State *J)\n {\n \tjs_Regexp *re;\n \tconst char *text;\n+\tint result;\n \tint opts;\n \tResub m;\n \n@@ -90,7 +95,10 @@ static void Rp_test(js_State *J)\n \t\t}\n \t}\n \n-\tif (!js_regexec(re->prog, text, &m, opts)) {\n+\tresult = js_regexec(re->prog, text, &m, opts);\n+\tif (result < 0)\n+\t\tjs_error(J, \""regexec failed\"");\n+\tif (result == 0) {\n \t\tif (re->flags & JS_REGEXP_G)\n \t\t\tre->last = re->last + (m.sub[0].ep - text);\n \t\tjs_pushboolean(J, 1);""}<_**next**_>{""sha"": ""29d2b8a56e95155a130c6eef25543fe0fb690ce8"", ""filename"": ""jsstring.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 6, ""changes"": 20, ""blob_url"": ""https://github.com/ccxvii/mujs/blob/00d4606c3baf813b7b1c176823b2729bf51002a2/jsstring.c"", ""raw_url"": ""https://github.com/ccxvii/mujs/raw/00d4606c3baf813b7b1c176823b2729bf51002a2/jsstring.c"", ""contents_url"": ""https://api.github.com/repos/ccxvii/mujs/contents/jsstring.c?ref=00d4606c3baf813b7b1c176823b2729bf51002a2"", ""patch"": ""@@ -4,6 +4,14 @@\n #include \""utf.h\""\n #include \""regexp.h\""\n \n+static int js_doregexec(js_State *J, Reprog *prog, const char *string, Resub *sub, int eflags)\n+{\n+\tint result = js_regexec(prog, string, sub, eflags);\n+\tif (result < 0)\n+\t\tjs_error(J, \""regexec failed\"");\n+\treturn result;\n+}\n+\n static const char *checkstring(js_State *J, int idx)\n {\n \tif (!js_iscoercible(J, idx))\n@@ -343,7 +351,7 @@ static void Sp_match(js_State *J)\n \ta = text;\n \te = text + strlen(text);\n \twhile (a <= e) {\n-\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n+\t\tif (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n \t\t\tbreak;\n \n \t\tb = m.sub[0].sp;\n@@ -380,7 +388,7 @@ static void Sp_search(js_State *J)\n \n \tre = js_toregexp(J, -1);\n \n-\tif (!js_regexec(re->prog, text, &m, 0))\n+\tif (!js_doregexec(J, re->prog, text, &m, 0))\n \t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n \telse\n \t\tjs_pushnumber(J, -1);\n@@ -397,7 +405,7 @@ static void Sp_replace_regexp(js_State *J)\n \tsource = checkstring(J, 0);\n \tre = js_toregexp(J, 1);\n \n-\tif (js_regexec(re->prog, source, &m, 0)) {\n+\tif (js_doregexec(J, re->prog, source, &m, 0)) {\n \t\tjs_copy(J, 0);\n \t\treturn;\n \t}\n@@ -471,7 +479,7 @@ static void Sp_replace_regexp(js_State *J)\n \t\t\telse\n \t\t\t\tgoto end;\n \t\t}\n-\t\tif (!js_regexec(re->prog, source, &m, REG_NOTBOL))\n+\t\tif (!js_doregexec(J, re->prog, source, &m, REG_NOTBOL))\n \t\t\tgoto loop;\n \t}\n \n@@ -576,7 +584,7 @@ static void Sp_split_regexp(js_State *J)\n \n \t/* splitting the empty string */\n \tif (e == text) {\n-\t\tif (js_regexec(re->prog, text, &m, 0)) {\n+\t\tif (js_doregexec(J, re->prog, text, &m, 0)) {\n \t\t\tif (len == limit) return;\n \t\t\tjs_pushliteral(J, \""\"");\n \t\t\tjs_setindex(J, -2, 0);\n@@ -586,7 +594,7 @@ static void Sp_split_regexp(js_State *J)\n \n \tp = a = text;\n \twhile (a < e) {\n-\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n+\t\tif (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n \t\t\tbreak; /* no match */\n \n \t\tb = m.sub[0].sp;""}<_**next**_>{""sha"": ""3f800e3bd275fd17ad95a9d5b82c5c1635f9c39d"", ""filename"": ""regexp.c"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 27, ""changes"": 69, ""blob_url"": ""https://github.com/ccxvii/mujs/blob/00d4606c3baf813b7b1c176823b2729bf51002a2/regexp.c"", ""raw_url"": ""https://github.com/ccxvii/mujs/raw/00d4606c3baf813b7b1c176823b2729bf51002a2/regexp.c"", ""contents_url"": ""https://api.github.com/repos/ccxvii/mujs/contents/regexp.c?ref=00d4606c3baf813b7b1c176823b2729bf51002a2"", ""patch"": ""@@ -16,6 +16,7 @@\n #define REPINF 255\n #define MAXSUB REG_MAXSUB\n #define MAXPROG (32 << 10)\n+#define MAXREC 1024\n \n typedef struct Reclass Reclass;\n typedef struct Renode Renode;\n@@ -967,98 +968,112 @@ static int strncmpcanon(const char *a, const char *b, int n)\n \treturn 0;\n }\n \n-static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *out)\n+static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *out, int depth)\n {\n \tResub scratch;\n+\tint result;\n \tint i;\n \tRune c;\n \n+\t/* stack overflow */\n+\tif (depth > MAXREC)\n+\t\treturn -1;\n+\n \tfor (;;) {\n \t\tswitch (pc->opcode) {\n \t\tcase I_END:\n-\t\t\treturn 1;\n+\t\t\treturn 0;\n \t\tcase I_JUMP:\n \t\t\tpc = pc->x;\n \t\t\tbreak;\n \t\tcase I_SPLIT:\n \t\t\tscratch = *out;\n-\t\t\tif (match(pc->x, sp, bol, flags, &scratch)) {\n+\t\t\tresult = match(pc->x, sp, bol, flags, &scratch, depth+1);\n+\t\t\tif (result == -1)\n+\t\t\t\treturn -1;\n+\t\t\tif (result == 0) {\n \t\t\t\t*out = scratch;\n-\t\t\t\treturn 1;\n+\t\t\t\treturn 0;\n \t\t\t}\n \t\t\tpc = pc->y;\n \t\t\tbreak;\n \n \t\tcase I_PLA:\n-\t\t\tif (!match(pc->x, sp, bol, flags, out))\n-\t\t\t\treturn 0;\n+\t\t\tresult = match(pc->x, sp, bol, flags, out, depth+1);\n+\t\t\tif (result == -1)\n+\t\t\t\treturn -1;\n+\t\t\tif (result == 1)\n+\t\t\t\treturn 1;\n \t\t\tpc = pc->y;\n \t\t\tbreak;\n \t\tcase I_NLA:\n \t\t\tscratch = *out;\n-\t\t\tif (match(pc->x, sp, bol, flags, &scratch))\n-\t\t\t\treturn 0;\n+\t\t\tresult = match(pc->x, sp, bol, flags, &scratch, depth+1);\n+\t\t\tif (result == -1)\n+\t\t\t\treturn -1;\n+\t\t\tif (result == 0)\n+\t\t\t\treturn 1;\n \t\t\tpc = pc->y;\n \t\t\tbreak;\n \n \t\tcase I_ANYNL:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_ANY:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (isnewline(c))\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_CHAR:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (flags & REG_ICASE)\n \t\t\t\tc = canon(c);\n \t\t\tif (c != pc->c)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_CCLASS:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (flags & REG_ICASE) {\n \t\t\t\tif (!incclasscanon(pc->cc, canon(c)))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t} else {\n \t\t\t\tif (!incclass(pc->cc, c))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t}\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_NCCLASS:\n \t\t\tsp += chartorune(&c, sp);\n \t\t\tif (c == 0)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tif (flags & REG_ICASE) {\n \t\t\t\tif (incclasscanon(pc->cc, canon(c)))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t} else {\n \t\t\t\tif (incclass(pc->cc, c))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t}\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_REF:\n \t\t\ti = out->sub[pc->n].ep - out->sub[pc->n].sp;\n \t\t\tif (flags & REG_ICASE) {\n \t\t\t\tif (strncmpcanon(sp, out->sub[pc->n].sp, i))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t} else {\n \t\t\t\tif (strncmp(sp, out->sub[pc->n].sp, i))\n-\t\t\t\t\treturn 0;\n+\t\t\t\t\treturn 1;\n \t\t\t}\n \t\t\tif (i > 0)\n \t\t\t\tsp += i;\n@@ -1076,7 +1091,7 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n-\t\t\treturn 0;\n+\t\t\treturn 1;\n \t\tcase I_EOL:\n \t\t\tif (*sp == 0) {\n \t\t\t\tpc = pc + 1;\n@@ -1088,19 +1103,19 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n-\t\t\treturn 0;\n+\t\t\treturn 1;\n \t\tcase I_WORD:\n \t\t\ti = sp > bol && iswordchar(sp[-1]);\n \t\t\ti ^= iswordchar(sp[0]);\n \t\t\tif (!i)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tcase I_NWORD:\n \t\t\ti = sp > bol && iswordchar(sp[-1]);\n \t\t\ti ^= iswordchar(sp[0]);\n \t\t\tif (i)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn 1;\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \n@@ -1113,7 +1128,7 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n \t\t\tpc = pc + 1;\n \t\t\tbreak;\n \t\tdefault:\n-\t\t\treturn 0;\n+\t\t\treturn 1;\n \t\t}\n \t}\n }\n@@ -1130,7 +1145,7 @@ int regexec(Reprog *prog, const char *sp, Resub *sub, int eflags)\n \tfor (i = 0; i < MAXSUB; ++i)\n \t\tsub->sub[i].sp = sub->sub[i].ep = NULL;\n \n-\treturn !match(prog->start, sp, sp, prog->flags | eflags, sub);\n+\treturn match(prog->start, sp, sp, prog->flags | eflags, sub, 0);\n }\n \n #ifdef TEST""}","static void Sp_split_regexp(js_State *J)
{
	js_Regexp *re;
	const char *text;
	int limit, len, k;
	const char *p, *a, *b, *c, *e;
	Resub m;

	text = checkstring(J, 0);
	re = js_toregexp(J, 1);
	limit = js_isdefined(J, 2) ? js_tointeger(J, 2) : 1 << 30;

	js_newarray(J);
	len = 0;

	e = text + strlen(text);
 
 	/* splitting the empty string */
 	if (e == text) {
		if (js_doregexec(J, re->prog, text, &m, 0)) {
 			if (len == limit) return;
 			js_pushliteral(J, """");
 			js_setindex(J, -2, 0);
		}
		return;
	}
 
 	p = a = text;
 	while (a < e) {
		if (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))
 			break; /* no match */
 
 		b = m.sub[0].sp;
		c = m.sub[0].ep;

		/* empty string at end of last match */
		if (b == p) {
			++a;
			continue;
		}

		if (len == limit) return;
		js_pushlstring(J, p, b - p);
		js_setindex(J, -2, len++);

		for (k = 1; k < m.nsub; ++k) {
			if (len == limit) return;
			js_pushlstring(J, m.sub[k].sp, m.sub[k].ep - m.sub[k].sp);
			js_setindex(J, -2, len++);
		}

		a = p = c;
	}

	if (len == limit) return;
	js_pushstring(J, p);
	js_setindex(J, -2, len);
}
","static void Sp_split_regexp(js_State *J)
{
	js_Regexp *re;
	const char *text;
	int limit, len, k;
	const char *p, *a, *b, *c, *e;
	Resub m;

	text = checkstring(J, 0);
	re = js_toregexp(J, 1);
	limit = js_isdefined(J, 2) ? js_tointeger(J, 2) : 1 << 30;

	js_newarray(J);
	len = 0;

	e = text + strlen(text);
 
 	/* splitting the empty string */
 	if (e == text) {
		if (js_regexec(re->prog, text, &m, 0)) {
 			if (len == limit) return;
 			js_pushliteral(J, """");
 			js_setindex(J, -2, 0);
		}
		return;
	}
 
 	p = a = text;
 	while (a < e) {
		if (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))
 			break; /* no match */
 
 		b = m.sub[0].sp;
		c = m.sub[0].ep;

		/* empty string at end of last match */
		if (b == p) {
			++a;
			continue;
		}

		if (len == limit) return;
		js_pushlstring(J, p, b - p);
		js_setindex(J, -2, len++);

		for (k = 1; k < m.nsub; ++k) {
			if (len == limit) return;
			js_pushlstring(J, m.sub[k].sp, m.sub[k].ep - m.sub[k].sp);
			js_setindex(J, -2, len++);
		}

		a = p = c;
	}

	if (len == limit) return;
	js_pushstring(J, p);
	js_setindex(J, -2, len);
}
",C,"		if (js_doregexec(J, re->prog, text, &m, 0)) {
		if (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))
","		if (js_regexec(re->prog, text, &m, 0)) {
		if (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))
",,"@@ -4,6 +4,14 @@
 #include ""utf.h""
 #include ""regexp.h""
 
+static int js_doregexec(js_State *J, Reprog *prog, const char *string, Resub *sub, int eflags)
+{
+	int result = js_regexec(prog, string, sub, eflags);
+	if (result < 0)
+		js_error(J, ""regexec failed"");
+	return result;
+}
+
 static const char *checkstring(js_State *J, int idx)
 {
 	if (!js_iscoercible(J, idx))
@@ -343,7 +351,7 @@ static void Sp_match(js_State *J)
 	a = text;
 	e = text + strlen(text);
 	while (a <= e) {
-		if (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))
+		if (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))
 			break;
 
 		b = m.sub[0].sp;
@@ -380,7 +388,7 @@ static void Sp_search(js_State *J)
 
 	re = js_toregexp(J, -1);
 
-	if (!js_regexec(re->prog, text, &m, 0))
+	if (!js_doregexec(J, re->prog, text, &m, 0))
 		js_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));
 	else
 		js_pushnumber(J, -1);
@@ -397,7 +405,7 @@ static void Sp_replace_regexp(js_State *J)
 	source = checkstring(J, 0);
 	re = js_toregexp(J, 1);
 
-	if (js_regexec(re->prog, source, &m, 0)) {
+	if (js_doregexec(J, re->prog, source, &m, 0)) {
 		js_copy(J, 0);
 		return;
 	}
@@ -471,7 +479,7 @@ static void Sp_replace_regexp(js_State *J)
 			else
 				goto end;
 		}
-		if (!js_regexec(re->prog, source, &m, REG_NOTBOL))
+		if (!js_doregexec(J, re->prog, source, &m, REG_NOTBOL))
 			goto loop;
 	}
 
@@ -576,7 +584,7 @@ static void Sp_split_regexp(js_State *J)
 
 	/* splitting the empty string */
 	if (e == text) {
-		if (js_regexec(re->prog, text, &m, 0)) {
+		if (js_doregexec(J, re->prog, text, &m, 0)) {
 			if (len == limit) return;
 			js_pushliteral(J, """");
 			js_setindex(J, -2, 0);
@@ -586,7 +594,7 @@ static void Sp_split_regexp(js_State *J)
 
 	p = a = text;
 	while (a < e) {
-		if (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))
+		if (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))
 			break; /* no match */
 
 		b = m.sub[0].sp;",mujs,00d4606c3baf813b7b1c176823b2729bf51002a2,1e5479084bc9852854feb1ba9bf68b52cd127e02,1,"static void Sp_split_regexp(js_State *J)
{
	js_Regexp *re;
	const char *text;
	int limit, len, k;
	const char *p, *a, *b, *c, *e;
	Resub m;

	text = checkstring(J, 0);
	re = js_toregexp(J, 1);
	limit = js_isdefined(J, 2) ? js_tointeger(J, 2) : 1 << 30;

	js_newarray(J);
	len = 0;

	e = text + strlen(text);
 
 	/* splitting the empty string */
 	if (e == text) {
//flaw_line_below:
		if (js_regexec(re->prog, text, &m, 0)) {
//fix_flaw_line_below:
//		if (js_doregexec(J, re->prog, text, &m, 0)) {
 			if (len == limit) return;
 			js_pushliteral(J, """");
 			js_setindex(J, -2, 0);
		}
		return;
	}
 
 	p = a = text;
 	while (a < e) {
//flaw_line_below:
		if (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))
//fix_flaw_line_below:
//		if (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))
 			break; /* no match */
 
 		b = m.sub[0].sp;
		c = m.sub[0].ep;

		/* empty string at end of last match */
		if (b == p) {
			++a;
			continue;
		}

		if (len == limit) return;
		js_pushlstring(J, p, b - p);
		js_setindex(J, -2, len++);

		for (k = 1; k < m.nsub; ++k) {
			if (len == limit) return;
			js_pushlstring(J, m.sub[k].sp, m.sub[k].ep - m.sub[k].sp);
			js_setindex(J, -2, len++);
		}

		a = p = c;
	}

	if (len == limit) return;
	js_pushstring(J, p);
	js_setindex(J, -2, len);
}
"
5195,182931,,Remote,Not required,Partial,CVE-2018-21017,https://www.cvedetails.com/cve/CVE-2018-21017/,CWE-400,Medium,,,,2019-09-16,4.3,GPAC 0.7.1 has a memory leak in dinf_Read in isomedia/box_code_base.c.,2019-09-17,,4,https://github.com/gpac/gpac/commit/d2371b4b204f0a3c0af51ad4e9b491144dd1225c,d2371b4b204f0a3c0af51ad4e9b491144dd1225c,prevent dref memleak on invalid input (#1183),1,src/isomedia/box_code_base.c,"{""sha"": ""667b57d078f7d8bf5efe85cdaff87b83391954a8"", ""filename"": ""src/isomedia/box_code_base.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/gpac/gpac/blob/d2371b4b204f0a3c0af51ad4e9b491144dd1225c/src/isomedia/box_code_base.c"", ""raw_url"": ""https://github.com/gpac/gpac/raw/d2371b4b204f0a3c0af51ad4e9b491144dd1225c/src/isomedia/box_code_base.c"", ""contents_url"": ""https://api.github.com/repos/gpac/gpac/contents/src/isomedia/box_code_base.c?ref=d2371b4b204f0a3c0af51ad4e9b491144dd1225c"", ""patch"": ""@@ -931,8 +931,11 @@ GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)\n \t\treturn e;\n \t}\n \tif (!((GF_DataInformationBox *)s)->dref) {\n+\t\tGF_Box* dref;\n \t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\""[iso file] Missing dref box in dinf\\n\""));\n-\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n+\t\tdref = gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n+\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)dref;\n+\t\tgf_isom_box_add_for_dump_mode(s, dref);\n \t}\n \treturn GF_OK;\n }""}","GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);
	if (e) {
 		return e;
 	}
 	if (!((GF_DataInformationBox *)s)->dref) {
		GF_Box* dref;
 		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Missing dref box in dinf\n""));
		dref = gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);
		((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)dref;
		gf_isom_box_add_for_dump_mode(s, dref);
 	}
 	return GF_OK;
 }
","GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);
	if (e) {
 		return e;
 	}
 	if (!((GF_DataInformationBox *)s)->dref) {
 		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Missing dref box in dinf\n""));
		((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);
 	}
 	return GF_OK;
 }
",C,"		GF_Box* dref;
		dref = gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);
		((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)dref;
		gf_isom_box_add_for_dump_mode(s, dref);
","		((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);
",,"@@ -931,8 +931,11 @@ GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)
 		return e;
 	}
 	if (!((GF_DataInformationBox *)s)->dref) {
+		GF_Box* dref;
 		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Missing dref box in dinf\n""));
-		((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);
+		dref = gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);
+		((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)dref;
+		gf_isom_box_add_for_dump_mode(s, dref);
 	}
 	return GF_OK;
 }",gpac,d2371b4b204f0a3c0af51ad4e9b491144dd1225c,1d9c5ef3b86e52ba0ad54e156346ecc3a3de274f,1,"GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);
	if (e) {
 		return e;
 	}
 	if (!((GF_DataInformationBox *)s)->dref) {
//fix_flaw_line_below:
//		GF_Box* dref;
 		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Missing dref box in dinf\n""));
//flaw_line_below:
		((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);
//fix_flaw_line_below:
//		dref = gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);
//fix_flaw_line_below:
//		((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)dref;
//fix_flaw_line_below:
//		gf_isom_box_add_for_dump_mode(s, dref);
 	}
 	return GF_OK;
 }
"
5220,182956,,Remote,Not required,Partial,CVE-2018-20784,https://www.cvedetails.com/cve/CVE-2018-20784/,CWE-400,Low,Partial,Partial,,2019-02-22,7.5,"In the Linux kernel before 4.20.2, kernel/sched/fair.c mishandles leaf cfs_rq's, which allows attackers to cause a denial of service (infinite loop in update_blocked_averages) or possibly have unspecified other impact by inducing a high load.",2019-07-30,DoS ,0,https://github.com/torvalds/linux/commit/c40f7d74c741a907cfaeb73a7697081881c497d0,c40f7d74c741a907cfaeb73a7697081881c497d0,"sched/fair: Fix infinite loop in update_blocked_averages() by reverting a9e7f6544b9c

Zhipeng Xie, Xie XiuQi and Sargun Dhillon reported lockups in the
scheduler under high loads, starting at around the v4.18 time frame,
and Zhipeng Xie tracked it down to bugs in the rq->leaf_cfs_rq_list
manipulation.

Do a (manual) revert of:

  a9e7f6544b9c (""sched/fair: Fix O(nr_cgroups) in load balance path"")

It turns out that the list_del_leaf_cfs_rq() introduced by this commit
is a surprising property that was not considered in followup commits
such as:

  9c2791f936ef (""sched/fair: Fix hierarchical order in rq->leaf_cfs_rq_list"")

As Vincent Guittot explains:

 ""I think that there is a bigger problem with commit a9e7f6544b9c and
  cfs_rq throttling:

  Let take the example of the following topology TG2 --> TG1 --> root:

   1) The 1st time a task is enqueued, we will add TG2 cfs_rq then TG1
      cfs_rq to leaf_cfs_rq_list and we are sure to do the whole branch in
      one path because it has never been used and can't be throttled so
      tmp_alone_branch will point to leaf_cfs_rq_list at the end.

   2) Then TG1 is throttled

   3) and we add TG3 as a new child of TG1.

   4) The 1st enqueue of a task on TG3 will add TG3 cfs_rq just before TG1
      cfs_rq and tmp_alone_branch will stay  on rq->leaf_cfs_rq_list.

  With commit a9e7f6544b9c, we can del a cfs_rq from rq->leaf_cfs_rq_list.
  So if the load of TG1 cfs_rq becomes NULL before step 2) above, TG1
  cfs_rq is removed from the list.
  Then at step 4), TG3 cfs_rq is added at the beginning of rq->leaf_cfs_rq_list
  but tmp_alone_branch still points to TG3 cfs_rq because its throttled
  parent can't be enqueued when the lock is released.
  tmp_alone_branch doesn't point to rq->leaf_cfs_rq_list whereas it should.

  So if TG3 cfs_rq is removed or destroyed before tmp_alone_branch
  points on another TG cfs_rq, the next TG cfs_rq that will be added,
  will be linked outside rq->leaf_cfs_rq_list - which is bad.

  In addition, we can break the ordering of the cfs_rq in
  rq->leaf_cfs_rq_list but this ordering is used to update and
  propagate the update from leaf down to root.""

Instead of trying to work through all these cases and trying to reproduce
the very high loads that produced the lockup to begin with, simplify
the code temporarily by reverting a9e7f6544b9c - which change was clearly
not thought through completely.

This (hopefully) gives us a kernel that doesn't lock up so people
can continue to enjoy their holidays without worrying about regressions. ;-)

[ mingo: Wrote changelog, fixed weird spelling in code comment while at it. ]

Analyzed-by: Xie XiuQi <xiexiuqi@huawei.com>
Analyzed-by: Vincent Guittot <vincent.guittot@linaro.org>
Reported-by: Zhipeng Xie <xiezhipeng1@huawei.com>
Reported-by: Sargun Dhillon <sargun@sargun.me>
Reported-by: Xie XiuQi <xiexiuqi@huawei.com>
Tested-by: Zhipeng Xie <xiezhipeng1@huawei.com>
Tested-by: Sargun Dhillon <sargun@sargun.me>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Acked-by: Vincent Guittot <vincent.guittot@linaro.org>
Cc: <stable@vger.kernel.org> # v4.13+
Cc: Bin Li <huawei.libin@huawei.com>
Cc: Mike Galbraith <efault@gmx.de>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: Tejun Heo <tj@kernel.org>
Cc: Thomas Gleixner <tglx@linutronix.de>
Fixes: a9e7f6544b9c (""sched/fair: Fix O(nr_cgroups) in load balance path"")
Link: http://lkml.kernel.org/r/1545879866-27809-1-git-send-email-xiexiuqi@huawei.com
Signed-off-by: Ingo Molnar <mingo@kernel.org>",11,kernel/sched/fair.c,"{""sha"": ""6483834f12788f80633c96e89d5cf874525a52e7"", ""filename"": ""kernel/sched/fair.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 34, ""changes"": 43, ""blob_url"": ""https://github.com/torvalds/linux/blob/c40f7d74c741a907cfaeb73a7697081881c497d0/kernel/sched/fair.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c40f7d74c741a907cfaeb73a7697081881c497d0/kernel/sched/fair.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/sched/fair.c?ref=c40f7d74c741a907cfaeb73a7697081881c497d0"", ""patch"": ""@@ -352,10 +352,9 @@ static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n \t}\n }\n \n-/* Iterate thr' all leaf cfs_rq's on a runqueue */\n-#define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos)\t\t\t\\\n-\tlist_for_each_entry_safe(cfs_rq, pos, &rq->leaf_cfs_rq_list,\t\\\n-\t\t\t\t leaf_cfs_rq_list)\n+/* Iterate through all leaf cfs_rq's on a runqueue: */\n+#define for_each_leaf_cfs_rq(rq, cfs_rq) \\\n+\tlist_for_each_entry_rcu(cfs_rq, &rq->leaf_cfs_rq_list, leaf_cfs_rq_list)\n \n /* Do the two (enqueued) entities belong to the same group ? */\n static inline struct cfs_rq *\n@@ -447,8 +446,8 @@ static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n {\n }\n \n-#define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos)\t\\\n-\t\tfor (cfs_rq = &rq->cfs, pos = NULL; cfs_rq; cfs_rq = pos)\n+#define for_each_leaf_cfs_rq(rq, cfs_rq)\t\\\n+\t\tfor (cfs_rq = &rq->cfs; cfs_rq; cfs_rq = NULL)\n \n static inline struct sched_entity *parent_entity(struct sched_entity *se)\n {\n@@ -7647,27 +7646,10 @@ static inline bool others_have_blocked(struct rq *rq)\n \n #ifdef CONFIG_FAIR_GROUP_SCHED\n \n-static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)\n-{\n-\tif (cfs_rq->load.weight)\n-\t\treturn false;\n-\n-\tif (cfs_rq->avg.load_sum)\n-\t\treturn false;\n-\n-\tif (cfs_rq->avg.util_sum)\n-\t\treturn false;\n-\n-\tif (cfs_rq->avg.runnable_load_sum)\n-\t\treturn false;\n-\n-\treturn true;\n-}\n-\n static void update_blocked_averages(int cpu)\n {\n \tstruct rq *rq = cpu_rq(cpu);\n-\tstruct cfs_rq *cfs_rq, *pos;\n+\tstruct cfs_rq *cfs_rq;\n \tconst struct sched_class *curr_class;\n \tstruct rq_flags rf;\n \tbool done = true;\n@@ -7679,7 +7661,7 @@ static void update_blocked_averages(int cpu)\n \t * Iterates the task_group tree in a bottom up fashion, see\n \t * list_add_leaf_cfs_rq() for details.\n \t */\n-\tfor_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {\n+\tfor_each_leaf_cfs_rq(rq, cfs_rq) {\n \t\tstruct sched_entity *se;\n \n \t\t/* throttled entities do not contribute to load */\n@@ -7694,13 +7676,6 @@ static void update_blocked_averages(int cpu)\n \t\tif (se && !skip_blocked_update(se))\n \t\t\tupdate_load_avg(cfs_rq_of(se), se, 0);\n \n-\t\t/*\n-\t\t * There can be a lot of idle CPU cgroups.  Don't let fully\n-\t\t * decayed cfs_rqs linger on the list.\n-\t\t */\n-\t\tif (cfs_rq_is_decayed(cfs_rq))\n-\t\t\tlist_del_leaf_cfs_rq(cfs_rq);\n-\n \t\t/* Don't need periodic decay once load/util_avg are null */\n \t\tif (cfs_rq_has_blocked(cfs_rq))\n \t\t\tdone = false;\n@@ -10570,10 +10545,10 @@ const struct sched_class fair_sched_class = {\n #ifdef CONFIG_SCHED_DEBUG\n void print_cfs_stats(struct seq_file *m, int cpu)\n {\n-\tstruct cfs_rq *cfs_rq, *pos;\n+\tstruct cfs_rq *cfs_rq;\n \n \trcu_read_lock();\n-\tfor_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)\n+\tfor_each_leaf_cfs_rq(cpu_rq(cpu), cfs_rq)\n \t\tprint_cfs_rq(m, cpu, cfs_rq);\n \trcu_read_unlock();\n }""}","static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)
","static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)
{
	if (cfs_rq->load.weight)
		return false;
	if (cfs_rq->avg.load_sum)
		return false;
	if (cfs_rq->avg.util_sum)
		return false;
	if (cfs_rq->avg.runnable_load_sum)
		return false;
	return true;
}
",C,,"{
	if (cfs_rq->load.weight)
		return false;
	if (cfs_rq->avg.load_sum)
		return false;
	if (cfs_rq->avg.util_sum)
		return false;
	if (cfs_rq->avg.runnable_load_sum)
		return false;
	return true;
}
",,"@@ -352,10 +352,9 @@ static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)
 	}
 }
 
-/* Iterate thr' all leaf cfs_rq's on a runqueue */
-#define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos)			\
-	list_for_each_entry_safe(cfs_rq, pos, &rq->leaf_cfs_rq_list,	\
-				 leaf_cfs_rq_list)
+/* Iterate through all leaf cfs_rq's on a runqueue: */
+#define for_each_leaf_cfs_rq(rq, cfs_rq) \
+	list_for_each_entry_rcu(cfs_rq, &rq->leaf_cfs_rq_list, leaf_cfs_rq_list)
 
 /* Do the two (enqueued) entities belong to the same group ? */
 static inline struct cfs_rq *
@@ -447,8 +446,8 @@ static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)
 {
 }
 
-#define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos)	\
-		for (cfs_rq = &rq->cfs, pos = NULL; cfs_rq; cfs_rq = pos)
+#define for_each_leaf_cfs_rq(rq, cfs_rq)	\
+		for (cfs_rq = &rq->cfs; cfs_rq; cfs_rq = NULL)
 
 static inline struct sched_entity *parent_entity(struct sched_entity *se)
 {
@@ -7647,27 +7646,10 @@ static inline bool others_have_blocked(struct rq *rq)
 
 #ifdef CONFIG_FAIR_GROUP_SCHED
 
-static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)
-{
-	if (cfs_rq->load.weight)
-		return false;
-
-	if (cfs_rq->avg.load_sum)
-		return false;
-
-	if (cfs_rq->avg.util_sum)
-		return false;
-
-	if (cfs_rq->avg.runnable_load_sum)
-		return false;
-
-	return true;
-}
-
 static void update_blocked_averages(int cpu)
 {
 	struct rq *rq = cpu_rq(cpu);
-	struct cfs_rq *cfs_rq, *pos;
+	struct cfs_rq *cfs_rq;
 	const struct sched_class *curr_class;
 	struct rq_flags rf;
 	bool done = true;
@@ -7679,7 +7661,7 @@ static void update_blocked_averages(int cpu)
 	 * Iterates the task_group tree in a bottom up fashion, see
 	 * list_add_leaf_cfs_rq() for details.
 	 */
-	for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {
+	for_each_leaf_cfs_rq(rq, cfs_rq) {
 		struct sched_entity *se;
 
 		/* throttled entities do not contribute to load */
@@ -7694,13 +7676,6 @@ static void update_blocked_averages(int cpu)
 		if (se && !skip_blocked_update(se))
 			update_load_avg(cfs_rq_of(se), se, 0);
 
-		/*
-		 * There can be a lot of idle CPU cgroups.  Don't let fully
-		 * decayed cfs_rqs linger on the list.
-		 */
-		if (cfs_rq_is_decayed(cfs_rq))
-			list_del_leaf_cfs_rq(cfs_rq);
-
 		/* Don't need periodic decay once load/util_avg are null */
 		if (cfs_rq_has_blocked(cfs_rq))
 			done = false;
@@ -10570,10 +10545,10 @@ const struct sched_class fair_sched_class = {
 #ifdef CONFIG_SCHED_DEBUG
 void print_cfs_stats(struct seq_file *m, int cpu)
 {
-	struct cfs_rq *cfs_rq, *pos;
+	struct cfs_rq *cfs_rq;
 
 	rcu_read_lock();
-	for_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)
+	for_each_leaf_cfs_rq(cpu_rq(cpu), cfs_rq)
 		print_cfs_rq(m, cpu, cfs_rq);
 	rcu_read_unlock();
 }",linux,c40f7d74c741a907cfaeb73a7697081881c497d0,6d101ba6be2a26a3e1f513b5e293f0fd2b79ec5c,1,"static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)
//flaw_line_below:
{
//flaw_line_below:
	if (cfs_rq->load.weight)
//flaw_line_below:
		return false;
//flaw_line_below:

//flaw_line_below:
	if (cfs_rq->avg.load_sum)
//flaw_line_below:
		return false;
//flaw_line_below:

//flaw_line_below:
	if (cfs_rq->avg.util_sum)
//flaw_line_below:
		return false;
//flaw_line_below:

//flaw_line_below:
	if (cfs_rq->avg.runnable_load_sum)
//flaw_line_below:
		return false;
//flaw_line_below:

//flaw_line_below:
	return true;
//flaw_line_below:
}
"
5221,182957,,Remote,Not required,Partial,CVE-2018-20784,https://www.cvedetails.com/cve/CVE-2018-20784/,CWE-400,Low,Partial,Partial,,2019-02-22,7.5,"In the Linux kernel before 4.20.2, kernel/sched/fair.c mishandles leaf cfs_rq's, which allows attackers to cause a denial of service (infinite loop in update_blocked_averages) or possibly have unspecified other impact by inducing a high load.",2019-07-30,DoS ,2,https://github.com/torvalds/linux/commit/c40f7d74c741a907cfaeb73a7697081881c497d0,c40f7d74c741a907cfaeb73a7697081881c497d0,"sched/fair: Fix infinite loop in update_blocked_averages() by reverting a9e7f6544b9c

Zhipeng Xie, Xie XiuQi and Sargun Dhillon reported lockups in the
scheduler under high loads, starting at around the v4.18 time frame,
and Zhipeng Xie tracked it down to bugs in the rq->leaf_cfs_rq_list
manipulation.

Do a (manual) revert of:

  a9e7f6544b9c (""sched/fair: Fix O(nr_cgroups) in load balance path"")

It turns out that the list_del_leaf_cfs_rq() introduced by this commit
is a surprising property that was not considered in followup commits
such as:

  9c2791f936ef (""sched/fair: Fix hierarchical order in rq->leaf_cfs_rq_list"")

As Vincent Guittot explains:

 ""I think that there is a bigger problem with commit a9e7f6544b9c and
  cfs_rq throttling:

  Let take the example of the following topology TG2 --> TG1 --> root:

   1) The 1st time a task is enqueued, we will add TG2 cfs_rq then TG1
      cfs_rq to leaf_cfs_rq_list and we are sure to do the whole branch in
      one path because it has never been used and can't be throttled so
      tmp_alone_branch will point to leaf_cfs_rq_list at the end.

   2) Then TG1 is throttled

   3) and we add TG3 as a new child of TG1.

   4) The 1st enqueue of a task on TG3 will add TG3 cfs_rq just before TG1
      cfs_rq and tmp_alone_branch will stay  on rq->leaf_cfs_rq_list.

  With commit a9e7f6544b9c, we can del a cfs_rq from rq->leaf_cfs_rq_list.
  So if the load of TG1 cfs_rq becomes NULL before step 2) above, TG1
  cfs_rq is removed from the list.
  Then at step 4), TG3 cfs_rq is added at the beginning of rq->leaf_cfs_rq_list
  but tmp_alone_branch still points to TG3 cfs_rq because its throttled
  parent can't be enqueued when the lock is released.
  tmp_alone_branch doesn't point to rq->leaf_cfs_rq_list whereas it should.

  So if TG3 cfs_rq is removed or destroyed before tmp_alone_branch
  points on another TG cfs_rq, the next TG cfs_rq that will be added,
  will be linked outside rq->leaf_cfs_rq_list - which is bad.

  In addition, we can break the ordering of the cfs_rq in
  rq->leaf_cfs_rq_list but this ordering is used to update and
  propagate the update from leaf down to root.""

Instead of trying to work through all these cases and trying to reproduce
the very high loads that produced the lockup to begin with, simplify
the code temporarily by reverting a9e7f6544b9c - which change was clearly
not thought through completely.

This (hopefully) gives us a kernel that doesn't lock up so people
can continue to enjoy their holidays without worrying about regressions. ;-)

[ mingo: Wrote changelog, fixed weird spelling in code comment while at it. ]

Analyzed-by: Xie XiuQi <xiexiuqi@huawei.com>
Analyzed-by: Vincent Guittot <vincent.guittot@linaro.org>
Reported-by: Zhipeng Xie <xiezhipeng1@huawei.com>
Reported-by: Sargun Dhillon <sargun@sargun.me>
Reported-by: Xie XiuQi <xiexiuqi@huawei.com>
Tested-by: Zhipeng Xie <xiezhipeng1@huawei.com>
Tested-by: Sargun Dhillon <sargun@sargun.me>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Acked-by: Vincent Guittot <vincent.guittot@linaro.org>
Cc: <stable@vger.kernel.org> # v4.13+
Cc: Bin Li <huawei.libin@huawei.com>
Cc: Mike Galbraith <efault@gmx.de>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: Tejun Heo <tj@kernel.org>
Cc: Thomas Gleixner <tglx@linutronix.de>
Fixes: a9e7f6544b9c (""sched/fair: Fix O(nr_cgroups) in load balance path"")
Link: http://lkml.kernel.org/r/1545879866-27809-1-git-send-email-xiexiuqi@huawei.com
Signed-off-by: Ingo Molnar <mingo@kernel.org>",2,kernel/sched/fair.c,"{""sha"": ""6483834f12788f80633c96e89d5cf874525a52e7"", ""filename"": ""kernel/sched/fair.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 34, ""changes"": 43, ""blob_url"": ""https://github.com/torvalds/linux/blob/c40f7d74c741a907cfaeb73a7697081881c497d0/kernel/sched/fair.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c40f7d74c741a907cfaeb73a7697081881c497d0/kernel/sched/fair.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/sched/fair.c?ref=c40f7d74c741a907cfaeb73a7697081881c497d0"", ""patch"": ""@@ -352,10 +352,9 @@ static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n \t}\n }\n \n-/* Iterate thr' all leaf cfs_rq's on a runqueue */\n-#define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos)\t\t\t\\\n-\tlist_for_each_entry_safe(cfs_rq, pos, &rq->leaf_cfs_rq_list,\t\\\n-\t\t\t\t leaf_cfs_rq_list)\n+/* Iterate through all leaf cfs_rq's on a runqueue: */\n+#define for_each_leaf_cfs_rq(rq, cfs_rq) \\\n+\tlist_for_each_entry_rcu(cfs_rq, &rq->leaf_cfs_rq_list, leaf_cfs_rq_list)\n \n /* Do the two (enqueued) entities belong to the same group ? */\n static inline struct cfs_rq *\n@@ -447,8 +446,8 @@ static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n {\n }\n \n-#define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos)\t\\\n-\t\tfor (cfs_rq = &rq->cfs, pos = NULL; cfs_rq; cfs_rq = pos)\n+#define for_each_leaf_cfs_rq(rq, cfs_rq)\t\\\n+\t\tfor (cfs_rq = &rq->cfs; cfs_rq; cfs_rq = NULL)\n \n static inline struct sched_entity *parent_entity(struct sched_entity *se)\n {\n@@ -7647,27 +7646,10 @@ static inline bool others_have_blocked(struct rq *rq)\n \n #ifdef CONFIG_FAIR_GROUP_SCHED\n \n-static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)\n-{\n-\tif (cfs_rq->load.weight)\n-\t\treturn false;\n-\n-\tif (cfs_rq->avg.load_sum)\n-\t\treturn false;\n-\n-\tif (cfs_rq->avg.util_sum)\n-\t\treturn false;\n-\n-\tif (cfs_rq->avg.runnable_load_sum)\n-\t\treturn false;\n-\n-\treturn true;\n-}\n-\n static void update_blocked_averages(int cpu)\n {\n \tstruct rq *rq = cpu_rq(cpu);\n-\tstruct cfs_rq *cfs_rq, *pos;\n+\tstruct cfs_rq *cfs_rq;\n \tconst struct sched_class *curr_class;\n \tstruct rq_flags rf;\n \tbool done = true;\n@@ -7679,7 +7661,7 @@ static void update_blocked_averages(int cpu)\n \t * Iterates the task_group tree in a bottom up fashion, see\n \t * list_add_leaf_cfs_rq() for details.\n \t */\n-\tfor_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {\n+\tfor_each_leaf_cfs_rq(rq, cfs_rq) {\n \t\tstruct sched_entity *se;\n \n \t\t/* throttled entities do not contribute to load */\n@@ -7694,13 +7676,6 @@ static void update_blocked_averages(int cpu)\n \t\tif (se && !skip_blocked_update(se))\n \t\t\tupdate_load_avg(cfs_rq_of(se), se, 0);\n \n-\t\t/*\n-\t\t * There can be a lot of idle CPU cgroups.  Don't let fully\n-\t\t * decayed cfs_rqs linger on the list.\n-\t\t */\n-\t\tif (cfs_rq_is_decayed(cfs_rq))\n-\t\t\tlist_del_leaf_cfs_rq(cfs_rq);\n-\n \t\t/* Don't need periodic decay once load/util_avg are null */\n \t\tif (cfs_rq_has_blocked(cfs_rq))\n \t\t\tdone = false;\n@@ -10570,10 +10545,10 @@ const struct sched_class fair_sched_class = {\n #ifdef CONFIG_SCHED_DEBUG\n void print_cfs_stats(struct seq_file *m, int cpu)\n {\n-\tstruct cfs_rq *cfs_rq, *pos;\n+\tstruct cfs_rq *cfs_rq;\n \n \trcu_read_lock();\n-\tfor_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)\n+\tfor_each_leaf_cfs_rq(cpu_rq(cpu), cfs_rq)\n \t\tprint_cfs_rq(m, cpu, cfs_rq);\n \trcu_read_unlock();\n }""}"," void print_cfs_stats(struct seq_file *m, int cpu)
 {
	struct cfs_rq *cfs_rq;
 
 	rcu_read_lock();
	for_each_leaf_cfs_rq(cpu_rq(cpu), cfs_rq)
 		print_cfs_rq(m, cpu, cfs_rq);
 	rcu_read_unlock();
 }
"," void print_cfs_stats(struct seq_file *m, int cpu)
 {
	struct cfs_rq *cfs_rq, *pos;
 
 	rcu_read_lock();
	for_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)
 		print_cfs_rq(m, cpu, cfs_rq);
 	rcu_read_unlock();
 }
",C,"	struct cfs_rq *cfs_rq;
	for_each_leaf_cfs_rq(cpu_rq(cpu), cfs_rq)
","	struct cfs_rq *cfs_rq, *pos;
	for_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)
",,"@@ -352,10 +352,9 @@ static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)
 	}
 }
 
-/* Iterate thr' all leaf cfs_rq's on a runqueue */
-#define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos)			\
-	list_for_each_entry_safe(cfs_rq, pos, &rq->leaf_cfs_rq_list,	\
-				 leaf_cfs_rq_list)
+/* Iterate through all leaf cfs_rq's on a runqueue: */
+#define for_each_leaf_cfs_rq(rq, cfs_rq) \
+	list_for_each_entry_rcu(cfs_rq, &rq->leaf_cfs_rq_list, leaf_cfs_rq_list)
 
 /* Do the two (enqueued) entities belong to the same group ? */
 static inline struct cfs_rq *
@@ -447,8 +446,8 @@ static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)
 {
 }
 
-#define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos)	\
-		for (cfs_rq = &rq->cfs, pos = NULL; cfs_rq; cfs_rq = pos)
+#define for_each_leaf_cfs_rq(rq, cfs_rq)	\
+		for (cfs_rq = &rq->cfs; cfs_rq; cfs_rq = NULL)
 
 static inline struct sched_entity *parent_entity(struct sched_entity *se)
 {
@@ -7647,27 +7646,10 @@ static inline bool others_have_blocked(struct rq *rq)
 
 #ifdef CONFIG_FAIR_GROUP_SCHED
 
-static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)
-{
-	if (cfs_rq->load.weight)
-		return false;
-
-	if (cfs_rq->avg.load_sum)
-		return false;
-
-	if (cfs_rq->avg.util_sum)
-		return false;
-
-	if (cfs_rq->avg.runnable_load_sum)
-		return false;
-
-	return true;
-}
-
 static void update_blocked_averages(int cpu)
 {
 	struct rq *rq = cpu_rq(cpu);
-	struct cfs_rq *cfs_rq, *pos;
+	struct cfs_rq *cfs_rq;
 	const struct sched_class *curr_class;
 	struct rq_flags rf;
 	bool done = true;
@@ -7679,7 +7661,7 @@ static void update_blocked_averages(int cpu)
 	 * Iterates the task_group tree in a bottom up fashion, see
 	 * list_add_leaf_cfs_rq() for details.
 	 */
-	for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {
+	for_each_leaf_cfs_rq(rq, cfs_rq) {
 		struct sched_entity *se;
 
 		/* throttled entities do not contribute to load */
@@ -7694,13 +7676,6 @@ static void update_blocked_averages(int cpu)
 		if (se && !skip_blocked_update(se))
 			update_load_avg(cfs_rq_of(se), se, 0);
 
-		/*
-		 * There can be a lot of idle CPU cgroups.  Don't let fully
-		 * decayed cfs_rqs linger on the list.
-		 */
-		if (cfs_rq_is_decayed(cfs_rq))
-			list_del_leaf_cfs_rq(cfs_rq);
-
 		/* Don't need periodic decay once load/util_avg are null */
 		if (cfs_rq_has_blocked(cfs_rq))
 			done = false;
@@ -10570,10 +10545,10 @@ const struct sched_class fair_sched_class = {
 #ifdef CONFIG_SCHED_DEBUG
 void print_cfs_stats(struct seq_file *m, int cpu)
 {
-	struct cfs_rq *cfs_rq, *pos;
+	struct cfs_rq *cfs_rq;
 
 	rcu_read_lock();
-	for_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)
+	for_each_leaf_cfs_rq(cpu_rq(cpu), cfs_rq)
 		print_cfs_rq(m, cpu, cfs_rq);
 	rcu_read_unlock();
 }",linux,c40f7d74c741a907cfaeb73a7697081881c497d0,6d101ba6be2a26a3e1f513b5e293f0fd2b79ec5c,1," void print_cfs_stats(struct seq_file *m, int cpu)
 {
//flaw_line_below:
	struct cfs_rq *cfs_rq, *pos;
//fix_flaw_line_below:
//	struct cfs_rq *cfs_rq;
 
 	rcu_read_lock();
//flaw_line_below:
	for_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)
//fix_flaw_line_below:
//	for_each_leaf_cfs_rq(cpu_rq(cpu), cfs_rq)
 		print_cfs_rq(m, cpu, cfs_rq);
 	rcu_read_unlock();
 }
"
5222,182958,,Remote,Not required,Partial,CVE-2018-20784,https://www.cvedetails.com/cve/CVE-2018-20784/,CWE-400,Low,Partial,Partial,,2019-02-22,7.5,"In the Linux kernel before 4.20.2, kernel/sched/fair.c mishandles leaf cfs_rq's, which allows attackers to cause a denial of service (infinite loop in update_blocked_averages) or possibly have unspecified other impact by inducing a high load.",2019-07-30,DoS ,2,https://github.com/torvalds/linux/commit/c40f7d74c741a907cfaeb73a7697081881c497d0,c40f7d74c741a907cfaeb73a7697081881c497d0,"sched/fair: Fix infinite loop in update_blocked_averages() by reverting a9e7f6544b9c

Zhipeng Xie, Xie XiuQi and Sargun Dhillon reported lockups in the
scheduler under high loads, starting at around the v4.18 time frame,
and Zhipeng Xie tracked it down to bugs in the rq->leaf_cfs_rq_list
manipulation.

Do a (manual) revert of:

  a9e7f6544b9c (""sched/fair: Fix O(nr_cgroups) in load balance path"")

It turns out that the list_del_leaf_cfs_rq() introduced by this commit
is a surprising property that was not considered in followup commits
such as:

  9c2791f936ef (""sched/fair: Fix hierarchical order in rq->leaf_cfs_rq_list"")

As Vincent Guittot explains:

 ""I think that there is a bigger problem with commit a9e7f6544b9c and
  cfs_rq throttling:

  Let take the example of the following topology TG2 --> TG1 --> root:

   1) The 1st time a task is enqueued, we will add TG2 cfs_rq then TG1
      cfs_rq to leaf_cfs_rq_list and we are sure to do the whole branch in
      one path because it has never been used and can't be throttled so
      tmp_alone_branch will point to leaf_cfs_rq_list at the end.

   2) Then TG1 is throttled

   3) and we add TG3 as a new child of TG1.

   4) The 1st enqueue of a task on TG3 will add TG3 cfs_rq just before TG1
      cfs_rq and tmp_alone_branch will stay  on rq->leaf_cfs_rq_list.

  With commit a9e7f6544b9c, we can del a cfs_rq from rq->leaf_cfs_rq_list.
  So if the load of TG1 cfs_rq becomes NULL before step 2) above, TG1
  cfs_rq is removed from the list.
  Then at step 4), TG3 cfs_rq is added at the beginning of rq->leaf_cfs_rq_list
  but tmp_alone_branch still points to TG3 cfs_rq because its throttled
  parent can't be enqueued when the lock is released.
  tmp_alone_branch doesn't point to rq->leaf_cfs_rq_list whereas it should.

  So if TG3 cfs_rq is removed or destroyed before tmp_alone_branch
  points on another TG cfs_rq, the next TG cfs_rq that will be added,
  will be linked outside rq->leaf_cfs_rq_list - which is bad.

  In addition, we can break the ordering of the cfs_rq in
  rq->leaf_cfs_rq_list but this ordering is used to update and
  propagate the update from leaf down to root.""

Instead of trying to work through all these cases and trying to reproduce
the very high loads that produced the lockup to begin with, simplify
the code temporarily by reverting a9e7f6544b9c - which change was clearly
not thought through completely.

This (hopefully) gives us a kernel that doesn't lock up so people
can continue to enjoy their holidays without worrying about regressions. ;-)

[ mingo: Wrote changelog, fixed weird spelling in code comment while at it. ]

Analyzed-by: Xie XiuQi <xiexiuqi@huawei.com>
Analyzed-by: Vincent Guittot <vincent.guittot@linaro.org>
Reported-by: Zhipeng Xie <xiezhipeng1@huawei.com>
Reported-by: Sargun Dhillon <sargun@sargun.me>
Reported-by: Xie XiuQi <xiexiuqi@huawei.com>
Tested-by: Zhipeng Xie <xiezhipeng1@huawei.com>
Tested-by: Sargun Dhillon <sargun@sargun.me>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Acked-by: Vincent Guittot <vincent.guittot@linaro.org>
Cc: <stable@vger.kernel.org> # v4.13+
Cc: Bin Li <huawei.libin@huawei.com>
Cc: Mike Galbraith <efault@gmx.de>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: Tejun Heo <tj@kernel.org>
Cc: Thomas Gleixner <tglx@linutronix.de>
Fixes: a9e7f6544b9c (""sched/fair: Fix O(nr_cgroups) in load balance path"")
Link: http://lkml.kernel.org/r/1545879866-27809-1-git-send-email-xiexiuqi@huawei.com
Signed-off-by: Ingo Molnar <mingo@kernel.org>",8,kernel/sched/fair.c,"{""sha"": ""6483834f12788f80633c96e89d5cf874525a52e7"", ""filename"": ""kernel/sched/fair.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 34, ""changes"": 43, ""blob_url"": ""https://github.com/torvalds/linux/blob/c40f7d74c741a907cfaeb73a7697081881c497d0/kernel/sched/fair.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c40f7d74c741a907cfaeb73a7697081881c497d0/kernel/sched/fair.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/sched/fair.c?ref=c40f7d74c741a907cfaeb73a7697081881c497d0"", ""patch"": ""@@ -352,10 +352,9 @@ static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n \t}\n }\n \n-/* Iterate thr' all leaf cfs_rq's on a runqueue */\n-#define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos)\t\t\t\\\n-\tlist_for_each_entry_safe(cfs_rq, pos, &rq->leaf_cfs_rq_list,\t\\\n-\t\t\t\t leaf_cfs_rq_list)\n+/* Iterate through all leaf cfs_rq's on a runqueue: */\n+#define for_each_leaf_cfs_rq(rq, cfs_rq) \\\n+\tlist_for_each_entry_rcu(cfs_rq, &rq->leaf_cfs_rq_list, leaf_cfs_rq_list)\n \n /* Do the two (enqueued) entities belong to the same group ? */\n static inline struct cfs_rq *\n@@ -447,8 +446,8 @@ static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n {\n }\n \n-#define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos)\t\\\n-\t\tfor (cfs_rq = &rq->cfs, pos = NULL; cfs_rq; cfs_rq = pos)\n+#define for_each_leaf_cfs_rq(rq, cfs_rq)\t\\\n+\t\tfor (cfs_rq = &rq->cfs; cfs_rq; cfs_rq = NULL)\n \n static inline struct sched_entity *parent_entity(struct sched_entity *se)\n {\n@@ -7647,27 +7646,10 @@ static inline bool others_have_blocked(struct rq *rq)\n \n #ifdef CONFIG_FAIR_GROUP_SCHED\n \n-static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)\n-{\n-\tif (cfs_rq->load.weight)\n-\t\treturn false;\n-\n-\tif (cfs_rq->avg.load_sum)\n-\t\treturn false;\n-\n-\tif (cfs_rq->avg.util_sum)\n-\t\treturn false;\n-\n-\tif (cfs_rq->avg.runnable_load_sum)\n-\t\treturn false;\n-\n-\treturn true;\n-}\n-\n static void update_blocked_averages(int cpu)\n {\n \tstruct rq *rq = cpu_rq(cpu);\n-\tstruct cfs_rq *cfs_rq, *pos;\n+\tstruct cfs_rq *cfs_rq;\n \tconst struct sched_class *curr_class;\n \tstruct rq_flags rf;\n \tbool done = true;\n@@ -7679,7 +7661,7 @@ static void update_blocked_averages(int cpu)\n \t * Iterates the task_group tree in a bottom up fashion, see\n \t * list_add_leaf_cfs_rq() for details.\n \t */\n-\tfor_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {\n+\tfor_each_leaf_cfs_rq(rq, cfs_rq) {\n \t\tstruct sched_entity *se;\n \n \t\t/* throttled entities do not contribute to load */\n@@ -7694,13 +7676,6 @@ static void update_blocked_averages(int cpu)\n \t\tif (se && !skip_blocked_update(se))\n \t\t\tupdate_load_avg(cfs_rq_of(se), se, 0);\n \n-\t\t/*\n-\t\t * There can be a lot of idle CPU cgroups.  Don't let fully\n-\t\t * decayed cfs_rqs linger on the list.\n-\t\t */\n-\t\tif (cfs_rq_is_decayed(cfs_rq))\n-\t\t\tlist_del_leaf_cfs_rq(cfs_rq);\n-\n \t\t/* Don't need periodic decay once load/util_avg are null */\n \t\tif (cfs_rq_has_blocked(cfs_rq))\n \t\t\tdone = false;\n@@ -10570,10 +10545,10 @@ const struct sched_class fair_sched_class = {\n #ifdef CONFIG_SCHED_DEBUG\n void print_cfs_stats(struct seq_file *m, int cpu)\n {\n-\tstruct cfs_rq *cfs_rq, *pos;\n+\tstruct cfs_rq *cfs_rq;\n \n \trcu_read_lock();\n-\tfor_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)\n+\tfor_each_leaf_cfs_rq(cpu_rq(cpu), cfs_rq)\n \t\tprint_cfs_rq(m, cpu, cfs_rq);\n \trcu_read_unlock();\n }""}"," static void update_blocked_averages(int cpu)
 {
 	struct rq *rq = cpu_rq(cpu);
	struct cfs_rq *cfs_rq;
 	const struct sched_class *curr_class;
 	struct rq_flags rf;
 	bool done = true;

	rq_lock_irqsave(rq, &rf);
	update_rq_clock(rq);

	/*
 	 * Iterates the task_group tree in a bottom up fashion, see
 	 * list_add_leaf_cfs_rq() for details.
 	 */
	for_each_leaf_cfs_rq(rq, cfs_rq) {
 		struct sched_entity *se;
 
 		/* throttled entities do not contribute to load */
		if (throttled_hierarchy(cfs_rq))
			continue;

		if (update_cfs_rq_load_avg(cfs_rq_clock_task(cfs_rq), cfs_rq))
			update_tg_load_avg(cfs_rq, 0);

		/* Propagate pending load changes to the parent, if any: */
		se = cfs_rq->tg->se[cpu];
 		if (se && !skip_blocked_update(se))
 			update_load_avg(cfs_rq_of(se), se, 0);
 
 		/* Don't need periodic decay once load/util_avg are null */
 		if (cfs_rq_has_blocked(cfs_rq))
 			done = false;
	}

	curr_class = rq->curr->sched_class;
	update_rt_rq_load_avg(rq_clock_task(rq), rq, curr_class == &rt_sched_class);
	update_dl_rq_load_avg(rq_clock_task(rq), rq, curr_class == &dl_sched_class);
	update_irq_load_avg(rq, 0);
	/* Don't need periodic decay once load/util_avg are null */
	if (others_have_blocked(rq))
		done = false;

#ifdef CONFIG_NO_HZ_COMMON
	rq->last_blocked_load_update_tick = jiffies;
	if (done)
		rq->has_blocked_load = 0;
#endif
	rq_unlock_irqrestore(rq, &rf);
}
"," static void update_blocked_averages(int cpu)
 {
 	struct rq *rq = cpu_rq(cpu);
	struct cfs_rq *cfs_rq, *pos;
 	const struct sched_class *curr_class;
 	struct rq_flags rf;
 	bool done = true;

	rq_lock_irqsave(rq, &rf);
	update_rq_clock(rq);

	/*
 	 * Iterates the task_group tree in a bottom up fashion, see
 	 * list_add_leaf_cfs_rq() for details.
 	 */
	for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {
 		struct sched_entity *se;
 
 		/* throttled entities do not contribute to load */
		if (throttled_hierarchy(cfs_rq))
			continue;

		if (update_cfs_rq_load_avg(cfs_rq_clock_task(cfs_rq), cfs_rq))
			update_tg_load_avg(cfs_rq, 0);

		/* Propagate pending load changes to the parent, if any: */
		se = cfs_rq->tg->se[cpu];
 		if (se && !skip_blocked_update(se))
 			update_load_avg(cfs_rq_of(se), se, 0);
 
		/*
		 * There can be a lot of idle CPU cgroups.  Don't let fully
		 * decayed cfs_rqs linger on the list.
		 */
		if (cfs_rq_is_decayed(cfs_rq))
			list_del_leaf_cfs_rq(cfs_rq);
 		/* Don't need periodic decay once load/util_avg are null */
 		if (cfs_rq_has_blocked(cfs_rq))
 			done = false;
	}

	curr_class = rq->curr->sched_class;
	update_rt_rq_load_avg(rq_clock_task(rq), rq, curr_class == &rt_sched_class);
	update_dl_rq_load_avg(rq_clock_task(rq), rq, curr_class == &dl_sched_class);
	update_irq_load_avg(rq, 0);
	/* Don't need periodic decay once load/util_avg are null */
	if (others_have_blocked(rq))
		done = false;

#ifdef CONFIG_NO_HZ_COMMON
	rq->last_blocked_load_update_tick = jiffies;
	if (done)
		rq->has_blocked_load = 0;
#endif
	rq_unlock_irqrestore(rq, &rf);
}
",C,"	struct cfs_rq *cfs_rq;
	for_each_leaf_cfs_rq(rq, cfs_rq) {
","	struct cfs_rq *cfs_rq, *pos;
	for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {
		/*
		 * There can be a lot of idle CPU cgroups.  Don't let fully
		 * decayed cfs_rqs linger on the list.
		 */
		if (cfs_rq_is_decayed(cfs_rq))
			list_del_leaf_cfs_rq(cfs_rq);
",,"@@ -352,10 +352,9 @@ static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)
 	}
 }
 
-/* Iterate thr' all leaf cfs_rq's on a runqueue */
-#define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos)			\
-	list_for_each_entry_safe(cfs_rq, pos, &rq->leaf_cfs_rq_list,	\
-				 leaf_cfs_rq_list)
+/* Iterate through all leaf cfs_rq's on a runqueue: */
+#define for_each_leaf_cfs_rq(rq, cfs_rq) \
+	list_for_each_entry_rcu(cfs_rq, &rq->leaf_cfs_rq_list, leaf_cfs_rq_list)
 
 /* Do the two (enqueued) entities belong to the same group ? */
 static inline struct cfs_rq *
@@ -447,8 +446,8 @@ static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)
 {
 }
 
-#define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos)	\
-		for (cfs_rq = &rq->cfs, pos = NULL; cfs_rq; cfs_rq = pos)
+#define for_each_leaf_cfs_rq(rq, cfs_rq)	\
+		for (cfs_rq = &rq->cfs; cfs_rq; cfs_rq = NULL)
 
 static inline struct sched_entity *parent_entity(struct sched_entity *se)
 {
@@ -7647,27 +7646,10 @@ static inline bool others_have_blocked(struct rq *rq)
 
 #ifdef CONFIG_FAIR_GROUP_SCHED
 
-static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)
-{
-	if (cfs_rq->load.weight)
-		return false;
-
-	if (cfs_rq->avg.load_sum)
-		return false;
-
-	if (cfs_rq->avg.util_sum)
-		return false;
-
-	if (cfs_rq->avg.runnable_load_sum)
-		return false;
-
-	return true;
-}
-
 static void update_blocked_averages(int cpu)
 {
 	struct rq *rq = cpu_rq(cpu);
-	struct cfs_rq *cfs_rq, *pos;
+	struct cfs_rq *cfs_rq;
 	const struct sched_class *curr_class;
 	struct rq_flags rf;
 	bool done = true;
@@ -7679,7 +7661,7 @@ static void update_blocked_averages(int cpu)
 	 * Iterates the task_group tree in a bottom up fashion, see
 	 * list_add_leaf_cfs_rq() for details.
 	 */
-	for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {
+	for_each_leaf_cfs_rq(rq, cfs_rq) {
 		struct sched_entity *se;
 
 		/* throttled entities do not contribute to load */
@@ -7694,13 +7676,6 @@ static void update_blocked_averages(int cpu)
 		if (se && !skip_blocked_update(se))
 			update_load_avg(cfs_rq_of(se), se, 0);
 
-		/*
-		 * There can be a lot of idle CPU cgroups.  Don't let fully
-		 * decayed cfs_rqs linger on the list.
-		 */
-		if (cfs_rq_is_decayed(cfs_rq))
-			list_del_leaf_cfs_rq(cfs_rq);
-
 		/* Don't need periodic decay once load/util_avg are null */
 		if (cfs_rq_has_blocked(cfs_rq))
 			done = false;
@@ -10570,10 +10545,10 @@ const struct sched_class fair_sched_class = {
 #ifdef CONFIG_SCHED_DEBUG
 void print_cfs_stats(struct seq_file *m, int cpu)
 {
-	struct cfs_rq *cfs_rq, *pos;
+	struct cfs_rq *cfs_rq;
 
 	rcu_read_lock();
-	for_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)
+	for_each_leaf_cfs_rq(cpu_rq(cpu), cfs_rq)
 		print_cfs_rq(m, cpu, cfs_rq);
 	rcu_read_unlock();
 }",linux,c40f7d74c741a907cfaeb73a7697081881c497d0,6d101ba6be2a26a3e1f513b5e293f0fd2b79ec5c,1," static void update_blocked_averages(int cpu)
 {
 	struct rq *rq = cpu_rq(cpu);
//flaw_line_below:
	struct cfs_rq *cfs_rq, *pos;
//fix_flaw_line_below:
//	struct cfs_rq *cfs_rq;
 	const struct sched_class *curr_class;
 	struct rq_flags rf;
 	bool done = true;

	rq_lock_irqsave(rq, &rf);
	update_rq_clock(rq);

	/*
 	 * Iterates the task_group tree in a bottom up fashion, see
 	 * list_add_leaf_cfs_rq() for details.
 	 */
//flaw_line_below:
	for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {
//fix_flaw_line_below:
//	for_each_leaf_cfs_rq(rq, cfs_rq) {
 		struct sched_entity *se;
 
 		/* throttled entities do not contribute to load */
		if (throttled_hierarchy(cfs_rq))
			continue;

		if (update_cfs_rq_load_avg(cfs_rq_clock_task(cfs_rq), cfs_rq))
			update_tg_load_avg(cfs_rq, 0);

		/* Propagate pending load changes to the parent, if any: */
		se = cfs_rq->tg->se[cpu];
 		if (se && !skip_blocked_update(se))
 			update_load_avg(cfs_rq_of(se), se, 0);
 
//flaw_line_below:
		/*
//flaw_line_below:
		 * There can be a lot of idle CPU cgroups.  Don't let fully
//flaw_line_below:
		 * decayed cfs_rqs linger on the list.
//flaw_line_below:
		 */
//flaw_line_below:
		if (cfs_rq_is_decayed(cfs_rq))
//flaw_line_below:
			list_del_leaf_cfs_rq(cfs_rq);
//flaw_line_below:

 		/* Don't need periodic decay once load/util_avg are null */
 		if (cfs_rq_has_blocked(cfs_rq))
 			done = false;
	}

	curr_class = rq->curr->sched_class;
	update_rt_rq_load_avg(rq_clock_task(rq), rq, curr_class == &rt_sched_class);
	update_dl_rq_load_avg(rq_clock_task(rq), rq, curr_class == &dl_sched_class);
	update_irq_load_avg(rq, 0);
	/* Don't need periodic decay once load/util_avg are null */
	if (others_have_blocked(rq))
		done = false;

#ifdef CONFIG_NO_HZ_COMMON
	rq->last_blocked_load_update_tick = jiffies;
	if (done)
		rq->has_blocked_load = 0;
#endif
	rq_unlock_irqrestore(rq, &rf);
}
"
5477,183213,,Remote,Not required,Complete,CVE-2017-11142,https://www.cvedetails.com/cve/CVE-2017-11142/,CWE-400,Low,,,,2017-07-10,7.8,"In PHP before 5.6.31, 7.x before 7.0.17, and 7.1.x before 7.1.3, remote attackers could cause a CPU consumption denial of service attack by injecting long form variables, related to main/php_variables.c.",2018-01-13,DoS ,5,https://github.com/php/php-src/commit/a15bffd105ac28fd0dd9b596632dbf035238fda3,a15bffd105ac28fd0dd9b596632dbf035238fda3,Fix bug #73807,2,main/php_variables.c,"{""sha"": ""3d402c67989b22d17cde2eb54356cba7b8b840e1"", ""filename"": ""NEWS"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/php/php-src/blob/a15bffd105ac28fd0dd9b596632dbf035238fda3/NEWS"", ""raw_url"": ""https://github.com/php/php-src/raw/a15bffd105ac28fd0dd9b596632dbf035238fda3/NEWS"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/NEWS?ref=a15bffd105ac28fd0dd9b596632dbf035238fda3"", ""patch"": ""@@ -2,6 +2,10 @@ PHP                                                                        NEWS\n |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\n ?? ??? 2017 PHP 7.0.17\n \n+- Core:\n+  . Fixed bug #73807 (Performance problem with processing large post request).\n+    (Nikita)\n+\n - OpenSSL:\n   . Fixed bug #74022 (PHP Fast CGI crashes when reading from a pfx file).\n     (Anatol)""}<_**next**_>{""sha"": ""aa6e426ba3829d5b3deaf7f2daa82e7f3271d7ff"", ""filename"": ""main/php_variables.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 2, ""changes"": 10, ""blob_url"": ""https://github.com/php/php-src/blob/a15bffd105ac28fd0dd9b596632dbf035238fda3/main/php_variables.c"", ""raw_url"": ""https://github.com/php/php-src/raw/a15bffd105ac28fd0dd9b596632dbf035238fda3/main/php_variables.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/main/php_variables.c?ref=a15bffd105ac28fd0dd9b596632dbf035238fda3"", ""patch"": ""@@ -239,21 +239,26 @@ typedef struct post_var_data {\n \tchar *ptr;\n \tchar *end;\n \tuint64_t cnt;\n+\n+\t/* Bytes in ptr that have already been scanned for '&' */\n+\tsize_t already_scanned;\n } post_var_data_t;\n \n static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof)\n {\n-\tchar *ksep, *vsep, *val;\n+\tchar *start, *ksep, *vsep, *val;\n \tsize_t klen, vlen;\n \tsize_t new_vlen;\n \n \tif (var->ptr >= var->end) {\n \t\treturn 0;\n \t}\n \n-\tvsep = memchr(var->ptr, '&', var->end - var->ptr);\n+\tstart = var->ptr + var->already_scanned;\n+\tvsep = memchr(start, '&', var->end - start);\n \tif (!vsep) {\n \t\tif (!eof) {\n+\t\t\tvar->already_scanned = var->end - var->ptr;\n \t\t\treturn 0;\n \t\t} else {\n \t\t\tvsep = var->end;\n@@ -286,6 +291,7 @@ static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof)\n \tefree(val);\n \n \tvar->ptr = vsep + (vsep != var->end);\n+\tvar->already_scanned = 0;\n \treturn 1;\n }\n ""}"," static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof)
 {
	char *start, *ksep, *vsep, *val;
 	size_t klen, vlen;
 	size_t new_vlen;
 
 	if (var->ptr >= var->end) {
 		return 0;
 	}
 
	start = var->ptr + var->already_scanned;
	vsep = memchr(start, '&', var->end - start);
 	if (!vsep) {
 		if (!eof) {
			var->already_scanned = var->end - var->ptr;
 			return 0;
 		} else {
 			vsep = var->end;
		}
	}

	ksep = memchr(var->ptr, '=', vsep - var->ptr);
	if (ksep) {
		*ksep = '\0';
		/* ""foo=bar&"" or ""foo=&"" */
		klen = ksep - var->ptr;
		vlen = vsep - ++ksep;
	} else {
		ksep = """";
		/* ""foo&"" */
		klen = vsep - var->ptr;
		vlen = 0;
	}

	php_url_decode(var->ptr, klen);

	val = estrndup(ksep, vlen);
	if (vlen) {
		vlen = php_url_decode(val, vlen);
	}

	if (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen)) {
		php_register_variable_safe(var->ptr, val, new_vlen, arr);
	}
 	efree(val);
 
 	var->ptr = vsep + (vsep != var->end);
	var->already_scanned = 0;
 	return 1;
 }
"," static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof)
 {
	char *ksep, *vsep, *val;
 	size_t klen, vlen;
 	size_t new_vlen;
 
 	if (var->ptr >= var->end) {
 		return 0;
 	}
 
	vsep = memchr(var->ptr, '&', var->end - var->ptr);
 	if (!vsep) {
 		if (!eof) {
 			return 0;
 		} else {
 			vsep = var->end;
		}
	}

	ksep = memchr(var->ptr, '=', vsep - var->ptr);
	if (ksep) {
		*ksep = '\0';
		/* ""foo=bar&"" or ""foo=&"" */
		klen = ksep - var->ptr;
		vlen = vsep - ++ksep;
	} else {
		ksep = """";
		/* ""foo&"" */
		klen = vsep - var->ptr;
		vlen = 0;
	}

	php_url_decode(var->ptr, klen);

	val = estrndup(ksep, vlen);
	if (vlen) {
		vlen = php_url_decode(val, vlen);
	}

	if (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen)) {
		php_register_variable_safe(var->ptr, val, new_vlen, arr);
	}
 	efree(val);
 
 	var->ptr = vsep + (vsep != var->end);
 	return 1;
 }
",C,"	char *start, *ksep, *vsep, *val;
	start = var->ptr + var->already_scanned;
	vsep = memchr(start, '&', var->end - start);
			var->already_scanned = var->end - var->ptr;
	var->already_scanned = 0;
","	char *ksep, *vsep, *val;
	vsep = memchr(var->ptr, '&', var->end - var->ptr);
",,"@@ -239,21 +239,26 @@ typedef struct post_var_data {
 	char *ptr;
 	char *end;
 	uint64_t cnt;
+
+	/* Bytes in ptr that have already been scanned for '&' */
+	size_t already_scanned;
 } post_var_data_t;
 
 static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof)
 {
-	char *ksep, *vsep, *val;
+	char *start, *ksep, *vsep, *val;
 	size_t klen, vlen;
 	size_t new_vlen;
 
 	if (var->ptr >= var->end) {
 		return 0;
 	}
 
-	vsep = memchr(var->ptr, '&', var->end - var->ptr);
+	start = var->ptr + var->already_scanned;
+	vsep = memchr(start, '&', var->end - start);
 	if (!vsep) {
 		if (!eof) {
+			var->already_scanned = var->end - var->ptr;
 			return 0;
 		} else {
 			vsep = var->end;
@@ -286,6 +291,7 @@ static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof)
 	efree(val);
 
 	var->ptr = vsep + (vsep != var->end);
+	var->already_scanned = 0;
 	return 1;
 }
 ",php-src,a15bffd105ac28fd0dd9b596632dbf035238fda3,570a2738074fba4305949ac7b16e93ca2d9c5e8a,1," static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof)
 {
//flaw_line_below:
	char *ksep, *vsep, *val;
//fix_flaw_line_below:
//	char *start, *ksep, *vsep, *val;
 	size_t klen, vlen;
 	size_t new_vlen;
 
 	if (var->ptr >= var->end) {
 		return 0;
 	}
 
//flaw_line_below:
	vsep = memchr(var->ptr, '&', var->end - var->ptr);
//fix_flaw_line_below:
//	start = var->ptr + var->already_scanned;
//fix_flaw_line_below:
//	vsep = memchr(start, '&', var->end - start);
 	if (!vsep) {
 		if (!eof) {
//fix_flaw_line_below:
//			var->already_scanned = var->end - var->ptr;
 			return 0;
 		} else {
 			vsep = var->end;
		}
	}

	ksep = memchr(var->ptr, '=', vsep - var->ptr);
	if (ksep) {
		*ksep = '\0';
		/* ""foo=bar&"" or ""foo=&"" */
		klen = ksep - var->ptr;
		vlen = vsep - ++ksep;
	} else {
		ksep = """";
		/* ""foo&"" */
		klen = vsep - var->ptr;
		vlen = 0;
	}

	php_url_decode(var->ptr, klen);

	val = estrndup(ksep, vlen);
	if (vlen) {
		vlen = php_url_decode(val, vlen);
	}

	if (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen)) {
		php_register_variable_safe(var->ptr, val, new_vlen, arr);
	}
 	efree(val);
 
 	var->ptr = vsep + (vsep != var->end);
//fix_flaw_line_below:
//	var->already_scanned = 0;
 	return 1;
 }
"
5646,183382,,Remote,Not required,Partial,CVE-2019-12973,https://www.cvedetails.com/cve/CVE-2019-12973/,CWE-400,Medium,,,,2019-06-26,4.3,"In OpenJPEG 2.3.1, there is excessive iteration in the opj_t1_encode_cblks function of openjp2/t1.c. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted bmp file. This issue is similar to CVE-2018-6616.",2019-09-30,DoS ,8,https://github.com/uclouvain/openjpeg/pull/1185/commits/cbe7384016083eac16078b359acd7a842253d503,cbe7384016083eac16078b359acd7a842253d503,"convertbmp: detect invalid file dimensions early

width/length dimensions read from bmp headers are not necessarily
valid. For instance they may have been maliciously set to very large
values with the intention to cause DoS (large memory allocation, stack
overflow). In these cases we want to detect the invalid size as early
as possible.

This commit introduces a counter which verifies that the number of
written bytes corresponds to the advertized width/length.

See commit 8ee335227bbc for details.

Signed-off-by: Young Xiao <YangX92@hotmail.com>",2,src/bin/jp2/convertbmp.c,"{""sha"": ""ec34f535b2a8a4fc4791060be430ba2d98545345"", ""filename"": ""src/bin/jp2/convertbmp.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 2, ""changes"": 10, ""blob_url"": ""https://github.com/uclouvain/openjpeg/blob/cbe7384016083eac16078b359acd7a842253d503/src/bin/jp2/convertbmp.c"", ""raw_url"": ""https://github.com/uclouvain/openjpeg/raw/cbe7384016083eac16078b359acd7a842253d503/src/bin/jp2/convertbmp.c"", ""contents_url"": ""https://api.github.com/repos/uclouvain/openjpeg/contents/src/bin/jp2/convertbmp.c?ref=cbe7384016083eac16078b359acd7a842253d503"", ""patch"": ""@@ -622,13 +622,13 @@ static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,\n static OPJ_BOOL bmp_read_rle4_data(FILE* IN, OPJ_UINT8* pData,\n                                    OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n {\n-    OPJ_UINT32 x, y;\n+    OPJ_UINT32 x, y, written;\n     OPJ_UINT8 *pix;\n     const OPJ_UINT8 *beyond;\n \n     beyond = pData + stride * height;\n     pix = pData;\n-    x = y = 0U;\n+    x = y = written = 0U;\n     while (y < height) {\n         int c = getc(IN);\n         if (c == EOF) {\n@@ -642,6 +642,7 @@ static OPJ_BOOL bmp_read_rle4_data(FILE* IN, OPJ_UINT8* pData,\n             for (j = 0; (j < c) && (x < width) &&\n                     ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                 *pix = (OPJ_UINT8)((j & 1) ? (c1 & 0x0fU) : ((c1 >> 4) & 0x0fU));\n+                written++;\n             }\n         } else { /* absolute mode */\n             c = getc(IN);\n@@ -671,13 +672,18 @@ static OPJ_BOOL bmp_read_rle4_data(FILE* IN, OPJ_UINT8* pData,\n                         c1 = (OPJ_UINT8)getc(IN);\n                     }\n                     *pix = (OPJ_UINT8)((j & 1) ? (c1 & 0x0fU) : ((c1 >> 4) & 0x0fU));\n+                    written++;\n                 }\n                 if (((c & 3) == 1) || ((c & 3) == 2)) { /* skip padding byte */\n                     getc(IN);\n                 }\n             }\n         }\n     }  /* while(y < height) */\n+    if (written != width * height) {\n+        fprintf(stderr, \""warning, image's actual size does not match advertized one\\n\"");\n+        return OPJ_FALSE;\n+    }\n     return OPJ_TRUE;\n }\n ""}"," static OPJ_BOOL bmp_read_rle4_data(FILE* IN, OPJ_UINT8* pData,
                                    OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)
 {
    OPJ_UINT32 x, y, written;
     OPJ_UINT8 *pix;
     const OPJ_UINT8 *beyond;
 
     beyond = pData + stride * height;
     pix = pData;
    x = y = written = 0U;
     while (y < height) {
         int c = getc(IN);
         if (c == EOF) {
            break;
        }

        if (c) { /* encoded mode */
            int j;
            OPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);

             for (j = 0; (j < c) && (x < width) &&
                     ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {
                 *pix = (OPJ_UINT8)((j & 1) ? (c1 & 0x0fU) : ((c1 >> 4) & 0x0fU));
                written++;
             }
         } else { /* absolute mode */
             c = getc(IN);
            if (c == EOF) {
                break;
            }

            if (c == 0x00) { /* EOL */
                x = 0;
                y++;
                pix = pData + y * stride;
            } else if (c == 0x01) { /* EOP */
                break;
            } else if (c == 0x02) { /* MOVE by dxdy */
                c = getc(IN);
                x += (OPJ_UINT32)c;
                c = getc(IN);
                y += (OPJ_UINT32)c;
                pix = pData + y * stride + x;
            } else { /* 03 .. 255 : absolute mode */
                int j;
                OPJ_UINT8 c1 = 0U;

                for (j = 0; (j < c) && (x < width) &&
                        ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {
                    if ((j & 1) == 0) {
                         c1 = (OPJ_UINT8)getc(IN);
                     }
                     *pix = (OPJ_UINT8)((j & 1) ? (c1 & 0x0fU) : ((c1 >> 4) & 0x0fU));
                    written++;
                 }
                 if (((c & 3) == 1) || ((c & 3) == 2)) { /* skip padding byte */
                     getc(IN);
                 }
             }
         }
     }  /* while(y < height) */
    if (written != width * height) {
        fprintf(stderr, ""warning, image's actual size does not match advertized one\n"");
        return OPJ_FALSE;
    }
     return OPJ_TRUE;
 }
"," static OPJ_BOOL bmp_read_rle4_data(FILE* IN, OPJ_UINT8* pData,
                                    OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)
 {
    OPJ_UINT32 x, y;
     OPJ_UINT8 *pix;
     const OPJ_UINT8 *beyond;
 
     beyond = pData + stride * height;
     pix = pData;
    x = y = 0U;
     while (y < height) {
         int c = getc(IN);
         if (c == EOF) {
            break;
        }

        if (c) { /* encoded mode */
            int j;
            OPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);

             for (j = 0; (j < c) && (x < width) &&
                     ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {
                 *pix = (OPJ_UINT8)((j & 1) ? (c1 & 0x0fU) : ((c1 >> 4) & 0x0fU));
             }
         } else { /* absolute mode */
             c = getc(IN);
            if (c == EOF) {
                break;
            }

            if (c == 0x00) { /* EOL */
                x = 0;
                y++;
                pix = pData + y * stride;
            } else if (c == 0x01) { /* EOP */
                break;
            } else if (c == 0x02) { /* MOVE by dxdy */
                c = getc(IN);
                x += (OPJ_UINT32)c;
                c = getc(IN);
                y += (OPJ_UINT32)c;
                pix = pData + y * stride + x;
            } else { /* 03 .. 255 : absolute mode */
                int j;
                OPJ_UINT8 c1 = 0U;

                for (j = 0; (j < c) && (x < width) &&
                        ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {
                    if ((j & 1) == 0) {
                         c1 = (OPJ_UINT8)getc(IN);
                     }
                     *pix = (OPJ_UINT8)((j & 1) ? (c1 & 0x0fU) : ((c1 >> 4) & 0x0fU));
                 }
                 if (((c & 3) == 1) || ((c & 3) == 2)) { /* skip padding byte */
                     getc(IN);
                 }
             }
         }
     }  /* while(y < height) */
     return OPJ_TRUE;
 }
",C,"    OPJ_UINT32 x, y, written;
    x = y = written = 0U;
                written++;
                    written++;
    if (written != width * height) {
        fprintf(stderr, ""warning, image's actual size does not match advertized one\n"");
        return OPJ_FALSE;
    }
","    OPJ_UINT32 x, y;
    x = y = 0U;
",,"@@ -622,13 +622,13 @@ static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,
 static OPJ_BOOL bmp_read_rle4_data(FILE* IN, OPJ_UINT8* pData,
                                    OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)
 {
-    OPJ_UINT32 x, y;
+    OPJ_UINT32 x, y, written;
     OPJ_UINT8 *pix;
     const OPJ_UINT8 *beyond;
 
     beyond = pData + stride * height;
     pix = pData;
-    x = y = 0U;
+    x = y = written = 0U;
     while (y < height) {
         int c = getc(IN);
         if (c == EOF) {
@@ -642,6 +642,7 @@ static OPJ_BOOL bmp_read_rle4_data(FILE* IN, OPJ_UINT8* pData,
             for (j = 0; (j < c) && (x < width) &&
                     ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {
                 *pix = (OPJ_UINT8)((j & 1) ? (c1 & 0x0fU) : ((c1 >> 4) & 0x0fU));
+                written++;
             }
         } else { /* absolute mode */
             c = getc(IN);
@@ -671,13 +672,18 @@ static OPJ_BOOL bmp_read_rle4_data(FILE* IN, OPJ_UINT8* pData,
                         c1 = (OPJ_UINT8)getc(IN);
                     }
                     *pix = (OPJ_UINT8)((j & 1) ? (c1 & 0x0fU) : ((c1 >> 4) & 0x0fU));
+                    written++;
                 }
                 if (((c & 3) == 1) || ((c & 3) == 2)) { /* skip padding byte */
                     getc(IN);
                 }
             }
         }
     }  /* while(y < height) */
+    if (written != width * height) {
+        fprintf(stderr, ""warning, image's actual size does not match advertized one\n"");
+        return OPJ_FALSE;
+    }
     return OPJ_TRUE;
 }
 ",openjpeg,cbe7384016083eac16078b359acd7a842253d503,51f097e6d5754ddae93e716276fe8176b44ec548,1," static OPJ_BOOL bmp_read_rle4_data(FILE* IN, OPJ_UINT8* pData,
                                    OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)
 {
//flaw_line_below:
    OPJ_UINT32 x, y;
//fix_flaw_line_below:
//    OPJ_UINT32 x, y, written;
     OPJ_UINT8 *pix;
     const OPJ_UINT8 *beyond;
 
     beyond = pData + stride * height;
     pix = pData;
//flaw_line_below:
    x = y = 0U;
//fix_flaw_line_below:
//    x = y = written = 0U;
     while (y < height) {
         int c = getc(IN);
         if (c == EOF) {
            break;
        }

        if (c) { /* encoded mode */
            int j;
            OPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);

             for (j = 0; (j < c) && (x < width) &&
                     ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {
                 *pix = (OPJ_UINT8)((j & 1) ? (c1 & 0x0fU) : ((c1 >> 4) & 0x0fU));
//fix_flaw_line_below:
//                written++;
             }
         } else { /* absolute mode */
             c = getc(IN);
            if (c == EOF) {
                break;
            }

            if (c == 0x00) { /* EOL */
                x = 0;
                y++;
                pix = pData + y * stride;
            } else if (c == 0x01) { /* EOP */
                break;
            } else if (c == 0x02) { /* MOVE by dxdy */
                c = getc(IN);
                x += (OPJ_UINT32)c;
                c = getc(IN);
                y += (OPJ_UINT32)c;
                pix = pData + y * stride + x;
            } else { /* 03 .. 255 : absolute mode */
                int j;
                OPJ_UINT8 c1 = 0U;

                for (j = 0; (j < c) && (x < width) &&
                        ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {
                    if ((j & 1) == 0) {
                         c1 = (OPJ_UINT8)getc(IN);
                     }
                     *pix = (OPJ_UINT8)((j & 1) ? (c1 & 0x0fU) : ((c1 >> 4) & 0x0fU));
//fix_flaw_line_below:
//                    written++;
                 }
                 if (((c & 3) == 1) || ((c & 3) == 2)) { /* skip padding byte */
                     getc(IN);
                 }
             }
         }
     }  /* while(y < height) */
//fix_flaw_line_below:
//    if (written != width * height) {
//fix_flaw_line_below:
//        fprintf(stderr, ""warning, image's actual size does not match advertized one\n"");
//fix_flaw_line_below:
//        return OPJ_FALSE;
//fix_flaw_line_below:
//    }
     return OPJ_TRUE;
 }
"
