,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix
195,177931,,Remote,Single system,,CVE-2018-14036,https://www.cvedetails.com/cve/CVE-2018-14036/,CWE-22,Low,Partial,,,2018-07-13,4.0,Directory Traversal with ../ sequences occurs in AccountsService before 0.6.50 because of an insufficient path check in user_change_icon_file_authorized_cb() in user.c.,2018-09-06,Dir. Trav.,8,https://cgit.freedesktop.org/accountsservice/commit/?id=f9abd359f71a5bce421b9ae23432f539a067847a,f9abd359f71a5bce421b9ae23432f539a067847a,,0,,,"user_change_icon_file_authorized_cb (Daemon                *daemon,
                                     User                  *user,
                                     GDBusMethodInvocation *context,
                                     gpointer               data)

{
        g_autofree gchar *filename = NULL;
        g_autoptr(GFile) file = NULL;
        g_autoptr(GFileInfo) info = NULL;
        guint32 mode;
        GFileType type;
        guint64 size;

        filename = g_strdup (data);

        if (filename == NULL ||
            *filename == '\0') {
                g_autofree gchar *dest_path = NULL;
                g_autoptr(GFile) dest = NULL;
                g_autoptr(GError) error = NULL;

                g_clear_pointer (&filename, g_free);

                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);
                dest = g_file_new_for_path (dest_path);

                if (!g_file_delete (dest, NULL, &error) &&
                    !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
                        throw_error (context, ERROR_FAILED, ""failed to remove user icon, %s"", error->message);
                        return;
                }
                goto icon_saved;
         }
 
         file = g_file_new_for_path (filename);
        g_clear_pointer (&filename, g_free);

        /* Canonicalize path so we can call g_str_has_prefix on it
         * below without concern for ../ path components moving outside
         * the prefix
         */
        filename = g_file_get_path (file);

         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_TYPE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,
                return;
        }
","user_change_icon_file_authorized_cb (Daemon                *daemon,
                                     User                  *user,
                                     GDBusMethodInvocation *context,
                                     gpointer               data)

{
        g_autofree gchar *filename = NULL;
        g_autoptr(GFile) file = NULL;
        g_autoptr(GFileInfo) info = NULL;
        guint32 mode;
        GFileType type;
        guint64 size;

        filename = g_strdup (data);

        if (filename == NULL ||
            *filename == '\0') {
                g_autofree gchar *dest_path = NULL;
                g_autoptr(GFile) dest = NULL;
                g_autoptr(GError) error = NULL;

                g_clear_pointer (&filename, g_free);

                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);
                dest = g_file_new_for_path (dest_path);

                if (!g_file_delete (dest, NULL, &error) &&
                    !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
                        throw_error (context, ERROR_FAILED, ""failed to remove user icon, %s"", error->message);
                        return;
                }
                goto icon_saved;
         }
 
         file = g_file_new_for_path (filename);
         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_TYPE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,
                return;
        }
",C,"        g_clear_pointer (&filename, g_free);

        /* Canonicalize path so we can call g_str_has_prefix on it
         * below without concern for ../ path components moving outside
         * the prefix
         */
        filename = g_file_get_path (file);

",,34bedecf7da81a8b42382254e3f9a32398c1ca5d,"@@ -1334,6 +1334,14 @@ user_change_icon_file_authorized_cb (Daemon                *daemon,
         }
 
         file = g_file_new_for_path (filename);
+        g_clear_pointer (&filename, g_free);
+
+        /* Canonicalize path so we can call g_str_has_prefix on it
+         * below without concern for ../ path components moving outside
+         * the prefix
+         */
+        filename = g_file_get_path (file);
+
         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_TYPE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,",accountsservice,https://cgit.freedesktop.org/accountsservice/tree/src/user.c?id=f9abd359f71a5bce421b9ae23432f539a067847a,https://cgit.freedesktop.org/accountsservice/tree/src/user.c?id=34bedecf7da81a8b42382254e3f9a32398c1ca5d,1,"user_change_icon_file_authorized_cb (Daemon                *daemon,
                                     User                  *user,
                                     GDBusMethodInvocation *context,
                                     gpointer               data)

{
        g_autofree gchar *filename = NULL;
        g_autoptr(GFile) file = NULL;
        g_autoptr(GFileInfo) info = NULL;
        guint32 mode;
        GFileType type;
        guint64 size;

        filename = g_strdup (data);

        if (filename == NULL ||
            *filename == '\0') {
                g_autofree gchar *dest_path = NULL;
                g_autoptr(GFile) dest = NULL;
                g_autoptr(GError) error = NULL;

                g_clear_pointer (&filename, g_free);

                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);
                dest = g_file_new_for_path (dest_path);

                if (!g_file_delete (dest, NULL, &error) &&
                    !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
                        throw_error (context, ERROR_FAILED, ""failed to remove user icon, %s"", error->message);
                        return;
                }
                goto icon_saved;
         }
 
         file = g_file_new_for_path (filename);
//fix_flaw_line_below:
//        g_clear_pointer (&filename, g_free);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        /* Canonicalize path so we can call g_str_has_prefix on it
//fix_flaw_line_below:
//         * below without concern for ../ path components moving outside
//fix_flaw_line_below:
//         * the prefix
//fix_flaw_line_below:
//         */
//fix_flaw_line_below:
//        filename = g_file_get_path (file);
//fix_flaw_line_below:
//
         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_TYPE "",""
                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,
                return;
        }
"
374,178110,,Local,Not required,,CVE-2016-7116,https://www.cvedetails.com/cve/CVE-2016-7116/,CWE-22,Low,Partial,,,2016-12-09,2.1,Directory traversal vulnerability in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local guest OS administrators to access host files outside the export path via a .. (dot dot) in an unspecified string.,2018-12-01,Dir. Trav.,1,https://git.qemu.org/?p=qemu.git;a=commit;h=56f101ecce0eafd09e2daf1c4eeb1377d6959261,56f101ecce0eafd09e2daf1c4eeb1377d6959261,,0,,,"static void v9fs_attach(void *opaque)
{
    V9fsPDU *pdu = opaque;
    V9fsState *s = pdu->s;
    int32_t fid, afid, n_uname;
    V9fsString uname, aname;
    V9fsFidState *fidp;
    size_t offset = 7;
    V9fsQID qid;
    ssize_t err;

    v9fs_string_init(&uname);
    v9fs_string_init(&aname);
    err = pdu_unmarshal(pdu, offset, ""ddssd"", &fid,
                        &afid, &uname, &aname, &n_uname);
    if (err < 0) {
        goto out_nofid;
    }
    trace_v9fs_attach(pdu->tag, pdu->id, fid, afid, uname.data, aname.data);

    fidp = alloc_fid(s, fid);
    if (fidp == NULL) {
        err = -EINVAL;
        goto out_nofid;
    }
    fidp->uid = n_uname;
    err = v9fs_co_name_to_path(pdu, NULL, ""/"", &fidp->path);
    if (err < 0) {
        err = -EINVAL;
        clunk_fid(s, fid);
        goto out;
    }
    err = fid_to_qid(pdu, fidp, &qid);
    if (err < 0) {
        err = -EINVAL;
        clunk_fid(s, fid);
        goto out;
    }
    err = pdu_marshal(pdu, offset, ""Q"", &qid);
    if (err < 0) {
        clunk_fid(s, fid);
         goto out;
     }
     err += offset;
    memcpy(&s->root_qid, &qid, sizeof(qid));
     trace_v9fs_attach_return(pdu->tag, pdu->id,
                              qid.type, qid.version, qid.path);
     /*
     * attach could get called multiple times for the same export.
     */
    if (!s->migration_blocker) {
        s->root_fid = fid;
        error_setg(&s->migration_blocker,
                   ""Migration is disabled when VirtFS export path '%s' is mounted in the guest using mount_tag '%s'"",
                   s->ctx.fs_root ? s->ctx.fs_root : ""NULL"", s->tag);
        migrate_add_blocker(s->migration_blocker);
    }
out:
    put_fid(pdu, fidp);
out_nofid:
    pdu_complete(pdu, err);
    v9fs_string_free(&uname);
    v9fs_string_free(&aname);
}
","static void v9fs_attach(void *opaque)
{
    V9fsPDU *pdu = opaque;
    V9fsState *s = pdu->s;
    int32_t fid, afid, n_uname;
    V9fsString uname, aname;
    V9fsFidState *fidp;
    size_t offset = 7;
    V9fsQID qid;
    ssize_t err;

    v9fs_string_init(&uname);
    v9fs_string_init(&aname);
    err = pdu_unmarshal(pdu, offset, ""ddssd"", &fid,
                        &afid, &uname, &aname, &n_uname);
    if (err < 0) {
        goto out_nofid;
    }
    trace_v9fs_attach(pdu->tag, pdu->id, fid, afid, uname.data, aname.data);

    fidp = alloc_fid(s, fid);
    if (fidp == NULL) {
        err = -EINVAL;
        goto out_nofid;
    }
    fidp->uid = n_uname;
    err = v9fs_co_name_to_path(pdu, NULL, ""/"", &fidp->path);
    if (err < 0) {
        err = -EINVAL;
        clunk_fid(s, fid);
        goto out;
    }
    err = fid_to_qid(pdu, fidp, &qid);
    if (err < 0) {
        err = -EINVAL;
        clunk_fid(s, fid);
        goto out;
    }
    err = pdu_marshal(pdu, offset, ""Q"", &qid);
    if (err < 0) {
        clunk_fid(s, fid);
         goto out;
     }
     err += offset;
     trace_v9fs_attach_return(pdu->tag, pdu->id,
                              qid.type, qid.version, qid.path);
     /*
     * attach could get called multiple times for the same export.
     */
    if (!s->migration_blocker) {
        s->root_fid = fid;
        error_setg(&s->migration_blocker,
                   ""Migration is disabled when VirtFS export path '%s' is mounted in the guest using mount_tag '%s'"",
                   s->ctx.fs_root ? s->ctx.fs_root : ""NULL"", s->tag);
        migrate_add_blocker(s->migration_blocker);
    }
out:
    put_fid(pdu, fidp);
out_nofid:
    pdu_complete(pdu, err);
    v9fs_string_free(&uname);
    v9fs_string_free(&aname);
}
",C,"    memcpy(&s->root_qid, &qid, sizeof(qid));
",,805b5d98c649d26fc44d2d7755a97f18e62b438a,"@@ -1010,6 +1010,7 @@ static void v9fs_attach(void *opaque)
         goto out;
     }
     err += offset;
+    memcpy(&s->root_qid, &qid, sizeof(qid));
     trace_v9fs_attach_return(pdu->tag, pdu->id,
                              qid.type, qid.version, qid.path);
     /*
@@ -1261,6 +1262,14 @@ static bool name_is_illegal(const char *name)
     return !*name || strchr(name, '/') != NULL;
 }
 
+static bool not_same_qid(const V9fsQID *qid1, const V9fsQID *qid2)
+{
+    return
+        qid1->type != qid2->type ||
+        qid1->version != qid2->version ||
+        qid1->path != qid2->path;
+}
+
 static void v9fs_walk(void *opaque)
 {
     int name_idx;
@@ -1276,6 +1285,7 @@ static void v9fs_walk(void *opaque)
     V9fsFidState *newfidp = NULL;
     V9fsPDU *pdu = opaque;
     V9fsState *s = pdu->s;
+    V9fsQID qid;
 
     err = pdu_unmarshal(pdu, offset, ""ddw"", &fid, &newfid, &nwnames);
     if (err < 0) {
@@ -1309,6 +1319,12 @@ static void v9fs_walk(void *opaque)
         err = -ENOENT;
         goto out_nofid;
     }
+
+    err = fid_to_qid(pdu, fidp, &qid);
+    if (err < 0) {
+        goto out;
+    }
+
     v9fs_path_init(&dpath);
     v9fs_path_init(&path);
     /*
@@ -1318,16 +1334,22 @@ static void v9fs_walk(void *opaque)
     v9fs_path_copy(&dpath, &fidp->path);
     v9fs_path_copy(&path, &fidp->path);
     for (name_idx = 0; name_idx < nwnames; name_idx++) {
-        err = v9fs_co_name_to_path(pdu, &dpath, wnames[name_idx].data, &path);
-        if (err < 0) {
-            goto out;
-        }
-        err = v9fs_co_lstat(pdu, &path, &stbuf);
-        if (err < 0) {
-            goto out;
+        if (not_same_qid(&pdu->s->root_qid, &qid) ||
+            strcmp("".."", wnames[name_idx].data)) {
+            err = v9fs_co_name_to_path(pdu, &dpath, wnames[name_idx].data,
+                                       &path);
+            if (err < 0) {
+                goto out;
+            }
+
+            err = v9fs_co_lstat(pdu, &path, &stbuf);
+            if (err < 0) {
+                goto out;
+            }
+            stat_to_qid(&stbuf, &qid);
+            v9fs_path_copy(&dpath, &path);
         }
-        stat_to_qid(&stbuf, &qids[name_idx]);
-        v9fs_path_copy(&dpath, &path);
+        memcpy(&qids[name_idx], &qid, sizeof(qid));
     }
     if (fid == newfid) {
         BUG_ON(fidp->fid_type != P9_FID_NONE);",qemu,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/9pfs/9p.c;h=dfe293d11d1ca3846a0792b7aabf32277c23a929;hb=56f101ecce0eafd09e2daf1c4eeb1377d6959261,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/9pfs/9p.c;h=51c6f9883bf8767df9e07f858da0a73f0b51d482,1,"static void v9fs_attach(void *opaque)
{
    V9fsPDU *pdu = opaque;
    V9fsState *s = pdu->s;
    int32_t fid, afid, n_uname;
    V9fsString uname, aname;
    V9fsFidState *fidp;
    size_t offset = 7;
    V9fsQID qid;
    ssize_t err;

    v9fs_string_init(&uname);
    v9fs_string_init(&aname);
    err = pdu_unmarshal(pdu, offset, ""ddssd"", &fid,
                        &afid, &uname, &aname, &n_uname);
    if (err < 0) {
        goto out_nofid;
    }
    trace_v9fs_attach(pdu->tag, pdu->id, fid, afid, uname.data, aname.data);

    fidp = alloc_fid(s, fid);
    if (fidp == NULL) {
        err = -EINVAL;
        goto out_nofid;
    }
    fidp->uid = n_uname;
    err = v9fs_co_name_to_path(pdu, NULL, ""/"", &fidp->path);
    if (err < 0) {
        err = -EINVAL;
        clunk_fid(s, fid);
        goto out;
    }
    err = fid_to_qid(pdu, fidp, &qid);
    if (err < 0) {
        err = -EINVAL;
        clunk_fid(s, fid);
        goto out;
    }
    err = pdu_marshal(pdu, offset, ""Q"", &qid);
    if (err < 0) {
        clunk_fid(s, fid);
         goto out;
     }
     err += offset;
//fix_flaw_line_below:
//    memcpy(&s->root_qid, &qid, sizeof(qid));
     trace_v9fs_attach_return(pdu->tag, pdu->id,
                              qid.type, qid.version, qid.path);
     /*
     * attach could get called multiple times for the same export.
     */
    if (!s->migration_blocker) {
        s->root_fid = fid;
        error_setg(&s->migration_blocker,
                   ""Migration is disabled when VirtFS export path '%s' is mounted in the guest using mount_tag '%s'"",
                   s->ctx.fs_root ? s->ctx.fs_root : ""NULL"", s->tag);
        migrate_add_blocker(s->migration_blocker);
    }
out:
    put_fid(pdu, fidp);
out_nofid:
    pdu_complete(pdu, err);
    v9fs_string_free(&uname);
    v9fs_string_free(&aname);
}
"
375,178111,,Local,Not required,,CVE-2016-7116,https://www.cvedetails.com/cve/CVE-2016-7116/,CWE-22,Low,Partial,,,2016-12-09,2.1,Directory traversal vulnerability in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local guest OS administrators to access host files outside the export path via a .. (dot dot) in an unspecified string.,2018-12-01,Dir. Trav.,1,https://git.qemu.org/?p=qemu.git;a=commit;h=56f101ecce0eafd09e2daf1c4eeb1377d6959261,56f101ecce0eafd09e2daf1c4eeb1377d6959261,,0,,," static void v9fs_walk(void *opaque)
 {
     int name_idx;
    V9fsFidState *newfidp = NULL;
    V9fsPDU *pdu = opaque;
    V9fsState *s = pdu->s;

    err = pdu_unmarshal(pdu, offset, ""ddw"", &fid, &newfid, &nwnames);
    if (err < 0) {
        pdu_complete(pdu, err);
        return ;
    }
     V9fsFidState *newfidp = NULL;
     V9fsPDU *pdu = opaque;
     V9fsState *s = pdu->s;
    V9fsQID qid;
 
     err = pdu_unmarshal(pdu, offset, ""ddw"", &fid, &newfid, &nwnames);
     if (err < 0) {
        for (i = 0; i < nwnames; i++) {
            err = pdu_unmarshal(pdu, offset, ""s"", &wnames[i]);
            if (err < 0) {
                goto out_nofid;
            }
            if (name_is_illegal(wnames[i].data)) {
                err = -ENOENT;
                goto out_nofid;
            }
            offset += err;
        }
    } else if (nwnames > P9_MAXWELEM) {
        err = -EINVAL;
        goto out_nofid;
    }
    fidp = get_fid(pdu, fid);
    if (fidp == NULL) {
        err = -ENOENT;
        goto out_nofid;
    }
    v9fs_path_init(&dpath);
    v9fs_path_init(&path);
    /*
     * Both dpath and path initially poin to fidp.
     * Needed to handle request with nwnames == 0
     */
    v9fs_path_copy(&dpath, &fidp->path);
         err = -ENOENT;
         goto out_nofid;
     }
"," static void v9fs_walk(void *opaque)
 {
     int name_idx;
    V9fsFidState *newfidp = NULL;
    V9fsPDU *pdu = opaque;
    V9fsState *s = pdu->s;

    err = pdu_unmarshal(pdu, offset, ""ddw"", &fid, &newfid, &nwnames);
    if (err < 0) {
        pdu_complete(pdu, err);
        return ;
    }
     V9fsFidState *newfidp = NULL;
     V9fsPDU *pdu = opaque;
     V9fsState *s = pdu->s;
 
     err = pdu_unmarshal(pdu, offset, ""ddw"", &fid, &newfid, &nwnames);
     if (err < 0) {
        for (i = 0; i < nwnames; i++) {
            err = pdu_unmarshal(pdu, offset, ""s"", &wnames[i]);
            if (err < 0) {
                goto out_nofid;
            }
            if (name_is_illegal(wnames[i].data)) {
                err = -ENOENT;
                goto out_nofid;
            }
            offset += err;
        }
    } else if (nwnames > P9_MAXWELEM) {
        err = -EINVAL;
        goto out_nofid;
    }
    fidp = get_fid(pdu, fid);
    if (fidp == NULL) {
        err = -ENOENT;
        goto out_nofid;
    }
    v9fs_path_init(&dpath);
    v9fs_path_init(&path);
    /*
     * Both dpath and path initially poin to fidp.
     * Needed to handle request with nwnames == 0
     */
    v9fs_path_copy(&dpath, &fidp->path);
         err = -ENOENT;
         goto out_nofid;
     }
",C,"    V9fsQID qid;
",,805b5d98c649d26fc44d2d7755a97f18e62b438a,"@@ -1010,6 +1010,7 @@ static void v9fs_attach(void *opaque)
         goto out;
     }
     err += offset;
+    memcpy(&s->root_qid, &qid, sizeof(qid));
     trace_v9fs_attach_return(pdu->tag, pdu->id,
                              qid.type, qid.version, qid.path);
     /*
@@ -1261,6 +1262,14 @@ static bool name_is_illegal(const char *name)
     return !*name || strchr(name, '/') != NULL;
 }
 
+static bool not_same_qid(const V9fsQID *qid1, const V9fsQID *qid2)
+{
+    return
+        qid1->type != qid2->type ||
+        qid1->version != qid2->version ||
+        qid1->path != qid2->path;
+}
+
 static void v9fs_walk(void *opaque)
 {
     int name_idx;
@@ -1276,6 +1285,7 @@ static void v9fs_walk(void *opaque)
     V9fsFidState *newfidp = NULL;
     V9fsPDU *pdu = opaque;
     V9fsState *s = pdu->s;
+    V9fsQID qid;
 
     err = pdu_unmarshal(pdu, offset, ""ddw"", &fid, &newfid, &nwnames);
     if (err < 0) {
@@ -1309,6 +1319,12 @@ static void v9fs_walk(void *opaque)
         err = -ENOENT;
         goto out_nofid;
     }
+
+    err = fid_to_qid(pdu, fidp, &qid);
+    if (err < 0) {
+        goto out;
+    }
+
     v9fs_path_init(&dpath);
     v9fs_path_init(&path);
     /*
@@ -1318,16 +1334,22 @@ static void v9fs_walk(void *opaque)
     v9fs_path_copy(&dpath, &fidp->path);
     v9fs_path_copy(&path, &fidp->path);
     for (name_idx = 0; name_idx < nwnames; name_idx++) {
-        err = v9fs_co_name_to_path(pdu, &dpath, wnames[name_idx].data, &path);
-        if (err < 0) {
-            goto out;
-        }
-        err = v9fs_co_lstat(pdu, &path, &stbuf);
-        if (err < 0) {
-            goto out;
+        if (not_same_qid(&pdu->s->root_qid, &qid) ||
+            strcmp("".."", wnames[name_idx].data)) {
+            err = v9fs_co_name_to_path(pdu, &dpath, wnames[name_idx].data,
+                                       &path);
+            if (err < 0) {
+                goto out;
+            }
+
+            err = v9fs_co_lstat(pdu, &path, &stbuf);
+            if (err < 0) {
+                goto out;
+            }
+            stat_to_qid(&stbuf, &qid);
+            v9fs_path_copy(&dpath, &path);
         }
-        stat_to_qid(&stbuf, &qids[name_idx]);
-        v9fs_path_copy(&dpath, &path);
+        memcpy(&qids[name_idx], &qid, sizeof(qid));
     }
     if (fid == newfid) {
         BUG_ON(fidp->fid_type != P9_FID_NONE);",qemu,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/9pfs/9p.c;h=dfe293d11d1ca3846a0792b7aabf32277c23a929;hb=56f101ecce0eafd09e2daf1c4eeb1377d6959261,https://git.qemu.org/?p=qemu.git;a=blob;f=hw/9pfs/9p.c;h=51c6f9883bf8767df9e07f858da0a73f0b51d482,1," static void v9fs_walk(void *opaque)
 {
     int name_idx;
    V9fsFidState *newfidp = NULL;
    V9fsPDU *pdu = opaque;
    V9fsState *s = pdu->s;

    err = pdu_unmarshal(pdu, offset, ""ddw"", &fid, &newfid, &nwnames);
    if (err < 0) {
        pdu_complete(pdu, err);
        return ;
    }
     V9fsFidState *newfidp = NULL;
     V9fsPDU *pdu = opaque;
     V9fsState *s = pdu->s;
//fix_flaw_line_below:
//    V9fsQID qid;
 
     err = pdu_unmarshal(pdu, offset, ""ddw"", &fid, &newfid, &nwnames);
     if (err < 0) {
        for (i = 0; i < nwnames; i++) {
            err = pdu_unmarshal(pdu, offset, ""s"", &wnames[i]);
            if (err < 0) {
                goto out_nofid;
            }
            if (name_is_illegal(wnames[i].data)) {
                err = -ENOENT;
                goto out_nofid;
            }
            offset += err;
        }
    } else if (nwnames > P9_MAXWELEM) {
        err = -EINVAL;
        goto out_nofid;
    }
    fidp = get_fid(pdu, fid);
    if (fidp == NULL) {
        err = -ENOENT;
        goto out_nofid;
    }
    v9fs_path_init(&dpath);
    v9fs_path_init(&path);
    /*
     * Both dpath and path initially poin to fidp.
     * Needed to handle request with nwnames == 0
     */
    v9fs_path_copy(&dpath, &fidp->path);
         err = -ENOENT;
         goto out_nofid;
     }
"
782,178518,,Remote,Not required,,CVE-2018-0496,https://www.cvedetails.com/cve/CVE-2018-0496/,CWE-22,Low,,Partial,,2018-06-12,5.0,Directory traversal issues in the D-Mod extractor in DFArc and DFArc2 (as well as in RTsoft's Dink Smallwood HD / ProtonSDK version) before 3.14 allow an attacker to overwrite arbitrary files on the user's system.,2018-08-07,Dir. Trav.,4,https://git.savannah.gnu.org/cgit/freedink/dfarc.git/commit/?id=40cc957f52e772f45125126439ba9333cf2d2998,40cc957f52e772f45125126439ba9333cf2d2998,,1,,,"InstallVerifyFrame::InstallVerifyFrame(const wxString& lDmodFilePath)
: InstallVerifyFrame_Base(NULL, wxID_ANY, _T(""""))
{
  mConfig = Config::GetConfig();

  prepareDialog();
  
  int flags = wxPD_AUTO_HIDE | wxPD_APP_MODAL | wxPD_REMAINING_TIME;
  wxProgressDialog lPrepareProgress(_(""Preparing""),
    _(""The D-Mod archive is being decompressed in a temporary file.""), 100, this, flags);
  
  BZip lBZip(lDmodFilePath);
  mTarFilePath = lBZip.Extract(&lPrepareProgress);
  
  if (mTarFilePath.Len() != 0)
     {
       Tar lTar(mTarFilePath);
      if (lTar.ReadHeaders() == 1) {
        this->EndModal(wxID_CANCEL);
        return;
      }
      
       wxString lDmodDescription = lTar.getmDmodDescription();
						""\n""
						""The D-Mod will be installed in subdirectory '%s'.""),
					      lTar.getInstalledDmodDirectory().c_str());
        }
      else
        {
	  int lBreakChar = lDmodDescription.Find( '\r' );
	  if ( lBreakChar <= 0 )
            {
	      lBreakChar = lDmodDescription.Find( '\n' );
            }
	  mDmodName = lDmodDescription.SubString( 0, lBreakChar - 1 );
	  this->SetTitle(_(""DFArc - Install D-Mod - "") + mDmodName);
        }
      mDmodDescription->SetValue(lDmodDescription);
      
      mInstallButton->Enable(true);
    }
","InstallVerifyFrame::InstallVerifyFrame(const wxString& lDmodFilePath)
: InstallVerifyFrame_Base(NULL, wxID_ANY, _T(""""))
{
  mConfig = Config::GetConfig();

  prepareDialog();
  
  int flags = wxPD_AUTO_HIDE | wxPD_APP_MODAL | wxPD_REMAINING_TIME;
  wxProgressDialog lPrepareProgress(_(""Preparing""),
    _(""The D-Mod archive is being decompressed in a temporary file.""), 100, this, flags);
  
  BZip lBZip(lDmodFilePath);
  mTarFilePath = lBZip.Extract(&lPrepareProgress);
  
  if (mTarFilePath.Len() != 0)
     {
       Tar lTar(mTarFilePath);
      lTar.ReadHeaders();
      
       wxString lDmodDescription = lTar.getmDmodDescription();
						""\n""
						""The D-Mod will be installed in subdirectory '%s'.""),
					      lTar.getInstalledDmodDirectory().c_str());
        }
      else
        {
	  int lBreakChar = lDmodDescription.Find( '\r' );
	  if ( lBreakChar <= 0 )
            {
	      lBreakChar = lDmodDescription.Find( '\n' );
            }
	  mDmodName = lDmodDescription.SubString( 0, lBreakChar - 1 );
	  this->SetTitle(_(""DFArc - Install D-Mod - "") + mDmodName);
        }
      mDmodDescription->SetValue(lDmodDescription);
      
      mInstallButton->Enable(true);
    }
",CPP,"      if (lTar.ReadHeaders() == 1) {
        this->EndModal(wxID_CANCEL);
        return;
      }
","      lTar.ReadHeaders();
",c14fd8aeeeadca0f49388f17eaf21b49bb754b76,"@@ -3,7 +3,7 @@
 
  * Copyright (C) 2004  Andrew Reading
  * Copyright (C) 2005, 2006  Dan Walma
- * Copyright (C) 2008  Sylvain Beucler
+ * Copyright (C) 2008, 2018  Sylvain Beucler
 
  * This file is part of GNU FreeDink
 
@@ -55,7 +55,10 @@ InstallVerifyFrame::InstallVerifyFrame(const wxString& lDmodFilePath)
     {
       // Prepare the tar file for reading
       Tar lTar(mTarFilePath);
-      lTar.ReadHeaders();
+      if (lTar.ReadHeaders() == 1) {
+        this->EndModal(wxID_CANCEL);
+        return;
+      }
      
       // Get and display the dmod description
       wxString lDmodDescription = lTar.getmDmodDescription();
@@ -122,7 +125,20 @@ void InstallVerifyFrame::onInstall(wxCommandEvent &Event)
     destdir = mConfig->mDModDir;
 
   Tar lTar(mTarFilePath);
-  lTar.ReadHeaders();
+  if (lTar.ReadHeaders() == 1) {
+    this->EndModal(wxID_CANCEL);
+    return;
+  }
+
+  if (wxDirExists(destdir + wxFileName::GetPathSeparator() + lTar.getInstalledDmodDirectory())) {
+    wxString question;
+    question.Printf(_(""Directory '%s' already exists. Continue?""), lTar.getInstalledDmodDirectory());
+    int lResult = wxMessageBox(question, _(""DFArc - Installing""),
+			       wxYES_NO | wxICON_WARNING, this);
+    if (lResult == wxNO)
+      return;
+  }
+
   int lError = lTar.Extract(destdir, &lInstallProgress);
   if (lError == 0)
     {",savannah,https://git.savannah.gnu.org/cgit/freedink/dfarc.git/tree/src/InstallVerifyFrame.cpp?id=40cc957f52e772f45125126439ba9333cf2d2998,https://git.savannah.gnu.org/cgit/freedink/dfarc.git/tree/src/InstallVerifyFrame.cpp?id=c14fd8aeeeadca0f49388f17eaf21b49bb754b76,1,"InstallVerifyFrame::InstallVerifyFrame(const wxString& lDmodFilePath)
: InstallVerifyFrame_Base(NULL, wxID_ANY, _T(""""))
{
  mConfig = Config::GetConfig();

  prepareDialog();
  
  int flags = wxPD_AUTO_HIDE | wxPD_APP_MODAL | wxPD_REMAINING_TIME;
  wxProgressDialog lPrepareProgress(_(""Preparing""),
    _(""The D-Mod archive is being decompressed in a temporary file.""), 100, this, flags);
  
  // Extract
  BZip lBZip(lDmodFilePath);
  mTarFilePath = lBZip.Extract(&lPrepareProgress);
  
  if (mTarFilePath.Len() != 0)
     {
       // Prepare the tar file for reading
       Tar lTar(mTarFilePath);
//flaw_line_below:
      lTar.ReadHeaders();
//fix_flaw_line_below:
//      if (lTar.ReadHeaders() == 1) {
//fix_flaw_line_below:
//        this->EndModal(wxID_CANCEL);
//fix_flaw_line_below:
//        return;
//fix_flaw_line_below:
//      }
      
       // Get and display the dmod description
       wxString lDmodDescription = lTar.getmDmodDescription();
						""\n""
						""The D-Mod will be installed in subdirectory '%s'.""),
					      lTar.getInstalledDmodDirectory().c_str());
        }
      else
        {
	  int lBreakChar = lDmodDescription.Find( '\r' );
	  if ( lBreakChar <= 0 )
            {
	      lBreakChar = lDmodDescription.Find( '\n' );
            }
	  mDmodName = lDmodDescription.SubString( 0, lBreakChar - 1 );
	  this->SetTitle(_(""DFArc - Install D-Mod - "") + mDmodName);
        }
      mDmodDescription->SetValue(lDmodDescription);
      
      // Re-enable the install button
      mInstallButton->Enable(true);
    }
"
783,178519,,Remote,Not required,,CVE-2018-0496,https://www.cvedetails.com/cve/CVE-2018-0496/,CWE-22,Low,,Partial,,2018-06-12,5.0,Directory traversal issues in the D-Mod extractor in DFArc and DFArc2 (as well as in RTsoft's Dink Smallwood HD / ProtonSDK version) before 3.14 allow an attacker to overwrite arbitrary files on the user's system.,2018-08-07,Dir. Trav.,9,https://git.savannah.gnu.org/cgit/freedink/dfarc.git/commit/?id=40cc957f52e772f45125126439ba9333cf2d2998,40cc957f52e772f45125126439ba9333cf2d2998,,1,,,"int Tar::ReadHeaders( void )
{
  FILE *in;
  TarHeader lHeader;
  TarRecord lRecord;
  unsigned int iBegData = 0;
  char buf_header[512];
  
  in = fopen(mFilePath.fn_str(), ""rb"");
  
  if(in == NULL)
    {
      wxLogFatalError(_(""Error: File '%s' not found!  Cannot read data.""), mFilePath.c_str());
      return 1;
    }
  
  wxString lDmodDizPath;
  mmDmodDescription = _T("""");
  mInstalledDmodDirectory = _T("""");

  int total_read = 0;
  while (true)
    {
      memset(&lHeader, 0, sizeof(TarHeader));
      memset(&lRecord, 0, sizeof(TarRecord));
      
      fread((char*)&lHeader.Name, 100, 1, in);
      fread((char*)&lHeader.Mode, 8, 1, in);
      fread((char*)&lHeader.Uid, 8, 1, in);
      fread((char*)&lHeader.Gid, 8, 1, in);
      fread((char*)&lHeader.Size, 12, 1, in);
      fread((char*)&lHeader.Mtime, 12, 1, in);
      fread((char*)&lHeader.Chksum, 8, 1, in);
      fread((char*)&lHeader.Linkflag, 1, 1, in);
      fread((char*)&lHeader.Linkname, 100, 1, in);
      fread((char*)&lHeader.Magic, 8, 1, in);
      fread((char*)&lHeader.Uname, 32, 1, in);
      fread((char*)&lHeader.Gname, 32, 1, in);
      fread((char*)&lHeader.Devmajor, 8, 1, in);
      fread((char*)&lHeader.Devminor, 8, 1, in);
      fread((char*)&lHeader.Padding, 167, 1, in);
      total_read += 512;

      if(!VerifyChecksum(&lHeader))
        {
	  wxLogFatalError(_(""Error: This .dmod file has an invalid checksum!  Cannot read file.""));
	  return 1;
        }
        
      strncpy(lRecord.Name, lHeader.Name, 100);
      
      if (strcmp(lHeader.Name, ""\xFF"") == 0)
	continue;
      
      sscanf((const char*)&lHeader.Size, ""%o"", &lRecord.iFileSize);
      lRecord.iFilePosBegin = total_read;
      
      if(strcmp(lHeader.Name, """") == 0)
        {
	  break;
        }
      
      wxString lPath(lRecord.Name, wxConvUTF8);
       wxString lPath(lRecord.Name, wxConvUTF8);
       if (mInstalledDmodDirectory.Length() == 0)
         {
	  // Security: ensure the D-Mod directory is non-empty
	  wxString firstDir = GetFirstDir(lPath);
	  if (firstDir.IsSameAs("""", true) || firstDir.IsSameAs("".."", true) || firstDir.IsSameAs(""dink"", true))
            {
	      wxLogError(_(""Error: invalid D-Mod directory.  Stopping.""));
              return 1;
            }
          mInstalledDmodDirectory = firstDir;

 	  lDmodDizPath = mInstalledDmodDirectory + _T(""dmod.diz"");
 	  lDmodDizPath.LowerCase();
         }
	}
      else
	{
	  int remaining = lRecord.iFileSize;
	  char buf[BUFSIZ];
	  while (remaining > 0)
	    {
	      if (feof(in))
		break; // TODO: error, unexpected end of file
	      int nb_read = fread(buf, 1, (remaining > BUFSIZ) ? BUFSIZ : remaining, in);
	      remaining -= nb_read;
	    }
	}
      total_read += lRecord.iFileSize;
      TarRecords.push_back(lRecord);
      
      int padding_size = (512 - (total_read % 512)) % 512;
      fread(buf_header, 1, padding_size, in);
      total_read += padding_size;
    }
","int Tar::ReadHeaders( void )
{
  FILE *in;
  TarHeader lHeader;
  TarRecord lRecord;
  unsigned int iBegData = 0;
  char buf_header[512];
  
  in = fopen(mFilePath.fn_str(), ""rb"");
  
  if(in == NULL)
    {
      wxLogFatalError(_(""Error: File '%s' not found!  Cannot read data.""), mFilePath.c_str());
      return 1;
    }
  
  wxString lDmodDizPath;
  mmDmodDescription = _T("""");
  mInstalledDmodDirectory = _T("""");

  int total_read = 0;
  while (true)
    {
      memset(&lHeader, 0, sizeof(TarHeader));
      memset(&lRecord, 0, sizeof(TarRecord));
      
      fread((char*)&lHeader.Name, 100, 1, in);
      fread((char*)&lHeader.Mode, 8, 1, in);
      fread((char*)&lHeader.Uid, 8, 1, in);
      fread((char*)&lHeader.Gid, 8, 1, in);
      fread((char*)&lHeader.Size, 12, 1, in);
      fread((char*)&lHeader.Mtime, 12, 1, in);
      fread((char*)&lHeader.Chksum, 8, 1, in);
      fread((char*)&lHeader.Linkflag, 1, 1, in);
      fread((char*)&lHeader.Linkname, 100, 1, in);
      fread((char*)&lHeader.Magic, 8, 1, in);
      fread((char*)&lHeader.Uname, 32, 1, in);
      fread((char*)&lHeader.Gname, 32, 1, in);
      fread((char*)&lHeader.Devmajor, 8, 1, in);
      fread((char*)&lHeader.Devminor, 8, 1, in);
      fread((char*)&lHeader.Padding, 167, 1, in);
      total_read += 512;

      if(!VerifyChecksum(&lHeader))
        {
	  wxLogFatalError(_(""Error: This .dmod file has an invalid checksum!  Cannot read file.""));
	  return 1;
        }
        
      strncpy(lRecord.Name, lHeader.Name, 100);
      
      if (strcmp(lHeader.Name, ""\xFF"") == 0)
	continue;
      
      sscanf((const char*)&lHeader.Size, ""%o"", &lRecord.iFileSize);
      lRecord.iFilePosBegin = total_read;
      
      if(strcmp(lHeader.Name, """") == 0)
        {
	  break;
        }
      
      wxString lPath(lRecord.Name, wxConvUTF8);
       wxString lPath(lRecord.Name, wxConvUTF8);
       if (mInstalledDmodDirectory.Length() == 0)
         {
	  mInstalledDmodDirectory = lPath.SubString( 0, lPath.Find( '/' ) );
 	  lDmodDizPath = mInstalledDmodDirectory + _T(""dmod.diz"");
 	  lDmodDizPath.LowerCase();
         }
	}
      else
	{
	  int remaining = lRecord.iFileSize;
	  char buf[BUFSIZ];
	  while (remaining > 0)
	    {
	      if (feof(in))
		break; // TODO: error, unexpected end of file
	      int nb_read = fread(buf, 1, (remaining > BUFSIZ) ? BUFSIZ : remaining, in);
	      remaining -= nb_read;
	    }
	}
      total_read += lRecord.iFileSize;
      TarRecords.push_back(lRecord);
      
      int padding_size = (512 - (total_read % 512)) % 512;
      fread(buf_header, 1, padding_size, in);
      total_read += padding_size;
    }
",CPP,"	  // Security: ensure the D-Mod directory is non-empty
	  wxString firstDir = GetFirstDir(lPath);
	  if (firstDir.IsSameAs("""", true) || firstDir.IsSameAs("".."", true) || firstDir.IsSameAs(""dink"", true))
            {
	      wxLogError(_(""Error: invalid D-Mod directory.  Stopping.""));
              return 1;
            }
          mInstalledDmodDirectory = firstDir;

","	  mInstalledDmodDirectory = lPath.SubString( 0, lPath.Find( '/' ) );
",c14fd8aeeeadca0f49388f17eaf21b49bb754b76,"@@ -3,7 +3,7 @@
 
  * Copyright (C) 2004  Andrew Reading
  * Copyright (C) 2005, 2006  Dan Walma
- * Copyright (C) 2008, 2014  Sylvain Beucler
+ * Copyright (C) 2008, 2014, 2018  Sylvain Beucler
 
  * This file is part of GNU FreeDink
 
@@ -31,6 +31,7 @@
 #include <wx/intl.h>
 #include <wx/log.h>
 #include <wx/filename.h>
+#include <wx/tokenzr.h>
 
 #include <math.h>
 #include <ext/stdio_filebuf.h>
@@ -427,7 +428,15 @@ int Tar::ReadHeaders( void )
       wxString lPath(lRecord.Name, wxConvUTF8);
       if (mInstalledDmodDirectory.Length() == 0)
         {
-	  mInstalledDmodDirectory = lPath.SubString( 0, lPath.Find( '/' ) );
+	  // Security: ensure the D-Mod directory is non-empty
+	  wxString firstDir = GetFirstDir(lPath);
+	  if (firstDir.IsSameAs("""", true) || firstDir.IsSameAs("".."", true) || firstDir.IsSameAs(""dink"", true))
+            {
+	      wxLogError(_(""Error: invalid D-Mod directory.  Stopping.""));
+              return 1;
+            }
+          mInstalledDmodDirectory = firstDir;
+
 	  lDmodDizPath = mInstalledDmodDirectory + _T(""dmod.diz"");
 	  lDmodDizPath.LowerCase();
         }
@@ -472,10 +481,6 @@ int Tar::Extract(wxString destdir, wxProgressDialog* aProgressDialog)
     wxString strBuf;
     int lError = 0;
 
-    // Remember current directory
-    wxString strCwd = ::wxGetCwd();
-
-
     // Open the file here so it doesn't error after changing.
     wxFile wx_In(mFilePath, wxFile::read);
 
@@ -495,8 +500,6 @@ int Tar::Extract(wxString destdir, wxProgressDialog* aProgressDialog)
 	wxLogFatalError(_(""Error: Cannot create directory '%s'.  Cannot extract data.""), destdir.c_str());
 	throw;
       }
-    // Move to the directory.
-    ::wxSetWorkingDirectory(destdir);
 
     // Put the data in the directories.
     __gnu_cxx::stdio_filebuf<char> filebuf(wx_In.fd(), std::ios::in);
@@ -507,10 +510,6 @@ int Tar::Extract(wxString destdir, wxProgressDialog* aProgressDialog)
     }
     wx_In.Close();
 
-
-    // We're done.  Move back.
-    ::wxSetWorkingDirectory(strCwd);
-    
     return lError;
 }
 
@@ -527,10 +526,6 @@ int Tar::ExtractData(std::istream& aTarStreamIn, wxString destdir, wxProgressDia
     aTarStreamIn.seekg(0, std::ios::beg);
     lTotalBytes = lEnd - static_cast<unsigned long>(aTarStreamIn.tellg());
 
-    // Move into the extract dir.
-    wxString lPreviousWorkingDirectory(::wxGetCwd());
-    ::wxSetWorkingDirectory(destdir);
-
     // Extract the files.
     int ebufsiz = 8192;
     char buffer[ebufsiz];
@@ -543,7 +538,16 @@ int Tar::ExtractData(std::istream& aTarStreamIn, wxString destdir, wxProgressDia
 		    /* Attempt convertion from latin-1 if not valid UTF-8 */
 		    lCurrentFilePath = wxString(lCurrentTarRecord.Name, wxConvISO8859_1);
 		  }
-		wxString lCurrentDirectory(lCurrentFilePath.substr(0, lCurrentFilePath.find_last_of('/')));
+        // Security: check if archive tries to jump out of destination directory
+        if (IsPathInsecure(lCurrentFilePath))
+        {
+            wxLogError(_(""Error: Insecure filename: '%s'.  Stopping.""), lCurrentFilePath);
+            lError = 1;
+            break;
+        }
+        // Security: ensure full, non-relative path, under destdir/
+        lCurrentFilePath = destdir + wxFileName::GetPathSeparator() + lCurrentFilePath;
+        wxString lCurrentDirectory = lCurrentFilePath.substr(0, lCurrentFilePath.find_last_of(""/\\""));
 
         // Odd bad file problem...
 	if (lCurrentFilePath.compare(_T(""\xFF"")) == 0) // ""�""
@@ -612,7 +616,6 @@ int Tar::ExtractData(std::istream& aTarStreamIn, wxString destdir, wxProgressDia
         }
     }
     aProgressDialog->Update(100, _(""Done.""));
-    ::wxSetWorkingDirectory(lPreviousWorkingDirectory);
     return lError;
 }
 
@@ -687,3 +690,45 @@ int Tar::RoundTo512(int n)
         return (n - (n % 512)) + 512;
     }
 }
+
+wxString Tar::GetFirstDir(wxString path) {
+    wxString firstDir = """";
+    wxString previousDir = """";
+    // tokenizer never returns empty strings + distinguish dir// and a/$
+    if (path.EndsWith(""/"") || path.EndsWith(""\\""))
+        path += ""dummy"";
+    wxStringTokenizer tokenizer(path, ""/\\"", wxTOKEN_STRTOK);
+    while (tokenizer.HasMoreTokens()) {
+        wxString curDir = tokenizer.GetNextToken();
+        if (curDir == '.')
+	    continue;
+        if (previousDir != """") {
+	  firstDir = previousDir;
+	  break;
+	}
+        previousDir = curDir;
+    }
+    return firstDir;
+}
+
+// Security: check if archive tries to jump out of destination directory
+bool Tar::IsPathInsecure(wxString path) {
+    // Avoid leading slashes (even if we preprend destdir)
+    if (path[0] == '/' || path[0] == '\\')
+        return true;
+    // Avoid ':' since wxFileName::Mkdir silently normalizes
+    // e.g. C:\test1\C:\test2 to C:\test2
+    if (path.Contains("":""))
+        return true;
+    // Ensure all files reside in the same subdirectory
+    if (GetFirstDir(path) != mInstalledDmodDirectory)
+        return true;
+    // Ensure there's no '..' path element
+    wxStringTokenizer tokenizer(path, ""/\\"");
+    while (tokenizer.HasMoreTokens()) {
+        wxString token = tokenizer.GetNextToken();
+        if (token == "".."")
+            return true;
+    }
+    return false;
+}",savannah,https://git.savannah.gnu.org/cgit/freedink/dfarc.git/tree/src/Tar.cpp?id=40cc957f52e772f45125126439ba9333cf2d2998,https://git.savannah.gnu.org/cgit/freedink/dfarc.git/tree/src/Tar.cpp?id=c14fd8aeeeadca0f49388f17eaf21b49bb754b76,1,"int Tar::ReadHeaders( void )
{
  FILE *in;
  TarHeader lHeader;
  TarRecord lRecord;
  unsigned int iBegData = 0;
  char buf_header[512];
  
  in = fopen(mFilePath.fn_str(), ""rb"");
  
  if(in == NULL)
    {
      wxLogFatalError(_(""Error: File '%s' not found!  Cannot read data.""), mFilePath.c_str());
      return 1;
    }
  
  wxString lDmodDizPath;
  mmDmodDescription = _T("""");
  mInstalledDmodDirectory = _T("""");

  int total_read = 0;
  while (true)
    {
      memset(&lHeader, 0, sizeof(TarHeader));
      memset(&lRecord, 0, sizeof(TarRecord));
      
      // Read the data. Dont load the whole header to a struct, you
      // never know what the memory alignment will be, especially in
      // these 32->64bits days
      fread((char*)&lHeader.Name, 100, 1, in);
      fread((char*)&lHeader.Mode, 8, 1, in);
      fread((char*)&lHeader.Uid, 8, 1, in);
      fread((char*)&lHeader.Gid, 8, 1, in);
      fread((char*)&lHeader.Size, 12, 1, in);
      fread((char*)&lHeader.Mtime, 12, 1, in);
      fread((char*)&lHeader.Chksum, 8, 1, in);
      fread((char*)&lHeader.Linkflag, 1, 1, in);
      fread((char*)&lHeader.Linkname, 100, 1, in);
      fread((char*)&lHeader.Magic, 8, 1, in);
      fread((char*)&lHeader.Uname, 32, 1, in);
      fread((char*)&lHeader.Gname, 32, 1, in);
      fread((char*)&lHeader.Devmajor, 8, 1, in);
      fread((char*)&lHeader.Devminor, 8, 1, in);
      fread((char*)&lHeader.Padding, 167, 1, in);
      total_read += 512;

      if(!VerifyChecksum(&lHeader))
        {
	  // Nope.  Exit.
	  wxLogFatalError(_(""Error: This .dmod file has an invalid checksum!  Cannot read file.""));
	  return 1;
        }
        
      strncpy(lRecord.Name, lHeader.Name, 100);
      
      // Bug fix for phantom files that aren't really files...
      // This is due to a bug in DFArc1.5 with empty files
      if (strcmp(lHeader.Name, ""\xFF"") == 0)
	continue;
      
      // Size
      sscanf((const char*)&lHeader.Size, ""%o"", &lRecord.iFileSize);
      // Start
      lRecord.iFilePosBegin = total_read;
      
      // Tar files (except for a design bug in DFArc1.5) have a
      // multitude of NULL characters at the end to round up to the
      // 10K mark.  If the header is blank, we don't have any more
      // data.
      if(strcmp(lHeader.Name, """") == 0)
        {
	  break;
        }
      //wxLogError(""%s %d"", lHeader.Name, lRecord.iFileSize);
      
      wxString lPath(lRecord.Name, wxConvUTF8);
       wxString lPath(lRecord.Name, wxConvUTF8);
       if (mInstalledDmodDirectory.Length() == 0)
         {
//flaw_line_below:
	  mInstalledDmodDirectory = lPath.SubString( 0, lPath.Find( '/' ) );
//fix_flaw_line_below:
//	  // Security: ensure the D-Mod directory is non-empty
//fix_flaw_line_below:
//	  wxString firstDir = GetFirstDir(lPath);
//fix_flaw_line_below:
//	  if (firstDir.IsSameAs("""", true) || firstDir.IsSameAs("".."", true) || firstDir.IsSameAs(""dink"", true))
//fix_flaw_line_below:
//            {
//fix_flaw_line_below:
//	      wxLogError(_(""Error: invalid D-Mod directory.  Stopping.""));
//fix_flaw_line_below:
//              return 1;
//fix_flaw_line_below:
//            }
//fix_flaw_line_below:
//          mInstalledDmodDirectory = firstDir;
//fix_flaw_line_below:
//
 	  lDmodDizPath = mInstalledDmodDirectory + _T(""dmod.diz"");
 	  lDmodDizPath.LowerCase();
         }
	}
      else
	{
	  int remaining = lRecord.iFileSize;
	  char buf[BUFSIZ];
	  while (remaining > 0)
	    {
	      if (feof(in))
		break; // TODO: error, unexpected end of file
	      int nb_read = fread(buf, 1, (remaining > BUFSIZ) ? BUFSIZ : remaining, in);
	      remaining -= nb_read;
	    }
	}
      total_read += lRecord.iFileSize;
      TarRecords.push_back(lRecord);
      
      // Move to the beginning of the next header
      int padding_size = (512 - (total_read % 512)) % 512;
      fread(buf_header, 1, padding_size, in);
      total_read += padding_size;
    }
"
832,178568,,Remote,Not required,,CVE-2015-1395,https://www.cvedetails.com/cve/CVE-2015-1395/,CWE-22,Low,,Complete,,2017-08-25,7.8,Directory traversal vulnerability in GNU patch versions which support Git-style patching before 2.7.3 allows remote attackers to write to arbitrary files with the permissions of the target user via a .. (dot dot) in a diff file name.,2017-08-29,Dir. Trav.,3,https://git.savannah.gnu.org/cgit/patch.git/commit/?id=17953b5893f7c9835f0dd2a704ba04e0371d2cbd,17953b5893f7c9835f0dd2a704ba04e0371d2cbd,,0,,,"main (int argc, char **argv)
{
    char const *val;
    bool somefailed = false;
    struct outstate outstate;
    struct stat tmpoutst;
    char numbuf[LINENUM_LENGTH_BOUND + 1];
    bool written_to_rejname = false;
    bool apply_empty_patch = false;
    mode_t file_type;
    int outfd = -1;
    bool have_git_diff = false;

    exit_failure = 2;
    set_program_name (argv[0]);
    init_time ();

    setbuf(stderr, serrbuf);

    bufsize = 8 * 1024;
    buf = xmalloc (bufsize);

    strippath = -1;

    val = getenv (""QUOTING_STYLE"");
    {
      int i = val ? argmatch (val, quoting_style_args, 0, 0) : -1;
      set_quoting_style ((struct quoting_options *) 0,
			 i < 0 ? shell_quoting_style : (enum quoting_style) i);
    }

    posixly_correct = getenv (""POSIXLY_CORRECT"") != 0;
    backup_if_mismatch = ! posixly_correct;
    patch_get = ((val = getenv (""PATCH_GET""))
		 ? numeric_string (val, true, ""PATCH_GET value"")
		 : 0);

    val = getenv (""SIMPLE_BACKUP_SUFFIX"");
    simple_backup_suffix = val && *val ? val : "".orig"";

    if ((version_control = getenv (""PATCH_VERSION_CONTROL"")))
      version_control_context = ""$PATCH_VERSION_CONTROL"";
    else if ((version_control = getenv (""VERSION_CONTROL"")))
      version_control_context = ""$VERSION_CONTROL"";

    init_backup_hash_table ();
    init_files_to_delete ();
    init_files_to_output ();

    /* parse switches */
    Argc = argc;
    Argv = argv;
    get_some_switches();

    /* Make get_date() assume that context diff headers use UTC. */
    if (set_utc)
      setenv (""TZ"", ""UTC"", 1);

    if (make_backups | backup_if_mismatch)
      backup_type = get_version (version_control_context, version_control);

    init_output (&outstate);
    if (outfile)
      outstate.ofp = open_outfile (outfile);

    /* Make sure we clean up in case of disaster.  */
    set_signals (false);

    if (inname && outfile)
      {
	/* When an input and an output filename is given and the patch is
	   empty, copy the input file to the output file.  In this case, the
	   input file must be a regular file (i.e., symlinks cannot be copied
	   this way).  */
	apply_empty_patch = true;
	file_type = S_IFREG;
	inerrno = -1;
      }
    for (
	open_patch_file (patchname);
	there_is_another_patch (! (inname || posixly_correct), &file_type)
	  || apply_empty_patch;
	reinitialize_almost_everything(),
	  apply_empty_patch = false
    ) {					/* for each patch in patch file */
      int hunk = 0;
      int failed = 0;
       bool mismatch = false;
       char const *outname = NULL;
 
      if (skip_rest_of_patch)
	somefailed = true;

       if (have_git_diff != pch_git_diff ())
 	{
 	  if (have_git_diff)
	    }
	  have_git_diff = ! have_git_diff;
	}

      if (TMPREJNAME_needs_removal)
	{
	  if (rejfp)
	    {
	      fclose (rejfp);
	      rejfp = NULL;
	    }
	  remove_if_needed (TMPREJNAME, &TMPREJNAME_needs_removal);
	}
      if (TMPOUTNAME_needs_removal)
        {
	  if (outfd != -1)
	    {
	      close (outfd);
	      outfd = -1;
	    }
	  remove_if_needed (TMPOUTNAME, &TMPOUTNAME_needs_removal);
	}

      if (! skip_rest_of_patch && ! file_type)
	{
	  say (""File %s: can't change file type from 0%o to 0%o.\n"",
	       quotearg (inname),
	       pch_mode (reverse) & S_IFMT,
	       pch_mode (! reverse) & S_IFMT);
	  skip_rest_of_patch = true;
	  somefailed = true;
	}

      if (! skip_rest_of_patch)
	{
	  if (outfile)
	    outname = outfile;
	  else if (pch_copy () || pch_rename ())
	    outname = pch_name (! strcmp (inname, pch_name (OLD)));
	  else
	    outname = inname;
	}

      if (pch_git_diff () && ! skip_rest_of_patch)
	{
	  struct stat outstat;
	  int outerrno = 0;

	  /* Try to recognize concatenated git diffs based on the SHA1 hashes
	     in the headers.  Will not always succeed for patches that rename
	     or copy files.  */

	  if (! strcmp (inname, outname))
	    {
	      if (inerrno == -1)
		inerrno = stat_file (inname, &instat);
	      outstat = instat;
	      outerrno = inerrno;
	    }
	  else
	    outerrno = stat_file (outname, &outstat);

	  if (! outerrno)
	    {
	      if (has_queued_output (&outstat))
		{
		  output_files (&outstat);
		  outerrno = stat_file (outname, &outstat);
		  inerrno = -1;
		}
	      if (! outerrno)
		set_queued_output (&outstat, true);
	    }
	}

      if (! skip_rest_of_patch)
	{
	  if (! get_input_file (inname, outname, file_type))
	    {
	      skip_rest_of_patch = true;
	      somefailed = true;
	    }
	}

      if (read_only_behavior != RO_IGNORE
	  && ! inerrno && ! S_ISLNK (instat.st_mode)
	  && access (inname, W_OK) != 0)
	{
	  say (""File %s is read-only; "", quotearg (inname));
	  if (read_only_behavior == RO_WARN)
	    say (""trying to patch anyway\n"");
	  else
	    {
	      say (""refusing to patch\n"");
	      skip_rest_of_patch = true;
	      somefailed = true;
	    }
	}

      tmpoutst.st_size = -1;
      outfd = make_tempfile (&TMPOUTNAME, 'o', outname,
			     O_WRONLY | binary_transput,
			     instat.st_mode & S_IRWXUGO);
      TMPOUTNAME_needs_removal = true;
      if (diff_type == ED_DIFF) {
	outstate.zero_output = false;
	somefailed |= skip_rest_of_patch;
	do_ed_script (inname, TMPOUTNAME, &TMPOUTNAME_needs_removal,
		      outstate.ofp);
	if (! dry_run && ! outfile && ! skip_rest_of_patch)
	  {
	    if (fstat (outfd, &tmpoutst) != 0)
	      pfatal (""%s"", TMPOUTNAME);
	    outstate.zero_output = tmpoutst.st_size == 0;
	  }
	close (outfd);
	outfd = -1;
      } else {
	int got_hunk;
	bool apply_anyway = merge;  /* don't try to reverse when merging */

	if (! skip_rest_of_patch && diff_type == GIT_BINARY_DIFF) {
	  say (""File %s: git binary diffs are not supported.\n"",
	       quotearg (outname));
	  skip_rest_of_patch = true;
	  somefailed = true;
	}
	/* initialize the patched file */
	if (! skip_rest_of_patch && ! outfile)
	  {
	    init_output (&outstate);
	    outstate.ofp = fdopen(outfd, binary_transput ? ""wb"" : ""w"");
	    if (! outstate.ofp)
	      pfatal (""%s"", TMPOUTNAME);
	  }

	/* find out where all the lines are */
	if (!skip_rest_of_patch) {
	    scan_input (inname, file_type);

	    if (verbosity != SILENT)
	      {
		bool renamed = strcmp (inname, outname);

		say (""%s %s %s%c"",
		     dry_run ? ""checking"" : ""patching"",
		     S_ISLNK (file_type) ? ""symbolic link"" : ""file"",
		     quotearg (outname), renamed ? ' ' : '\n');
		if (renamed)
		  say (""(%s from %s)\n"",
		       pch_copy () ? ""copied"" :
		       (pch_rename () ? ""renamed"" : ""read""),
		       inname);
		if (verbosity == VERBOSE)
		  say (""Using Plan %s...\n"", using_plan_a ? ""A"" : ""B"");
	      }
	}

	/* from here on, open no standard i/o files, because malloc */
	/* might misfire and we can't catch it easily */

	/* apply each hunk of patch */
	while (0 < (got_hunk = another_hunk (diff_type, reverse)))
	  {
	    lin where = 0; /* Pacify 'gcc -Wall'.  */
	    lin newwhere;
	    lin fuzz = 0;
	    lin mymaxfuzz;

	    if (merge)
	      {
		/* When in merge mode, don't apply with fuzz.  */
		mymaxfuzz = 0;
	      }
	    else
	      {
		lin prefix_context = pch_prefix_context ();
		lin suffix_context = pch_suffix_context ();
		lin context = (prefix_context < suffix_context
			       ? suffix_context : prefix_context);
		mymaxfuzz = (maxfuzz < context ? maxfuzz : context);
	      }

	    hunk++;
	    if (!skip_rest_of_patch) {
		do {
		    where = locate_hunk(fuzz);
		    if (! where || fuzz || in_offset)
		      mismatch = true;
		    if (hunk == 1 && ! where && ! (force | apply_anyway)
			&& reverse == reverse_flag_specified) {
						/* dwim for reversed patch? */
			if (!pch_swap()) {
			    say (
""Not enough memory to try swapped hunk!  Assuming unswapped.\n"");
			    continue;
			}
			/* Try again.  */
			where = locate_hunk (fuzz);
			if (where
			    && (ok_to_reverse
				(""%s patch detected!"",
				 (reverse
				  ? ""Unreversed""
				  : ""Reversed (or previously applied)""))))
			  reverse = ! reverse;
			else
			  {
			    /* Put it back to normal.  */
			    if (! pch_swap ())
			      fatal (""lost hunk on alloc error!"");
			    if (where)
			      {
				apply_anyway = true;
				fuzz--; /* Undo '++fuzz' below.  */
				where = 0;
			      }
			  }
		    }
		} while (!skip_rest_of_patch && !where
			 && ++fuzz <= mymaxfuzz);

		if (skip_rest_of_patch) {		/* just got decided */
		  if (outstate.ofp && ! outfile)
		    {
		      fclose (outstate.ofp);
		      outstate.ofp = 0;
		      outfd = -1;
		    }
		}
	    }

	    newwhere = (where ? where : pch_first()) + out_offset;
	    if (skip_rest_of_patch
		|| (merge && ! merge_hunk (hunk, &outstate, where,
					   &somefailed))
		|| (! merge
		    && ((where == 1 && pch_says_nonexistent (reverse) == 2
			 && instat.st_size)
			|| ! where
			|| ! apply_hunk (&outstate, where))))
	      {
		abort_hunk (outname, ! failed, reverse);
		failed++;
		if (verbosity == VERBOSE ||
		    (! skip_rest_of_patch && verbosity != SILENT))
		  say (""Hunk #%d %s at %s%s.\n"", hunk,
		       skip_rest_of_patch ? ""ignored"" : ""FAILED"",
		       format_linenum (numbuf, newwhere),
		       ! skip_rest_of_patch && check_line_endings (newwhere)
			 ?  "" (different line endings)"" : """");
	      }
	    else if (! merge &&
		     (verbosity == VERBOSE
		      || (verbosity != SILENT && (fuzz || in_offset))))
	      {
		say (""Hunk #%d succeeded at %s"", hunk,
		     format_linenum (numbuf, newwhere));
		if (fuzz)
		  say ("" with fuzz %s"", format_linenum (numbuf, fuzz));
		if (in_offset)
		  say ("" (offset %s line%s)"",
		       format_linenum (numbuf, in_offset),
		       ""s"" + (in_offset == 1));
		say ("".\n"");
	      }
	  }

	if (!skip_rest_of_patch)
	  {
	    if (got_hunk < 0  &&  using_plan_a)
	      {
		if (outfile)
		  fatal (""out of memory using Plan A"");
		say (""\n\nRan out of memory using Plan A -- trying again...\n\n"");
		if (outstate.ofp)
		  {
		    fclose (outstate.ofp);
		    outstate.ofp = 0;
		  }
		continue;
	      }

	    /* Finish spewing out the new file.  */
	    if (! spew_output (&outstate, &tmpoutst))
	      {
		say (""Skipping patch.\n"");
		skip_rest_of_patch = true;
	      }
	  }
      }

      /* and put the output where desired */
      ignore_signals ();
      if (! skip_rest_of_patch && ! outfile) {
	  bool backup = make_backups
			|| (backup_if_mismatch && (mismatch | failed));
	  if (outstate.zero_output
	      && (remove_empty_files
		  || (pch_says_nonexistent (! reverse) == 2
		      && ! posixly_correct)
		  || S_ISLNK (file_type)))
	    {
	      if (! dry_run)
		output_file (NULL, NULL, NULL, outname,
			     (inname == outname) ? &instat : NULL,
			     file_type | 0, backup);
	    }
	  else
	    {
	      if (! outstate.zero_output
		  && pch_says_nonexistent (! reverse) == 2
		  && (remove_empty_files || ! posixly_correct)
		  && ! (merge && somefailed))
		{
		  mismatch = true;
		  somefailed = true;
		  if (verbosity != SILENT)
		    say (""Not deleting file %s as content differs from patch\n"",
			 quotearg (outname));
		}

	      if (! dry_run)
		{
		  mode_t old_mode = pch_mode (reverse);
		  mode_t new_mode = pch_mode (! reverse);
		  bool set_mode = new_mode && old_mode != new_mode;

		  /* Avoid replacing files when nothing has changed.  */
		  if (failed < hunk || diff_type == ED_DIFF || set_mode
		      || pch_copy () || pch_rename ())
		    {
		      enum file_attributes attr = 0;
		      struct timespec new_time = pch_timestamp (! reverse);
		      mode_t mode = file_type |
			  ((new_mode ? new_mode : instat.st_mode) & S_IRWXUGO);

		      if ((set_time | set_utc) && new_time.tv_sec != -1)
			{
			  struct timespec old_time = pch_timestamp (reverse);

			  if (! force && ! inerrno
			      && pch_says_nonexistent (reverse) != 2
			      && old_time.tv_sec != -1
			      && timespec_cmp (old_time,
					       get_stat_mtime (&instat)))
			    say (""Not setting time of file %s ""
				 ""(time mismatch)\n"",
				 quotearg (outname));
			  else if (! force && (mismatch | failed))
			    say (""Not setting time of file %s ""
				 ""(contents mismatch)\n"",
				 quotearg (outname));
			  else
			    attr |= FA_TIMES;
			}

		      if (inerrno)
			set_file_attributes (TMPOUTNAME, attr, NULL, NULL,
					     mode, &new_time);
		      else
			{
			  attr |= FA_IDS | FA_MODE | FA_XATTRS;
			  set_file_attributes (TMPOUTNAME, attr, inname, &instat,
					       mode, &new_time);
			}

		      output_file (TMPOUTNAME, &TMPOUTNAME_needs_removal,
				   &tmpoutst, outname, NULL, mode, backup);

		      if (pch_rename ())
			output_file (NULL, NULL, NULL, inname, &instat,
				     mode, backup);
		    }
		  else
		    output_file (outname, NULL, &tmpoutst, NULL, NULL,
				 file_type | 0, backup);
		}
	    }
      }
      if (diff_type != ED_DIFF) {
	struct stat rejst;

	if (failed) {
	    if (fstat (fileno (rejfp), &rejst) != 0 || fclose (rejfp) != 0)
	      write_fatal ();
	    rejfp = NULL;
	    somefailed = true;
	    say (""%d out of %d hunk%s %s"", failed, hunk, ""s"" + (hunk == 1),
		 skip_rest_of_patch ? ""ignored"" : ""FAILED"");
	    if (outname && (! rejname || strcmp (rejname, ""-"") != 0)) {
		char *rej = rejname;
		if (!rejname) {
		    /* FIXME: This should really be done differently!  */
		    const char *s = simple_backup_suffix;
		    size_t len;
		    simple_backup_suffix = "".rej"";
		    rej = find_backup_file_name (outname, simple_backups);
		    len = strlen (rej);
		    if (rej[len - 1] == '~')
		      rej[len - 1] = '#';
		    simple_backup_suffix = s;
		}
		if (! dry_run)
		  {
		    say ("" -- saving rejects to file %s\n"", quotearg (rej));
		    if (rejname)
		      {
			if (! written_to_rejname)
			  {
			    copy_file (TMPREJNAME, rejname, 0, 0,
				       S_IFREG | 0666, true);
			    written_to_rejname = true;
			  }
			else
			  append_to_file (TMPREJNAME, rejname);
		      }
		    else
		      {
			struct stat oldst;
			int olderrno;

			olderrno = stat_file (rej, &oldst);
			if (olderrno && olderrno != ENOENT)
			  write_fatal ();
		        if (! olderrno && lookup_file_id (&oldst) == CREATED)
			  append_to_file (TMPREJNAME, rej);
			else
			  move_file (TMPREJNAME, &TMPREJNAME_needs_removal,
				     &rejst, rej, S_IFREG | 0666, false);
		      }
		  }
		else
		  say (""\n"");
		if (!rejname)
		    free (rej);
	    } else
	      say (""\n"");
	}
      }
      set_signals (true);
    }
","main (int argc, char **argv)
{
    char const *val;
    bool somefailed = false;
    struct outstate outstate;
    struct stat tmpoutst;
    char numbuf[LINENUM_LENGTH_BOUND + 1];
    bool written_to_rejname = false;
    bool apply_empty_patch = false;
    mode_t file_type;
    int outfd = -1;
    bool have_git_diff = false;

    exit_failure = 2;
    set_program_name (argv[0]);
    init_time ();

    setbuf(stderr, serrbuf);

    bufsize = 8 * 1024;
    buf = xmalloc (bufsize);

    strippath = -1;

    val = getenv (""QUOTING_STYLE"");
    {
      int i = val ? argmatch (val, quoting_style_args, 0, 0) : -1;
      set_quoting_style ((struct quoting_options *) 0,
			 i < 0 ? shell_quoting_style : (enum quoting_style) i);
    }

    posixly_correct = getenv (""POSIXLY_CORRECT"") != 0;
    backup_if_mismatch = ! posixly_correct;
    patch_get = ((val = getenv (""PATCH_GET""))
		 ? numeric_string (val, true, ""PATCH_GET value"")
		 : 0);

    val = getenv (""SIMPLE_BACKUP_SUFFIX"");
    simple_backup_suffix = val && *val ? val : "".orig"";

    if ((version_control = getenv (""PATCH_VERSION_CONTROL"")))
      version_control_context = ""$PATCH_VERSION_CONTROL"";
    else if ((version_control = getenv (""VERSION_CONTROL"")))
      version_control_context = ""$VERSION_CONTROL"";

    init_backup_hash_table ();
    init_files_to_delete ();
    init_files_to_output ();

    /* parse switches */
    Argc = argc;
    Argv = argv;
    get_some_switches();

    /* Make get_date() assume that context diff headers use UTC. */
    if (set_utc)
      setenv (""TZ"", ""UTC"", 1);

    if (make_backups | backup_if_mismatch)
      backup_type = get_version (version_control_context, version_control);

    init_output (&outstate);
    if (outfile)
      outstate.ofp = open_outfile (outfile);

    /* Make sure we clean up in case of disaster.  */
    set_signals (false);

    if (inname && outfile)
      {
	/* When an input and an output filename is given and the patch is
	   empty, copy the input file to the output file.  In this case, the
	   input file must be a regular file (i.e., symlinks cannot be copied
	   this way).  */
	apply_empty_patch = true;
	file_type = S_IFREG;
	inerrno = -1;
      }
    for (
	open_patch_file (patchname);
	there_is_another_patch (! (inname || posixly_correct), &file_type)
	  || apply_empty_patch;
	reinitialize_almost_everything(),
	  apply_empty_patch = false
    ) {					/* for each patch in patch file */
      int hunk = 0;
      int failed = 0;
       bool mismatch = false;
       char const *outname = NULL;
 
       if (have_git_diff != pch_git_diff ())
 	{
 	  if (have_git_diff)
	    }
	  have_git_diff = ! have_git_diff;
	}

      if (TMPREJNAME_needs_removal)
	{
	  if (rejfp)
	    {
	      fclose (rejfp);
	      rejfp = NULL;
	    }
	  remove_if_needed (TMPREJNAME, &TMPREJNAME_needs_removal);
	}
      if (TMPOUTNAME_needs_removal)
        {
	  if (outfd != -1)
	    {
	      close (outfd);
	      outfd = -1;
	    }
	  remove_if_needed (TMPOUTNAME, &TMPOUTNAME_needs_removal);
	}

      if (! skip_rest_of_patch && ! file_type)
	{
	  say (""File %s: can't change file type from 0%o to 0%o.\n"",
	       quotearg (inname),
	       pch_mode (reverse) & S_IFMT,
	       pch_mode (! reverse) & S_IFMT);
	  skip_rest_of_patch = true;
	  somefailed = true;
	}

      if (! skip_rest_of_patch)
	{
	  if (outfile)
	    outname = outfile;
	  else if (pch_copy () || pch_rename ())
	    outname = pch_name (! strcmp (inname, pch_name (OLD)));
	  else
	    outname = inname;
	}

      if (pch_git_diff () && ! skip_rest_of_patch)
	{
	  struct stat outstat;
	  int outerrno = 0;

	  /* Try to recognize concatenated git diffs based on the SHA1 hashes
	     in the headers.  Will not always succeed for patches that rename
	     or copy files.  */

	  if (! strcmp (inname, outname))
	    {
	      if (inerrno == -1)
		inerrno = stat_file (inname, &instat);
	      outstat = instat;
	      outerrno = inerrno;
	    }
	  else
	    outerrno = stat_file (outname, &outstat);

	  if (! outerrno)
	    {
	      if (has_queued_output (&outstat))
		{
		  output_files (&outstat);
		  outerrno = stat_file (outname, &outstat);
		  inerrno = -1;
		}
	      if (! outerrno)
		set_queued_output (&outstat, true);
	    }
	}

      if (! skip_rest_of_patch)
	{
	  if (! get_input_file (inname, outname, file_type))
	    {
	      skip_rest_of_patch = true;
	      somefailed = true;
	    }
	}

      if (read_only_behavior != RO_IGNORE
	  && ! inerrno && ! S_ISLNK (instat.st_mode)
	  && access (inname, W_OK) != 0)
	{
	  say (""File %s is read-only; "", quotearg (inname));
	  if (read_only_behavior == RO_WARN)
	    say (""trying to patch anyway\n"");
	  else
	    {
	      say (""refusing to patch\n"");
	      skip_rest_of_patch = true;
	      somefailed = true;
	    }
	}

      tmpoutst.st_size = -1;
      outfd = make_tempfile (&TMPOUTNAME, 'o', outname,
			     O_WRONLY | binary_transput,
			     instat.st_mode & S_IRWXUGO);
      TMPOUTNAME_needs_removal = true;
      if (diff_type == ED_DIFF) {
	outstate.zero_output = false;
	somefailed |= skip_rest_of_patch;
	do_ed_script (inname, TMPOUTNAME, &TMPOUTNAME_needs_removal,
		      outstate.ofp);
	if (! dry_run && ! outfile && ! skip_rest_of_patch)
	  {
	    if (fstat (outfd, &tmpoutst) != 0)
	      pfatal (""%s"", TMPOUTNAME);
	    outstate.zero_output = tmpoutst.st_size == 0;
	  }
	close (outfd);
	outfd = -1;
      } else {
	int got_hunk;
	bool apply_anyway = merge;  /* don't try to reverse when merging */

	if (! skip_rest_of_patch && diff_type == GIT_BINARY_DIFF) {
	  say (""File %s: git binary diffs are not supported.\n"",
	       quotearg (outname));
	  skip_rest_of_patch = true;
	  somefailed = true;
	}
	/* initialize the patched file */
	if (! skip_rest_of_patch && ! outfile)
	  {
	    init_output (&outstate);
	    outstate.ofp = fdopen(outfd, binary_transput ? ""wb"" : ""w"");
	    if (! outstate.ofp)
	      pfatal (""%s"", TMPOUTNAME);
	  }

	/* find out where all the lines are */
	if (!skip_rest_of_patch) {
	    scan_input (inname, file_type);

	    if (verbosity != SILENT)
	      {
		bool renamed = strcmp (inname, outname);

		say (""%s %s %s%c"",
		     dry_run ? ""checking"" : ""patching"",
		     S_ISLNK (file_type) ? ""symbolic link"" : ""file"",
		     quotearg (outname), renamed ? ' ' : '\n');
		if (renamed)
		  say (""(%s from %s)\n"",
		       pch_copy () ? ""copied"" :
		       (pch_rename () ? ""renamed"" : ""read""),
		       inname);
		if (verbosity == VERBOSE)
		  say (""Using Plan %s...\n"", using_plan_a ? ""A"" : ""B"");
	      }
	}

	/* from here on, open no standard i/o files, because malloc */
	/* might misfire and we can't catch it easily */

	/* apply each hunk of patch */
	while (0 < (got_hunk = another_hunk (diff_type, reverse)))
	  {
	    lin where = 0; /* Pacify 'gcc -Wall'.  */
	    lin newwhere;
	    lin fuzz = 0;
	    lin mymaxfuzz;

	    if (merge)
	      {
		/* When in merge mode, don't apply with fuzz.  */
		mymaxfuzz = 0;
	      }
	    else
	      {
		lin prefix_context = pch_prefix_context ();
		lin suffix_context = pch_suffix_context ();
		lin context = (prefix_context < suffix_context
			       ? suffix_context : prefix_context);
		mymaxfuzz = (maxfuzz < context ? maxfuzz : context);
	      }

	    hunk++;
	    if (!skip_rest_of_patch) {
		do {
		    where = locate_hunk(fuzz);
		    if (! where || fuzz || in_offset)
		      mismatch = true;
		    if (hunk == 1 && ! where && ! (force | apply_anyway)
			&& reverse == reverse_flag_specified) {
						/* dwim for reversed patch? */
			if (!pch_swap()) {
			    say (
""Not enough memory to try swapped hunk!  Assuming unswapped.\n"");
			    continue;
			}
			/* Try again.  */
			where = locate_hunk (fuzz);
			if (where
			    && (ok_to_reverse
				(""%s patch detected!"",
				 (reverse
				  ? ""Unreversed""
				  : ""Reversed (or previously applied)""))))
			  reverse = ! reverse;
			else
			  {
			    /* Put it back to normal.  */
			    if (! pch_swap ())
			      fatal (""lost hunk on alloc error!"");
			    if (where)
			      {
				apply_anyway = true;
				fuzz--; /* Undo '++fuzz' below.  */
				where = 0;
			      }
			  }
		    }
		} while (!skip_rest_of_patch && !where
			 && ++fuzz <= mymaxfuzz);

		if (skip_rest_of_patch) {		/* just got decided */
		  if (outstate.ofp && ! outfile)
		    {
		      fclose (outstate.ofp);
		      outstate.ofp = 0;
		      outfd = -1;
		    }
		}
	    }

	    newwhere = (where ? where : pch_first()) + out_offset;
	    if (skip_rest_of_patch
		|| (merge && ! merge_hunk (hunk, &outstate, where,
					   &somefailed))
		|| (! merge
		    && ((where == 1 && pch_says_nonexistent (reverse) == 2
			 && instat.st_size)
			|| ! where
			|| ! apply_hunk (&outstate, where))))
	      {
		abort_hunk (outname, ! failed, reverse);
		failed++;
		if (verbosity == VERBOSE ||
		    (! skip_rest_of_patch && verbosity != SILENT))
		  say (""Hunk #%d %s at %s%s.\n"", hunk,
		       skip_rest_of_patch ? ""ignored"" : ""FAILED"",
		       format_linenum (numbuf, newwhere),
		       ! skip_rest_of_patch && check_line_endings (newwhere)
			 ?  "" (different line endings)"" : """");
	      }
	    else if (! merge &&
		     (verbosity == VERBOSE
		      || (verbosity != SILENT && (fuzz || in_offset))))
	      {
		say (""Hunk #%d succeeded at %s"", hunk,
		     format_linenum (numbuf, newwhere));
		if (fuzz)
		  say ("" with fuzz %s"", format_linenum (numbuf, fuzz));
		if (in_offset)
		  say ("" (offset %s line%s)"",
		       format_linenum (numbuf, in_offset),
		       ""s"" + (in_offset == 1));
		say ("".\n"");
	      }
	  }

	if (!skip_rest_of_patch)
	  {
	    if (got_hunk < 0  &&  using_plan_a)
	      {
		if (outfile)
		  fatal (""out of memory using Plan A"");
		say (""\n\nRan out of memory using Plan A -- trying again...\n\n"");
		if (outstate.ofp)
		  {
		    fclose (outstate.ofp);
		    outstate.ofp = 0;
		  }
		continue;
	      }

	    /* Finish spewing out the new file.  */
	    if (! spew_output (&outstate, &tmpoutst))
	      {
		say (""Skipping patch.\n"");
		skip_rest_of_patch = true;
	      }
	  }
      }

      /* and put the output where desired */
      ignore_signals ();
      if (! skip_rest_of_patch && ! outfile) {
	  bool backup = make_backups
			|| (backup_if_mismatch && (mismatch | failed));
	  if (outstate.zero_output
	      && (remove_empty_files
		  || (pch_says_nonexistent (! reverse) == 2
		      && ! posixly_correct)
		  || S_ISLNK (file_type)))
	    {
	      if (! dry_run)
		output_file (NULL, NULL, NULL, outname,
			     (inname == outname) ? &instat : NULL,
			     file_type | 0, backup);
	    }
	  else
	    {
	      if (! outstate.zero_output
		  && pch_says_nonexistent (! reverse) == 2
		  && (remove_empty_files || ! posixly_correct)
		  && ! (merge && somefailed))
		{
		  mismatch = true;
		  somefailed = true;
		  if (verbosity != SILENT)
		    say (""Not deleting file %s as content differs from patch\n"",
			 quotearg (outname));
		}

	      if (! dry_run)
		{
		  mode_t old_mode = pch_mode (reverse);
		  mode_t new_mode = pch_mode (! reverse);
		  bool set_mode = new_mode && old_mode != new_mode;

		  /* Avoid replacing files when nothing has changed.  */
		  if (failed < hunk || diff_type == ED_DIFF || set_mode
		      || pch_copy () || pch_rename ())
		    {
		      enum file_attributes attr = 0;
		      struct timespec new_time = pch_timestamp (! reverse);
		      mode_t mode = file_type |
			  ((new_mode ? new_mode : instat.st_mode) & S_IRWXUGO);

		      if ((set_time | set_utc) && new_time.tv_sec != -1)
			{
			  struct timespec old_time = pch_timestamp (reverse);

			  if (! force && ! inerrno
			      && pch_says_nonexistent (reverse) != 2
			      && old_time.tv_sec != -1
			      && timespec_cmp (old_time,
					       get_stat_mtime (&instat)))
			    say (""Not setting time of file %s ""
				 ""(time mismatch)\n"",
				 quotearg (outname));
			  else if (! force && (mismatch | failed))
			    say (""Not setting time of file %s ""
				 ""(contents mismatch)\n"",
				 quotearg (outname));
			  else
			    attr |= FA_TIMES;
			}

		      if (inerrno)
			set_file_attributes (TMPOUTNAME, attr, NULL, NULL,
					     mode, &new_time);
		      else
			{
			  attr |= FA_IDS | FA_MODE | FA_XATTRS;
			  set_file_attributes (TMPOUTNAME, attr, inname, &instat,
					       mode, &new_time);
			}

		      output_file (TMPOUTNAME, &TMPOUTNAME_needs_removal,
				   &tmpoutst, outname, NULL, mode, backup);

		      if (pch_rename ())
			output_file (NULL, NULL, NULL, inname, &instat,
				     mode, backup);
		    }
		  else
		    output_file (outname, NULL, &tmpoutst, NULL, NULL,
				 file_type | 0, backup);
		}
	    }
      }
      if (diff_type != ED_DIFF) {
	struct stat rejst;

	if (failed) {
	    if (fstat (fileno (rejfp), &rejst) != 0 || fclose (rejfp) != 0)
	      write_fatal ();
	    rejfp = NULL;
	    somefailed = true;
	    say (""%d out of %d hunk%s %s"", failed, hunk, ""s"" + (hunk == 1),
		 skip_rest_of_patch ? ""ignored"" : ""FAILED"");
	    if (outname && (! rejname || strcmp (rejname, ""-"") != 0)) {
		char *rej = rejname;
		if (!rejname) {
		    /* FIXME: This should really be done differently!  */
		    const char *s = simple_backup_suffix;
		    size_t len;
		    simple_backup_suffix = "".rej"";
		    rej = find_backup_file_name (outname, simple_backups);
		    len = strlen (rej);
		    if (rej[len - 1] == '~')
		      rej[len - 1] = '#';
		    simple_backup_suffix = s;
		}
		if (! dry_run)
		  {
		    say ("" -- saving rejects to file %s\n"", quotearg (rej));
		    if (rejname)
		      {
			if (! written_to_rejname)
			  {
			    copy_file (TMPREJNAME, rejname, 0, 0,
				       S_IFREG | 0666, true);
			    written_to_rejname = true;
			  }
			else
			  append_to_file (TMPREJNAME, rejname);
		      }
		    else
		      {
			struct stat oldst;
			int olderrno;

			olderrno = stat_file (rej, &oldst);
			if (olderrno && olderrno != ENOENT)
			  write_fatal ();
		        if (! olderrno && lookup_file_id (&oldst) == CREATED)
			  append_to_file (TMPREJNAME, rej);
			else
			  move_file (TMPREJNAME, &TMPREJNAME_needs_removal,
				     &rejst, rej, S_IFREG | 0666, false);
		      }
		  }
		else
		  say (""\n"");
		if (!rejname)
		    free (rej);
	    } else
	      say (""\n"");
	}
      }
      set_signals (true);
    }
",C,"      if (skip_rest_of_patch)
	somefailed = true;

",,0c08d7a902c6fdd49b704623a12d8d672ef18944,"@@ -196,6 +196,9 @@ main (int argc, char **argv)
       bool mismatch = false;
       char const *outname = NULL;
 
+      if (skip_rest_of_patch)
+	somefailed = true;
+
       if (have_git_diff != pch_git_diff ())
 	{
 	  if (have_git_diff)",savannah,https://git.savannah.gnu.org/cgit/patch.git/tree/src/patch.c?id=17953b5893f7c9835f0dd2a704ba04e0371d2cbd,https://git.savannah.gnu.org/cgit/patch.git/tree/src/patch.c?id=0c08d7a902c6fdd49b704623a12d8d672ef18944,1,"main (int argc, char **argv)
{
    char const *val;
    bool somefailed = false;
    struct outstate outstate;
    struct stat tmpoutst;
    char numbuf[LINENUM_LENGTH_BOUND + 1];
    bool written_to_rejname = false;
    bool apply_empty_patch = false;
    mode_t file_type;
    int outfd = -1;
    bool have_git_diff = false;

    exit_failure = 2;
    set_program_name (argv[0]);
    init_time ();

    setbuf(stderr, serrbuf);

    bufsize = 8 * 1024;
    buf = xmalloc (bufsize);

    strippath = -1;

    val = getenv (""QUOTING_STYLE"");
    {
      int i = val ? argmatch (val, quoting_style_args, 0, 0) : -1;
      set_quoting_style ((struct quoting_options *) 0,
			 i < 0 ? shell_quoting_style : (enum quoting_style) i);
    }

    posixly_correct = getenv (""POSIXLY_CORRECT"") != 0;
    backup_if_mismatch = ! posixly_correct;
    patch_get = ((val = getenv (""PATCH_GET""))
		 ? numeric_string (val, true, ""PATCH_GET value"")
		 : 0);

    val = getenv (""SIMPLE_BACKUP_SUFFIX"");
    simple_backup_suffix = val && *val ? val : "".orig"";

    if ((version_control = getenv (""PATCH_VERSION_CONTROL"")))
      version_control_context = ""$PATCH_VERSION_CONTROL"";
    else if ((version_control = getenv (""VERSION_CONTROL"")))
      version_control_context = ""$VERSION_CONTROL"";

    init_backup_hash_table ();
    init_files_to_delete ();
    init_files_to_output ();

    /* parse switches */
    Argc = argc;
    Argv = argv;
    get_some_switches();

    /* Make get_date() assume that context diff headers use UTC. */
    if (set_utc)
      setenv (""TZ"", ""UTC"", 1);

    if (make_backups | backup_if_mismatch)
      backup_type = get_version (version_control_context, version_control);

    init_output (&outstate);
    if (outfile)
      outstate.ofp = open_outfile (outfile);

    /* Make sure we clean up in case of disaster.  */
    set_signals (false);

    if (inname && outfile)
      {
	/* When an input and an output filename is given and the patch is
	   empty, copy the input file to the output file.  In this case, the
	   input file must be a regular file (i.e., symlinks cannot be copied
	   this way).  */
	apply_empty_patch = true;
	file_type = S_IFREG;
	inerrno = -1;
      }
    for (
	open_patch_file (patchname);
	there_is_another_patch (! (inname || posixly_correct), &file_type)
	  || apply_empty_patch;
	reinitialize_almost_everything(),
	  apply_empty_patch = false
    ) {					/* for each patch in patch file */
      int hunk = 0;
      int failed = 0;
       bool mismatch = false;
       char const *outname = NULL;
 
//fix_flaw_line_below:
//      if (skip_rest_of_patch)
//fix_flaw_line_below:
//	somefailed = true;
//fix_flaw_line_below:
//
       if (have_git_diff != pch_git_diff ())
 	{
 	  if (have_git_diff)
	    }
	  have_git_diff = ! have_git_diff;
	}

      if (TMPREJNAME_needs_removal)
	{
	  if (rejfp)
	    {
	      fclose (rejfp);
	      rejfp = NULL;
	    }
	  remove_if_needed (TMPREJNAME, &TMPREJNAME_needs_removal);
	}
      if (TMPOUTNAME_needs_removal)
        {
	  if (outfd != -1)
	    {
	      close (outfd);
	      outfd = -1;
	    }
	  remove_if_needed (TMPOUTNAME, &TMPOUTNAME_needs_removal);
	}

      if (! skip_rest_of_patch && ! file_type)
	{
	  say (""File %s: can't change file type from 0%o to 0%o.\n"",
	       quotearg (inname),
	       pch_mode (reverse) & S_IFMT,
	       pch_mode (! reverse) & S_IFMT);
	  skip_rest_of_patch = true;
	  somefailed = true;
	}

      if (! skip_rest_of_patch)
	{
	  if (outfile)
	    outname = outfile;
	  else if (pch_copy () || pch_rename ())
	    outname = pch_name (! strcmp (inname, pch_name (OLD)));
	  else
	    outname = inname;
	}

      if (pch_git_diff () && ! skip_rest_of_patch)
	{
	  struct stat outstat;
	  int outerrno = 0;

	  /* Try to recognize concatenated git diffs based on the SHA1 hashes
	     in the headers.  Will not always succeed for patches that rename
	     or copy files.  */

	  if (! strcmp (inname, outname))
	    {
	      if (inerrno == -1)
		inerrno = stat_file (inname, &instat);
	      outstat = instat;
	      outerrno = inerrno;
	    }
	  else
	    outerrno = stat_file (outname, &outstat);

	  if (! outerrno)
	    {
	      if (has_queued_output (&outstat))
		{
		  output_files (&outstat);
		  outerrno = stat_file (outname, &outstat);
		  inerrno = -1;
		}
	      if (! outerrno)
		set_queued_output (&outstat, true);
	    }
	}

      if (! skip_rest_of_patch)
	{
	  if (! get_input_file (inname, outname, file_type))
	    {
	      skip_rest_of_patch = true;
	      somefailed = true;
	    }
	}

      if (read_only_behavior != RO_IGNORE
	  && ! inerrno && ! S_ISLNK (instat.st_mode)
	  && access (inname, W_OK) != 0)
	{
	  say (""File %s is read-only; "", quotearg (inname));
	  if (read_only_behavior == RO_WARN)
	    say (""trying to patch anyway\n"");
	  else
	    {
	      say (""refusing to patch\n"");
	      skip_rest_of_patch = true;
	      somefailed = true;
	    }
	}

      tmpoutst.st_size = -1;
      outfd = make_tempfile (&TMPOUTNAME, 'o', outname,
			     O_WRONLY | binary_transput,
			     instat.st_mode & S_IRWXUGO);
      TMPOUTNAME_needs_removal = true;
      if (diff_type == ED_DIFF) {
	outstate.zero_output = false;
	somefailed |= skip_rest_of_patch;
	do_ed_script (inname, TMPOUTNAME, &TMPOUTNAME_needs_removal,
		      outstate.ofp);
	if (! dry_run && ! outfile && ! skip_rest_of_patch)
	  {
	    if (fstat (outfd, &tmpoutst) != 0)
	      pfatal (""%s"", TMPOUTNAME);
	    outstate.zero_output = tmpoutst.st_size == 0;
	  }
	close (outfd);
	outfd = -1;
      } else {
	int got_hunk;
	bool apply_anyway = merge;  /* don't try to reverse when merging */

	if (! skip_rest_of_patch && diff_type == GIT_BINARY_DIFF) {
	  say (""File %s: git binary diffs are not supported.\n"",
	       quotearg (outname));
	  skip_rest_of_patch = true;
	  somefailed = true;
	}
	/* initialize the patched file */
	if (! skip_rest_of_patch && ! outfile)
	  {
	    init_output (&outstate);
	    outstate.ofp = fdopen(outfd, binary_transput ? ""wb"" : ""w"");
	    if (! outstate.ofp)
	      pfatal (""%s"", TMPOUTNAME);
	  }

	/* find out where all the lines are */
	if (!skip_rest_of_patch) {
	    scan_input (inname, file_type);

	    if (verbosity != SILENT)
	      {
		bool renamed = strcmp (inname, outname);

		say (""%s %s %s%c"",
		     dry_run ? ""checking"" : ""patching"",
		     S_ISLNK (file_type) ? ""symbolic link"" : ""file"",
		     quotearg (outname), renamed ? ' ' : '\n');
		if (renamed)
		  say (""(%s from %s)\n"",
		       pch_copy () ? ""copied"" :
		       (pch_rename () ? ""renamed"" : ""read""),
		       inname);
		if (verbosity == VERBOSE)
		  say (""Using Plan %s...\n"", using_plan_a ? ""A"" : ""B"");
	      }
	}

	/* from here on, open no standard i/o files, because malloc */
	/* might misfire and we can't catch it easily */

	/* apply each hunk of patch */
	while (0 < (got_hunk = another_hunk (diff_type, reverse)))
	  {
	    lin where = 0; /* Pacify 'gcc -Wall'.  */
	    lin newwhere;
	    lin fuzz = 0;
	    lin mymaxfuzz;

	    if (merge)
	      {
		/* When in merge mode, don't apply with fuzz.  */
		mymaxfuzz = 0;
	      }
	    else
	      {
		lin prefix_context = pch_prefix_context ();
		lin suffix_context = pch_suffix_context ();
		lin context = (prefix_context < suffix_context
			       ? suffix_context : prefix_context);
		mymaxfuzz = (maxfuzz < context ? maxfuzz : context);
	      }

	    hunk++;
	    if (!skip_rest_of_patch) {
		do {
		    where = locate_hunk(fuzz);
		    if (! where || fuzz || in_offset)
		      mismatch = true;
		    if (hunk == 1 && ! where && ! (force | apply_anyway)
			&& reverse == reverse_flag_specified) {
						/* dwim for reversed patch? */
			if (!pch_swap()) {
			    say (
""Not enough memory to try swapped hunk!  Assuming unswapped.\n"");
			    continue;
			}
			/* Try again.  */
			where = locate_hunk (fuzz);
			if (where
			    && (ok_to_reverse
				(""%s patch detected!"",
				 (reverse
				  ? ""Unreversed""
				  : ""Reversed (or previously applied)""))))
			  reverse = ! reverse;
			else
			  {
			    /* Put it back to normal.  */
			    if (! pch_swap ())
			      fatal (""lost hunk on alloc error!"");
			    if (where)
			      {
				apply_anyway = true;
				fuzz--; /* Undo '++fuzz' below.  */
				where = 0;
			      }
			  }
		    }
		} while (!skip_rest_of_patch && !where
			 && ++fuzz <= mymaxfuzz);

		if (skip_rest_of_patch) {		/* just got decided */
		  if (outstate.ofp && ! outfile)
		    {
		      fclose (outstate.ofp);
		      outstate.ofp = 0;
		      outfd = -1;
		    }
		}
	    }

	    newwhere = (where ? where : pch_first()) + out_offset;
	    if (skip_rest_of_patch
		|| (merge && ! merge_hunk (hunk, &outstate, where,
					   &somefailed))
		|| (! merge
		    && ((where == 1 && pch_says_nonexistent (reverse) == 2
			 && instat.st_size)
			|| ! where
			|| ! apply_hunk (&outstate, where))))
	      {
		abort_hunk (outname, ! failed, reverse);
		failed++;
		if (verbosity == VERBOSE ||
		    (! skip_rest_of_patch && verbosity != SILENT))
		  say (""Hunk #%d %s at %s%s.\n"", hunk,
		       skip_rest_of_patch ? ""ignored"" : ""FAILED"",
		       format_linenum (numbuf, newwhere),
		       ! skip_rest_of_patch && check_line_endings (newwhere)
			 ?  "" (different line endings)"" : """");
	      }
	    else if (! merge &&
		     (verbosity == VERBOSE
		      || (verbosity != SILENT && (fuzz || in_offset))))
	      {
		say (""Hunk #%d succeeded at %s"", hunk,
		     format_linenum (numbuf, newwhere));
		if (fuzz)
		  say ("" with fuzz %s"", format_linenum (numbuf, fuzz));
		if (in_offset)
		  say ("" (offset %s line%s)"",
		       format_linenum (numbuf, in_offset),
		       ""s"" + (in_offset == 1));
		say ("".\n"");
	      }
	  }

	if (!skip_rest_of_patch)
	  {
	    if (got_hunk < 0  &&  using_plan_a)
	      {
		if (outfile)
		  fatal (""out of memory using Plan A"");
		say (""\n\nRan out of memory using Plan A -- trying again...\n\n"");
		if (outstate.ofp)
		  {
		    fclose (outstate.ofp);
		    outstate.ofp = 0;
		  }
		continue;
	      }

	    /* Finish spewing out the new file.  */
	    if (! spew_output (&outstate, &tmpoutst))
	      {
		say (""Skipping patch.\n"");
		skip_rest_of_patch = true;
	      }
	  }
      }

      /* and put the output where desired */
      ignore_signals ();
      if (! skip_rest_of_patch && ! outfile) {
	  bool backup = make_backups
			|| (backup_if_mismatch && (mismatch | failed));
	  if (outstate.zero_output
	      && (remove_empty_files
		  || (pch_says_nonexistent (! reverse) == 2
		      && ! posixly_correct)
		  || S_ISLNK (file_type)))
	    {
	      if (! dry_run)
		output_file (NULL, NULL, NULL, outname,
			     (inname == outname) ? &instat : NULL,
			     file_type | 0, backup);
	    }
	  else
	    {
	      if (! outstate.zero_output
		  && pch_says_nonexistent (! reverse) == 2
		  && (remove_empty_files || ! posixly_correct)
		  && ! (merge && somefailed))
		{
		  mismatch = true;
		  somefailed = true;
		  if (verbosity != SILENT)
		    say (""Not deleting file %s as content differs from patch\n"",
			 quotearg (outname));
		}

	      if (! dry_run)
		{
		  mode_t old_mode = pch_mode (reverse);
		  mode_t new_mode = pch_mode (! reverse);
		  bool set_mode = new_mode && old_mode != new_mode;

		  /* Avoid replacing files when nothing has changed.  */
		  if (failed < hunk || diff_type == ED_DIFF || set_mode
		      || pch_copy () || pch_rename ())
		    {
		      enum file_attributes attr = 0;
		      struct timespec new_time = pch_timestamp (! reverse);
		      mode_t mode = file_type |
			  ((new_mode ? new_mode : instat.st_mode) & S_IRWXUGO);

		      if ((set_time | set_utc) && new_time.tv_sec != -1)
			{
			  struct timespec old_time = pch_timestamp (reverse);

			  if (! force && ! inerrno
			      && pch_says_nonexistent (reverse) != 2
			      && old_time.tv_sec != -1
			      && timespec_cmp (old_time,
					       get_stat_mtime (&instat)))
			    say (""Not setting time of file %s ""
				 ""(time mismatch)\n"",
				 quotearg (outname));
			  else if (! force && (mismatch | failed))
			    say (""Not setting time of file %s ""
				 ""(contents mismatch)\n"",
				 quotearg (outname));
			  else
			    attr |= FA_TIMES;
			}

		      if (inerrno)
			set_file_attributes (TMPOUTNAME, attr, NULL, NULL,
					     mode, &new_time);
		      else
			{
			  attr |= FA_IDS | FA_MODE | FA_XATTRS;
			  set_file_attributes (TMPOUTNAME, attr, inname, &instat,
					       mode, &new_time);
			}

		      output_file (TMPOUTNAME, &TMPOUTNAME_needs_removal,
				   &tmpoutst, outname, NULL, mode, backup);

		      if (pch_rename ())
			output_file (NULL, NULL, NULL, inname, &instat,
				     mode, backup);
		    }
		  else
		    output_file (outname, NULL, &tmpoutst, NULL, NULL,
				 file_type | 0, backup);
		}
	    }
      }
      if (diff_type != ED_DIFF) {
	struct stat rejst;

	if (failed) {
	    if (fstat (fileno (rejfp), &rejst) != 0 || fclose (rejfp) != 0)
	      write_fatal ();
	    rejfp = NULL;
	    somefailed = true;
	    say (""%d out of %d hunk%s %s"", failed, hunk, ""s"" + (hunk == 1),
		 skip_rest_of_patch ? ""ignored"" : ""FAILED"");
	    if (outname && (! rejname || strcmp (rejname, ""-"") != 0)) {
		char *rej = rejname;
		if (!rejname) {
		    /* FIXME: This should really be done differently!  */
		    const char *s = simple_backup_suffix;
		    size_t len;
		    simple_backup_suffix = "".rej"";
		    rej = find_backup_file_name (outname, simple_backups);
		    len = strlen (rej);
		    if (rej[len - 1] == '~')
		      rej[len - 1] = '#';
		    simple_backup_suffix = s;
		}
		if (! dry_run)
		  {
		    say ("" -- saving rejects to file %s\n"", quotearg (rej));
		    if (rejname)
		      {
			if (! written_to_rejname)
			  {
			    copy_file (TMPREJNAME, rejname, 0, 0,
				       S_IFREG | 0666, true);
			    written_to_rejname = true;
			  }
			else
			  append_to_file (TMPREJNAME, rejname);
		      }
		    else
		      {
			struct stat oldst;
			int olderrno;

			olderrno = stat_file (rej, &oldst);
			if (olderrno && olderrno != ENOENT)
			  write_fatal ();
		        if (! olderrno && lookup_file_id (&oldst) == CREATED)
			  append_to_file (TMPREJNAME, rej);
			else
			  move_file (TMPREJNAME, &TMPREJNAME_needs_removal,
				     &rejst, rej, S_IFREG | 0666, false);
		      }
		  }
		else
		  say (""\n"");
		if (!rejname)
		    free (rej);
	    } else
	      say (""\n"");
	}
      }
      set_signals (true);
    }
"
833,178569,,Remote,Not required,,CVE-2015-1395,https://www.cvedetails.com/cve/CVE-2015-1395/,CWE-22,Low,,Complete,,2017-08-25,7.8,Directory traversal vulnerability in GNU patch versions which support Git-style patching before 2.7.3 allows remote attackers to write to arbitrary files with the permissions of the target user via a .. (dot dot) in a diff file name.,2017-08-29,Dir. Trav.,10,https://git.savannah.gnu.org/cgit/patch.git/commit/?id=17953b5893f7c9835f0dd2a704ba04e0371d2cbd,17953b5893f7c9835f0dd2a704ba04e0371d2cbd,,0,,,"intuit_diff_type (bool need_header, mode_t *p_file_type)
{
    file_offset this_line = 0;
    file_offset first_command_line = -1;
    char first_ed_command_letter = 0;
    lin fcl_line = 0; /* Pacify 'gcc -W'.  */
    bool this_is_a_command = false;
    bool stars_this_line = false;
    bool extended_headers = false;
    enum nametype i;
    struct stat st[3];
    int stat_errno[3];
    int version_controlled[3];
    enum diff retval;
    mode_t file_type;

    for (i = OLD;  i <= INDEX;  i++)
      if (p_name[i]) {
	  free (p_name[i]);
	  p_name[i] = 0;
        }
    for (i = 0; i < ARRAY_SIZE (invalid_names); i++)
	invalid_names[i] = NULL;
    for (i = OLD; i <= NEW; i++)
      if (p_timestr[i])
	{
	  free(p_timestr[i]);
	  p_timestr[i] = 0;
	}
    for (i = OLD; i <= NEW; i++)
      if (p_sha1[i])
	{
	  free (p_sha1[i]);
	  p_sha1[i] = 0;
	}
    p_git_diff = false;
    for (i = OLD; i <= NEW; i++)
      {
	p_mode[i] = 0;
	p_copy[i] = false;
	p_rename[i] = false;
      }

    /* Ed and normal format patches don't have filename headers.  */
    if (diff_type == ED_DIFF || diff_type == NORMAL_DIFF)
      need_header = false;

    version_controlled[OLD] = -1;
    version_controlled[NEW] = -1;
    version_controlled[INDEX] = -1;
    p_rfc934_nesting = 0;
    p_timestamp[OLD].tv_sec = p_timestamp[NEW].tv_sec = -1;
    p_says_nonexistent[OLD] = p_says_nonexistent[NEW] = 0;
    Fseek (pfp, p_base, SEEK_SET);
    p_input_line = p_bline - 1;
    for (;;) {
	char *s;
	char *t;
	file_offset previous_line = this_line;
	bool last_line_was_command = this_is_a_command;
	bool stars_last_line = stars_this_line;
	size_t indent = 0;
	char ed_command_letter;
	bool strip_trailing_cr;
	size_t chars_read;

	this_line = file_tell (pfp);
	chars_read = pget_line (0, 0, false, false);
	if (chars_read == (size_t) -1)
	  xalloc_die ();
	if (! chars_read) {
	    if (first_ed_command_letter) {
					/* nothing but deletes!? */
		p_start = first_command_line;
		p_sline = fcl_line;
		retval = ED_DIFF;
		goto scan_exit;
	    }
	    else {
		p_start = this_line;
		p_sline = p_input_line;
		if (extended_headers)
		  {
		    /* Patch contains no hunks; any diff type will do. */
		    retval = UNI_DIFF;
		    goto scan_exit;
		  }
		return NO_DIFF;
	    }
	}
	strip_trailing_cr = 2 <= chars_read && buf[chars_read - 2] == '\r';
	for (s = buf; *s == ' ' || *s == '\t' || *s == 'X'; s++) {
	    if (*s == '\t')
		indent = (indent + 8) & ~7;
	    else
		indent++;
	}
	if (ISDIGIT (*s))
	  {
	    for (t = s + 1; ISDIGIT (*t) || *t == ',';  t++)
	      /* do nothing */ ;
	    if (*t == 'd' || *t == 'c' || *t == 'a')
	      {
		for (t++;  ISDIGIT (*t) || *t == ',';  t++)
		  /* do nothing */ ;
		for (; *t == ' ' || *t == '\t'; t++)
		  /* do nothing */ ;
		if (*t == '\r')
		  t++;
		this_is_a_command = (*t == '\n');
	      }
	  }
	if (! need_header
	    && first_command_line < 0
	    && ((ed_command_letter = get_ed_command_letter (s))
		|| this_is_a_command)) {
	    first_command_line = this_line;
	    first_ed_command_letter = ed_command_letter;
	    fcl_line = p_input_line;
	    p_indent = indent;		/* assume this for now */
	    p_strip_trailing_cr = strip_trailing_cr;
	}
	if (!stars_last_line && strnEQ(s, ""*** "", 4))
	  {
	    fetchname (s+4, strippath, &p_name[OLD], &p_timestr[OLD],
		       &p_timestamp[OLD]);
	    need_header = false;
	  }
	else if (strnEQ(s, ""+++ "", 4))
	  {
	    /* Swap with NEW below.  */
	    fetchname (s+4, strippath, &p_name[OLD], &p_timestr[OLD],
		       &p_timestamp[OLD]);
	    need_header = false;
	    p_strip_trailing_cr = strip_trailing_cr;
	  }
	else if (strnEQ(s, ""Index:"", 6))
	  {
	    fetchname (s+6, strippath, &p_name[INDEX], (char **) 0, NULL);
	    need_header = false;
	    p_strip_trailing_cr = strip_trailing_cr;
	  }
	else if (strnEQ(s, ""Prereq:"", 7))
	  {
	    for (t = s + 7;  ISSPACE ((unsigned char) *t);  t++)
	      /* do nothing */ ;
	    revision = t;
	    for (t = revision;  *t;  t++)
	      if (ISSPACE ((unsigned char) *t))
		{
		  char const *u;
		  for (u = t + 1;  ISSPACE ((unsigned char) *u);  u++)
		    /* do nothing */ ;
		  if (*u)
		    {
		      char numbuf[LINENUM_LENGTH_BOUND + 1];
		      say (""Prereq: with multiple words at line %s of patch\n"",
			   format_linenum (numbuf, this_line));
		    }
		  break;
		}
	    if (t == revision)
		revision = 0;
	    else {
		char oldc = *t;
		*t = '\0';
		revision = xstrdup (revision);
		*t = oldc;
	    }
	  }
	else if (strnEQ (s, ""diff --git "", 11))
	  {
	    char const *u;

	    if (extended_headers)
	      {
		p_start = this_line;
		p_sline = p_input_line;
		/* Patch contains no hunks; any diff type will do. */
		retval = UNI_DIFF;
		goto scan_exit;
	      }

	    for (i = OLD; i <= NEW; i++)
	      {
		free (p_name[i]);
		p_name[i] = 0;
	      }
	    if (! ((p_name[OLD] = parse_name (s + 11, strippath, &u))
		   && ISSPACE ((unsigned char) *u)
		   && (p_name[NEW] = parse_name (u, strippath, &u))
		   && (u = skip_spaces (u), ! *u)))
	      for (i = OLD; i <= NEW; i++)
		{
		  free (p_name[i]);
		  p_name[i] = 0;
		}
	    p_git_diff = true;
	  }
	else if (p_git_diff && strnEQ (s, ""index "", 6))
	  {
	    char const *u, *v;
	    if ((u = skip_hex_digits (s + 6))
		&& u[0] == '.' && u[1] == '.'
		&& (v = skip_hex_digits (u + 2))
		&& (! *v || ISSPACE ((unsigned char) *v)))
	      {
		get_sha1(&p_sha1[OLD], s + 6, u);
		get_sha1(&p_sha1[NEW], u + 2, v);
		p_says_nonexistent[OLD] = sha1_says_nonexistent (p_sha1[OLD]);
		p_says_nonexistent[NEW] = sha1_says_nonexistent (p_sha1[NEW]);
		if (*(v = skip_spaces (v)))
		  p_mode[OLD] = p_mode[NEW] = fetchmode (v);
		extended_headers = true;
	      }
	  }
	else if (p_git_diff && strnEQ (s, ""old mode "", 9))
	  {
	    p_mode[OLD] = fetchmode (s + 9);
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""new mode "", 9))
	  {
	    p_mode[NEW] = fetchmode (s + 9);
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""deleted file mode "", 18))
	  {
	    p_mode[OLD] = fetchmode (s + 18);
	    p_says_nonexistent[NEW] = 2;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""new file mode "", 14))
	  {
	    p_mode[NEW] = fetchmode (s + 14);
	    p_says_nonexistent[OLD] = 2;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""rename from "", 12))
	  {
	    /* Git leaves out the prefix in the file name in this header,
	       so we can only ignore the file name.  */
	    p_rename[OLD] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""rename to "", 10))
	  {
	    /* Git leaves out the prefix in the file name in this header,
	       so we can only ignore the file name.  */
	    p_rename[NEW] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""copy from "", 10))
	  {
	    /* Git leaves out the prefix in the file name in this header,
	       so we can only ignore the file name.  */
	    p_copy[OLD] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""copy to "", 8))
	  {
	    /* Git leaves out the prefix in the file name in this header,
	       so we can only ignore the file name.  */
	    p_copy[NEW] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""GIT binary patch"", 16))
	  {
	    p_start = this_line;
	    p_sline = p_input_line;
	    retval = GIT_BINARY_DIFF;
	    goto scan_exit;
	  }
	else
	  {
	    for (t = s;  t[0] == '-' && t[1] == ' ';  t += 2)
	      /* do nothing */ ;
	    if (strnEQ(t, ""--- "", 4))
	      {
		struct timespec timestamp;
		timestamp.tv_sec = -1;
		fetchname (t+4, strippath, &p_name[NEW], &p_timestr[NEW],
			   &timestamp);
		need_header = false;
		if (timestamp.tv_sec != -1)
		  {
		    p_timestamp[NEW] = timestamp;
		    p_rfc934_nesting = (t - s) >> 1;
		  }
		p_strip_trailing_cr = strip_trailing_cr;
	      }
	  }
	if (need_header)
	  continue;
	if ((diff_type == NO_DIFF || diff_type == ED_DIFF) &&
	  first_command_line >= 0 &&
	  strEQ(s, "".\n"") ) {
	    p_start = first_command_line;
	    p_sline = fcl_line;
	    retval = ED_DIFF;
	    goto scan_exit;
	}
	if ((diff_type == NO_DIFF || diff_type == UNI_DIFF)
	    && strnEQ(s, ""@@ -"", 4)) {

	    /* 'p_name', 'p_timestr', and 'p_timestamp' are backwards;
	       swap them.  */
	    struct timespec ti = p_timestamp[OLD];
	    p_timestamp[OLD] = p_timestamp[NEW];
	    p_timestamp[NEW] = ti;
	    t = p_name[OLD];
	    p_name[OLD] = p_name[NEW];
	    p_name[NEW] = t;
	    t = p_timestr[OLD];
	    p_timestr[OLD] = p_timestr[NEW];
	    p_timestr[NEW] = t;

	    s += 4;
	    if (s[0] == '0' && !ISDIGIT (s[1]))
	      p_says_nonexistent[OLD] = 1 + ! p_timestamp[OLD].tv_sec;
	    while (*s != ' ' && *s != '\n')
	      s++;
	    while (*s == ' ')
	      s++;
	    if (s[0] == '+' && s[1] == '0' && !ISDIGIT (s[2]))
	      p_says_nonexistent[NEW] = 1 + ! p_timestamp[NEW].tv_sec;
	    p_indent = indent;
	    p_start = this_line;
	    p_sline = p_input_line;
	    retval = UNI_DIFF;
	    if (! ((p_name[OLD] || ! p_timestamp[OLD].tv_sec)
		   && (p_name[NEW] || ! p_timestamp[NEW].tv_sec))
		&& ! p_name[INDEX] && need_header)
	      {
		char numbuf[LINENUM_LENGTH_BOUND + 1];
		say (""missing header for unified diff at line %s of patch\n"",
		     format_linenum (numbuf, p_sline));
	      }
	    goto scan_exit;
	}
	stars_this_line = strnEQ(s, ""********"", 8);
	if ((diff_type == NO_DIFF
	     || diff_type == CONTEXT_DIFF
	     || diff_type == NEW_CONTEXT_DIFF)
	    && stars_last_line && strnEQ (s, ""*** "", 4)) {
	    s += 4;
	    if (s[0] == '0' && !ISDIGIT (s[1]))
	      p_says_nonexistent[OLD] = 1 + ! p_timestamp[OLD].tv_sec;
	    /* if this is a new context diff the character just before */
	    /* the newline is a '*'. */
	    while (*s != '\n')
		s++;
	    p_indent = indent;
	    p_strip_trailing_cr = strip_trailing_cr;
	    p_start = previous_line;
	    p_sline = p_input_line - 1;
	    retval = (*(s-1) == '*' ? NEW_CONTEXT_DIFF : CONTEXT_DIFF);

	    {
	      /* Scan the first hunk to see whether the file contents
		 appear to have been deleted.  */
	      file_offset saved_p_base = p_base;
	      lin saved_p_bline = p_bline;
	      Fseek (pfp, previous_line, SEEK_SET);
	      p_input_line -= 2;
	      if (another_hunk (retval, false)
		  && ! p_repl_lines && p_newfirst == 1)
		p_says_nonexistent[NEW] = 1 + ! p_timestamp[NEW].tv_sec;
	      next_intuit_at (saved_p_base, saved_p_bline);
	    }

	    if (! ((p_name[OLD] || ! p_timestamp[OLD].tv_sec)
		   && (p_name[NEW] || ! p_timestamp[NEW].tv_sec))
		&& ! p_name[INDEX] && need_header)
	      {
		char numbuf[LINENUM_LENGTH_BOUND + 1];
		say (""missing header for context diff at line %s of patch\n"",
		     format_linenum (numbuf, p_sline));
	      }
	    goto scan_exit;
	}
	if ((diff_type == NO_DIFF || diff_type == NORMAL_DIFF) &&
	  last_line_was_command &&
	  (strnEQ(s, ""< "", 2) || strnEQ(s, ""> "", 2)) ) {
	    p_start = previous_line;
	    p_sline = p_input_line - 1;
	    p_indent = indent;
	    retval = NORMAL_DIFF;
	    goto scan_exit;
	}
    }

  scan_exit:

    /* The old, new, or old and new file types may be defined.  When both
       file types are defined, make sure they are the same, or else assume
       we do not know the file type.  */
    file_type = p_mode[OLD] & S_IFMT;
    if (file_type)
      {
	mode_t new_file_type = p_mode[NEW] & S_IFMT;
	if (new_file_type && file_type != new_file_type)
	  file_type = 0;
      }
    else
      {
	file_type = p_mode[NEW] & S_IFMT;
	if (! file_type)
	  file_type = S_IFREG;
      }
    *p_file_type = file_type;

    /* To intuit 'inname', the name of the file to patch,
       use the algorithm specified by POSIX 1003.1-2001 XCU lines 25680-26599
       (with some modifications if posixly_correct is zero):

       - Take the old and new names from the context header if present,
	 and take the index name from the 'Index:' line if present and
	 if either the old and new names are both absent
	 or posixly_correct is nonzero.
	 Consider the file names to be in the order (old, new, index).
       - If some named files exist, use the first one if posixly_correct
	 is nonzero, the best one otherwise.
       - If patch_get is nonzero, and no named files exist,
	 but an RCS or SCCS master file exists,
	 use the first named file with an RCS or SCCS master.
       - If no named files exist, no RCS or SCCS master was found,
	 some names are given, posixly_correct is zero,
	 and the patch appears to create a file, then use the best name
	 requiring the creation of the fewest directories.
       - Otherwise, report failure by setting 'inname' to 0;
	 this causes our invoker to ask the user for a file name.  */

    i = NONE;

    if (!inname)
      {
	enum nametype i0 = NONE;

	if (! posixly_correct && (p_name[OLD] || p_name[NEW]) && p_name[INDEX])
	  {
	    free (p_name[INDEX]);
	    p_name[INDEX] = 0;
	  }

	for (i = OLD;  i <= INDEX;  i++)
	  if (p_name[i])
	    {
	      if (i0 != NONE && strcmp (p_name[i0], p_name[i]) == 0)
		{
		  /* It's the same name as before; reuse stat results.  */
		  stat_errno[i] = stat_errno[i0];
		  if (! stat_errno[i])
		    st[i] = st[i0];
		}
	      else
		{
		  stat_errno[i] = stat_file (p_name[i], &st[i]);
		  if (! stat_errno[i])
		    {
		      if (lookup_file_id (&st[i]) == DELETE_LATER)
			stat_errno[i] = ENOENT;
		      else if (posixly_correct && name_is_valid (p_name[i]))
			break;
		    }
		}
	      i0 = i;
	    }

	if (! posixly_correct)
	  {
	    /* The best of all existing files. */
	    i = best_name (p_name, stat_errno);

	    if (i == NONE && patch_get)
	      {
		enum nametype nope = NONE;

		for (i = OLD;  i <= INDEX;  i++)
		  if (p_name[i])
		    {
		      char const *cs;
		      char *getbuf;
		      char *diffbuf;
		      bool readonly = (outfile
				       && strcmp (outfile, p_name[i]) != 0);

		      if (nope == NONE || strcmp (p_name[nope], p_name[i]) != 0)
			{
			  cs = (version_controller
			        (p_name[i], readonly, (struct stat *) 0,
				 &getbuf, &diffbuf));
			  version_controlled[i] = !! cs;
			  if (cs)
			    {
			      if (version_get (p_name[i], cs, false, readonly,
					       getbuf, &st[i]))
				stat_errno[i] = 0;
			      else
				version_controlled[i] = 0;

			      free (getbuf);
			      free (diffbuf);

			      if (! stat_errno[i])
				break;
			    }
			}

		      nope = i;
		    }
	      }

	    if (i0 != NONE
		&& (i == NONE || (st[i].st_mode & S_IFMT) == file_type)
		&& maybe_reverse (p_name[i == NONE ? i0 : i], i == NONE,
				  i == NONE || st[i].st_size == 0)
		&& i == NONE)
	      i = i0;

	    if (i == NONE && p_says_nonexistent[reverse])
	      {
		int newdirs[3];
		int newdirs_min = INT_MAX;
		int distance_from_minimum[3];

		for (i = OLD;  i <= INDEX;  i++)
		  if (p_name[i])
		    {
		      newdirs[i] = (prefix_components (p_name[i], false)
				    - prefix_components (p_name[i], true));
		      if (newdirs[i] < newdirs_min)
			newdirs_min = newdirs[i];
		    }

		for (i = OLD;  i <= INDEX;  i++)
		  if (p_name[i])
		    distance_from_minimum[i] = newdirs[i] - newdirs_min;

		/* The best of the filenames which create the fewest directories. */
		i = best_name (p_name, distance_from_minimum);
	      }
 	  }
       }
 
    if ((pch_rename () || pch_copy ())
	&& ! inname
	&& ! ((i == OLD || i == NEW) &&
	      p_name[! reverse] &&
	      name_is_valid (p_name[! reverse])))
      {
	say (""Cannot %s file without two valid file names\n"", pch_rename () ? ""rename"" : ""copy"");
	skip_rest_of_patch = true;
      }

     if (i == NONE)
       {
 	if (inname)
	inname = xstrdup (p_name[i]);
	inerrno = stat_errno[i];
	invc = version_controlled[i];
	instat = st[i];
      }

    return retval;
}
","intuit_diff_type (bool need_header, mode_t *p_file_type)
{
    file_offset this_line = 0;
    file_offset first_command_line = -1;
    char first_ed_command_letter = 0;
    lin fcl_line = 0; /* Pacify 'gcc -W'.  */
    bool this_is_a_command = false;
    bool stars_this_line = false;
    bool extended_headers = false;
    enum nametype i;
    struct stat st[3];
    int stat_errno[3];
    int version_controlled[3];
    enum diff retval;
    mode_t file_type;

    for (i = OLD;  i <= INDEX;  i++)
      if (p_name[i]) {
	  free (p_name[i]);
	  p_name[i] = 0;
        }
    for (i = 0; i < ARRAY_SIZE (invalid_names); i++)
	invalid_names[i] = NULL;
    for (i = OLD; i <= NEW; i++)
      if (p_timestr[i])
	{
	  free(p_timestr[i]);
	  p_timestr[i] = 0;
	}
    for (i = OLD; i <= NEW; i++)
      if (p_sha1[i])
	{
	  free (p_sha1[i]);
	  p_sha1[i] = 0;
	}
    p_git_diff = false;
    for (i = OLD; i <= NEW; i++)
      {
	p_mode[i] = 0;
	p_copy[i] = false;
	p_rename[i] = false;
      }

    /* Ed and normal format patches don't have filename headers.  */
    if (diff_type == ED_DIFF || diff_type == NORMAL_DIFF)
      need_header = false;

    version_controlled[OLD] = -1;
    version_controlled[NEW] = -1;
    version_controlled[INDEX] = -1;
    p_rfc934_nesting = 0;
    p_timestamp[OLD].tv_sec = p_timestamp[NEW].tv_sec = -1;
    p_says_nonexistent[OLD] = p_says_nonexistent[NEW] = 0;
    Fseek (pfp, p_base, SEEK_SET);
    p_input_line = p_bline - 1;
    for (;;) {
	char *s;
	char *t;
	file_offset previous_line = this_line;
	bool last_line_was_command = this_is_a_command;
	bool stars_last_line = stars_this_line;
	size_t indent = 0;
	char ed_command_letter;
	bool strip_trailing_cr;
	size_t chars_read;

	this_line = file_tell (pfp);
	chars_read = pget_line (0, 0, false, false);
	if (chars_read == (size_t) -1)
	  xalloc_die ();
	if (! chars_read) {
	    if (first_ed_command_letter) {
					/* nothing but deletes!? */
		p_start = first_command_line;
		p_sline = fcl_line;
		retval = ED_DIFF;
		goto scan_exit;
	    }
	    else {
		p_start = this_line;
		p_sline = p_input_line;
		if (extended_headers)
		  {
		    /* Patch contains no hunks; any diff type will do. */
		    retval = UNI_DIFF;
		    goto scan_exit;
		  }
		return NO_DIFF;
	    }
	}
	strip_trailing_cr = 2 <= chars_read && buf[chars_read - 2] == '\r';
	for (s = buf; *s == ' ' || *s == '\t' || *s == 'X'; s++) {
	    if (*s == '\t')
		indent = (indent + 8) & ~7;
	    else
		indent++;
	}
	if (ISDIGIT (*s))
	  {
	    for (t = s + 1; ISDIGIT (*t) || *t == ',';  t++)
	      /* do nothing */ ;
	    if (*t == 'd' || *t == 'c' || *t == 'a')
	      {
		for (t++;  ISDIGIT (*t) || *t == ',';  t++)
		  /* do nothing */ ;
		for (; *t == ' ' || *t == '\t'; t++)
		  /* do nothing */ ;
		if (*t == '\r')
		  t++;
		this_is_a_command = (*t == '\n');
	      }
	  }
	if (! need_header
	    && first_command_line < 0
	    && ((ed_command_letter = get_ed_command_letter (s))
		|| this_is_a_command)) {
	    first_command_line = this_line;
	    first_ed_command_letter = ed_command_letter;
	    fcl_line = p_input_line;
	    p_indent = indent;		/* assume this for now */
	    p_strip_trailing_cr = strip_trailing_cr;
	}
	if (!stars_last_line && strnEQ(s, ""*** "", 4))
	  {
	    fetchname (s+4, strippath, &p_name[OLD], &p_timestr[OLD],
		       &p_timestamp[OLD]);
	    need_header = false;
	  }
	else if (strnEQ(s, ""+++ "", 4))
	  {
	    /* Swap with NEW below.  */
	    fetchname (s+4, strippath, &p_name[OLD], &p_timestr[OLD],
		       &p_timestamp[OLD]);
	    need_header = false;
	    p_strip_trailing_cr = strip_trailing_cr;
	  }
	else if (strnEQ(s, ""Index:"", 6))
	  {
	    fetchname (s+6, strippath, &p_name[INDEX], (char **) 0, NULL);
	    need_header = false;
	    p_strip_trailing_cr = strip_trailing_cr;
	  }
	else if (strnEQ(s, ""Prereq:"", 7))
	  {
	    for (t = s + 7;  ISSPACE ((unsigned char) *t);  t++)
	      /* do nothing */ ;
	    revision = t;
	    for (t = revision;  *t;  t++)
	      if (ISSPACE ((unsigned char) *t))
		{
		  char const *u;
		  for (u = t + 1;  ISSPACE ((unsigned char) *u);  u++)
		    /* do nothing */ ;
		  if (*u)
		    {
		      char numbuf[LINENUM_LENGTH_BOUND + 1];
		      say (""Prereq: with multiple words at line %s of patch\n"",
			   format_linenum (numbuf, this_line));
		    }
		  break;
		}
	    if (t == revision)
		revision = 0;
	    else {
		char oldc = *t;
		*t = '\0';
		revision = xstrdup (revision);
		*t = oldc;
	    }
	  }
	else if (strnEQ (s, ""diff --git "", 11))
	  {
	    char const *u;

	    if (extended_headers)
	      {
		p_start = this_line;
		p_sline = p_input_line;
		/* Patch contains no hunks; any diff type will do. */
		retval = UNI_DIFF;
		goto scan_exit;
	      }

	    for (i = OLD; i <= NEW; i++)
	      {
		free (p_name[i]);
		p_name[i] = 0;
	      }
	    if (! ((p_name[OLD] = parse_name (s + 11, strippath, &u))
		   && ISSPACE ((unsigned char) *u)
		   && (p_name[NEW] = parse_name (u, strippath, &u))
		   && (u = skip_spaces (u), ! *u)))
	      for (i = OLD; i <= NEW; i++)
		{
		  free (p_name[i]);
		  p_name[i] = 0;
		}
	    p_git_diff = true;
	  }
	else if (p_git_diff && strnEQ (s, ""index "", 6))
	  {
	    char const *u, *v;
	    if ((u = skip_hex_digits (s + 6))
		&& u[0] == '.' && u[1] == '.'
		&& (v = skip_hex_digits (u + 2))
		&& (! *v || ISSPACE ((unsigned char) *v)))
	      {
		get_sha1(&p_sha1[OLD], s + 6, u);
		get_sha1(&p_sha1[NEW], u + 2, v);
		p_says_nonexistent[OLD] = sha1_says_nonexistent (p_sha1[OLD]);
		p_says_nonexistent[NEW] = sha1_says_nonexistent (p_sha1[NEW]);
		if (*(v = skip_spaces (v)))
		  p_mode[OLD] = p_mode[NEW] = fetchmode (v);
		extended_headers = true;
	      }
	  }
	else if (p_git_diff && strnEQ (s, ""old mode "", 9))
	  {
	    p_mode[OLD] = fetchmode (s + 9);
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""new mode "", 9))
	  {
	    p_mode[NEW] = fetchmode (s + 9);
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""deleted file mode "", 18))
	  {
	    p_mode[OLD] = fetchmode (s + 18);
	    p_says_nonexistent[NEW] = 2;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""new file mode "", 14))
	  {
	    p_mode[NEW] = fetchmode (s + 14);
	    p_says_nonexistent[OLD] = 2;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""rename from "", 12))
	  {
	    /* Git leaves out the prefix in the file name in this header,
	       so we can only ignore the file name.  */
	    p_rename[OLD] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""rename to "", 10))
	  {
	    /* Git leaves out the prefix in the file name in this header,
	       so we can only ignore the file name.  */
	    p_rename[NEW] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""copy from "", 10))
	  {
	    /* Git leaves out the prefix in the file name in this header,
	       so we can only ignore the file name.  */
	    p_copy[OLD] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""copy to "", 8))
	  {
	    /* Git leaves out the prefix in the file name in this header,
	       so we can only ignore the file name.  */
	    p_copy[NEW] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""GIT binary patch"", 16))
	  {
	    p_start = this_line;
	    p_sline = p_input_line;
	    retval = GIT_BINARY_DIFF;
	    goto scan_exit;
	  }
	else
	  {
	    for (t = s;  t[0] == '-' && t[1] == ' ';  t += 2)
	      /* do nothing */ ;
	    if (strnEQ(t, ""--- "", 4))
	      {
		struct timespec timestamp;
		timestamp.tv_sec = -1;
		fetchname (t+4, strippath, &p_name[NEW], &p_timestr[NEW],
			   &timestamp);
		need_header = false;
		if (timestamp.tv_sec != -1)
		  {
		    p_timestamp[NEW] = timestamp;
		    p_rfc934_nesting = (t - s) >> 1;
		  }
		p_strip_trailing_cr = strip_trailing_cr;
	      }
	  }
	if (need_header)
	  continue;
	if ((diff_type == NO_DIFF || diff_type == ED_DIFF) &&
	  first_command_line >= 0 &&
	  strEQ(s, "".\n"") ) {
	    p_start = first_command_line;
	    p_sline = fcl_line;
	    retval = ED_DIFF;
	    goto scan_exit;
	}
	if ((diff_type == NO_DIFF || diff_type == UNI_DIFF)
	    && strnEQ(s, ""@@ -"", 4)) {

	    /* 'p_name', 'p_timestr', and 'p_timestamp' are backwards;
	       swap them.  */
	    struct timespec ti = p_timestamp[OLD];
	    p_timestamp[OLD] = p_timestamp[NEW];
	    p_timestamp[NEW] = ti;
	    t = p_name[OLD];
	    p_name[OLD] = p_name[NEW];
	    p_name[NEW] = t;
	    t = p_timestr[OLD];
	    p_timestr[OLD] = p_timestr[NEW];
	    p_timestr[NEW] = t;

	    s += 4;
	    if (s[0] == '0' && !ISDIGIT (s[1]))
	      p_says_nonexistent[OLD] = 1 + ! p_timestamp[OLD].tv_sec;
	    while (*s != ' ' && *s != '\n')
	      s++;
	    while (*s == ' ')
	      s++;
	    if (s[0] == '+' && s[1] == '0' && !ISDIGIT (s[2]))
	      p_says_nonexistent[NEW] = 1 + ! p_timestamp[NEW].tv_sec;
	    p_indent = indent;
	    p_start = this_line;
	    p_sline = p_input_line;
	    retval = UNI_DIFF;
	    if (! ((p_name[OLD] || ! p_timestamp[OLD].tv_sec)
		   && (p_name[NEW] || ! p_timestamp[NEW].tv_sec))
		&& ! p_name[INDEX] && need_header)
	      {
		char numbuf[LINENUM_LENGTH_BOUND + 1];
		say (""missing header for unified diff at line %s of patch\n"",
		     format_linenum (numbuf, p_sline));
	      }
	    goto scan_exit;
	}
	stars_this_line = strnEQ(s, ""********"", 8);
	if ((diff_type == NO_DIFF
	     || diff_type == CONTEXT_DIFF
	     || diff_type == NEW_CONTEXT_DIFF)
	    && stars_last_line && strnEQ (s, ""*** "", 4)) {
	    s += 4;
	    if (s[0] == '0' && !ISDIGIT (s[1]))
	      p_says_nonexistent[OLD] = 1 + ! p_timestamp[OLD].tv_sec;
	    /* if this is a new context diff the character just before */
	    /* the newline is a '*'. */
	    while (*s != '\n')
		s++;
	    p_indent = indent;
	    p_strip_trailing_cr = strip_trailing_cr;
	    p_start = previous_line;
	    p_sline = p_input_line - 1;
	    retval = (*(s-1) == '*' ? NEW_CONTEXT_DIFF : CONTEXT_DIFF);

	    {
	      /* Scan the first hunk to see whether the file contents
		 appear to have been deleted.  */
	      file_offset saved_p_base = p_base;
	      lin saved_p_bline = p_bline;
	      Fseek (pfp, previous_line, SEEK_SET);
	      p_input_line -= 2;
	      if (another_hunk (retval, false)
		  && ! p_repl_lines && p_newfirst == 1)
		p_says_nonexistent[NEW] = 1 + ! p_timestamp[NEW].tv_sec;
	      next_intuit_at (saved_p_base, saved_p_bline);
	    }

	    if (! ((p_name[OLD] || ! p_timestamp[OLD].tv_sec)
		   && (p_name[NEW] || ! p_timestamp[NEW].tv_sec))
		&& ! p_name[INDEX] && need_header)
	      {
		char numbuf[LINENUM_LENGTH_BOUND + 1];
		say (""missing header for context diff at line %s of patch\n"",
		     format_linenum (numbuf, p_sline));
	      }
	    goto scan_exit;
	}
	if ((diff_type == NO_DIFF || diff_type == NORMAL_DIFF) &&
	  last_line_was_command &&
	  (strnEQ(s, ""< "", 2) || strnEQ(s, ""> "", 2)) ) {
	    p_start = previous_line;
	    p_sline = p_input_line - 1;
	    p_indent = indent;
	    retval = NORMAL_DIFF;
	    goto scan_exit;
	}
    }

  scan_exit:

    /* The old, new, or old and new file types may be defined.  When both
       file types are defined, make sure they are the same, or else assume
       we do not know the file type.  */
    file_type = p_mode[OLD] & S_IFMT;
    if (file_type)
      {
	mode_t new_file_type = p_mode[NEW] & S_IFMT;
	if (new_file_type && file_type != new_file_type)
	  file_type = 0;
      }
    else
      {
	file_type = p_mode[NEW] & S_IFMT;
	if (! file_type)
	  file_type = S_IFREG;
      }
    *p_file_type = file_type;

    /* To intuit 'inname', the name of the file to patch,
       use the algorithm specified by POSIX 1003.1-2001 XCU lines 25680-26599
       (with some modifications if posixly_correct is zero):

       - Take the old and new names from the context header if present,
	 and take the index name from the 'Index:' line if present and
	 if either the old and new names are both absent
	 or posixly_correct is nonzero.
	 Consider the file names to be in the order (old, new, index).
       - If some named files exist, use the first one if posixly_correct
	 is nonzero, the best one otherwise.
       - If patch_get is nonzero, and no named files exist,
	 but an RCS or SCCS master file exists,
	 use the first named file with an RCS or SCCS master.
       - If no named files exist, no RCS or SCCS master was found,
	 some names are given, posixly_correct is zero,
	 and the patch appears to create a file, then use the best name
	 requiring the creation of the fewest directories.
       - Otherwise, report failure by setting 'inname' to 0;
	 this causes our invoker to ask the user for a file name.  */

    i = NONE;

    if (!inname)
      {
	enum nametype i0 = NONE;

	if (! posixly_correct && (p_name[OLD] || p_name[NEW]) && p_name[INDEX])
	  {
	    free (p_name[INDEX]);
	    p_name[INDEX] = 0;
	  }

	for (i = OLD;  i <= INDEX;  i++)
	  if (p_name[i])
	    {
	      if (i0 != NONE && strcmp (p_name[i0], p_name[i]) == 0)
		{
		  /* It's the same name as before; reuse stat results.  */
		  stat_errno[i] = stat_errno[i0];
		  if (! stat_errno[i])
		    st[i] = st[i0];
		}
	      else
		{
		  stat_errno[i] = stat_file (p_name[i], &st[i]);
		  if (! stat_errno[i])
		    {
		      if (lookup_file_id (&st[i]) == DELETE_LATER)
			stat_errno[i] = ENOENT;
		      else if (posixly_correct && name_is_valid (p_name[i]))
			break;
		    }
		}
	      i0 = i;
	    }

	if (! posixly_correct)
	  {
	    /* The best of all existing files. */
	    i = best_name (p_name, stat_errno);

	    if (i == NONE && patch_get)
	      {
		enum nametype nope = NONE;

		for (i = OLD;  i <= INDEX;  i++)
		  if (p_name[i])
		    {
		      char const *cs;
		      char *getbuf;
		      char *diffbuf;
		      bool readonly = (outfile
				       && strcmp (outfile, p_name[i]) != 0);

		      if (nope == NONE || strcmp (p_name[nope], p_name[i]) != 0)
			{
			  cs = (version_controller
			        (p_name[i], readonly, (struct stat *) 0,
				 &getbuf, &diffbuf));
			  version_controlled[i] = !! cs;
			  if (cs)
			    {
			      if (version_get (p_name[i], cs, false, readonly,
					       getbuf, &st[i]))
				stat_errno[i] = 0;
			      else
				version_controlled[i] = 0;

			      free (getbuf);
			      free (diffbuf);

			      if (! stat_errno[i])
				break;
			    }
			}

		      nope = i;
		    }
	      }

	    if (i0 != NONE
		&& (i == NONE || (st[i].st_mode & S_IFMT) == file_type)
		&& maybe_reverse (p_name[i == NONE ? i0 : i], i == NONE,
				  i == NONE || st[i].st_size == 0)
		&& i == NONE)
	      i = i0;

	    if (i == NONE && p_says_nonexistent[reverse])
	      {
		int newdirs[3];
		int newdirs_min = INT_MAX;
		int distance_from_minimum[3];

		for (i = OLD;  i <= INDEX;  i++)
		  if (p_name[i])
		    {
		      newdirs[i] = (prefix_components (p_name[i], false)
				    - prefix_components (p_name[i], true));
		      if (newdirs[i] < newdirs_min)
			newdirs_min = newdirs[i];
		    }

		for (i = OLD;  i <= INDEX;  i++)
		  if (p_name[i])
		    distance_from_minimum[i] = newdirs[i] - newdirs_min;

		/* The best of the filenames which create the fewest directories. */
		i = best_name (p_name, distance_from_minimum);
	      }
 	  }
       }
 
     if (i == NONE)
       {
 	if (inname)
	inname = xstrdup (p_name[i]);
	inerrno = stat_errno[i];
	invc = version_controlled[i];
	instat = st[i];
      }

    return retval;
}
",C,"    if ((pch_rename () || pch_copy ())
	&& ! inname
	&& ! ((i == OLD || i == NEW) &&
	      p_name[! reverse] &&
	      name_is_valid (p_name[! reverse])))
      {
	say (""Cannot %s file without two valid file names\n"", pch_rename () ? ""rename"" : ""copy"");
	skip_rest_of_patch = true;
      }

",,0c08d7a902c6fdd49b704623a12d8d672ef18944,"@@ -978,6 +978,16 @@ intuit_diff_type (bool need_header, mode_t *p_file_type)
 	  }
       }
 
+    if ((pch_rename () || pch_copy ())
+	&& ! inname
+	&& ! ((i == OLD || i == NEW) &&
+	      p_name[! reverse] &&
+	      name_is_valid (p_name[! reverse])))
+      {
+	say (""Cannot %s file without two valid file names\n"", pch_rename () ? ""rename"" : ""copy"");
+	skip_rest_of_patch = true;
+      }
+
     if (i == NONE)
       {
 	if (inname)
@@ -2178,14 +2188,12 @@ pch_name (enum nametype type)
 
 bool pch_copy (void)
 {
-  return p_copy[OLD] && p_copy[NEW]
-	 && p_name[OLD] && p_name[NEW];
+  return p_copy[OLD] && p_copy[NEW];
 }
 
 bool pch_rename (void)
 {
-  return p_rename[OLD] && p_rename[NEW]
-	 && p_name[OLD] && p_name[NEW];
+  return p_rename[OLD] && p_rename[NEW];
 }
 
 /* Return the specified line position in the old file of the old context. */",savannah,https://git.savannah.gnu.org/cgit/patch.git/tree/src/pch.c?id=17953b5893f7c9835f0dd2a704ba04e0371d2cbd,https://git.savannah.gnu.org/cgit/patch.git/tree/src/pch.c?id=0c08d7a902c6fdd49b704623a12d8d672ef18944,1,"intuit_diff_type (bool need_header, mode_t *p_file_type)
{
    file_offset this_line = 0;
    file_offset first_command_line = -1;
    char first_ed_command_letter = 0;
    lin fcl_line = 0; /* Pacify 'gcc -W'.  */
    bool this_is_a_command = false;
    bool stars_this_line = false;
    bool extended_headers = false;
    enum nametype i;
    struct stat st[3];
    int stat_errno[3];
    int version_controlled[3];
    enum diff retval;
    mode_t file_type;

    for (i = OLD;  i <= INDEX;  i++)
      if (p_name[i]) {
	  free (p_name[i]);
	  p_name[i] = 0;
        }
    for (i = 0; i < ARRAY_SIZE (invalid_names); i++)
	invalid_names[i] = NULL;
    for (i = OLD; i <= NEW; i++)
      if (p_timestr[i])
	{
	  free(p_timestr[i]);
	  p_timestr[i] = 0;
	}
    for (i = OLD; i <= NEW; i++)
      if (p_sha1[i])
	{
	  free (p_sha1[i]);
	  p_sha1[i] = 0;
	}
    p_git_diff = false;
    for (i = OLD; i <= NEW; i++)
      {
	p_mode[i] = 0;
	p_copy[i] = false;
	p_rename[i] = false;
      }

    /* Ed and normal format patches don't have filename headers.  */
    if (diff_type == ED_DIFF || diff_type == NORMAL_DIFF)
      need_header = false;

    version_controlled[OLD] = -1;
    version_controlled[NEW] = -1;
    version_controlled[INDEX] = -1;
    p_rfc934_nesting = 0;
    p_timestamp[OLD].tv_sec = p_timestamp[NEW].tv_sec = -1;
    p_says_nonexistent[OLD] = p_says_nonexistent[NEW] = 0;
    Fseek (pfp, p_base, SEEK_SET);
    p_input_line = p_bline - 1;
    for (;;) {
	char *s;
	char *t;
	file_offset previous_line = this_line;
	bool last_line_was_command = this_is_a_command;
	bool stars_last_line = stars_this_line;
	size_t indent = 0;
	char ed_command_letter;
	bool strip_trailing_cr;
	size_t chars_read;

	this_line = file_tell (pfp);
	chars_read = pget_line (0, 0, false, false);
	if (chars_read == (size_t) -1)
	  xalloc_die ();
	if (! chars_read) {
	    if (first_ed_command_letter) {
					/* nothing but deletes!? */
		p_start = first_command_line;
		p_sline = fcl_line;
		retval = ED_DIFF;
		goto scan_exit;
	    }
	    else {
		p_start = this_line;
		p_sline = p_input_line;
		if (extended_headers)
		  {
		    /* Patch contains no hunks; any diff type will do. */
		    retval = UNI_DIFF;
		    goto scan_exit;
		  }
		return NO_DIFF;
	    }
	}
	strip_trailing_cr = 2 <= chars_read && buf[chars_read - 2] == '\r';
	for (s = buf; *s == ' ' || *s == '\t' || *s == 'X'; s++) {
	    if (*s == '\t')
		indent = (indent + 8) & ~7;
	    else
		indent++;
	}
	if (ISDIGIT (*s))
	  {
	    for (t = s + 1; ISDIGIT (*t) || *t == ',';  t++)
	      /* do nothing */ ;
	    if (*t == 'd' || *t == 'c' || *t == 'a')
	      {
		for (t++;  ISDIGIT (*t) || *t == ',';  t++)
		  /* do nothing */ ;
		for (; *t == ' ' || *t == '\t'; t++)
		  /* do nothing */ ;
		if (*t == '\r')
		  t++;
		this_is_a_command = (*t == '\n');
	      }
	  }
	if (! need_header
	    && first_command_line < 0
	    && ((ed_command_letter = get_ed_command_letter (s))
		|| this_is_a_command)) {
	    first_command_line = this_line;
	    first_ed_command_letter = ed_command_letter;
	    fcl_line = p_input_line;
	    p_indent = indent;		/* assume this for now */
	    p_strip_trailing_cr = strip_trailing_cr;
	}
	if (!stars_last_line && strnEQ(s, ""*** "", 4))
	  {
	    fetchname (s+4, strippath, &p_name[OLD], &p_timestr[OLD],
		       &p_timestamp[OLD]);
	    need_header = false;
	  }
	else if (strnEQ(s, ""+++ "", 4))
	  {
	    /* Swap with NEW below.  */
	    fetchname (s+4, strippath, &p_name[OLD], &p_timestr[OLD],
		       &p_timestamp[OLD]);
	    need_header = false;
	    p_strip_trailing_cr = strip_trailing_cr;
	  }
	else if (strnEQ(s, ""Index:"", 6))
	  {
	    fetchname (s+6, strippath, &p_name[INDEX], (char **) 0, NULL);
	    need_header = false;
	    p_strip_trailing_cr = strip_trailing_cr;
	  }
	else if (strnEQ(s, ""Prereq:"", 7))
	  {
	    for (t = s + 7;  ISSPACE ((unsigned char) *t);  t++)
	      /* do nothing */ ;
	    revision = t;
	    for (t = revision;  *t;  t++)
	      if (ISSPACE ((unsigned char) *t))
		{
		  char const *u;
		  for (u = t + 1;  ISSPACE ((unsigned char) *u);  u++)
		    /* do nothing */ ;
		  if (*u)
		    {
		      char numbuf[LINENUM_LENGTH_BOUND + 1];
		      say (""Prereq: with multiple words at line %s of patch\n"",
			   format_linenum (numbuf, this_line));
		    }
		  break;
		}
	    if (t == revision)
		revision = 0;
	    else {
		char oldc = *t;
		*t = '\0';
		revision = xstrdup (revision);
		*t = oldc;
	    }
	  }
	else if (strnEQ (s, ""diff --git "", 11))
	  {
	    char const *u;

	    if (extended_headers)
	      {
		p_start = this_line;
		p_sline = p_input_line;
		/* Patch contains no hunks; any diff type will do. */
		retval = UNI_DIFF;
		goto scan_exit;
	      }

	    for (i = OLD; i <= NEW; i++)
	      {
		free (p_name[i]);
		p_name[i] = 0;
	      }
	    if (! ((p_name[OLD] = parse_name (s + 11, strippath, &u))
		   && ISSPACE ((unsigned char) *u)
		   && (p_name[NEW] = parse_name (u, strippath, &u))
		   && (u = skip_spaces (u), ! *u)))
	      for (i = OLD; i <= NEW; i++)
		{
		  free (p_name[i]);
		  p_name[i] = 0;
		}
	    p_git_diff = true;
	  }
	else if (p_git_diff && strnEQ (s, ""index "", 6))
	  {
	    char const *u, *v;
	    if ((u = skip_hex_digits (s + 6))
		&& u[0] == '.' && u[1] == '.'
		&& (v = skip_hex_digits (u + 2))
		&& (! *v || ISSPACE ((unsigned char) *v)))
	      {
		get_sha1(&p_sha1[OLD], s + 6, u);
		get_sha1(&p_sha1[NEW], u + 2, v);
		p_says_nonexistent[OLD] = sha1_says_nonexistent (p_sha1[OLD]);
		p_says_nonexistent[NEW] = sha1_says_nonexistent (p_sha1[NEW]);
		if (*(v = skip_spaces (v)))
		  p_mode[OLD] = p_mode[NEW] = fetchmode (v);
		extended_headers = true;
	      }
	  }
	else if (p_git_diff && strnEQ (s, ""old mode "", 9))
	  {
	    p_mode[OLD] = fetchmode (s + 9);
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""new mode "", 9))
	  {
	    p_mode[NEW] = fetchmode (s + 9);
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""deleted file mode "", 18))
	  {
	    p_mode[OLD] = fetchmode (s + 18);
	    p_says_nonexistent[NEW] = 2;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""new file mode "", 14))
	  {
	    p_mode[NEW] = fetchmode (s + 14);
	    p_says_nonexistent[OLD] = 2;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""rename from "", 12))
	  {
	    /* Git leaves out the prefix in the file name in this header,
	       so we can only ignore the file name.  */
	    p_rename[OLD] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""rename to "", 10))
	  {
	    /* Git leaves out the prefix in the file name in this header,
	       so we can only ignore the file name.  */
	    p_rename[NEW] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""copy from "", 10))
	  {
	    /* Git leaves out the prefix in the file name in this header,
	       so we can only ignore the file name.  */
	    p_copy[OLD] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""copy to "", 8))
	  {
	    /* Git leaves out the prefix in the file name in this header,
	       so we can only ignore the file name.  */
	    p_copy[NEW] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""GIT binary patch"", 16))
	  {
	    p_start = this_line;
	    p_sline = p_input_line;
	    retval = GIT_BINARY_DIFF;
	    goto scan_exit;
	  }
	else
	  {
	    for (t = s;  t[0] == '-' && t[1] == ' ';  t += 2)
	      /* do nothing */ ;
	    if (strnEQ(t, ""--- "", 4))
	      {
		struct timespec timestamp;
		timestamp.tv_sec = -1;
		fetchname (t+4, strippath, &p_name[NEW], &p_timestr[NEW],
			   &timestamp);
		need_header = false;
		if (timestamp.tv_sec != -1)
		  {
		    p_timestamp[NEW] = timestamp;
		    p_rfc934_nesting = (t - s) >> 1;
		  }
		p_strip_trailing_cr = strip_trailing_cr;
	      }
	  }
	if (need_header)
	  continue;
	if ((diff_type == NO_DIFF || diff_type == ED_DIFF) &&
	  first_command_line >= 0 &&
	  strEQ(s, "".\n"") ) {
	    p_start = first_command_line;
	    p_sline = fcl_line;
	    retval = ED_DIFF;
	    goto scan_exit;
	}
	if ((diff_type == NO_DIFF || diff_type == UNI_DIFF)
	    && strnEQ(s, ""@@ -"", 4)) {

	    /* 'p_name', 'p_timestr', and 'p_timestamp' are backwards;
	       swap them.  */
	    struct timespec ti = p_timestamp[OLD];
	    p_timestamp[OLD] = p_timestamp[NEW];
	    p_timestamp[NEW] = ti;
	    t = p_name[OLD];
	    p_name[OLD] = p_name[NEW];
	    p_name[NEW] = t;
	    t = p_timestr[OLD];
	    p_timestr[OLD] = p_timestr[NEW];
	    p_timestr[NEW] = t;

	    s += 4;
	    if (s[0] == '0' && !ISDIGIT (s[1]))
	      p_says_nonexistent[OLD] = 1 + ! p_timestamp[OLD].tv_sec;
	    while (*s != ' ' && *s != '\n')
	      s++;
	    while (*s == ' ')
	      s++;
	    if (s[0] == '+' && s[1] == '0' && !ISDIGIT (s[2]))
	      p_says_nonexistent[NEW] = 1 + ! p_timestamp[NEW].tv_sec;
	    p_indent = indent;
	    p_start = this_line;
	    p_sline = p_input_line;
	    retval = UNI_DIFF;
	    if (! ((p_name[OLD] || ! p_timestamp[OLD].tv_sec)
		   && (p_name[NEW] || ! p_timestamp[NEW].tv_sec))
		&& ! p_name[INDEX] && need_header)
	      {
		char numbuf[LINENUM_LENGTH_BOUND + 1];
		say (""missing header for unified diff at line %s of patch\n"",
		     format_linenum (numbuf, p_sline));
	      }
	    goto scan_exit;
	}
	stars_this_line = strnEQ(s, ""********"", 8);
	if ((diff_type == NO_DIFF
	     || diff_type == CONTEXT_DIFF
	     || diff_type == NEW_CONTEXT_DIFF)
	    && stars_last_line && strnEQ (s, ""*** "", 4)) {
	    s += 4;
	    if (s[0] == '0' && !ISDIGIT (s[1]))
	      p_says_nonexistent[OLD] = 1 + ! p_timestamp[OLD].tv_sec;
	    /* if this is a new context diff the character just before */
	    /* the newline is a '*'. */
	    while (*s != '\n')
		s++;
	    p_indent = indent;
	    p_strip_trailing_cr = strip_trailing_cr;
	    p_start = previous_line;
	    p_sline = p_input_line - 1;
	    retval = (*(s-1) == '*' ? NEW_CONTEXT_DIFF : CONTEXT_DIFF);

	    {
	      /* Scan the first hunk to see whether the file contents
		 appear to have been deleted.  */
	      file_offset saved_p_base = p_base;
	      lin saved_p_bline = p_bline;
	      Fseek (pfp, previous_line, SEEK_SET);
	      p_input_line -= 2;
	      if (another_hunk (retval, false)
		  && ! p_repl_lines && p_newfirst == 1)
		p_says_nonexistent[NEW] = 1 + ! p_timestamp[NEW].tv_sec;
	      next_intuit_at (saved_p_base, saved_p_bline);
	    }

	    if (! ((p_name[OLD] || ! p_timestamp[OLD].tv_sec)
		   && (p_name[NEW] || ! p_timestamp[NEW].tv_sec))
		&& ! p_name[INDEX] && need_header)
	      {
		char numbuf[LINENUM_LENGTH_BOUND + 1];
		say (""missing header for context diff at line %s of patch\n"",
		     format_linenum (numbuf, p_sline));
	      }
	    goto scan_exit;
	}
	if ((diff_type == NO_DIFF || diff_type == NORMAL_DIFF) &&
	  last_line_was_command &&
	  (strnEQ(s, ""< "", 2) || strnEQ(s, ""> "", 2)) ) {
	    p_start = previous_line;
	    p_sline = p_input_line - 1;
	    p_indent = indent;
	    retval = NORMAL_DIFF;
	    goto scan_exit;
	}
    }

  scan_exit:

    /* The old, new, or old and new file types may be defined.  When both
       file types are defined, make sure they are the same, or else assume
       we do not know the file type.  */
    file_type = p_mode[OLD] & S_IFMT;
    if (file_type)
      {
	mode_t new_file_type = p_mode[NEW] & S_IFMT;
	if (new_file_type && file_type != new_file_type)
	  file_type = 0;
      }
    else
      {
	file_type = p_mode[NEW] & S_IFMT;
	if (! file_type)
	  file_type = S_IFREG;
      }
    *p_file_type = file_type;

    /* To intuit 'inname', the name of the file to patch,
       use the algorithm specified by POSIX 1003.1-2001 XCU lines 25680-26599
       (with some modifications if posixly_correct is zero):

       - Take the old and new names from the context header if present,
	 and take the index name from the 'Index:' line if present and
	 if either the old and new names are both absent
	 or posixly_correct is nonzero.
	 Consider the file names to be in the order (old, new, index).
       - If some named files exist, use the first one if posixly_correct
	 is nonzero, the best one otherwise.
       - If patch_get is nonzero, and no named files exist,
	 but an RCS or SCCS master file exists,
	 use the first named file with an RCS or SCCS master.
       - If no named files exist, no RCS or SCCS master was found,
	 some names are given, posixly_correct is zero,
	 and the patch appears to create a file, then use the best name
	 requiring the creation of the fewest directories.
       - Otherwise, report failure by setting 'inname' to 0;
	 this causes our invoker to ask the user for a file name.  */

    i = NONE;

    if (!inname)
      {
	enum nametype i0 = NONE;

	if (! posixly_correct && (p_name[OLD] || p_name[NEW]) && p_name[INDEX])
	  {
	    free (p_name[INDEX]);
	    p_name[INDEX] = 0;
	  }

	for (i = OLD;  i <= INDEX;  i++)
	  if (p_name[i])
	    {
	      if (i0 != NONE && strcmp (p_name[i0], p_name[i]) == 0)
		{
		  /* It's the same name as before; reuse stat results.  */
		  stat_errno[i] = stat_errno[i0];
		  if (! stat_errno[i])
		    st[i] = st[i0];
		}
	      else
		{
		  stat_errno[i] = stat_file (p_name[i], &st[i]);
		  if (! stat_errno[i])
		    {
		      if (lookup_file_id (&st[i]) == DELETE_LATER)
			stat_errno[i] = ENOENT;
		      else if (posixly_correct && name_is_valid (p_name[i]))
			break;
		    }
		}
	      i0 = i;
	    }

	if (! posixly_correct)
	  {
	    /* The best of all existing files. */
	    i = best_name (p_name, stat_errno);

	    if (i == NONE && patch_get)
	      {
		enum nametype nope = NONE;

		for (i = OLD;  i <= INDEX;  i++)
		  if (p_name[i])
		    {
		      char const *cs;
		      char *getbuf;
		      char *diffbuf;
		      bool readonly = (outfile
				       && strcmp (outfile, p_name[i]) != 0);

		      if (nope == NONE || strcmp (p_name[nope], p_name[i]) != 0)
			{
			  cs = (version_controller
			        (p_name[i], readonly, (struct stat *) 0,
				 &getbuf, &diffbuf));
			  version_controlled[i] = !! cs;
			  if (cs)
			    {
			      if (version_get (p_name[i], cs, false, readonly,
					       getbuf, &st[i]))
				stat_errno[i] = 0;
			      else
				version_controlled[i] = 0;

			      free (getbuf);
			      free (diffbuf);

			      if (! stat_errno[i])
				break;
			    }
			}

		      nope = i;
		    }
	      }

	    if (i0 != NONE
		&& (i == NONE || (st[i].st_mode & S_IFMT) == file_type)
		&& maybe_reverse (p_name[i == NONE ? i0 : i], i == NONE,
				  i == NONE || st[i].st_size == 0)
		&& i == NONE)
	      i = i0;

	    if (i == NONE && p_says_nonexistent[reverse])
	      {
		int newdirs[3];
		int newdirs_min = INT_MAX;
		int distance_from_minimum[3];

		for (i = OLD;  i <= INDEX;  i++)
		  if (p_name[i])
		    {
		      newdirs[i] = (prefix_components (p_name[i], false)
				    - prefix_components (p_name[i], true));
		      if (newdirs[i] < newdirs_min)
			newdirs_min = newdirs[i];
		    }

		for (i = OLD;  i <= INDEX;  i++)
		  if (p_name[i])
		    distance_from_minimum[i] = newdirs[i] - newdirs_min;

		/* The best of the filenames which create the fewest directories. */
		i = best_name (p_name, distance_from_minimum);
	      }
 	  }
       }
 
//fix_flaw_line_below:
//    if ((pch_rename () || pch_copy ())
//fix_flaw_line_below:
//	&& ! inname
//fix_flaw_line_below:
//	&& ! ((i == OLD || i == NEW) &&
//fix_flaw_line_below:
//	      p_name[! reverse] &&
//fix_flaw_line_below:
//	      name_is_valid (p_name[! reverse])))
//fix_flaw_line_below:
//      {
//fix_flaw_line_below:
//	say (""Cannot %s file without two valid file names\n"", pch_rename () ? ""rename"" : ""copy"");
//fix_flaw_line_below:
//	skip_rest_of_patch = true;
//fix_flaw_line_below:
//      }
//fix_flaw_line_below:
//
     if (i == NONE)
       {
 	if (inname)
	inname = xstrdup (p_name[i]);
	inerrno = stat_errno[i];
	invc = version_controlled[i];
	instat = st[i];
      }

    return retval;
}
"
945,178681,,Remote,Not required,,CVE-2014-10073,https://www.cvedetails.com/cve/CVE-2014-10073/,CWE-22,Low,Partial,,,2018-04-20,5.0,The create_response function in server/server.c in Psensor before 1.1.4 allows Directory Traversal because it lacks a check for whether a file is under the webserver directory.,2019-10-03,Dir. Trav.,12,http://git.wpitchoune.net/gitweb/?p=psensor.git;a=commit;h=8b10426dcc0246c1712a99460dd470dcb1cc4d9c,8b10426dcc0246c1712a99460dd470dcb1cc4d9c,,2,,," create_response(const char *nurl, const char *method, unsigned int *rp_code)
 {
       char *page, *fpath, *rpath;
        struct MHD_Response *resp = NULL;
       int n;
 
        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {
                resp = create_response_api(nurl, method, rp_code);
        } else {
                fpath = get_path(nurl, server_data.www_dir);
 
               rpath = realpath(fpath, NULL);
               if (rpath) {
                       n = strlen(server_data.www_dir);
                       if (!strncmp(server_data.www_dir, rpath, n))
                               resp = create_response_file(nurl,
                                                           method,
                                                           rp_code,
                                                           fpath);
                       free(rpath);
               }
 
                free(fpath);
        }
}
"," create_response(const char *nurl, const char *method, unsigned int *rp_code)
 {
       char *page, *fpath;
        struct MHD_Response *resp = NULL;
 
        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {
                resp = create_response_api(nurl, method, rp_code);
        } else {
                fpath = get_path(nurl, server_data.www_dir);
 
               resp = create_response_file(nurl, method, rp_code, fpath);
 
                free(fpath);
        }
}
",C,"       char *page, *fpath, *rpath;
       int n;
               rpath = realpath(fpath, NULL);
               if (rpath) {
                       n = strlen(server_data.www_dir);
                       if (!strncmp(server_data.www_dir, rpath, n))
                               resp = create_response_file(nurl,
                                                           method,
                                                           rp_code,
                                                           fpath);
                       free(rpath);
               }
","       char *page, *fpath;
               resp = create_response_file(nurl, method, rp_code, fpath);
",30280f0093e8aea4bc8af8a46c2e529e8ec61ac9,"@@ -23,6 +23,7 @@
 #include <libintl.h>
 #define _(str) gettext(str)
 
+#include <limits.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -245,15 +246,25 @@ static struct MHD_Response *create_response_file(const char *nurl,
 static struct MHD_Response *
 create_response(const char *nurl, const char *method, unsigned int *rp_code)
 {
-       char *page, *fpath;
+       char *page, *fpath, *rpath;
        struct MHD_Response *resp = NULL;
+       int n;
 
        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {
                resp = create_response_api(nurl, method, rp_code);
        } else {
                fpath = get_path(nurl, server_data.www_dir);
 
-               resp = create_response_file(nurl, method, rp_code, fpath);
+               rpath = realpath(fpath, NULL);
+               if (rpath) {
+                       n = strlen(server_data.www_dir);
+                       if (!strncmp(server_data.www_dir, rpath, n))
+                               resp = create_response_file(nurl,
+                                                           method,
+                                                           rp_code,
+                                                           fpath);
+                       free(rpath);
+               }
 
                free(fpath);
        }
@@ -349,7 +360,7 @@ int main(int argc, char *argv[])
                switch (optc) {
                case 'w':
                        if (optarg)
-                               server_data.www_dir = strdup(optarg);
+                               server_data.www_dir = realpath(optarg, NULL);
                        break;
                case 'p':
                        if (optarg)
@@ -388,8 +399,14 @@ int main(int argc, char *argv[])
                exit(EXIT_FAILURE);
        }
 
-       if (!server_data.www_dir)
-               server_data.www_dir = strdup(DEFAULT_WWW_DIR);
+       if (!server_data.www_dir) {
+               server_data.www_dir = realpath(DEFAULT_WWW_DIR, NULL);
+               if (!server_data.www_dir) {
+                       fprintf(stderr,
+                               _(""Webserver directory does not exist.\n""));
+                       exit(EXIT_FAILURE);
+               }
+       }
 
        if (!log_file)
                log_file = strdup(DEFAULT_LOG_FILE);",wpitchoune,http://git.wpitchoune.net/gitweb/?p=psensor.git;a=blob;f=src/server/server.c;h=95998c8deb916813798042df837170f2600170c4;hb=95998c8deb916813798042df837170f2600170c4,http://git.wpitchoune.net/gitweb/?p=psensor.git;a=blob;f=src/server/server.c;h=3db6828760f47e0d0a081a519b3b79d3158c5b08;hb=3db6828760f47e0d0a081a519b3b79d3158c5b08,1," create_response(const char *nurl, const char *method, unsigned int *rp_code)
 {
//flaw_line_below:
       char *page, *fpath;
//fix_flaw_line_below:
//       char *page, *fpath, *rpath;
        struct MHD_Response *resp = NULL;
//fix_flaw_line_below:
//       int n;
 
        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {
                resp = create_response_api(nurl, method, rp_code);
        } else {
                fpath = get_path(nurl, server_data.www_dir);
 
//flaw_line_below:
               resp = create_response_file(nurl, method, rp_code, fpath);
//fix_flaw_line_below:
//               rpath = realpath(fpath, NULL);
//fix_flaw_line_below:
//               if (rpath) {
//fix_flaw_line_below:
//                       n = strlen(server_data.www_dir);
//fix_flaw_line_below:
//                       if (!strncmp(server_data.www_dir, rpath, n))
//fix_flaw_line_below:
//                               resp = create_response_file(nurl,
//fix_flaw_line_below:
//                                                           method,
//fix_flaw_line_below:
//                                                           rp_code,
//fix_flaw_line_below:
//                                                           fpath);
//fix_flaw_line_below:
//                       free(rpath);
//fix_flaw_line_below:
//               }
 
                free(fpath);
        }
}
"
946,178682,,Remote,Not required,,CVE-2014-10073,https://www.cvedetails.com/cve/CVE-2014-10073/,CWE-22,Low,Partial,,,2018-04-20,5.0,The create_response function in server/server.c in Psensor before 1.1.4 allows Directory Traversal because it lacks a check for whether a file is under the webserver directory.,2019-10-03,Dir. Trav.,9,http://git.wpitchoune.net/gitweb/?p=psensor.git;a=commit;h=8b10426dcc0246c1712a99460dd470dcb1cc4d9c,8b10426dcc0246c1712a99460dd470dcb1cc4d9c,,3,,,"int main(int argc, char *argv[])
{
	struct MHD_Daemon *d;
	int port, opti, optc, cmdok, ret, slog_interval;
	char *log_file, *slog_file;

	program_name = argv[0];

	setlocale(LC_ALL, """");

#if ENABLE_NLS
	bindtextdomain(PACKAGE, LOCALEDIR);
	textdomain(PACKAGE);
#endif

	server_data.www_dir = NULL;
#ifdef HAVE_GTOP
	server_data.psysinfo.interfaces = NULL;
#endif
	log_file = NULL;
	slog_file = NULL;
	slog_interval = 300;
	port = DEFAULT_PORT;
	cmdok = 1;

	while ((optc = getopt_long(argc,
				   argv,
				   ""vhp:w:d:l:"",
				   long_options,
				   &opti)) != -1) {
		switch (optc) {
		case 'w':
			if (optarg)
				server_data.www_dir = strdup(optarg);
			break;
		case 'p':
			if (optarg)
				port = atoi(optarg);
			break;
		case 'h':
			print_help();
                switch (optc) {
                case 'w':
                        if (optarg)
                               server_data.www_dir = realpath(optarg, NULL);
                        break;
                case 'p':
                        if (optarg)
			break;
		case 'l':
			if (optarg)
				log_file = strdup(optarg);
			break;
		case 0:
			if (!strcmp(long_options[opti].name, ""sensor-log-file""))
				slog_file = strdup(optarg);
			else if (!strcmp(long_options[opti].name,
					 ""sensor-log-interval""))
				slog_interval = atoi(optarg);
			break;
		default:
			cmdok = 0;
			break;
		}
	}

	if (!cmdok || optind != argc) {
		fprintf(stderr, _(""Try `%s --help' for more information.\n""),
			program_name);
		exit(EXIT_FAILURE);
	}

	if (!server_data.www_dir)
		server_data.www_dir = strdup(DEFAULT_WWW_DIR);

	if (!log_file)
		log_file = strdup(DEFAULT_LOG_FILE);

	pmutex_init(&mutex);

                exit(EXIT_FAILURE);
        }
 
       if (!server_data.www_dir) {
               server_data.www_dir = realpath(DEFAULT_WWW_DIR, NULL);
               if (!server_data.www_dir) {
                       fprintf(stderr,
                               _(""Webserver directory does not exist.\n""));
                       exit(EXIT_FAILURE);
               }
       }
 
        if (!log_file)
                log_file = strdup(DEFAULT_LOG_FILE);
			     port,
			     NULL, NULL, &cbk_http_request, server_data.sensors,
			     MHD_OPTION_END);
	if (!d) {
		log_err(_(""Failed to create Web server.""));
		exit(EXIT_FAILURE);
	}

	log_info(_(""Web server started on port: %d""), port);
	log_info(_(""WWW directory: %s""), server_data.www_dir);
	log_info(_(""URL: http://localhost:%d""), port);

	if (slog_file) {
		if (slog_interval <= 0)
			slog_interval = 300;
		ret = slog_activate(slog_file,
				    server_data.sensors,
				    &mutex,
				    slog_interval);
		if (!ret)
			log_err(_(""Failed to activate logging of sensors.""));
	}

	while (!server_stop_requested) {
		pmutex_lock(&mutex);

#ifdef HAVE_GTOP
		sysinfo_update(&server_data.psysinfo);
		cpu_usage_sensor_update(server_data.cpu_usage);
#endif

#ifdef HAVE_ATASMART
		atasmart_psensor_list_update(server_data.sensors);
#endif

		hddtemp_psensor_list_update(server_data.sensors);

		lmsensor_psensor_list_update(server_data.sensors);

		psensor_log_measures(server_data.sensors);

		pmutex_unlock(&mutex);
		sleep(5);
	}

	slog_close();

	MHD_stop_daemon(d);

	/* sanity cleanup for valgrind */
	psensor_list_free(server_data.sensors);
#ifdef HAVE_GTOP
	psensor_free(server_data.cpu_usage);
#endif
	free(server_data.www_dir);
	lmsensor_cleanup();

#ifdef HAVE_GTOP
	sysinfo_cleanup();
#endif

	if (log_file != DEFAULT_LOG_FILE)
		free(log_file);

	return EXIT_SUCCESS;
}
","int main(int argc, char *argv[])
{
	struct MHD_Daemon *d;
	int port, opti, optc, cmdok, ret, slog_interval;
	char *log_file, *slog_file;

	program_name = argv[0];

	setlocale(LC_ALL, """");

#if ENABLE_NLS
	bindtextdomain(PACKAGE, LOCALEDIR);
	textdomain(PACKAGE);
#endif

	server_data.www_dir = NULL;
#ifdef HAVE_GTOP
	server_data.psysinfo.interfaces = NULL;
#endif
	log_file = NULL;
	slog_file = NULL;
	slog_interval = 300;
	port = DEFAULT_PORT;
	cmdok = 1;

	while ((optc = getopt_long(argc,
				   argv,
				   ""vhp:w:d:l:"",
				   long_options,
				   &opti)) != -1) {
		switch (optc) {
		case 'w':
			if (optarg)
				server_data.www_dir = strdup(optarg);
			break;
		case 'p':
			if (optarg)
				port = atoi(optarg);
			break;
		case 'h':
			print_help();
                switch (optc) {
                case 'w':
                        if (optarg)
                               server_data.www_dir = strdup(optarg);
                        break;
                case 'p':
                        if (optarg)
			break;
		case 'l':
			if (optarg)
				log_file = strdup(optarg);
			break;
		case 0:
			if (!strcmp(long_options[opti].name, ""sensor-log-file""))
				slog_file = strdup(optarg);
			else if (!strcmp(long_options[opti].name,
					 ""sensor-log-interval""))
				slog_interval = atoi(optarg);
			break;
		default:
			cmdok = 0;
			break;
		}
	}

	if (!cmdok || optind != argc) {
		fprintf(stderr, _(""Try `%s --help' for more information.\n""),
			program_name);
		exit(EXIT_FAILURE);
	}

	if (!server_data.www_dir)
		server_data.www_dir = strdup(DEFAULT_WWW_DIR);

	if (!log_file)
		log_file = strdup(DEFAULT_LOG_FILE);

	pmutex_init(&mutex);

                exit(EXIT_FAILURE);
        }
 
       if (!server_data.www_dir)
               server_data.www_dir = strdup(DEFAULT_WWW_DIR);
 
        if (!log_file)
                log_file = strdup(DEFAULT_LOG_FILE);
			     port,
			     NULL, NULL, &cbk_http_request, server_data.sensors,
			     MHD_OPTION_END);
	if (!d) {
		log_err(_(""Failed to create Web server.""));
		exit(EXIT_FAILURE);
	}

	log_info(_(""Web server started on port: %d""), port);
	log_info(_(""WWW directory: %s""), server_data.www_dir);
	log_info(_(""URL: http://localhost:%d""), port);

	if (slog_file) {
		if (slog_interval <= 0)
			slog_interval = 300;
		ret = slog_activate(slog_file,
				    server_data.sensors,
				    &mutex,
				    slog_interval);
		if (!ret)
			log_err(_(""Failed to activate logging of sensors.""));
	}

	while (!server_stop_requested) {
		pmutex_lock(&mutex);

#ifdef HAVE_GTOP
		sysinfo_update(&server_data.psysinfo);
		cpu_usage_sensor_update(server_data.cpu_usage);
#endif

#ifdef HAVE_ATASMART
		atasmart_psensor_list_update(server_data.sensors);
#endif

		hddtemp_psensor_list_update(server_data.sensors);

		lmsensor_psensor_list_update(server_data.sensors);

		psensor_log_measures(server_data.sensors);

		pmutex_unlock(&mutex);
		sleep(5);
	}

	slog_close();

	MHD_stop_daemon(d);

	/* sanity cleanup for valgrind */
	psensor_list_free(server_data.sensors);
#ifdef HAVE_GTOP
	psensor_free(server_data.cpu_usage);
#endif
	free(server_data.www_dir);
	lmsensor_cleanup();

#ifdef HAVE_GTOP
	sysinfo_cleanup();
#endif

	if (log_file != DEFAULT_LOG_FILE)
		free(log_file);

	return EXIT_SUCCESS;
}
",C,"                               server_data.www_dir = realpath(optarg, NULL);
       if (!server_data.www_dir) {
               server_data.www_dir = realpath(DEFAULT_WWW_DIR, NULL);
               if (!server_data.www_dir) {
                       fprintf(stderr,
                               _(""Webserver directory does not exist.\n""));
                       exit(EXIT_FAILURE);
               }
       }
","                               server_data.www_dir = strdup(optarg);
       if (!server_data.www_dir)
               server_data.www_dir = strdup(DEFAULT_WWW_DIR);
",30280f0093e8aea4bc8af8a46c2e529e8ec61ac9,"@@ -23,6 +23,7 @@
 #include <libintl.h>
 #define _(str) gettext(str)
 
+#include <limits.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -245,15 +246,25 @@ static struct MHD_Response *create_response_file(const char *nurl,
 static struct MHD_Response *
 create_response(const char *nurl, const char *method, unsigned int *rp_code)
 {
-       char *page, *fpath;
+       char *page, *fpath, *rpath;
        struct MHD_Response *resp = NULL;
+       int n;
 
        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {
                resp = create_response_api(nurl, method, rp_code);
        } else {
                fpath = get_path(nurl, server_data.www_dir);
 
-               resp = create_response_file(nurl, method, rp_code, fpath);
+               rpath = realpath(fpath, NULL);
+               if (rpath) {
+                       n = strlen(server_data.www_dir);
+                       if (!strncmp(server_data.www_dir, rpath, n))
+                               resp = create_response_file(nurl,
+                                                           method,
+                                                           rp_code,
+                                                           fpath);
+                       free(rpath);
+               }
 
                free(fpath);
        }
@@ -349,7 +360,7 @@ int main(int argc, char *argv[])
                switch (optc) {
                case 'w':
                        if (optarg)
-                               server_data.www_dir = strdup(optarg);
+                               server_data.www_dir = realpath(optarg, NULL);
                        break;
                case 'p':
                        if (optarg)
@@ -388,8 +399,14 @@ int main(int argc, char *argv[])
                exit(EXIT_FAILURE);
        }
 
-       if (!server_data.www_dir)
-               server_data.www_dir = strdup(DEFAULT_WWW_DIR);
+       if (!server_data.www_dir) {
+               server_data.www_dir = realpath(DEFAULT_WWW_DIR, NULL);
+               if (!server_data.www_dir) {
+                       fprintf(stderr,
+                               _(""Webserver directory does not exist.\n""));
+                       exit(EXIT_FAILURE);
+               }
+       }
 
        if (!log_file)
                log_file = strdup(DEFAULT_LOG_FILE);",wpitchoune,http://git.wpitchoune.net/gitweb/?p=psensor.git;a=blob;f=src/server/server.c;h=95998c8deb916813798042df837170f2600170c4;hb=95998c8deb916813798042df837170f2600170c4,http://git.wpitchoune.net/gitweb/?p=psensor.git;a=blob;f=src/server/server.c;h=3db6828760f47e0d0a081a519b3b79d3158c5b08;hb=3db6828760f47e0d0a081a519b3b79d3158c5b08,1,"int main(int argc, char *argv[])
{
	struct MHD_Daemon *d;
	int port, opti, optc, cmdok, ret, slog_interval;
	char *log_file, *slog_file;

	program_name = argv[0];

	setlocale(LC_ALL, """");

#if ENABLE_NLS
	bindtextdomain(PACKAGE, LOCALEDIR);
	textdomain(PACKAGE);
#endif

	server_data.www_dir = NULL;
#ifdef HAVE_GTOP
	server_data.psysinfo.interfaces = NULL;
#endif
	log_file = NULL;
	slog_file = NULL;
	slog_interval = 300;
	port = DEFAULT_PORT;
	cmdok = 1;

	while ((optc = getopt_long(argc,
				   argv,
				   ""vhp:w:d:l:"",
				   long_options,
				   &opti)) != -1) {
		switch (optc) {
		case 'w':
			if (optarg)
				server_data.www_dir = strdup(optarg);
			break;
		case 'p':
			if (optarg)
				port = atoi(optarg);
			break;
		case 'h':
			print_help();
                switch (optc) {
                case 'w':
                        if (optarg)
//flaw_line_below:
                               server_data.www_dir = strdup(optarg);
//fix_flaw_line_below:
//                               server_data.www_dir = realpath(optarg, NULL);
                        break;
                case 'p':
                        if (optarg)
			break;
		case 'l':
			if (optarg)
				log_file = strdup(optarg);
			break;
		case 0:
			if (!strcmp(long_options[opti].name, ""sensor-log-file""))
				slog_file = strdup(optarg);
			else if (!strcmp(long_options[opti].name,
					 ""sensor-log-interval""))
				slog_interval = atoi(optarg);
			break;
		default:
			cmdok = 0;
			break;
		}
	}

	if (!cmdok || optind != argc) {
		fprintf(stderr, _(""Try `%s --help' for more information.\n""),
			program_name);
		exit(EXIT_FAILURE);
	}

	if (!server_data.www_dir)
		server_data.www_dir = strdup(DEFAULT_WWW_DIR);

	if (!log_file)
		log_file = strdup(DEFAULT_LOG_FILE);

	pmutex_init(&mutex);

                exit(EXIT_FAILURE);
        }
 
//flaw_line_below:
       if (!server_data.www_dir)
//flaw_line_below:
               server_data.www_dir = strdup(DEFAULT_WWW_DIR);
//fix_flaw_line_below:
//       if (!server_data.www_dir) {
//fix_flaw_line_below:
//               server_data.www_dir = realpath(DEFAULT_WWW_DIR, NULL);
//fix_flaw_line_below:
//               if (!server_data.www_dir) {
//fix_flaw_line_below:
//                       fprintf(stderr,
//fix_flaw_line_below:
//                               _(""Webserver directory does not exist.\n""));
//fix_flaw_line_below:
//                       exit(EXIT_FAILURE);
//fix_flaw_line_below:
//               }
//fix_flaw_line_below:
//       }
 
        if (!log_file)
                log_file = strdup(DEFAULT_LOG_FILE);
			     port,
			     NULL, NULL, &cbk_http_request, server_data.sensors,
			     MHD_OPTION_END);
	if (!d) {
		log_err(_(""Failed to create Web server.""));
		exit(EXIT_FAILURE);
	}

	log_info(_(""Web server started on port: %d""), port);
	log_info(_(""WWW directory: %s""), server_data.www_dir);
	log_info(_(""URL: http://localhost:%d""), port);

	if (slog_file) {
		if (slog_interval <= 0)
			slog_interval = 300;
		ret = slog_activate(slog_file,
				    server_data.sensors,
				    &mutex,
				    slog_interval);
		if (!ret)
			log_err(_(""Failed to activate logging of sensors.""));
	}

	while (!server_stop_requested) {
		pmutex_lock(&mutex);

#ifdef HAVE_GTOP
		sysinfo_update(&server_data.psysinfo);
		cpu_usage_sensor_update(server_data.cpu_usage);
#endif

#ifdef HAVE_ATASMART
		atasmart_psensor_list_update(server_data.sensors);
#endif

		hddtemp_psensor_list_update(server_data.sensors);

		lmsensor_psensor_list_update(server_data.sensors);

		psensor_log_measures(server_data.sensors);

		pmutex_unlock(&mutex);
		sleep(5);
	}

	slog_close();

	MHD_stop_daemon(d);

	/* sanity cleanup for valgrind */
	psensor_list_free(server_data.sensors);
#ifdef HAVE_GTOP
	psensor_free(server_data.cpu_usage);
#endif
	free(server_data.www_dir);
	lmsensor_cleanup();

#ifdef HAVE_GTOP
	sysinfo_cleanup();
#endif

	if (log_file != DEFAULT_LOG_FILE)
		free(log_file);

	return EXIT_SUCCESS;
}
"
1986,179722,,Remote,Not required,Partial,CVE-2011-3602,https://www.cvedetails.com/cve/CVE-2011-3602/,CWE-22,Low,,Partial,,2014-04-27,6.4,"Directory traversal vulnerability in device-linux.c in the router advertisement daemon (radvd) before 1.8.2 allows local users to overwrite arbitrary files, and remote attackers to overwrite certain files, via a .. (dot dot) in an interface name.  NOTE: this can be leveraged with a symlink to overwrite arbitrary files.",2014-04-28,Dir. Trav. ,4,https://github.com/reubenhwk/radvd/commit/92e22ca23e52066da2258df8c76a2dca8a428bcc,92e22ca23e52066da2258df8c76a2dca8a428bcc,"set_interface_var() doesn't check interface name and blindly does
fopen(path ""/"" ifname, ""w"") on it.  As ""ifname"" is an untrusted input, it
should be checked for "".."" and/or ""/"" in it.  Otherwise, an infected
unprivileged daemon may overwrite contents of file named ""mtu"",
""hoplimit"", etc. in arbitrary location with arbitrary 32-bit value in
decimal representation (""%d"").  If an attacker has a local account or
may create arbitrary symlinks with these names in any location (e.g.
/tmp), any file may be overwritten with a decimal value.",0,device-linux.c,"{""sha"": ""709eebc630e69faa8f5300a45f39c70742fa5add"", ""filename"": ""device-linux.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/reubenhwk/radvd/blob/92e22ca23e52066da2258df8c76a2dca8a428bcc/device-linux.c"", ""raw_url"": ""https://github.com/reubenhwk/radvd/raw/92e22ca23e52066da2258df8c76a2dca8a428bcc/device-linux.c"", ""contents_url"": ""https://api.github.com/repos/reubenhwk/radvd/contents/device-linux.c?ref=92e22ca23e52066da2258df8c76a2dca8a428bcc"", ""patch"": ""@@ -243,6 +243,10 @@ set_interface_var(const char *iface,\n \tif (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))\n \t\treturn -1;\n \n+\t/* No path traversal */\n+\tif (strstr(name, \""..\"") || strchr(name, '/'))\n+\t\treturn -1;\n+\n \tif (access(spath, F_OK) != 0)\n \t\treturn -1;\n ""}","set_interface_var(const char *iface,
		  const char *var, const char *name,
		  uint32_t val)
{
	FILE *fp;
	char spath[64+IFNAMSIZ];	/* XXX: magic constant */
 	if (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))
 		return -1;
 
	/* No path traversal */
	if (strstr(name, "".."") || strchr(name, '/'))
		return -1;

 	if (access(spath, F_OK) != 0)
 		return -1;
 
	fp = fopen(spath, ""w"");
	if (!fp) {
		if (name)
			flog(LOG_ERR, ""failed to set %s (%u) for %s: %s"",
			     name, val, iface, strerror(errno));
		return -1;
	}
	fprintf(fp, ""%u"", val);
	fclose(fp);

	return 0;
}
","set_interface_var(const char *iface,
		  const char *var, const char *name,
		  uint32_t val)
{
	FILE *fp;
	char spath[64+IFNAMSIZ];	/* XXX: magic constant */
 	if (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))
 		return -1;
 
 	if (access(spath, F_OK) != 0)
 		return -1;
 
	fp = fopen(spath, ""w"");
	if (!fp) {
		if (name)
			flog(LOG_ERR, ""failed to set %s (%u) for %s: %s"",
			     name, val, iface, strerror(errno));
		return -1;
	}
	fprintf(fp, ""%u"", val);
	fclose(fp);

	return 0;
}
",C,"	/* No path traversal */
	if (strstr(name, "".."") || strchr(name, '/'))
		return -1;

",,,"@@ -243,6 +243,10 @@ set_interface_var(const char *iface,
 	if (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))
 		return -1;
 
+	/* No path traversal */
+	if (strstr(name, "".."") || strchr(name, '/'))
+		return -1;
+
 	if (access(spath, F_OK) != 0)
 		return -1;
 ",radvd,92e22ca23e52066da2258df8c76a2dca8a428bcc,9dfaaaf740ce784541e76e68de4ae04dce2c0921,1,"set_interface_var(const char *iface,
		  const char *var, const char *name,
		  uint32_t val)
{
	FILE *fp;
	char spath[64+IFNAMSIZ];	/* XXX: magic constant */
 	if (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))
 		return -1;
 
//fix_flaw_line_below:
//	/* No path traversal */
//fix_flaw_line_below:
//	if (strstr(name, "".."") || strchr(name, '/'))
//fix_flaw_line_below:
//		return -1;
//fix_flaw_line_below:
//
 	if (access(spath, F_OK) != 0)
 		return -1;
 
	fp = fopen(spath, ""w"");
	if (!fp) {
		if (name)
			flog(LOG_ERR, ""failed to set %s (%u) for %s: %s"",
			     name, val, iface, strerror(errno));
		return -1;
	}
	fprintf(fp, ""%u"", val);
	fclose(fp);

	return 0;
}
"
2116,179852,,Remote,Not required,Partial,CVE-2015-2304,https://www.cvedetails.com/cve/CVE-2015-2304/,CWE-22,Low,,Partial,,2015-03-15,6.4,Absolute path traversal vulnerability in bsdcpio in libarchive 3.1.2 and earlier allows remote attackers to write to arbitrary files via a full pathname in an archive.,2018-10-30,Dir. Trav. ,2,https://github.com/libarchive/libarchive/commit/59357157706d47c365b2227739e17daba3607526,59357157706d47c365b2227739e17daba3607526,"Add ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS option

This fixes a directory traversal in the cpio tool.",0,cpio/cpio.c,"{""sha"": ""e52546e6f761a14ee1bb003235b97799422bf427"", ""filename"": ""cpio/bsdcpio.1"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/libarchive/libarchive/blob/59357157706d47c365b2227739e17daba3607526/cpio/bsdcpio.1"", ""raw_url"": ""https://github.com/libarchive/libarchive/raw/59357157706d47c365b2227739e17daba3607526/cpio/bsdcpio.1"", ""contents_url"": ""https://api.github.com/repos/libarchive/libarchive/contents/cpio/bsdcpio.1?ref=59357157706d47c365b2227739e17daba3607526"", ""patch"": ""@@ -156,7 +156,8 @@ See above for description.\n .It Fl Fl insecure\n (i and p mode only)\n Disable security checks during extraction or copying.\n-This allows extraction via symbolic links and path names containing\n+This allows extraction via symbolic links, absolute paths,\n+and path names containing\n .Sq ..\n in the name.\n .It Fl J , Fl Fl xz""}<_**next**_>{""sha"": ""b267e9b8a74486a3a92992555aa1f3fd96175649"", ""filename"": ""cpio/cpio.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/libarchive/libarchive/blob/59357157706d47c365b2227739e17daba3607526/cpio/cpio.c"", ""raw_url"": ""https://github.com/libarchive/libarchive/raw/59357157706d47c365b2227739e17daba3607526/cpio/cpio.c"", ""contents_url"": ""https://api.github.com/repos/libarchive/libarchive/contents/cpio/cpio.c?ref=59357157706d47c365b2227739e17daba3607526"", ""patch"": ""@@ -171,6 +171,7 @@ main(int argc, char *argv[])\n \tcpio->extract_flags |= ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER;\n \tcpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_SYMLINKS;\n \tcpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n+\tcpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS;\n \tcpio->extract_flags |= ARCHIVE_EXTRACT_PERM;\n \tcpio->extract_flags |= ARCHIVE_EXTRACT_FFLAGS;\n \tcpio->extract_flags |= ARCHIVE_EXTRACT_ACL;\n@@ -256,6 +257,7 @@ main(int argc, char *argv[])\n \t\tcase OPTION_INSECURE:\n \t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_SYMLINKS;\n \t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n+\t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS;\n \t\t\tbreak;\n \t\tcase 'L': /* GNU cpio */\n \t\t\tcpio->option_follow_links = 1;""}<_**next**_>{""sha"": ""ef635ac9dc6bb1e035265550bfb5fccff4769883"", ""filename"": ""libarchive/archive.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/libarchive/libarchive/blob/59357157706d47c365b2227739e17daba3607526/libarchive/archive.h"", ""raw_url"": ""https://github.com/libarchive/libarchive/raw/59357157706d47c365b2227739e17daba3607526/libarchive/archive.h"", ""contents_url"": ""https://api.github.com/repos/libarchive/libarchive/contents/libarchive/archive.h?ref=59357157706d47c365b2227739e17daba3607526"", ""patch"": ""@@ -649,6 +649,8 @@ __LA_DECL int archive_read_set_passphrase_callback(struct archive *,\n /* Default: Do not use HFS+ compression if it was not compressed. */\n /* This has no effect except on Mac OS v10.6 or later. */\n #define\tARCHIVE_EXTRACT_HFS_COMPRESSION_FORCED\t(0x8000)\n+/* Default: Do not reject entries with absolute paths */\n+#define ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS (0x10000)\n \n __LA_DECL int archive_read_extract(struct archive *, struct archive_entry *,\n \t\t     int flags);""}<_**next**_>{""sha"": ""a2e7afaa06d8909ab28ebda6f4058b61c707e43c"", ""filename"": ""libarchive/archive_write_disk.3"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/libarchive/libarchive/blob/59357157706d47c365b2227739e17daba3607526/libarchive/archive_write_disk.3"", ""raw_url"": ""https://github.com/libarchive/libarchive/raw/59357157706d47c365b2227739e17daba3607526/libarchive/archive_write_disk.3"", ""contents_url"": ""https://api.github.com/repos/libarchive/libarchive/contents/libarchive/archive_write_disk.3?ref=59357157706d47c365b2227739e17daba3607526"", ""patch"": ""@@ -177,6 +177,9 @@ The default is to not refuse such paths.\n Note that paths ending in\n .Pa ..\n always cause an error, regardless of this flag.\n+.It Cm ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS\n+Refuse to extract an absolute path.\n+The default is to not refuse such paths.\n .It Cm ARCHIVE_EXTRACT_SPARSE\n Scan data for blocks of NUL bytes and try to recreate them with holes.\n This results in sparse files, independent of whether the archive format""}<_**next**_>{""sha"": ""c1290eb3aec56a434a204269eb87dfcb0c2af16a"", ""filename"": ""libarchive/archive_write_disk_posix.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 3, ""changes"": 14, ""blob_url"": ""https://github.com/libarchive/libarchive/blob/59357157706d47c365b2227739e17daba3607526/libarchive/archive_write_disk_posix.c"", ""raw_url"": ""https://github.com/libarchive/libarchive/raw/59357157706d47c365b2227739e17daba3607526/libarchive/archive_write_disk_posix.c"", ""contents_url"": ""https://api.github.com/repos/libarchive/libarchive/contents/libarchive/archive_write_disk_posix.c?ref=59357157706d47c365b2227739e17daba3607526"", ""patch"": ""@@ -2509,8 +2509,9 @@ cleanup_pathname_win(struct archive_write_disk *a)\n /*\n  * Canonicalize the pathname.  In particular, this strips duplicate\n  * '/' characters, '.' elements, and trailing '/'.  It also raises an\n- * error for an empty path, a trailing '..' or (if _SECURE_NODOTDOT is\n- * set) any '..' in the path.\n+ * error for an empty path, a trailing '..', (if _SECURE_NODOTDOT is\n+ * set) any '..' in the path or (if ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS\n+ * is set) if the path is absolute.\n  */\n static int\n cleanup_pathname(struct archive_write_disk *a)\n@@ -2529,8 +2530,15 @@ cleanup_pathname(struct archive_write_disk *a)\n \tcleanup_pathname_win(a);\n #endif\n \t/* Skip leading '/'. */\n-\tif (*src == '/')\n+\tif (*src == '/') {\n+\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {\n+\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n+\t\t\t                  \""Path is absolute\"");\n+\t\t\treturn (ARCHIVE_FAILED);\n+\t\t}\n+\n \t\tseparator = *src++;\n+\t}\n \n \t/* Scan the pathname one element at a time. */\n \tfor (;;) {""}<_**next**_>{""sha"": ""2c942068f3d4d4ca50b726b9d0fbfb0bcd838d7a"", ""filename"": ""libarchive/test/test_write_disk_secure.c"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 0, ""changes"": 23, ""blob_url"": ""https://github.com/libarchive/libarchive/blob/59357157706d47c365b2227739e17daba3607526/libarchive/test/test_write_disk_secure.c"", ""raw_url"": ""https://github.com/libarchive/libarchive/raw/59357157706d47c365b2227739e17daba3607526/libarchive/test/test_write_disk_secure.c"", ""contents_url"": ""https://api.github.com/repos/libarchive/libarchive/contents/libarchive/test/test_write_disk_secure.c?ref=59357157706d47c365b2227739e17daba3607526"", ""patch"": ""@@ -178,6 +178,29 @@ DEFINE_TEST(test_write_disk_secure)\n \tassert(S_ISDIR(st.st_mode));\n \tarchive_entry_free(ae);\n \n+\t/*\n+\t * Without security checks, we should be able to\n+\t * extract an absolute path.\n+\t */\n+\tassert((ae = archive_entry_new()) != NULL);\n+\tarchive_entry_copy_pathname(ae, \""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp\"");\n+\tarchive_entry_set_mode(ae, S_IFREG | 0777);\n+\tassert(0 == archive_write_header(a, ae));\n+\tassert(0 == archive_write_finish_entry(a));\n+\tassertFileExists(\""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp\"");\n+\tassert(0 == unlink(\""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp\""));\n+\n+\t/* But with security checks enabled, this should fail. */\n+\tassert(archive_entry_clear(ae) != NULL);\n+\tarchive_entry_copy_pathname(ae, \""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp\"");\n+\tarchive_entry_set_mode(ae, S_IFREG | 0777);\n+\tarchive_write_disk_set_options(a, ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS);\n+\tfailure(\""Extracting an absolute path should fail here.\"");\n+\tassertEqualInt(ARCHIVE_FAILED, archive_write_header(a, ae));\n+\tarchive_entry_free(ae);\n+\tassert(0 == archive_write_finish_entry(a));\n+\tassertFileNotExists(\""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp\"");\n+\n \tassertEqualInt(ARCHIVE_OK, archive_write_free(a));\n \n \t/* Test the entries on disk. */""}","main(int argc, char *argv[])
{
	static char buff[16384];
	struct cpio _cpio; /* Allocated on stack. */
	struct cpio *cpio;
	const char *errmsg;
	int uid, gid;
	int opt;

	cpio = &_cpio;
	memset(cpio, 0, sizeof(*cpio));
	cpio->buff = buff;
	cpio->buff_size = sizeof(buff);

#if defined(HAVE_SIGACTION) && defined(SIGPIPE)
	{ /* Ignore SIGPIPE signals. */
		struct sigaction sa;
		sigemptyset(&sa.sa_mask);
		sa.sa_flags = 0;
		sa.sa_handler = SIG_IGN;
		sigaction(SIGPIPE, &sa, NULL);
	}
#endif

	/* Set lafe_progname before calling lafe_warnc. */
	lafe_setprogname(*argv, ""bsdcpio"");

#if HAVE_SETLOCALE
	if (setlocale(LC_ALL, """") == NULL)
		lafe_warnc(0, ""Failed to set default locale"");
#endif

	cpio->uid_override = -1;
	cpio->gid_override = -1;
	cpio->argv = argv;
	cpio->argc = argc;
	cpio->mode = '\0';
	cpio->verbose = 0;
	cpio->compress = '\0';
	cpio->extract_flags = ARCHIVE_EXTRACT_NO_AUTODIR;
 	cpio->extract_flags |= ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER;
 	cpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_SYMLINKS;
 	cpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;
	cpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS;
 	cpio->extract_flags |= ARCHIVE_EXTRACT_PERM;
 	cpio->extract_flags |= ARCHIVE_EXTRACT_FFLAGS;
 	cpio->extract_flags |= ARCHIVE_EXTRACT_ACL;
#if !defined(_WIN32) && !defined(__CYGWIN__)
	if (geteuid() == 0)
		cpio->extract_flags |= ARCHIVE_EXTRACT_OWNER;
#endif
	cpio->bytes_per_block = 512;
	cpio->filename = NULL;

	cpio->matching = archive_match_new();
	if (cpio->matching == NULL)
		lafe_errc(1, 0, ""Out of memory"");

	while ((opt = cpio_getopt(cpio)) != -1) {
		switch (opt) {
		case '0': /* GNU convention: --null, -0 */
			cpio->option_null = 1;
			break;
		case 'A': /* NetBSD/OpenBSD */
			cpio->option_append = 1;
			break;
		case 'a': /* POSIX 1997 */
			cpio->option_atime_restore = 1;
			break;
		case 'B': /* POSIX 1997 */
			cpio->bytes_per_block = 5120;
			break;
		case OPTION_B64ENCODE:
			cpio->add_filter = opt;
			break;
		case 'C': /* NetBSD/OpenBSD */
			cpio->bytes_per_block = atoi(cpio->argument);
			if (cpio->bytes_per_block <= 0)
				lafe_errc(1, 0, ""Invalid blocksize %s"", cpio->argument);
			break;
		case 'c': /* POSIX 1997 */
			cpio->format = ""odc"";
			break;
		case 'd': /* POSIX 1997 */
			cpio->extract_flags &= ~ARCHIVE_EXTRACT_NO_AUTODIR;
			break;
		case 'E': /* NetBSD/OpenBSD */
			if (archive_match_include_pattern_from_file(
			    cpio->matching, cpio->argument,
			    cpio->option_null) != ARCHIVE_OK)
				lafe_errc(1, 0, ""Error : %s"",
				    archive_error_string(cpio->matching));
			break;
		case 'F': /* NetBSD/OpenBSD/GNU cpio */
			cpio->filename = cpio->argument;
			break;
		case 'f': /* POSIX 1997 */
			if (archive_match_exclude_pattern(cpio->matching,
			    cpio->argument) != ARCHIVE_OK)
				lafe_errc(1, 0, ""Error : %s"",
				    archive_error_string(cpio->matching));
			break;
		case OPTION_GRZIP:
			cpio->compress = opt;
			break;
		case 'H': /* GNU cpio (also --format) */
			cpio->format = cpio->argument;
			break;
		case 'h':
			long_help();
			break;
		case 'I': /* NetBSD/OpenBSD */
			cpio->filename = cpio->argument;
			break;
		case 'i': /* POSIX 1997 */
			if (cpio->mode != '\0')
				lafe_errc(1, 0,
				    ""Cannot use both -i and -%c"", cpio->mode);
			cpio->mode = opt;
			break;
		case 'J': /* GNU tar, others */
			cpio->compress = opt;
			break;
		case 'j': /* GNU tar, others */
			cpio->compress = opt;
			break;
 		case OPTION_INSECURE:
 			cpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_SYMLINKS;
 			cpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NODOTDOT;
			cpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS;
 			break;
 		case 'L': /* GNU cpio */
 			cpio->option_follow_links = 1;
			break;
		case 'l': /* POSIX 1997 */
			cpio->option_link = 1;
			break;
		case OPTION_LRZIP:
		case OPTION_LZ4:
		case OPTION_LZMA: /* GNU tar, others */
		case OPTION_LZOP: /* GNU tar, others */
			cpio->compress = opt;
			break;
		case 'm': /* POSIX 1997 */
			cpio->extract_flags |= ARCHIVE_EXTRACT_TIME;
			break;
		case 'n': /* GNU cpio */
			cpio->option_numeric_uid_gid = 1;
			break;
		case OPTION_NO_PRESERVE_OWNER: /* GNU cpio */
			cpio->extract_flags &= ~ARCHIVE_EXTRACT_OWNER;
			break;
		case 'O': /* GNU cpio */
			cpio->filename = cpio->argument;
			break;
		case 'o': /* POSIX 1997 */
			if (cpio->mode != '\0')
				lafe_errc(1, 0,
				    ""Cannot use both -o and -%c"", cpio->mode);
			cpio->mode = opt;
			break;
		case 'p': /* POSIX 1997 */
			if (cpio->mode != '\0')
				lafe_errc(1, 0,
				    ""Cannot use both -p and -%c"", cpio->mode);
			cpio->mode = opt;
			cpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NODOTDOT;
			break;
		case OPTION_PASSPHRASE:
			cpio->passphrase = cpio->argument;
			break;
		case OPTION_PRESERVE_OWNER:
			cpio->extract_flags |= ARCHIVE_EXTRACT_OWNER;
			break;
		case OPTION_QUIET: /* GNU cpio */
			cpio->quiet = 1;
			break;
		case 'R': /* GNU cpio, also --owner */
			/* TODO: owner_parse should return uname/gname
			 * also; use that to set [ug]name_override. */
			errmsg = owner_parse(cpio->argument, &uid, &gid);
			if (errmsg) {
				lafe_warnc(-1, ""%s"", errmsg);
				usage();
			}
			if (uid != -1) {
				cpio->uid_override = uid;
				cpio->uname_override = NULL;
			}
			if (gid != -1) {
				cpio->gid_override = gid;
				cpio->gname_override = NULL;
			}
			break;
		case 'r': /* POSIX 1997 */
			cpio->option_rename = 1;
			break;
		case 't': /* POSIX 1997 */
			cpio->option_list = 1;
			break;
		case 'u': /* POSIX 1997 */
			cpio->extract_flags
			    &= ~ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER;
			break;
		case OPTION_UUENCODE:
			cpio->add_filter = opt;
			break;
		case 'v': /* POSIX 1997 */
			cpio->verbose++;
			break;
		case 'V': /* GNU cpio */
			cpio->dot++;
			break;
		case OPTION_VERSION: /* GNU convention */
			version();
			break;
#if 0
	        /*
		 * cpio_getopt() handles -W specially, so it's not
		 * available here.
		 */
		case 'W': /* Obscure, but useful GNU convention. */
			break;
#endif
		case 'y': /* tar convention */
			cpio->compress = opt;
			break;
		case 'Z': /* tar convention */
			cpio->compress = opt;
			break;
		case 'z': /* tar convention */
			cpio->compress = opt;
			break;
		default:
			usage();
		}
	}

	/*
	 * Sanity-check args, error out on nonsensical combinations.
	 */
	/* -t implies -i if no mode was specified. */
	if (cpio->option_list && cpio->mode == '\0')
		cpio->mode = 'i';
	/* -t requires -i */
	if (cpio->option_list && cpio->mode != 'i')
		lafe_errc(1, 0, ""Option -t requires -i"");
	/* -n requires -it */
	if (cpio->option_numeric_uid_gid && !cpio->option_list)
		lafe_errc(1, 0, ""Option -n requires -it"");
	/* Can only specify format when writing */
	if (cpio->format != NULL && cpio->mode != 'o')
		lafe_errc(1, 0, ""Option --format requires -o"");
	/* -l requires -p */
	if (cpio->option_link && cpio->mode != 'p')
		lafe_errc(1, 0, ""Option -l requires -p"");
	/* -v overrides -V */
	if (cpio->dot && cpio->verbose)
		cpio->dot = 0;
	/* TODO: Flag other nonsensical combinations. */

	switch (cpio->mode) {
	case 'o':
		/* TODO: Implement old binary format in libarchive,
		   use that here. */
		if (cpio->format == NULL)
			cpio->format = ""odc""; /* Default format */

		mode_out(cpio);
		break;
	case 'i':
		while (*cpio->argv != NULL) {
			if (archive_match_include_pattern(cpio->matching,
			    *cpio->argv) != ARCHIVE_OK)
				lafe_errc(1, 0, ""Error : %s"",
				    archive_error_string(cpio->matching));
			--cpio->argc;
			++cpio->argv;
		}
		if (cpio->option_list)
			mode_list(cpio);
		else
			mode_in(cpio);
		break;
	case 'p':
		if (*cpio->argv == NULL || **cpio->argv == '\0')
			lafe_errc(1, 0,
			    ""-p mode requires a target directory"");
		mode_pass(cpio, *cpio->argv);
		break;
	default:
		lafe_errc(1, 0,
		    ""Must specify at least one of -i, -o, or -p"");
	}

	archive_match_free(cpio->matching);
	free_cache(cpio->gname_cache);
	free_cache(cpio->uname_cache);
	free(cpio->destdir);
	passphrase_free(cpio->ppbuff);
	return (cpio->return_value);
}
","main(int argc, char *argv[])
{
	static char buff[16384];
	struct cpio _cpio; /* Allocated on stack. */
	struct cpio *cpio;
	const char *errmsg;
	int uid, gid;
	int opt;

	cpio = &_cpio;
	memset(cpio, 0, sizeof(*cpio));
	cpio->buff = buff;
	cpio->buff_size = sizeof(buff);

#if defined(HAVE_SIGACTION) && defined(SIGPIPE)
	{ /* Ignore SIGPIPE signals. */
		struct sigaction sa;
		sigemptyset(&sa.sa_mask);
		sa.sa_flags = 0;
		sa.sa_handler = SIG_IGN;
		sigaction(SIGPIPE, &sa, NULL);
	}
#endif

	/* Set lafe_progname before calling lafe_warnc. */
	lafe_setprogname(*argv, ""bsdcpio"");

#if HAVE_SETLOCALE
	if (setlocale(LC_ALL, """") == NULL)
		lafe_warnc(0, ""Failed to set default locale"");
#endif

	cpio->uid_override = -1;
	cpio->gid_override = -1;
	cpio->argv = argv;
	cpio->argc = argc;
	cpio->mode = '\0';
	cpio->verbose = 0;
	cpio->compress = '\0';
	cpio->extract_flags = ARCHIVE_EXTRACT_NO_AUTODIR;
 	cpio->extract_flags |= ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER;
 	cpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_SYMLINKS;
 	cpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;
 	cpio->extract_flags |= ARCHIVE_EXTRACT_PERM;
 	cpio->extract_flags |= ARCHIVE_EXTRACT_FFLAGS;
 	cpio->extract_flags |= ARCHIVE_EXTRACT_ACL;
#if !defined(_WIN32) && !defined(__CYGWIN__)
	if (geteuid() == 0)
		cpio->extract_flags |= ARCHIVE_EXTRACT_OWNER;
#endif
	cpio->bytes_per_block = 512;
	cpio->filename = NULL;

	cpio->matching = archive_match_new();
	if (cpio->matching == NULL)
		lafe_errc(1, 0, ""Out of memory"");

	while ((opt = cpio_getopt(cpio)) != -1) {
		switch (opt) {
		case '0': /* GNU convention: --null, -0 */
			cpio->option_null = 1;
			break;
		case 'A': /* NetBSD/OpenBSD */
			cpio->option_append = 1;
			break;
		case 'a': /* POSIX 1997 */
			cpio->option_atime_restore = 1;
			break;
		case 'B': /* POSIX 1997 */
			cpio->bytes_per_block = 5120;
			break;
		case OPTION_B64ENCODE:
			cpio->add_filter = opt;
			break;
		case 'C': /* NetBSD/OpenBSD */
			cpio->bytes_per_block = atoi(cpio->argument);
			if (cpio->bytes_per_block <= 0)
				lafe_errc(1, 0, ""Invalid blocksize %s"", cpio->argument);
			break;
		case 'c': /* POSIX 1997 */
			cpio->format = ""odc"";
			break;
		case 'd': /* POSIX 1997 */
			cpio->extract_flags &= ~ARCHIVE_EXTRACT_NO_AUTODIR;
			break;
		case 'E': /* NetBSD/OpenBSD */
			if (archive_match_include_pattern_from_file(
			    cpio->matching, cpio->argument,
			    cpio->option_null) != ARCHIVE_OK)
				lafe_errc(1, 0, ""Error : %s"",
				    archive_error_string(cpio->matching));
			break;
		case 'F': /* NetBSD/OpenBSD/GNU cpio */
			cpio->filename = cpio->argument;
			break;
		case 'f': /* POSIX 1997 */
			if (archive_match_exclude_pattern(cpio->matching,
			    cpio->argument) != ARCHIVE_OK)
				lafe_errc(1, 0, ""Error : %s"",
				    archive_error_string(cpio->matching));
			break;
		case OPTION_GRZIP:
			cpio->compress = opt;
			break;
		case 'H': /* GNU cpio (also --format) */
			cpio->format = cpio->argument;
			break;
		case 'h':
			long_help();
			break;
		case 'I': /* NetBSD/OpenBSD */
			cpio->filename = cpio->argument;
			break;
		case 'i': /* POSIX 1997 */
			if (cpio->mode != '\0')
				lafe_errc(1, 0,
				    ""Cannot use both -i and -%c"", cpio->mode);
			cpio->mode = opt;
			break;
		case 'J': /* GNU tar, others */
			cpio->compress = opt;
			break;
		case 'j': /* GNU tar, others */
			cpio->compress = opt;
			break;
 		case OPTION_INSECURE:
 			cpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_SYMLINKS;
 			cpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NODOTDOT;
 			break;
 		case 'L': /* GNU cpio */
 			cpio->option_follow_links = 1;
			break;
		case 'l': /* POSIX 1997 */
			cpio->option_link = 1;
			break;
		case OPTION_LRZIP:
		case OPTION_LZ4:
		case OPTION_LZMA: /* GNU tar, others */
		case OPTION_LZOP: /* GNU tar, others */
			cpio->compress = opt;
			break;
		case 'm': /* POSIX 1997 */
			cpio->extract_flags |= ARCHIVE_EXTRACT_TIME;
			break;
		case 'n': /* GNU cpio */
			cpio->option_numeric_uid_gid = 1;
			break;
		case OPTION_NO_PRESERVE_OWNER: /* GNU cpio */
			cpio->extract_flags &= ~ARCHIVE_EXTRACT_OWNER;
			break;
		case 'O': /* GNU cpio */
			cpio->filename = cpio->argument;
			break;
		case 'o': /* POSIX 1997 */
			if (cpio->mode != '\0')
				lafe_errc(1, 0,
				    ""Cannot use both -o and -%c"", cpio->mode);
			cpio->mode = opt;
			break;
		case 'p': /* POSIX 1997 */
			if (cpio->mode != '\0')
				lafe_errc(1, 0,
				    ""Cannot use both -p and -%c"", cpio->mode);
			cpio->mode = opt;
			cpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NODOTDOT;
			break;
		case OPTION_PASSPHRASE:
			cpio->passphrase = cpio->argument;
			break;
		case OPTION_PRESERVE_OWNER:
			cpio->extract_flags |= ARCHIVE_EXTRACT_OWNER;
			break;
		case OPTION_QUIET: /* GNU cpio */
			cpio->quiet = 1;
			break;
		case 'R': /* GNU cpio, also --owner */
			/* TODO: owner_parse should return uname/gname
			 * also; use that to set [ug]name_override. */
			errmsg = owner_parse(cpio->argument, &uid, &gid);
			if (errmsg) {
				lafe_warnc(-1, ""%s"", errmsg);
				usage();
			}
			if (uid != -1) {
				cpio->uid_override = uid;
				cpio->uname_override = NULL;
			}
			if (gid != -1) {
				cpio->gid_override = gid;
				cpio->gname_override = NULL;
			}
			break;
		case 'r': /* POSIX 1997 */
			cpio->option_rename = 1;
			break;
		case 't': /* POSIX 1997 */
			cpio->option_list = 1;
			break;
		case 'u': /* POSIX 1997 */
			cpio->extract_flags
			    &= ~ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER;
			break;
		case OPTION_UUENCODE:
			cpio->add_filter = opt;
			break;
		case 'v': /* POSIX 1997 */
			cpio->verbose++;
			break;
		case 'V': /* GNU cpio */
			cpio->dot++;
			break;
		case OPTION_VERSION: /* GNU convention */
			version();
			break;
#if 0
	        /*
		 * cpio_getopt() handles -W specially, so it's not
		 * available here.
		 */
		case 'W': /* Obscure, but useful GNU convention. */
			break;
#endif
		case 'y': /* tar convention */
			cpio->compress = opt;
			break;
		case 'Z': /* tar convention */
			cpio->compress = opt;
			break;
		case 'z': /* tar convention */
			cpio->compress = opt;
			break;
		default:
			usage();
		}
	}

	/*
	 * Sanity-check args, error out on nonsensical combinations.
	 */
	/* -t implies -i if no mode was specified. */
	if (cpio->option_list && cpio->mode == '\0')
		cpio->mode = 'i';
	/* -t requires -i */
	if (cpio->option_list && cpio->mode != 'i')
		lafe_errc(1, 0, ""Option -t requires -i"");
	/* -n requires -it */
	if (cpio->option_numeric_uid_gid && !cpio->option_list)
		lafe_errc(1, 0, ""Option -n requires -it"");
	/* Can only specify format when writing */
	if (cpio->format != NULL && cpio->mode != 'o')
		lafe_errc(1, 0, ""Option --format requires -o"");
	/* -l requires -p */
	if (cpio->option_link && cpio->mode != 'p')
		lafe_errc(1, 0, ""Option -l requires -p"");
	/* -v overrides -V */
	if (cpio->dot && cpio->verbose)
		cpio->dot = 0;
	/* TODO: Flag other nonsensical combinations. */

	switch (cpio->mode) {
	case 'o':
		/* TODO: Implement old binary format in libarchive,
		   use that here. */
		if (cpio->format == NULL)
			cpio->format = ""odc""; /* Default format */

		mode_out(cpio);
		break;
	case 'i':
		while (*cpio->argv != NULL) {
			if (archive_match_include_pattern(cpio->matching,
			    *cpio->argv) != ARCHIVE_OK)
				lafe_errc(1, 0, ""Error : %s"",
				    archive_error_string(cpio->matching));
			--cpio->argc;
			++cpio->argv;
		}
		if (cpio->option_list)
			mode_list(cpio);
		else
			mode_in(cpio);
		break;
	case 'p':
		if (*cpio->argv == NULL || **cpio->argv == '\0')
			lafe_errc(1, 0,
			    ""-p mode requires a target directory"");
		mode_pass(cpio, *cpio->argv);
		break;
	default:
		lafe_errc(1, 0,
		    ""Must specify at least one of -i, -o, or -p"");
	}

	archive_match_free(cpio->matching);
	free_cache(cpio->gname_cache);
	free_cache(cpio->uname_cache);
	free(cpio->destdir);
	passphrase_free(cpio->ppbuff);
	return (cpio->return_value);
}
",C,"	cpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS;
			cpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS;
",,,"@@ -171,6 +171,7 @@ main(int argc, char *argv[])
 	cpio->extract_flags |= ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER;
 	cpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_SYMLINKS;
 	cpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;
+	cpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS;
 	cpio->extract_flags |= ARCHIVE_EXTRACT_PERM;
 	cpio->extract_flags |= ARCHIVE_EXTRACT_FFLAGS;
 	cpio->extract_flags |= ARCHIVE_EXTRACT_ACL;
@@ -256,6 +257,7 @@ main(int argc, char *argv[])
 		case OPTION_INSECURE:
 			cpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_SYMLINKS;
 			cpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NODOTDOT;
+			cpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS;
 			break;
 		case 'L': /* GNU cpio */
 			cpio->option_follow_links = 1;",libarchive,59357157706d47c365b2227739e17daba3607526,fc04ba0941fed6b55fa5b90858e1104c8c937d72,1,"main(int argc, char *argv[])
{
	static char buff[16384];
	struct cpio _cpio; /* Allocated on stack. */
	struct cpio *cpio;
	const char *errmsg;
	int uid, gid;
	int opt;

	cpio = &_cpio;
	memset(cpio, 0, sizeof(*cpio));
	cpio->buff = buff;
	cpio->buff_size = sizeof(buff);

#if defined(HAVE_SIGACTION) && defined(SIGPIPE)
	{ /* Ignore SIGPIPE signals. */
		struct sigaction sa;
		sigemptyset(&sa.sa_mask);
		sa.sa_flags = 0;
		sa.sa_handler = SIG_IGN;
		sigaction(SIGPIPE, &sa, NULL);
	}
#endif

	/* Set lafe_progname before calling lafe_warnc. */
	lafe_setprogname(*argv, ""bsdcpio"");

#if HAVE_SETLOCALE
	if (setlocale(LC_ALL, """") == NULL)
		lafe_warnc(0, ""Failed to set default locale"");
#endif

	cpio->uid_override = -1;
	cpio->gid_override = -1;
	cpio->argv = argv;
	cpio->argc = argc;
	cpio->mode = '\0';
	cpio->verbose = 0;
	cpio->compress = '\0';
	cpio->extract_flags = ARCHIVE_EXTRACT_NO_AUTODIR;
 	cpio->extract_flags |= ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER;
 	cpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_SYMLINKS;
 	cpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;
//fix_flaw_line_below:
//	cpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS;
 	cpio->extract_flags |= ARCHIVE_EXTRACT_PERM;
 	cpio->extract_flags |= ARCHIVE_EXTRACT_FFLAGS;
 	cpio->extract_flags |= ARCHIVE_EXTRACT_ACL;
#if !defined(_WIN32) && !defined(__CYGWIN__)
	if (geteuid() == 0)
		cpio->extract_flags |= ARCHIVE_EXTRACT_OWNER;
#endif
	cpio->bytes_per_block = 512;
	cpio->filename = NULL;

	cpio->matching = archive_match_new();
	if (cpio->matching == NULL)
		lafe_errc(1, 0, ""Out of memory"");

	while ((opt = cpio_getopt(cpio)) != -1) {
		switch (opt) {
		case '0': /* GNU convention: --null, -0 */
			cpio->option_null = 1;
			break;
		case 'A': /* NetBSD/OpenBSD */
			cpio->option_append = 1;
			break;
		case 'a': /* POSIX 1997 */
			cpio->option_atime_restore = 1;
			break;
		case 'B': /* POSIX 1997 */
			cpio->bytes_per_block = 5120;
			break;
		case OPTION_B64ENCODE:
			cpio->add_filter = opt;
			break;
		case 'C': /* NetBSD/OpenBSD */
			cpio->bytes_per_block = atoi(cpio->argument);
			if (cpio->bytes_per_block <= 0)
				lafe_errc(1, 0, ""Invalid blocksize %s"", cpio->argument);
			break;
		case 'c': /* POSIX 1997 */
			cpio->format = ""odc"";
			break;
		case 'd': /* POSIX 1997 */
			cpio->extract_flags &= ~ARCHIVE_EXTRACT_NO_AUTODIR;
			break;
		case 'E': /* NetBSD/OpenBSD */
			if (archive_match_include_pattern_from_file(
			    cpio->matching, cpio->argument,
			    cpio->option_null) != ARCHIVE_OK)
				lafe_errc(1, 0, ""Error : %s"",
				    archive_error_string(cpio->matching));
			break;
		case 'F': /* NetBSD/OpenBSD/GNU cpio */
			cpio->filename = cpio->argument;
			break;
		case 'f': /* POSIX 1997 */
			if (archive_match_exclude_pattern(cpio->matching,
			    cpio->argument) != ARCHIVE_OK)
				lafe_errc(1, 0, ""Error : %s"",
				    archive_error_string(cpio->matching));
			break;
		case OPTION_GRZIP:
			cpio->compress = opt;
			break;
		case 'H': /* GNU cpio (also --format) */
			cpio->format = cpio->argument;
			break;
		case 'h':
			long_help();
			break;
		case 'I': /* NetBSD/OpenBSD */
			cpio->filename = cpio->argument;
			break;
		case 'i': /* POSIX 1997 */
			if (cpio->mode != '\0')
				lafe_errc(1, 0,
				    ""Cannot use both -i and -%c"", cpio->mode);
			cpio->mode = opt;
			break;
		case 'J': /* GNU tar, others */
			cpio->compress = opt;
			break;
		case 'j': /* GNU tar, others */
			cpio->compress = opt;
			break;
 		case OPTION_INSECURE:
 			cpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_SYMLINKS;
 			cpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NODOTDOT;
//fix_flaw_line_below:
//			cpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS;
 			break;
 		case 'L': /* GNU cpio */
 			cpio->option_follow_links = 1;
			break;
		case 'l': /* POSIX 1997 */
			cpio->option_link = 1;
			break;
		case OPTION_LRZIP:
		case OPTION_LZ4:
		case OPTION_LZMA: /* GNU tar, others */
		case OPTION_LZOP: /* GNU tar, others */
			cpio->compress = opt;
			break;
		case 'm': /* POSIX 1997 */
			cpio->extract_flags |= ARCHIVE_EXTRACT_TIME;
			break;
		case 'n': /* GNU cpio */
			cpio->option_numeric_uid_gid = 1;
			break;
		case OPTION_NO_PRESERVE_OWNER: /* GNU cpio */
			cpio->extract_flags &= ~ARCHIVE_EXTRACT_OWNER;
			break;
		case 'O': /* GNU cpio */
			cpio->filename = cpio->argument;
			break;
		case 'o': /* POSIX 1997 */
			if (cpio->mode != '\0')
				lafe_errc(1, 0,
				    ""Cannot use both -o and -%c"", cpio->mode);
			cpio->mode = opt;
			break;
		case 'p': /* POSIX 1997 */
			if (cpio->mode != '\0')
				lafe_errc(1, 0,
				    ""Cannot use both -p and -%c"", cpio->mode);
			cpio->mode = opt;
			cpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NODOTDOT;
			break;
		case OPTION_PASSPHRASE:
			cpio->passphrase = cpio->argument;
			break;
		case OPTION_PRESERVE_OWNER:
			cpio->extract_flags |= ARCHIVE_EXTRACT_OWNER;
			break;
		case OPTION_QUIET: /* GNU cpio */
			cpio->quiet = 1;
			break;
		case 'R': /* GNU cpio, also --owner */
			/* TODO: owner_parse should return uname/gname
			 * also; use that to set [ug]name_override. */
			errmsg = owner_parse(cpio->argument, &uid, &gid);
			if (errmsg) {
				lafe_warnc(-1, ""%s"", errmsg);
				usage();
			}
			if (uid != -1) {
				cpio->uid_override = uid;
				cpio->uname_override = NULL;
			}
			if (gid != -1) {
				cpio->gid_override = gid;
				cpio->gname_override = NULL;
			}
			break;
		case 'r': /* POSIX 1997 */
			cpio->option_rename = 1;
			break;
		case 't': /* POSIX 1997 */
			cpio->option_list = 1;
			break;
		case 'u': /* POSIX 1997 */
			cpio->extract_flags
			    &= ~ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER;
			break;
		case OPTION_UUENCODE:
			cpio->add_filter = opt;
			break;
		case 'v': /* POSIX 1997 */
			cpio->verbose++;
			break;
		case 'V': /* GNU cpio */
			cpio->dot++;
			break;
		case OPTION_VERSION: /* GNU convention */
			version();
			break;
#if 0
	        /*
		 * cpio_getopt() handles -W specially, so it's not
		 * available here.
		 */
		case 'W': /* Obscure, but useful GNU convention. */
			break;
#endif
		case 'y': /* tar convention */
			cpio->compress = opt;
			break;
		case 'Z': /* tar convention */
			cpio->compress = opt;
			break;
		case 'z': /* tar convention */
			cpio->compress = opt;
			break;
		default:
			usage();
		}
	}

	/*
	 * Sanity-check args, error out on nonsensical combinations.
	 */
	/* -t implies -i if no mode was specified. */
	if (cpio->option_list && cpio->mode == '\0')
		cpio->mode = 'i';
	/* -t requires -i */
	if (cpio->option_list && cpio->mode != 'i')
		lafe_errc(1, 0, ""Option -t requires -i"");
	/* -n requires -it */
	if (cpio->option_numeric_uid_gid && !cpio->option_list)
		lafe_errc(1, 0, ""Option -n requires -it"");
	/* Can only specify format when writing */
	if (cpio->format != NULL && cpio->mode != 'o')
		lafe_errc(1, 0, ""Option --format requires -o"");
	/* -l requires -p */
	if (cpio->option_link && cpio->mode != 'p')
		lafe_errc(1, 0, ""Option -l requires -p"");
	/* -v overrides -V */
	if (cpio->dot && cpio->verbose)
		cpio->dot = 0;
	/* TODO: Flag other nonsensical combinations. */

	switch (cpio->mode) {
	case 'o':
		/* TODO: Implement old binary format in libarchive,
		   use that here. */
		if (cpio->format == NULL)
			cpio->format = ""odc""; /* Default format */

		mode_out(cpio);
		break;
	case 'i':
		while (*cpio->argv != NULL) {
			if (archive_match_include_pattern(cpio->matching,
			    *cpio->argv) != ARCHIVE_OK)
				lafe_errc(1, 0, ""Error : %s"",
				    archive_error_string(cpio->matching));
			--cpio->argc;
			++cpio->argv;
		}
		if (cpio->option_list)
			mode_list(cpio);
		else
			mode_in(cpio);
		break;
	case 'p':
		if (*cpio->argv == NULL || **cpio->argv == '\0')
			lafe_errc(1, 0,
			    ""-p mode requires a target directory"");
		mode_pass(cpio, *cpio->argv);
		break;
	default:
		lafe_errc(1, 0,
		    ""Must specify at least one of -i, -o, or -p"");
	}

	archive_match_free(cpio->matching);
	free_cache(cpio->gname_cache);
	free_cache(cpio->uname_cache);
	free(cpio->destdir);
	passphrase_free(cpio->ppbuff);
	return (cpio->return_value);
}
"
2117,179853,,Remote,Not required,Partial,CVE-2015-2304,https://www.cvedetails.com/cve/CVE-2015-2304/,CWE-22,Low,,Partial,,2015-03-15,6.4,Absolute path traversal vulnerability in bsdcpio in libarchive 3.1.2 and earlier allows remote attackers to write to arbitrary files via a full pathname in an archive.,2018-10-30,Dir. Trav. ,8,https://github.com/libarchive/libarchive/commit/59357157706d47c365b2227739e17daba3607526,59357157706d47c365b2227739e17daba3607526,"Add ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS option

This fixes a directory traversal in the cpio tool.",1,libarchive/archive_write_disk_posix.c,"{""sha"": ""e52546e6f761a14ee1bb003235b97799422bf427"", ""filename"": ""cpio/bsdcpio.1"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/libarchive/libarchive/blob/59357157706d47c365b2227739e17daba3607526/cpio/bsdcpio.1"", ""raw_url"": ""https://github.com/libarchive/libarchive/raw/59357157706d47c365b2227739e17daba3607526/cpio/bsdcpio.1"", ""contents_url"": ""https://api.github.com/repos/libarchive/libarchive/contents/cpio/bsdcpio.1?ref=59357157706d47c365b2227739e17daba3607526"", ""patch"": ""@@ -156,7 +156,8 @@ See above for description.\n .It Fl Fl insecure\n (i and p mode only)\n Disable security checks during extraction or copying.\n-This allows extraction via symbolic links and path names containing\n+This allows extraction via symbolic links, absolute paths,\n+and path names containing\n .Sq ..\n in the name.\n .It Fl J , Fl Fl xz""}<_**next**_>{""sha"": ""b267e9b8a74486a3a92992555aa1f3fd96175649"", ""filename"": ""cpio/cpio.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/libarchive/libarchive/blob/59357157706d47c365b2227739e17daba3607526/cpio/cpio.c"", ""raw_url"": ""https://github.com/libarchive/libarchive/raw/59357157706d47c365b2227739e17daba3607526/cpio/cpio.c"", ""contents_url"": ""https://api.github.com/repos/libarchive/libarchive/contents/cpio/cpio.c?ref=59357157706d47c365b2227739e17daba3607526"", ""patch"": ""@@ -171,6 +171,7 @@ main(int argc, char *argv[])\n \tcpio->extract_flags |= ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER;\n \tcpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_SYMLINKS;\n \tcpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n+\tcpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS;\n \tcpio->extract_flags |= ARCHIVE_EXTRACT_PERM;\n \tcpio->extract_flags |= ARCHIVE_EXTRACT_FFLAGS;\n \tcpio->extract_flags |= ARCHIVE_EXTRACT_ACL;\n@@ -256,6 +257,7 @@ main(int argc, char *argv[])\n \t\tcase OPTION_INSECURE:\n \t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_SYMLINKS;\n \t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n+\t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS;\n \t\t\tbreak;\n \t\tcase 'L': /* GNU cpio */\n \t\t\tcpio->option_follow_links = 1;""}<_**next**_>{""sha"": ""ef635ac9dc6bb1e035265550bfb5fccff4769883"", ""filename"": ""libarchive/archive.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/libarchive/libarchive/blob/59357157706d47c365b2227739e17daba3607526/libarchive/archive.h"", ""raw_url"": ""https://github.com/libarchive/libarchive/raw/59357157706d47c365b2227739e17daba3607526/libarchive/archive.h"", ""contents_url"": ""https://api.github.com/repos/libarchive/libarchive/contents/libarchive/archive.h?ref=59357157706d47c365b2227739e17daba3607526"", ""patch"": ""@@ -649,6 +649,8 @@ __LA_DECL int archive_read_set_passphrase_callback(struct archive *,\n /* Default: Do not use HFS+ compression if it was not compressed. */\n /* This has no effect except on Mac OS v10.6 or later. */\n #define\tARCHIVE_EXTRACT_HFS_COMPRESSION_FORCED\t(0x8000)\n+/* Default: Do not reject entries with absolute paths */\n+#define ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS (0x10000)\n \n __LA_DECL int archive_read_extract(struct archive *, struct archive_entry *,\n \t\t     int flags);""}<_**next**_>{""sha"": ""a2e7afaa06d8909ab28ebda6f4058b61c707e43c"", ""filename"": ""libarchive/archive_write_disk.3"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/libarchive/libarchive/blob/59357157706d47c365b2227739e17daba3607526/libarchive/archive_write_disk.3"", ""raw_url"": ""https://github.com/libarchive/libarchive/raw/59357157706d47c365b2227739e17daba3607526/libarchive/archive_write_disk.3"", ""contents_url"": ""https://api.github.com/repos/libarchive/libarchive/contents/libarchive/archive_write_disk.3?ref=59357157706d47c365b2227739e17daba3607526"", ""patch"": ""@@ -177,6 +177,9 @@ The default is to not refuse such paths.\n Note that paths ending in\n .Pa ..\n always cause an error, regardless of this flag.\n+.It Cm ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS\n+Refuse to extract an absolute path.\n+The default is to not refuse such paths.\n .It Cm ARCHIVE_EXTRACT_SPARSE\n Scan data for blocks of NUL bytes and try to recreate them with holes.\n This results in sparse files, independent of whether the archive format""}<_**next**_>{""sha"": ""c1290eb3aec56a434a204269eb87dfcb0c2af16a"", ""filename"": ""libarchive/archive_write_disk_posix.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 3, ""changes"": 14, ""blob_url"": ""https://github.com/libarchive/libarchive/blob/59357157706d47c365b2227739e17daba3607526/libarchive/archive_write_disk_posix.c"", ""raw_url"": ""https://github.com/libarchive/libarchive/raw/59357157706d47c365b2227739e17daba3607526/libarchive/archive_write_disk_posix.c"", ""contents_url"": ""https://api.github.com/repos/libarchive/libarchive/contents/libarchive/archive_write_disk_posix.c?ref=59357157706d47c365b2227739e17daba3607526"", ""patch"": ""@@ -2509,8 +2509,9 @@ cleanup_pathname_win(struct archive_write_disk *a)\n /*\n  * Canonicalize the pathname.  In particular, this strips duplicate\n  * '/' characters, '.' elements, and trailing '/'.  It also raises an\n- * error for an empty path, a trailing '..' or (if _SECURE_NODOTDOT is\n- * set) any '..' in the path.\n+ * error for an empty path, a trailing '..', (if _SECURE_NODOTDOT is\n+ * set) any '..' in the path or (if ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS\n+ * is set) if the path is absolute.\n  */\n static int\n cleanup_pathname(struct archive_write_disk *a)\n@@ -2529,8 +2530,15 @@ cleanup_pathname(struct archive_write_disk *a)\n \tcleanup_pathname_win(a);\n #endif\n \t/* Skip leading '/'. */\n-\tif (*src == '/')\n+\tif (*src == '/') {\n+\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {\n+\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n+\t\t\t                  \""Path is absolute\"");\n+\t\t\treturn (ARCHIVE_FAILED);\n+\t\t}\n+\n \t\tseparator = *src++;\n+\t}\n \n \t/* Scan the pathname one element at a time. */\n \tfor (;;) {""}<_**next**_>{""sha"": ""2c942068f3d4d4ca50b726b9d0fbfb0bcd838d7a"", ""filename"": ""libarchive/test/test_write_disk_secure.c"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 0, ""changes"": 23, ""blob_url"": ""https://github.com/libarchive/libarchive/blob/59357157706d47c365b2227739e17daba3607526/libarchive/test/test_write_disk_secure.c"", ""raw_url"": ""https://github.com/libarchive/libarchive/raw/59357157706d47c365b2227739e17daba3607526/libarchive/test/test_write_disk_secure.c"", ""contents_url"": ""https://api.github.com/repos/libarchive/libarchive/contents/libarchive/test/test_write_disk_secure.c?ref=59357157706d47c365b2227739e17daba3607526"", ""patch"": ""@@ -178,6 +178,29 @@ DEFINE_TEST(test_write_disk_secure)\n \tassert(S_ISDIR(st.st_mode));\n \tarchive_entry_free(ae);\n \n+\t/*\n+\t * Without security checks, we should be able to\n+\t * extract an absolute path.\n+\t */\n+\tassert((ae = archive_entry_new()) != NULL);\n+\tarchive_entry_copy_pathname(ae, \""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp\"");\n+\tarchive_entry_set_mode(ae, S_IFREG | 0777);\n+\tassert(0 == archive_write_header(a, ae));\n+\tassert(0 == archive_write_finish_entry(a));\n+\tassertFileExists(\""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp\"");\n+\tassert(0 == unlink(\""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp\""));\n+\n+\t/* But with security checks enabled, this should fail. */\n+\tassert(archive_entry_clear(ae) != NULL);\n+\tarchive_entry_copy_pathname(ae, \""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp\"");\n+\tarchive_entry_set_mode(ae, S_IFREG | 0777);\n+\tarchive_write_disk_set_options(a, ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS);\n+\tfailure(\""Extracting an absolute path should fail here.\"");\n+\tassertEqualInt(ARCHIVE_FAILED, archive_write_header(a, ae));\n+\tarchive_entry_free(ae);\n+\tassert(0 == archive_write_finish_entry(a));\n+\tassertFileNotExists(\""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp\"");\n+\n \tassertEqualInt(ARCHIVE_OK, archive_write_free(a));\n \n \t/* Test the entries on disk. */""}"," cleanup_pathname(struct archive_write_disk *a)
{
	char *dest, *src;
	char separator = '\0';

	dest = src = a->name;
	if (*src == '\0') {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");
		return (ARCHIVE_FAILED);
	}

#if defined(__CYGWIN__)
 	cleanup_pathname_win(a);
 #endif
 	/* Skip leading '/'. */
	if (*src == '/') {
		if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"");
			return (ARCHIVE_FAILED);
		}

 		separator = *src++;
	}
 
 	/* Scan the pathname one element at a time. */
 	for (;;) {
		/* src points to first char after '/' */
		if (src[0] == '\0') {
			break;
		} else if (src[0] == '/') {
			/* Found '//', ignore second one. */
			src++;
			continue;
		} else if (src[0] == '.') {
			if (src[1] == '\0') {
				/* Ignore trailing '.' */
				break;
			} else if (src[1] == '/') {
				/* Skip './'. */
				src += 2;
				continue;
			} else if (src[1] == '.') {
				if (src[2] == '/' || src[2] == '\0') {
					/* Conditionally warn about '..' */
					if (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
						archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"");
						return (ARCHIVE_FAILED);
					}
				}
				/*
				 * Note: Under no circumstances do we
				 * remove '..' elements.  In
				 * particular, restoring
				 * '/foo/../bar/' should create the
				 * 'foo' dir as a side-effect.
				 */
			}
		}

		/* Copy current element, including leading '/'. */
		if (separator)
			*dest++ = '/';
		while (*src != '\0' && *src != '/') {
			*dest++ = *src++;
		}

		if (*src == '\0')
			break;

		/* Skip '/' separator. */
		separator = *src++;
	}
	/*
	 * We've just copied zero or more path elements, not including the
	 * final '/'.
	 */
	if (dest == a->name) {
		/*
		 * Nothing got copied.  The path must have been something
		 * like '.' or '/' or './' or '/././././/./'.
		 */
		if (separator)
			*dest++ = '/';
		else
			*dest++ = '.';
	}
	/* Terminate the result. */
	*dest = '\0';
	return (ARCHIVE_OK);
}
"," cleanup_pathname(struct archive_write_disk *a)
{
	char *dest, *src;
	char separator = '\0';

	dest = src = a->name;
	if (*src == '\0') {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");
		return (ARCHIVE_FAILED);
	}

#if defined(__CYGWIN__)
 	cleanup_pathname_win(a);
 #endif
 	/* Skip leading '/'. */
	if (*src == '/')
 		separator = *src++;
 
 	/* Scan the pathname one element at a time. */
 	for (;;) {
		/* src points to first char after '/' */
		if (src[0] == '\0') {
			break;
		} else if (src[0] == '/') {
			/* Found '//', ignore second one. */
			src++;
			continue;
		} else if (src[0] == '.') {
			if (src[1] == '\0') {
				/* Ignore trailing '.' */
				break;
			} else if (src[1] == '/') {
				/* Skip './'. */
				src += 2;
				continue;
			} else if (src[1] == '.') {
				if (src[2] == '/' || src[2] == '\0') {
					/* Conditionally warn about '..' */
					if (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
						archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"");
						return (ARCHIVE_FAILED);
					}
				}
				/*
				 * Note: Under no circumstances do we
				 * remove '..' elements.  In
				 * particular, restoring
				 * '/foo/../bar/' should create the
				 * 'foo' dir as a side-effect.
				 */
			}
		}

		/* Copy current element, including leading '/'. */
		if (separator)
			*dest++ = '/';
		while (*src != '\0' && *src != '/') {
			*dest++ = *src++;
		}

		if (*src == '\0')
			break;

		/* Skip '/' separator. */
		separator = *src++;
	}
	/*
	 * We've just copied zero or more path elements, not including the
	 * final '/'.
	 */
	if (dest == a->name) {
		/*
		 * Nothing got copied.  The path must have been something
		 * like '.' or '/' or './' or '/././././/./'.
		 */
		if (separator)
			*dest++ = '/';
		else
			*dest++ = '.';
	}
	/* Terminate the result. */
	*dest = '\0';
	return (ARCHIVE_OK);
}
",C,"	if (*src == '/') {
		if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"");
			return (ARCHIVE_FAILED);
		}

	}
","	if (*src == '/')
",,"@@ -2509,8 +2509,9 @@ cleanup_pathname_win(struct archive_write_disk *a)
 /*
  * Canonicalize the pathname.  In particular, this strips duplicate
  * '/' characters, '.' elements, and trailing '/'.  It also raises an
- * error for an empty path, a trailing '..' or (if _SECURE_NODOTDOT is
- * set) any '..' in the path.
+ * error for an empty path, a trailing '..', (if _SECURE_NODOTDOT is
+ * set) any '..' in the path or (if ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS
+ * is set) if the path is absolute.
  */
 static int
 cleanup_pathname(struct archive_write_disk *a)
@@ -2529,8 +2530,15 @@ cleanup_pathname(struct archive_write_disk *a)
 	cleanup_pathname_win(a);
 #endif
 	/* Skip leading '/'. */
-	if (*src == '/')
+	if (*src == '/') {
+		if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+			                  ""Path is absolute"");
+			return (ARCHIVE_FAILED);
+		}
+
 		separator = *src++;
+	}
 
 	/* Scan the pathname one element at a time. */
 	for (;;) {",libarchive,59357157706d47c365b2227739e17daba3607526,fc04ba0941fed6b55fa5b90858e1104c8c937d72,1," cleanup_pathname(struct archive_write_disk *a)
{
	char *dest, *src;
	char separator = '\0';

	dest = src = a->name;
	if (*src == '\0') {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");
		return (ARCHIVE_FAILED);
	}

#if defined(__CYGWIN__)
 	cleanup_pathname_win(a);
 #endif
 	/* Skip leading '/'. */
//flaw_line_below:
	if (*src == '/')
//fix_flaw_line_below:
//	if (*src == '/') {
//fix_flaw_line_below:
//		if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
//fix_flaw_line_below:
//			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
//fix_flaw_line_below:
//			                  ""Path is absolute"");
//fix_flaw_line_below:
//			return (ARCHIVE_FAILED);
//fix_flaw_line_below:
//		}
//fix_flaw_line_below:
//
 		separator = *src++;
//fix_flaw_line_below:
//	}
 
 	/* Scan the pathname one element at a time. */
 	for (;;) {
		/* src points to first char after '/' */
		if (src[0] == '\0') {
			break;
		} else if (src[0] == '/') {
			/* Found '//', ignore second one. */
			src++;
			continue;
		} else if (src[0] == '.') {
			if (src[1] == '\0') {
				/* Ignore trailing '.' */
				break;
			} else if (src[1] == '/') {
				/* Skip './'. */
				src += 2;
				continue;
			} else if (src[1] == '.') {
				if (src[2] == '/' || src[2] == '\0') {
					/* Conditionally warn about '..' */
					if (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
						archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"");
						return (ARCHIVE_FAILED);
					}
				}
				/*
				 * Note: Under no circumstances do we
				 * remove '..' elements.  In
				 * particular, restoring
				 * '/foo/../bar/' should create the
				 * 'foo' dir as a side-effect.
				 */
			}
		}

		/* Copy current element, including leading '/'. */
		if (separator)
			*dest++ = '/';
		while (*src != '\0' && *src != '/') {
			*dest++ = *src++;
		}

		if (*src == '\0')
			break;

		/* Skip '/' separator. */
		separator = *src++;
	}
	/*
	 * We've just copied zero or more path elements, not including the
	 * final '/'.
	 */
	if (dest == a->name) {
		/*
		 * Nothing got copied.  The path must have been something
		 * like '.' or '/' or './' or '/././././/./'.
		 */
		if (separator)
			*dest++ = '/';
		else
			*dest++ = '.';
	}
	/* Terminate the result. */
	*dest = '\0';
	return (ARCHIVE_OK);
}
"
2163,179899,,Remote,Not required,,CVE-2015-1191,https://www.cvedetails.com/cve/CVE-2015-1191/,CWE-22,Low,,Partial,,2015-01-21,5.0,Multiple directory traversal vulnerabilities in pigz 2.3.1 allow remote attackers to write to arbitrary files via a (1) full pathname or (2) .. (dot dot) in an archive.,2016-12-02,Dir. Trav. ,23,https://github.com/madler/pigz/commit/fdad1406b3ec809f4954ff7cdf9e99eb18c2458f,fdad1406b3ec809f4954ff7cdf9e99eb18c2458f,"When decompressing with -N or -NT, strip any path from header name.

This uses the path of the compressed file combined with the name
from the header as the name of the decompressed output file.  Any
path information in the header name is stripped.  This avoids a
possible vulnerability where absolute or descending paths are put
in the gzip header.",12,pigz.c,"{""sha"": ""38c0d4fec22f33537cc3b26a5e13946a3514c4f1"", ""filename"": ""pigz.c"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 14, ""changes"": 37, ""blob_url"": ""https://github.com/madler/pigz/blob/fdad1406b3ec809f4954ff7cdf9e99eb18c2458f/pigz.c"", ""raw_url"": ""https://github.com/madler/pigz/raw/fdad1406b3ec809f4954ff7cdf9e99eb18c2458f/pigz.c"", ""contents_url"": ""https://api.github.com/repos/madler/pigz/contents/pigz.c?ref=fdad1406b3ec809f4954ff7cdf9e99eb18c2458f"", ""patch"": ""@@ -3520,26 +3520,35 @@ local void process(char *path)\n                  \"" (use -f to force)\"");\n     }\n     else {\n-        char *to, *repl;\n-\n-        /* use header name for output when decompressing with -N */\n-        to = g.inf;\n-        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {\n-            to = g.hname;\n-            len = strlen(g.hname);\n+        char *to = g.inf, *sufx = \""\"";\n+        size_t pre = 0;\n+\n+        /* select parts of the output file name */\n+        if (g.decode) {\n+            /* for -dN or -dNT, use the path from the input file and the name\n+               from the header, stripping any path in the header name */\n+            if ((g.headis & 1) != 0 && g.hname != NULL) {\n+                pre = justname(g.inf) - g.inf;\n+                to = justname(g.hname);\n+                len = strlen(to);\n+            }\n+            /* for -d or -dNn, replace abbreviated suffixes */\n+            else if (strcmp(to + len, \"".tgz\"") == 0)\n+                sufx = \"".tar\"";\n         }\n-\n-        /* replace .tgz with .tar when decoding */\n-        repl = g.decode && strcmp(to + len, \"".tgz\"") ? \""\"" : \"".tar\"";\n+        else\n+            /* add appropriate suffix when compressing */\n+            sufx = g.sufx;\n \n         /* create output file and open to write */\n-        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);\n+        g.outf = MALLOC(pre + len + strlen(sufx) + 1);\n         if (g.outf == NULL)\n             bail(\""not enough memory\"", \""\"");\n-        memcpy(g.outf, to, len);\n-        strcpy(g.outf + len, g.decode ? repl : g.sufx);\n+        memcpy(g.outf, g.inf, pre);\n+        memcpy(g.outf + pre, to, len);\n+        strcpy(g.outf + pre + len, sufx);\n         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |\n-                             (g.force ? 0 : O_EXCL), 0600);\n+                              (g.force ? 0 : O_EXCL), 0600);\n \n         /* if exists and not -f, give user a chance to overwrite */\n         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {""}","local void process(char *path)
{
    int method = -1;                /* get_header() return value */
    size_t len;                     /* length of base name (minus suffix) */
    struct stat st;                 /* to get file type and mod time */
    /* all compressed suffixes for decoding search, in length order */
    static char *sufs[] = {"".z"", ""-z"", ""_z"", "".Z"", "".gz"", ""-gz"", "".zz"", ""-zz"",
                           "".zip"", "".ZIP"", "".tgz"", NULL};

    /* open input file with name in, descriptor ind -- set name and mtime */
    if (path == NULL) {
        strcpy(g.inf, ""<stdin>"");
        g.ind = 0;
        g.name = NULL;
        g.mtime = g.headis & 2 ?
                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;
        len = 0;
    }
    else {
        /* set input file name (already set if recursed here) */
        if (path != g.inf) {
            strncpy(g.inf, path, sizeof(g.inf));
            if (g.inf[sizeof(g.inf) - 1])
                bail(""name too long: "", path);
        }
        len = strlen(g.inf);

        /* try to stat input file -- if not there and decoding, look for that
           name with compressed suffixes */
        if (lstat(g.inf, &st)) {
            if (errno == ENOENT && (g.list || g.decode)) {
                char **try = sufs;
                do {
                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))
                        break;
                    strcpy(g.inf + len, *try++);
                    errno = 0;
                } while (lstat(g.inf, &st) && errno == ENOENT);
            }
#ifdef EOVERFLOW
            if (errno == EOVERFLOW || errno == EFBIG)
                bail(g.inf,
                    "" too large -- not compiled with large file support"");
#endif
            if (errno) {
                g.inf[len] = 0;
                complain(""%s does not exist -- skipping"", g.inf);
                return;
            }
            len = strlen(g.inf);
        }

        /* only process regular files, but allow symbolic links if -f,
           recurse into directory if -r */
        if ((st.st_mode & S_IFMT) != S_IFREG &&
            (st.st_mode & S_IFMT) != S_IFLNK &&
            (st.st_mode & S_IFMT) != S_IFDIR) {
            complain(""%s is a special file or device -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {
            complain(""%s is a symbolic link -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {
            complain(""%s is a directory -- skipping"", g.inf);
            return;
        }

        /* recurse into directory (assumes Unix) */
        if ((st.st_mode & S_IFMT) == S_IFDIR) {
            char *roll, *item, *cut, *base, *bigger;
            size_t len, hold;
            DIR *here;
            struct dirent *next;

            /* accumulate list of entries (need to do this, since readdir()
               behavior not defined if directory modified between calls) */
            here = opendir(g.inf);
            if (here == NULL)
                return;
            hold = 512;
            roll = MALLOC(hold);
            if (roll == NULL)
                bail(""not enough memory"", """");
            *roll = 0;
            item = roll;
            while ((next = readdir(here)) != NULL) {
                if (next->d_name[0] == 0 ||
                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||
                     (next->d_name[1] == '.' && next->d_name[2] == 0))))
                    continue;
                len = strlen(next->d_name) + 1;
                if (item + len + 1 > roll + hold) {
                    do {                    /* make roll bigger */
                        hold <<= 1;
                    } while (item + len + 1 > roll + hold);
                    bigger = REALLOC(roll, hold);
                    if (bigger == NULL) {
                        FREE(roll);
                        bail(""not enough memory"", """");
                    }
                    item = bigger + (item - roll);
                    roll = bigger;
                }
                strcpy(item, next->d_name);
                item += len;
                *item = 0;
            }
            closedir(here);

            /* run process() for each entry in the directory */
            cut = base = g.inf + strlen(g.inf);
            if (base > g.inf && base[-1] != (unsigned char)'/') {
                if ((size_t)(base - g.inf) >= sizeof(g.inf))
                    bail(""path too long"", g.inf);
                *base++ = '/';
            }
            item = roll;
            while (*item) {
                strncpy(base, item, sizeof(g.inf) - (base - g.inf));
                if (g.inf[sizeof(g.inf) - 1]) {
                    strcpy(g.inf + (sizeof(g.inf) - 4), ""..."");
                    bail(""path too long: "", g.inf);
                }
                process(g.inf);
                item += strlen(item) + 1;
            }
            *cut = 0;

            /* release list of entries */
            FREE(roll);
            return;
        }

        /* don't compress .gz (or provided suffix) files, unless -f */
        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&
                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {
            complain(""%s ends with %s -- skipping"", g.inf, g.sufx);
            return;
        }

        /* create output file only if input file has compressed suffix */
        if (g.decode == 1 && !g.pipeout && !g.list) {
            int suf = compressed_suffix(g.inf);
            if (suf == 0) {
                complain(""%s does not have compressed suffix -- skipping"",
                         g.inf);
                return;
            }
            len -= suf;
        }

        /* open input file */
        g.ind = open(g.inf, O_RDONLY, 0);
        if (g.ind < 0)
            bail(""read error on "", g.inf);

        /* prepare gzip header information for compression */
        g.name = g.headis & 1 ? justname(g.inf) : NULL;
        g.mtime = g.headis & 2 ? st.st_mtime : 0;
    }
    SET_BINARY_MODE(g.ind);

    /* if decoding or testing, try to read gzip header */
    g.hname = NULL;
    if (g.decode) {
        in_init();
        method = get_header(1);
        if (method != 8 && method != 257 &&
                /* gzip -cdf acts like cat on uncompressed input */
                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&
                  !g.list)) {
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            if (method != -1)
                complain(method < 0 ? ""%s is not compressed -- skipping"" :
                         ""%s has unknown compression method -- skipping"",
                         g.inf);
            return;
        }

        /* if requested, test input file (possibly a special list) */
        if (g.decode == 2) {
            if (method == 8)
                infchk();
            else {
                unlzw();
                if (g.list) {
                    g.in_tot -= 3;
                    show_info(method, 0, g.out_tot, 0);
                }
            }
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }
    }

    /* if requested, just list information about input file */
    if (g.list) {
        list_info();
        RELEASE(g.hname);
        if (g.ind != 0)
            close(g.ind);
        return;
    }

    /* create output file out, descriptor outd */
    if (path == NULL || g.pipeout) {
        /* write to stdout */
        g.outf = MALLOC(strlen(""<stdout>"") + 1);
        if (g.outf == NULL)
            bail(""not enough memory"", """");
        strcpy(g.outf, ""<stdout>"");
        g.outd = 1;
        if (!g.decode && !g.force && isatty(g.outd))
            bail(""trying to write compressed data to a terminal"",
                  "" (use -f to force)"");
     }
     else {
        char *to = g.inf, *sufx = """";
        size_t pre = 0;

        /* select parts of the output file name */
        if (g.decode) {
            /* for -dN or -dNT, use the path from the input file and the name
               from the header, stripping any path in the header name */
            if ((g.headis & 1) != 0 && g.hname != NULL) {
                pre = justname(g.inf) - g.inf;
                to = justname(g.hname);
                len = strlen(to);
            }
            /* for -d or -dNn, replace abbreviated suffixes */
            else if (strcmp(to + len, "".tgz"") == 0)
                sufx = "".tar"";
         }
        else
            /* add appropriate suffix when compressing */
            sufx = g.sufx;
 
         /* create output file and open to write */
        g.outf = MALLOC(pre + len + strlen(sufx) + 1);
         if (g.outf == NULL)
             bail(""not enough memory"", """");
        memcpy(g.outf, g.inf, pre);
        memcpy(g.outf + pre, to, len);
        strcpy(g.outf + pre + len, sufx);
         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
                              (g.force ? 0 : O_EXCL), 0600);
 
         /* if exists and not -f, give user a chance to overwrite */
         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {
            int ch, reply;

            fprintf(stderr, ""%s exists -- overwrite (y/n)? "", g.outf);
            fflush(stderr);
            reply = -1;
            do {
                ch = getchar();
                if (reply < 0 && ch != ' ' && ch != '\t')
                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;
            } while (ch != EOF && ch != '\n' && ch != '\r');
            if (reply == 1)
                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,
                              0600);
        }

        /* if exists and no overwrite, report and go on to next */
        if (g.outd < 0 && errno == EEXIST) {
            complain(""%s exists -- skipping"", g.outf);
            RELEASE(g.outf);
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }

        /* if some other error, give up */
        if (g.outd < 0)
            bail(""write error on "", g.outf);
    }
    SET_BINARY_MODE(g.outd);
    RELEASE(g.hname);

    /* process ind to outd */
    if (g.verbosity > 1)
        fprintf(stderr, ""%s to %s "", g.inf, g.outf);
    if (g.decode) {
        if (method == 8)
            infchk();
        else if (method == 257)
            unlzw();
        else
            cat();
    }
#ifndef NOTHREAD
    else if (g.procs > 1)
        parallel_compress();
#endif
    else
        single_compress(0);
    if (g.verbosity > 1) {
        putc('\n', stderr);
        fflush(stderr);
    }

    /* finish up, copy attributes, set times, delete original */
    if (g.ind != 0)
        close(g.ind);
    if (g.outd != 1) {
        if (close(g.outd))
            bail(""write error on "", g.outf);
        g.outd = -1;            /* now prevent deletion on interrupt */
        if (g.ind != 0) {
            copymeta(g.inf, g.outf);
            if (!g.keep)
                unlink(g.inf);
        }
        if (g.decode && (g.headis & 2) != 0 && g.stamp)
            touch(g.outf, g.stamp);
    }
    RELEASE(g.outf);
}
","local void process(char *path)
{
    int method = -1;                /* get_header() return value */
    size_t len;                     /* length of base name (minus suffix) */
    struct stat st;                 /* to get file type and mod time */
    /* all compressed suffixes for decoding search, in length order */
    static char *sufs[] = {"".z"", ""-z"", ""_z"", "".Z"", "".gz"", ""-gz"", "".zz"", ""-zz"",
                           "".zip"", "".ZIP"", "".tgz"", NULL};

    /* open input file with name in, descriptor ind -- set name and mtime */
    if (path == NULL) {
        strcpy(g.inf, ""<stdin>"");
        g.ind = 0;
        g.name = NULL;
        g.mtime = g.headis & 2 ?
                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;
        len = 0;
    }
    else {
        /* set input file name (already set if recursed here) */
        if (path != g.inf) {
            strncpy(g.inf, path, sizeof(g.inf));
            if (g.inf[sizeof(g.inf) - 1])
                bail(""name too long: "", path);
        }
        len = strlen(g.inf);

        /* try to stat input file -- if not there and decoding, look for that
           name with compressed suffixes */
        if (lstat(g.inf, &st)) {
            if (errno == ENOENT && (g.list || g.decode)) {
                char **try = sufs;
                do {
                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))
                        break;
                    strcpy(g.inf + len, *try++);
                    errno = 0;
                } while (lstat(g.inf, &st) && errno == ENOENT);
            }
#ifdef EOVERFLOW
            if (errno == EOVERFLOW || errno == EFBIG)
                bail(g.inf,
                    "" too large -- not compiled with large file support"");
#endif
            if (errno) {
                g.inf[len] = 0;
                complain(""%s does not exist -- skipping"", g.inf);
                return;
            }
            len = strlen(g.inf);
        }

        /* only process regular files, but allow symbolic links if -f,
           recurse into directory if -r */
        if ((st.st_mode & S_IFMT) != S_IFREG &&
            (st.st_mode & S_IFMT) != S_IFLNK &&
            (st.st_mode & S_IFMT) != S_IFDIR) {
            complain(""%s is a special file or device -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {
            complain(""%s is a symbolic link -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {
            complain(""%s is a directory -- skipping"", g.inf);
            return;
        }

        /* recurse into directory (assumes Unix) */
        if ((st.st_mode & S_IFMT) == S_IFDIR) {
            char *roll, *item, *cut, *base, *bigger;
            size_t len, hold;
            DIR *here;
            struct dirent *next;

            /* accumulate list of entries (need to do this, since readdir()
               behavior not defined if directory modified between calls) */
            here = opendir(g.inf);
            if (here == NULL)
                return;
            hold = 512;
            roll = MALLOC(hold);
            if (roll == NULL)
                bail(""not enough memory"", """");
            *roll = 0;
            item = roll;
            while ((next = readdir(here)) != NULL) {
                if (next->d_name[0] == 0 ||
                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||
                     (next->d_name[1] == '.' && next->d_name[2] == 0))))
                    continue;
                len = strlen(next->d_name) + 1;
                if (item + len + 1 > roll + hold) {
                    do {                    /* make roll bigger */
                        hold <<= 1;
                    } while (item + len + 1 > roll + hold);
                    bigger = REALLOC(roll, hold);
                    if (bigger == NULL) {
                        FREE(roll);
                        bail(""not enough memory"", """");
                    }
                    item = bigger + (item - roll);
                    roll = bigger;
                }
                strcpy(item, next->d_name);
                item += len;
                *item = 0;
            }
            closedir(here);

            /* run process() for each entry in the directory */
            cut = base = g.inf + strlen(g.inf);
            if (base > g.inf && base[-1] != (unsigned char)'/') {
                if ((size_t)(base - g.inf) >= sizeof(g.inf))
                    bail(""path too long"", g.inf);
                *base++ = '/';
            }
            item = roll;
            while (*item) {
                strncpy(base, item, sizeof(g.inf) - (base - g.inf));
                if (g.inf[sizeof(g.inf) - 1]) {
                    strcpy(g.inf + (sizeof(g.inf) - 4), ""..."");
                    bail(""path too long: "", g.inf);
                }
                process(g.inf);
                item += strlen(item) + 1;
            }
            *cut = 0;

            /* release list of entries */
            FREE(roll);
            return;
        }

        /* don't compress .gz (or provided suffix) files, unless -f */
        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&
                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {
            complain(""%s ends with %s -- skipping"", g.inf, g.sufx);
            return;
        }

        /* create output file only if input file has compressed suffix */
        if (g.decode == 1 && !g.pipeout && !g.list) {
            int suf = compressed_suffix(g.inf);
            if (suf == 0) {
                complain(""%s does not have compressed suffix -- skipping"",
                         g.inf);
                return;
            }
            len -= suf;
        }

        /* open input file */
        g.ind = open(g.inf, O_RDONLY, 0);
        if (g.ind < 0)
            bail(""read error on "", g.inf);

        /* prepare gzip header information for compression */
        g.name = g.headis & 1 ? justname(g.inf) : NULL;
        g.mtime = g.headis & 2 ? st.st_mtime : 0;
    }
    SET_BINARY_MODE(g.ind);

    /* if decoding or testing, try to read gzip header */
    g.hname = NULL;
    if (g.decode) {
        in_init();
        method = get_header(1);
        if (method != 8 && method != 257 &&
                /* gzip -cdf acts like cat on uncompressed input */
                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&
                  !g.list)) {
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            if (method != -1)
                complain(method < 0 ? ""%s is not compressed -- skipping"" :
                         ""%s has unknown compression method -- skipping"",
                         g.inf);
            return;
        }

        /* if requested, test input file (possibly a special list) */
        if (g.decode == 2) {
            if (method == 8)
                infchk();
            else {
                unlzw();
                if (g.list) {
                    g.in_tot -= 3;
                    show_info(method, 0, g.out_tot, 0);
                }
            }
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }
    }

    /* if requested, just list information about input file */
    if (g.list) {
        list_info();
        RELEASE(g.hname);
        if (g.ind != 0)
            close(g.ind);
        return;
    }

    /* create output file out, descriptor outd */
    if (path == NULL || g.pipeout) {
        /* write to stdout */
        g.outf = MALLOC(strlen(""<stdout>"") + 1);
        if (g.outf == NULL)
            bail(""not enough memory"", """");
        strcpy(g.outf, ""<stdout>"");
        g.outd = 1;
        if (!g.decode && !g.force && isatty(g.outd))
            bail(""trying to write compressed data to a terminal"",
                  "" (use -f to force)"");
     }
     else {
        char *to, *repl;
        /* use header name for output when decompressing with -N */
        to = g.inf;
        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {
            to = g.hname;
            len = strlen(g.hname);
         }
        /* replace .tgz with .tar when decoding */
        repl = g.decode && strcmp(to + len, "".tgz"") ? """" : "".tar"";
 
         /* create output file and open to write */
        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);
         if (g.outf == NULL)
             bail(""not enough memory"", """");
        memcpy(g.outf, to, len);
        strcpy(g.outf + len, g.decode ? repl : g.sufx);
         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
                             (g.force ? 0 : O_EXCL), 0600);
 
         /* if exists and not -f, give user a chance to overwrite */
         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {
            int ch, reply;

            fprintf(stderr, ""%s exists -- overwrite (y/n)? "", g.outf);
            fflush(stderr);
            reply = -1;
            do {
                ch = getchar();
                if (reply < 0 && ch != ' ' && ch != '\t')
                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;
            } while (ch != EOF && ch != '\n' && ch != '\r');
            if (reply == 1)
                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,
                              0600);
        }

        /* if exists and no overwrite, report and go on to next */
        if (g.outd < 0 && errno == EEXIST) {
            complain(""%s exists -- skipping"", g.outf);
            RELEASE(g.outf);
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }

        /* if some other error, give up */
        if (g.outd < 0)
            bail(""write error on "", g.outf);
    }
    SET_BINARY_MODE(g.outd);
    RELEASE(g.hname);

    /* process ind to outd */
    if (g.verbosity > 1)
        fprintf(stderr, ""%s to %s "", g.inf, g.outf);
    if (g.decode) {
        if (method == 8)
            infchk();
        else if (method == 257)
            unlzw();
        else
            cat();
    }
#ifndef NOTHREAD
    else if (g.procs > 1)
        parallel_compress();
#endif
    else
        single_compress(0);
    if (g.verbosity > 1) {
        putc('\n', stderr);
        fflush(stderr);
    }

    /* finish up, copy attributes, set times, delete original */
    if (g.ind != 0)
        close(g.ind);
    if (g.outd != 1) {
        if (close(g.outd))
            bail(""write error on "", g.outf);
        g.outd = -1;            /* now prevent deletion on interrupt */
        if (g.ind != 0) {
            copymeta(g.inf, g.outf);
            if (!g.keep)
                unlink(g.inf);
        }
        if (g.decode && (g.headis & 2) != 0 && g.stamp)
            touch(g.outf, g.stamp);
    }
    RELEASE(g.outf);
}
",C,"        char *to = g.inf, *sufx = """";
        size_t pre = 0;

        /* select parts of the output file name */
        if (g.decode) {
            /* for -dN or -dNT, use the path from the input file and the name
               from the header, stripping any path in the header name */
            if ((g.headis & 1) != 0 && g.hname != NULL) {
                pre = justname(g.inf) - g.inf;
                to = justname(g.hname);
                len = strlen(to);
            }
            /* for -d or -dNn, replace abbreviated suffixes */
            else if (strcmp(to + len, "".tgz"") == 0)
                sufx = "".tar"";
        else
            /* add appropriate suffix when compressing */
            sufx = g.sufx;
        g.outf = MALLOC(pre + len + strlen(sufx) + 1);
        memcpy(g.outf, g.inf, pre);
        memcpy(g.outf + pre, to, len);
        strcpy(g.outf + pre + len, sufx);
                              (g.force ? 0 : O_EXCL), 0600);
","        char *to, *repl;
        /* use header name for output when decompressing with -N */
        to = g.inf;
        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {
            to = g.hname;
            len = strlen(g.hname);
        /* replace .tgz with .tar when decoding */
        repl = g.decode && strcmp(to + len, "".tgz"") ? """" : "".tar"";
        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);
        memcpy(g.outf, to, len);
        strcpy(g.outf + len, g.decode ? repl : g.sufx);
                             (g.force ? 0 : O_EXCL), 0600);
",,"@@ -3520,26 +3520,35 @@ local void process(char *path)
                  "" (use -f to force)"");
     }
     else {
-        char *to, *repl;
-
-        /* use header name for output when decompressing with -N */
-        to = g.inf;
-        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {
-            to = g.hname;
-            len = strlen(g.hname);
+        char *to = g.inf, *sufx = """";
+        size_t pre = 0;
+
+        /* select parts of the output file name */
+        if (g.decode) {
+            /* for -dN or -dNT, use the path from the input file and the name
+               from the header, stripping any path in the header name */
+            if ((g.headis & 1) != 0 && g.hname != NULL) {
+                pre = justname(g.inf) - g.inf;
+                to = justname(g.hname);
+                len = strlen(to);
+            }
+            /* for -d or -dNn, replace abbreviated suffixes */
+            else if (strcmp(to + len, "".tgz"") == 0)
+                sufx = "".tar"";
         }
-
-        /* replace .tgz with .tar when decoding */
-        repl = g.decode && strcmp(to + len, "".tgz"") ? """" : "".tar"";
+        else
+            /* add appropriate suffix when compressing */
+            sufx = g.sufx;
 
         /* create output file and open to write */
-        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);
+        g.outf = MALLOC(pre + len + strlen(sufx) + 1);
         if (g.outf == NULL)
             bail(""not enough memory"", """");
-        memcpy(g.outf, to, len);
-        strcpy(g.outf + len, g.decode ? repl : g.sufx);
+        memcpy(g.outf, g.inf, pre);
+        memcpy(g.outf + pre, to, len);
+        strcpy(g.outf + pre + len, sufx);
         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
-                             (g.force ? 0 : O_EXCL), 0600);
+                              (g.force ? 0 : O_EXCL), 0600);
 
         /* if exists and not -f, give user a chance to overwrite */
         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {",pigz,fdad1406b3ec809f4954ff7cdf9e99eb18c2458f,e5318b2cd88f1cb74c0bbce8a618c2b72ec263fb,1,"local void process(char *path)
{
    int method = -1;                /* get_header() return value */
    size_t len;                     /* length of base name (minus suffix) */
    struct stat st;                 /* to get file type and mod time */
    /* all compressed suffixes for decoding search, in length order */
    static char *sufs[] = {"".z"", ""-z"", ""_z"", "".Z"", "".gz"", ""-gz"", "".zz"", ""-zz"",
                           "".zip"", "".ZIP"", "".tgz"", NULL};

    /* open input file with name in, descriptor ind -- set name and mtime */
    if (path == NULL) {
        strcpy(g.inf, ""<stdin>"");
        g.ind = 0;
        g.name = NULL;
        g.mtime = g.headis & 2 ?
                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;
        len = 0;
    }
    else {
        /* set input file name (already set if recursed here) */
        if (path != g.inf) {
            strncpy(g.inf, path, sizeof(g.inf));
            if (g.inf[sizeof(g.inf) - 1])
                bail(""name too long: "", path);
        }
        len = strlen(g.inf);

        /* try to stat input file -- if not there and decoding, look for that
           name with compressed suffixes */
        if (lstat(g.inf, &st)) {
            if (errno == ENOENT && (g.list || g.decode)) {
                char **try = sufs;
                do {
                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))
                        break;
                    strcpy(g.inf + len, *try++);
                    errno = 0;
                } while (lstat(g.inf, &st) && errno == ENOENT);
            }
#ifdef EOVERFLOW
            if (errno == EOVERFLOW || errno == EFBIG)
                bail(g.inf,
                    "" too large -- not compiled with large file support"");
#endif
            if (errno) {
                g.inf[len] = 0;
                complain(""%s does not exist -- skipping"", g.inf);
                return;
            }
            len = strlen(g.inf);
        }

        /* only process regular files, but allow symbolic links if -f,
           recurse into directory if -r */
        if ((st.st_mode & S_IFMT) != S_IFREG &&
            (st.st_mode & S_IFMT) != S_IFLNK &&
            (st.st_mode & S_IFMT) != S_IFDIR) {
            complain(""%s is a special file or device -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {
            complain(""%s is a symbolic link -- skipping"", g.inf);
            return;
        }
        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {
            complain(""%s is a directory -- skipping"", g.inf);
            return;
        }

        /* recurse into directory (assumes Unix) */
        if ((st.st_mode & S_IFMT) == S_IFDIR) {
            char *roll, *item, *cut, *base, *bigger;
            size_t len, hold;
            DIR *here;
            struct dirent *next;

            /* accumulate list of entries (need to do this, since readdir()
               behavior not defined if directory modified between calls) */
            here = opendir(g.inf);
            if (here == NULL)
                return;
            hold = 512;
            roll = MALLOC(hold);
            if (roll == NULL)
                bail(""not enough memory"", """");
            *roll = 0;
            item = roll;
            while ((next = readdir(here)) != NULL) {
                if (next->d_name[0] == 0 ||
                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||
                     (next->d_name[1] == '.' && next->d_name[2] == 0))))
                    continue;
                len = strlen(next->d_name) + 1;
                if (item + len + 1 > roll + hold) {
                    do {                    /* make roll bigger */
                        hold <<= 1;
                    } while (item + len + 1 > roll + hold);
                    bigger = REALLOC(roll, hold);
                    if (bigger == NULL) {
                        FREE(roll);
                        bail(""not enough memory"", """");
                    }
                    item = bigger + (item - roll);
                    roll = bigger;
                }
                strcpy(item, next->d_name);
                item += len;
                *item = 0;
            }
            closedir(here);

            /* run process() for each entry in the directory */
            cut = base = g.inf + strlen(g.inf);
            if (base > g.inf && base[-1] != (unsigned char)'/') {
                if ((size_t)(base - g.inf) >= sizeof(g.inf))
                    bail(""path too long"", g.inf);
                *base++ = '/';
            }
            item = roll;
            while (*item) {
                strncpy(base, item, sizeof(g.inf) - (base - g.inf));
                if (g.inf[sizeof(g.inf) - 1]) {
                    strcpy(g.inf + (sizeof(g.inf) - 4), ""..."");
                    bail(""path too long: "", g.inf);
                }
                process(g.inf);
                item += strlen(item) + 1;
            }
            *cut = 0;

            /* release list of entries */
            FREE(roll);
            return;
        }

        /* don't compress .gz (or provided suffix) files, unless -f */
        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&
                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {
            complain(""%s ends with %s -- skipping"", g.inf, g.sufx);
            return;
        }

        /* create output file only if input file has compressed suffix */
        if (g.decode == 1 && !g.pipeout && !g.list) {
            int suf = compressed_suffix(g.inf);
            if (suf == 0) {
                complain(""%s does not have compressed suffix -- skipping"",
                         g.inf);
                return;
            }
            len -= suf;
        }

        /* open input file */
        g.ind = open(g.inf, O_RDONLY, 0);
        if (g.ind < 0)
            bail(""read error on "", g.inf);

        /* prepare gzip header information for compression */
        g.name = g.headis & 1 ? justname(g.inf) : NULL;
        g.mtime = g.headis & 2 ? st.st_mtime : 0;
    }
    SET_BINARY_MODE(g.ind);

    /* if decoding or testing, try to read gzip header */
    g.hname = NULL;
    if (g.decode) {
        in_init();
        method = get_header(1);
        if (method != 8 && method != 257 &&
                /* gzip -cdf acts like cat on uncompressed input */
                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&
                  !g.list)) {
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            if (method != -1)
                complain(method < 0 ? ""%s is not compressed -- skipping"" :
                         ""%s has unknown compression method -- skipping"",
                         g.inf);
            return;
        }

        /* if requested, test input file (possibly a special list) */
        if (g.decode == 2) {
            if (method == 8)
                infchk();
            else {
                unlzw();
                if (g.list) {
                    g.in_tot -= 3;
                    show_info(method, 0, g.out_tot, 0);
                }
            }
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }
    }

    /* if requested, just list information about input file */
    if (g.list) {
        list_info();
        RELEASE(g.hname);
        if (g.ind != 0)
            close(g.ind);
        return;
    }

    /* create output file out, descriptor outd */
    if (path == NULL || g.pipeout) {
        /* write to stdout */
        g.outf = MALLOC(strlen(""<stdout>"") + 1);
        if (g.outf == NULL)
            bail(""not enough memory"", """");
        strcpy(g.outf, ""<stdout>"");
        g.outd = 1;
        if (!g.decode && !g.force && isatty(g.outd))
            bail(""trying to write compressed data to a terminal"",
                  "" (use -f to force)"");
     }
     else {
//flaw_line_below:
        char *to, *repl;
//flaw_line_below:

//flaw_line_below:
        /* use header name for output when decompressing with -N */
//flaw_line_below:
        to = g.inf;
//flaw_line_below:
        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {
//flaw_line_below:
            to = g.hname;
//flaw_line_below:
            len = strlen(g.hname);
//fix_flaw_line_below:
//        char *to = g.inf, *sufx = """";
//fix_flaw_line_below:
//        size_t pre = 0;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        /* select parts of the output file name */
//fix_flaw_line_below:
//        if (g.decode) {
//fix_flaw_line_below:
//            /* for -dN or -dNT, use the path from the input file and the name
//fix_flaw_line_below:
//               from the header, stripping any path in the header name */
//fix_flaw_line_below:
//            if ((g.headis & 1) != 0 && g.hname != NULL) {
//fix_flaw_line_below:
//                pre = justname(g.inf) - g.inf;
//fix_flaw_line_below:
//                to = justname(g.hname);
//fix_flaw_line_below:
//                len = strlen(to);
//fix_flaw_line_below:
//            }
//fix_flaw_line_below:
//            /* for -d or -dNn, replace abbreviated suffixes */
//fix_flaw_line_below:
//            else if (strcmp(to + len, "".tgz"") == 0)
//fix_flaw_line_below:
//                sufx = "".tar"";
         }
//flaw_line_below:

//flaw_line_below:
        /* replace .tgz with .tar when decoding */
//flaw_line_below:
        repl = g.decode && strcmp(to + len, "".tgz"") ? """" : "".tar"";
//fix_flaw_line_below:
//        else
//fix_flaw_line_below:
//            /* add appropriate suffix when compressing */
//fix_flaw_line_below:
//            sufx = g.sufx;
 
         /* create output file and open to write */
//flaw_line_below:
        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);
//fix_flaw_line_below:
//        g.outf = MALLOC(pre + len + strlen(sufx) + 1);
         if (g.outf == NULL)
             bail(""not enough memory"", """");
//flaw_line_below:
        memcpy(g.outf, to, len);
//flaw_line_below:
        strcpy(g.outf + len, g.decode ? repl : g.sufx);
//fix_flaw_line_below:
//        memcpy(g.outf, g.inf, pre);
//fix_flaw_line_below:
//        memcpy(g.outf + pre, to, len);
//fix_flaw_line_below:
//        strcpy(g.outf + pre + len, sufx);
         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
//flaw_line_below:
                             (g.force ? 0 : O_EXCL), 0600);
//fix_flaw_line_below:
//                              (g.force ? 0 : O_EXCL), 0600);
 
         /* if exists and not -f, give user a chance to overwrite */
         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {
            int ch, reply;

            fprintf(stderr, ""%s exists -- overwrite (y/n)? "", g.outf);
            fflush(stderr);
            reply = -1;
            do {
                ch = getchar();
                if (reply < 0 && ch != ' ' && ch != '\t')
                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;
            } while (ch != EOF && ch != '\n' && ch != '\r');
            if (reply == 1)
                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,
                              0600);
        }

        /* if exists and no overwrite, report and go on to next */
        if (g.outd < 0 && errno == EEXIST) {
            complain(""%s exists -- skipping"", g.outf);
            RELEASE(g.outf);
            RELEASE(g.hname);
            if (g.ind != 0)
                close(g.ind);
            return;
        }

        /* if some other error, give up */
        if (g.outd < 0)
            bail(""write error on "", g.outf);
    }
    SET_BINARY_MODE(g.outd);
    RELEASE(g.hname);

    /* process ind to outd */
    if (g.verbosity > 1)
        fprintf(stderr, ""%s to %s "", g.inf, g.outf);
    if (g.decode) {
        if (method == 8)
            infchk();
        else if (method == 257)
            unlzw();
        else
            cat();
    }
#ifndef NOTHREAD
    else if (g.procs > 1)
        parallel_compress();
#endif
    else
        single_compress(0);
    if (g.verbosity > 1) {
        putc('\n', stderr);
        fflush(stderr);
    }

    /* finish up, copy attributes, set times, delete original */
    if (g.ind != 0)
        close(g.ind);
    if (g.outd != 1) {
        if (close(g.outd))
            bail(""write error on "", g.outf);
        g.outd = -1;            /* now prevent deletion on interrupt */
        if (g.ind != 0) {
            copymeta(g.inf, g.outf);
            if (!g.keep)
                unlink(g.inf);
        }
        if (g.decode && (g.headis & 2) != 0 && g.stamp)
            touch(g.outf, g.stamp);
    }
    RELEASE(g.outf);
}
"
3030,180766,,Remote,Not required,,CVE-2013-7448,https://www.cvedetails.com/cve/CVE-2013-7448/,CWE-22,Low,Partial,,,2016-02-23,5.0,Directory traversal vulnerability in wiki.c in didiwiki allows remote attackers to read arbitrary files via the page parameter to api/page/get.,2016-03-10,Dir. Trav. ,1,https://github.com/yarolig/didiwiki/commit/5e5c796617e1712905dc5462b94bd5e6c08d15ea,5e5c796617e1712905dc5462b94bd5e6c08d15ea,page_name_is_good function,1,src/wiki.c,"{""sha"": ""850c9b82360ba842c77b6abaf19f288589bf76ac"", ""filename"": ""src/wiki.c"", ""status"": ""modified"", ""additions"": 28, ""deletions"": 5, ""changes"": 33, ""blob_url"": ""https://github.com/yarolig/didiwiki/blob/5e5c796617e1712905dc5462b94bd5e6c08d15ea/src/wiki.c"", ""raw_url"": ""https://github.com/yarolig/didiwiki/raw/5e5c796617e1712905dc5462b94bd5e6c08d15ea/src/wiki.c"", ""contents_url"": ""https://api.github.com/repos/yarolig/didiwiki/contents/src/wiki.c?ref=5e5c796617e1712905dc5462b94bd5e6c08d15ea"", ""patch"": ""@@ -851,6 +851,26 @@ wiki_show_footer(HttpResponse *res)\n \t\t       );\n }\n \n+int page_name_is_good(char* page_name)\n+{\n+/* We should give access only to subdirs of didiwiki root.\n+   I guess that check for absense of '/' is enough.\n+\n+   TODO: Use realpath()\n+*/\n+    if (!page_name)\n+        return FALSE;\n+\n+    if (!isalnum(page[0]))\n+        return FALSE;\n+\n+    if (strstr(page, \""..\""))\n+        return FALSE;\n+\n+    return TRUE;\n+}\n+\n+\n void\n wiki_handle_rest_call(HttpRequest  *req, \n \t\t      HttpResponse *res,\n@@ -866,7 +886,7 @@ wiki_handle_rest_call(HttpRequest  *req,\n \t  if (page == NULL)\n \t    page = http_request_get_query_string(req);\n \n-\t  if (page && (access(page, R_OK) == 0)) \n+\t  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))\n \t    {\n \t      http_response_printf(res, \""%s\"", file_read(page));\n \t      http_response_send(res);\n@@ -879,11 +899,14 @@ wiki_handle_rest_call(HttpRequest  *req,\n \t  if( ( (wikitext = http_request_param_get(req, \""text\"")) != NULL)\n \t      && ( (page = http_request_param_get(req, \""page\"")) != NULL))\n \t    {\n-\t      file_write(page, wikitext);\t      \n+\t  if (page_name_is_good(page))\n+\t    {\n+\t      file_write(page, wikitext);\n \t      http_response_printf(res, \""success\"");\n \t      http_response_send(res);\n \t      return;\n \t    }\n+\t    }\n \t}\n       else if (!strcmp(func, \""page/delete\""))\n \t{\n@@ -892,7 +915,7 @@ wiki_handle_rest_call(HttpRequest  *req,\n \t  if (page == NULL)\n \t    page = http_request_get_query_string(req);\n \n-\t  if (page && (unlink(page) > 0))\n+\t  if (page && page_name_is_good(page) && (unlink(page) > 0))\n \t    {\n \t      http_response_printf(res, \""success\"");\n \t      http_response_send(res);\n@@ -906,7 +929,7 @@ wiki_handle_rest_call(HttpRequest  *req,\n \t  if (page == NULL)\n \t    page = http_request_get_query_string(req);\n \n-\t  if (page && (access(page, R_OK) == 0)) \n+\t  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))\n \t    {\n \t      http_response_printf(res, \""success\"");\n \t      http_response_send(res);\n@@ -1005,7 +1028,7 @@ wiki_handle_http_request(HttpRequest *req)\n   /* A little safety. issue a malformed request for any paths,\n    * There shouldn't need to be any..\n    */\n-  if (strchr(page, '/'))\n+  if (!page_name_is_good(page))\n     {\n       http_response_set_status(res, 404, \""Not Found\"");\n       http_response_printf(res, \""<html><body>404 Not Found</body></html>\\n\"");""}","wiki_handle_http_request(HttpRequest *req)
{
  HttpResponse *res      = http_response_new(req);
  char         *page     = http_request_get_path_info(req); 
  char         *command  = http_request_get_query_string(req); 
  char         *wikitext = """";

  util_dehttpize(page); 	/* remove any encoding on the requested
				   page name.                           */

  if (!strcmp(page, ""/""))
    {
      if (access(""WikiHome"", R_OK) != 0)
	wiki_redirect(res, ""/WikiHome?create"");
      page = ""/WikiHome"";
    }

  if (!strcmp(page, ""/styles.css""))
    {
      /*  Return CSS page */
      http_response_set_content_type(res, ""text/css"");
      http_response_printf(res, ""%s"", CssData);
      http_response_send(res);
      exit(0);
    }

  if (!strcmp(page, ""/favicon.ico""))
    {
      /*  Return favicon */
      http_response_set_content_type(res, ""image/ico"");
      http_response_set_data(res, FaviconData, FaviconDataLen);
      http_response_send(res);
      exit(0);
    }


  page = page + 1; 		/* skip slash */

  if (!strncmp(page, ""api/"", 4))
    {
      char *p;

      page += 4; 
      for (p=page; *p != '\0'; p++)
	if (*p=='?') { *p ='\0'; break; }
      
      wiki_handle_rest_call(req, res, page); 
      exit(0);
    }

   /* A little safety. issue a malformed request for any paths,
    * There shouldn't need to be any..
    */
  if (!page_name_is_good(page))
     {
       http_response_set_status(res, 404, ""Not Found"");
       http_response_printf(res, ""<html><body>404 Not Found</body></html>\n"");
      http_response_send(res);
      exit(0);
    }

  if (!strcmp(page, ""Changes""))
    {
      wiki_show_changes_page(res);
    }
  else if (!strcmp(page, ""ChangesRss""))
    {
      wiki_show_changes_page_rss(res);
    }
  else if (!strcmp(page, ""Search""))
    {
      wiki_show_search_results_page(res, http_request_param_get(req, ""expr""));
    }
  else if (!strcmp(page, ""Create""))
    {
      if ( (wikitext = http_request_param_get(req, ""title"")) != NULL)
	{
	  /* create page and redirect */
	  wiki_redirect(res, http_request_param_get(req, ""title""));
	}
      else
	{
	   /* show create page form  */
	  wiki_show_create_page(res);
	}
    }
  else
    {
      /* TODO: dont blindly write wikitext data to disk */
      if ( (wikitext = http_request_param_get(req, ""wikitext"")) != NULL)
	{
	  file_write(page, wikitext);	      
	}

      if (access(page, R_OK) == 0) 	/* page exists */
	{
	  wikitext = file_read(page);
	  
	  if (!strcmp(command, ""edit""))
	    {
	      /* print edit page */
	      wiki_show_edit_page(res, wikitext, page);
	    }
	  else
	    {
	      wiki_show_page(res, wikitext, page);
	    }
	}
      else
	{
	  if (!strcmp(command, ""create""))
	    {
	      wiki_show_edit_page(res, NULL, page);
	    }
	  else
	    {
	      char buf[1024];
	      snprintf(buf, 1024, ""%s?create"", page);
	      wiki_redirect(res, buf);
	    }
	}
    }

}
","wiki_handle_http_request(HttpRequest *req)
{
  HttpResponse *res      = http_response_new(req);
  char         *page     = http_request_get_path_info(req); 
  char         *command  = http_request_get_query_string(req); 
  char         *wikitext = """";

  util_dehttpize(page); 	/* remove any encoding on the requested
				   page name.                           */

  if (!strcmp(page, ""/""))
    {
      if (access(""WikiHome"", R_OK) != 0)
	wiki_redirect(res, ""/WikiHome?create"");
      page = ""/WikiHome"";
    }

  if (!strcmp(page, ""/styles.css""))
    {
      /*  Return CSS page */
      http_response_set_content_type(res, ""text/css"");
      http_response_printf(res, ""%s"", CssData);
      http_response_send(res);
      exit(0);
    }

  if (!strcmp(page, ""/favicon.ico""))
    {
      /*  Return favicon */
      http_response_set_content_type(res, ""image/ico"");
      http_response_set_data(res, FaviconData, FaviconDataLen);
      http_response_send(res);
      exit(0);
    }


  page = page + 1; 		/* skip slash */

  if (!strncmp(page, ""api/"", 4))
    {
      char *p;

      page += 4; 
      for (p=page; *p != '\0'; p++)
	if (*p=='?') { *p ='\0'; break; }
      
      wiki_handle_rest_call(req, res, page); 
      exit(0);
    }

   /* A little safety. issue a malformed request for any paths,
    * There shouldn't need to be any..
    */
  if (strchr(page, '/'))
     {
       http_response_set_status(res, 404, ""Not Found"");
       http_response_printf(res, ""<html><body>404 Not Found</body></html>\n"");
      http_response_send(res);
      exit(0);
    }

  if (!strcmp(page, ""Changes""))
    {
      wiki_show_changes_page(res);
    }
  else if (!strcmp(page, ""ChangesRss""))
    {
      wiki_show_changes_page_rss(res);
    }
  else if (!strcmp(page, ""Search""))
    {
      wiki_show_search_results_page(res, http_request_param_get(req, ""expr""));
    }
  else if (!strcmp(page, ""Create""))
    {
      if ( (wikitext = http_request_param_get(req, ""title"")) != NULL)
	{
	  /* create page and redirect */
	  wiki_redirect(res, http_request_param_get(req, ""title""));
	}
      else
	{
	   /* show create page form  */
	  wiki_show_create_page(res);
	}
    }
  else
    {
      /* TODO: dont blindly write wikitext data to disk */
      if ( (wikitext = http_request_param_get(req, ""wikitext"")) != NULL)
	{
	  file_write(page, wikitext);	      
	}

      if (access(page, R_OK) == 0) 	/* page exists */
	{
	  wikitext = file_read(page);
	  
	  if (!strcmp(command, ""edit""))
	    {
	      /* print edit page */
	      wiki_show_edit_page(res, wikitext, page);
	    }
	  else
	    {
	      wiki_show_page(res, wikitext, page);
	    }
	}
      else
	{
	  if (!strcmp(command, ""create""))
	    {
	      wiki_show_edit_page(res, NULL, page);
	    }
	  else
	    {
	      char buf[1024];
	      snprintf(buf, 1024, ""%s?create"", page);
	      wiki_redirect(res, buf);
	    }
	}
    }

}
",C,"  if (!page_name_is_good(page))
","  if (strchr(page, '/'))
",,"@@ -851,6 +851,26 @@ wiki_show_footer(HttpResponse *res)
 		       );
 }
 
+int page_name_is_good(char* page_name)
+{
+/* We should give access only to subdirs of didiwiki root.
+   I guess that check for absense of '/' is enough.
+
+   TODO: Use realpath()
+*/
+    if (!page_name)
+        return FALSE;
+
+    if (!isalnum(page[0]))
+        return FALSE;
+
+    if (strstr(page, ""..""))
+        return FALSE;
+
+    return TRUE;
+}
+
+
 void
 wiki_handle_rest_call(HttpRequest  *req, 
 		      HttpResponse *res,
@@ -866,7 +886,7 @@ wiki_handle_rest_call(HttpRequest  *req,
 	  if (page == NULL)
 	    page = http_request_get_query_string(req);
 
-	  if (page && (access(page, R_OK) == 0)) 
+	  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))
 	    {
 	      http_response_printf(res, ""%s"", file_read(page));
 	      http_response_send(res);
@@ -879,11 +899,14 @@ wiki_handle_rest_call(HttpRequest  *req,
 	  if( ( (wikitext = http_request_param_get(req, ""text"")) != NULL)
 	      && ( (page = http_request_param_get(req, ""page"")) != NULL))
 	    {
-	      file_write(page, wikitext);	      
+	  if (page_name_is_good(page))
+	    {
+	      file_write(page, wikitext);
 	      http_response_printf(res, ""success"");
 	      http_response_send(res);
 	      return;
 	    }
+	    }
 	}
       else if (!strcmp(func, ""page/delete""))
 	{
@@ -892,7 +915,7 @@ wiki_handle_rest_call(HttpRequest  *req,
 	  if (page == NULL)
 	    page = http_request_get_query_string(req);
 
-	  if (page && (unlink(page) > 0))
+	  if (page && page_name_is_good(page) && (unlink(page) > 0))
 	    {
 	      http_response_printf(res, ""success"");
 	      http_response_send(res);
@@ -906,7 +929,7 @@ wiki_handle_rest_call(HttpRequest  *req,
 	  if (page == NULL)
 	    page = http_request_get_query_string(req);
 
-	  if (page && (access(page, R_OK) == 0)) 
+	  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))
 	    {
 	      http_response_printf(res, ""success"");
 	      http_response_send(res);
@@ -1005,7 +1028,7 @@ wiki_handle_http_request(HttpRequest *req)
   /* A little safety. issue a malformed request for any paths,
    * There shouldn't need to be any..
    */
-  if (strchr(page, '/'))
+  if (!page_name_is_good(page))
     {
       http_response_set_status(res, 404, ""Not Found"");
       http_response_printf(res, ""<html><body>404 Not Found</body></html>\n"");",didiwiki,5e5c796617e1712905dc5462b94bd5e6c08d15ea,3799c571a9f667dffb5119ce0b3d4715ac6a52af,1,"wiki_handle_http_request(HttpRequest *req)
{
  HttpResponse *res      = http_response_new(req);
  char         *page     = http_request_get_path_info(req); 
  char         *command  = http_request_get_query_string(req); 
  char         *wikitext = """";

  util_dehttpize(page); 	/* remove any encoding on the requested
				   page name.                           */

  if (!strcmp(page, ""/""))
    {
      if (access(""WikiHome"", R_OK) != 0)
	wiki_redirect(res, ""/WikiHome?create"");
      page = ""/WikiHome"";
    }

  if (!strcmp(page, ""/styles.css""))
    {
      /*  Return CSS page */
      http_response_set_content_type(res, ""text/css"");
      http_response_printf(res, ""%s"", CssData);
      http_response_send(res);
      exit(0);
    }

  if (!strcmp(page, ""/favicon.ico""))
    {
      /*  Return favicon */
      http_response_set_content_type(res, ""image/ico"");
      http_response_set_data(res, FaviconData, FaviconDataLen);
      http_response_send(res);
      exit(0);
    }


  page = page + 1; 		/* skip slash */

  if (!strncmp(page, ""api/"", 4))
    {
      char *p;

      page += 4; 
      for (p=page; *p != '\0'; p++)
	if (*p=='?') { *p ='\0'; break; }
      
      wiki_handle_rest_call(req, res, page); 
      exit(0);
    }

   /* A little safety. issue a malformed request for any paths,
    * There shouldn't need to be any..
    */
//flaw_line_below:
  if (strchr(page, '/'))
//fix_flaw_line_below:
//  if (!page_name_is_good(page))
     {
       http_response_set_status(res, 404, ""Not Found"");
       http_response_printf(res, ""<html><body>404 Not Found</body></html>\n"");
      http_response_send(res);
      exit(0);
    }

  if (!strcmp(page, ""Changes""))
    {
      wiki_show_changes_page(res);
    }
  else if (!strcmp(page, ""ChangesRss""))
    {
      wiki_show_changes_page_rss(res);
    }
  else if (!strcmp(page, ""Search""))
    {
      wiki_show_search_results_page(res, http_request_param_get(req, ""expr""));
    }
  else if (!strcmp(page, ""Create""))
    {
      if ( (wikitext = http_request_param_get(req, ""title"")) != NULL)
	{
	  /* create page and redirect */
	  wiki_redirect(res, http_request_param_get(req, ""title""));
	}
      else
	{
	   /* show create page form  */
	  wiki_show_create_page(res);
	}
    }
  else
    {
      /* TODO: dont blindly write wikitext data to disk */
      if ( (wikitext = http_request_param_get(req, ""wikitext"")) != NULL)
	{
	  file_write(page, wikitext);	      
	}

      if (access(page, R_OK) == 0) 	/* page exists */
	{
	  wikitext = file_read(page);
	  
	  if (!strcmp(command, ""edit""))
	    {
	      /* print edit page */
	      wiki_show_edit_page(res, wikitext, page);
	    }
	  else
	    {
	      wiki_show_page(res, wikitext, page);
	    }
	}
      else
	{
	  if (!strcmp(command, ""create""))
	    {
	      wiki_show_edit_page(res, NULL, page);
	    }
	  else
	    {
	      char buf[1024];
	      snprintf(buf, 1024, ""%s?create"", page);
	      wiki_redirect(res, buf);
	    }
	}
    }

}
"
3031,180767,,Remote,Not required,,CVE-2013-7448,https://www.cvedetails.com/cve/CVE-2013-7448/,CWE-22,Low,Partial,,,2016-02-23,5.0,Directory traversal vulnerability in wiki.c in didiwiki allows remote attackers to read arbitrary files via the page parameter to api/page/get.,2016-03-10,Dir. Trav. ,7,https://github.com/yarolig/didiwiki/commit/5e5c796617e1712905dc5462b94bd5e6c08d15ea,5e5c796617e1712905dc5462b94bd5e6c08d15ea,page_name_is_good function,4,src/wiki.c,"{""sha"": ""850c9b82360ba842c77b6abaf19f288589bf76ac"", ""filename"": ""src/wiki.c"", ""status"": ""modified"", ""additions"": 28, ""deletions"": 5, ""changes"": 33, ""blob_url"": ""https://github.com/yarolig/didiwiki/blob/5e5c796617e1712905dc5462b94bd5e6c08d15ea/src/wiki.c"", ""raw_url"": ""https://github.com/yarolig/didiwiki/raw/5e5c796617e1712905dc5462b94bd5e6c08d15ea/src/wiki.c"", ""contents_url"": ""https://api.github.com/repos/yarolig/didiwiki/contents/src/wiki.c?ref=5e5c796617e1712905dc5462b94bd5e6c08d15ea"", ""patch"": ""@@ -851,6 +851,26 @@ wiki_show_footer(HttpResponse *res)\n \t\t       );\n }\n \n+int page_name_is_good(char* page_name)\n+{\n+/* We should give access only to subdirs of didiwiki root.\n+   I guess that check for absense of '/' is enough.\n+\n+   TODO: Use realpath()\n+*/\n+    if (!page_name)\n+        return FALSE;\n+\n+    if (!isalnum(page[0]))\n+        return FALSE;\n+\n+    if (strstr(page, \""..\""))\n+        return FALSE;\n+\n+    return TRUE;\n+}\n+\n+\n void\n wiki_handle_rest_call(HttpRequest  *req, \n \t\t      HttpResponse *res,\n@@ -866,7 +886,7 @@ wiki_handle_rest_call(HttpRequest  *req,\n \t  if (page == NULL)\n \t    page = http_request_get_query_string(req);\n \n-\t  if (page && (access(page, R_OK) == 0)) \n+\t  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))\n \t    {\n \t      http_response_printf(res, \""%s\"", file_read(page));\n \t      http_response_send(res);\n@@ -879,11 +899,14 @@ wiki_handle_rest_call(HttpRequest  *req,\n \t  if( ( (wikitext = http_request_param_get(req, \""text\"")) != NULL)\n \t      && ( (page = http_request_param_get(req, \""page\"")) != NULL))\n \t    {\n-\t      file_write(page, wikitext);\t      \n+\t  if (page_name_is_good(page))\n+\t    {\n+\t      file_write(page, wikitext);\n \t      http_response_printf(res, \""success\"");\n \t      http_response_send(res);\n \t      return;\n \t    }\n+\t    }\n \t}\n       else if (!strcmp(func, \""page/delete\""))\n \t{\n@@ -892,7 +915,7 @@ wiki_handle_rest_call(HttpRequest  *req,\n \t  if (page == NULL)\n \t    page = http_request_get_query_string(req);\n \n-\t  if (page && (unlink(page) > 0))\n+\t  if (page && page_name_is_good(page) && (unlink(page) > 0))\n \t    {\n \t      http_response_printf(res, \""success\"");\n \t      http_response_send(res);\n@@ -906,7 +929,7 @@ wiki_handle_rest_call(HttpRequest  *req,\n \t  if (page == NULL)\n \t    page = http_request_get_query_string(req);\n \n-\t  if (page && (access(page, R_OK) == 0)) \n+\t  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))\n \t    {\n \t      http_response_printf(res, \""success\"");\n \t      http_response_send(res);\n@@ -1005,7 +1028,7 @@ wiki_handle_http_request(HttpRequest *req)\n   /* A little safety. issue a malformed request for any paths,\n    * There shouldn't need to be any..\n    */\n-  if (strchr(page, '/'))\n+  if (!page_name_is_good(page))\n     {\n       http_response_set_status(res, 404, \""Not Found\"");\n       http_response_printf(res, \""<html><body>404 Not Found</body></html>\\n\"");""}"," wiki_handle_rest_call(HttpRequest  *req, 
 		      HttpResponse *res,
		      char         *func)
{

  if (func != NULL && *func != '\0')
    {
      if (!strcmp(func, ""page/get""))
	{
	  char *page = http_request_param_get(req, ""page"");

 	  if (page == NULL)
 	    page = http_request_get_query_string(req);
 
	  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))
 	    {
 	      http_response_printf(res, ""%s"", file_read(page));
 	      http_response_send(res);
	      return;
	    }  
	}
      else if (!strcmp(func, ""page/set""))
	{
	  char *wikitext = NULL, *page = NULL;
 	  if( ( (wikitext = http_request_param_get(req, ""text"")) != NULL)
 	      && ( (page = http_request_param_get(req, ""page"")) != NULL))
 	    {
	  if (page_name_is_good(page))
	    {
	      file_write(page, wikitext);
 	      http_response_printf(res, ""success"");
 	      http_response_send(res);
 	      return;
 	    }
	    }
 	}
       else if (!strcmp(func, ""page/delete""))
 	{
	  char *page = http_request_param_get(req, ""page"");

 	  if (page == NULL)
 	    page = http_request_get_query_string(req);
 
	  if (page && page_name_is_good(page) && (unlink(page) > 0))
 	    {
 	      http_response_printf(res, ""success"");
 	      http_response_send(res);
	      return;  
	    }
	}
      else if (!strcmp(func, ""page/exists""))
	{
	  char *page = http_request_param_get(req, ""page"");

 	  if (page == NULL)
 	    page = http_request_get_query_string(req);
 
	  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))
 	    {
 	      http_response_printf(res, ""success"");
 	      http_response_send(res);
	      return;  
	    }
	}
      else if (!strcmp(func, ""pages"") || !strcmp(func, ""search""))
	{
	  WikiPageList **pages = NULL;
	  int            n_pages, i;
	  char          *expr = http_request_param_get(req, ""expr"");

	  if (expr == NULL)
	    expr = http_request_get_query_string(req);
	  
	  pages = wiki_get_pages(&n_pages, expr);

	  if (pages)
	    {
	      for (i=0; i<n_pages; i++)
		{
		  struct tm   *pTm;
		  char   datebuf[64];
		  
		  pTm = localtime(&pages[i]->mtime);
		  strftime(datebuf, sizeof(datebuf), ""%Y-%m-%d %H:%M"", pTm);
		  http_response_printf(res, ""%s\t%s\n"", pages[i]->name, datebuf);
		}

	      http_response_send(res);
	      return;  
	    }
	}
    }

  http_response_set_status(res, 500, ""Error"");
  http_response_printf(res, ""<html><body>Failed</body></html>\n"");
  http_response_send(res);

  return;  
}
"," wiki_handle_rest_call(HttpRequest  *req, 
 		      HttpResponse *res,
		      char         *func)
{

  if (func != NULL && *func != '\0')
    {
      if (!strcmp(func, ""page/get""))
	{
	  char *page = http_request_param_get(req, ""page"");

 	  if (page == NULL)
 	    page = http_request_get_query_string(req);
 
	  if (page && (access(page, R_OK) == 0)) 
 	    {
 	      http_response_printf(res, ""%s"", file_read(page));
 	      http_response_send(res);
	      return;
	    }  
	}
      else if (!strcmp(func, ""page/set""))
	{
	  char *wikitext = NULL, *page = NULL;
 	  if( ( (wikitext = http_request_param_get(req, ""text"")) != NULL)
 	      && ( (page = http_request_param_get(req, ""page"")) != NULL))
 	    {
	      file_write(page, wikitext);	      
 	      http_response_printf(res, ""success"");
 	      http_response_send(res);
 	      return;
 	    }
 	}
       else if (!strcmp(func, ""page/delete""))
 	{
	  char *page = http_request_param_get(req, ""page"");

 	  if (page == NULL)
 	    page = http_request_get_query_string(req);
 
	  if (page && (unlink(page) > 0))
 	    {
 	      http_response_printf(res, ""success"");
 	      http_response_send(res);
	      return;  
	    }
	}
      else if (!strcmp(func, ""page/exists""))
	{
	  char *page = http_request_param_get(req, ""page"");

 	  if (page == NULL)
 	    page = http_request_get_query_string(req);
 
	  if (page && (access(page, R_OK) == 0)) 
 	    {
 	      http_response_printf(res, ""success"");
 	      http_response_send(res);
	      return;  
	    }
	}
      else if (!strcmp(func, ""pages"") || !strcmp(func, ""search""))
	{
	  WikiPageList **pages = NULL;
	  int            n_pages, i;
	  char          *expr = http_request_param_get(req, ""expr"");

	  if (expr == NULL)
	    expr = http_request_get_query_string(req);
	  
	  pages = wiki_get_pages(&n_pages, expr);

	  if (pages)
	    {
	      for (i=0; i<n_pages; i++)
		{
		  struct tm   *pTm;
		  char   datebuf[64];
		  
		  pTm = localtime(&pages[i]->mtime);
		  strftime(datebuf, sizeof(datebuf), ""%Y-%m-%d %H:%M"", pTm);
		  http_response_printf(res, ""%s\t%s\n"", pages[i]->name, datebuf);
		}

	      http_response_send(res);
	      return;  
	    }
	}
    }

  http_response_set_status(res, 500, ""Error"");
  http_response_printf(res, ""<html><body>Failed</body></html>\n"");
  http_response_send(res);

  return;  
}
",C,"	  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))
	  if (page_name_is_good(page))
	    {
	      file_write(page, wikitext);
	    }
	  if (page && page_name_is_good(page) && (unlink(page) > 0))
	  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))
","	  if (page && (access(page, R_OK) == 0)) 
	      file_write(page, wikitext);	      
	  if (page && (unlink(page) > 0))
	  if (page && (access(page, R_OK) == 0)) 
",,"@@ -851,6 +851,26 @@ wiki_show_footer(HttpResponse *res)
 		       );
 }
 
+int page_name_is_good(char* page_name)
+{
+/* We should give access only to subdirs of didiwiki root.
+   I guess that check for absense of '/' is enough.
+
+   TODO: Use realpath()
+*/
+    if (!page_name)
+        return FALSE;
+
+    if (!isalnum(page[0]))
+        return FALSE;
+
+    if (strstr(page, ""..""))
+        return FALSE;
+
+    return TRUE;
+}
+
+
 void
 wiki_handle_rest_call(HttpRequest  *req, 
 		      HttpResponse *res,
@@ -866,7 +886,7 @@ wiki_handle_rest_call(HttpRequest  *req,
 	  if (page == NULL)
 	    page = http_request_get_query_string(req);
 
-	  if (page && (access(page, R_OK) == 0)) 
+	  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))
 	    {
 	      http_response_printf(res, ""%s"", file_read(page));
 	      http_response_send(res);
@@ -879,11 +899,14 @@ wiki_handle_rest_call(HttpRequest  *req,
 	  if( ( (wikitext = http_request_param_get(req, ""text"")) != NULL)
 	      && ( (page = http_request_param_get(req, ""page"")) != NULL))
 	    {
-	      file_write(page, wikitext);	      
+	  if (page_name_is_good(page))
+	    {
+	      file_write(page, wikitext);
 	      http_response_printf(res, ""success"");
 	      http_response_send(res);
 	      return;
 	    }
+	    }
 	}
       else if (!strcmp(func, ""page/delete""))
 	{
@@ -892,7 +915,7 @@ wiki_handle_rest_call(HttpRequest  *req,
 	  if (page == NULL)
 	    page = http_request_get_query_string(req);
 
-	  if (page && (unlink(page) > 0))
+	  if (page && page_name_is_good(page) && (unlink(page) > 0))
 	    {
 	      http_response_printf(res, ""success"");
 	      http_response_send(res);
@@ -906,7 +929,7 @@ wiki_handle_rest_call(HttpRequest  *req,
 	  if (page == NULL)
 	    page = http_request_get_query_string(req);
 
-	  if (page && (access(page, R_OK) == 0)) 
+	  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))
 	    {
 	      http_response_printf(res, ""success"");
 	      http_response_send(res);
@@ -1005,7 +1028,7 @@ wiki_handle_http_request(HttpRequest *req)
   /* A little safety. issue a malformed request for any paths,
    * There shouldn't need to be any..
    */
-  if (strchr(page, '/'))
+  if (!page_name_is_good(page))
     {
       http_response_set_status(res, 404, ""Not Found"");
       http_response_printf(res, ""<html><body>404 Not Found</body></html>\n"");",didiwiki,5e5c796617e1712905dc5462b94bd5e6c08d15ea,3799c571a9f667dffb5119ce0b3d4715ac6a52af,1," wiki_handle_rest_call(HttpRequest  *req, 
 		      HttpResponse *res,
		      char         *func)
{

  if (func != NULL && *func != '\0')
    {
      if (!strcmp(func, ""page/get""))
	{
	  char *page = http_request_param_get(req, ""page"");

 	  if (page == NULL)
 	    page = http_request_get_query_string(req);
 
//flaw_line_below:
	  if (page && (access(page, R_OK) == 0)) 
//fix_flaw_line_below:
//	  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))
 	    {
 	      http_response_printf(res, ""%s"", file_read(page));
 	      http_response_send(res);
	      return;
	    }  
	}
      else if (!strcmp(func, ""page/set""))
	{
	  char *wikitext = NULL, *page = NULL;
 	  if( ( (wikitext = http_request_param_get(req, ""text"")) != NULL)
 	      && ( (page = http_request_param_get(req, ""page"")) != NULL))
 	    {
//flaw_line_below:
	      file_write(page, wikitext);	      
//fix_flaw_line_below:
//	  if (page_name_is_good(page))
//fix_flaw_line_below:
//	    {
//fix_flaw_line_below:
//	      file_write(page, wikitext);
 	      http_response_printf(res, ""success"");
 	      http_response_send(res);
 	      return;
 	    }
//fix_flaw_line_below:
//	    }
 	}
       else if (!strcmp(func, ""page/delete""))
 	{
	  char *page = http_request_param_get(req, ""page"");

 	  if (page == NULL)
 	    page = http_request_get_query_string(req);
 
//flaw_line_below:
	  if (page && (unlink(page) > 0))
//fix_flaw_line_below:
//	  if (page && page_name_is_good(page) && (unlink(page) > 0))
 	    {
 	      http_response_printf(res, ""success"");
 	      http_response_send(res);
	      return;  
	    }
	}
      else if (!strcmp(func, ""page/exists""))
	{
	  char *page = http_request_param_get(req, ""page"");

 	  if (page == NULL)
 	    page = http_request_get_query_string(req);
 
//flaw_line_below:
	  if (page && (access(page, R_OK) == 0)) 
//fix_flaw_line_below:
//	  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))
 	    {
 	      http_response_printf(res, ""success"");
 	      http_response_send(res);
	      return;  
	    }
	}
      else if (!strcmp(func, ""pages"") || !strcmp(func, ""search""))
	{
	  WikiPageList **pages = NULL;
	  int            n_pages, i;
	  char          *expr = http_request_param_get(req, ""expr"");

	  if (expr == NULL)
	    expr = http_request_get_query_string(req);
	  
	  pages = wiki_get_pages(&n_pages, expr);

	  if (pages)
	    {
	      for (i=0; i<n_pages; i++)
		{
		  struct tm   *pTm;
		  char   datebuf[64];
		  
		  pTm = localtime(&pages[i]->mtime);
		  strftime(datebuf, sizeof(datebuf), ""%Y-%m-%d %H:%M"", pTm);
		  http_response_printf(res, ""%s\t%s\n"", pages[i]->name, datebuf);
		}

	      http_response_send(res);
	      return;  
	    }
	}
    }

  http_response_set_status(res, 500, ""Error"");
  http_response_printf(res, ""<html><body>Failed</body></html>\n"");
  http_response_send(res);

  return;  
}
"
4078,181814,,Remote,Not required,,CVE-2016-10048,https://www.cvedetails.com/cve/CVE-2016-10048/,CWE-22,Low,,Partial,,2017-03-23,5.0,Directory traversal vulnerability in magick/module.c in ImageMagick 6.9.4-7 allows remote attackers to load arbitrary modules via unspecified vectors.,2017-03-24,Dir. Trav. ,9,https://github.com/ImageMagick/ImageMagick/commit/fc6080f1321fd21e86ef916195cc110b05d9effb,fc6080f1321fd21e86ef916195cc110b05d9effb,"Coder path traversal is not authorized, bug report provided by Masaaki Chida",0,magick/module.c,"{""sha"": ""0a6aefdf34546cdf939c6f37398cd48153cc4727"", ""filename"": ""ChangeLog"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/fc6080f1321fd21e86ef916195cc110b05d9effb/ChangeLog"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/fc6080f1321fd21e86ef916195cc110b05d9effb/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/ChangeLog?ref=fc6080f1321fd21e86ef916195cc110b05d9effb"", ""patch"": ""@@ -1,3 +1,8 @@\n+2016-06-02  6.9.4-7 Cristy  <quetzlzacatenango@image...>\n+  * Fix small memory leak (patch provided by \u0410\u043d\u0434\u0440\u0435\u0439 \u0427\u0435\u0440\u043d\u044b\u0439).\n+  * Coder path traversal is not authorized (bug report provided by\n+    Masaaki Chida).\n+\n 2016-05-31  6.9.4-6 Cristy  <quetzlzacatenango@image...>\n   * Release ImageMagick version 6.9.4-6, GIT revision 18334:97775b5:20160531.\n ""}<_**next**_>{""sha"": ""a00b76d64018ebcaaac7c4728e9e10cd94a7d650"", ""filename"": ""magick/module.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/fc6080f1321fd21e86ef916195cc110b05d9effb/magick/module.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/fc6080f1321fd21e86ef916195cc110b05d9effb/magick/module.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/magick/module.c?ref=fc6080f1321fd21e86ef916195cc110b05d9effb"", ""patch"": ""@@ -547,6 +547,15 @@ static MagickBooleanType GetMagickModulePath(const char *filename,\n   assert(path != (char *) NULL);\n   assert(exception != (ExceptionInfo *) NULL);\n   (void) CopyMagickString(path,filename,MaxTextExtent);\n+#if defined(MAGICKCORE_INSTALLED_SUPPORT)\n+  if (strstr(path,\""../\"") != (char *) NULL)\n+    {\n+      errno=EPERM;\n+      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n+        \""NotAuthorized\"",\""`%s'\"",path);\n+      return(MagickFalse);\n+    }\n+#endif\n   module_path=(char *) NULL;\n   switch (module_type)\n   {""}<_**next**_>{""sha"": ""efe48065ed5e94de9c280e64e6ec0d8d6904c23b"", ""filename"": ""magick/xml-tree.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/fc6080f1321fd21e86ef916195cc110b05d9effb/magick/xml-tree.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/fc6080f1321fd21e86ef916195cc110b05d9effb/magick/xml-tree.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/magick/xml-tree.c?ref=fc6080f1321fd21e86ef916195cc110b05d9effb"", ""patch"": ""@@ -2140,7 +2140,10 @@ MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)\n                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))\n                   ParseOpenTag(root,tag,attributes);\n                 else\n-                  ignore_depth++;\n+                  {\n+                    ignore_depth++;\n+                    (void) DestroyXMLTreeAttributes(attributes);\n+                  }\n                 *p=c;\n               }\n             else""}","static MagickBooleanType GetMagickModulePath(const char *filename,
  MagickModuleType module_type,char *path,ExceptionInfo *exception)
{
  char
    *module_path;

  assert(filename != (const char *) NULL);
  (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",filename);
   assert(path != (char *) NULL);
   assert(exception != (ExceptionInfo *) NULL);
   (void) CopyMagickString(path,filename,MaxTextExtent);
#if defined(MAGICKCORE_INSTALLED_SUPPORT)
  if (strstr(path,""../"") != (char *) NULL)
    {
      errno=EPERM;
      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,
        ""NotAuthorized"",""`%s'"",path);
      return(MagickFalse);
    }
#endif
   module_path=(char *) NULL;
   switch (module_type)
   {
    case MagickImageCoderModule:
    default:
    {
      (void) LogMagickEvent(ModuleEvent,GetMagickModule(),
        ""Searching for coder module file \""%s\"" ..."",filename);
      module_path=GetEnvironmentValue(""MAGICK_CODER_MODULE_PATH"");
#if defined(MAGICKCORE_CODER_PATH)
      if (module_path == (char *) NULL)
        module_path=AcquireString(MAGICKCORE_CODER_PATH);
#endif
      break;
    }
    case MagickImageFilterModule:
    {
      (void) LogMagickEvent(ModuleEvent,GetMagickModule(),
        ""Searching for filter module file \""%s\"" ..."",filename);
      module_path=GetEnvironmentValue(""MAGICK_CODER_FILTER_PATH"");
#if defined(MAGICKCORE_FILTER_PATH)
      if (module_path == (char *) NULL)
        module_path=AcquireString(MAGICKCORE_FILTER_PATH);
#endif
      break;
    }
  }
  if (module_path != (char *) NULL)
    {
      register char
        *p,
        *q;

      for (p=module_path-1; p != (char *) NULL; )
      {
        (void) CopyMagickString(path,p+1,MaxTextExtent);
        q=strchr(path,DirectoryListSeparator);
        if (q != (char *) NULL)
          *q='\0';
        q=path+strlen(path)-1;
        if ((q >= path) && (*q != *DirectorySeparator))
          (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);
        (void) ConcatenateMagickString(path,filename,MaxTextExtent);
        if (IsPathAccessible(path) != MagickFalse)
          {
            module_path=DestroyString(module_path);
            return(MagickTrue);
          }
        p=strchr(p+1,DirectoryListSeparator);
      }
      module_path=DestroyString(module_path);
    }
#if defined(MAGICKCORE_INSTALLED_SUPPORT)
  else
#if defined(MAGICKCORE_CODER_PATH)
    {
      const char
        *directory;

      /*
        Search hard coded paths.
      */
      switch (module_type)
      {
        case MagickImageCoderModule:
        default:
        {
          directory=MAGICKCORE_CODER_PATH;
          break;
        }
        case MagickImageFilterModule:
        {
          directory=MAGICKCORE_FILTER_PATH;
          break;
        }
      }
      (void) FormatLocaleString(path,MaxTextExtent,""%s%s"",directory,filename);
      if (IsPathAccessible(path) == MagickFalse)
        {
          ThrowFileException(exception,ConfigureWarning,
            ""UnableToOpenModuleFile"",path);
          return(MagickFalse);
        }
      return(MagickTrue);
    }
#else
#if defined(MAGICKCORE_WINDOWS_SUPPORT)
    {
      const char
        *registery_key;

      unsigned char
        *key_value;

      /*
        Locate path via registry key.
      */
      switch (module_type)
      {
        case MagickImageCoderModule:
        default:
        {
          registery_key=""CoderModulesPath"";
          break;
        }
        case MagickImageFilterModule:
        {
          registery_key=""FilterModulesPath"";
          break;
        }
      }
      key_value=NTRegistryKeyLookup(registery_key);
      if (key_value == (unsigned char *) NULL)
        {
          ThrowMagickException(exception,GetMagickModule(),ConfigureError,
            ""RegistryKeyLookupFailed"",""`%s'"",registery_key);
          return(MagickFalse);
        }
      (void) FormatLocaleString(path,MaxTextExtent,""%s%s%s"",(char *) key_value,
        DirectorySeparator,filename);
      key_value=(unsigned char *) RelinquishMagickMemory(key_value);
      if (IsPathAccessible(path) == MagickFalse)
        {
          ThrowFileException(exception,ConfigureWarning,
            ""UnableToOpenModuleFile"",path);
          return(MagickFalse);
        }
      return(MagickTrue);
    }
#endif
#endif
#if !defined(MAGICKCORE_CODER_PATH) && !defined(MAGICKCORE_WINDOWS_SUPPORT)
# error MAGICKCORE_CODER_PATH or MAGICKCORE_WINDOWS_SUPPORT must be defined when MAGICKCORE_INSTALLED_SUPPORT is defined
#endif
#else
  {
    char
      *home;

    home=GetEnvironmentValue(""MAGICK_HOME"");
    if (home != (char *) NULL)
      {
        /*
          Search MAGICK_HOME.
        */
#if !defined(MAGICKCORE_POSIX_SUPPORT)
        (void) FormatLocaleString(path,MaxTextExtent,""%s%s%s"",home,
          DirectorySeparator,filename);
#else
        const char
          *directory;

        switch (module_type)
        {
          case MagickImageCoderModule:
          default:
          {
            directory=MAGICKCORE_CODER_RELATIVE_PATH;
            break;
          }
          case MagickImageFilterModule:
          {
            directory=MAGICKCORE_FILTER_RELATIVE_PATH;
            break;
          }
        }
        (void) FormatLocaleString(path,MaxTextExtent,""%s/lib/%s/%s"",home,
          directory,filename);
#endif
        home=DestroyString(home);
        if (IsPathAccessible(path) != MagickFalse)
          return(MagickTrue);
      }
  }
  if (*GetClientPath() != '\0')
    {
      /*
        Search based on executable directory.
      */
#if !defined(MAGICKCORE_POSIX_SUPPORT)
      (void) FormatLocaleString(path,MaxTextExtent,""%s%s%s"",GetClientPath(),
        DirectorySeparator,filename);
#else
      char
        prefix[MaxTextExtent];

      const char
        *directory;

      switch (module_type)
      {
        case MagickImageCoderModule:
        default:
        {
          directory=""coders"";
          break;
        }
        case MagickImageFilterModule:
        {
          directory=""filters"";
          break;
        }
      }
      (void) CopyMagickString(prefix,GetClientPath(),MaxTextExtent);
      ChopPathComponents(prefix,1);
      (void) FormatLocaleString(path,MaxTextExtent,""%s/lib/%s/%s/%s"",prefix,
        MAGICKCORE_MODULES_RELATIVE_PATH,directory,filename);
#endif
      if (IsPathAccessible(path) != MagickFalse)
        return(MagickTrue);
    }
#if defined(MAGICKCORE_WINDOWS_SUPPORT)
  {
    /*
      Search module path.
    */
    if ((NTGetModulePath(""CORE_RL_magick_.dll"",path) != MagickFalse) ||
        (NTGetModulePath(""CORE_DB_magick_.dll"",path) != MagickFalse) ||
        (NTGetModulePath(""Magick.dll"",path) != MagickFalse))
      {
        (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);
        (void) ConcatenateMagickString(path,filename,MaxTextExtent);
        if (IsPathAccessible(path) != MagickFalse)
          return(MagickTrue);
      }
  }
#endif
  {
    char
      *home;

    home=GetEnvironmentValue(""XDG_CONFIG_HOME"");
    if (home == (char *) NULL)
      home=GetEnvironmentValue(""LOCALAPPDATA"");
    if (home == (char *) NULL)
      home=GetEnvironmentValue(""APPDATA"");
    if (home == (char *) NULL)
      home=GetEnvironmentValue(""USERPROFILE"");
    if (home != (char *) NULL)
      {
        /*
          Search $XDG_CONFIG_HOME/ImageMagick.
        */
        (void) FormatLocaleString(path,MaxTextExtent,""%s%sImageMagick%s%s"",
          home,DirectorySeparator,DirectorySeparator,filename);
        home=DestroyString(home);
        if (IsPathAccessible(path) != MagickFalse)
          return(MagickTrue);
      }
    home=GetEnvironmentValue(""HOME"");
    if (home != (char *) NULL)
      {
        /*
          Search $HOME/.config/ImageMagick.
        */
        (void) FormatLocaleString(path,MaxTextExtent,
          ""%s%s.config%sImageMagick%s%s"",home,DirectorySeparator,
          DirectorySeparator,DirectorySeparator,filename);
        if (IsPathAccessible(path) != MagickFalse)
          {
            home=DestroyString(home);
            return(MagickTrue);
          }
        /*
          Search $HOME/.magick.
        */
        (void) FormatLocaleString(path,MaxTextExtent,""%s%s.magick%s%s"",home,
          DirectorySeparator,DirectorySeparator,filename);
        home=DestroyString(home);
        if (IsPathAccessible(path) != MagickFalse)
          return(MagickTrue);
      }
  }
  /*
    Search current directory.
  */
  if (IsPathAccessible(path) != MagickFalse)
    return(MagickTrue);
  if (exception->severity < ConfigureError)
    ThrowFileException(exception,ConfigureWarning,""UnableToOpenModuleFile"",
      path);
#endif
  return(MagickFalse);
}
","static MagickBooleanType GetMagickModulePath(const char *filename,
  MagickModuleType module_type,char *path,ExceptionInfo *exception)
{
  char
    *module_path;

  assert(filename != (const char *) NULL);
  (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",filename);
   assert(path != (char *) NULL);
   assert(exception != (ExceptionInfo *) NULL);
   (void) CopyMagickString(path,filename,MaxTextExtent);
   module_path=(char *) NULL;
   switch (module_type)
   {
    case MagickImageCoderModule:
    default:
    {
      (void) LogMagickEvent(ModuleEvent,GetMagickModule(),
        ""Searching for coder module file \""%s\"" ..."",filename);
      module_path=GetEnvironmentValue(""MAGICK_CODER_MODULE_PATH"");
#if defined(MAGICKCORE_CODER_PATH)
      if (module_path == (char *) NULL)
        module_path=AcquireString(MAGICKCORE_CODER_PATH);
#endif
      break;
    }
    case MagickImageFilterModule:
    {
      (void) LogMagickEvent(ModuleEvent,GetMagickModule(),
        ""Searching for filter module file \""%s\"" ..."",filename);
      module_path=GetEnvironmentValue(""MAGICK_CODER_FILTER_PATH"");
#if defined(MAGICKCORE_FILTER_PATH)
      if (module_path == (char *) NULL)
        module_path=AcquireString(MAGICKCORE_FILTER_PATH);
#endif
      break;
    }
  }
  if (module_path != (char *) NULL)
    {
      register char
        *p,
        *q;

      for (p=module_path-1; p != (char *) NULL; )
      {
        (void) CopyMagickString(path,p+1,MaxTextExtent);
        q=strchr(path,DirectoryListSeparator);
        if (q != (char *) NULL)
          *q='\0';
        q=path+strlen(path)-1;
        if ((q >= path) && (*q != *DirectorySeparator))
          (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);
        (void) ConcatenateMagickString(path,filename,MaxTextExtent);
        if (IsPathAccessible(path) != MagickFalse)
          {
            module_path=DestroyString(module_path);
            return(MagickTrue);
          }
        p=strchr(p+1,DirectoryListSeparator);
      }
      module_path=DestroyString(module_path);
    }
#if defined(MAGICKCORE_INSTALLED_SUPPORT)
  else
#if defined(MAGICKCORE_CODER_PATH)
    {
      const char
        *directory;

      /*
        Search hard coded paths.
      */
      switch (module_type)
      {
        case MagickImageCoderModule:
        default:
        {
          directory=MAGICKCORE_CODER_PATH;
          break;
        }
        case MagickImageFilterModule:
        {
          directory=MAGICKCORE_FILTER_PATH;
          break;
        }
      }
      (void) FormatLocaleString(path,MaxTextExtent,""%s%s"",directory,filename);
      if (IsPathAccessible(path) == MagickFalse)
        {
          ThrowFileException(exception,ConfigureWarning,
            ""UnableToOpenModuleFile"",path);
          return(MagickFalse);
        }
      return(MagickTrue);
    }
#else
#if defined(MAGICKCORE_WINDOWS_SUPPORT)
    {
      const char
        *registery_key;

      unsigned char
        *key_value;

      /*
        Locate path via registry key.
      */
      switch (module_type)
      {
        case MagickImageCoderModule:
        default:
        {
          registery_key=""CoderModulesPath"";
          break;
        }
        case MagickImageFilterModule:
        {
          registery_key=""FilterModulesPath"";
          break;
        }
      }
      key_value=NTRegistryKeyLookup(registery_key);
      if (key_value == (unsigned char *) NULL)
        {
          ThrowMagickException(exception,GetMagickModule(),ConfigureError,
            ""RegistryKeyLookupFailed"",""`%s'"",registery_key);
          return(MagickFalse);
        }
      (void) FormatLocaleString(path,MaxTextExtent,""%s%s%s"",(char *) key_value,
        DirectorySeparator,filename);
      key_value=(unsigned char *) RelinquishMagickMemory(key_value);
      if (IsPathAccessible(path) == MagickFalse)
        {
          ThrowFileException(exception,ConfigureWarning,
            ""UnableToOpenModuleFile"",path);
          return(MagickFalse);
        }
      return(MagickTrue);
    }
#endif
#endif
#if !defined(MAGICKCORE_CODER_PATH) && !defined(MAGICKCORE_WINDOWS_SUPPORT)
# error MAGICKCORE_CODER_PATH or MAGICKCORE_WINDOWS_SUPPORT must be defined when MAGICKCORE_INSTALLED_SUPPORT is defined
#endif
#else
  {
    char
      *home;

    home=GetEnvironmentValue(""MAGICK_HOME"");
    if (home != (char *) NULL)
      {
        /*
          Search MAGICK_HOME.
        */
#if !defined(MAGICKCORE_POSIX_SUPPORT)
        (void) FormatLocaleString(path,MaxTextExtent,""%s%s%s"",home,
          DirectorySeparator,filename);
#else
        const char
          *directory;

        switch (module_type)
        {
          case MagickImageCoderModule:
          default:
          {
            directory=MAGICKCORE_CODER_RELATIVE_PATH;
            break;
          }
          case MagickImageFilterModule:
          {
            directory=MAGICKCORE_FILTER_RELATIVE_PATH;
            break;
          }
        }
        (void) FormatLocaleString(path,MaxTextExtent,""%s/lib/%s/%s"",home,
          directory,filename);
#endif
        home=DestroyString(home);
        if (IsPathAccessible(path) != MagickFalse)
          return(MagickTrue);
      }
  }
  if (*GetClientPath() != '\0')
    {
      /*
        Search based on executable directory.
      */
#if !defined(MAGICKCORE_POSIX_SUPPORT)
      (void) FormatLocaleString(path,MaxTextExtent,""%s%s%s"",GetClientPath(),
        DirectorySeparator,filename);
#else
      char
        prefix[MaxTextExtent];

      const char
        *directory;

      switch (module_type)
      {
        case MagickImageCoderModule:
        default:
        {
          directory=""coders"";
          break;
        }
        case MagickImageFilterModule:
        {
          directory=""filters"";
          break;
        }
      }
      (void) CopyMagickString(prefix,GetClientPath(),MaxTextExtent);
      ChopPathComponents(prefix,1);
      (void) FormatLocaleString(path,MaxTextExtent,""%s/lib/%s/%s/%s"",prefix,
        MAGICKCORE_MODULES_RELATIVE_PATH,directory,filename);
#endif
      if (IsPathAccessible(path) != MagickFalse)
        return(MagickTrue);
    }
#if defined(MAGICKCORE_WINDOWS_SUPPORT)
  {
    /*
      Search module path.
    */
    if ((NTGetModulePath(""CORE_RL_magick_.dll"",path) != MagickFalse) ||
        (NTGetModulePath(""CORE_DB_magick_.dll"",path) != MagickFalse) ||
        (NTGetModulePath(""Magick.dll"",path) != MagickFalse))
      {
        (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);
        (void) ConcatenateMagickString(path,filename,MaxTextExtent);
        if (IsPathAccessible(path) != MagickFalse)
          return(MagickTrue);
      }
  }
#endif
  {
    char
      *home;

    home=GetEnvironmentValue(""XDG_CONFIG_HOME"");
    if (home == (char *) NULL)
      home=GetEnvironmentValue(""LOCALAPPDATA"");
    if (home == (char *) NULL)
      home=GetEnvironmentValue(""APPDATA"");
    if (home == (char *) NULL)
      home=GetEnvironmentValue(""USERPROFILE"");
    if (home != (char *) NULL)
      {
        /*
          Search $XDG_CONFIG_HOME/ImageMagick.
        */
        (void) FormatLocaleString(path,MaxTextExtent,""%s%sImageMagick%s%s"",
          home,DirectorySeparator,DirectorySeparator,filename);
        home=DestroyString(home);
        if (IsPathAccessible(path) != MagickFalse)
          return(MagickTrue);
      }
    home=GetEnvironmentValue(""HOME"");
    if (home != (char *) NULL)
      {
        /*
          Search $HOME/.config/ImageMagick.
        */
        (void) FormatLocaleString(path,MaxTextExtent,
          ""%s%s.config%sImageMagick%s%s"",home,DirectorySeparator,
          DirectorySeparator,DirectorySeparator,filename);
        if (IsPathAccessible(path) != MagickFalse)
          {
            home=DestroyString(home);
            return(MagickTrue);
          }
        /*
          Search $HOME/.magick.
        */
        (void) FormatLocaleString(path,MaxTextExtent,""%s%s.magick%s%s"",home,
          DirectorySeparator,DirectorySeparator,filename);
        home=DestroyString(home);
        if (IsPathAccessible(path) != MagickFalse)
          return(MagickTrue);
      }
  }
  /*
    Search current directory.
  */
  if (IsPathAccessible(path) != MagickFalse)
    return(MagickTrue);
  if (exception->severity < ConfigureError)
    ThrowFileException(exception,ConfigureWarning,""UnableToOpenModuleFile"",
      path);
#endif
  return(MagickFalse);
}
",C,"#if defined(MAGICKCORE_INSTALLED_SUPPORT)
  if (strstr(path,""../"") != (char *) NULL)
    {
      errno=EPERM;
      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,
        ""NotAuthorized"",""`%s'"",path);
      return(MagickFalse);
    }
#endif
",,,"@@ -547,6 +547,15 @@ static MagickBooleanType GetMagickModulePath(const char *filename,
   assert(path != (char *) NULL);
   assert(exception != (ExceptionInfo *) NULL);
   (void) CopyMagickString(path,filename,MaxTextExtent);
+#if defined(MAGICKCORE_INSTALLED_SUPPORT)
+  if (strstr(path,""../"") != (char *) NULL)
+    {
+      errno=EPERM;
+      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,
+        ""NotAuthorized"",""`%s'"",path);
+      return(MagickFalse);
+    }
+#endif
   module_path=(char *) NULL;
   switch (module_type)
   {",ImageMagick,fc6080f1321fd21e86ef916195cc110b05d9effb,96b300c1bf3b213e8e7331ba54de1836b665cef3,1,"static MagickBooleanType GetMagickModulePath(const char *filename,
  MagickModuleType module_type,char *path,ExceptionInfo *exception)
{
  char
    *module_path;

  assert(filename != (const char *) NULL);
  (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",filename);
   assert(path != (char *) NULL);
   assert(exception != (ExceptionInfo *) NULL);
   (void) CopyMagickString(path,filename,MaxTextExtent);
//fix_flaw_line_below:
//#if defined(MAGICKCORE_INSTALLED_SUPPORT)
//fix_flaw_line_below:
//  if (strstr(path,""../"") != (char *) NULL)
//fix_flaw_line_below:
//    {
//fix_flaw_line_below:
//      errno=EPERM;
//fix_flaw_line_below:
//      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,
//fix_flaw_line_below:
//        ""NotAuthorized"",""`%s'"",path);
//fix_flaw_line_below:
//      return(MagickFalse);
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//#endif
   module_path=(char *) NULL;
   switch (module_type)
   {
    case MagickImageCoderModule:
    default:
    {
      (void) LogMagickEvent(ModuleEvent,GetMagickModule(),
        ""Searching for coder module file \""%s\"" ..."",filename);
      module_path=GetEnvironmentValue(""MAGICK_CODER_MODULE_PATH"");
#if defined(MAGICKCORE_CODER_PATH)
      if (module_path == (char *) NULL)
        module_path=AcquireString(MAGICKCORE_CODER_PATH);
#endif
      break;
    }
    case MagickImageFilterModule:
    {
      (void) LogMagickEvent(ModuleEvent,GetMagickModule(),
        ""Searching for filter module file \""%s\"" ..."",filename);
      module_path=GetEnvironmentValue(""MAGICK_CODER_FILTER_PATH"");
#if defined(MAGICKCORE_FILTER_PATH)
      if (module_path == (char *) NULL)
        module_path=AcquireString(MAGICKCORE_FILTER_PATH);
#endif
      break;
    }
  }
  if (module_path != (char *) NULL)
    {
      register char
        *p,
        *q;

      for (p=module_path-1; p != (char *) NULL; )
      {
        (void) CopyMagickString(path,p+1,MaxTextExtent);
        q=strchr(path,DirectoryListSeparator);
        if (q != (char *) NULL)
          *q='\0';
        q=path+strlen(path)-1;
        if ((q >= path) && (*q != *DirectorySeparator))
          (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);
        (void) ConcatenateMagickString(path,filename,MaxTextExtent);
        if (IsPathAccessible(path) != MagickFalse)
          {
            module_path=DestroyString(module_path);
            return(MagickTrue);
          }
        p=strchr(p+1,DirectoryListSeparator);
      }
      module_path=DestroyString(module_path);
    }
#if defined(MAGICKCORE_INSTALLED_SUPPORT)
  else
#if defined(MAGICKCORE_CODER_PATH)
    {
      const char
        *directory;

      /*
        Search hard coded paths.
      */
      switch (module_type)
      {
        case MagickImageCoderModule:
        default:
        {
          directory=MAGICKCORE_CODER_PATH;
          break;
        }
        case MagickImageFilterModule:
        {
          directory=MAGICKCORE_FILTER_PATH;
          break;
        }
      }
      (void) FormatLocaleString(path,MaxTextExtent,""%s%s"",directory,filename);
      if (IsPathAccessible(path) == MagickFalse)
        {
          ThrowFileException(exception,ConfigureWarning,
            ""UnableToOpenModuleFile"",path);
          return(MagickFalse);
        }
      return(MagickTrue);
    }
#else
#if defined(MAGICKCORE_WINDOWS_SUPPORT)
    {
      const char
        *registery_key;

      unsigned char
        *key_value;

      /*
        Locate path via registry key.
      */
      switch (module_type)
      {
        case MagickImageCoderModule:
        default:
        {
          registery_key=""CoderModulesPath"";
          break;
        }
        case MagickImageFilterModule:
        {
          registery_key=""FilterModulesPath"";
          break;
        }
      }
      key_value=NTRegistryKeyLookup(registery_key);
      if (key_value == (unsigned char *) NULL)
        {
          ThrowMagickException(exception,GetMagickModule(),ConfigureError,
            ""RegistryKeyLookupFailed"",""`%s'"",registery_key);
          return(MagickFalse);
        }
      (void) FormatLocaleString(path,MaxTextExtent,""%s%s%s"",(char *) key_value,
        DirectorySeparator,filename);
      key_value=(unsigned char *) RelinquishMagickMemory(key_value);
      if (IsPathAccessible(path) == MagickFalse)
        {
          ThrowFileException(exception,ConfigureWarning,
            ""UnableToOpenModuleFile"",path);
          return(MagickFalse);
        }
      return(MagickTrue);
    }
#endif
#endif
#if !defined(MAGICKCORE_CODER_PATH) && !defined(MAGICKCORE_WINDOWS_SUPPORT)
# error MAGICKCORE_CODER_PATH or MAGICKCORE_WINDOWS_SUPPORT must be defined when MAGICKCORE_INSTALLED_SUPPORT is defined
#endif
#else
  {
    char
      *home;

    home=GetEnvironmentValue(""MAGICK_HOME"");
    if (home != (char *) NULL)
      {
        /*
          Search MAGICK_HOME.
        */
#if !defined(MAGICKCORE_POSIX_SUPPORT)
        (void) FormatLocaleString(path,MaxTextExtent,""%s%s%s"",home,
          DirectorySeparator,filename);
#else
        const char
          *directory;

        switch (module_type)
        {
          case MagickImageCoderModule:
          default:
          {
            directory=MAGICKCORE_CODER_RELATIVE_PATH;
            break;
          }
          case MagickImageFilterModule:
          {
            directory=MAGICKCORE_FILTER_RELATIVE_PATH;
            break;
          }
        }
        (void) FormatLocaleString(path,MaxTextExtent,""%s/lib/%s/%s"",home,
          directory,filename);
#endif
        home=DestroyString(home);
        if (IsPathAccessible(path) != MagickFalse)
          return(MagickTrue);
      }
  }
  if (*GetClientPath() != '\0')
    {
      /*
        Search based on executable directory.
      */
#if !defined(MAGICKCORE_POSIX_SUPPORT)
      (void) FormatLocaleString(path,MaxTextExtent,""%s%s%s"",GetClientPath(),
        DirectorySeparator,filename);
#else
      char
        prefix[MaxTextExtent];

      const char
        *directory;

      switch (module_type)
      {
        case MagickImageCoderModule:
        default:
        {
          directory=""coders"";
          break;
        }
        case MagickImageFilterModule:
        {
          directory=""filters"";
          break;
        }
      }
      (void) CopyMagickString(prefix,GetClientPath(),MaxTextExtent);
      ChopPathComponents(prefix,1);
      (void) FormatLocaleString(path,MaxTextExtent,""%s/lib/%s/%s/%s"",prefix,
        MAGICKCORE_MODULES_RELATIVE_PATH,directory,filename);
#endif
      if (IsPathAccessible(path) != MagickFalse)
        return(MagickTrue);
    }
#if defined(MAGICKCORE_WINDOWS_SUPPORT)
  {
    /*
      Search module path.
    */
    if ((NTGetModulePath(""CORE_RL_magick_.dll"",path) != MagickFalse) ||
        (NTGetModulePath(""CORE_DB_magick_.dll"",path) != MagickFalse) ||
        (NTGetModulePath(""Magick.dll"",path) != MagickFalse))
      {
        (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);
        (void) ConcatenateMagickString(path,filename,MaxTextExtent);
        if (IsPathAccessible(path) != MagickFalse)
          return(MagickTrue);
      }
  }
#endif
  {
    char
      *home;

    home=GetEnvironmentValue(""XDG_CONFIG_HOME"");
    if (home == (char *) NULL)
      home=GetEnvironmentValue(""LOCALAPPDATA"");
    if (home == (char *) NULL)
      home=GetEnvironmentValue(""APPDATA"");
    if (home == (char *) NULL)
      home=GetEnvironmentValue(""USERPROFILE"");
    if (home != (char *) NULL)
      {
        /*
          Search $XDG_CONFIG_HOME/ImageMagick.
        */
        (void) FormatLocaleString(path,MaxTextExtent,""%s%sImageMagick%s%s"",
          home,DirectorySeparator,DirectorySeparator,filename);
        home=DestroyString(home);
        if (IsPathAccessible(path) != MagickFalse)
          return(MagickTrue);
      }
    home=GetEnvironmentValue(""HOME"");
    if (home != (char *) NULL)
      {
        /*
          Search $HOME/.config/ImageMagick.
        */
        (void) FormatLocaleString(path,MaxTextExtent,
          ""%s%s.config%sImageMagick%s%s"",home,DirectorySeparator,
          DirectorySeparator,DirectorySeparator,filename);
        if (IsPathAccessible(path) != MagickFalse)
          {
            home=DestroyString(home);
            return(MagickTrue);
          }
        /*
          Search $HOME/.magick.
        */
        (void) FormatLocaleString(path,MaxTextExtent,""%s%s.magick%s%s"",home,
          DirectorySeparator,DirectorySeparator,filename);
        home=DestroyString(home);
        if (IsPathAccessible(path) != MagickFalse)
          return(MagickTrue);
      }
  }
  /*
    Search current directory.
  */
  if (IsPathAccessible(path) != MagickFalse)
    return(MagickTrue);
  if (exception->severity < ConfigureError)
    ThrowFileException(exception,ConfigureWarning,""UnableToOpenModuleFile"",
      path);
#endif
  return(MagickFalse);
}
"
4079,181815,,Remote,Not required,,CVE-2016-10048,https://www.cvedetails.com/cve/CVE-2016-10048/,CWE-22,Low,,Partial,,2017-03-23,5.0,Directory traversal vulnerability in magick/module.c in ImageMagick 6.9.4-7 allows remote attackers to load arbitrary modules via unspecified vectors.,2017-03-24,Dir. Trav. ,4,https://github.com/ImageMagick/ImageMagick/commit/fc6080f1321fd21e86ef916195cc110b05d9effb,fc6080f1321fd21e86ef916195cc110b05d9effb,"Coder path traversal is not authorized, bug report provided by Masaaki Chida",1,magick/xml-tree.c,"{""sha"": ""0a6aefdf34546cdf939c6f37398cd48153cc4727"", ""filename"": ""ChangeLog"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/fc6080f1321fd21e86ef916195cc110b05d9effb/ChangeLog"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/fc6080f1321fd21e86ef916195cc110b05d9effb/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/ChangeLog?ref=fc6080f1321fd21e86ef916195cc110b05d9effb"", ""patch"": ""@@ -1,3 +1,8 @@\n+2016-06-02  6.9.4-7 Cristy  <quetzlzacatenango@image...>\n+  * Fix small memory leak (patch provided by \u0410\u043d\u0434\u0440\u0435\u0439 \u0427\u0435\u0440\u043d\u044b\u0439).\n+  * Coder path traversal is not authorized (bug report provided by\n+    Masaaki Chida).\n+\n 2016-05-31  6.9.4-6 Cristy  <quetzlzacatenango@image...>\n   * Release ImageMagick version 6.9.4-6, GIT revision 18334:97775b5:20160531.\n ""}<_**next**_>{""sha"": ""a00b76d64018ebcaaac7c4728e9e10cd94a7d650"", ""filename"": ""magick/module.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/fc6080f1321fd21e86ef916195cc110b05d9effb/magick/module.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/fc6080f1321fd21e86ef916195cc110b05d9effb/magick/module.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/magick/module.c?ref=fc6080f1321fd21e86ef916195cc110b05d9effb"", ""patch"": ""@@ -547,6 +547,15 @@ static MagickBooleanType GetMagickModulePath(const char *filename,\n   assert(path != (char *) NULL);\n   assert(exception != (ExceptionInfo *) NULL);\n   (void) CopyMagickString(path,filename,MaxTextExtent);\n+#if defined(MAGICKCORE_INSTALLED_SUPPORT)\n+  if (strstr(path,\""../\"") != (char *) NULL)\n+    {\n+      errno=EPERM;\n+      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n+        \""NotAuthorized\"",\""`%s'\"",path);\n+      return(MagickFalse);\n+    }\n+#endif\n   module_path=(char *) NULL;\n   switch (module_type)\n   {""}<_**next**_>{""sha"": ""efe48065ed5e94de9c280e64e6ec0d8d6904c23b"", ""filename"": ""magick/xml-tree.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/fc6080f1321fd21e86ef916195cc110b05d9effb/magick/xml-tree.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/fc6080f1321fd21e86ef916195cc110b05d9effb/magick/xml-tree.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/magick/xml-tree.c?ref=fc6080f1321fd21e86ef916195cc110b05d9effb"", ""patch"": ""@@ -2140,7 +2140,10 @@ MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)\n                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))\n                   ParseOpenTag(root,tag,attributes);\n                 else\n-                  ignore_depth++;\n+                  {\n+                    ignore_depth++;\n+                    (void) DestroyXMLTreeAttributes(attributes);\n+                  }\n                 *p=c;\n               }\n             else""}","MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)
{
  char
    **attribute,
    **attributes,
    *tag,
    *utf8;

  int
    c,
    terminal;

  MagickBooleanType
    status;

  register char
    *p;

  register ssize_t
    i;

  size_t
    ignore_depth,
    length;

  ssize_t
    j,
    l;

  XMLTreeRoot
    *root;

  /*
    Convert xml-string to UTF8.
  */
  if ((xml == (const char *) NULL) || (strlen(xml) == 0))
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return((XMLTreeInfo *) NULL);
    }
  root=(XMLTreeRoot *) NewXMLTreeTag((char *) NULL);
  length=strlen(xml);
  utf8=ConvertUTF16ToUTF8(xml,&length);
  if (utf8 == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""UTF16 to UTF8 failed"");
      return((XMLTreeInfo *) NULL);
    }
  terminal=utf8[length-1];
  utf8[length-1]='\0';
  p=utf8;
  while ((*p != '\0') && (*p != '<'))
    p++;
  if (*p == '\0')
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      utf8=DestroyString(utf8);
      return((XMLTreeInfo *) NULL);
    }
  attribute=(char **) NULL;
  l=0;
  ignore_depth=0;
  for (p++; ; p++)
  {
    attributes=(char **) sentinel;
    tag=p;
    c=(*p);
    if ((isalpha((int) ((unsigned char) *p)) !=0) || (*p == '_') ||
        (*p == ':') || (c < '\0'))
      {
        /*
          Tag.
        */
        if (root->node == (XMLTreeInfo *) NULL)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),
              OptionWarning,""ParseError"",""root tag missing"");
            utf8=DestroyString(utf8);
            return(&root->root);
          }
        p+=strcspn(p,XMLWhitespace ""/>"");
        while (isspace((int) ((unsigned char) *p)) != 0)
          *p++='\0';
        if (ignore_depth == 0)
          {
            if ((*p != '\0') && (*p != '/') && (*p != '>'))
              {
                /*
                  Find tag in default attributes list.
                */
                i=0;
                while ((root->attributes[i] != (char **) NULL) &&
                       (strcmp(root->attributes[i][0],tag) != 0))
                  i++;
                attribute=root->attributes[i];
              }
            for (l=0; (*p != '\0') && (*p != '/') && (*p != '>'); l+=2)
            {
              /*
                Attribute.
              */
              if (l == 0)
                attributes=(char **) AcquireQuantumMemory(4,
                  sizeof(*attributes));
              else
                attributes=(char **) ResizeQuantumMemory(attributes,
                  (size_t) (l+4),sizeof(*attributes));
              if (attributes == (char **) NULL)
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    ResourceLimitError,""MemoryAllocationFailed"",""`%s'"","""");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
              attributes[l+2]=(char *) NULL;
              attributes[l+1]=(char *) NULL;
              attributes[l]=p;
              p+=strcspn(p,XMLWhitespace ""=/>"");
              if ((*p != '=') && (isspace((int) ((unsigned char) *p)) == 0))
                attributes[l]=ConstantString("""");
              else
                {
                  *p++='\0';
                  p+=strspn(p,XMLWhitespace ""="");
                  c=(*p);
                  if ((c == '""') || (c == '\''))
                    {
                      /*
                        Attributes value.
                      */
                      p++;
                      attributes[l+1]=p;
                      while ((*p != '\0') && (*p != c))
                        p++;
                      if (*p != '\0')
                        *p++='\0';
                      else
                        {
                          attributes[l]=ConstantString("""");
                          attributes[l+1]=ConstantString("""");
                          (void) DestroyXMLTreeAttributes(attributes);
                          (void) ThrowMagickException(exception,
                            GetMagickModule(),OptionWarning,""ParseError"",
                            ""missing %c"",c);
                          utf8=DestroyString(utf8);
                          return(&root->root);
                        }
                      j=1;
                      while ((attribute != (char **) NULL) &&
                             (attribute[j] != (char *) NULL) &&
                             (strcmp(attribute[j],attributes[l]) != 0))
                        j+=3;
                      attributes[l+1]=ParseEntities(attributes[l+1],
                        root->entities,(attribute != (char **) NULL) &&
                        (attribute[j] != (char *) NULL) ? *attribute[j+2] :
                        ' ');
                    }
                  attributes[l]=ConstantString(attributes[l]);
                }
              while (isspace((int) ((unsigned char) *p)) != 0)
                p++;
            }
          }
        else
          {
            while((*p != '\0') && (*p != '/') && (*p != '>'))
              p++;
          }
        if (*p == '/')
          {
            /*
              Self closing tag.
            */
            *p++='\0';
            if (((*p != '\0') && (*p != '>')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
            if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
              {
                ParseOpenTag(root,tag,attributes);
                (void) ParseCloseTag(root,tag,exception);
              }
          }
        else
          {
            c=(*p);
            if ((*p == '>') || ((*p == '\0') && (terminal == '>')))
              {
                *p='\0';
                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
                   ParseOpenTag(root,tag,attributes);
                 else
                  {
                    ignore_depth++;
                    (void) DestroyXMLTreeAttributes(attributes);
                  }
                 *p=c;
               }
             else
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
      }
    else
      if (*p == '/')
        {
          /*
            Close tag.
          */
          tag=p+1;
          p+=strcspn(tag,XMLWhitespace "">"")+1;
          c=(*p);
          if ((c == '\0') && (terminal != '>'))
            {
              (void) ThrowMagickException(exception,GetMagickModule(),
                OptionWarning,""ParseError"",""missing >"");
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          *p='\0';
          if (ignore_depth == 0 && ParseCloseTag(root,tag,exception) !=
              (XMLTreeInfo *) NULL)
            {
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          if (ignore_depth > 0)
            ignore_depth--;
          *p=c;
          if (isspace((int) ((unsigned char) *p)) != 0)
            p+=strspn(p,XMLWhitespace);
        }
      else
        if (strncmp(p,""!--"",3) == 0)
          {
            /*
              Comment.
            */
            p=strstr(p+3,""--"");
            if ((p == (char *) NULL) || ((*(p+=2) != '>') && (*p != '\0')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""unclosed <!--"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
        else
          if (strncmp(p,""![CDATA["",8) == 0)
            {
              /*
                Cdata.
              */
              p=strstr(p,""]]>"");
              if (p != (char *) NULL)
                {
                  p+=2;
                  if (ignore_depth == 0)
                    ParseCharacterContent(root,tag+8,(size_t) (p-tag-10),'c');
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unclosed <![CDATA["");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
            }
          else
            if (strncmp(p,""!DOCTYPE"",8) == 0)
              {
                /*
                  DTD.
                */
                for (l=0; (*p != '\0') && (((l == 0) && (*p != '>')) ||
                     ((l != 0) && ((*p != ']') ||
                     (*(p+strspn(p+1,XMLWhitespace)+1) != '>'))));
                  l=(ssize_t) ((*p == '[') ? 1 : l))
                p+=strcspn(p+1,""[]>"")+1;
                if ((*p == '\0') && (terminal != '>'))
                  {
                    (void) ThrowMagickException(exception,GetMagickModule(),
                      OptionWarning,""ParseError"",""unclosed <!DOCTYPE"");
                    utf8=DestroyString(utf8);
                    return(&root->root);
                  }
                if (l != 0)
                  tag=strchr(tag,'[')+1;
                if (l != 0)
                  {
                    status=ParseInternalDoctype(root,tag,(size_t) (p-tag),
                      exception);
                    if (status == MagickFalse)
                      {
                        utf8=DestroyString(utf8);
                        return(&root->root);
                      }
                    p++;
                  }
              }
            else
              if (*p == '?')
                {
                  /*
                    Processing instructions.
                  */
                  do
                  {
                    p=strchr(p,'?');
                    if (p == (char *) NULL)
                      break;
                    p++;
                  } while ((*p != '\0') && (*p != '>'));
                  if ((p == (char *) NULL) || ((*p == '\0') &&
                      (terminal != '>')))
                    {
                      (void) ThrowMagickException(exception,GetMagickModule(),
                        OptionWarning,""ParseError"",""unclosed <?"");
                      utf8=DestroyString(utf8);
                      return(&root->root);
                    }
                  ParseProcessingInstructions(root,tag+1,(size_t) (p-tag-2));
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unexpected <"");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
     if ((p == (char *) NULL) || (*p == '\0'))
       break;
     *p++='\0';
     tag=p;
     if ((*p != '\0') && (*p != '<'))
       {
        /*
          Tag character content.
        */
        while ((*p != '\0') && (*p != '<'))
          p++;
        if (*p == '\0')
          break;
        if (ignore_depth == 0)
          ParseCharacterContent(root,tag,(size_t) (p-tag),'&');
      }
    else
      if (*p == '\0')
        break;
  }
  utf8=DestroyString(utf8);
  if (root->node == (XMLTreeInfo *) NULL)
    return(&root->root);
  if (root->node->tag == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return(&root->root);
    }
  (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
    ""ParseError"",""unclosed tag: `%s'"",root->node->tag);
  return(&root->root);
}
","MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)
{
  char
    **attribute,
    **attributes,
    *tag,
    *utf8;

  int
    c,
    terminal;

  MagickBooleanType
    status;

  register char
    *p;

  register ssize_t
    i;

  size_t
    ignore_depth,
    length;

  ssize_t
    j,
    l;

  XMLTreeRoot
    *root;

  /*
    Convert xml-string to UTF8.
  */
  if ((xml == (const char *) NULL) || (strlen(xml) == 0))
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return((XMLTreeInfo *) NULL);
    }
  root=(XMLTreeRoot *) NewXMLTreeTag((char *) NULL);
  length=strlen(xml);
  utf8=ConvertUTF16ToUTF8(xml,&length);
  if (utf8 == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""UTF16 to UTF8 failed"");
      return((XMLTreeInfo *) NULL);
    }
  terminal=utf8[length-1];
  utf8[length-1]='\0';
  p=utf8;
  while ((*p != '\0') && (*p != '<'))
    p++;
  if (*p == '\0')
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      utf8=DestroyString(utf8);
      return((XMLTreeInfo *) NULL);
    }
  attribute=(char **) NULL;
  l=0;
  ignore_depth=0;
  for (p++; ; p++)
  {
    attributes=(char **) sentinel;
    tag=p;
    c=(*p);
    if ((isalpha((int) ((unsigned char) *p)) !=0) || (*p == '_') ||
        (*p == ':') || (c < '\0'))
      {
        /*
          Tag.
        */
        if (root->node == (XMLTreeInfo *) NULL)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),
              OptionWarning,""ParseError"",""root tag missing"");
            utf8=DestroyString(utf8);
            return(&root->root);
          }
        p+=strcspn(p,XMLWhitespace ""/>"");
        while (isspace((int) ((unsigned char) *p)) != 0)
          *p++='\0';
        if (ignore_depth == 0)
          {
            if ((*p != '\0') && (*p != '/') && (*p != '>'))
              {
                /*
                  Find tag in default attributes list.
                */
                i=0;
                while ((root->attributes[i] != (char **) NULL) &&
                       (strcmp(root->attributes[i][0],tag) != 0))
                  i++;
                attribute=root->attributes[i];
              }
            for (l=0; (*p != '\0') && (*p != '/') && (*p != '>'); l+=2)
            {
              /*
                Attribute.
              */
              if (l == 0)
                attributes=(char **) AcquireQuantumMemory(4,
                  sizeof(*attributes));
              else
                attributes=(char **) ResizeQuantumMemory(attributes,
                  (size_t) (l+4),sizeof(*attributes));
              if (attributes == (char **) NULL)
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    ResourceLimitError,""MemoryAllocationFailed"",""`%s'"","""");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
              attributes[l+2]=(char *) NULL;
              attributes[l+1]=(char *) NULL;
              attributes[l]=p;
              p+=strcspn(p,XMLWhitespace ""=/>"");
              if ((*p != '=') && (isspace((int) ((unsigned char) *p)) == 0))
                attributes[l]=ConstantString("""");
              else
                {
                  *p++='\0';
                  p+=strspn(p,XMLWhitespace ""="");
                  c=(*p);
                  if ((c == '""') || (c == '\''))
                    {
                      /*
                        Attributes value.
                      */
                      p++;
                      attributes[l+1]=p;
                      while ((*p != '\0') && (*p != c))
                        p++;
                      if (*p != '\0')
                        *p++='\0';
                      else
                        {
                          attributes[l]=ConstantString("""");
                          attributes[l+1]=ConstantString("""");
                          (void) DestroyXMLTreeAttributes(attributes);
                          (void) ThrowMagickException(exception,
                            GetMagickModule(),OptionWarning,""ParseError"",
                            ""missing %c"",c);
                          utf8=DestroyString(utf8);
                          return(&root->root);
                        }
                      j=1;
                      while ((attribute != (char **) NULL) &&
                             (attribute[j] != (char *) NULL) &&
                             (strcmp(attribute[j],attributes[l]) != 0))
                        j+=3;
                      attributes[l+1]=ParseEntities(attributes[l+1],
                        root->entities,(attribute != (char **) NULL) &&
                        (attribute[j] != (char *) NULL) ? *attribute[j+2] :
                        ' ');
                    }
                  attributes[l]=ConstantString(attributes[l]);
                }
              while (isspace((int) ((unsigned char) *p)) != 0)
                p++;
            }
          }
        else
          {
            while((*p != '\0') && (*p != '/') && (*p != '>'))
              p++;
          }
        if (*p == '/')
          {
            /*
              Self closing tag.
            */
            *p++='\0';
            if (((*p != '\0') && (*p != '>')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
            if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
              {
                ParseOpenTag(root,tag,attributes);
                (void) ParseCloseTag(root,tag,exception);
              }
          }
        else
          {
            c=(*p);
            if ((*p == '>') || ((*p == '\0') && (terminal == '>')))
              {
                *p='\0';
                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
                   ParseOpenTag(root,tag,attributes);
                 else
                  ignore_depth++;
                 *p=c;
               }
             else
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
      }
    else
      if (*p == '/')
        {
          /*
            Close tag.
          */
          tag=p+1;
          p+=strcspn(tag,XMLWhitespace "">"")+1;
          c=(*p);
          if ((c == '\0') && (terminal != '>'))
            {
              (void) ThrowMagickException(exception,GetMagickModule(),
                OptionWarning,""ParseError"",""missing >"");
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          *p='\0';
          if (ignore_depth == 0 && ParseCloseTag(root,tag,exception) !=
              (XMLTreeInfo *) NULL)
            {
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          if (ignore_depth > 0)
            ignore_depth--;
          *p=c;
          if (isspace((int) ((unsigned char) *p)) != 0)
            p+=strspn(p,XMLWhitespace);
        }
      else
        if (strncmp(p,""!--"",3) == 0)
          {
            /*
              Comment.
            */
            p=strstr(p+3,""--"");
            if ((p == (char *) NULL) || ((*(p+=2) != '>') && (*p != '\0')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""unclosed <!--"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
        else
          if (strncmp(p,""![CDATA["",8) == 0)
            {
              /*
                Cdata.
              */
              p=strstr(p,""]]>"");
              if (p != (char *) NULL)
                {
                  p+=2;
                  if (ignore_depth == 0)
                    ParseCharacterContent(root,tag+8,(size_t) (p-tag-10),'c');
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unclosed <![CDATA["");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
            }
          else
            if (strncmp(p,""!DOCTYPE"",8) == 0)
              {
                /*
                  DTD.
                */
                for (l=0; (*p != '\0') && (((l == 0) && (*p != '>')) ||
                     ((l != 0) && ((*p != ']') ||
                     (*(p+strspn(p+1,XMLWhitespace)+1) != '>'))));
                  l=(ssize_t) ((*p == '[') ? 1 : l))
                p+=strcspn(p+1,""[]>"")+1;
                if ((*p == '\0') && (terminal != '>'))
                  {
                    (void) ThrowMagickException(exception,GetMagickModule(),
                      OptionWarning,""ParseError"",""unclosed <!DOCTYPE"");
                    utf8=DestroyString(utf8);
                    return(&root->root);
                  }
                if (l != 0)
                  tag=strchr(tag,'[')+1;
                if (l != 0)
                  {
                    status=ParseInternalDoctype(root,tag,(size_t) (p-tag),
                      exception);
                    if (status == MagickFalse)
                      {
                        utf8=DestroyString(utf8);
                        return(&root->root);
                      }
                    p++;
                  }
              }
            else
              if (*p == '?')
                {
                  /*
                    Processing instructions.
                  */
                  do
                  {
                    p=strchr(p,'?');
                    if (p == (char *) NULL)
                      break;
                    p++;
                  } while ((*p != '\0') && (*p != '>'));
                  if ((p == (char *) NULL) || ((*p == '\0') &&
                      (terminal != '>')))
                    {
                      (void) ThrowMagickException(exception,GetMagickModule(),
                        OptionWarning,""ParseError"",""unclosed <?"");
                      utf8=DestroyString(utf8);
                      return(&root->root);
                    }
                  ParseProcessingInstructions(root,tag+1,(size_t) (p-tag-2));
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unexpected <"");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
     if ((p == (char *) NULL) || (*p == '\0'))
       break;
     *p++='\0';
     tag=p;
     if ((*p != '\0') && (*p != '<'))
       {
        /*
          Tag character content.
        */
        while ((*p != '\0') && (*p != '<'))
          p++;
        if (*p == '\0')
          break;
        if (ignore_depth == 0)
          ParseCharacterContent(root,tag,(size_t) (p-tag),'&');
      }
    else
      if (*p == '\0')
        break;
  }
  utf8=DestroyString(utf8);
  if (root->node == (XMLTreeInfo *) NULL)
    return(&root->root);
  if (root->node->tag == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return(&root->root);
    }
  (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
    ""ParseError"",""unclosed tag: `%s'"",root->node->tag);
  return(&root->root);
}
",C,"                  {
                    ignore_depth++;
                    (void) DestroyXMLTreeAttributes(attributes);
                  }
","                  ignore_depth++;
",,"@@ -2140,7 +2140,10 @@ MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)
                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
                   ParseOpenTag(root,tag,attributes);
                 else
-                  ignore_depth++;
+                  {
+                    ignore_depth++;
+                    (void) DestroyXMLTreeAttributes(attributes);
+                  }
                 *p=c;
               }
             else",ImageMagick,fc6080f1321fd21e86ef916195cc110b05d9effb,96b300c1bf3b213e8e7331ba54de1836b665cef3,1,"MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)
{
  char
    **attribute,
    **attributes,
    *tag,
    *utf8;

  int
    c,
    terminal;

  MagickBooleanType
    status;

  register char
    *p;

  register ssize_t
    i;

  size_t
    ignore_depth,
    length;

  ssize_t
    j,
    l;

  XMLTreeRoot
    *root;

  /*
    Convert xml-string to UTF8.
  */
  if ((xml == (const char *) NULL) || (strlen(xml) == 0))
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return((XMLTreeInfo *) NULL);
    }
  root=(XMLTreeRoot *) NewXMLTreeTag((char *) NULL);
  length=strlen(xml);
  utf8=ConvertUTF16ToUTF8(xml,&length);
  if (utf8 == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""UTF16 to UTF8 failed"");
      return((XMLTreeInfo *) NULL);
    }
  terminal=utf8[length-1];
  utf8[length-1]='\0';
  p=utf8;
  while ((*p != '\0') && (*p != '<'))
    p++;
  if (*p == '\0')
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      utf8=DestroyString(utf8);
      return((XMLTreeInfo *) NULL);
    }
  attribute=(char **) NULL;
  l=0;
  ignore_depth=0;
  for (p++; ; p++)
  {
    attributes=(char **) sentinel;
    tag=p;
    c=(*p);
    if ((isalpha((int) ((unsigned char) *p)) !=0) || (*p == '_') ||
        (*p == ':') || (c < '\0'))
      {
        /*
          Tag.
        */
        if (root->node == (XMLTreeInfo *) NULL)
          {
            (void) ThrowMagickException(exception,GetMagickModule(),
              OptionWarning,""ParseError"",""root tag missing"");
            utf8=DestroyString(utf8);
            return(&root->root);
          }
        p+=strcspn(p,XMLWhitespace ""/>"");
        while (isspace((int) ((unsigned char) *p)) != 0)
          *p++='\0';
        if (ignore_depth == 0)
          {
            if ((*p != '\0') && (*p != '/') && (*p != '>'))
              {
                /*
                  Find tag in default attributes list.
                */
                i=0;
                while ((root->attributes[i] != (char **) NULL) &&
                       (strcmp(root->attributes[i][0],tag) != 0))
                  i++;
                attribute=root->attributes[i];
              }
            for (l=0; (*p != '\0') && (*p != '/') && (*p != '>'); l+=2)
            {
              /*
                Attribute.
              */
              if (l == 0)
                attributes=(char **) AcquireQuantumMemory(4,
                  sizeof(*attributes));
              else
                attributes=(char **) ResizeQuantumMemory(attributes,
                  (size_t) (l+4),sizeof(*attributes));
              if (attributes == (char **) NULL)
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    ResourceLimitError,""MemoryAllocationFailed"",""`%s'"","""");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
              attributes[l+2]=(char *) NULL;
              attributes[l+1]=(char *) NULL;
              attributes[l]=p;
              p+=strcspn(p,XMLWhitespace ""=/>"");
              if ((*p != '=') && (isspace((int) ((unsigned char) *p)) == 0))
                attributes[l]=ConstantString("""");
              else
                {
                  *p++='\0';
                  p+=strspn(p,XMLWhitespace ""="");
                  c=(*p);
                  if ((c == '""') || (c == '\''))
                    {
                      /*
                        Attributes value.
                      */
                      p++;
                      attributes[l+1]=p;
                      while ((*p != '\0') && (*p != c))
                        p++;
                      if (*p != '\0')
                        *p++='\0';
                      else
                        {
                          attributes[l]=ConstantString("""");
                          attributes[l+1]=ConstantString("""");
                          (void) DestroyXMLTreeAttributes(attributes);
                          (void) ThrowMagickException(exception,
                            GetMagickModule(),OptionWarning,""ParseError"",
                            ""missing %c"",c);
                          utf8=DestroyString(utf8);
                          return(&root->root);
                        }
                      j=1;
                      while ((attribute != (char **) NULL) &&
                             (attribute[j] != (char *) NULL) &&
                             (strcmp(attribute[j],attributes[l]) != 0))
                        j+=3;
                      attributes[l+1]=ParseEntities(attributes[l+1],
                        root->entities,(attribute != (char **) NULL) &&
                        (attribute[j] != (char *) NULL) ? *attribute[j+2] :
                        ' ');
                    }
                  attributes[l]=ConstantString(attributes[l]);
                }
              while (isspace((int) ((unsigned char) *p)) != 0)
                p++;
            }
          }
        else
          {
            while((*p != '\0') && (*p != '/') && (*p != '>'))
              p++;
          }
        if (*p == '/')
          {
            /*
              Self closing tag.
            */
            *p++='\0';
            if (((*p != '\0') && (*p != '>')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
            if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
              {
                ParseOpenTag(root,tag,attributes);
                (void) ParseCloseTag(root,tag,exception);
              }
          }
        else
          {
            c=(*p);
            if ((*p == '>') || ((*p == '\0') && (terminal == '>')))
              {
                *p='\0';
                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))
                   ParseOpenTag(root,tag,attributes);
                 else
//flaw_line_below:
                  ignore_depth++;
//fix_flaw_line_below:
//                  {
//fix_flaw_line_below:
//                    ignore_depth++;
//fix_flaw_line_below:
//                    (void) DestroyXMLTreeAttributes(attributes);
//fix_flaw_line_below:
//                  }
                 *p=c;
               }
             else
              {
                if (l != 0)
                  (void) DestroyXMLTreeAttributes(attributes);
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""missing >"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
      }
    else
      if (*p == '/')
        {
          /*
            Close tag.
          */
          tag=p+1;
          p+=strcspn(tag,XMLWhitespace "">"")+1;
          c=(*p);
          if ((c == '\0') && (terminal != '>'))
            {
              (void) ThrowMagickException(exception,GetMagickModule(),
                OptionWarning,""ParseError"",""missing >"");
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          *p='\0';
          if (ignore_depth == 0 && ParseCloseTag(root,tag,exception) !=
              (XMLTreeInfo *) NULL)
            {
              utf8=DestroyString(utf8);
              return(&root->root);
            }
          if (ignore_depth > 0)
            ignore_depth--;
          *p=c;
          if (isspace((int) ((unsigned char) *p)) != 0)
            p+=strspn(p,XMLWhitespace);
        }
      else
        if (strncmp(p,""!--"",3) == 0)
          {
            /*
              Comment.
            */
            p=strstr(p+3,""--"");
            if ((p == (char *) NULL) || ((*(p+=2) != '>') && (*p != '\0')) ||
                ((*p == '\0') && (terminal != '>')))
              {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionWarning,""ParseError"",""unclosed <!--"");
                utf8=DestroyString(utf8);
                return(&root->root);
              }
          }
        else
          if (strncmp(p,""![CDATA["",8) == 0)
            {
              /*
                Cdata.
              */
              p=strstr(p,""]]>"");
              if (p != (char *) NULL)
                {
                  p+=2;
                  if (ignore_depth == 0)
                    ParseCharacterContent(root,tag+8,(size_t) (p-tag-10),'c');
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unclosed <![CDATA["");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
            }
          else
            if (strncmp(p,""!DOCTYPE"",8) == 0)
              {
                /*
                  DTD.
                */
                for (l=0; (*p != '\0') && (((l == 0) && (*p != '>')) ||
                     ((l != 0) && ((*p != ']') ||
                     (*(p+strspn(p+1,XMLWhitespace)+1) != '>'))));
                  l=(ssize_t) ((*p == '[') ? 1 : l))
                p+=strcspn(p+1,""[]>"")+1;
                if ((*p == '\0') && (terminal != '>'))
                  {
                    (void) ThrowMagickException(exception,GetMagickModule(),
                      OptionWarning,""ParseError"",""unclosed <!DOCTYPE"");
                    utf8=DestroyString(utf8);
                    return(&root->root);
                  }
                if (l != 0)
                  tag=strchr(tag,'[')+1;
                if (l != 0)
                  {
                    status=ParseInternalDoctype(root,tag,(size_t) (p-tag),
                      exception);
                    if (status == MagickFalse)
                      {
                        utf8=DestroyString(utf8);
                        return(&root->root);
                      }
                    p++;
                  }
              }
            else
              if (*p == '?')
                {
                  /*
                    Processing instructions.
                  */
                  do
                  {
                    p=strchr(p,'?');
                    if (p == (char *) NULL)
                      break;
                    p++;
                  } while ((*p != '\0') && (*p != '>'));
                  if ((p == (char *) NULL) || ((*p == '\0') &&
                      (terminal != '>')))
                    {
                      (void) ThrowMagickException(exception,GetMagickModule(),
                        OptionWarning,""ParseError"",""unclosed <?"");
                      utf8=DestroyString(utf8);
                      return(&root->root);
                    }
                  ParseProcessingInstructions(root,tag+1,(size_t) (p-tag-2));
                }
              else
                {
                  (void) ThrowMagickException(exception,GetMagickModule(),
                    OptionWarning,""ParseError"",""unexpected <"");
                  utf8=DestroyString(utf8);
                  return(&root->root);
                }
     if ((p == (char *) NULL) || (*p == '\0'))
       break;
     *p++='\0';
     tag=p;
     if ((*p != '\0') && (*p != '<'))
       {
        /*
          Tag character content.
        */
        while ((*p != '\0') && (*p != '<'))
          p++;
        if (*p == '\0')
          break;
        if (ignore_depth == 0)
          ParseCharacterContent(root,tag,(size_t) (p-tag),'&');
      }
    else
      if (*p == '\0')
        break;
  }
  utf8=DestroyString(utf8);
  if (root->node == (XMLTreeInfo *) NULL)
    return(&root->root);
  if (root->node->tag == (char *) NULL)
    {
      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
        ""ParseError"",""root tag missing"");
      return(&root->root);
    }
  (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
    ""ParseError"",""unclosed tag: `%s'"",root->node->tag);
  return(&root->root);
}
"
4437,182173,,Remote,Not required,,CVE-2018-18586,https://www.cvedetails.com/cve/CVE-2018-18586/,CWE-22,Low,Partial,,,2018-10-22,5.0,"** DISPUTED ** chmextract.c in the chmextract sample program, as distributed with libmspack before 0.8alpha, does not protect against absolute/relative pathnames in CHM files, leading to Directory Traversal. NOTE: the vendor disputes that this is a libmspack vulnerability, because chmextract.c was only intended as a source-code example, not a supported application.",2019-04-03,Dir. Trav. ,16,https://github.com/kyz/libmspack/commit/7cadd489698be117c47efcadd742651594429e6d,7cadd489698be117c47efcadd742651594429e6d,"add anti ""../"" and leading slash protection to chmextract",94,libmspack/src/chmextract.c,"{""sha"": ""325c160d25e254d902dac15fedfdc897d6bdd60d"", ""filename"": ""libmspack/ChangeLog"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 0, ""changes"": 10, ""blob_url"": ""https://github.com/kyz/libmspack/blob/7cadd489698be117c47efcadd742651594429e6d/libmspack/ChangeLog"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/7cadd489698be117c47efcadd742651594429e6d/libmspack/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/ChangeLog?ref=7cadd489698be117c47efcadd742651594429e6d"", ""patch"": ""@@ -1,3 +1,13 @@\n+2018-10-20  Stuart Caie <kyzer@cabextract.org.uk>\n+\n+\t* src/chmextract.c: add anti \""../\"" and leading slash protection to\n+\tchmextract. I'm not pleased about this. All the sample code provided\n+\twith libmspack is meant to be simple examples of library use, not\n+\t\""productised\"" binaries. Making the \""useful\"" code samples install\n+\tas binaries was a mistake. They were never intended to protect you\n+\tfrom unpacking archive files with relative/absolute paths, and I\n+\twould prefer that they never will be.\n+\n 2018-10-17  Stuart Caie <kyzer@cabextract.org.uk>\n \n \t* cab.h: Make the CAB block input buffer one byte larger, to allow""}<_**next**_>{""sha"": ""b535f0eef7727052df7b7cf5b1650a2d9cf837a8"", ""filename"": ""libmspack/src/chmextract.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 123, ""changes"": 140, ""blob_url"": ""https://github.com/kyz/libmspack/blob/7cadd489698be117c47efcadd742651594429e6d/libmspack/src/chmextract.c"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/7cadd489698be117c47efcadd742651594429e6d/libmspack/src/chmextract.c"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/src/chmextract.c?ref=7cadd489698be117c47efcadd742651594429e6d"", ""patch"": ""@@ -25,8 +25,6 @@\n \n mode_t user_umask;\n \n-#define FILENAME \"".test.chmx\""\n-\n /**\n  * Ensures that all directory components in a filepath exist. New directory\n  * components are created, if necessary.\n@@ -51,126 +49,22 @@ static int ensure_filepath(char *path) {\n   return 1;\n }\n \n-/**\n- * Creates a UNIX filename from the internal CAB filename and the given\n- * parameters.\n- *\n- * @param fname  the internal CAB filename.\n- * @param dir    a directory path to prepend to the output filename.\n- * @param lower  if non-zero, filename should be made lower-case.\n- * @param isunix if zero, MS-DOS path seperators are used in the internal\n- *               CAB filename. If non-zero, UNIX path seperators are used.\n- * @param utf8   if non-zero, the internal CAB filename is encoded in UTF8.\n- * @return a freshly allocated and created filename, or NULL if there was\n- *         not enough memory.\n- * @see unix_path_seperators()\n- */\n-static char *create_output_name(unsigned char *fname, unsigned char *dir,\n-\t\t\t int lower, int isunix, int utf8)\n-{\n-  unsigned char *p, *name, c, *fe, sep, slash;\n-  unsigned int x;\n-\n-  sep   = (isunix) ? '/'  : '\\\\'; /* the path-seperator */\n-  slash = (isunix) ? '\\\\' : '/';  /* the other slash */\n-\n-  /* length of filename */\n-  x = strlen((char *) fname);\n-  /* UTF8 worst case scenario: tolower() expands all chars from 1 to 3 bytes */\n-  if (utf8) x *= 3;\n-  /* length of output directory */\n-  if (dir) x += strlen((char *) dir);\n-\n-  if (!(name = (unsigned char *) malloc(x + 2))) {\n-    fprintf(stderr, \""out of memory!\\n\"");\n-    return NULL;\n-  }\n-  \n-  /* start with blank name */\n-  *name = '\\0';\n-\n-  /* add output directory if needed */\n-  if (dir) {\n-    strcpy((char *) name, (char *) dir);\n-    strcat((char *) name, \""/\"");\n-  }\n-\n-  /* remove leading slashes */\n-  while (*fname == sep) fname++;\n-\n-  /* copy from fi->filename to new name, converting MS-DOS slashes to UNIX\n-   * slashes as we go. Also lowercases characters if needed.\n-   */\n-  p = &name[strlen((char *)name)];\n-  fe = &fname[strlen((char *)fname)];\n-\n-  if (utf8) {\n-    /* UTF8 translates two-byte unicode characters into 1, 2 or 3 bytes.\n-     * %000000000xxxxxxx -> %0xxxxxxx\n-     * %00000xxxxxyyyyyy -> %110xxxxx %10yyyyyy\n-     * %xxxxyyyyyyzzzzzz -> %1110xxxx %10yyyyyy %10zzzzzz\n-     *\n-     * Therefore, the inverse is as follows:\n-     * First char:\n-     *  0x00 - 0x7F = one byte char\n-     *  0x80 - 0xBF = invalid\n-     *  0xC0 - 0xDF = 2 byte char (next char only 0x80-0xBF is valid)\n-     *  0xE0 - 0xEF = 3 byte char (next 2 chars only 0x80-0xBF is valid)\n-     *  0xF0 - 0xFF = invalid\n-     */\n-    do {\n-      if (fname >= fe) {\n-\tfree(name);\n-\treturn NULL;\n-      }\n-\n-      /* get next UTF8 char */\n-      if ((c = *fname++) < 0x80) x = c;\n-      else {\n-\tif ((c >= 0xC0) && (c < 0xE0)) {\n-\t  x = (c & 0x1F) << 6;\n-\t  x |= *fname++ & 0x3F;\n-\t}\n-\telse if ((c >= 0xE0) && (c < 0xF0)) {\n-\t  x = (c & 0xF) << 12;\n-\t  x |= (*fname++ & 0x3F) << 6;\n-\t  x |= *fname++ & 0x3F;\n-\t}\n-\telse x = '?';\n-      }\n-\n-      /* whatever is the path seperator -> '/'\n-       * whatever is the other slash    -> '\\\\'\n-       * otherwise, if lower is set, the lowercase version */\n-      if      (x == sep)   x = '/';\n-      else if (x == slash) x = '\\\\';\n-      else if (lower)      x = (unsigned int) tolower((int) x);\n-\n-      /* integer back to UTF8 */\n-      if (x < 0x80) {\n-\t*p++ = (unsigned char) x;\n-      }\n-      else if (x < 0x800) {\n-\t*p++ = 0xC0 | (x >> 6);   \n-\t*p++ = 0x80 | (x & 0x3F);\n-      }\n-      else {\n-\t*p++ = 0xE0 | (x >> 12);\n-\t*p++ = 0x80 | ((x >> 6) & 0x3F);\n-\t*p++ = 0x80 | (x & 0x3F);\n-      }\n-    } while (x);\n-  }\n-  else {\n-    /* regular non-utf8 version */\n-    do {\n-      c = *fname++;\n-      if      (c == sep)   c = '/';\n-      else if (c == slash) c = '\\\\';\n-      else if (lower)      c = (unsigned char) tolower((int) c);\n-    } while ((*p++ = c));\n-  }\n-  return (char *) name;\n+char *create_output_name(char *fname) {\n+    char *out, *p;\n+    if ((out = malloc(strlen(fname) + 1))) {\n+        /* remove leading slashes */\n+        while (*fname == '/' || *fname == '\\\\') fname++;\n+        /* if that removes all characters, just call it \""x\"" */\n+        strcpy(out, (*fname) ? fname : \""x\"");\n+\n+        /* change \""../\"" to \""xx/\"" */\n+        for (p = out; *p; p++) {\n+            if (p[0] == '.' && p[1] == '.' && (p[2] == '/' || p[2] == '\\\\')) {\n+               p[0] = p[1] = 'x';\n+            }\n+        }\n+    }\n+    return out;\n }\n \n static int sortfunc(const void *a, const void *b) {\n@@ -205,7 +99,7 @@ int main(int argc, char *argv[]) {\n \t  qsort(f, numf, sizeof(struct mschmd_file *), &sortfunc);\n \n \t  for (i = 0; i < numf; i++) {\n-\t    char *outname = create_output_name((unsigned char *)f[i]->filename,NULL,0,1,0);\n+\t    char *outname = create_output_name(f[i]->filename);\n \t    printf(\""Extracting %s\\n\"", outname);\n \t    ensure_filepath(outname);\n \t    if (chmd->extract(chmd, f[i], outname)) {""}","static char *create_output_name(unsigned char *fname, unsigned char *dir,
char *create_output_name(char *fname) {
    char *out, *p;
    if ((out = malloc(strlen(fname) + 1))) {
        /* remove leading slashes */
        while (*fname == '/' || *fname == '\\') fname++;
        /* if that removes all characters, just call it ""x"" */
        strcpy(out, (*fname) ? fname : ""x"");

        /* change ""../"" to ""xx/"" */
        for (p = out; *p; p++) {
            if (p[0] == '.' && p[1] == '.' && (p[2] == '/' || p[2] == '\\')) {
               p[0] = p[1] = 'x';
            }
        }
    }
    return out;
 }
","static char *create_output_name(unsigned char *fname, unsigned char *dir,
			 int lower, int isunix, int utf8)
{
  unsigned char *p, *name, c, *fe, sep, slash;
  unsigned int x;
  sep   = (isunix) ? '/'  : '\\'; /* the path-seperator */
  slash = (isunix) ? '\\' : '/';  /* the other slash */
  /* length of filename */
  x = strlen((char *) fname);
  /* UTF8 worst case scenario: tolower() expands all chars from 1 to 3 bytes */
  if (utf8) x *= 3;
  /* length of output directory */
  if (dir) x += strlen((char *) dir);
  if (!(name = (unsigned char *) malloc(x + 2))) {
    fprintf(stderr, ""out of memory!\n"");
    return NULL;
  }
  /* start with blank name */
  *name = '\0';
  /* add output directory if needed */
  if (dir) {
    strcpy((char *) name, (char *) dir);
    strcat((char *) name, ""/"");
  }
  /* remove leading slashes */
  while (*fname == sep) fname++;
  /* copy from fi->filename to new name, converting MS-DOS slashes to UNIX
   * slashes as we go. Also lowercases characters if needed.
   */
  p = &name[strlen((char *)name)];
  fe = &fname[strlen((char *)fname)];
  if (utf8) {
    /* UTF8 translates two-byte unicode characters into 1, 2 or 3 bytes.
     * %000000000xxxxxxx -> %0xxxxxxx
     * %00000xxxxxyyyyyy -> %110xxxxx %10yyyyyy
     * %xxxxyyyyyyzzzzzz -> %1110xxxx %10yyyyyy %10zzzzzz
     *
     * Therefore, the inverse is as follows:
     * First char:
     *  0x00 - 0x7F = one byte char
     *  0x80 - 0xBF = invalid
     *  0xC0 - 0xDF = 2 byte char (next char only 0x80-0xBF is valid)
     *  0xE0 - 0xEF = 3 byte char (next 2 chars only 0x80-0xBF is valid)
     *  0xF0 - 0xFF = invalid
     */
    do {
      if (fname >= fe) {
	free(name);
	return NULL;
      }
      /* get next UTF8 char */
      if ((c = *fname++) < 0x80) x = c;
      else {
	if ((c >= 0xC0) && (c < 0xE0)) {
	  x = (c & 0x1F) << 6;
	  x |= *fname++ & 0x3F;
	}
	else if ((c >= 0xE0) && (c < 0xF0)) {
	  x = (c & 0xF) << 12;
	  x |= (*fname++ & 0x3F) << 6;
	  x |= *fname++ & 0x3F;
	}
	else x = '?';
      }
      /* whatever is the path seperator -> '/'
       * whatever is the other slash    -> '\\'
       * otherwise, if lower is set, the lowercase version */
      if      (x == sep)   x = '/';
      else if (x == slash) x = '\\';
      else if (lower)      x = (unsigned int) tolower((int) x);
      /* integer back to UTF8 */
      if (x < 0x80) {
	*p++ = (unsigned char) x;
      }
      else if (x < 0x800) {
	*p++ = 0xC0 | (x >> 6);   
	*p++ = 0x80 | (x & 0x3F);
      }
      else {
	*p++ = 0xE0 | (x >> 12);
	*p++ = 0x80 | ((x >> 6) & 0x3F);
	*p++ = 0x80 | (x & 0x3F);
      }
    } while (x);
  }
  else {
    /* regular non-utf8 version */
    do {
      c = *fname++;
      if      (c == sep)   c = '/';
      else if (c == slash) c = '\\';
      else if (lower)      c = (unsigned char) tolower((int) c);
    } while ((*p++ = c));
  }
  return (char *) name;
 }
",C,"char *create_output_name(char *fname) {
    char *out, *p;
    if ((out = malloc(strlen(fname) + 1))) {
        /* remove leading slashes */
        while (*fname == '/' || *fname == '\\') fname++;
        /* if that removes all characters, just call it ""x"" */
        strcpy(out, (*fname) ? fname : ""x"");

        /* change ""../"" to ""xx/"" */
        for (p = out; *p; p++) {
            if (p[0] == '.' && p[1] == '.' && (p[2] == '/' || p[2] == '\\')) {
               p[0] = p[1] = 'x';
            }
        }
    }
    return out;
","			 int lower, int isunix, int utf8)
{
  unsigned char *p, *name, c, *fe, sep, slash;
  unsigned int x;
  sep   = (isunix) ? '/'  : '\\'; /* the path-seperator */
  slash = (isunix) ? '\\' : '/';  /* the other slash */
  /* length of filename */
  x = strlen((char *) fname);
  /* UTF8 worst case scenario: tolower() expands all chars from 1 to 3 bytes */
  if (utf8) x *= 3;
  /* length of output directory */
  if (dir) x += strlen((char *) dir);
  if (!(name = (unsigned char *) malloc(x + 2))) {
    fprintf(stderr, ""out of memory!\n"");
    return NULL;
  }
  /* start with blank name */
  *name = '\0';
  /* add output directory if needed */
  if (dir) {
    strcpy((char *) name, (char *) dir);
    strcat((char *) name, ""/"");
  }
  /* remove leading slashes */
  while (*fname == sep) fname++;
  /* copy from fi->filename to new name, converting MS-DOS slashes to UNIX
   * slashes as we go. Also lowercases characters if needed.
   */
  p = &name[strlen((char *)name)];
  fe = &fname[strlen((char *)fname)];
  if (utf8) {
    /* UTF8 translates two-byte unicode characters into 1, 2 or 3 bytes.
     * %000000000xxxxxxx -> %0xxxxxxx
     * %00000xxxxxyyyyyy -> %110xxxxx %10yyyyyy
     * %xxxxyyyyyyzzzzzz -> %1110xxxx %10yyyyyy %10zzzzzz
     *
     * Therefore, the inverse is as follows:
     * First char:
     *  0x00 - 0x7F = one byte char
     *  0x80 - 0xBF = invalid
     *  0xC0 - 0xDF = 2 byte char (next char only 0x80-0xBF is valid)
     *  0xE0 - 0xEF = 3 byte char (next 2 chars only 0x80-0xBF is valid)
     *  0xF0 - 0xFF = invalid
     */
    do {
      if (fname >= fe) {
	free(name);
	return NULL;
      }
      /* get next UTF8 char */
      if ((c = *fname++) < 0x80) x = c;
      else {
	if ((c >= 0xC0) && (c < 0xE0)) {
	  x = (c & 0x1F) << 6;
	  x |= *fname++ & 0x3F;
	}
	else if ((c >= 0xE0) && (c < 0xF0)) {
	  x = (c & 0xF) << 12;
	  x |= (*fname++ & 0x3F) << 6;
	  x |= *fname++ & 0x3F;
	}
	else x = '?';
      }
      /* whatever is the path seperator -> '/'
       * whatever is the other slash    -> '\\'
       * otherwise, if lower is set, the lowercase version */
      if      (x == sep)   x = '/';
      else if (x == slash) x = '\\';
      else if (lower)      x = (unsigned int) tolower((int) x);
      /* integer back to UTF8 */
      if (x < 0x80) {
	*p++ = (unsigned char) x;
      }
      else if (x < 0x800) {
	*p++ = 0xC0 | (x >> 6);   
	*p++ = 0x80 | (x & 0x3F);
      }
      else {
	*p++ = 0xE0 | (x >> 12);
	*p++ = 0x80 | ((x >> 6) & 0x3F);
	*p++ = 0x80 | (x & 0x3F);
      }
    } while (x);
  }
  else {
    /* regular non-utf8 version */
    do {
      c = *fname++;
      if      (c == sep)   c = '/';
      else if (c == slash) c = '\\';
      else if (lower)      c = (unsigned char) tolower((int) c);
    } while ((*p++ = c));
  }
  return (char *) name;
",,"@@ -25,8 +25,6 @@
 
 mode_t user_umask;
 
-#define FILENAME "".test.chmx""
-
 /**
  * Ensures that all directory components in a filepath exist. New directory
  * components are created, if necessary.
@@ -51,126 +49,22 @@ static int ensure_filepath(char *path) {
   return 1;
 }
 
-/**
- * Creates a UNIX filename from the internal CAB filename and the given
- * parameters.
- *
- * @param fname  the internal CAB filename.
- * @param dir    a directory path to prepend to the output filename.
- * @param lower  if non-zero, filename should be made lower-case.
- * @param isunix if zero, MS-DOS path seperators are used in the internal
- *               CAB filename. If non-zero, UNIX path seperators are used.
- * @param utf8   if non-zero, the internal CAB filename is encoded in UTF8.
- * @return a freshly allocated and created filename, or NULL if there was
- *         not enough memory.
- * @see unix_path_seperators()
- */
-static char *create_output_name(unsigned char *fname, unsigned char *dir,
-			 int lower, int isunix, int utf8)
-{
-  unsigned char *p, *name, c, *fe, sep, slash;
-  unsigned int x;
-
-  sep   = (isunix) ? '/'  : '\\'; /* the path-seperator */
-  slash = (isunix) ? '\\' : '/';  /* the other slash */
-
-  /* length of filename */
-  x = strlen((char *) fname);
-  /* UTF8 worst case scenario: tolower() expands all chars from 1 to 3 bytes */
-  if (utf8) x *= 3;
-  /* length of output directory */
-  if (dir) x += strlen((char *) dir);
-
-  if (!(name = (unsigned char *) malloc(x + 2))) {
-    fprintf(stderr, ""out of memory!\n"");
-    return NULL;
-  }
-  
-  /* start with blank name */
-  *name = '\0';
-
-  /* add output directory if needed */
-  if (dir) {
-    strcpy((char *) name, (char *) dir);
-    strcat((char *) name, ""/"");
-  }
-
-  /* remove leading slashes */
-  while (*fname == sep) fname++;
-
-  /* copy from fi->filename to new name, converting MS-DOS slashes to UNIX
-   * slashes as we go. Also lowercases characters if needed.
-   */
-  p = &name[strlen((char *)name)];
-  fe = &fname[strlen((char *)fname)];
-
-  if (utf8) {
-    /* UTF8 translates two-byte unicode characters into 1, 2 or 3 bytes.
-     * %000000000xxxxxxx -> %0xxxxxxx
-     * %00000xxxxxyyyyyy -> %110xxxxx %10yyyyyy
-     * %xxxxyyyyyyzzzzzz -> %1110xxxx %10yyyyyy %10zzzzzz
-     *
-     * Therefore, the inverse is as follows:
-     * First char:
-     *  0x00 - 0x7F = one byte char
-     *  0x80 - 0xBF = invalid
-     *  0xC0 - 0xDF = 2 byte char (next char only 0x80-0xBF is valid)
-     *  0xE0 - 0xEF = 3 byte char (next 2 chars only 0x80-0xBF is valid)
-     *  0xF0 - 0xFF = invalid
-     */
-    do {
-      if (fname >= fe) {
-	free(name);
-	return NULL;
-      }
-
-      /* get next UTF8 char */
-      if ((c = *fname++) < 0x80) x = c;
-      else {
-	if ((c >= 0xC0) && (c < 0xE0)) {
-	  x = (c & 0x1F) << 6;
-	  x |= *fname++ & 0x3F;
-	}
-	else if ((c >= 0xE0) && (c < 0xF0)) {
-	  x = (c & 0xF) << 12;
-	  x |= (*fname++ & 0x3F) << 6;
-	  x |= *fname++ & 0x3F;
-	}
-	else x = '?';
-      }
-
-      /* whatever is the path seperator -> '/'
-       * whatever is the other slash    -> '\\'
-       * otherwise, if lower is set, the lowercase version */
-      if      (x == sep)   x = '/';
-      else if (x == slash) x = '\\';
-      else if (lower)      x = (unsigned int) tolower((int) x);
-
-      /* integer back to UTF8 */
-      if (x < 0x80) {
-	*p++ = (unsigned char) x;
-      }
-      else if (x < 0x800) {
-	*p++ = 0xC0 | (x >> 6);   
-	*p++ = 0x80 | (x & 0x3F);
-      }
-      else {
-	*p++ = 0xE0 | (x >> 12);
-	*p++ = 0x80 | ((x >> 6) & 0x3F);
-	*p++ = 0x80 | (x & 0x3F);
-      }
-    } while (x);
-  }
-  else {
-    /* regular non-utf8 version */
-    do {
-      c = *fname++;
-      if      (c == sep)   c = '/';
-      else if (c == slash) c = '\\';
-      else if (lower)      c = (unsigned char) tolower((int) c);
-    } while ((*p++ = c));
-  }
-  return (char *) name;
+char *create_output_name(char *fname) {
+    char *out, *p;
+    if ((out = malloc(strlen(fname) + 1))) {
+        /* remove leading slashes */
+        while (*fname == '/' || *fname == '\\') fname++;
+        /* if that removes all characters, just call it ""x"" */
+        strcpy(out, (*fname) ? fname : ""x"");
+
+        /* change ""../"" to ""xx/"" */
+        for (p = out; *p; p++) {
+            if (p[0] == '.' && p[1] == '.' && (p[2] == '/' || p[2] == '\\')) {
+               p[0] = p[1] = 'x';
+            }
+        }
+    }
+    return out;
 }
 
 static int sortfunc(const void *a, const void *b) {
@@ -205,7 +99,7 @@ int main(int argc, char *argv[]) {
 	  qsort(f, numf, sizeof(struct mschmd_file *), &sortfunc);
 
 	  for (i = 0; i < numf; i++) {
-	    char *outname = create_output_name((unsigned char *)f[i]->filename,NULL,0,1,0);
+	    char *outname = create_output_name(f[i]->filename);
 	    printf(""Extracting %s\n"", outname);
 	    ensure_filepath(outname);
 	    if (chmd->extract(chmd, f[i], outname)) {",libmspack,7cadd489698be117c47efcadd742651594429e6d,3a53aa72950f5c40a3182c0ee8f22d38af35d988,1,"static char *create_output_name(unsigned char *fname, unsigned char *dir,
//flaw_line_below:
			 int lower, int isunix, int utf8)
//flaw_line_below:
{
//flaw_line_below:
  unsigned char *p, *name, c, *fe, sep, slash;
//flaw_line_below:
  unsigned int x;
//flaw_line_below:

//flaw_line_below:
  sep   = (isunix) ? '/'  : '\\'; /* the path-seperator */
//flaw_line_below:
  slash = (isunix) ? '\\' : '/';  /* the other slash */
//flaw_line_below:

//flaw_line_below:
  /* length of filename */
//flaw_line_below:
  x = strlen((char *) fname);
//flaw_line_below:
  /* UTF8 worst case scenario: tolower() expands all chars from 1 to 3 bytes */
//flaw_line_below:
  if (utf8) x *= 3;
//flaw_line_below:
  /* length of output directory */
//flaw_line_below:
  if (dir) x += strlen((char *) dir);
//flaw_line_below:

//flaw_line_below:
  if (!(name = (unsigned char *) malloc(x + 2))) {
//flaw_line_below:
    fprintf(stderr, ""out of memory!\n"");
//flaw_line_below:
    return NULL;
//flaw_line_below:
  }
//flaw_line_below:
  
//flaw_line_below:
  /* start with blank name */
//flaw_line_below:
  *name = '\0';
//flaw_line_below:

//flaw_line_below:
  /* add output directory if needed */
//flaw_line_below:
  if (dir) {
//flaw_line_below:
    strcpy((char *) name, (char *) dir);
//flaw_line_below:
    strcat((char *) name, ""/"");
//flaw_line_below:
  }
//flaw_line_below:

//flaw_line_below:
  /* remove leading slashes */
//flaw_line_below:
  while (*fname == sep) fname++;
//flaw_line_below:

//flaw_line_below:
  /* copy from fi->filename to new name, converting MS-DOS slashes to UNIX
//flaw_line_below:
   * slashes as we go. Also lowercases characters if needed.
//flaw_line_below:
   */
//flaw_line_below:
  p = &name[strlen((char *)name)];
//flaw_line_below:
  fe = &fname[strlen((char *)fname)];
//flaw_line_below:

//flaw_line_below:
  if (utf8) {
//flaw_line_below:
    /* UTF8 translates two-byte unicode characters into 1, 2 or 3 bytes.
//flaw_line_below:
     * %000000000xxxxxxx -> %0xxxxxxx
//flaw_line_below:
     * %00000xxxxxyyyyyy -> %110xxxxx %10yyyyyy
//flaw_line_below:
     * %xxxxyyyyyyzzzzzz -> %1110xxxx %10yyyyyy %10zzzzzz
//flaw_line_below:
     *
//flaw_line_below:
     * Therefore, the inverse is as follows:
//flaw_line_below:
     * First char:
//flaw_line_below:
     *  0x00 - 0x7F = one byte char
//flaw_line_below:
     *  0x80 - 0xBF = invalid
//flaw_line_below:
     *  0xC0 - 0xDF = 2 byte char (next char only 0x80-0xBF is valid)
//flaw_line_below:
     *  0xE0 - 0xEF = 3 byte char (next 2 chars only 0x80-0xBF is valid)
//flaw_line_below:
     *  0xF0 - 0xFF = invalid
//flaw_line_below:
     */
//flaw_line_below:
    do {
//flaw_line_below:
      if (fname >= fe) {
//flaw_line_below:
	free(name);
//flaw_line_below:
	return NULL;
//flaw_line_below:
      }
//flaw_line_below:

//flaw_line_below:
      /* get next UTF8 char */
//flaw_line_below:
      if ((c = *fname++) < 0x80) x = c;
//flaw_line_below:
      else {
//flaw_line_below:
	if ((c >= 0xC0) && (c < 0xE0)) {
//flaw_line_below:
	  x = (c & 0x1F) << 6;
//flaw_line_below:
	  x |= *fname++ & 0x3F;
//flaw_line_below:
	}
//flaw_line_below:
	else if ((c >= 0xE0) && (c < 0xF0)) {
//flaw_line_below:
	  x = (c & 0xF) << 12;
//flaw_line_below:
	  x |= (*fname++ & 0x3F) << 6;
//flaw_line_below:
	  x |= *fname++ & 0x3F;
//flaw_line_below:
	}
//flaw_line_below:
	else x = '?';
//flaw_line_below:
      }
//flaw_line_below:

//flaw_line_below:
      /* whatever is the path seperator -> '/'
//flaw_line_below:
       * whatever is the other slash    -> '\\'
//flaw_line_below:
       * otherwise, if lower is set, the lowercase version */
//flaw_line_below:
      if      (x == sep)   x = '/';
//flaw_line_below:
      else if (x == slash) x = '\\';
//flaw_line_below:
      else if (lower)      x = (unsigned int) tolower((int) x);
//flaw_line_below:

//flaw_line_below:
      /* integer back to UTF8 */
//flaw_line_below:
      if (x < 0x80) {
//flaw_line_below:
	*p++ = (unsigned char) x;
//flaw_line_below:
      }
//flaw_line_below:
      else if (x < 0x800) {
//flaw_line_below:
	*p++ = 0xC0 | (x >> 6);   
//flaw_line_below:
	*p++ = 0x80 | (x & 0x3F);
//flaw_line_below:
      }
//flaw_line_below:
      else {
//flaw_line_below:
	*p++ = 0xE0 | (x >> 12);
//flaw_line_below:
	*p++ = 0x80 | ((x >> 6) & 0x3F);
//flaw_line_below:
	*p++ = 0x80 | (x & 0x3F);
//flaw_line_below:
      }
//flaw_line_below:
    } while (x);
//flaw_line_below:
  }
//flaw_line_below:
  else {
//flaw_line_below:
    /* regular non-utf8 version */
//flaw_line_below:
    do {
//flaw_line_below:
      c = *fname++;
//flaw_line_below:
      if      (c == sep)   c = '/';
//flaw_line_below:
      else if (c == slash) c = '\\';
//flaw_line_below:
      else if (lower)      c = (unsigned char) tolower((int) c);
//flaw_line_below:
    } while ((*p++ = c));
//flaw_line_below:
  }
//flaw_line_below:
  return (char *) name;
//fix_flaw_line_below:
//char *create_output_name(char *fname) {
//fix_flaw_line_below:
//    char *out, *p;
//fix_flaw_line_below:
//    if ((out = malloc(strlen(fname) + 1))) {
//fix_flaw_line_below:
//        /* remove leading slashes */
//fix_flaw_line_below:
//        while (*fname == '/' || *fname == '\\') fname++;
//fix_flaw_line_below:
//        /* if that removes all characters, just call it ""x"" */
//fix_flaw_line_below:
//        strcpy(out, (*fname) ? fname : ""x"");
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        /* change ""../"" to ""xx/"" */
//fix_flaw_line_below:
//        for (p = out; *p; p++) {
//fix_flaw_line_below:
//            if (p[0] == '.' && p[1] == '.' && (p[2] == '/' || p[2] == '\\')) {
//fix_flaw_line_below:
//               p[0] = p[1] = 'x';
//fix_flaw_line_below:
//            }
//fix_flaw_line_below:
//        }
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//    return out;
 }
"
4438,182174,,Remote,Not required,,CVE-2018-18586,https://www.cvedetails.com/cve/CVE-2018-18586/,CWE-22,Low,Partial,,,2018-10-22,5.0,"** DISPUTED ** chmextract.c in the chmextract sample program, as distributed with libmspack before 0.8alpha, does not protect against absolute/relative pathnames in CHM files, leading to Directory Traversal. NOTE: the vendor disputes that this is a libmspack vulnerability, because chmextract.c was only intended as a source-code example, not a supported application.",2019-04-03,Dir. Trav. ,1,https://github.com/kyz/libmspack/commit/7cadd489698be117c47efcadd742651594429e6d,7cadd489698be117c47efcadd742651594429e6d,"add anti ""../"" and leading slash protection to chmextract",1,libmspack/src/chmextract.c,"{""sha"": ""325c160d25e254d902dac15fedfdc897d6bdd60d"", ""filename"": ""libmspack/ChangeLog"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 0, ""changes"": 10, ""blob_url"": ""https://github.com/kyz/libmspack/blob/7cadd489698be117c47efcadd742651594429e6d/libmspack/ChangeLog"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/7cadd489698be117c47efcadd742651594429e6d/libmspack/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/ChangeLog?ref=7cadd489698be117c47efcadd742651594429e6d"", ""patch"": ""@@ -1,3 +1,13 @@\n+2018-10-20  Stuart Caie <kyzer@cabextract.org.uk>\n+\n+\t* src/chmextract.c: add anti \""../\"" and leading slash protection to\n+\tchmextract. I'm not pleased about this. All the sample code provided\n+\twith libmspack is meant to be simple examples of library use, not\n+\t\""productised\"" binaries. Making the \""useful\"" code samples install\n+\tas binaries was a mistake. They were never intended to protect you\n+\tfrom unpacking archive files with relative/absolute paths, and I\n+\twould prefer that they never will be.\n+\n 2018-10-17  Stuart Caie <kyzer@cabextract.org.uk>\n \n \t* cab.h: Make the CAB block input buffer one byte larger, to allow""}<_**next**_>{""sha"": ""b535f0eef7727052df7b7cf5b1650a2d9cf837a8"", ""filename"": ""libmspack/src/chmextract.c"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 123, ""changes"": 140, ""blob_url"": ""https://github.com/kyz/libmspack/blob/7cadd489698be117c47efcadd742651594429e6d/libmspack/src/chmextract.c"", ""raw_url"": ""https://github.com/kyz/libmspack/raw/7cadd489698be117c47efcadd742651594429e6d/libmspack/src/chmextract.c"", ""contents_url"": ""https://api.github.com/repos/kyz/libmspack/contents/libmspack/src/chmextract.c?ref=7cadd489698be117c47efcadd742651594429e6d"", ""patch"": ""@@ -25,8 +25,6 @@\n \n mode_t user_umask;\n \n-#define FILENAME \"".test.chmx\""\n-\n /**\n  * Ensures that all directory components in a filepath exist. New directory\n  * components are created, if necessary.\n@@ -51,126 +49,22 @@ static int ensure_filepath(char *path) {\n   return 1;\n }\n \n-/**\n- * Creates a UNIX filename from the internal CAB filename and the given\n- * parameters.\n- *\n- * @param fname  the internal CAB filename.\n- * @param dir    a directory path to prepend to the output filename.\n- * @param lower  if non-zero, filename should be made lower-case.\n- * @param isunix if zero, MS-DOS path seperators are used in the internal\n- *               CAB filename. If non-zero, UNIX path seperators are used.\n- * @param utf8   if non-zero, the internal CAB filename is encoded in UTF8.\n- * @return a freshly allocated and created filename, or NULL if there was\n- *         not enough memory.\n- * @see unix_path_seperators()\n- */\n-static char *create_output_name(unsigned char *fname, unsigned char *dir,\n-\t\t\t int lower, int isunix, int utf8)\n-{\n-  unsigned char *p, *name, c, *fe, sep, slash;\n-  unsigned int x;\n-\n-  sep   = (isunix) ? '/'  : '\\\\'; /* the path-seperator */\n-  slash = (isunix) ? '\\\\' : '/';  /* the other slash */\n-\n-  /* length of filename */\n-  x = strlen((char *) fname);\n-  /* UTF8 worst case scenario: tolower() expands all chars from 1 to 3 bytes */\n-  if (utf8) x *= 3;\n-  /* length of output directory */\n-  if (dir) x += strlen((char *) dir);\n-\n-  if (!(name = (unsigned char *) malloc(x + 2))) {\n-    fprintf(stderr, \""out of memory!\\n\"");\n-    return NULL;\n-  }\n-  \n-  /* start with blank name */\n-  *name = '\\0';\n-\n-  /* add output directory if needed */\n-  if (dir) {\n-    strcpy((char *) name, (char *) dir);\n-    strcat((char *) name, \""/\"");\n-  }\n-\n-  /* remove leading slashes */\n-  while (*fname == sep) fname++;\n-\n-  /* copy from fi->filename to new name, converting MS-DOS slashes to UNIX\n-   * slashes as we go. Also lowercases characters if needed.\n-   */\n-  p = &name[strlen((char *)name)];\n-  fe = &fname[strlen((char *)fname)];\n-\n-  if (utf8) {\n-    /* UTF8 translates two-byte unicode characters into 1, 2 or 3 bytes.\n-     * %000000000xxxxxxx -> %0xxxxxxx\n-     * %00000xxxxxyyyyyy -> %110xxxxx %10yyyyyy\n-     * %xxxxyyyyyyzzzzzz -> %1110xxxx %10yyyyyy %10zzzzzz\n-     *\n-     * Therefore, the inverse is as follows:\n-     * First char:\n-     *  0x00 - 0x7F = one byte char\n-     *  0x80 - 0xBF = invalid\n-     *  0xC0 - 0xDF = 2 byte char (next char only 0x80-0xBF is valid)\n-     *  0xE0 - 0xEF = 3 byte char (next 2 chars only 0x80-0xBF is valid)\n-     *  0xF0 - 0xFF = invalid\n-     */\n-    do {\n-      if (fname >= fe) {\n-\tfree(name);\n-\treturn NULL;\n-      }\n-\n-      /* get next UTF8 char */\n-      if ((c = *fname++) < 0x80) x = c;\n-      else {\n-\tif ((c >= 0xC0) && (c < 0xE0)) {\n-\t  x = (c & 0x1F) << 6;\n-\t  x |= *fname++ & 0x3F;\n-\t}\n-\telse if ((c >= 0xE0) && (c < 0xF0)) {\n-\t  x = (c & 0xF) << 12;\n-\t  x |= (*fname++ & 0x3F) << 6;\n-\t  x |= *fname++ & 0x3F;\n-\t}\n-\telse x = '?';\n-      }\n-\n-      /* whatever is the path seperator -> '/'\n-       * whatever is the other slash    -> '\\\\'\n-       * otherwise, if lower is set, the lowercase version */\n-      if      (x == sep)   x = '/';\n-      else if (x == slash) x = '\\\\';\n-      else if (lower)      x = (unsigned int) tolower((int) x);\n-\n-      /* integer back to UTF8 */\n-      if (x < 0x80) {\n-\t*p++ = (unsigned char) x;\n-      }\n-      else if (x < 0x800) {\n-\t*p++ = 0xC0 | (x >> 6);   \n-\t*p++ = 0x80 | (x & 0x3F);\n-      }\n-      else {\n-\t*p++ = 0xE0 | (x >> 12);\n-\t*p++ = 0x80 | ((x >> 6) & 0x3F);\n-\t*p++ = 0x80 | (x & 0x3F);\n-      }\n-    } while (x);\n-  }\n-  else {\n-    /* regular non-utf8 version */\n-    do {\n-      c = *fname++;\n-      if      (c == sep)   c = '/';\n-      else if (c == slash) c = '\\\\';\n-      else if (lower)      c = (unsigned char) tolower((int) c);\n-    } while ((*p++ = c));\n-  }\n-  return (char *) name;\n+char *create_output_name(char *fname) {\n+    char *out, *p;\n+    if ((out = malloc(strlen(fname) + 1))) {\n+        /* remove leading slashes */\n+        while (*fname == '/' || *fname == '\\\\') fname++;\n+        /* if that removes all characters, just call it \""x\"" */\n+        strcpy(out, (*fname) ? fname : \""x\"");\n+\n+        /* change \""../\"" to \""xx/\"" */\n+        for (p = out; *p; p++) {\n+            if (p[0] == '.' && p[1] == '.' && (p[2] == '/' || p[2] == '\\\\')) {\n+               p[0] = p[1] = 'x';\n+            }\n+        }\n+    }\n+    return out;\n }\n \n static int sortfunc(const void *a, const void *b) {\n@@ -205,7 +99,7 @@ int main(int argc, char *argv[]) {\n \t  qsort(f, numf, sizeof(struct mschmd_file *), &sortfunc);\n \n \t  for (i = 0; i < numf; i++) {\n-\t    char *outname = create_output_name((unsigned char *)f[i]->filename,NULL,0,1,0);\n+\t    char *outname = create_output_name(f[i]->filename);\n \t    printf(\""Extracting %s\\n\"", outname);\n \t    ensure_filepath(outname);\n \t    if (chmd->extract(chmd, f[i], outname)) {""}","int main(int argc, char *argv[]) {
  struct mschm_decompressor *chmd;
  struct mschmd_header *chm;
  struct mschmd_file *file, **f;
  unsigned int numf, i;

  setbuf(stdout, NULL);
  setbuf(stderr, NULL);
  user_umask = umask(0); umask(user_umask);

  MSPACK_SYS_SELFTEST(i);
  if (i) return 0;

  if ((chmd = mspack_create_chm_decompressor(NULL))) {
    for (argv++; *argv; argv++) {
      printf(""%s\n"", *argv);
      if ((chm = chmd->open(chmd, *argv))) {

	/* build an ordered list of files for maximum extraction speed */
	for (numf=0, file=chm->files; file; file = file->next) numf++;
	if ((f = (struct mschmd_file **) calloc(numf, sizeof(struct mschmd_file *)))) {
	  for (i=0, file=chm->files; file; file = file->next) f[i++] = file;
 	  qsort(f, numf, sizeof(struct mschmd_file *), &sortfunc);
 
 	  for (i = 0; i < numf; i++) {
	    char *outname = create_output_name(f[i]->filename);
 	    printf(""Extracting %s\n"", outname);
 	    ensure_filepath(outname);
 	    if (chmd->extract(chmd, f[i], outname)) {
	      printf(""%s: extract error on \""%s\"": %s\n"",
		     *argv, f[i]->filename, ERROR(chmd));
	    }
	    free(outname);
	  }
	  free(f);
	}
	chmd->close(chmd, chm);
      }
      else {
	printf(""%s: can't open -- %s\n"", *argv, ERROR(chmd));
      }
    }
    mspack_destroy_chm_decompressor(chmd);
  }
  return 0;
}
","int main(int argc, char *argv[]) {
  struct mschm_decompressor *chmd;
  struct mschmd_header *chm;
  struct mschmd_file *file, **f;
  unsigned int numf, i;

  setbuf(stdout, NULL);
  setbuf(stderr, NULL);
  user_umask = umask(0); umask(user_umask);

  MSPACK_SYS_SELFTEST(i);
  if (i) return 0;

  if ((chmd = mspack_create_chm_decompressor(NULL))) {
    for (argv++; *argv; argv++) {
      printf(""%s\n"", *argv);
      if ((chm = chmd->open(chmd, *argv))) {

	/* build an ordered list of files for maximum extraction speed */
	for (numf=0, file=chm->files; file; file = file->next) numf++;
	if ((f = (struct mschmd_file **) calloc(numf, sizeof(struct mschmd_file *)))) {
	  for (i=0, file=chm->files; file; file = file->next) f[i++] = file;
 	  qsort(f, numf, sizeof(struct mschmd_file *), &sortfunc);
 
 	  for (i = 0; i < numf; i++) {
	    char *outname = create_output_name((unsigned char *)f[i]->filename,NULL,0,1,0);
 	    printf(""Extracting %s\n"", outname);
 	    ensure_filepath(outname);
 	    if (chmd->extract(chmd, f[i], outname)) {
	      printf(""%s: extract error on \""%s\"": %s\n"",
		     *argv, f[i]->filename, ERROR(chmd));
	    }
	    free(outname);
	  }
	  free(f);
	}
	chmd->close(chmd, chm);
      }
      else {
	printf(""%s: can't open -- %s\n"", *argv, ERROR(chmd));
      }
    }
    mspack_destroy_chm_decompressor(chmd);
  }
  return 0;
}
",C,"	    char *outname = create_output_name(f[i]->filename);
","	    char *outname = create_output_name((unsigned char *)f[i]->filename,NULL,0,1,0);
",,"@@ -25,8 +25,6 @@
 
 mode_t user_umask;
 
-#define FILENAME "".test.chmx""
-
 /**
  * Ensures that all directory components in a filepath exist. New directory
  * components are created, if necessary.
@@ -51,126 +49,22 @@ static int ensure_filepath(char *path) {
   return 1;
 }
 
-/**
- * Creates a UNIX filename from the internal CAB filename and the given
- * parameters.
- *
- * @param fname  the internal CAB filename.
- * @param dir    a directory path to prepend to the output filename.
- * @param lower  if non-zero, filename should be made lower-case.
- * @param isunix if zero, MS-DOS path seperators are used in the internal
- *               CAB filename. If non-zero, UNIX path seperators are used.
- * @param utf8   if non-zero, the internal CAB filename is encoded in UTF8.
- * @return a freshly allocated and created filename, or NULL if there was
- *         not enough memory.
- * @see unix_path_seperators()
- */
-static char *create_output_name(unsigned char *fname, unsigned char *dir,
-			 int lower, int isunix, int utf8)
-{
-  unsigned char *p, *name, c, *fe, sep, slash;
-  unsigned int x;
-
-  sep   = (isunix) ? '/'  : '\\'; /* the path-seperator */
-  slash = (isunix) ? '\\' : '/';  /* the other slash */
-
-  /* length of filename */
-  x = strlen((char *) fname);
-  /* UTF8 worst case scenario: tolower() expands all chars from 1 to 3 bytes */
-  if (utf8) x *= 3;
-  /* length of output directory */
-  if (dir) x += strlen((char *) dir);
-
-  if (!(name = (unsigned char *) malloc(x + 2))) {
-    fprintf(stderr, ""out of memory!\n"");
-    return NULL;
-  }
-  
-  /* start with blank name */
-  *name = '\0';
-
-  /* add output directory if needed */
-  if (dir) {
-    strcpy((char *) name, (char *) dir);
-    strcat((char *) name, ""/"");
-  }
-
-  /* remove leading slashes */
-  while (*fname == sep) fname++;
-
-  /* copy from fi->filename to new name, converting MS-DOS slashes to UNIX
-   * slashes as we go. Also lowercases characters if needed.
-   */
-  p = &name[strlen((char *)name)];
-  fe = &fname[strlen((char *)fname)];
-
-  if (utf8) {
-    /* UTF8 translates two-byte unicode characters into 1, 2 or 3 bytes.
-     * %000000000xxxxxxx -> %0xxxxxxx
-     * %00000xxxxxyyyyyy -> %110xxxxx %10yyyyyy
-     * %xxxxyyyyyyzzzzzz -> %1110xxxx %10yyyyyy %10zzzzzz
-     *
-     * Therefore, the inverse is as follows:
-     * First char:
-     *  0x00 - 0x7F = one byte char
-     *  0x80 - 0xBF = invalid
-     *  0xC0 - 0xDF = 2 byte char (next char only 0x80-0xBF is valid)
-     *  0xE0 - 0xEF = 3 byte char (next 2 chars only 0x80-0xBF is valid)
-     *  0xF0 - 0xFF = invalid
-     */
-    do {
-      if (fname >= fe) {
-	free(name);
-	return NULL;
-      }
-
-      /* get next UTF8 char */
-      if ((c = *fname++) < 0x80) x = c;
-      else {
-	if ((c >= 0xC0) && (c < 0xE0)) {
-	  x = (c & 0x1F) << 6;
-	  x |= *fname++ & 0x3F;
-	}
-	else if ((c >= 0xE0) && (c < 0xF0)) {
-	  x = (c & 0xF) << 12;
-	  x |= (*fname++ & 0x3F) << 6;
-	  x |= *fname++ & 0x3F;
-	}
-	else x = '?';
-      }
-
-      /* whatever is the path seperator -> '/'
-       * whatever is the other slash    -> '\\'
-       * otherwise, if lower is set, the lowercase version */
-      if      (x == sep)   x = '/';
-      else if (x == slash) x = '\\';
-      else if (lower)      x = (unsigned int) tolower((int) x);
-
-      /* integer back to UTF8 */
-      if (x < 0x80) {
-	*p++ = (unsigned char) x;
-      }
-      else if (x < 0x800) {
-	*p++ = 0xC0 | (x >> 6);   
-	*p++ = 0x80 | (x & 0x3F);
-      }
-      else {
-	*p++ = 0xE0 | (x >> 12);
-	*p++ = 0x80 | ((x >> 6) & 0x3F);
-	*p++ = 0x80 | (x & 0x3F);
-      }
-    } while (x);
-  }
-  else {
-    /* regular non-utf8 version */
-    do {
-      c = *fname++;
-      if      (c == sep)   c = '/';
-      else if (c == slash) c = '\\';
-      else if (lower)      c = (unsigned char) tolower((int) c);
-    } while ((*p++ = c));
-  }
-  return (char *) name;
+char *create_output_name(char *fname) {
+    char *out, *p;
+    if ((out = malloc(strlen(fname) + 1))) {
+        /* remove leading slashes */
+        while (*fname == '/' || *fname == '\\') fname++;
+        /* if that removes all characters, just call it ""x"" */
+        strcpy(out, (*fname) ? fname : ""x"");
+
+        /* change ""../"" to ""xx/"" */
+        for (p = out; *p; p++) {
+            if (p[0] == '.' && p[1] == '.' && (p[2] == '/' || p[2] == '\\')) {
+               p[0] = p[1] = 'x';
+            }
+        }
+    }
+    return out;
 }
 
 static int sortfunc(const void *a, const void *b) {
@@ -205,7 +99,7 @@ int main(int argc, char *argv[]) {
 	  qsort(f, numf, sizeof(struct mschmd_file *), &sortfunc);
 
 	  for (i = 0; i < numf; i++) {
-	    char *outname = create_output_name((unsigned char *)f[i]->filename,NULL,0,1,0);
+	    char *outname = create_output_name(f[i]->filename);
 	    printf(""Extracting %s\n"", outname);
 	    ensure_filepath(outname);
 	    if (chmd->extract(chmd, f[i], outname)) {",libmspack,7cadd489698be117c47efcadd742651594429e6d,3a53aa72950f5c40a3182c0ee8f22d38af35d988,1,"int main(int argc, char *argv[]) {
  struct mschm_decompressor *chmd;
  struct mschmd_header *chm;
  struct mschmd_file *file, **f;
  unsigned int numf, i;

  setbuf(stdout, NULL);
  setbuf(stderr, NULL);
  user_umask = umask(0); umask(user_umask);

  MSPACK_SYS_SELFTEST(i);
  if (i) return 0;

  if ((chmd = mspack_create_chm_decompressor(NULL))) {
    for (argv++; *argv; argv++) {
      printf(""%s\n"", *argv);
      if ((chm = chmd->open(chmd, *argv))) {

	/* build an ordered list of files for maximum extraction speed */
	for (numf=0, file=chm->files; file; file = file->next) numf++;
	if ((f = (struct mschmd_file **) calloc(numf, sizeof(struct mschmd_file *)))) {
	  for (i=0, file=chm->files; file; file = file->next) f[i++] = file;
 	  qsort(f, numf, sizeof(struct mschmd_file *), &sortfunc);
 
 	  for (i = 0; i < numf; i++) {
//flaw_line_below:
	    char *outname = create_output_name((unsigned char *)f[i]->filename,NULL,0,1,0);
//fix_flaw_line_below:
//	    char *outname = create_output_name(f[i]->filename);
 	    printf(""Extracting %s\n"", outname);
 	    ensure_filepath(outname);
 	    if (chmd->extract(chmd, f[i], outname)) {
	      printf(""%s: extract error on \""%s\"": %s\n"",
		     *argv, f[i]->filename, ERROR(chmd));
	    }
	    free(outname);
	  }
	  free(f);
	}
	chmd->close(chmd, chm);
      }
      else {
	printf(""%s: can't open -- %s\n"", *argv, ERROR(chmd));
      }
    }
    mspack_destroy_chm_decompressor(chmd);
  }
  return 0;
}
"
4555,182291,,Remote,Not required,,CVE-2018-14363,https://www.cvedetails.com/cve/CVE-2018-14363/,CWE-22,Low,,Partial,,2018-07-17,5.0,An issue was discovered in NeoMutt before 2018-07-16. newsrc.c does not properly restrict '/' characters that may have unsafe interaction with cache pathnames.,2019-10-02,Dir. Trav. ,12,https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e,9bfab35522301794483f8f9ed60820bdec9be59e,"sanitise cache paths

Co-authored-by: JerikoOne <jeriko.one@gmx.us>",1,newsrc.c,"{""sha"": ""c9dfdba23c03a5608841c4a703f0df61b10d89af"", ""filename"": ""newsrc.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 1, ""changes"": 13, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/9bfab35522301794483f8f9ed60820bdec9be59e/newsrc.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/9bfab35522301794483f8f9ed60820bdec9be59e/newsrc.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/newsrc.c?ref=9bfab35522301794483f8f9ed60820bdec9be59e"", ""patch"": ""@@ -715,7 +715,18 @@ int nntp_active_save_cache(struct NntpServer *nserv)\n  */\n static int nntp_hcache_namer(const char *path, char *dest, size_t destlen)\n {\n-  return snprintf(dest, destlen, \""%s.hcache\"", path);\n+  int count = snprintf(dest, destlen, \""%s.hcache\"", path);\n+\n+  /* Strip out any directories in the path */\n+  char *first = strchr(dest, '/');\n+  char *last = strrchr(dest, '/');\n+  if (first && last && (last > first))\n+  {\n+    memmove(first, last, strlen(last) + 1);\n+    count -= (last - first);\n+  }\n+\n+  return count;\n }\n \n /**""}<_**next**_>{""sha"": ""4f3a592a8d562aec7dfe3c80bec8e010cd879c97"", ""filename"": ""pop.c"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 6, ""changes"": 29, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/9bfab35522301794483f8f9ed60820bdec9be59e/pop.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/9bfab35522301794483f8f9ed60820bdec9be59e/pop.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/pop.c?ref=9bfab35522301794483f8f9ed60820bdec9be59e"", ""patch"": ""@@ -63,6 +63,23 @@\n #define HC_FEXT \""hcache\""   /* extension for hcache as POP lacks paths */\n #endif\n \n+/**\n+ * cache_id - Make a message-cache-compatible id\n+ * @param id POP message id\n+ * @retval ptr Sanitised string\n+ *\n+ * The POP message id may contain '/' and other awkward characters.\n+ *\n+ * @note This function returns a pointer to a static buffer.\n+ */\n+static const char *cache_id(const char *id)\n+{\n+  static char clean[SHORT_STRING];\n+  mutt_str_strfcpy(clean, id, sizeof(clean));\n+  mutt_file_sanitize_filename(clean, true);\n+  return clean;\n+}\n+\n /**\n  * fetch_message - write line to file\n  * @param line String to write\n@@ -242,7 +259,7 @@ static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)\n   /* message not found in context -> remove it from cache\n    * return the result of bcache, so we stop upon its first error\n    */\n-  return mutt_bcache_del(bcache, id);\n+  return mutt_bcache_del(bcache, cache_id(id));\n }\n \n #ifdef USE_HCACHE\n@@ -407,7 +424,7 @@ static int pop_fetch_headers(struct Context *ctx)\n        *        - if we don't have a body: new\n        */\n       const bool bcached =\n-          (mutt_bcache_exists(pop_data->bcache, ctx->hdrs[i]->data) == 0);\n+          (mutt_bcache_exists(pop_data->bcache, cache_id(ctx->hdrs[i]->data)) == 0);\n       ctx->hdrs[i]->old = false;\n       ctx->hdrs[i]->read = false;\n       if (hcached)\n@@ -597,7 +614,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno\n   unsigned short bcache = 1;\n \n   /* see if we already have the message in body cache */\n-  msg->fp = mutt_bcache_get(pop_data->bcache, h->data);\n+  msg->fp = mutt_bcache_get(pop_data->bcache, cache_id(h->data));\n   if (msg->fp)\n     return 0;\n \n@@ -644,7 +661,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno\n                        NetInc, h->content->length + h->content->offset - 1);\n \n     /* see if we can put in body cache; use our cache as fallback */\n-    msg->fp = mutt_bcache_put(pop_data->bcache, h->data);\n+    msg->fp = mutt_bcache_put(pop_data->bcache, cache_id(h->data));\n     if (!msg->fp)\n     {\n       /* no */\n@@ -689,7 +706,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno\n    * portion of the headers, those required for the main display.\n    */\n   if (bcache)\n-    mutt_bcache_commit(pop_data->bcache, h->data);\n+    mutt_bcache_commit(pop_data->bcache, cache_id(h->data));\n   else\n   {\n     cache->index = h->index;\n@@ -783,7 +800,7 @@ static int pop_sync_mailbox(struct Context *ctx, int *index_hint)\n         ret = pop_query(pop_data, buf, sizeof(buf));\n         if (ret == 0)\n         {\n-          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);\n+          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));\n #ifdef USE_HCACHE\n           mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n #endif""}"," static int nntp_hcache_namer(const char *path, char *dest, size_t destlen)
 {
  int count = snprintf(dest, destlen, ""%s.hcache"", path);

  /* Strip out any directories in the path */
  char *first = strchr(dest, '/');
  char *last = strrchr(dest, '/');
  if (first && last && (last > first))
  {
    memmove(first, last, strlen(last) + 1);
    count -= (last - first);
  }

  return count;
 }
"," static int nntp_hcache_namer(const char *path, char *dest, size_t destlen)
 {
  return snprintf(dest, destlen, ""%s.hcache"", path);
 }
",C,"  int count = snprintf(dest, destlen, ""%s.hcache"", path);

  /* Strip out any directories in the path */
  char *first = strchr(dest, '/');
  char *last = strrchr(dest, '/');
  if (first && last && (last > first))
  {
    memmove(first, last, strlen(last) + 1);
    count -= (last - first);
  }

  return count;
","  return snprintf(dest, destlen, ""%s.hcache"", path);
",,"@@ -715,7 +715,18 @@ int nntp_active_save_cache(struct NntpServer *nserv)
  */
 static int nntp_hcache_namer(const char *path, char *dest, size_t destlen)
 {
-  return snprintf(dest, destlen, ""%s.hcache"", path);
+  int count = snprintf(dest, destlen, ""%s.hcache"", path);
+
+  /* Strip out any directories in the path */
+  char *first = strchr(dest, '/');
+  char *last = strrchr(dest, '/');
+  if (first && last && (last > first))
+  {
+    memmove(first, last, strlen(last) + 1);
+    count -= (last - first);
+  }
+
+  return count;
 }
 
 /**",neomutt,9bfab35522301794483f8f9ed60820bdec9be59e,98aad9c3f1fb281e35a966d4a9b01b60db402e7a,1," static int nntp_hcache_namer(const char *path, char *dest, size_t destlen)
 {
//flaw_line_below:
  return snprintf(dest, destlen, ""%s.hcache"", path);
//fix_flaw_line_below:
//  int count = snprintf(dest, destlen, ""%s.hcache"", path);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  /* Strip out any directories in the path */
//fix_flaw_line_below:
//  char *first = strchr(dest, '/');
//fix_flaw_line_below:
//  char *last = strrchr(dest, '/');
//fix_flaw_line_below:
//  if (first && last && (last > first))
//fix_flaw_line_below:
//  {
//fix_flaw_line_below:
//    memmove(first, last, strlen(last) + 1);
//fix_flaw_line_below:
//    count -= (last - first);
//fix_flaw_line_below:
//  }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  return count;
 }
"
4556,182292,,Remote,Not required,,CVE-2018-14363,https://www.cvedetails.com/cve/CVE-2018-14363/,CWE-22,Low,,Partial,,2018-07-17,5.0,An issue was discovered in NeoMutt before 2018-07-16. newsrc.c does not properly restrict '/' characters that may have unsafe interaction with cache pathnames.,2019-10-02,Dir. Trav. ,1,https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e,9bfab35522301794483f8f9ed60820bdec9be59e,"sanitise cache paths

Co-authored-by: JerikoOne <jeriko.one@gmx.us>",1,pop.c,"{""sha"": ""c9dfdba23c03a5608841c4a703f0df61b10d89af"", ""filename"": ""newsrc.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 1, ""changes"": 13, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/9bfab35522301794483f8f9ed60820bdec9be59e/newsrc.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/9bfab35522301794483f8f9ed60820bdec9be59e/newsrc.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/newsrc.c?ref=9bfab35522301794483f8f9ed60820bdec9be59e"", ""patch"": ""@@ -715,7 +715,18 @@ int nntp_active_save_cache(struct NntpServer *nserv)\n  */\n static int nntp_hcache_namer(const char *path, char *dest, size_t destlen)\n {\n-  return snprintf(dest, destlen, \""%s.hcache\"", path);\n+  int count = snprintf(dest, destlen, \""%s.hcache\"", path);\n+\n+  /* Strip out any directories in the path */\n+  char *first = strchr(dest, '/');\n+  char *last = strrchr(dest, '/');\n+  if (first && last && (last > first))\n+  {\n+    memmove(first, last, strlen(last) + 1);\n+    count -= (last - first);\n+  }\n+\n+  return count;\n }\n \n /**""}<_**next**_>{""sha"": ""4f3a592a8d562aec7dfe3c80bec8e010cd879c97"", ""filename"": ""pop.c"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 6, ""changes"": 29, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/9bfab35522301794483f8f9ed60820bdec9be59e/pop.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/9bfab35522301794483f8f9ed60820bdec9be59e/pop.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/pop.c?ref=9bfab35522301794483f8f9ed60820bdec9be59e"", ""patch"": ""@@ -63,6 +63,23 @@\n #define HC_FEXT \""hcache\""   /* extension for hcache as POP lacks paths */\n #endif\n \n+/**\n+ * cache_id - Make a message-cache-compatible id\n+ * @param id POP message id\n+ * @retval ptr Sanitised string\n+ *\n+ * The POP message id may contain '/' and other awkward characters.\n+ *\n+ * @note This function returns a pointer to a static buffer.\n+ */\n+static const char *cache_id(const char *id)\n+{\n+  static char clean[SHORT_STRING];\n+  mutt_str_strfcpy(clean, id, sizeof(clean));\n+  mutt_file_sanitize_filename(clean, true);\n+  return clean;\n+}\n+\n /**\n  * fetch_message - write line to file\n  * @param line String to write\n@@ -242,7 +259,7 @@ static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)\n   /* message not found in context -> remove it from cache\n    * return the result of bcache, so we stop upon its first error\n    */\n-  return mutt_bcache_del(bcache, id);\n+  return mutt_bcache_del(bcache, cache_id(id));\n }\n \n #ifdef USE_HCACHE\n@@ -407,7 +424,7 @@ static int pop_fetch_headers(struct Context *ctx)\n        *        - if we don't have a body: new\n        */\n       const bool bcached =\n-          (mutt_bcache_exists(pop_data->bcache, ctx->hdrs[i]->data) == 0);\n+          (mutt_bcache_exists(pop_data->bcache, cache_id(ctx->hdrs[i]->data)) == 0);\n       ctx->hdrs[i]->old = false;\n       ctx->hdrs[i]->read = false;\n       if (hcached)\n@@ -597,7 +614,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno\n   unsigned short bcache = 1;\n \n   /* see if we already have the message in body cache */\n-  msg->fp = mutt_bcache_get(pop_data->bcache, h->data);\n+  msg->fp = mutt_bcache_get(pop_data->bcache, cache_id(h->data));\n   if (msg->fp)\n     return 0;\n \n@@ -644,7 +661,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno\n                        NetInc, h->content->length + h->content->offset - 1);\n \n     /* see if we can put in body cache; use our cache as fallback */\n-    msg->fp = mutt_bcache_put(pop_data->bcache, h->data);\n+    msg->fp = mutt_bcache_put(pop_data->bcache, cache_id(h->data));\n     if (!msg->fp)\n     {\n       /* no */\n@@ -689,7 +706,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno\n    * portion of the headers, those required for the main display.\n    */\n   if (bcache)\n-    mutt_bcache_commit(pop_data->bcache, h->data);\n+    mutt_bcache_commit(pop_data->bcache, cache_id(h->data));\n   else\n   {\n     cache->index = h->index;\n@@ -783,7 +800,7 @@ static int pop_sync_mailbox(struct Context *ctx, int *index_hint)\n         ret = pop_query(pop_data, buf, sizeof(buf));\n         if (ret == 0)\n         {\n-          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);\n+          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));\n #ifdef USE_HCACHE\n           mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n #endif""}","static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)
{
  struct Context *ctx = (struct Context *) data;
  if (!ctx)
    return -1;
  struct PopData *pop_data = (struct PopData *) ctx->data;
  if (!pop_data)
    return -1;

#ifdef USE_HCACHE
  /* keep hcache file if hcache == bcache */
  if (strcmp(HC_FNAME ""."" HC_FEXT, id) == 0)
    return 0;
#endif

  for (int i = 0; i < ctx->msgcount; i++)
  {
    /* if the id we get is known for a header: done (i.e. keep in cache) */
    if (ctx->hdrs[i]->data && (mutt_str_strcmp(ctx->hdrs[i]->data, id) == 0))
      return 0;
  }

   /* message not found in context -> remove it from cache
    * return the result of bcache, so we stop upon its first error
    */
  return mutt_bcache_del(bcache, cache_id(id));
 }
","static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)
{
  struct Context *ctx = (struct Context *) data;
  if (!ctx)
    return -1;
  struct PopData *pop_data = (struct PopData *) ctx->data;
  if (!pop_data)
    return -1;

#ifdef USE_HCACHE
  /* keep hcache file if hcache == bcache */
  if (strcmp(HC_FNAME ""."" HC_FEXT, id) == 0)
    return 0;
#endif

  for (int i = 0; i < ctx->msgcount; i++)
  {
    /* if the id we get is known for a header: done (i.e. keep in cache) */
    if (ctx->hdrs[i]->data && (mutt_str_strcmp(ctx->hdrs[i]->data, id) == 0))
      return 0;
  }

   /* message not found in context -> remove it from cache
    * return the result of bcache, so we stop upon its first error
    */
  return mutt_bcache_del(bcache, id);
 }
",C,"  return mutt_bcache_del(bcache, cache_id(id));
","  return mutt_bcache_del(bcache, id);
",,"@@ -63,6 +63,23 @@
 #define HC_FEXT ""hcache""   /* extension for hcache as POP lacks paths */
 #endif
 
+/**
+ * cache_id - Make a message-cache-compatible id
+ * @param id POP message id
+ * @retval ptr Sanitised string
+ *
+ * The POP message id may contain '/' and other awkward characters.
+ *
+ * @note This function returns a pointer to a static buffer.
+ */
+static const char *cache_id(const char *id)
+{
+  static char clean[SHORT_STRING];
+  mutt_str_strfcpy(clean, id, sizeof(clean));
+  mutt_file_sanitize_filename(clean, true);
+  return clean;
+}
+
 /**
  * fetch_message - write line to file
  * @param line String to write
@@ -242,7 +259,7 @@ static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)
   /* message not found in context -> remove it from cache
    * return the result of bcache, so we stop upon its first error
    */
-  return mutt_bcache_del(bcache, id);
+  return mutt_bcache_del(bcache, cache_id(id));
 }
 
 #ifdef USE_HCACHE
@@ -407,7 +424,7 @@ static int pop_fetch_headers(struct Context *ctx)
        *        - if we don't have a body: new
        */
       const bool bcached =
-          (mutt_bcache_exists(pop_data->bcache, ctx->hdrs[i]->data) == 0);
+          (mutt_bcache_exists(pop_data->bcache, cache_id(ctx->hdrs[i]->data)) == 0);
       ctx->hdrs[i]->old = false;
       ctx->hdrs[i]->read = false;
       if (hcached)
@@ -597,7 +614,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno
   unsigned short bcache = 1;
 
   /* see if we already have the message in body cache */
-  msg->fp = mutt_bcache_get(pop_data->bcache, h->data);
+  msg->fp = mutt_bcache_get(pop_data->bcache, cache_id(h->data));
   if (msg->fp)
     return 0;
 
@@ -644,7 +661,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno
                        NetInc, h->content->length + h->content->offset - 1);
 
     /* see if we can put in body cache; use our cache as fallback */
-    msg->fp = mutt_bcache_put(pop_data->bcache, h->data);
+    msg->fp = mutt_bcache_put(pop_data->bcache, cache_id(h->data));
     if (!msg->fp)
     {
       /* no */
@@ -689,7 +706,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno
    * portion of the headers, those required for the main display.
    */
   if (bcache)
-    mutt_bcache_commit(pop_data->bcache, h->data);
+    mutt_bcache_commit(pop_data->bcache, cache_id(h->data));
   else
   {
     cache->index = h->index;
@@ -783,7 +800,7 @@ static int pop_sync_mailbox(struct Context *ctx, int *index_hint)
         ret = pop_query(pop_data, buf, sizeof(buf));
         if (ret == 0)
         {
-          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);
+          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));
 #ifdef USE_HCACHE
           mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));
 #endif",neomutt,9bfab35522301794483f8f9ed60820bdec9be59e,98aad9c3f1fb281e35a966d4a9b01b60db402e7a,1,"static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)
{
  struct Context *ctx = (struct Context *) data;
  if (!ctx)
    return -1;
  struct PopData *pop_data = (struct PopData *) ctx->data;
  if (!pop_data)
    return -1;

#ifdef USE_HCACHE
  /* keep hcache file if hcache == bcache */
  if (strcmp(HC_FNAME ""."" HC_FEXT, id) == 0)
    return 0;
#endif

  for (int i = 0; i < ctx->msgcount; i++)
  {
    /* if the id we get is known for a header: done (i.e. keep in cache) */
    if (ctx->hdrs[i]->data && (mutt_str_strcmp(ctx->hdrs[i]->data, id) == 0))
      return 0;
  }

   /* message not found in context -> remove it from cache
    * return the result of bcache, so we stop upon its first error
    */
//flaw_line_below:
  return mutt_bcache_del(bcache, id);
//fix_flaw_line_below:
//  return mutt_bcache_del(bcache, cache_id(id));
 }
"
4557,182293,,Remote,Not required,,CVE-2018-14363,https://www.cvedetails.com/cve/CVE-2018-14363/,CWE-22,Low,,Partial,,2018-07-17,5.0,An issue was discovered in NeoMutt before 2018-07-16. newsrc.c does not properly restrict '/' characters that may have unsafe interaction with cache pathnames.,2019-10-02,Dir. Trav. ,1,https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e,9bfab35522301794483f8f9ed60820bdec9be59e,"sanitise cache paths

Co-authored-by: JerikoOne <jeriko.one@gmx.us>",1,pop.c,"{""sha"": ""c9dfdba23c03a5608841c4a703f0df61b10d89af"", ""filename"": ""newsrc.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 1, ""changes"": 13, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/9bfab35522301794483f8f9ed60820bdec9be59e/newsrc.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/9bfab35522301794483f8f9ed60820bdec9be59e/newsrc.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/newsrc.c?ref=9bfab35522301794483f8f9ed60820bdec9be59e"", ""patch"": ""@@ -715,7 +715,18 @@ int nntp_active_save_cache(struct NntpServer *nserv)\n  */\n static int nntp_hcache_namer(const char *path, char *dest, size_t destlen)\n {\n-  return snprintf(dest, destlen, \""%s.hcache\"", path);\n+  int count = snprintf(dest, destlen, \""%s.hcache\"", path);\n+\n+  /* Strip out any directories in the path */\n+  char *first = strchr(dest, '/');\n+  char *last = strrchr(dest, '/');\n+  if (first && last && (last > first))\n+  {\n+    memmove(first, last, strlen(last) + 1);\n+    count -= (last - first);\n+  }\n+\n+  return count;\n }\n \n /**""}<_**next**_>{""sha"": ""4f3a592a8d562aec7dfe3c80bec8e010cd879c97"", ""filename"": ""pop.c"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 6, ""changes"": 29, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/9bfab35522301794483f8f9ed60820bdec9be59e/pop.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/9bfab35522301794483f8f9ed60820bdec9be59e/pop.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/pop.c?ref=9bfab35522301794483f8f9ed60820bdec9be59e"", ""patch"": ""@@ -63,6 +63,23 @@\n #define HC_FEXT \""hcache\""   /* extension for hcache as POP lacks paths */\n #endif\n \n+/**\n+ * cache_id - Make a message-cache-compatible id\n+ * @param id POP message id\n+ * @retval ptr Sanitised string\n+ *\n+ * The POP message id may contain '/' and other awkward characters.\n+ *\n+ * @note This function returns a pointer to a static buffer.\n+ */\n+static const char *cache_id(const char *id)\n+{\n+  static char clean[SHORT_STRING];\n+  mutt_str_strfcpy(clean, id, sizeof(clean));\n+  mutt_file_sanitize_filename(clean, true);\n+  return clean;\n+}\n+\n /**\n  * fetch_message - write line to file\n  * @param line String to write\n@@ -242,7 +259,7 @@ static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)\n   /* message not found in context -> remove it from cache\n    * return the result of bcache, so we stop upon its first error\n    */\n-  return mutt_bcache_del(bcache, id);\n+  return mutt_bcache_del(bcache, cache_id(id));\n }\n \n #ifdef USE_HCACHE\n@@ -407,7 +424,7 @@ static int pop_fetch_headers(struct Context *ctx)\n        *        - if we don't have a body: new\n        */\n       const bool bcached =\n-          (mutt_bcache_exists(pop_data->bcache, ctx->hdrs[i]->data) == 0);\n+          (mutt_bcache_exists(pop_data->bcache, cache_id(ctx->hdrs[i]->data)) == 0);\n       ctx->hdrs[i]->old = false;\n       ctx->hdrs[i]->read = false;\n       if (hcached)\n@@ -597,7 +614,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno\n   unsigned short bcache = 1;\n \n   /* see if we already have the message in body cache */\n-  msg->fp = mutt_bcache_get(pop_data->bcache, h->data);\n+  msg->fp = mutt_bcache_get(pop_data->bcache, cache_id(h->data));\n   if (msg->fp)\n     return 0;\n \n@@ -644,7 +661,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno\n                        NetInc, h->content->length + h->content->offset - 1);\n \n     /* see if we can put in body cache; use our cache as fallback */\n-    msg->fp = mutt_bcache_put(pop_data->bcache, h->data);\n+    msg->fp = mutt_bcache_put(pop_data->bcache, cache_id(h->data));\n     if (!msg->fp)\n     {\n       /* no */\n@@ -689,7 +706,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno\n    * portion of the headers, those required for the main display.\n    */\n   if (bcache)\n-    mutt_bcache_commit(pop_data->bcache, h->data);\n+    mutt_bcache_commit(pop_data->bcache, cache_id(h->data));\n   else\n   {\n     cache->index = h->index;\n@@ -783,7 +800,7 @@ static int pop_sync_mailbox(struct Context *ctx, int *index_hint)\n         ret = pop_query(pop_data, buf, sizeof(buf));\n         if (ret == 0)\n         {\n-          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);\n+          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));\n #ifdef USE_HCACHE\n           mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n #endif""}","static int pop_fetch_headers(struct Context *ctx)
{
  struct PopData *pop_data = (struct PopData *) ctx->data;
  struct Progress progress;

#ifdef USE_HCACHE
  header_cache_t *hc = pop_hcache_open(pop_data, ctx->path);
#endif

  time(&pop_data->check_time);
  pop_data->clear_cache = false;

  for (int i = 0; i < ctx->msgcount; i++)
    ctx->hdrs[i]->refno = -1;

  const int old_count = ctx->msgcount;
  int ret = pop_fetch_data(pop_data, ""UIDL\r\n"", NULL, fetch_uidl, ctx);
  const int new_count = ctx->msgcount;
  ctx->msgcount = old_count;

  if (pop_data->cmd_uidl == 2)
  {
    if (ret == 0)
    {
      pop_data->cmd_uidl = 1;

      mutt_debug(1, ""set UIDL capability\n"");
    }

    if (ret == -2 && pop_data->cmd_uidl == 2)
    {
      pop_data->cmd_uidl = 0;

      mutt_debug(1, ""unset UIDL capability\n"");
      snprintf(pop_data->err_msg, sizeof(pop_data->err_msg), ""%s"",
               _(""Command UIDL is not supported by server.""));
    }
  }

  if (!ctx->quiet)
  {
    mutt_progress_init(&progress, _(""Fetching message headers...""),
                       MUTT_PROGRESS_MSG, ReadInc, new_count - old_count);
  }

  if (ret == 0)
  {
    int i, deleted;
    for (i = 0, deleted = 0; i < old_count; i++)
    {
      if (ctx->hdrs[i]->refno == -1)
      {
        ctx->hdrs[i]->deleted = true;
        deleted++;
      }
    }
    if (deleted > 0)
    {
      mutt_error(
          ngettext(""%d message has been lost. Try reopening the mailbox."",
                   ""%d messages have been lost. Try reopening the mailbox."", deleted),
          deleted);
    }

    bool hcached = false;
    for (i = old_count; i < new_count; i++)
    {
      if (!ctx->quiet)
        mutt_progress_update(&progress, i + 1 - old_count, -1);
#ifdef USE_HCACHE
      void *data = mutt_hcache_fetch(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));
      if (data)
      {
        char *uidl = mutt_str_strdup(ctx->hdrs[i]->data);
        int refno = ctx->hdrs[i]->refno;
        int index = ctx->hdrs[i]->index;
        /*
         * - POP dynamically numbers headers and relies on h->refno
         *   to map messages; so restore header and overwrite restored
         *   refno with current refno, same for index
         * - h->data needs to a separate pointer as it's driver-specific
         *   data freed separately elsewhere
         *   (the old h->data should point inside a malloc'd block from
         *   hcache so there shouldn't be a memleak here)
         */
        struct Header *h = mutt_hcache_restore((unsigned char *) data);
        mutt_hcache_free(hc, &data);
        mutt_header_free(&ctx->hdrs[i]);
        ctx->hdrs[i] = h;
        ctx->hdrs[i]->refno = refno;
        ctx->hdrs[i]->index = index;
        ctx->hdrs[i]->data = uidl;
        ret = 0;
        hcached = true;
      }
      else
#endif
          if ((ret = pop_read_header(pop_data, ctx->hdrs[i])) < 0)
        break;
#ifdef USE_HCACHE
      else
      {
        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),
                          ctx->hdrs[i], 0);
      }
#endif

      /*
       * faked support for flags works like this:
       * - if 'hcached' is true, we have the message in our hcache:
       *        - if we also have a body: read
       *        - if we don't have a body: old
       *          (if $mark_old is set which is maybe wrong as
       *          $mark_old should be considered for syncing the
       *          folder and not when opening it XXX)
       * - if 'hcached' is false, we don't have the message in our hcache:
       *        - if we also have a body: read
        *        - if we don't have a body: new
        */
       const bool bcached =
          (mutt_bcache_exists(pop_data->bcache, cache_id(ctx->hdrs[i]->data)) == 0);
       ctx->hdrs[i]->old = false;
       ctx->hdrs[i]->read = false;
       if (hcached)
      {
        if (bcached)
          ctx->hdrs[i]->read = true;
        else if (MarkOld)
          ctx->hdrs[i]->old = true;
      }
      else
      {
        if (bcached)
          ctx->hdrs[i]->read = true;
      }

      ctx->msgcount++;
    }

    if (i > old_count)
      mx_update_context(ctx, i - old_count);
  }

#ifdef USE_HCACHE
  mutt_hcache_close(hc);
#endif

  if (ret < 0)
  {
    for (int i = ctx->msgcount; i < new_count; i++)
      mutt_header_free(&ctx->hdrs[i]);
    return ret;
  }

  /* after putting the result into our structures,
   * clean up cache, i.e. wipe messages deleted outside
   * the availability of our cache
   */
  if (MessageCacheClean)
    mutt_bcache_list(pop_data->bcache, msg_cache_check, (void *) ctx);

  mutt_clear_error();
  return (new_count - old_count);
}
","static int pop_fetch_headers(struct Context *ctx)
{
  struct PopData *pop_data = (struct PopData *) ctx->data;
  struct Progress progress;

#ifdef USE_HCACHE
  header_cache_t *hc = pop_hcache_open(pop_data, ctx->path);
#endif

  time(&pop_data->check_time);
  pop_data->clear_cache = false;

  for (int i = 0; i < ctx->msgcount; i++)
    ctx->hdrs[i]->refno = -1;

  const int old_count = ctx->msgcount;
  int ret = pop_fetch_data(pop_data, ""UIDL\r\n"", NULL, fetch_uidl, ctx);
  const int new_count = ctx->msgcount;
  ctx->msgcount = old_count;

  if (pop_data->cmd_uidl == 2)
  {
    if (ret == 0)
    {
      pop_data->cmd_uidl = 1;

      mutt_debug(1, ""set UIDL capability\n"");
    }

    if (ret == -2 && pop_data->cmd_uidl == 2)
    {
      pop_data->cmd_uidl = 0;

      mutt_debug(1, ""unset UIDL capability\n"");
      snprintf(pop_data->err_msg, sizeof(pop_data->err_msg), ""%s"",
               _(""Command UIDL is not supported by server.""));
    }
  }

  if (!ctx->quiet)
  {
    mutt_progress_init(&progress, _(""Fetching message headers...""),
                       MUTT_PROGRESS_MSG, ReadInc, new_count - old_count);
  }

  if (ret == 0)
  {
    int i, deleted;
    for (i = 0, deleted = 0; i < old_count; i++)
    {
      if (ctx->hdrs[i]->refno == -1)
      {
        ctx->hdrs[i]->deleted = true;
        deleted++;
      }
    }
    if (deleted > 0)
    {
      mutt_error(
          ngettext(""%d message has been lost. Try reopening the mailbox."",
                   ""%d messages have been lost. Try reopening the mailbox."", deleted),
          deleted);
    }

    bool hcached = false;
    for (i = old_count; i < new_count; i++)
    {
      if (!ctx->quiet)
        mutt_progress_update(&progress, i + 1 - old_count, -1);
#ifdef USE_HCACHE
      void *data = mutt_hcache_fetch(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));
      if (data)
      {
        char *uidl = mutt_str_strdup(ctx->hdrs[i]->data);
        int refno = ctx->hdrs[i]->refno;
        int index = ctx->hdrs[i]->index;
        /*
         * - POP dynamically numbers headers and relies on h->refno
         *   to map messages; so restore header and overwrite restored
         *   refno with current refno, same for index
         * - h->data needs to a separate pointer as it's driver-specific
         *   data freed separately elsewhere
         *   (the old h->data should point inside a malloc'd block from
         *   hcache so there shouldn't be a memleak here)
         */
        struct Header *h = mutt_hcache_restore((unsigned char *) data);
        mutt_hcache_free(hc, &data);
        mutt_header_free(&ctx->hdrs[i]);
        ctx->hdrs[i] = h;
        ctx->hdrs[i]->refno = refno;
        ctx->hdrs[i]->index = index;
        ctx->hdrs[i]->data = uidl;
        ret = 0;
        hcached = true;
      }
      else
#endif
          if ((ret = pop_read_header(pop_data, ctx->hdrs[i])) < 0)
        break;
#ifdef USE_HCACHE
      else
      {
        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),
                          ctx->hdrs[i], 0);
      }
#endif

      /*
       * faked support for flags works like this:
       * - if 'hcached' is true, we have the message in our hcache:
       *        - if we also have a body: read
       *        - if we don't have a body: old
       *          (if $mark_old is set which is maybe wrong as
       *          $mark_old should be considered for syncing the
       *          folder and not when opening it XXX)
       * - if 'hcached' is false, we don't have the message in our hcache:
       *        - if we also have a body: read
        *        - if we don't have a body: new
        */
       const bool bcached =
          (mutt_bcache_exists(pop_data->bcache, ctx->hdrs[i]->data) == 0);
       ctx->hdrs[i]->old = false;
       ctx->hdrs[i]->read = false;
       if (hcached)
      {
        if (bcached)
          ctx->hdrs[i]->read = true;
        else if (MarkOld)
          ctx->hdrs[i]->old = true;
      }
      else
      {
        if (bcached)
          ctx->hdrs[i]->read = true;
      }

      ctx->msgcount++;
    }

    if (i > old_count)
      mx_update_context(ctx, i - old_count);
  }

#ifdef USE_HCACHE
  mutt_hcache_close(hc);
#endif

  if (ret < 0)
  {
    for (int i = ctx->msgcount; i < new_count; i++)
      mutt_header_free(&ctx->hdrs[i]);
    return ret;
  }

  /* after putting the result into our structures,
   * clean up cache, i.e. wipe messages deleted outside
   * the availability of our cache
   */
  if (MessageCacheClean)
    mutt_bcache_list(pop_data->bcache, msg_cache_check, (void *) ctx);

  mutt_clear_error();
  return (new_count - old_count);
}
",C,"          (mutt_bcache_exists(pop_data->bcache, cache_id(ctx->hdrs[i]->data)) == 0);
","          (mutt_bcache_exists(pop_data->bcache, ctx->hdrs[i]->data) == 0);
",,"@@ -63,6 +63,23 @@
 #define HC_FEXT ""hcache""   /* extension for hcache as POP lacks paths */
 #endif
 
+/**
+ * cache_id - Make a message-cache-compatible id
+ * @param id POP message id
+ * @retval ptr Sanitised string
+ *
+ * The POP message id may contain '/' and other awkward characters.
+ *
+ * @note This function returns a pointer to a static buffer.
+ */
+static const char *cache_id(const char *id)
+{
+  static char clean[SHORT_STRING];
+  mutt_str_strfcpy(clean, id, sizeof(clean));
+  mutt_file_sanitize_filename(clean, true);
+  return clean;
+}
+
 /**
  * fetch_message - write line to file
  * @param line String to write
@@ -242,7 +259,7 @@ static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)
   /* message not found in context -> remove it from cache
    * return the result of bcache, so we stop upon its first error
    */
-  return mutt_bcache_del(bcache, id);
+  return mutt_bcache_del(bcache, cache_id(id));
 }
 
 #ifdef USE_HCACHE
@@ -407,7 +424,7 @@ static int pop_fetch_headers(struct Context *ctx)
        *        - if we don't have a body: new
        */
       const bool bcached =
-          (mutt_bcache_exists(pop_data->bcache, ctx->hdrs[i]->data) == 0);
+          (mutt_bcache_exists(pop_data->bcache, cache_id(ctx->hdrs[i]->data)) == 0);
       ctx->hdrs[i]->old = false;
       ctx->hdrs[i]->read = false;
       if (hcached)
@@ -597,7 +614,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno
   unsigned short bcache = 1;
 
   /* see if we already have the message in body cache */
-  msg->fp = mutt_bcache_get(pop_data->bcache, h->data);
+  msg->fp = mutt_bcache_get(pop_data->bcache, cache_id(h->data));
   if (msg->fp)
     return 0;
 
@@ -644,7 +661,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno
                        NetInc, h->content->length + h->content->offset - 1);
 
     /* see if we can put in body cache; use our cache as fallback */
-    msg->fp = mutt_bcache_put(pop_data->bcache, h->data);
+    msg->fp = mutt_bcache_put(pop_data->bcache, cache_id(h->data));
     if (!msg->fp)
     {
       /* no */
@@ -689,7 +706,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno
    * portion of the headers, those required for the main display.
    */
   if (bcache)
-    mutt_bcache_commit(pop_data->bcache, h->data);
+    mutt_bcache_commit(pop_data->bcache, cache_id(h->data));
   else
   {
     cache->index = h->index;
@@ -783,7 +800,7 @@ static int pop_sync_mailbox(struct Context *ctx, int *index_hint)
         ret = pop_query(pop_data, buf, sizeof(buf));
         if (ret == 0)
         {
-          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);
+          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));
 #ifdef USE_HCACHE
           mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));
 #endif",neomutt,9bfab35522301794483f8f9ed60820bdec9be59e,98aad9c3f1fb281e35a966d4a9b01b60db402e7a,1,"static int pop_fetch_headers(struct Context *ctx)
{
  struct PopData *pop_data = (struct PopData *) ctx->data;
  struct Progress progress;

#ifdef USE_HCACHE
  header_cache_t *hc = pop_hcache_open(pop_data, ctx->path);
#endif

  time(&pop_data->check_time);
  pop_data->clear_cache = false;

  for (int i = 0; i < ctx->msgcount; i++)
    ctx->hdrs[i]->refno = -1;

  const int old_count = ctx->msgcount;
  int ret = pop_fetch_data(pop_data, ""UIDL\r\n"", NULL, fetch_uidl, ctx);
  const int new_count = ctx->msgcount;
  ctx->msgcount = old_count;

  if (pop_data->cmd_uidl == 2)
  {
    if (ret == 0)
    {
      pop_data->cmd_uidl = 1;

      mutt_debug(1, ""set UIDL capability\n"");
    }

    if (ret == -2 && pop_data->cmd_uidl == 2)
    {
      pop_data->cmd_uidl = 0;

      mutt_debug(1, ""unset UIDL capability\n"");
      snprintf(pop_data->err_msg, sizeof(pop_data->err_msg), ""%s"",
               _(""Command UIDL is not supported by server.""));
    }
  }

  if (!ctx->quiet)
  {
    mutt_progress_init(&progress, _(""Fetching message headers...""),
                       MUTT_PROGRESS_MSG, ReadInc, new_count - old_count);
  }

  if (ret == 0)
  {
    int i, deleted;
    for (i = 0, deleted = 0; i < old_count; i++)
    {
      if (ctx->hdrs[i]->refno == -1)
      {
        ctx->hdrs[i]->deleted = true;
        deleted++;
      }
    }
    if (deleted > 0)
    {
      mutt_error(
          ngettext(""%d message has been lost. Try reopening the mailbox."",
                   ""%d messages have been lost. Try reopening the mailbox."", deleted),
          deleted);
    }

    bool hcached = false;
    for (i = old_count; i < new_count; i++)
    {
      if (!ctx->quiet)
        mutt_progress_update(&progress, i + 1 - old_count, -1);
#ifdef USE_HCACHE
      void *data = mutt_hcache_fetch(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));
      if (data)
      {
        char *uidl = mutt_str_strdup(ctx->hdrs[i]->data);
        int refno = ctx->hdrs[i]->refno;
        int index = ctx->hdrs[i]->index;
        /*
         * - POP dynamically numbers headers and relies on h->refno
         *   to map messages; so restore header and overwrite restored
         *   refno with current refno, same for index
         * - h->data needs to a separate pointer as it's driver-specific
         *   data freed separately elsewhere
         *   (the old h->data should point inside a malloc'd block from
         *   hcache so there shouldn't be a memleak here)
         */
        struct Header *h = mutt_hcache_restore((unsigned char *) data);
        mutt_hcache_free(hc, &data);
        mutt_header_free(&ctx->hdrs[i]);
        ctx->hdrs[i] = h;
        ctx->hdrs[i]->refno = refno;
        ctx->hdrs[i]->index = index;
        ctx->hdrs[i]->data = uidl;
        ret = 0;
        hcached = true;
      }
      else
#endif
          if ((ret = pop_read_header(pop_data, ctx->hdrs[i])) < 0)
        break;
#ifdef USE_HCACHE
      else
      {
        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),
                          ctx->hdrs[i], 0);
      }
#endif

      /*
       * faked support for flags works like this:
       * - if 'hcached' is true, we have the message in our hcache:
       *        - if we also have a body: read
       *        - if we don't have a body: old
       *          (if $mark_old is set which is maybe wrong as
       *          $mark_old should be considered for syncing the
       *          folder and not when opening it XXX)
       * - if 'hcached' is false, we don't have the message in our hcache:
       *        - if we also have a body: read
        *        - if we don't have a body: new
        */
       const bool bcached =
//flaw_line_below:
          (mutt_bcache_exists(pop_data->bcache, ctx->hdrs[i]->data) == 0);
//fix_flaw_line_below:
//          (mutt_bcache_exists(pop_data->bcache, cache_id(ctx->hdrs[i]->data)) == 0);
       ctx->hdrs[i]->old = false;
       ctx->hdrs[i]->read = false;
       if (hcached)
      {
        if (bcached)
          ctx->hdrs[i]->read = true;
        else if (MarkOld)
          ctx->hdrs[i]->old = true;
      }
      else
      {
        if (bcached)
          ctx->hdrs[i]->read = true;
      }

      ctx->msgcount++;
    }

    if (i > old_count)
      mx_update_context(ctx, i - old_count);
  }

#ifdef USE_HCACHE
  mutt_hcache_close(hc);
#endif

  if (ret < 0)
  {
    for (int i = ctx->msgcount; i < new_count; i++)
      mutt_header_free(&ctx->hdrs[i]);
    return ret;
  }

  /* after putting the result into our structures,
   * clean up cache, i.e. wipe messages deleted outside
   * the availability of our cache
   */
  if (MessageCacheClean)
    mutt_bcache_list(pop_data->bcache, msg_cache_check, (void *) ctx);

  mutt_clear_error();
  return (new_count - old_count);
}
"
4558,182294,,Remote,Not required,,CVE-2018-14363,https://www.cvedetails.com/cve/CVE-2018-14363/,CWE-22,Low,,Partial,,2018-07-17,5.0,An issue was discovered in NeoMutt before 2018-07-16. newsrc.c does not properly restrict '/' characters that may have unsafe interaction with cache pathnames.,2019-10-02,Dir. Trav. ,3,https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e,9bfab35522301794483f8f9ed60820bdec9be59e,"sanitise cache paths

Co-authored-by: JerikoOne <jeriko.one@gmx.us>",3,pop.c,"{""sha"": ""c9dfdba23c03a5608841c4a703f0df61b10d89af"", ""filename"": ""newsrc.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 1, ""changes"": 13, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/9bfab35522301794483f8f9ed60820bdec9be59e/newsrc.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/9bfab35522301794483f8f9ed60820bdec9be59e/newsrc.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/newsrc.c?ref=9bfab35522301794483f8f9ed60820bdec9be59e"", ""patch"": ""@@ -715,7 +715,18 @@ int nntp_active_save_cache(struct NntpServer *nserv)\n  */\n static int nntp_hcache_namer(const char *path, char *dest, size_t destlen)\n {\n-  return snprintf(dest, destlen, \""%s.hcache\"", path);\n+  int count = snprintf(dest, destlen, \""%s.hcache\"", path);\n+\n+  /* Strip out any directories in the path */\n+  char *first = strchr(dest, '/');\n+  char *last = strrchr(dest, '/');\n+  if (first && last && (last > first))\n+  {\n+    memmove(first, last, strlen(last) + 1);\n+    count -= (last - first);\n+  }\n+\n+  return count;\n }\n \n /**""}<_**next**_>{""sha"": ""4f3a592a8d562aec7dfe3c80bec8e010cd879c97"", ""filename"": ""pop.c"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 6, ""changes"": 29, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/9bfab35522301794483f8f9ed60820bdec9be59e/pop.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/9bfab35522301794483f8f9ed60820bdec9be59e/pop.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/pop.c?ref=9bfab35522301794483f8f9ed60820bdec9be59e"", ""patch"": ""@@ -63,6 +63,23 @@\n #define HC_FEXT \""hcache\""   /* extension for hcache as POP lacks paths */\n #endif\n \n+/**\n+ * cache_id - Make a message-cache-compatible id\n+ * @param id POP message id\n+ * @retval ptr Sanitised string\n+ *\n+ * The POP message id may contain '/' and other awkward characters.\n+ *\n+ * @note This function returns a pointer to a static buffer.\n+ */\n+static const char *cache_id(const char *id)\n+{\n+  static char clean[SHORT_STRING];\n+  mutt_str_strfcpy(clean, id, sizeof(clean));\n+  mutt_file_sanitize_filename(clean, true);\n+  return clean;\n+}\n+\n /**\n  * fetch_message - write line to file\n  * @param line String to write\n@@ -242,7 +259,7 @@ static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)\n   /* message not found in context -> remove it from cache\n    * return the result of bcache, so we stop upon its first error\n    */\n-  return mutt_bcache_del(bcache, id);\n+  return mutt_bcache_del(bcache, cache_id(id));\n }\n \n #ifdef USE_HCACHE\n@@ -407,7 +424,7 @@ static int pop_fetch_headers(struct Context *ctx)\n        *        - if we don't have a body: new\n        */\n       const bool bcached =\n-          (mutt_bcache_exists(pop_data->bcache, ctx->hdrs[i]->data) == 0);\n+          (mutt_bcache_exists(pop_data->bcache, cache_id(ctx->hdrs[i]->data)) == 0);\n       ctx->hdrs[i]->old = false;\n       ctx->hdrs[i]->read = false;\n       if (hcached)\n@@ -597,7 +614,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno\n   unsigned short bcache = 1;\n \n   /* see if we already have the message in body cache */\n-  msg->fp = mutt_bcache_get(pop_data->bcache, h->data);\n+  msg->fp = mutt_bcache_get(pop_data->bcache, cache_id(h->data));\n   if (msg->fp)\n     return 0;\n \n@@ -644,7 +661,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno\n                        NetInc, h->content->length + h->content->offset - 1);\n \n     /* see if we can put in body cache; use our cache as fallback */\n-    msg->fp = mutt_bcache_put(pop_data->bcache, h->data);\n+    msg->fp = mutt_bcache_put(pop_data->bcache, cache_id(h->data));\n     if (!msg->fp)\n     {\n       /* no */\n@@ -689,7 +706,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno\n    * portion of the headers, those required for the main display.\n    */\n   if (bcache)\n-    mutt_bcache_commit(pop_data->bcache, h->data);\n+    mutt_bcache_commit(pop_data->bcache, cache_id(h->data));\n   else\n   {\n     cache->index = h->index;\n@@ -783,7 +800,7 @@ static int pop_sync_mailbox(struct Context *ctx, int *index_hint)\n         ret = pop_query(pop_data, buf, sizeof(buf));\n         if (ret == 0)\n         {\n-          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);\n+          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));\n #ifdef USE_HCACHE\n           mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n #endif""}","static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno)
{
  void *uidl = NULL;
  char buf[LONG_STRING];
  char path[PATH_MAX];
  struct Progress progressbar;
  struct PopData *pop_data = (struct PopData *) ctx->data;
  struct PopCache *cache = NULL;
  struct Header *h = ctx->hdrs[msgno];
   unsigned short bcache = 1;
 
   /* see if we already have the message in body cache */
  msg->fp = mutt_bcache_get(pop_data->bcache, cache_id(h->data));
   if (msg->fp)
     return 0;
 
  /*
   * see if we already have the message in our cache in
   * case $message_cachedir is unset
   */
  cache = &pop_data->cache[h->index % POP_CACHE_LEN];

  if (cache->path)
  {
    if (cache->index == h->index)
    {
      /* yes, so just return a pointer to the message */
      msg->fp = fopen(cache->path, ""r"");
      if (msg->fp)
        return 0;

      mutt_perror(cache->path);
      return -1;
    }
    else
    {
      /* clear the previous entry */
      unlink(cache->path);
      FREE(&cache->path);
    }
  }

  while (true)
  {
    if (pop_reconnect(ctx) < 0)
      return -1;

    /* verify that massage index is correct */
    if (h->refno < 0)
    {
      mutt_error(
          _(""The message index is incorrect. Try reopening the mailbox.""));
      return -1;
    }

    mutt_progress_init(&progressbar, _(""Fetching message...""), MUTT_PROGRESS_SIZE,
                        NetInc, h->content->length + h->content->offset - 1);
 
     /* see if we can put in body cache; use our cache as fallback */
    msg->fp = mutt_bcache_put(pop_data->bcache, cache_id(h->data));
     if (!msg->fp)
     {
       /* no */
      bcache = 0;
      mutt_mktemp(path, sizeof(path));
      msg->fp = mutt_file_fopen(path, ""w+"");
      if (!msg->fp)
      {
        mutt_perror(path);
        return -1;
      }
    }

    snprintf(buf, sizeof(buf), ""RETR %d\r\n"", h->refno);

    const int ret = pop_fetch_data(pop_data, buf, &progressbar, fetch_message, msg->fp);
    if (ret == 0)
      break;

    mutt_file_fclose(&msg->fp);

    /* if RETR failed (e.g. connection closed), be sure to remove either
     * the file in bcache or from POP's own cache since the next iteration
     * of the loop will re-attempt to put() the message */
    if (!bcache)
      unlink(path);

    if (ret == -2)
    {
      mutt_error(""%s"", pop_data->err_msg);
      return -1;
    }

    if (ret == -3)
    {
      mutt_error(_(""Can't write message to temporary file!""));
      return -1;
    }
  }

  /* Update the header information.  Previously, we only downloaded a
    * portion of the headers, those required for the main display.
    */
   if (bcache)
    mutt_bcache_commit(pop_data->bcache, cache_id(h->data));
   else
   {
     cache->index = h->index;
    cache->path = mutt_str_strdup(path);
  }
  rewind(msg->fp);
  uidl = h->data;

  /* we replace envelop, key in subj_hash has to be updated as well */
  if (ctx->subj_hash && h->env->real_subj)
    mutt_hash_delete(ctx->subj_hash, h->env->real_subj, h);
  mutt_label_hash_remove(ctx, h);
  mutt_env_free(&h->env);
  h->env = mutt_rfc822_read_header(msg->fp, h, 0, 0);
  if (ctx->subj_hash && h->env->real_subj)
    mutt_hash_insert(ctx->subj_hash, h->env->real_subj, h);
  mutt_label_hash_add(ctx, h);

  h->data = uidl;
  h->lines = 0;
  fgets(buf, sizeof(buf), msg->fp);
  while (!feof(msg->fp))
  {
    ctx->hdrs[msgno]->lines++;
    fgets(buf, sizeof(buf), msg->fp);
  }

  h->content->length = ftello(msg->fp) - h->content->offset;

  /* This needs to be done in case this is a multipart message */
  if (!WithCrypto)
    h->security = crypt_query(h->content);

  mutt_clear_error();
  rewind(msg->fp);

  return 0;
}
","static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno)
{
  void *uidl = NULL;
  char buf[LONG_STRING];
  char path[PATH_MAX];
  struct Progress progressbar;
  struct PopData *pop_data = (struct PopData *) ctx->data;
  struct PopCache *cache = NULL;
  struct Header *h = ctx->hdrs[msgno];
   unsigned short bcache = 1;
 
   /* see if we already have the message in body cache */
  msg->fp = mutt_bcache_get(pop_data->bcache, h->data);
   if (msg->fp)
     return 0;
 
  /*
   * see if we already have the message in our cache in
   * case $message_cachedir is unset
   */
  cache = &pop_data->cache[h->index % POP_CACHE_LEN];

  if (cache->path)
  {
    if (cache->index == h->index)
    {
      /* yes, so just return a pointer to the message */
      msg->fp = fopen(cache->path, ""r"");
      if (msg->fp)
        return 0;

      mutt_perror(cache->path);
      return -1;
    }
    else
    {
      /* clear the previous entry */
      unlink(cache->path);
      FREE(&cache->path);
    }
  }

  while (true)
  {
    if (pop_reconnect(ctx) < 0)
      return -1;

    /* verify that massage index is correct */
    if (h->refno < 0)
    {
      mutt_error(
          _(""The message index is incorrect. Try reopening the mailbox.""));
      return -1;
    }

    mutt_progress_init(&progressbar, _(""Fetching message...""), MUTT_PROGRESS_SIZE,
                        NetInc, h->content->length + h->content->offset - 1);
 
     /* see if we can put in body cache; use our cache as fallback */
    msg->fp = mutt_bcache_put(pop_data->bcache, h->data);
     if (!msg->fp)
     {
       /* no */
      bcache = 0;
      mutt_mktemp(path, sizeof(path));
      msg->fp = mutt_file_fopen(path, ""w+"");
      if (!msg->fp)
      {
        mutt_perror(path);
        return -1;
      }
    }

    snprintf(buf, sizeof(buf), ""RETR %d\r\n"", h->refno);

    const int ret = pop_fetch_data(pop_data, buf, &progressbar, fetch_message, msg->fp);
    if (ret == 0)
      break;

    mutt_file_fclose(&msg->fp);

    /* if RETR failed (e.g. connection closed), be sure to remove either
     * the file in bcache or from POP's own cache since the next iteration
     * of the loop will re-attempt to put() the message */
    if (!bcache)
      unlink(path);

    if (ret == -2)
    {
      mutt_error(""%s"", pop_data->err_msg);
      return -1;
    }

    if (ret == -3)
    {
      mutt_error(_(""Can't write message to temporary file!""));
      return -1;
    }
  }

  /* Update the header information.  Previously, we only downloaded a
    * portion of the headers, those required for the main display.
    */
   if (bcache)
    mutt_bcache_commit(pop_data->bcache, h->data);
   else
   {
     cache->index = h->index;
    cache->path = mutt_str_strdup(path);
  }
  rewind(msg->fp);
  uidl = h->data;

  /* we replace envelop, key in subj_hash has to be updated as well */
  if (ctx->subj_hash && h->env->real_subj)
    mutt_hash_delete(ctx->subj_hash, h->env->real_subj, h);
  mutt_label_hash_remove(ctx, h);
  mutt_env_free(&h->env);
  h->env = mutt_rfc822_read_header(msg->fp, h, 0, 0);
  if (ctx->subj_hash && h->env->real_subj)
    mutt_hash_insert(ctx->subj_hash, h->env->real_subj, h);
  mutt_label_hash_add(ctx, h);

  h->data = uidl;
  h->lines = 0;
  fgets(buf, sizeof(buf), msg->fp);
  while (!feof(msg->fp))
  {
    ctx->hdrs[msgno]->lines++;
    fgets(buf, sizeof(buf), msg->fp);
  }

  h->content->length = ftello(msg->fp) - h->content->offset;

  /* This needs to be done in case this is a multipart message */
  if (!WithCrypto)
    h->security = crypt_query(h->content);

  mutt_clear_error();
  rewind(msg->fp);

  return 0;
}
",C,"  msg->fp = mutt_bcache_get(pop_data->bcache, cache_id(h->data));
    msg->fp = mutt_bcache_put(pop_data->bcache, cache_id(h->data));
    mutt_bcache_commit(pop_data->bcache, cache_id(h->data));
","  msg->fp = mutt_bcache_get(pop_data->bcache, h->data);
    msg->fp = mutt_bcache_put(pop_data->bcache, h->data);
    mutt_bcache_commit(pop_data->bcache, h->data);
",,"@@ -63,6 +63,23 @@
 #define HC_FEXT ""hcache""   /* extension for hcache as POP lacks paths */
 #endif
 
+/**
+ * cache_id - Make a message-cache-compatible id
+ * @param id POP message id
+ * @retval ptr Sanitised string
+ *
+ * The POP message id may contain '/' and other awkward characters.
+ *
+ * @note This function returns a pointer to a static buffer.
+ */
+static const char *cache_id(const char *id)
+{
+  static char clean[SHORT_STRING];
+  mutt_str_strfcpy(clean, id, sizeof(clean));
+  mutt_file_sanitize_filename(clean, true);
+  return clean;
+}
+
 /**
  * fetch_message - write line to file
  * @param line String to write
@@ -242,7 +259,7 @@ static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)
   /* message not found in context -> remove it from cache
    * return the result of bcache, so we stop upon its first error
    */
-  return mutt_bcache_del(bcache, id);
+  return mutt_bcache_del(bcache, cache_id(id));
 }
 
 #ifdef USE_HCACHE
@@ -407,7 +424,7 @@ static int pop_fetch_headers(struct Context *ctx)
        *        - if we don't have a body: new
        */
       const bool bcached =
-          (mutt_bcache_exists(pop_data->bcache, ctx->hdrs[i]->data) == 0);
+          (mutt_bcache_exists(pop_data->bcache, cache_id(ctx->hdrs[i]->data)) == 0);
       ctx->hdrs[i]->old = false;
       ctx->hdrs[i]->read = false;
       if (hcached)
@@ -597,7 +614,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno
   unsigned short bcache = 1;
 
   /* see if we already have the message in body cache */
-  msg->fp = mutt_bcache_get(pop_data->bcache, h->data);
+  msg->fp = mutt_bcache_get(pop_data->bcache, cache_id(h->data));
   if (msg->fp)
     return 0;
 
@@ -644,7 +661,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno
                        NetInc, h->content->length + h->content->offset - 1);
 
     /* see if we can put in body cache; use our cache as fallback */
-    msg->fp = mutt_bcache_put(pop_data->bcache, h->data);
+    msg->fp = mutt_bcache_put(pop_data->bcache, cache_id(h->data));
     if (!msg->fp)
     {
       /* no */
@@ -689,7 +706,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno
    * portion of the headers, those required for the main display.
    */
   if (bcache)
-    mutt_bcache_commit(pop_data->bcache, h->data);
+    mutt_bcache_commit(pop_data->bcache, cache_id(h->data));
   else
   {
     cache->index = h->index;
@@ -783,7 +800,7 @@ static int pop_sync_mailbox(struct Context *ctx, int *index_hint)
         ret = pop_query(pop_data, buf, sizeof(buf));
         if (ret == 0)
         {
-          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);
+          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));
 #ifdef USE_HCACHE
           mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));
 #endif",neomutt,9bfab35522301794483f8f9ed60820bdec9be59e,98aad9c3f1fb281e35a966d4a9b01b60db402e7a,1,"static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno)
{
  void *uidl = NULL;
  char buf[LONG_STRING];
  char path[PATH_MAX];
  struct Progress progressbar;
  struct PopData *pop_data = (struct PopData *) ctx->data;
  struct PopCache *cache = NULL;
  struct Header *h = ctx->hdrs[msgno];
   unsigned short bcache = 1;
 
   /* see if we already have the message in body cache */
//flaw_line_below:
  msg->fp = mutt_bcache_get(pop_data->bcache, h->data);
//fix_flaw_line_below:
//  msg->fp = mutt_bcache_get(pop_data->bcache, cache_id(h->data));
   if (msg->fp)
     return 0;
 
  /*
   * see if we already have the message in our cache in
   * case $message_cachedir is unset
   */
  cache = &pop_data->cache[h->index % POP_CACHE_LEN];

  if (cache->path)
  {
    if (cache->index == h->index)
    {
      /* yes, so just return a pointer to the message */
      msg->fp = fopen(cache->path, ""r"");
      if (msg->fp)
        return 0;

      mutt_perror(cache->path);
      return -1;
    }
    else
    {
      /* clear the previous entry */
      unlink(cache->path);
      FREE(&cache->path);
    }
  }

  while (true)
  {
    if (pop_reconnect(ctx) < 0)
      return -1;

    /* verify that massage index is correct */
    if (h->refno < 0)
    {
      mutt_error(
          _(""The message index is incorrect. Try reopening the mailbox.""));
      return -1;
    }

    mutt_progress_init(&progressbar, _(""Fetching message...""), MUTT_PROGRESS_SIZE,
                        NetInc, h->content->length + h->content->offset - 1);
 
     /* see if we can put in body cache; use our cache as fallback */
//flaw_line_below:
    msg->fp = mutt_bcache_put(pop_data->bcache, h->data);
//fix_flaw_line_below:
//    msg->fp = mutt_bcache_put(pop_data->bcache, cache_id(h->data));
     if (!msg->fp)
     {
       /* no */
      bcache = 0;
      mutt_mktemp(path, sizeof(path));
      msg->fp = mutt_file_fopen(path, ""w+"");
      if (!msg->fp)
      {
        mutt_perror(path);
        return -1;
      }
    }

    snprintf(buf, sizeof(buf), ""RETR %d\r\n"", h->refno);

    const int ret = pop_fetch_data(pop_data, buf, &progressbar, fetch_message, msg->fp);
    if (ret == 0)
      break;

    mutt_file_fclose(&msg->fp);

    /* if RETR failed (e.g. connection closed), be sure to remove either
     * the file in bcache or from POP's own cache since the next iteration
     * of the loop will re-attempt to put() the message */
    if (!bcache)
      unlink(path);

    if (ret == -2)
    {
      mutt_error(""%s"", pop_data->err_msg);
      return -1;
    }

    if (ret == -3)
    {
      mutt_error(_(""Can't write message to temporary file!""));
      return -1;
    }
  }

  /* Update the header information.  Previously, we only downloaded a
    * portion of the headers, those required for the main display.
    */
   if (bcache)
//flaw_line_below:
    mutt_bcache_commit(pop_data->bcache, h->data);
//fix_flaw_line_below:
//    mutt_bcache_commit(pop_data->bcache, cache_id(h->data));
   else
   {
     cache->index = h->index;
    cache->path = mutt_str_strdup(path);
  }
  rewind(msg->fp);
  uidl = h->data;

  /* we replace envelop, key in subj_hash has to be updated as well */
  if (ctx->subj_hash && h->env->real_subj)
    mutt_hash_delete(ctx->subj_hash, h->env->real_subj, h);
  mutt_label_hash_remove(ctx, h);
  mutt_env_free(&h->env);
  h->env = mutt_rfc822_read_header(msg->fp, h, 0, 0);
  if (ctx->subj_hash && h->env->real_subj)
    mutt_hash_insert(ctx->subj_hash, h->env->real_subj, h);
  mutt_label_hash_add(ctx, h);

  h->data = uidl;
  h->lines = 0;
  fgets(buf, sizeof(buf), msg->fp);
  while (!feof(msg->fp))
  {
    ctx->hdrs[msgno]->lines++;
    fgets(buf, sizeof(buf), msg->fp);
  }

  h->content->length = ftello(msg->fp) - h->content->offset;

  /* This needs to be done in case this is a multipart message */
  if (!WithCrypto)
    h->security = crypt_query(h->content);

  mutt_clear_error();
  rewind(msg->fp);

  return 0;
}
"
4559,182295,,Remote,Not required,,CVE-2018-14363,https://www.cvedetails.com/cve/CVE-2018-14363/,CWE-22,Low,,Partial,,2018-07-17,5.0,An issue was discovered in NeoMutt before 2018-07-16. newsrc.c does not properly restrict '/' characters that may have unsafe interaction with cache pathnames.,2019-10-02,Dir. Trav. ,1,https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e,9bfab35522301794483f8f9ed60820bdec9be59e,"sanitise cache paths

Co-authored-by: JerikoOne <jeriko.one@gmx.us>",1,pop.c,"{""sha"": ""c9dfdba23c03a5608841c4a703f0df61b10d89af"", ""filename"": ""newsrc.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 1, ""changes"": 13, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/9bfab35522301794483f8f9ed60820bdec9be59e/newsrc.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/9bfab35522301794483f8f9ed60820bdec9be59e/newsrc.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/newsrc.c?ref=9bfab35522301794483f8f9ed60820bdec9be59e"", ""patch"": ""@@ -715,7 +715,18 @@ int nntp_active_save_cache(struct NntpServer *nserv)\n  */\n static int nntp_hcache_namer(const char *path, char *dest, size_t destlen)\n {\n-  return snprintf(dest, destlen, \""%s.hcache\"", path);\n+  int count = snprintf(dest, destlen, \""%s.hcache\"", path);\n+\n+  /* Strip out any directories in the path */\n+  char *first = strchr(dest, '/');\n+  char *last = strrchr(dest, '/');\n+  if (first && last && (last > first))\n+  {\n+    memmove(first, last, strlen(last) + 1);\n+    count -= (last - first);\n+  }\n+\n+  return count;\n }\n \n /**""}<_**next**_>{""sha"": ""4f3a592a8d562aec7dfe3c80bec8e010cd879c97"", ""filename"": ""pop.c"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 6, ""changes"": 29, ""blob_url"": ""https://github.com/neomutt/neomutt/blob/9bfab35522301794483f8f9ed60820bdec9be59e/pop.c"", ""raw_url"": ""https://github.com/neomutt/neomutt/raw/9bfab35522301794483f8f9ed60820bdec9be59e/pop.c"", ""contents_url"": ""https://api.github.com/repos/neomutt/neomutt/contents/pop.c?ref=9bfab35522301794483f8f9ed60820bdec9be59e"", ""patch"": ""@@ -63,6 +63,23 @@\n #define HC_FEXT \""hcache\""   /* extension for hcache as POP lacks paths */\n #endif\n \n+/**\n+ * cache_id - Make a message-cache-compatible id\n+ * @param id POP message id\n+ * @retval ptr Sanitised string\n+ *\n+ * The POP message id may contain '/' and other awkward characters.\n+ *\n+ * @note This function returns a pointer to a static buffer.\n+ */\n+static const char *cache_id(const char *id)\n+{\n+  static char clean[SHORT_STRING];\n+  mutt_str_strfcpy(clean, id, sizeof(clean));\n+  mutt_file_sanitize_filename(clean, true);\n+  return clean;\n+}\n+\n /**\n  * fetch_message - write line to file\n  * @param line String to write\n@@ -242,7 +259,7 @@ static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)\n   /* message not found in context -> remove it from cache\n    * return the result of bcache, so we stop upon its first error\n    */\n-  return mutt_bcache_del(bcache, id);\n+  return mutt_bcache_del(bcache, cache_id(id));\n }\n \n #ifdef USE_HCACHE\n@@ -407,7 +424,7 @@ static int pop_fetch_headers(struct Context *ctx)\n        *        - if we don't have a body: new\n        */\n       const bool bcached =\n-          (mutt_bcache_exists(pop_data->bcache, ctx->hdrs[i]->data) == 0);\n+          (mutt_bcache_exists(pop_data->bcache, cache_id(ctx->hdrs[i]->data)) == 0);\n       ctx->hdrs[i]->old = false;\n       ctx->hdrs[i]->read = false;\n       if (hcached)\n@@ -597,7 +614,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno\n   unsigned short bcache = 1;\n \n   /* see if we already have the message in body cache */\n-  msg->fp = mutt_bcache_get(pop_data->bcache, h->data);\n+  msg->fp = mutt_bcache_get(pop_data->bcache, cache_id(h->data));\n   if (msg->fp)\n     return 0;\n \n@@ -644,7 +661,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno\n                        NetInc, h->content->length + h->content->offset - 1);\n \n     /* see if we can put in body cache; use our cache as fallback */\n-    msg->fp = mutt_bcache_put(pop_data->bcache, h->data);\n+    msg->fp = mutt_bcache_put(pop_data->bcache, cache_id(h->data));\n     if (!msg->fp)\n     {\n       /* no */\n@@ -689,7 +706,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno\n    * portion of the headers, those required for the main display.\n    */\n   if (bcache)\n-    mutt_bcache_commit(pop_data->bcache, h->data);\n+    mutt_bcache_commit(pop_data->bcache, cache_id(h->data));\n   else\n   {\n     cache->index = h->index;\n@@ -783,7 +800,7 @@ static int pop_sync_mailbox(struct Context *ctx, int *index_hint)\n         ret = pop_query(pop_data, buf, sizeof(buf));\n         if (ret == 0)\n         {\n-          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);\n+          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));\n #ifdef USE_HCACHE\n           mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n #endif""}","static int pop_sync_mailbox(struct Context *ctx, int *index_hint)
{
  int i, j, ret = 0;
  char buf[LONG_STRING];
  struct PopData *pop_data = (struct PopData *) ctx->data;
  struct Progress progress;
#ifdef USE_HCACHE
  header_cache_t *hc = NULL;
#endif

  pop_data->check_time = 0;

  while (true)
  {
    if (pop_reconnect(ctx) < 0)
      return -1;

    mutt_progress_init(&progress, _(""Marking messages deleted...""),
                       MUTT_PROGRESS_MSG, WriteInc, ctx->deleted);

#ifdef USE_HCACHE
    hc = pop_hcache_open(pop_data, ctx->path);
#endif

    for (i = 0, j = 0, ret = 0; ret == 0 && i < ctx->msgcount; i++)
    {
      if (ctx->hdrs[i]->deleted && ctx->hdrs[i]->refno != -1)
      {
        j++;
        if (!ctx->quiet)
          mutt_progress_update(&progress, j, -1);
        snprintf(buf, sizeof(buf), ""DELE %d\r\n"", ctx->hdrs[i]->refno);
         ret = pop_query(pop_data, buf, sizeof(buf));
         if (ret == 0)
         {
          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));
 #ifdef USE_HCACHE
           mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));
 #endif
        }
      }

#ifdef USE_HCACHE
      if (ctx->hdrs[i]->changed)
      {
        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),
                          ctx->hdrs[i], 0);
      }
#endif
    }

#ifdef USE_HCACHE
    mutt_hcache_close(hc);
#endif

    if (ret == 0)
    {
      mutt_str_strfcpy(buf, ""QUIT\r\n"", sizeof(buf));
      ret = pop_query(pop_data, buf, sizeof(buf));
    }

    if (ret == 0)
    {
      pop_data->clear_cache = true;
      pop_clear_cache(pop_data);
      pop_data->status = POP_DISCONNECTED;
      return 0;
    }

    if (ret == -2)
    {
      mutt_error(""%s"", pop_data->err_msg);
      return -1;
    }
  }
}
","static int pop_sync_mailbox(struct Context *ctx, int *index_hint)
{
  int i, j, ret = 0;
  char buf[LONG_STRING];
  struct PopData *pop_data = (struct PopData *) ctx->data;
  struct Progress progress;
#ifdef USE_HCACHE
  header_cache_t *hc = NULL;
#endif

  pop_data->check_time = 0;

  while (true)
  {
    if (pop_reconnect(ctx) < 0)
      return -1;

    mutt_progress_init(&progress, _(""Marking messages deleted...""),
                       MUTT_PROGRESS_MSG, WriteInc, ctx->deleted);

#ifdef USE_HCACHE
    hc = pop_hcache_open(pop_data, ctx->path);
#endif

    for (i = 0, j = 0, ret = 0; ret == 0 && i < ctx->msgcount; i++)
    {
      if (ctx->hdrs[i]->deleted && ctx->hdrs[i]->refno != -1)
      {
        j++;
        if (!ctx->quiet)
          mutt_progress_update(&progress, j, -1);
        snprintf(buf, sizeof(buf), ""DELE %d\r\n"", ctx->hdrs[i]->refno);
         ret = pop_query(pop_data, buf, sizeof(buf));
         if (ret == 0)
         {
          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);
 #ifdef USE_HCACHE
           mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));
 #endif
        }
      }

#ifdef USE_HCACHE
      if (ctx->hdrs[i]->changed)
      {
        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),
                          ctx->hdrs[i], 0);
      }
#endif
    }

#ifdef USE_HCACHE
    mutt_hcache_close(hc);
#endif

    if (ret == 0)
    {
      mutt_str_strfcpy(buf, ""QUIT\r\n"", sizeof(buf));
      ret = pop_query(pop_data, buf, sizeof(buf));
    }

    if (ret == 0)
    {
      pop_data->clear_cache = true;
      pop_clear_cache(pop_data);
      pop_data->status = POP_DISCONNECTED;
      return 0;
    }

    if (ret == -2)
    {
      mutt_error(""%s"", pop_data->err_msg);
      return -1;
    }
  }
}
",C,"          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));
","          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);
",,"@@ -63,6 +63,23 @@
 #define HC_FEXT ""hcache""   /* extension for hcache as POP lacks paths */
 #endif
 
+/**
+ * cache_id - Make a message-cache-compatible id
+ * @param id POP message id
+ * @retval ptr Sanitised string
+ *
+ * The POP message id may contain '/' and other awkward characters.
+ *
+ * @note This function returns a pointer to a static buffer.
+ */
+static const char *cache_id(const char *id)
+{
+  static char clean[SHORT_STRING];
+  mutt_str_strfcpy(clean, id, sizeof(clean));
+  mutt_file_sanitize_filename(clean, true);
+  return clean;
+}
+
 /**
  * fetch_message - write line to file
  * @param line String to write
@@ -242,7 +259,7 @@ static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)
   /* message not found in context -> remove it from cache
    * return the result of bcache, so we stop upon its first error
    */
-  return mutt_bcache_del(bcache, id);
+  return mutt_bcache_del(bcache, cache_id(id));
 }
 
 #ifdef USE_HCACHE
@@ -407,7 +424,7 @@ static int pop_fetch_headers(struct Context *ctx)
        *        - if we don't have a body: new
        */
       const bool bcached =
-          (mutt_bcache_exists(pop_data->bcache, ctx->hdrs[i]->data) == 0);
+          (mutt_bcache_exists(pop_data->bcache, cache_id(ctx->hdrs[i]->data)) == 0);
       ctx->hdrs[i]->old = false;
       ctx->hdrs[i]->read = false;
       if (hcached)
@@ -597,7 +614,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno
   unsigned short bcache = 1;
 
   /* see if we already have the message in body cache */
-  msg->fp = mutt_bcache_get(pop_data->bcache, h->data);
+  msg->fp = mutt_bcache_get(pop_data->bcache, cache_id(h->data));
   if (msg->fp)
     return 0;
 
@@ -644,7 +661,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno
                        NetInc, h->content->length + h->content->offset - 1);
 
     /* see if we can put in body cache; use our cache as fallback */
-    msg->fp = mutt_bcache_put(pop_data->bcache, h->data);
+    msg->fp = mutt_bcache_put(pop_data->bcache, cache_id(h->data));
     if (!msg->fp)
     {
       /* no */
@@ -689,7 +706,7 @@ static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno
    * portion of the headers, those required for the main display.
    */
   if (bcache)
-    mutt_bcache_commit(pop_data->bcache, h->data);
+    mutt_bcache_commit(pop_data->bcache, cache_id(h->data));
   else
   {
     cache->index = h->index;
@@ -783,7 +800,7 @@ static int pop_sync_mailbox(struct Context *ctx, int *index_hint)
         ret = pop_query(pop_data, buf, sizeof(buf));
         if (ret == 0)
         {
-          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);
+          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));
 #ifdef USE_HCACHE
           mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));
 #endif",neomutt,9bfab35522301794483f8f9ed60820bdec9be59e,98aad9c3f1fb281e35a966d4a9b01b60db402e7a,1,"static int pop_sync_mailbox(struct Context *ctx, int *index_hint)
{
  int i, j, ret = 0;
  char buf[LONG_STRING];
  struct PopData *pop_data = (struct PopData *) ctx->data;
  struct Progress progress;
#ifdef USE_HCACHE
  header_cache_t *hc = NULL;
#endif

  pop_data->check_time = 0;

  while (true)
  {
    if (pop_reconnect(ctx) < 0)
      return -1;

    mutt_progress_init(&progress, _(""Marking messages deleted...""),
                       MUTT_PROGRESS_MSG, WriteInc, ctx->deleted);

#ifdef USE_HCACHE
    hc = pop_hcache_open(pop_data, ctx->path);
#endif

    for (i = 0, j = 0, ret = 0; ret == 0 && i < ctx->msgcount; i++)
    {
      if (ctx->hdrs[i]->deleted && ctx->hdrs[i]->refno != -1)
      {
        j++;
        if (!ctx->quiet)
          mutt_progress_update(&progress, j, -1);
        snprintf(buf, sizeof(buf), ""DELE %d\r\n"", ctx->hdrs[i]->refno);
         ret = pop_query(pop_data, buf, sizeof(buf));
         if (ret == 0)
         {
//flaw_line_below:
          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);
//fix_flaw_line_below:
//          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));
 #ifdef USE_HCACHE
           mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));
 #endif
        }
      }

#ifdef USE_HCACHE
      if (ctx->hdrs[i]->changed)
      {
        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),
                          ctx->hdrs[i], 0);
      }
#endif
    }

#ifdef USE_HCACHE
    mutt_hcache_close(hc);
#endif

    if (ret == 0)
    {
      mutt_str_strfcpy(buf, ""QUIT\r\n"", sizeof(buf));
      ret = pop_query(pop_data, buf, sizeof(buf));
    }

    if (ret == 0)
    {
      pop_data->clear_cache = true;
      pop_clear_cache(pop_data);
      pop_data->status = POP_DISCONNECTED;
      return 0;
    }

    if (ret == -2)
    {
      mutt_error(""%s"", pop_data->err_msg);
      return -1;
    }
  }
}
"
7152,184888,,Remote,Not required,Partial,CVE-2013-2900,https://www.cvedetails.com/cve/CVE-2013-2900/,CWE-22,Low,Partial,Partial,,2013-08-21,7.5,"The FilePath::ReferencesParent function in files/file_path.cc in Google Chrome before 29.0.1547.57 on Windows does not properly handle pathname components composed entirely of . (dot) and whitespace characters, which allows remote attackers to conduct directory traversal attacks via a crafted directory name.",2017-09-18,Dir. Trav. ,3,https://github.com/chromium/chromium/commit/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337,bd3392a1f8b95bf0b0ee3821bc3245d743fb1337,"AX: Calendar Picker: Add AX labels to MonthPopupButton and CalendarNavigationButtons.

This CL adds no new tests. Will add tests after a Chromium change for
string resource.

BUG=123896

Review URL: https://codereview.chromium.org/552163002

git-svn-id: svn://svn.chromium.org/blink/trunk@181617 bbb929c8-8fbe-4397-9dbb-9b2b20218538",0,third_party/WebKit/Source/web/DateTimeChooserImpl.cpp,"{""sha"": ""12cccdfa59676411125945dcd7aa13898fc408e2"", ""filename"": ""third_party/WebKit/ManualTests/forms/calendar-picker.html"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/ManualTests/forms/calendar-picker.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/ManualTests/forms/calendar-picker.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/ManualTests/forms/calendar-picker.html?ref=bd3392a1f8b95bf0b0ee3821bc3245d743fb1337"", ""patch"": ""@@ -269,7 +269,11 @@ <h2>Config</h2>\n         min: config.min,\n         step: config.step * (config.type === \""month\"" ? 1 : 86400000),\n         stepBase: \""0\"",\n-        currentValue: config.value\n+        currentValue: config.value,\n+        axShowMonthSelector: \""Show month selection panel\"",\n+        axShowNextMonth: \""Show next month\"",\n+        axShowPreviousMonth: \""Show previous month\"",\n+        todayLabel: \""Today\"",\n     }\n };\n ""}<_**next**_>{""sha"": ""1cdb077dea9cd61af7c69ae482e4c0cfe9253113"", ""filename"": ""third_party/WebKit/Source/web/DateTimeChooserImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/Source/web/DateTimeChooserImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/Source/web/DateTimeChooserImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/web/DateTimeChooserImpl.cpp?ref=bd3392a1f8b95bf0b0ee3821bc3245d743fb1337"", ""patch"": ""@@ -138,6 +138,9 @@ void DateTimeChooserImpl::writeDocument(SharedBuffer* data)\n     addProperty(\""todayLabel\"", todayLabelString, data);\n     addProperty(\""clearLabel\"", locale().queryString(WebLocalizedString::CalendarClear), data);\n     addProperty(\""weekLabel\"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);\n+    addProperty(\""axShowMonthSelector\"", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);\n+    addProperty(\""axShowNextMonth\"", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);\n+    addProperty(\""axShowPreviousMonth\"", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);\n     addProperty(\""weekStartDay\"", m_locale->firstDayOfWeek(), data);\n     addProperty(\""shortMonthLabels\"", m_locale->shortMonthLabels(), data);\n     addProperty(\""dayLabels\"", m_locale->weekDayShortLabels(), data);""}<_**next**_>{""sha"": ""2459e401c4237a186e0039c67c54ad271412b12d"", ""filename"": ""third_party/WebKit/Source/web/resources/calendarPicker.js"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/Source/web/resources/calendarPicker.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/Source/web/resources/calendarPicker.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/web/resources/calendarPicker.js?ref=bd3392a1f8b95bf0b0ee3821bc3245d743fb1337"", ""patch"": ""@@ -2763,6 +2763,7 @@ MonthPopupView.prototype.onClick = function(event) {\n  */\n function MonthPopupButton(maxWidth) {\n     View.call(this, createElement(\""button\"", MonthPopupButton.ClassNameMonthPopupButton));\n+    this.element.setAttribute(\""aria-label\"", global.params.axShowMonthSelector);\n \n     /**\n      * @type {!Element}\n@@ -2951,6 +2952,7 @@ function CalendarHeaderView(calendarPicker) {\n     this._previousMonthButton.attachTo(this);\n     this._previousMonthButton.on(CalendarNavigationButton.EventTypeButtonClick, this.onNavigationButtonClick);\n     this._previousMonthButton.on(CalendarNavigationButton.EventTypeRepeatingButtonClick, this.onNavigationButtonClick);\n+    this._previousMonthButton.element.setAttribute(\""aria-label\"", global.params.axShowPreviousMonth);\n \n     /**\n      * @type {!CalendarNavigationButton}\n@@ -2962,6 +2964,7 @@ function CalendarHeaderView(calendarPicker) {\n     this._todayButton.element.classList.add(CalendarHeaderView.ClassNameTodayButton);\n     var monthContainingToday = Month.createFromToday();\n     this._todayButton.setDisabled(monthContainingToday < this.calendarPicker.minimumMonth || monthContainingToday > this.calendarPicker.maximumMonth);\n+    this._todayButton.element.setAttribute(\""aria-label\"", global.params.todayLabel);\n \n     /**\n      * @type {!CalendarNavigationButton}\n@@ -2971,6 +2974,7 @@ function CalendarHeaderView(calendarPicker) {\n     this._nextMonthButton.attachTo(this);\n     this._nextMonthButton.on(CalendarNavigationButton.EventTypeButtonClick, this.onNavigationButtonClick);\n     this._nextMonthButton.on(CalendarNavigationButton.EventTypeRepeatingButtonClick, this.onNavigationButtonClick);\n+    this._nextMonthButton.element.setAttribute(\""aria-label\"", global.params.axShowNextMonth);\n \n     if (global.params.isLocaleRTL) {\n         this._nextMonthButton.element.innerHTML = CalendarHeaderView._BackwardTriangle;""}<_**next**_>{""sha"": ""d2cc50cce3d1f450b6e1e35ca03a41d25518be8c"", ""filename"": ""third_party/WebKit/public/platform/WebLocalizedString.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/public/platform/WebLocalizedString.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/public/platform/WebLocalizedString.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/public/platform/WebLocalizedString.h?ref=bd3392a1f8b95bf0b0ee3821bc3245d743fb1337"", ""patch"": ""@@ -37,6 +37,9 @@ struct WebLocalizedString {\n     enum Name {\n         AXAMPMFieldText,\n         AXButtonActionVerb,\n+        AXCalendarShowMonthSelector,\n+        AXCalendarShowNextMonth,\n+        AXCalendarShowPreviousMonth,\n         AXCheckedCheckBoxActionVerb,\n         AXDateTimeFieldEmptyValueText,\n         AXDayOfMonthFieldText,""}","void DateTimeChooserImpl::writeDocument(SharedBuffer* data)
{
    String stepString = String::number(m_parameters.step);
    String stepBaseString = String::number(m_parameters.stepBase, 11, WTF::TruncateTrailingZeros);
    IntRect anchorRectInScreen = m_chromeClient->rootViewToScreen(m_parameters.anchorRectInRootView);
    String todayLabelString;
    String otherDateLabelString;
    if (m_parameters.type == InputTypeNames::month) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisMonthButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherMonthLabel);
    } else if (m_parameters.type == InputTypeNames::week) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisWeekButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherWeekLabel);
    } else {
        todayLabelString = locale().queryString(WebLocalizedString::CalendarToday);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherDateLabel);
    }

    addString(""<!DOCTYPE html><head><meta charset='UTF-8'><style>\n"", data);
    data->append(Platform::current()->loadResource(""pickerCommon.css""));
    data->append(Platform::current()->loadResource(""pickerButton.css""));
    data->append(Platform::current()->loadResource(""suggestionPicker.css""));
    data->append(Platform::current()->loadResource(""calendarPicker.css""));
    addString(""</style></head><body><div id=main>Loading...</div><script>\n""
        ""window.dialogArguments = {\n"", data);
    addProperty(""anchorRectInScreen"", anchorRectInScreen, data);
    addProperty(""min"", valueToDateTimeString(m_parameters.minimum, m_parameters.type), data);
    addProperty(""max"", valueToDateTimeString(m_parameters.maximum, m_parameters.type), data);
    addProperty(""step"", stepString, data);
    addProperty(""stepBase"", stepBaseString, data);
    addProperty(""required"", m_parameters.required, data);
    addProperty(""currentValue"", valueToDateTimeString(m_parameters.doubleValue, m_parameters.type), data);
    addProperty(""locale"", m_parameters.locale.string(), data);
     addProperty(""todayLabel"", todayLabelString, data);
     addProperty(""clearLabel"", locale().queryString(WebLocalizedString::CalendarClear), data);
     addProperty(""weekLabel"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);
    addProperty(""axShowMonthSelector"", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);
    addProperty(""axShowNextMonth"", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);
    addProperty(""axShowPreviousMonth"", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);
     addProperty(""weekStartDay"", m_locale->firstDayOfWeek(), data);
     addProperty(""shortMonthLabels"", m_locale->shortMonthLabels(), data);
     addProperty(""dayLabels"", m_locale->weekDayShortLabels(), data);
    addProperty(""isLocaleRTL"", m_locale->isRTL(), data);
    addProperty(""isRTL"", m_parameters.isAnchorElementRTL, data);
    addProperty(""mode"", m_parameters.type.string(), data);
    if (m_parameters.suggestions.size()) {
        Vector<String> suggestionValues;
        Vector<String> localizedSuggestionValues;
        Vector<String> suggestionLabels;
        for (unsigned i = 0; i < m_parameters.suggestions.size(); i++) {
            suggestionValues.append(valueToDateTimeString(m_parameters.suggestions[i].value, m_parameters.type));
            localizedSuggestionValues.append(m_parameters.suggestions[i].localizedValue);
            suggestionLabels.append(m_parameters.suggestions[i].label);
        }
        addProperty(""suggestionValues"", suggestionValues, data);
        addProperty(""localizedSuggestionValues"", localizedSuggestionValues, data);
        addProperty(""suggestionLabels"", suggestionLabels, data);
        addProperty(""inputWidth"", static_cast<unsigned>(m_parameters.anchorRectInRootView.width()), data);
        addProperty(""showOtherDateEntry"", RenderTheme::theme().supportsCalendarPicker(m_parameters.type), data);
        addProperty(""otherDateLabel"", otherDateLabelString, data);
        addProperty(""suggestionHighlightColor"", RenderTheme::theme().activeListBoxSelectionBackgroundColor().serialized(), data);
        addProperty(""suggestionHighlightTextColor"", RenderTheme::theme().activeListBoxSelectionForegroundColor().serialized(), data);
    }
    addString(""}\n"", data);

    data->append(Platform::current()->loadResource(""pickerCommon.js""));
    data->append(Platform::current()->loadResource(""suggestionPicker.js""));
    data->append(Platform::current()->loadResource(""calendarPicker.js""));
    addString(""</script></body>\n"", data);
}
","void DateTimeChooserImpl::writeDocument(SharedBuffer* data)
{
    String stepString = String::number(m_parameters.step);
    String stepBaseString = String::number(m_parameters.stepBase, 11, WTF::TruncateTrailingZeros);
    IntRect anchorRectInScreen = m_chromeClient->rootViewToScreen(m_parameters.anchorRectInRootView);
    String todayLabelString;
    String otherDateLabelString;
    if (m_parameters.type == InputTypeNames::month) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisMonthButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherMonthLabel);
    } else if (m_parameters.type == InputTypeNames::week) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisWeekButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherWeekLabel);
    } else {
        todayLabelString = locale().queryString(WebLocalizedString::CalendarToday);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherDateLabel);
    }

    addString(""<!DOCTYPE html><head><meta charset='UTF-8'><style>\n"", data);
    data->append(Platform::current()->loadResource(""pickerCommon.css""));
    data->append(Platform::current()->loadResource(""pickerButton.css""));
    data->append(Platform::current()->loadResource(""suggestionPicker.css""));
    data->append(Platform::current()->loadResource(""calendarPicker.css""));
    addString(""</style></head><body><div id=main>Loading...</div><script>\n""
        ""window.dialogArguments = {\n"", data);
    addProperty(""anchorRectInScreen"", anchorRectInScreen, data);
    addProperty(""min"", valueToDateTimeString(m_parameters.minimum, m_parameters.type), data);
    addProperty(""max"", valueToDateTimeString(m_parameters.maximum, m_parameters.type), data);
    addProperty(""step"", stepString, data);
    addProperty(""stepBase"", stepBaseString, data);
    addProperty(""required"", m_parameters.required, data);
    addProperty(""currentValue"", valueToDateTimeString(m_parameters.doubleValue, m_parameters.type), data);
    addProperty(""locale"", m_parameters.locale.string(), data);
     addProperty(""todayLabel"", todayLabelString, data);
     addProperty(""clearLabel"", locale().queryString(WebLocalizedString::CalendarClear), data);
     addProperty(""weekLabel"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);
     addProperty(""weekStartDay"", m_locale->firstDayOfWeek(), data);
     addProperty(""shortMonthLabels"", m_locale->shortMonthLabels(), data);
     addProperty(""dayLabels"", m_locale->weekDayShortLabels(), data);
    addProperty(""isLocaleRTL"", m_locale->isRTL(), data);
    addProperty(""isRTL"", m_parameters.isAnchorElementRTL, data);
    addProperty(""mode"", m_parameters.type.string(), data);
    if (m_parameters.suggestions.size()) {
        Vector<String> suggestionValues;
        Vector<String> localizedSuggestionValues;
        Vector<String> suggestionLabels;
        for (unsigned i = 0; i < m_parameters.suggestions.size(); i++) {
            suggestionValues.append(valueToDateTimeString(m_parameters.suggestions[i].value, m_parameters.type));
            localizedSuggestionValues.append(m_parameters.suggestions[i].localizedValue);
            suggestionLabels.append(m_parameters.suggestions[i].label);
        }
        addProperty(""suggestionValues"", suggestionValues, data);
        addProperty(""localizedSuggestionValues"", localizedSuggestionValues, data);
        addProperty(""suggestionLabels"", suggestionLabels, data);
        addProperty(""inputWidth"", static_cast<unsigned>(m_parameters.anchorRectInRootView.width()), data);
        addProperty(""showOtherDateEntry"", RenderTheme::theme().supportsCalendarPicker(m_parameters.type), data);
        addProperty(""otherDateLabel"", otherDateLabelString, data);
        addProperty(""suggestionHighlightColor"", RenderTheme::theme().activeListBoxSelectionBackgroundColor().serialized(), data);
        addProperty(""suggestionHighlightTextColor"", RenderTheme::theme().activeListBoxSelectionForegroundColor().serialized(), data);
    }
    addString(""}\n"", data);

    data->append(Platform::current()->loadResource(""pickerCommon.js""));
    data->append(Platform::current()->loadResource(""suggestionPicker.js""));
    data->append(Platform::current()->loadResource(""calendarPicker.js""));
    addString(""</script></body>\n"", data);
}
",C,"    addProperty(""axShowMonthSelector"", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);
    addProperty(""axShowNextMonth"", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);
    addProperty(""axShowPreviousMonth"", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);
",,,"@@ -138,6 +138,9 @@ void DateTimeChooserImpl::writeDocument(SharedBuffer* data)
     addProperty(""todayLabel"", todayLabelString, data);
     addProperty(""clearLabel"", locale().queryString(WebLocalizedString::CalendarClear), data);
     addProperty(""weekLabel"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);
+    addProperty(""axShowMonthSelector"", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);
+    addProperty(""axShowNextMonth"", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);
+    addProperty(""axShowPreviousMonth"", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);
     addProperty(""weekStartDay"", m_locale->firstDayOfWeek(), data);
     addProperty(""shortMonthLabels"", m_locale->shortMonthLabels(), data);
     addProperty(""dayLabels"", m_locale->weekDayShortLabels(), data);",Chrome,bd3392a1f8b95bf0b0ee3821bc3245d743fb1337,8a2c034f43ae98cc6a429f91dd1d16fc3fe331c9,1,"void DateTimeChooserImpl::writeDocument(SharedBuffer* data)
{
    String stepString = String::number(m_parameters.step);
    String stepBaseString = String::number(m_parameters.stepBase, 11, WTF::TruncateTrailingZeros);
    IntRect anchorRectInScreen = m_chromeClient->rootViewToScreen(m_parameters.anchorRectInRootView);
    String todayLabelString;
    String otherDateLabelString;
    if (m_parameters.type == InputTypeNames::month) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisMonthButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherMonthLabel);
    } else if (m_parameters.type == InputTypeNames::week) {
        todayLabelString = locale().queryString(WebLocalizedString::ThisWeekButtonLabel);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherWeekLabel);
    } else {
        todayLabelString = locale().queryString(WebLocalizedString::CalendarToday);
        otherDateLabelString = locale().queryString(WebLocalizedString::OtherDateLabel);
    }

    addString(""<!DOCTYPE html><head><meta charset='UTF-8'><style>\n"", data);
    data->append(Platform::current()->loadResource(""pickerCommon.css""));
    data->append(Platform::current()->loadResource(""pickerButton.css""));
    data->append(Platform::current()->loadResource(""suggestionPicker.css""));
    data->append(Platform::current()->loadResource(""calendarPicker.css""));
    addString(""</style></head><body><div id=main>Loading...</div><script>\n""
        ""window.dialogArguments = {\n"", data);
    addProperty(""anchorRectInScreen"", anchorRectInScreen, data);
    addProperty(""min"", valueToDateTimeString(m_parameters.minimum, m_parameters.type), data);
    addProperty(""max"", valueToDateTimeString(m_parameters.maximum, m_parameters.type), data);
    addProperty(""step"", stepString, data);
    addProperty(""stepBase"", stepBaseString, data);
    addProperty(""required"", m_parameters.required, data);
    addProperty(""currentValue"", valueToDateTimeString(m_parameters.doubleValue, m_parameters.type), data);
    addProperty(""locale"", m_parameters.locale.string(), data);
     addProperty(""todayLabel"", todayLabelString, data);
     addProperty(""clearLabel"", locale().queryString(WebLocalizedString::CalendarClear), data);
     addProperty(""weekLabel"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);
//fix_flaw_line_below:
//    addProperty(""axShowMonthSelector"", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);
//fix_flaw_line_below:
//    addProperty(""axShowNextMonth"", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);
//fix_flaw_line_below:
//    addProperty(""axShowPreviousMonth"", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);
     addProperty(""weekStartDay"", m_locale->firstDayOfWeek(), data);
     addProperty(""shortMonthLabels"", m_locale->shortMonthLabels(), data);
     addProperty(""dayLabels"", m_locale->weekDayShortLabels(), data);
    addProperty(""isLocaleRTL"", m_locale->isRTL(), data);
    addProperty(""isRTL"", m_parameters.isAnchorElementRTL, data);
    addProperty(""mode"", m_parameters.type.string(), data);
    if (m_parameters.suggestions.size()) {
        Vector<String> suggestionValues;
        Vector<String> localizedSuggestionValues;
        Vector<String> suggestionLabels;
        for (unsigned i = 0; i < m_parameters.suggestions.size(); i++) {
            suggestionValues.append(valueToDateTimeString(m_parameters.suggestions[i].value, m_parameters.type));
            localizedSuggestionValues.append(m_parameters.suggestions[i].localizedValue);
            suggestionLabels.append(m_parameters.suggestions[i].label);
        }
        addProperty(""suggestionValues"", suggestionValues, data);
        addProperty(""localizedSuggestionValues"", localizedSuggestionValues, data);
        addProperty(""suggestionLabels"", suggestionLabels, data);
        addProperty(""inputWidth"", static_cast<unsigned>(m_parameters.anchorRectInRootView.width()), data);
        addProperty(""showOtherDateEntry"", RenderTheme::theme().supportsCalendarPicker(m_parameters.type), data);
        addProperty(""otherDateLabel"", otherDateLabelString, data);
        addProperty(""suggestionHighlightColor"", RenderTheme::theme().activeListBoxSelectionBackgroundColor().serialized(), data);
        addProperty(""suggestionHighlightTextColor"", RenderTheme::theme().activeListBoxSelectionForegroundColor().serialized(), data);
    }
    addString(""}\n"", data);

    data->append(Platform::current()->loadResource(""pickerCommon.js""));
    data->append(Platform::current()->loadResource(""suggestionPicker.js""));
    data->append(Platform::current()->loadResource(""calendarPicker.js""));
    addString(""</script></body>\n"", data);
}
"
7371,185107,,Remote,Not required,Partial,CVE-2013-0895,https://www.cvedetails.com/cve/CVE-2013-0895/,CWE-22,Low,Partial,Partial,,2013-02-23,7.5,"Google Chrome before 25.0.1364.97 on Linux, and before 25.0.1364.99 on Mac OS X, does not properly handle pathnames during copy operations, which might make it easier for remote attackers to execute arbitrary programs via unspecified vectors.",2013-09-30,Dir. Trav. ,8,https://github.com/chromium/chromium/commit/23803a58e481e464a787e4b2c461af9e62f03905,23803a58e481e464a787e4b2c461af9e62f03905,"Fix creating target paths in file_util_posix CopyDirectory.

BUG=167840


Review URL: https://chromiumcodereview.appspot.com/11773018

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@176659 0039d316-1c4b-4281-b951-d872f2087c98",5,base/file_util_posix.cc,"{""sha"": ""95ffb42f7dd5a7d66812b84292c84f9cc2dcf35f"", ""filename"": ""base/file_util_posix.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/23803a58e481e464a787e4b2c461af9e62f03905/base/file_util_posix.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/23803a58e481e464a787e4b2c461af9e62f03905/base/file_util_posix.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/file_util_posix.cc?ref=23803a58e481e464a787e4b2c461af9e62f03905"", ""patch"": ""@@ -343,15 +343,15 @@ bool CopyDirectory(const FilePath& from_path,\n   DCHECK(recursive || S_ISDIR(info.stat.st_mode));\n \n   while (success && !current.empty()) {\n-    // current is the source path, including from_path, so paste\n-    // the suffix after from_path onto to_path to create the target_path.\n-    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);\n-    // Strip the leading '/' (if any).\n-    if (!suffix.empty()) {\n-      DCHECK_EQ('/', suffix[0]);\n-      suffix.erase(0, 1);\n+    // current is the source path, including from_path, so append\n+    // the suffix after from_path to to_path to create the target_path.\n+    FilePath target_path(to_path);\n+    if (from_path_base != current) {\n+      if (!from_path_base.AppendRelativePath(current, &target_path)) {\n+        success = false;\n+        break;\n+      }\n     }\n-    const FilePath target_path = to_path.Append(suffix);\n \n     if (S_ISDIR(info.stat.st_mode)) {\n       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&""}<_**next**_>{""sha"": ""c1006e1304c205c52a7e58b38e9d7e8ade80e60d"", ""filename"": ""base/file_util_unittest.cc"", ""status"": ""modified"", ""additions"": 37, ""deletions"": 0, ""changes"": 37, ""blob_url"": ""https://github.com/chromium/chromium/blob/23803a58e481e464a787e4b2c461af9e62f03905/base/file_util_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/23803a58e481e464a787e4b2c461af9e62f03905/base/file_util_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/file_util_unittest.cc?ref=23803a58e481e464a787e4b2c461af9e62f03905"", ""patch"": ""@@ -1466,6 +1466,43 @@ TEST_F(FileUtilTest, CopyFileWithCopyDirectoryRecursiveToExistingDirectory) {\n   EXPECT_TRUE(file_util::PathExists(file_name_to));\n }\n \n+TEST_F(FileUtilTest, CopyDirectoryWithTrailingSeparators) {\n+  // Create a directory.\n+  FilePath dir_name_from =\n+      temp_dir_.path().Append(FILE_PATH_LITERAL(\""Copy_From_Subdir\""));\n+  file_util::CreateDirectory(dir_name_from);\n+  ASSERT_TRUE(file_util::PathExists(dir_name_from));\n+\n+  // Create a file under the directory.\n+  FilePath file_name_from =\n+      dir_name_from.Append(FILE_PATH_LITERAL(\""Copy_Test_File.txt\""));\n+  CreateTextFile(file_name_from, L\""Gooooooooooooooooooooogle\"");\n+  ASSERT_TRUE(file_util::PathExists(file_name_from));\n+\n+  // Copy the directory recursively.\n+  FilePath dir_name_to =\n+      temp_dir_.path().Append(FILE_PATH_LITERAL(\""Destination\""));\n+  FilePath file_name_to =\n+      dir_name_to.Append(FILE_PATH_LITERAL(\""Copy_Test_File.txt\""));\n+\n+  // Create from path with trailing separators.\n+#if defined(OS_WIN)\n+  FilePath from_path =\n+      temp_dir_.path().Append(FILE_PATH_LITERAL(\""Copy_From_Subdir\\\\\\\\\\\\\""));\n+#elif defined(OS_POSIX)\n+  FilePath from_path =\n+      temp_dir_.path().Append(FILE_PATH_LITERAL(\""Copy_From_Subdir///\""));\n+#endif\n+\n+  EXPECT_TRUE(file_util::CopyDirectory(from_path, dir_name_to, true));\n+\n+  // Check everything has been copied.\n+  EXPECT_TRUE(file_util::PathExists(dir_name_from));\n+  EXPECT_TRUE(file_util::PathExists(file_name_from));\n+  EXPECT_TRUE(file_util::PathExists(dir_name_to));\n+  EXPECT_TRUE(file_util::PathExists(file_name_to));\n+}\n+\n TEST_F(FileUtilTest, CopyFile) {\n   // Create a directory\n   FilePath dir_name_from =""}","bool CopyDirectory(const FilePath& from_path,
                   const FilePath& to_path,
                   bool recursive) {
  base::ThreadRestrictions::AssertIOAllowed();
  DCHECK(to_path.value().find('*') == std::string::npos);
  DCHECK(from_path.value().find('*') == std::string::npos);

  char top_dir[PATH_MAX];
  if (base::strlcpy(top_dir, from_path.value().c_str(),
                    arraysize(top_dir)) >= arraysize(top_dir)) {
    return false;
  }

  FilePath real_to_path = to_path;
  if (PathExists(real_to_path)) {
    if (!AbsolutePath(&real_to_path))
      return false;
  } else {
    real_to_path = real_to_path.DirName();
    if (!AbsolutePath(&real_to_path))
      return false;
  }
  FilePath real_from_path = from_path;
  if (!AbsolutePath(&real_from_path))
    return false;
  if (real_to_path.value().size() >= real_from_path.value().size() &&
      real_to_path.value().compare(0, real_from_path.value().size(),
      real_from_path.value()) == 0)
    return false;

  bool success = true;
  int traverse_type = FileEnumerator::FILES | FileEnumerator::SHOW_SYM_LINKS;
  if (recursive)
    traverse_type |= FileEnumerator::DIRECTORIES;
  FileEnumerator traversal(from_path, recursive, traverse_type);

  FileEnumerator::FindInfo info;
  FilePath current = from_path;
  if (stat(from_path.value().c_str(), &info.stat) < 0) {
    DLOG(ERROR) << ""CopyDirectory() couldn't stat source directory: ""
                << from_path.value() << "" errno = "" << errno;
    success = false;
  }
  struct stat to_path_stat;
  FilePath from_path_base = from_path;
  if (recursive && stat(to_path.value().c_str(), &to_path_stat) == 0 &&
      S_ISDIR(to_path_stat.st_mode)) {
    from_path_base = from_path.DirName();
  }

   DCHECK(recursive || S_ISDIR(info.stat.st_mode));
 
   while (success && !current.empty()) {
    // current is the source path, including from_path, so append
    // the suffix after from_path to to_path to create the target_path.
    FilePath target_path(to_path);
    if (from_path_base != current) {
      if (!from_path_base.AppendRelativePath(current, &target_path)) {
        success = false;
        break;
      }
     }
 
     if (S_ISDIR(info.stat.st_mode)) {
       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&
          errno != EEXIST) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create directory: ""
                    << target_path.value() << "" errno = "" << errno;
        success = false;
      }
    } else if (S_ISREG(info.stat.st_mode)) {
      if (!CopyFile(current, target_path)) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create file: ""
                    << target_path.value();
        success = false;
      }
    } else {
      DLOG(WARNING) << ""CopyDirectory() skipping non-regular file: ""
                    << current.value();
    }

    current = traversal.Next();
    traversal.GetFindInfo(&info);
  }

  return success;
}
","bool CopyDirectory(const FilePath& from_path,
                   const FilePath& to_path,
                   bool recursive) {
  base::ThreadRestrictions::AssertIOAllowed();
  DCHECK(to_path.value().find('*') == std::string::npos);
  DCHECK(from_path.value().find('*') == std::string::npos);

  char top_dir[PATH_MAX];
  if (base::strlcpy(top_dir, from_path.value().c_str(),
                    arraysize(top_dir)) >= arraysize(top_dir)) {
    return false;
  }

  FilePath real_to_path = to_path;
  if (PathExists(real_to_path)) {
    if (!AbsolutePath(&real_to_path))
      return false;
  } else {
    real_to_path = real_to_path.DirName();
    if (!AbsolutePath(&real_to_path))
      return false;
  }
  FilePath real_from_path = from_path;
  if (!AbsolutePath(&real_from_path))
    return false;
  if (real_to_path.value().size() >= real_from_path.value().size() &&
      real_to_path.value().compare(0, real_from_path.value().size(),
      real_from_path.value()) == 0)
    return false;

  bool success = true;
  int traverse_type = FileEnumerator::FILES | FileEnumerator::SHOW_SYM_LINKS;
  if (recursive)
    traverse_type |= FileEnumerator::DIRECTORIES;
  FileEnumerator traversal(from_path, recursive, traverse_type);

  FileEnumerator::FindInfo info;
  FilePath current = from_path;
  if (stat(from_path.value().c_str(), &info.stat) < 0) {
    DLOG(ERROR) << ""CopyDirectory() couldn't stat source directory: ""
                << from_path.value() << "" errno = "" << errno;
    success = false;
  }
  struct stat to_path_stat;
  FilePath from_path_base = from_path;
  if (recursive && stat(to_path.value().c_str(), &to_path_stat) == 0 &&
      S_ISDIR(to_path_stat.st_mode)) {
    from_path_base = from_path.DirName();
  }

   DCHECK(recursive || S_ISDIR(info.stat.st_mode));
 
   while (success && !current.empty()) {
    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);
    if (!suffix.empty()) {
      DCHECK_EQ('/', suffix[0]);
      suffix.erase(0, 1);
     }
    const FilePath target_path = to_path.Append(suffix);
 
     if (S_ISDIR(info.stat.st_mode)) {
       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&
          errno != EEXIST) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create directory: ""
                    << target_path.value() << "" errno = "" << errno;
        success = false;
      }
    } else if (S_ISREG(info.stat.st_mode)) {
      if (!CopyFile(current, target_path)) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create file: ""
                    << target_path.value();
        success = false;
      }
    } else {
      DLOG(WARNING) << ""CopyDirectory() skipping non-regular file: ""
                    << current.value();
    }

    current = traversal.Next();
    traversal.GetFindInfo(&info);
  }

  return success;
}
",C,"    // current is the source path, including from_path, so append
    // the suffix after from_path to to_path to create the target_path.
    FilePath target_path(to_path);
    if (from_path_base != current) {
      if (!from_path_base.AppendRelativePath(current, &target_path)) {
        success = false;
        break;
      }
","    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);
    if (!suffix.empty()) {
      DCHECK_EQ('/', suffix[0]);
      suffix.erase(0, 1);
    const FilePath target_path = to_path.Append(suffix);
",,"@@ -343,15 +343,15 @@ bool CopyDirectory(const FilePath& from_path,
   DCHECK(recursive || S_ISDIR(info.stat.st_mode));
 
   while (success && !current.empty()) {
-    // current is the source path, including from_path, so paste
-    // the suffix after from_path onto to_path to create the target_path.
-    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);
-    // Strip the leading '/' (if any).
-    if (!suffix.empty()) {
-      DCHECK_EQ('/', suffix[0]);
-      suffix.erase(0, 1);
+    // current is the source path, including from_path, so append
+    // the suffix after from_path to to_path to create the target_path.
+    FilePath target_path(to_path);
+    if (from_path_base != current) {
+      if (!from_path_base.AppendRelativePath(current, &target_path)) {
+        success = false;
+        break;
+      }
     }
-    const FilePath target_path = to_path.Append(suffix);
 
     if (S_ISDIR(info.stat.st_mode)) {
       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&",Chrome,23803a58e481e464a787e4b2c461af9e62f03905,0297467c47dfe10b7b3495f57b2e1515cfcec55d,1,"bool CopyDirectory(const FilePath& from_path,
                   const FilePath& to_path,
                   bool recursive) {
  base::ThreadRestrictions::AssertIOAllowed();
  // Some old callers of CopyDirectory want it to support wildcards.
  // After some discussion, we decided to fix those callers.
  // Break loudly here if anyone tries to do this.
  // TODO(evanm): remove this once we're sure it's ok.
  DCHECK(to_path.value().find('*') == std::string::npos);
  DCHECK(from_path.value().find('*') == std::string::npos);

  char top_dir[PATH_MAX];
  if (base::strlcpy(top_dir, from_path.value().c_str(),
                    arraysize(top_dir)) >= arraysize(top_dir)) {
    return false;
  }

  // This function does not properly handle destinations within the source
  FilePath real_to_path = to_path;
  if (PathExists(real_to_path)) {
    if (!AbsolutePath(&real_to_path))
      return false;
  } else {
    real_to_path = real_to_path.DirName();
    if (!AbsolutePath(&real_to_path))
      return false;
  }
  FilePath real_from_path = from_path;
  if (!AbsolutePath(&real_from_path))
    return false;
  if (real_to_path.value().size() >= real_from_path.value().size() &&
      real_to_path.value().compare(0, real_from_path.value().size(),
      real_from_path.value()) == 0)
    return false;

  bool success = true;
  int traverse_type = FileEnumerator::FILES | FileEnumerator::SHOW_SYM_LINKS;
  if (recursive)
    traverse_type |= FileEnumerator::DIRECTORIES;
  FileEnumerator traversal(from_path, recursive, traverse_type);

  // We have to mimic windows behavior here. |to_path| may not exist yet,
  // start the loop with |to_path|.
  FileEnumerator::FindInfo info;
  FilePath current = from_path;
  if (stat(from_path.value().c_str(), &info.stat) < 0) {
    DLOG(ERROR) << ""CopyDirectory() couldn't stat source directory: ""
                << from_path.value() << "" errno = "" << errno;
    success = false;
  }
  struct stat to_path_stat;
  FilePath from_path_base = from_path;
  if (recursive && stat(to_path.value().c_str(), &to_path_stat) == 0 &&
      S_ISDIR(to_path_stat.st_mode)) {
    // If the destination already exists and is a directory, then the
    // top level of source needs to be copied.
    from_path_base = from_path.DirName();
  }

  // The Windows version of this function assumes that non-recursive calls
  // will always have a directory for from_path.
   DCHECK(recursive || S_ISDIR(info.stat.st_mode));
 
   while (success && !current.empty()) {
//flaw_line_below:
    // current is the source path, including from_path, so paste
//flaw_line_below:
    // the suffix after from_path onto to_path to create the target_path.
//flaw_line_below:
    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);
//flaw_line_below:
    // Strip the leading '/' (if any).
//flaw_line_below:
    if (!suffix.empty()) {
//flaw_line_below:
      DCHECK_EQ('/', suffix[0]);
//flaw_line_below:
      suffix.erase(0, 1);
//fix_flaw_line_below:
//    // current is the source path, including from_path, so append
//fix_flaw_line_below:
//    // the suffix after from_path to to_path to create the target_path.
//fix_flaw_line_below:
//    FilePath target_path(to_path);
//fix_flaw_line_below:
//    if (from_path_base != current) {
//fix_flaw_line_below:
//      if (!from_path_base.AppendRelativePath(current, &target_path)) {
//fix_flaw_line_below:
//        success = false;
//fix_flaw_line_below:
//        break;
//fix_flaw_line_below:
//      }
     }
//flaw_line_below:
    const FilePath target_path = to_path.Append(suffix);
 
     if (S_ISDIR(info.stat.st_mode)) {
       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&
          errno != EEXIST) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create directory: ""
                    << target_path.value() << "" errno = "" << errno;
        success = false;
      }
    } else if (S_ISREG(info.stat.st_mode)) {
      if (!CopyFile(current, target_path)) {
        DLOG(ERROR) << ""CopyDirectory() couldn't create file: ""
                    << target_path.value();
        success = false;
      }
    } else {
      DLOG(WARNING) << ""CopyDirectory() skipping non-regular file: ""
                    << current.value();
    }

    current = traversal.Next();
    traversal.GetFindInfo(&info);
  }

  return success;
}
"
7439,185175,,Remote,Not required,Partial,CVE-2013-0911,https://www.cvedetails.com/cve/CVE-2013-0911/,CWE-22,Low,Partial,Partial,,2013-03-05,7.5,Directory traversal vulnerability in Google Chrome before 25.0.1364.152 allows remote attackers to have an unspecified impact via vectors related to databases.,2017-09-18,Dir. Trav. ,7,https://github.com/chromium/chromium/commit/ccfb891dc0c936a8806d663fe6581bf659761819,ccfb891dc0c936a8806d663fe6581bf659761819,"WebDatabase: check path traversal in origin_identifier

BUG=172264


Review URL: https://chromiumcodereview.appspot.com/12212091

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@183141 0039d316-1c4b-4281-b951-d872f2087c98",0,content/browser/renderer_host/database_message_filter.cc,"{""sha"": ""f364ce2f2c1a6772e5f86b646c08dd0de48117ba"", ""filename"": ""content/browser/renderer_host/database_message_filter.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 0, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/ccfb891dc0c936a8806d663fe6581bf659761819/content/browser/renderer_host/database_message_filter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ccfb891dc0c936a8806d663fe6581bf659761819/content/browser/renderer_host/database_message_filter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/database_message_filter.cc?ref=ccfb891dc0c936a8806d663fe6581bf659761819"", ""patch"": ""@@ -284,6 +284,13 @@ void DatabaseMessageFilter::OnDatabaseOpened(const string16& origin_identifier,\n                                              const string16& description,\n                                              int64 estimated_size) {\n   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));\n+\n+  if (!DatabaseUtil::IsValidOriginIdentifier(origin_identifier)) {\n+    RecordAction(UserMetricsAction(\""BadMessageTerminate_DBMF\""));\n+    BadMessageReceived();\n+    return;\n+  }\n+\n   int64 database_size = 0;\n   db_tracker_->DatabaseOpened(origin_identifier, database_name, description,\n                               estimated_size, &database_size);\n@@ -325,6 +332,12 @@ void DatabaseMessageFilter::OnHandleSqliteError(\n     const string16& database_name,\n     int error) {\n   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));\n+  if (!DatabaseUtil::IsValidOriginIdentifier(origin_identifier)) {\n+    RecordAction(UserMetricsAction(\""BadMessageTerminate_DBMF\""));\n+    BadMessageReceived();\n+    return;\n+  }\n+\n   db_tracker_->HandleSqliteError(origin_identifier, database_name, error);\n }\n ""}<_**next**_>{""sha"": ""8acccd22f26c9588945417e1f5e11e7e1665634f"", ""filename"": ""webkit/database/database_util.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/ccfb891dc0c936a8806d663fe6581bf659761819/webkit/database/database_util.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ccfb891dc0c936a8806d663fe6581bf659761819/webkit/database/database_util.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/database/database_util.cc?ref=ccfb891dc0c936a8806d663fe6581bf659761819"", ""patch"": ""@@ -4,6 +4,7 @@\n \n #include \""webkit/database/database_util.h\""\n \n+#include \""base/basictypes.h\""\n #include \""base/utf_string_conversions.h\""\n #include \""third_party/WebKit/Source/Platform/chromium/public/WebString.h\""\n #include \""third_party/WebKit/Source/WebKit/chromium/public/WebSecurityOrigin.h\""\n@@ -90,4 +91,15 @@ GURL DatabaseUtil::GetOriginFromIdentifier(const string16& origin_identifier) {\n   return GURL(web_security_origin.toString());\n }\n \n+bool DatabaseUtil::IsValidOriginIdentifier(const string16& origin_identifier) {\n+  string16 dotdot = ASCIIToUTF16(\""..\"");\n+  char16 forbidden[] = {'\\\\', '/', '\\0'};\n+\n+  string16::size_type pos = origin_identifier.find(dotdot);\n+  if (pos == string16::npos)\n+    pos = origin_identifier.find_first_of(forbidden, 0, arraysize(forbidden));\n+\n+  return pos == string16::npos;\n+}\n+\n }  // namespace webkit_database""}<_**next**_>{""sha"": ""8b366aabe5facf28d682808794ad4332c6701d56"", ""filename"": ""webkit/database/database_util.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/ccfb891dc0c936a8806d663fe6581bf659761819/webkit/database/database_util.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ccfb891dc0c936a8806d663fe6581bf659761819/webkit/database/database_util.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/database/database_util.h?ref=ccfb891dc0c936a8806d663fe6581bf659761819"", ""patch"": ""@@ -31,6 +31,7 @@ class WEBKIT_STORAGE_EXPORT DatabaseUtil {\n                                                   const string16& vfs_file_name);\n   static string16 GetOriginIdentifier(const GURL& url);\n   static GURL GetOriginFromIdentifier(const string16& origin_identifier);\n+  static bool IsValidOriginIdentifier(const string16& origin_identifier);\n };\n \n }  // namespace webkit_database""}<_**next**_>{""sha"": ""aa9d007ac9494f3a388bd6195936a204221c6173"", ""filename"": ""webkit/database/database_util_unittest.cc"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/ccfb891dc0c936a8806d663fe6581bf659761819/webkit/database/database_util_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ccfb891dc0c936a8806d663fe6581bf659761819/webkit/database/database_util_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/database/database_util_unittest.cc?ref=ccfb891dc0c936a8806d663fe6581bf659761819"", ""patch"": ""@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n+#include \""base/string_piece.h\""\n #include \""base/utf_string_conversions.h\""\n #include \""testing/gtest/include/gtest/gtest.h\""\n #include \""webkit/database/database_util.h\""\n@@ -31,6 +32,12 @@ static GURL ToAndFromOriginIdentifier(const GURL origin_url) {\n   return DatabaseUtil::GetOriginFromIdentifier(id);\n }\n \n+static void TestValidOriginIdentifier(bool expected_result,\n+                                      const base::StringPiece id) {\n+  EXPECT_EQ(expected_result,\n+            DatabaseUtil::IsValidOriginIdentifier(ASCIIToUTF16(id)));\n+}\n+\n namespace webkit_database {\n \n // Test DatabaseUtil::CrackVfsFilePath on various inputs.\n@@ -54,4 +61,13 @@ TEST(DatabaseUtilTest, OriginIdentifiers) {\n   EXPECT_EQ(kHttpOrigin, ToAndFromOriginIdentifier(kHttpOrigin));\n }\n \n+TEST(DatabaseUtilTest, IsValidOriginIdentifier) {\n+  TestValidOriginIdentifier(true,  \""http_bar_0\"");\n+  TestValidOriginIdentifier(true,  \""\"");\n+  TestValidOriginIdentifier(false, \""bad..id\"");\n+  TestValidOriginIdentifier(false, \""bad/id\"");\n+  TestValidOriginIdentifier(false, \""bad\\\\id\"");\n+  TestValidOriginIdentifier(false, base::StringPiece(\""bad\\0id\"", 6));\n+}\n+\n }  // namespace webkit_database""}","void DatabaseMessageFilter::OnDatabaseOpened(const string16& origin_identifier,
                                             const string16& database_name,
                                              const string16& description,
                                              int64 estimated_size) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));

  if (!DatabaseUtil::IsValidOriginIdentifier(origin_identifier)) {
    RecordAction(UserMetricsAction(""BadMessageTerminate_DBMF""));
    BadMessageReceived();
    return;
  }

   int64 database_size = 0;
   db_tracker_->DatabaseOpened(origin_identifier, database_name, description,
                               estimated_size, &database_size);
  database_connections_.AddConnection(origin_identifier, database_name);
  Send(new DatabaseMsg_UpdateSize(origin_identifier, database_name,
                                  database_size));
}
","void DatabaseMessageFilter::OnDatabaseOpened(const string16& origin_identifier,
                                             const string16& database_name,
                                              const string16& description,
                                              int64 estimated_size) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));
   int64 database_size = 0;
   db_tracker_->DatabaseOpened(origin_identifier, database_name, description,
                               estimated_size, &database_size);
  database_connections_.AddConnection(origin_identifier, database_name);
  Send(new DatabaseMsg_UpdateSize(origin_identifier, database_name,
                                  database_size));
}
",C,"
  if (!DatabaseUtil::IsValidOriginIdentifier(origin_identifier)) {
    RecordAction(UserMetricsAction(""BadMessageTerminate_DBMF""));
    BadMessageReceived();
    return;
  }

",,,"@@ -284,6 +284,13 @@ void DatabaseMessageFilter::OnDatabaseOpened(const string16& origin_identifier,
                                              const string16& description,
                                              int64 estimated_size) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));
+
+  if (!DatabaseUtil::IsValidOriginIdentifier(origin_identifier)) {
+    RecordAction(UserMetricsAction(""BadMessageTerminate_DBMF""));
+    BadMessageReceived();
+    return;
+  }
+
   int64 database_size = 0;
   db_tracker_->DatabaseOpened(origin_identifier, database_name, description,
                               estimated_size, &database_size);
@@ -325,6 +332,12 @@ void DatabaseMessageFilter::OnHandleSqliteError(
     const string16& database_name,
     int error) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));
+  if (!DatabaseUtil::IsValidOriginIdentifier(origin_identifier)) {
+    RecordAction(UserMetricsAction(""BadMessageTerminate_DBMF""));
+    BadMessageReceived();
+    return;
+  }
+
   db_tracker_->HandleSqliteError(origin_identifier, database_name, error);
 }
 ",Chrome,ccfb891dc0c936a8806d663fe6581bf659761819,31c0e51315a22462860909c286a8db2324c7b6b9,1,"void DatabaseMessageFilter::OnDatabaseOpened(const string16& origin_identifier,
                                             const string16& database_name,
                                              const string16& description,
                                              int64 estimated_size) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  if (!DatabaseUtil::IsValidOriginIdentifier(origin_identifier)) {
//fix_flaw_line_below:
//    RecordAction(UserMetricsAction(""BadMessageTerminate_DBMF""));
//fix_flaw_line_below:
//    BadMessageReceived();
//fix_flaw_line_below:
//    return;
//fix_flaw_line_below:
//  }
//fix_flaw_line_below:
//
   int64 database_size = 0;
   db_tracker_->DatabaseOpened(origin_identifier, database_name, description,
                               estimated_size, &database_size);
  database_connections_.AddConnection(origin_identifier, database_name);
  Send(new DatabaseMsg_UpdateSize(origin_identifier, database_name,
                                  database_size));
}
"
7440,185176,,Remote,Not required,Partial,CVE-2013-0911,https://www.cvedetails.com/cve/CVE-2013-0911/,CWE-22,Low,Partial,Partial,,2013-03-05,7.5,Directory traversal vulnerability in Google Chrome before 25.0.1364.152 allows remote attackers to have an unspecified impact via vectors related to databases.,2017-09-18,Dir. Trav. ,6,https://github.com/chromium/chromium/commit/ccfb891dc0c936a8806d663fe6581bf659761819,ccfb891dc0c936a8806d663fe6581bf659761819,"WebDatabase: check path traversal in origin_identifier

BUG=172264


Review URL: https://chromiumcodereview.appspot.com/12212091

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@183141 0039d316-1c4b-4281-b951-d872f2087c98",0,content/browser/renderer_host/database_message_filter.cc,"{""sha"": ""f364ce2f2c1a6772e5f86b646c08dd0de48117ba"", ""filename"": ""content/browser/renderer_host/database_message_filter.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 0, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/ccfb891dc0c936a8806d663fe6581bf659761819/content/browser/renderer_host/database_message_filter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ccfb891dc0c936a8806d663fe6581bf659761819/content/browser/renderer_host/database_message_filter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/database_message_filter.cc?ref=ccfb891dc0c936a8806d663fe6581bf659761819"", ""patch"": ""@@ -284,6 +284,13 @@ void DatabaseMessageFilter::OnDatabaseOpened(const string16& origin_identifier,\n                                              const string16& description,\n                                              int64 estimated_size) {\n   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));\n+\n+  if (!DatabaseUtil::IsValidOriginIdentifier(origin_identifier)) {\n+    RecordAction(UserMetricsAction(\""BadMessageTerminate_DBMF\""));\n+    BadMessageReceived();\n+    return;\n+  }\n+\n   int64 database_size = 0;\n   db_tracker_->DatabaseOpened(origin_identifier, database_name, description,\n                               estimated_size, &database_size);\n@@ -325,6 +332,12 @@ void DatabaseMessageFilter::OnHandleSqliteError(\n     const string16& database_name,\n     int error) {\n   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));\n+  if (!DatabaseUtil::IsValidOriginIdentifier(origin_identifier)) {\n+    RecordAction(UserMetricsAction(\""BadMessageTerminate_DBMF\""));\n+    BadMessageReceived();\n+    return;\n+  }\n+\n   db_tracker_->HandleSqliteError(origin_identifier, database_name, error);\n }\n ""}<_**next**_>{""sha"": ""8acccd22f26c9588945417e1f5e11e7e1665634f"", ""filename"": ""webkit/database/database_util.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/ccfb891dc0c936a8806d663fe6581bf659761819/webkit/database/database_util.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ccfb891dc0c936a8806d663fe6581bf659761819/webkit/database/database_util.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/database/database_util.cc?ref=ccfb891dc0c936a8806d663fe6581bf659761819"", ""patch"": ""@@ -4,6 +4,7 @@\n \n #include \""webkit/database/database_util.h\""\n \n+#include \""base/basictypes.h\""\n #include \""base/utf_string_conversions.h\""\n #include \""third_party/WebKit/Source/Platform/chromium/public/WebString.h\""\n #include \""third_party/WebKit/Source/WebKit/chromium/public/WebSecurityOrigin.h\""\n@@ -90,4 +91,15 @@ GURL DatabaseUtil::GetOriginFromIdentifier(const string16& origin_identifier) {\n   return GURL(web_security_origin.toString());\n }\n \n+bool DatabaseUtil::IsValidOriginIdentifier(const string16& origin_identifier) {\n+  string16 dotdot = ASCIIToUTF16(\""..\"");\n+  char16 forbidden[] = {'\\\\', '/', '\\0'};\n+\n+  string16::size_type pos = origin_identifier.find(dotdot);\n+  if (pos == string16::npos)\n+    pos = origin_identifier.find_first_of(forbidden, 0, arraysize(forbidden));\n+\n+  return pos == string16::npos;\n+}\n+\n }  // namespace webkit_database""}<_**next**_>{""sha"": ""8b366aabe5facf28d682808794ad4332c6701d56"", ""filename"": ""webkit/database/database_util.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/ccfb891dc0c936a8806d663fe6581bf659761819/webkit/database/database_util.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ccfb891dc0c936a8806d663fe6581bf659761819/webkit/database/database_util.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/database/database_util.h?ref=ccfb891dc0c936a8806d663fe6581bf659761819"", ""patch"": ""@@ -31,6 +31,7 @@ class WEBKIT_STORAGE_EXPORT DatabaseUtil {\n                                                   const string16& vfs_file_name);\n   static string16 GetOriginIdentifier(const GURL& url);\n   static GURL GetOriginFromIdentifier(const string16& origin_identifier);\n+  static bool IsValidOriginIdentifier(const string16& origin_identifier);\n };\n \n }  // namespace webkit_database""}<_**next**_>{""sha"": ""aa9d007ac9494f3a388bd6195936a204221c6173"", ""filename"": ""webkit/database/database_util_unittest.cc"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/ccfb891dc0c936a8806d663fe6581bf659761819/webkit/database/database_util_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ccfb891dc0c936a8806d663fe6581bf659761819/webkit/database/database_util_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/webkit/database/database_util_unittest.cc?ref=ccfb891dc0c936a8806d663fe6581bf659761819"", ""patch"": ""@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n+#include \""base/string_piece.h\""\n #include \""base/utf_string_conversions.h\""\n #include \""testing/gtest/include/gtest/gtest.h\""\n #include \""webkit/database/database_util.h\""\n@@ -31,6 +32,12 @@ static GURL ToAndFromOriginIdentifier(const GURL origin_url) {\n   return DatabaseUtil::GetOriginFromIdentifier(id);\n }\n \n+static void TestValidOriginIdentifier(bool expected_result,\n+                                      const base::StringPiece id) {\n+  EXPECT_EQ(expected_result,\n+            DatabaseUtil::IsValidOriginIdentifier(ASCIIToUTF16(id)));\n+}\n+\n namespace webkit_database {\n \n // Test DatabaseUtil::CrackVfsFilePath on various inputs.\n@@ -54,4 +61,13 @@ TEST(DatabaseUtilTest, OriginIdentifiers) {\n   EXPECT_EQ(kHttpOrigin, ToAndFromOriginIdentifier(kHttpOrigin));\n }\n \n+TEST(DatabaseUtilTest, IsValidOriginIdentifier) {\n+  TestValidOriginIdentifier(true,  \""http_bar_0\"");\n+  TestValidOriginIdentifier(true,  \""\"");\n+  TestValidOriginIdentifier(false, \""bad..id\"");\n+  TestValidOriginIdentifier(false, \""bad/id\"");\n+  TestValidOriginIdentifier(false, \""bad\\\\id\"");\n+  TestValidOriginIdentifier(false, base::StringPiece(\""bad\\0id\"", 6));\n+}\n+\n }  // namespace webkit_database""}","void DatabaseMessageFilter::OnHandleSqliteError(
    const string16& origin_identifier,
     const string16& database_name,
     int error) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));
  if (!DatabaseUtil::IsValidOriginIdentifier(origin_identifier)) {
    RecordAction(UserMetricsAction(""BadMessageTerminate_DBMF""));
    BadMessageReceived();
    return;
  }

   db_tracker_->HandleSqliteError(origin_identifier, database_name, error);
 }
","void DatabaseMessageFilter::OnHandleSqliteError(
    const string16& origin_identifier,
     const string16& database_name,
     int error) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));
   db_tracker_->HandleSqliteError(origin_identifier, database_name, error);
 }
",C,"  if (!DatabaseUtil::IsValidOriginIdentifier(origin_identifier)) {
    RecordAction(UserMetricsAction(""BadMessageTerminate_DBMF""));
    BadMessageReceived();
    return;
  }

",,,"@@ -284,6 +284,13 @@ void DatabaseMessageFilter::OnDatabaseOpened(const string16& origin_identifier,
                                              const string16& description,
                                              int64 estimated_size) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));
+
+  if (!DatabaseUtil::IsValidOriginIdentifier(origin_identifier)) {
+    RecordAction(UserMetricsAction(""BadMessageTerminate_DBMF""));
+    BadMessageReceived();
+    return;
+  }
+
   int64 database_size = 0;
   db_tracker_->DatabaseOpened(origin_identifier, database_name, description,
                               estimated_size, &database_size);
@@ -325,6 +332,12 @@ void DatabaseMessageFilter::OnHandleSqliteError(
     const string16& database_name,
     int error) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));
+  if (!DatabaseUtil::IsValidOriginIdentifier(origin_identifier)) {
+    RecordAction(UserMetricsAction(""BadMessageTerminate_DBMF""));
+    BadMessageReceived();
+    return;
+  }
+
   db_tracker_->HandleSqliteError(origin_identifier, database_name, error);
 }
 ",Chrome,ccfb891dc0c936a8806d663fe6581bf659761819,31c0e51315a22462860909c286a8db2324c7b6b9,1,"void DatabaseMessageFilter::OnHandleSqliteError(
    const string16& origin_identifier,
     const string16& database_name,
     int error) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));
//fix_flaw_line_below:
//  if (!DatabaseUtil::IsValidOriginIdentifier(origin_identifier)) {
//fix_flaw_line_below:
//    RecordAction(UserMetricsAction(""BadMessageTerminate_DBMF""));
//fix_flaw_line_below:
//    BadMessageReceived();
//fix_flaw_line_below:
//    return;
//fix_flaw_line_below:
//  }
//fix_flaw_line_below:
//
   db_tracker_->HandleSqliteError(origin_identifier, database_name, error);
 }
"
7736,185472,,Remote,Not required,Partial,CVE-2014-1715,https://www.cvedetails.com/cve/CVE-2014-1715/,CWE-22,Low,Partial,Partial,,2014-03-16,7.5,Directory traversal vulnerability in Google Chrome before 33.0.1750.152 on OS X and Linux and before 33.0.1750.154 on Windows has unspecified impact and attack vectors.,2017-01-06,Dir. Trav. ,1,https://github.com/chromium/chromium/commit/ce70785c73a2b7cf2b34de0d8439ca31929b4743,ce70785c73a2b7cf2b34de0d8439ca31929b4743,"Consistently check if a block can handle pagination strut propagation.

https://codereview.chromium.org/1360753002 got it right for inline child
layout, but did nothing for block child layout.

BUG=329421
R=jchaffraix@chromium.org,leviw@chromium.org

Review URL: https://codereview.chromium.org/1387553002

Cr-Commit-Position: refs/heads/master@{#352429}",1,third_party/WebKit/Source/core/layout/LayoutBlockFlow.cpp,"{""sha"": ""81a1d86e3cadf41c028e858c0b0f78514746f10e"", ""filename"": ""third_party/WebKit/LayoutTests/fast/multicol/flexbox-starts-at-column-boundary-with-block-expected.html"", ""status"": ""added"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/ce70785c73a2b7cf2b34de0d8439ca31929b4743/third_party/WebKit/LayoutTests/fast/multicol/flexbox-starts-at-column-boundary-with-block-expected.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ce70785c73a2b7cf2b34de0d8439ca31929b4743/third_party/WebKit/LayoutTests/fast/multicol/flexbox-starts-at-column-boundary-with-block-expected.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/multicol/flexbox-starts-at-column-boundary-with-block-expected.html?ref=ce70785c73a2b7cf2b34de0d8439ca31929b4743"", ""patch"": ""@@ -0,0 +1,4 @@\n+<!DOCTYPE html>\n+<p>Check that a flexbox that starts at a column boundary is properly pushed to the next column.</p>\n+<p>The word \""PASS\"" should be seen below.</p>\n+<div style=\""margin-left:50%;\"">PASS</div>""}<_**next**_>{""sha"": ""dd053512ba5c28f122c593329177488ea5f9cc54"", ""filename"": ""third_party/WebKit/LayoutTests/fast/multicol/flexbox-starts-at-column-boundary-with-block.html"", ""status"": ""added"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/ce70785c73a2b7cf2b34de0d8439ca31929b4743/third_party/WebKit/LayoutTests/fast/multicol/flexbox-starts-at-column-boundary-with-block.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ce70785c73a2b7cf2b34de0d8439ca31929b4743/third_party/WebKit/LayoutTests/fast/multicol/flexbox-starts-at-column-boundary-with-block.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/multicol/flexbox-starts-at-column-boundary-with-block.html?ref=ce70785c73a2b7cf2b34de0d8439ca31929b4743"", ""patch"": ""@@ -0,0 +1,9 @@\n+<!DOCTYPE html>\n+<p>Check that a flexbox that starts at a column boundary is properly pushed to the next column.</p>\n+<p>The word \""PASS\"" should be seen below.</p>\n+<div style=\""-webkit-columns:2; -webkit-column-gap:0; column-fill:auto; height:90px;\"">\n+    <div style=\""height:80px;\""></div>\n+    <div style=\""display:flex;\"">\n+        <div><div>PASS</div></div>\n+    </div>\n+</div>""}<_**next**_>{""sha"": ""22f555200b984453b6a8efe704163149ae88889b"", ""filename"": ""third_party/WebKit/LayoutTests/fast/multicol/table-caption-with-block-expected.html"", ""status"": ""added"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/ce70785c73a2b7cf2b34de0d8439ca31929b4743/third_party/WebKit/LayoutTests/fast/multicol/table-caption-with-block-expected.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ce70785c73a2b7cf2b34de0d8439ca31929b4743/third_party/WebKit/LayoutTests/fast/multicol/table-caption-with-block-expected.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/multicol/table-caption-with-block-expected.html?ref=ce70785c73a2b7cf2b34de0d8439ca31929b4743"", ""patch"": ""@@ -0,0 +1,6 @@\n+<!DOCTYPE html>\n+<p>Check that a table caption with a block at a column boundary is properly pushed to the next column.</p>\n+<p>The word \""PASS\"" should be seen below, fully visible and unbroken.</p>\n+<div style=\""margin-left:20em; line-height:2em;\"">\n+    PASS\n+</div>""}<_**next**_>{""sha"": ""b31e567c8bdf97334c4b473d73fdd7fbebe06bc3"", ""filename"": ""third_party/WebKit/LayoutTests/fast/multicol/table-caption-with-block.html"", ""status"": ""added"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/ce70785c73a2b7cf2b34de0d8439ca31929b4743/third_party/WebKit/LayoutTests/fast/multicol/table-caption-with-block.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ce70785c73a2b7cf2b34de0d8439ca31929b4743/third_party/WebKit/LayoutTests/fast/multicol/table-caption-with-block.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/multicol/table-caption-with-block.html?ref=ce70785c73a2b7cf2b34de0d8439ca31929b4743"", ""patch"": ""@@ -0,0 +1,11 @@\n+<!DOCTYPE html>\n+<p>Check that a table caption with a block at a column boundary is properly pushed to the next column.</p>\n+<p>The word \""PASS\"" should be seen below, fully visible and unbroken.</p>\n+<div style=\""-webkit-columns:2; -webkit-column-gap:0; column-fill:auto; line-height:2em; width:40em; height:3em;\"">\n+    <div style=\""height:2em;\""></div>\n+    <table cellspacing=\""0\"" cellpadding=\""0\"">\n+        <caption>\n+            <div>PASS</div>\n+        </caption>\n+    </table>\n+</div>""}<_**next**_>{""sha"": ""3d324ac3bfca1eee8b9b31a91ba3b96a4b0d5715"", ""filename"": ""third_party/WebKit/Source/core/layout/LayoutBlockFlow.cpp"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 11, ""changes"": 28, ""blob_url"": ""https://github.com/chromium/chromium/blob/ce70785c73a2b7cf2b34de0d8439ca31929b4743/third_party/WebKit/Source/core/layout/LayoutBlockFlow.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ce70785c73a2b7cf2b34de0d8439ca31929b4743/third_party/WebKit/Source/core/layout/LayoutBlockFlow.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/layout/LayoutBlockFlow.cpp?ref=ce70785c73a2b7cf2b34de0d8439ca31929b4743"", ""patch"": ""@@ -705,7 +705,7 @@ LayoutUnit LayoutBlockFlow::adjustBlockChildForPagination(LayoutUnit logicalTop,\n     if (paginationStrut) {\n         // We are willing to propagate out to our parent block as long as we were at the top of the block prior\n         // to collapsing our margins, and as long as we didn't clear or move as a result of other pagination.\n-        if (atBeforeSideOfBlock && logicalTop == newLogicalTop && !isOutOfFlowPositioned() && !isTableCell()) {\n+        if (atBeforeSideOfBlock && logicalTop == newLogicalTop && allowsPaginationStrut()) {\n             // FIXME: Should really check if we're exceeding the page height before propagating the strut, but we don't\n             // have all the information to do so (the strut only has the remaining amount to push). Gecko gets this wrong too\n             // and pushes to the next page anyway, so not too concerned about it.\n@@ -781,16 +781,7 @@ static inline bool shouldSetStrutOnBlock(const LayoutBlockFlow& block, const Roo\n         if (totalLogicalHeight < pageLogicalHeightAtNewOffset)\n             wantsStrutOnBlock = true;\n     }\n-    // The block needs to be contained by a LayoutBlockFlow (and not by e.g. a flexbox or a table\n-    // (which would be the case for table cell or table caption)). The reason for this limitation is\n-    // simply that LayoutBlockFlow child layout code is the only place where we pick up the struts\n-    // and handle them. We handle floats and regular in-flow children, and that's all. We could\n-    // handle this in other layout modes as well (and even for out-of-flow children), but currently\n-    // we don't.\n-    if (!wantsStrutOnBlock || block.isOutOfFlowPositioned())\n-        return false;\n-    LayoutBlock* containingBlock = block.containingBlock();\n-    return containingBlock && containingBlock->isLayoutBlockFlow();\n+    return wantsStrutOnBlock && block.allowsPaginationStrut();\n }\n \n void LayoutBlockFlow::adjustLinePositionForPagination(RootInlineBox& lineBox, LayoutUnit& delta)\n@@ -2909,6 +2900,21 @@ void LayoutBlockFlow::getSelectionGapInfo(SelectionState state, bool& leftGap, b\n         || (state == SelectionEnd && !ltr);\n }\n \n+bool LayoutBlockFlow::allowsPaginationStrut() const\n+{\n+    // The block needs to be contained by a LayoutBlockFlow (and not by e.g. a flexbox, grid, or a\n+    // table (the latter being the case for table cell or table caption)). The reason for this\n+    // limitation is simply that LayoutBlockFlow child layout code is the only place where we pick\n+    // up the struts and handle them. We handle floats and regular in-flow children, and that's\n+    // all. We could handle this in other layout modes as well (and even for out-of-flow children),\n+    // but currently we don't.\n+    // TODO(mstensho): But we *should*.\n+    if (isOutOfFlowPositioned())\n+        return false;\n+    LayoutBlock* containingBlock = this->containingBlock();\n+    return containingBlock && containingBlock->isLayoutBlockFlow();\n+}\n+\n void LayoutBlockFlow::setPaginationStrut(LayoutUnit strut)\n {\n     if (!m_rareData) {""}<_**next**_>{""sha"": ""f482c8fbceaf10ddf98138291e17ef41e142e521"", ""filename"": ""third_party/WebKit/Source/core/layout/LayoutBlockFlow.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/ce70785c73a2b7cf2b34de0d8439ca31929b4743/third_party/WebKit/Source/core/layout/LayoutBlockFlow.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ce70785c73a2b7cf2b34de0d8439ca31929b4743/third_party/WebKit/Source/core/layout/LayoutBlockFlow.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/layout/LayoutBlockFlow.h?ref=ce70785c73a2b7cf2b34de0d8439ca31929b4743"", ""patch"": ""@@ -217,6 +217,7 @@ class CORE_EXPORT LayoutBlockFlow : public LayoutBlock {\n     LayoutRect blockSelectionGap(const LayoutBlock* rootBlock, const LayoutPoint& rootBlockPhysicalPosition, const LayoutSize& offsetFromRootBlock,\n         LayoutUnit lastLogicalTop, LayoutUnit lastLogicalLeft, LayoutUnit lastLogicalRight, LayoutUnit logicalBottom, const PaintInfo*) const;\n \n+    bool allowsPaginationStrut() const;\n     LayoutUnit paginationStrut() const { return m_rareData ? m_rareData->m_paginationStrut : LayoutUnit(); }\n     void setPaginationStrut(LayoutUnit);\n ""}","LayoutUnit LayoutBlockFlow::adjustBlockChildForPagination(LayoutUnit logicalTop, LayoutBox& child, bool atBeforeSideOfBlock)
{
    LayoutBlockFlow* childBlockFlow = child.isLayoutBlockFlow() ? toLayoutBlockFlow(&child) : 0;

    LayoutUnit newLogicalTop = applyBeforeBreak(child, logicalTop);

    LayoutUnit logicalTopBeforeUnsplittableAdjustment = newLogicalTop;
    LayoutUnit logicalTopAfterUnsplittableAdjustment = adjustForUnsplittableChild(child, newLogicalTop);

    LayoutUnit paginationStrut = 0;
    LayoutUnit unsplittableAdjustmentDelta = logicalTopAfterUnsplittableAdjustment - logicalTopBeforeUnsplittableAdjustment;
    LayoutUnit childLogicalHeight = child.logicalHeight();
    if (unsplittableAdjustmentDelta) {
        setPageBreak(newLogicalTop, childLogicalHeight - unsplittableAdjustmentDelta);
        paginationStrut = unsplittableAdjustmentDelta;
    } else if (childBlockFlow && childBlockFlow->paginationStrut()) {
        paginationStrut = childBlockFlow->paginationStrut();
    }

     if (paginationStrut) {
        if (atBeforeSideOfBlock && logicalTop == newLogicalTop && allowsPaginationStrut()) {
            paginationStrut += logicalTop;
            if (isFloating())
                paginationStrut += marginBefore(); // Floats' margins do not collapse with page or column boundaries.
            setPaginationStrut(paginationStrut);
            if (childBlockFlow)
                childBlockFlow->setPaginationStrut(0);
        } else {
            newLogicalTop += paginationStrut;
        }
    }

    if (!unsplittableAdjustmentDelta) {
        if (LayoutUnit pageLogicalHeight = pageLogicalHeightForOffset(newLogicalTop)) {
            LayoutUnit remainingLogicalHeight = pageRemainingLogicalHeightForOffset(newLogicalTop, AssociateWithLatterPage);
            LayoutUnit spaceShortage = childLogicalHeight - remainingLogicalHeight;
            if (spaceShortage > 0) {
                LayoutUnit spaceShortageInLastColumn = intMod(spaceShortage, pageLogicalHeight);
                setPageBreak(newLogicalTop, spaceShortageInLastColumn ? spaceShortageInLastColumn : spaceShortage);
            } else if (remainingLogicalHeight == pageLogicalHeight && offsetFromLogicalTopOfFirstPage() + child.logicalTop()) {
                setPageBreak(newLogicalTop, childLogicalHeight);
            }
        }
    }

    setLogicalHeight(logicalHeight() + (newLogicalTop - logicalTop));

    return newLogicalTop;
}
","LayoutUnit LayoutBlockFlow::adjustBlockChildForPagination(LayoutUnit logicalTop, LayoutBox& child, bool atBeforeSideOfBlock)
{
    LayoutBlockFlow* childBlockFlow = child.isLayoutBlockFlow() ? toLayoutBlockFlow(&child) : 0;

    LayoutUnit newLogicalTop = applyBeforeBreak(child, logicalTop);

    LayoutUnit logicalTopBeforeUnsplittableAdjustment = newLogicalTop;
    LayoutUnit logicalTopAfterUnsplittableAdjustment = adjustForUnsplittableChild(child, newLogicalTop);

    LayoutUnit paginationStrut = 0;
    LayoutUnit unsplittableAdjustmentDelta = logicalTopAfterUnsplittableAdjustment - logicalTopBeforeUnsplittableAdjustment;
    LayoutUnit childLogicalHeight = child.logicalHeight();
    if (unsplittableAdjustmentDelta) {
        setPageBreak(newLogicalTop, childLogicalHeight - unsplittableAdjustmentDelta);
        paginationStrut = unsplittableAdjustmentDelta;
    } else if (childBlockFlow && childBlockFlow->paginationStrut()) {
        paginationStrut = childBlockFlow->paginationStrut();
    }

     if (paginationStrut) {
        if (atBeforeSideOfBlock && logicalTop == newLogicalTop && !isOutOfFlowPositioned() && !isTableCell()) {
            paginationStrut += logicalTop;
            if (isFloating())
                paginationStrut += marginBefore(); // Floats' margins do not collapse with page or column boundaries.
            setPaginationStrut(paginationStrut);
            if (childBlockFlow)
                childBlockFlow->setPaginationStrut(0);
        } else {
            newLogicalTop += paginationStrut;
        }
    }

    if (!unsplittableAdjustmentDelta) {
        if (LayoutUnit pageLogicalHeight = pageLogicalHeightForOffset(newLogicalTop)) {
            LayoutUnit remainingLogicalHeight = pageRemainingLogicalHeightForOffset(newLogicalTop, AssociateWithLatterPage);
            LayoutUnit spaceShortage = childLogicalHeight - remainingLogicalHeight;
            if (spaceShortage > 0) {
                LayoutUnit spaceShortageInLastColumn = intMod(spaceShortage, pageLogicalHeight);
                setPageBreak(newLogicalTop, spaceShortageInLastColumn ? spaceShortageInLastColumn : spaceShortage);
            } else if (remainingLogicalHeight == pageLogicalHeight && offsetFromLogicalTopOfFirstPage() + child.logicalTop()) {
                setPageBreak(newLogicalTop, childLogicalHeight);
            }
        }
    }

    setLogicalHeight(logicalHeight() + (newLogicalTop - logicalTop));

    return newLogicalTop;
}
",C,"        if (atBeforeSideOfBlock && logicalTop == newLogicalTop && allowsPaginationStrut()) {
","        if (atBeforeSideOfBlock && logicalTop == newLogicalTop && !isOutOfFlowPositioned() && !isTableCell()) {
",,"@@ -705,7 +705,7 @@ LayoutUnit LayoutBlockFlow::adjustBlockChildForPagination(LayoutUnit logicalTop,
     if (paginationStrut) {
         // We are willing to propagate out to our parent block as long as we were at the top of the block prior
         // to collapsing our margins, and as long as we didn't clear or move as a result of other pagination.
-        if (atBeforeSideOfBlock && logicalTop == newLogicalTop && !isOutOfFlowPositioned() && !isTableCell()) {
+        if (atBeforeSideOfBlock && logicalTop == newLogicalTop && allowsPaginationStrut()) {
             // FIXME: Should really check if we're exceeding the page height before propagating the strut, but we don't
             // have all the information to do so (the strut only has the remaining amount to push). Gecko gets this wrong too
             // and pushes to the next page anyway, so not too concerned about it.
@@ -781,16 +781,7 @@ static inline bool shouldSetStrutOnBlock(const LayoutBlockFlow& block, const Roo
         if (totalLogicalHeight < pageLogicalHeightAtNewOffset)
             wantsStrutOnBlock = true;
     }
-    // The block needs to be contained by a LayoutBlockFlow (and not by e.g. a flexbox or a table
-    // (which would be the case for table cell or table caption)). The reason for this limitation is
-    // simply that LayoutBlockFlow child layout code is the only place where we pick up the struts
-    // and handle them. We handle floats and regular in-flow children, and that's all. We could
-    // handle this in other layout modes as well (and even for out-of-flow children), but currently
-    // we don't.
-    if (!wantsStrutOnBlock || block.isOutOfFlowPositioned())
-        return false;
-    LayoutBlock* containingBlock = block.containingBlock();
-    return containingBlock && containingBlock->isLayoutBlockFlow();
+    return wantsStrutOnBlock && block.allowsPaginationStrut();
 }
 
 void LayoutBlockFlow::adjustLinePositionForPagination(RootInlineBox& lineBox, LayoutUnit& delta)
@@ -2909,6 +2900,21 @@ void LayoutBlockFlow::getSelectionGapInfo(SelectionState state, bool& leftGap, b
         || (state == SelectionEnd && !ltr);
 }
 
+bool LayoutBlockFlow::allowsPaginationStrut() const
+{
+    // The block needs to be contained by a LayoutBlockFlow (and not by e.g. a flexbox, grid, or a
+    // table (the latter being the case for table cell or table caption)). The reason for this
+    // limitation is simply that LayoutBlockFlow child layout code is the only place where we pick
+    // up the struts and handle them. We handle floats and regular in-flow children, and that's
+    // all. We could handle this in other layout modes as well (and even for out-of-flow children),
+    // but currently we don't.
+    // TODO(mstensho): But we *should*.
+    if (isOutOfFlowPositioned())
+        return false;
+    LayoutBlock* containingBlock = this->containingBlock();
+    return containingBlock && containingBlock->isLayoutBlockFlow();
+}
+
 void LayoutBlockFlow::setPaginationStrut(LayoutUnit strut)
 {
     if (!m_rareData) {",Chrome,ce70785c73a2b7cf2b34de0d8439ca31929b4743,696e7fade0295050a1aa8290b49925b5506ad27a,1,"LayoutUnit LayoutBlockFlow::adjustBlockChildForPagination(LayoutUnit logicalTop, LayoutBox& child, bool atBeforeSideOfBlock)
{
    LayoutBlockFlow* childBlockFlow = child.isLayoutBlockFlow() ? toLayoutBlockFlow(&child) : 0;

    // If the object has a page or column break value of ""before"", then we should shift to the top of the next page.
    LayoutUnit newLogicalTop = applyBeforeBreak(child, logicalTop);

    // For replaced elements and scrolled elements, we want to shift them to the next page if they don't fit on the current one.
    LayoutUnit logicalTopBeforeUnsplittableAdjustment = newLogicalTop;
    LayoutUnit logicalTopAfterUnsplittableAdjustment = adjustForUnsplittableChild(child, newLogicalTop);

    LayoutUnit paginationStrut = 0;
    LayoutUnit unsplittableAdjustmentDelta = logicalTopAfterUnsplittableAdjustment - logicalTopBeforeUnsplittableAdjustment;
    LayoutUnit childLogicalHeight = child.logicalHeight();
    if (unsplittableAdjustmentDelta) {
        setPageBreak(newLogicalTop, childLogicalHeight - unsplittableAdjustmentDelta);
        paginationStrut = unsplittableAdjustmentDelta;
    } else if (childBlockFlow && childBlockFlow->paginationStrut()) {
        paginationStrut = childBlockFlow->paginationStrut();
    }

     if (paginationStrut) {
         // We are willing to propagate out to our parent block as long as we were at the top of the block prior
         // to collapsing our margins, and as long as we didn't clear or move as a result of other pagination.
//flaw_line_below:
        if (atBeforeSideOfBlock && logicalTop == newLogicalTop && !isOutOfFlowPositioned() && !isTableCell()) {
//fix_flaw_line_below:
//        if (atBeforeSideOfBlock && logicalTop == newLogicalTop && allowsPaginationStrut()) {
             // FIXME: Should really check if we're exceeding the page height before propagating the strut, but we don't
             // have all the information to do so (the strut only has the remaining amount to push). Gecko gets this wrong too
             // and pushes to the next page anyway, so not too concerned about it.
            paginationStrut += logicalTop;
            if (isFloating())
                paginationStrut += marginBefore(); // Floats' margins do not collapse with page or column boundaries.
            setPaginationStrut(paginationStrut);
            if (childBlockFlow)
                childBlockFlow->setPaginationStrut(0);
        } else {
            newLogicalTop += paginationStrut;
        }
    }

    if (!unsplittableAdjustmentDelta) {
        if (LayoutUnit pageLogicalHeight = pageLogicalHeightForOffset(newLogicalTop)) {
            LayoutUnit remainingLogicalHeight = pageRemainingLogicalHeightForOffset(newLogicalTop, AssociateWithLatterPage);
            LayoutUnit spaceShortage = childLogicalHeight - remainingLogicalHeight;
            if (spaceShortage > 0) {
                // If the child crosses a column boundary, report a break, in case nothing inside it
                // has already done so. The column balancer needs to know how much it has to stretch
                // the columns to make more content fit. If no breaks are reported (but do occur),
                // the balancer will have no clue. Only measure the space after the last column
                // boundary, in case it crosses more than one.
                LayoutUnit spaceShortageInLastColumn = intMod(spaceShortage, pageLogicalHeight);
                setPageBreak(newLogicalTop, spaceShortageInLastColumn ? spaceShortageInLastColumn : spaceShortage);
            } else if (remainingLogicalHeight == pageLogicalHeight && offsetFromLogicalTopOfFirstPage() + child.logicalTop()) {
                // We're at the very top of a page or column, and it's not the first one. This child
                // may turn out to be the smallest piece of content that causes a page break, so we
                // need to report it.
                setPageBreak(newLogicalTop, childLogicalHeight);
            }
        }
    }

    // Similar to how we apply clearance. Go ahead and boost height() to be the place where we're going to position the child.
    setLogicalHeight(logicalHeight() + (newLogicalTop - logicalTop));

    // Return the final adjusted logical top.
    return newLogicalTop;
}
"
7737,185473,,Remote,Not required,Partial,CVE-2014-1715,https://www.cvedetails.com/cve/CVE-2014-1715/,CWE-22,Low,Partial,Partial,,2014-03-16,7.5,Directory traversal vulnerability in Google Chrome before 33.0.1750.152 on OS X and Linux and before 33.0.1750.154 on Windows has unspecified impact and attack vectors.,2017-01-06,Dir. Trav. ,1,https://github.com/chromium/chromium/commit/ce70785c73a2b7cf2b34de0d8439ca31929b4743,ce70785c73a2b7cf2b34de0d8439ca31929b4743,"Consistently check if a block can handle pagination strut propagation.

https://codereview.chromium.org/1360753002 got it right for inline child
layout, but did nothing for block child layout.

BUG=329421
R=jchaffraix@chromium.org,leviw@chromium.org

Review URL: https://codereview.chromium.org/1387553002

Cr-Commit-Position: refs/heads/master@{#352429}",4,third_party/WebKit/Source/core/layout/LayoutBlockFlow.cpp,"{""sha"": ""81a1d86e3cadf41c028e858c0b0f78514746f10e"", ""filename"": ""third_party/WebKit/LayoutTests/fast/multicol/flexbox-starts-at-column-boundary-with-block-expected.html"", ""status"": ""added"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/ce70785c73a2b7cf2b34de0d8439ca31929b4743/third_party/WebKit/LayoutTests/fast/multicol/flexbox-starts-at-column-boundary-with-block-expected.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ce70785c73a2b7cf2b34de0d8439ca31929b4743/third_party/WebKit/LayoutTests/fast/multicol/flexbox-starts-at-column-boundary-with-block-expected.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/multicol/flexbox-starts-at-column-boundary-with-block-expected.html?ref=ce70785c73a2b7cf2b34de0d8439ca31929b4743"", ""patch"": ""@@ -0,0 +1,4 @@\n+<!DOCTYPE html>\n+<p>Check that a flexbox that starts at a column boundary is properly pushed to the next column.</p>\n+<p>The word \""PASS\"" should be seen below.</p>\n+<div style=\""margin-left:50%;\"">PASS</div>""}<_**next**_>{""sha"": ""dd053512ba5c28f122c593329177488ea5f9cc54"", ""filename"": ""third_party/WebKit/LayoutTests/fast/multicol/flexbox-starts-at-column-boundary-with-block.html"", ""status"": ""added"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/ce70785c73a2b7cf2b34de0d8439ca31929b4743/third_party/WebKit/LayoutTests/fast/multicol/flexbox-starts-at-column-boundary-with-block.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ce70785c73a2b7cf2b34de0d8439ca31929b4743/third_party/WebKit/LayoutTests/fast/multicol/flexbox-starts-at-column-boundary-with-block.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/multicol/flexbox-starts-at-column-boundary-with-block.html?ref=ce70785c73a2b7cf2b34de0d8439ca31929b4743"", ""patch"": ""@@ -0,0 +1,9 @@\n+<!DOCTYPE html>\n+<p>Check that a flexbox that starts at a column boundary is properly pushed to the next column.</p>\n+<p>The word \""PASS\"" should be seen below.</p>\n+<div style=\""-webkit-columns:2; -webkit-column-gap:0; column-fill:auto; height:90px;\"">\n+    <div style=\""height:80px;\""></div>\n+    <div style=\""display:flex;\"">\n+        <div><div>PASS</div></div>\n+    </div>\n+</div>""}<_**next**_>{""sha"": ""22f555200b984453b6a8efe704163149ae88889b"", ""filename"": ""third_party/WebKit/LayoutTests/fast/multicol/table-caption-with-block-expected.html"", ""status"": ""added"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/ce70785c73a2b7cf2b34de0d8439ca31929b4743/third_party/WebKit/LayoutTests/fast/multicol/table-caption-with-block-expected.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ce70785c73a2b7cf2b34de0d8439ca31929b4743/third_party/WebKit/LayoutTests/fast/multicol/table-caption-with-block-expected.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/multicol/table-caption-with-block-expected.html?ref=ce70785c73a2b7cf2b34de0d8439ca31929b4743"", ""patch"": ""@@ -0,0 +1,6 @@\n+<!DOCTYPE html>\n+<p>Check that a table caption with a block at a column boundary is properly pushed to the next column.</p>\n+<p>The word \""PASS\"" should be seen below, fully visible and unbroken.</p>\n+<div style=\""margin-left:20em; line-height:2em;\"">\n+    PASS\n+</div>""}<_**next**_>{""sha"": ""b31e567c8bdf97334c4b473d73fdd7fbebe06bc3"", ""filename"": ""third_party/WebKit/LayoutTests/fast/multicol/table-caption-with-block.html"", ""status"": ""added"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/ce70785c73a2b7cf2b34de0d8439ca31929b4743/third_party/WebKit/LayoutTests/fast/multicol/table-caption-with-block.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ce70785c73a2b7cf2b34de0d8439ca31929b4743/third_party/WebKit/LayoutTests/fast/multicol/table-caption-with-block.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/fast/multicol/table-caption-with-block.html?ref=ce70785c73a2b7cf2b34de0d8439ca31929b4743"", ""patch"": ""@@ -0,0 +1,11 @@\n+<!DOCTYPE html>\n+<p>Check that a table caption with a block at a column boundary is properly pushed to the next column.</p>\n+<p>The word \""PASS\"" should be seen below, fully visible and unbroken.</p>\n+<div style=\""-webkit-columns:2; -webkit-column-gap:0; column-fill:auto; line-height:2em; width:40em; height:3em;\"">\n+    <div style=\""height:2em;\""></div>\n+    <table cellspacing=\""0\"" cellpadding=\""0\"">\n+        <caption>\n+            <div>PASS</div>\n+        </caption>\n+    </table>\n+</div>""}<_**next**_>{""sha"": ""3d324ac3bfca1eee8b9b31a91ba3b96a4b0d5715"", ""filename"": ""third_party/WebKit/Source/core/layout/LayoutBlockFlow.cpp"", ""status"": ""modified"", ""additions"": 17, ""deletions"": 11, ""changes"": 28, ""blob_url"": ""https://github.com/chromium/chromium/blob/ce70785c73a2b7cf2b34de0d8439ca31929b4743/third_party/WebKit/Source/core/layout/LayoutBlockFlow.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ce70785c73a2b7cf2b34de0d8439ca31929b4743/third_party/WebKit/Source/core/layout/LayoutBlockFlow.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/layout/LayoutBlockFlow.cpp?ref=ce70785c73a2b7cf2b34de0d8439ca31929b4743"", ""patch"": ""@@ -705,7 +705,7 @@ LayoutUnit LayoutBlockFlow::adjustBlockChildForPagination(LayoutUnit logicalTop,\n     if (paginationStrut) {\n         // We are willing to propagate out to our parent block as long as we were at the top of the block prior\n         // to collapsing our margins, and as long as we didn't clear or move as a result of other pagination.\n-        if (atBeforeSideOfBlock && logicalTop == newLogicalTop && !isOutOfFlowPositioned() && !isTableCell()) {\n+        if (atBeforeSideOfBlock && logicalTop == newLogicalTop && allowsPaginationStrut()) {\n             // FIXME: Should really check if we're exceeding the page height before propagating the strut, but we don't\n             // have all the information to do so (the strut only has the remaining amount to push). Gecko gets this wrong too\n             // and pushes to the next page anyway, so not too concerned about it.\n@@ -781,16 +781,7 @@ static inline bool shouldSetStrutOnBlock(const LayoutBlockFlow& block, const Roo\n         if (totalLogicalHeight < pageLogicalHeightAtNewOffset)\n             wantsStrutOnBlock = true;\n     }\n-    // The block needs to be contained by a LayoutBlockFlow (and not by e.g. a flexbox or a table\n-    // (which would be the case for table cell or table caption)). The reason for this limitation is\n-    // simply that LayoutBlockFlow child layout code is the only place where we pick up the struts\n-    // and handle them. We handle floats and regular in-flow children, and that's all. We could\n-    // handle this in other layout modes as well (and even for out-of-flow children), but currently\n-    // we don't.\n-    if (!wantsStrutOnBlock || block.isOutOfFlowPositioned())\n-        return false;\n-    LayoutBlock* containingBlock = block.containingBlock();\n-    return containingBlock && containingBlock->isLayoutBlockFlow();\n+    return wantsStrutOnBlock && block.allowsPaginationStrut();\n }\n \n void LayoutBlockFlow::adjustLinePositionForPagination(RootInlineBox& lineBox, LayoutUnit& delta)\n@@ -2909,6 +2900,21 @@ void LayoutBlockFlow::getSelectionGapInfo(SelectionState state, bool& leftGap, b\n         || (state == SelectionEnd && !ltr);\n }\n \n+bool LayoutBlockFlow::allowsPaginationStrut() const\n+{\n+    // The block needs to be contained by a LayoutBlockFlow (and not by e.g. a flexbox, grid, or a\n+    // table (the latter being the case for table cell or table caption)). The reason for this\n+    // limitation is simply that LayoutBlockFlow child layout code is the only place where we pick\n+    // up the struts and handle them. We handle floats and regular in-flow children, and that's\n+    // all. We could handle this in other layout modes as well (and even for out-of-flow children),\n+    // but currently we don't.\n+    // TODO(mstensho): But we *should*.\n+    if (isOutOfFlowPositioned())\n+        return false;\n+    LayoutBlock* containingBlock = this->containingBlock();\n+    return containingBlock && containingBlock->isLayoutBlockFlow();\n+}\n+\n void LayoutBlockFlow::setPaginationStrut(LayoutUnit strut)\n {\n     if (!m_rareData) {""}<_**next**_>{""sha"": ""f482c8fbceaf10ddf98138291e17ef41e142e521"", ""filename"": ""third_party/WebKit/Source/core/layout/LayoutBlockFlow.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/ce70785c73a2b7cf2b34de0d8439ca31929b4743/third_party/WebKit/Source/core/layout/LayoutBlockFlow.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ce70785c73a2b7cf2b34de0d8439ca31929b4743/third_party/WebKit/Source/core/layout/LayoutBlockFlow.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/layout/LayoutBlockFlow.h?ref=ce70785c73a2b7cf2b34de0d8439ca31929b4743"", ""patch"": ""@@ -217,6 +217,7 @@ class CORE_EXPORT LayoutBlockFlow : public LayoutBlock {\n     LayoutRect blockSelectionGap(const LayoutBlock* rootBlock, const LayoutPoint& rootBlockPhysicalPosition, const LayoutSize& offsetFromRootBlock,\n         LayoutUnit lastLogicalTop, LayoutUnit lastLogicalLeft, LayoutUnit lastLogicalRight, LayoutUnit logicalBottom, const PaintInfo*) const;\n \n+    bool allowsPaginationStrut() const;\n     LayoutUnit paginationStrut() const { return m_rareData ? m_rareData->m_paginationStrut : LayoutUnit(); }\n     void setPaginationStrut(LayoutUnit);\n ""}","static inline bool shouldSetStrutOnBlock(const LayoutBlockFlow& block, const RootInlineBox& lineBox, LayoutUnit lineLogicalOffset, int lineIndex, LayoutUnit remainingLogicalHeight)
{
    bool wantsStrutOnBlock = false;
    if (!block.style()->hasAutoOrphans() && block.style()->orphans() >= lineIndex) {
        wantsStrutOnBlock = true;
    } else if (lineBox == block.firstRootBox() && lineLogicalOffset == block.borderAndPaddingBefore()) {
        LayoutUnit lineHeight = lineBox.lineBottomWithLeading() - lineBox.lineTopWithLeading();
        LayoutUnit totalLogicalHeight = lineHeight + std::max<LayoutUnit>(0, lineLogicalOffset);
        LayoutUnit pageLogicalHeightAtNewOffset = block.pageLogicalHeightForOffset(lineLogicalOffset + remainingLogicalHeight);
         if (totalLogicalHeight < pageLogicalHeightAtNewOffset)
             wantsStrutOnBlock = true;
     }
    return wantsStrutOnBlock && block.allowsPaginationStrut();
 }
","static inline bool shouldSetStrutOnBlock(const LayoutBlockFlow& block, const RootInlineBox& lineBox, LayoutUnit lineLogicalOffset, int lineIndex, LayoutUnit remainingLogicalHeight)
{
    bool wantsStrutOnBlock = false;
    if (!block.style()->hasAutoOrphans() && block.style()->orphans() >= lineIndex) {
        wantsStrutOnBlock = true;
    } else if (lineBox == block.firstRootBox() && lineLogicalOffset == block.borderAndPaddingBefore()) {
        LayoutUnit lineHeight = lineBox.lineBottomWithLeading() - lineBox.lineTopWithLeading();
        LayoutUnit totalLogicalHeight = lineHeight + std::max<LayoutUnit>(0, lineLogicalOffset);
        LayoutUnit pageLogicalHeightAtNewOffset = block.pageLogicalHeightForOffset(lineLogicalOffset + remainingLogicalHeight);
         if (totalLogicalHeight < pageLogicalHeightAtNewOffset)
             wantsStrutOnBlock = true;
     }
    if (!wantsStrutOnBlock || block.isOutOfFlowPositioned())
        return false;
    LayoutBlock* containingBlock = block.containingBlock();
    return containingBlock && containingBlock->isLayoutBlockFlow();
 }
",C,"    return wantsStrutOnBlock && block.allowsPaginationStrut();
","    if (!wantsStrutOnBlock || block.isOutOfFlowPositioned())
        return false;
    LayoutBlock* containingBlock = block.containingBlock();
    return containingBlock && containingBlock->isLayoutBlockFlow();
",,"@@ -705,7 +705,7 @@ LayoutUnit LayoutBlockFlow::adjustBlockChildForPagination(LayoutUnit logicalTop,
     if (paginationStrut) {
         // We are willing to propagate out to our parent block as long as we were at the top of the block prior
         // to collapsing our margins, and as long as we didn't clear or move as a result of other pagination.
-        if (atBeforeSideOfBlock && logicalTop == newLogicalTop && !isOutOfFlowPositioned() && !isTableCell()) {
+        if (atBeforeSideOfBlock && logicalTop == newLogicalTop && allowsPaginationStrut()) {
             // FIXME: Should really check if we're exceeding the page height before propagating the strut, but we don't
             // have all the information to do so (the strut only has the remaining amount to push). Gecko gets this wrong too
             // and pushes to the next page anyway, so not too concerned about it.
@@ -781,16 +781,7 @@ static inline bool shouldSetStrutOnBlock(const LayoutBlockFlow& block, const Roo
         if (totalLogicalHeight < pageLogicalHeightAtNewOffset)
             wantsStrutOnBlock = true;
     }
-    // The block needs to be contained by a LayoutBlockFlow (and not by e.g. a flexbox or a table
-    // (which would be the case for table cell or table caption)). The reason for this limitation is
-    // simply that LayoutBlockFlow child layout code is the only place where we pick up the struts
-    // and handle them. We handle floats and regular in-flow children, and that's all. We could
-    // handle this in other layout modes as well (and even for out-of-flow children), but currently
-    // we don't.
-    if (!wantsStrutOnBlock || block.isOutOfFlowPositioned())
-        return false;
-    LayoutBlock* containingBlock = block.containingBlock();
-    return containingBlock && containingBlock->isLayoutBlockFlow();
+    return wantsStrutOnBlock && block.allowsPaginationStrut();
 }
 
 void LayoutBlockFlow::adjustLinePositionForPagination(RootInlineBox& lineBox, LayoutUnit& delta)
@@ -2909,6 +2900,21 @@ void LayoutBlockFlow::getSelectionGapInfo(SelectionState state, bool& leftGap, b
         || (state == SelectionEnd && !ltr);
 }
 
+bool LayoutBlockFlow::allowsPaginationStrut() const
+{
+    // The block needs to be contained by a LayoutBlockFlow (and not by e.g. a flexbox, grid, or a
+    // table (the latter being the case for table cell or table caption)). The reason for this
+    // limitation is simply that LayoutBlockFlow child layout code is the only place where we pick
+    // up the struts and handle them. We handle floats and regular in-flow children, and that's
+    // all. We could handle this in other layout modes as well (and even for out-of-flow children),
+    // but currently we don't.
+    // TODO(mstensho): But we *should*.
+    if (isOutOfFlowPositioned())
+        return false;
+    LayoutBlock* containingBlock = this->containingBlock();
+    return containingBlock && containingBlock->isLayoutBlockFlow();
+}
+
 void LayoutBlockFlow::setPaginationStrut(LayoutUnit strut)
 {
     if (!m_rareData) {",Chrome,ce70785c73a2b7cf2b34de0d8439ca31929b4743,696e7fade0295050a1aa8290b49925b5506ad27a,1,"static inline bool shouldSetStrutOnBlock(const LayoutBlockFlow& block, const RootInlineBox& lineBox, LayoutUnit lineLogicalOffset, int lineIndex, LayoutUnit remainingLogicalHeight)
{
    bool wantsStrutOnBlock = false;
    if (!block.style()->hasAutoOrphans() && block.style()->orphans() >= lineIndex) {
        // Not enough orphans here. Push the entire block to the next column / page as an
        // attempt to better satisfy the orphans requirement.
        wantsStrutOnBlock = true;
    } else if (lineBox == block.firstRootBox() && lineLogicalOffset == block.borderAndPaddingBefore()) {
        // This is the first line in the block. We can take the whole block with us to the next page
        // or column, rather than keeping a content-less portion of it in the previous one. Only do
        // this if the line is flush with the content edge of the block, though. If it isn't, it
        // means that the line was pushed downwards by preceding floats that didn't fit beside the
        // line, and we don't want to move all that, since it has already been established that it
        // fits nicely where it is.
        LayoutUnit lineHeight = lineBox.lineBottomWithLeading() - lineBox.lineTopWithLeading();
        LayoutUnit totalLogicalHeight = lineHeight + std::max<LayoutUnit>(0, lineLogicalOffset);
        LayoutUnit pageLogicalHeightAtNewOffset = block.pageLogicalHeightForOffset(lineLogicalOffset + remainingLogicalHeight);
        // It's rather pointless to break before the block if the current line isn't going to
        // fit in the same column or page, so check that as well.
         if (totalLogicalHeight < pageLogicalHeightAtNewOffset)
             wantsStrutOnBlock = true;
     }
//flaw_line_below:
    // The block needs to be contained by a LayoutBlockFlow (and not by e.g. a flexbox or a table
//flaw_line_below:
    // (which would be the case for table cell or table caption)). The reason for this limitation is
//flaw_line_below:
    // simply that LayoutBlockFlow child layout code is the only place where we pick up the struts
//flaw_line_below:
    // and handle them. We handle floats and regular in-flow children, and that's all. We could
//flaw_line_below:
    // handle this in other layout modes as well (and even for out-of-flow children), but currently
//flaw_line_below:
    // we don't.
//flaw_line_below:
    if (!wantsStrutOnBlock || block.isOutOfFlowPositioned())
//flaw_line_below:
        return false;
//flaw_line_below:
    LayoutBlock* containingBlock = block.containingBlock();
//flaw_line_below:
    return containingBlock && containingBlock->isLayoutBlockFlow();
//fix_flaw_line_below:
//    return wantsStrutOnBlock && block.allowsPaginationStrut();
 }
"
8505,186241,,Remote,Not required,Partial,CVE-2016-1671,https://www.cvedetails.com/cve/CVE-2016-1671/,CWE-22,Medium,Partial,Partial,,2016-05-14,6.8,"Google Chrome before 50.0.2661.102 on Android mishandles / (slash) and  (backslash) characters, which allows attackers to conduct directory traversal attacks via a file: URL, related to net/base/escape.cc and net/base/filename_util.cc.",2016-11-30,Dir. Trav. ,3,https://github.com/chromium/chromium/commit/9cfe470d793da6e09b966d435c8fa2ba1625d5fe,9cfe470d793da6e09b966d435c8fa2ba1625d5fe,"[base] Make dynamic container to static span conversion explicit

This change disallows implicit conversions from dynamic containers to
static spans. This conversion can cause CHECK failures, and thus should
be done carefully. Requiring explicit construction makes it more obvious
when this happens. To aid usability, appropriate base::make_span<size_t>
overloads are added.

Bug: 877931
Change-Id: Id9f526bc57bfd30a52d14df827b0445ca087381d
Reviewed-on: https://chromium-review.googlesource.com/1189985
Reviewed-by: Ryan Sleevi <rsleevi@chromium.org>
Reviewed-by: Balazs Engedy <engedy@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Commit-Queue: Jan Wilken Dörrie <jdoerrie@chromium.org>
Cr-Commit-Position: refs/heads/master@{#586657}",1,content/browser/webauth/virtual_authenticator.cc,"{""sha"": ""2f01162f08c3b186f5ebc35dfbe146920bdda5ea"", ""filename"": ""base/containers/span.h"", ""status"": ""modified"", ""additions"": 69, ""deletions"": 9, ""changes"": 78, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/containers/span.h?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -71,13 +71,31 @@ using EnableIfSpanCompatibleArray =\n                      ContainerHasConvertibleData<Array, T>::value>;\n \n // SFINAE check if Container can be converted to a span<T>.\n+template <typename Container, typename T>\n+using IsSpanCompatibleContainer =\n+    std::conditional_t<!IsSpan<Container>::value &&\n+                           !IsStdArray<Container>::value &&\n+                           !IsCArray<Container>::value &&\n+                           ContainerHasConvertibleData<Container, T>::value &&\n+                           ContainerHasIntegralSize<Container>::value,\n+                       std::true_type,\n+                       std::false_type>;\n+\n template <typename Container, typename T>\n using EnableIfSpanCompatibleContainer =\n-    std::enable_if_t<!internal::IsSpan<Container>::value &&\n-                     !internal::IsStdArray<Container>::value &&\n-                     !internal::IsCArray<Container>::value &&\n-                     ContainerHasConvertibleData<Container, T>::value &&\n-                     ContainerHasIntegralSize<Container>::value>;\n+    std::enable_if_t<IsSpanCompatibleContainer<Container, T>::value>;\n+\n+template <typename Container, typename T, size_t Extent>\n+using EnableIfSpanCompatibleContainerAndSpanIsDynamic =\n+    std::enable_if_t<IsSpanCompatibleContainer<Container, T>::value &&\n+                         Extent == dynamic_extent,\n+                     bool>;\n+\n+template <typename Container, typename T, size_t Extent>\n+using EnableIfSpanCompatibleContainerAndSpanIsStatic =\n+    std::enable_if_t<IsSpanCompatibleContainer<Container, T>::value &&\n+                         Extent != dynamic_extent,\n+                     bool>;\n \n // A helper template for storing the size of a span. Spans with static extents\n // don't require additional storage, since the extent itself is specified in the\n@@ -171,6 +189,10 @@ struct ExtentStorage<dynamic_extent> {\n // Differences in constants and types:\n // - index_type is aliased to size_t\n //\n+// Differences from [span.cons]:\n+// - Constructing a static span (i.e. Extent != dynamic_extent) from a dynamic\n+//   sized container (e.g. std::vector) requires an explicit conversion.\n+//\n // Differences from [span.sub]:\n // - using size_t instead of ptrdiff_t for indexing\n //\n@@ -245,15 +267,36 @@ class span : public internal::ExtentStorage<Extent> {\n \n   // Conversion from a container that has compatible base::data() and integral\n   // base::size().\n-  template <typename Container,\n-            typename = internal::EnableIfSpanCompatibleContainer<Container&, T>>\n+  template <\n+      typename Container,\n+      internal::EnableIfSpanCompatibleContainerAndSpanIsDynamic<Container&,\n+                                                                T,\n+                                                                Extent> = false>\n   constexpr span(Container& container) noexcept\n       : span(base::data(container), base::size(container)) {}\n \n   template <\n       typename Container,\n-      typename = internal::EnableIfSpanCompatibleContainer<const Container&, T>>\n-  span(const Container& container) noexcept\n+      internal::EnableIfSpanCompatibleContainerAndSpanIsStatic<Container&,\n+                                                               T,\n+                                                               Extent> = false>\n+  constexpr explicit span(Container& container) noexcept\n+      : span(base::data(container), base::size(container)) {}\n+\n+  template <typename Container,\n+            internal::EnableIfSpanCompatibleContainerAndSpanIsDynamic<\n+                const Container&,\n+                T,\n+                Extent> = false>\n+  constexpr span(const Container& container) noexcept\n+      : span(base::data(container), base::size(container)) {}\n+\n+  template <\n+      typename Container,\n+      internal::EnableIfSpanCompatibleContainerAndSpanIsStatic<const Container&,\n+                                                               T,\n+                                                               Extent> = false>\n+  constexpr explicit span(const Container& container) noexcept\n       : span(base::data(container), base::size(container)) {}\n \n   constexpr span(const span& other) noexcept = default;\n@@ -467,6 +510,23 @@ constexpr span<T> make_span(const Container& container) noexcept {\n   return container;\n }\n \n+template <size_t N,\n+          typename Container,\n+          typename T = typename Container::value_type,\n+          typename = internal::EnableIfSpanCompatibleContainer<Container&, T>>\n+constexpr span<T, N> make_span(Container& container) noexcept {\n+  return span<T, N>(container);\n+}\n+\n+template <\n+    size_t N,\n+    typename Container,\n+    typename T = const typename Container::value_type,\n+    typename = internal::EnableIfSpanCompatibleContainer<const Container&, T>>\n+constexpr span<T, N> make_span(const Container& container) noexcept {\n+  return span<T, N>(container);\n+}\n+\n template <typename T, size_t X>\n constexpr span<T, X> make_span(const span<T, X>& span) noexcept {\n   return span;""}<_**next**_>{""sha"": ""d9499fd8ba2ae0e0618b2383606f91fbfb69db5b"", ""filename"": ""base/containers/span_unittest.cc"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 0, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/containers/span_unittest.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -1101,13 +1101,27 @@ TEST(SpanTest, MakeSpanFromConstContainer) {\n   static_assert(decltype(make_span(vector))::extent == dynamic_extent, \""\"");\n }\n \n+TEST(SpanTest, MakeStaticSpanFromConstContainer) {\n+  const std::vector<int> vector = {-1, -2, -3, -4, -5};\n+  span<const int, 5> span(vector);\n+  EXPECT_EQ(span, make_span<5>(vector));\n+  static_assert(decltype(make_span<5>(vector))::extent == 5, \""\"");\n+}\n+\n TEST(SpanTest, MakeSpanFromContainer) {\n   std::vector<int> vector = {-1, -2, -3, -4, -5};\n   span<int> span(vector);\n   EXPECT_EQ(span, make_span(vector));\n   static_assert(decltype(make_span(vector))::extent == dynamic_extent, \""\"");\n }\n \n+TEST(SpanTest, MakeStaticSpanFromContainer) {\n+  std::vector<int> vector = {-1, -2, -3, -4, -5};\n+  span<int, 5> span(vector);\n+  EXPECT_EQ(span, make_span<5>(vector));\n+  static_assert(decltype(make_span<5>(vector))::extent == 5, \""\"");\n+}\n+\n TEST(SpanTest, MakeSpanFromDynamicSpan) {\n   static constexpr int kArray[] = {1, 2, 3, 4, 5};\n   constexpr span<const int> span(kArray);""}<_**next**_>{""sha"": ""f78685a97b7c4a5df7498f58c890c4fbe1ced32d"", ""filename"": ""base/containers/span_unittest.nc"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span_unittest.nc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span_unittest.nc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/containers/span_unittest.nc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -102,6 +102,22 @@ void WontCompile() {\n   span<int> span(v);\n }\n \n+#elif defined(NCTEST_IMPLICIT_CONVERSION_FROM_DYNAMIC_CONST_CONTAINER_TO_STATIC_SPAN_DISALLOWED) // [r\""fatal error: no viable conversion from 'const std::vector<int>' to 'span<const int, 3>'\""]\n+\n+// A dynamic const container should not be implicitly convertible to a static span.\n+void WontCompile() {\n+  const std::vector<int> v = {1, 2, 3};\n+  span<const int, 3> span = v;\n+}\n+\n+#elif defined(NCTEST_IMPLICIT_CONVERSION_FROM_DYNAMIC_MUTABLE_CONTAINER_TO_STATIC_SPAN_DISALLOWED) // [r\""fatal error: no viable conversion from 'std::vector<int>' to 'span<int, 3>'\""]\n+\n+// A dynamic mutable container should not be implicitly convertible to a static span.\n+void WontCompile() {\n+  std::vector<int> v = {1, 2, 3};\n+  span<int, 3> span = v;\n+}\n+\n #elif defined(NCTEST_STD_SET_CONVERSION_DISALLOWED)  // [r\""fatal error: no matching constructor for initialization of 'span<int>'\""]\n \n // A std::set() should not satisfy the requirements for conversion to a span.""}<_**next**_>{""sha"": ""4fbc6ae976ee383b7500de891e28f3896997f2f9"", ""filename"": ""content/browser/webauth/virtual_authenticator.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/content/browser/webauth/virtual_authenticator.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/content/browser/webauth/virtual_authenticator.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/webauth/virtual_authenticator.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -7,6 +7,7 @@\n #include <utility>\n #include <vector>\n \n+#include \""base/containers/span.h\""\n #include \""base/guid.h\""\n #include \""crypto/ec_private_key.h\""\n #include \""device/fido/virtual_u2f_device.h\""\n@@ -64,7 +65,9 @@ void VirtualAuthenticator::AddRegistration(\n       ::device::VirtualFidoDevice::RegistrationData(\n           crypto::ECPrivateKey::CreateFromPrivateKeyInfo(\n               registration->private_key),\n-          registration->application_parameter, registration->counter));\n+          base::make_span<device::kRpIdHashLength>(\n+              registration->application_parameter),\n+          registration->counter));\n   std::move(callback).Run(success);\n }\n ""}<_**next**_>{""sha"": ""a227377a0969ed8ee5ce31777e5c1b4a5b03cad8"", ""filename"": ""device/fido/cable/fido_cable_handshake_handler.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/cable/fido_cable_handshake_handler.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/cable/fido_cable_handshake_handler.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/device/fido/cable/fido_cable_handshake_handler.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -7,6 +7,7 @@\n #include <algorithm>\n #include <utility>\n \n+#include \""base/containers/span.h\""\n #include \""base/threading/thread_task_runner_handle.h\""\n #include \""components/cbor/cbor_reader.h\""\n #include \""components/cbor/cbor_values.h\""\n@@ -149,8 +150,8 @@ bool FidoCableHandshakeHandler::ValidateAuthenticatorHandshakeMessage(\n   }\n \n   cable_device_->SetEncryptionData(\n-      GetEncryptionKeyAfterSuccessfulHandshake(\n-          authenticator_random_nonce->second.GetBytestring()),\n+      GetEncryptionKeyAfterSuccessfulHandshake(base::make_span<16>(\n+          authenticator_random_nonce->second.GetBytestring())),\n       nonce_);\n \n   return true;""}<_**next**_>{""sha"": ""fa8b455c25273efdf83f572932482048c44cffdc"", ""filename"": ""device/fido/ctap_response_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/ctap_response_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/ctap_response_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/device/fido/ctap_response_unittest.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -574,8 +574,7 @@ TEST(CTAPResponseTest, TestReadGetInfoResponseWithIncorrectFormat) {\n \n TEST(CTAPResponseTest, TestSerializeGetInfoResponse) {\n   AuthenticatorGetInfoResponse response(\n-      {ProtocolVersion::kCtap, ProtocolVersion::kU2f},\n-      fido_parsing_utils::Materialize(kTestDeviceAaguid));\n+      {ProtocolVersion::kCtap, ProtocolVersion::kU2f}, kTestDeviceAaguid);\n   response.SetExtensions({\""uvm\"", \""hmac-secret\""});\n   AuthenticatorSupportedOptions options;\n   options.SetSupportsResidentKey(true);""}<_**next**_>{""sha"": ""e4ee349100db016cf767e95a218976b18477e32c"", ""filename"": ""device/fido/device_response_converter.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/device_response_converter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/device_response_converter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/device/fido/device_response_converter.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -8,6 +8,7 @@\n #include <string>\n #include <utility>\n \n+#include \""base/containers/span.h\""\n #include \""base/numerics/safe_conversions.h\""\n #include \""base/optional.h\""\n #include \""base/stl_util.h\""\n@@ -186,8 +187,9 @@ base::Optional<AuthenticatorGetInfoResponse> ReadCTAPGetInfoResponse(\n     return base::nullopt;\n   }\n \n-  AuthenticatorGetInfoResponse response(std::move(protocol_versions),\n-                                        it->second.GetBytestring());\n+  AuthenticatorGetInfoResponse response(\n+      std::move(protocol_versions),\n+      base::make_span<kAaguidLength>(it->second.GetBytestring()));\n \n   it = response_map.find(CBOR(2));\n   if (it != response_map.end()) {""}<_**next**_>{""sha"": ""ceb35ae0df020daa578e513e483dc748c071cbfc"", ""filename"": ""device/fido/make_credential_task_unittest.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/make_credential_task_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/make_credential_task_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/device/fido/make_credential_task_unittest.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -137,8 +137,7 @@ TEST_F(FidoMakeCredentialTaskTest, TestDefaultU2fRegisterOperationWithoutFlag) {\n \n TEST_F(FidoMakeCredentialTaskTest, DefaultToU2fWhenClientPinSet) {\n   AuthenticatorGetInfoResponse device_info(\n-      {ProtocolVersion::kCtap, ProtocolVersion::kU2f},\n-      fido_parsing_utils::Materialize(kTestDeviceAaguid));\n+      {ProtocolVersion::kCtap, ProtocolVersion::kU2f}, kTestDeviceAaguid);\n   AuthenticatorSupportedOptions options;\n   options.SetClientPinAvailability(\n       AuthenticatorSupportedOptions::ClientPinAvailability::\n@@ -159,8 +158,7 @@ TEST_F(FidoMakeCredentialTaskTest, DefaultToU2fWhenClientPinSet) {\n \n TEST_F(FidoMakeCredentialTaskTest, EnforceClientPinWhenUserVerificationSet) {\n   AuthenticatorGetInfoResponse device_info(\n-      {ProtocolVersion::kCtap, ProtocolVersion::kU2f},\n-      fido_parsing_utils::Materialize(kTestDeviceAaguid));\n+      {ProtocolVersion::kCtap, ProtocolVersion::kU2f}, kTestDeviceAaguid);\n   AuthenticatorSupportedOptions options;\n   options.SetClientPinAvailability(\n       AuthenticatorSupportedOptions::ClientPinAvailability::""}<_**next**_>{""sha"": ""4f9f422a5e0d90aee010a61605f30bfeb17a96ec"", ""filename"": ""net/ntlm/ntlm.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/net/ntlm/ntlm.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/net/ntlm/ntlm.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/net/ntlm/ntlm.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -6,11 +6,13 @@\n \n #include <string.h>\n \n+#include \""base/containers/span.h\""\n #include \""base/logging.h\""\n #include \""base/md5.h\""\n #include \""base/strings/utf_string_conversions.h\""\n #include \""net/base/net_string_util.h\""\n #include \""net/ntlm/ntlm_buffer_writer.h\""\n+#include \""net/ntlm/ntlm_constants.h\""\n #include \""third_party/boringssl/src/include/openssl/des.h\""\n #include \""third_party/boringssl/src/include/openssl/hmac.h\""\n #include \""third_party/boringssl/src/include/openssl/md4.h\""\n@@ -95,7 +97,9 @@ void UpdateTargetInfoAvPairs(bool is_mic_enabled,\n \n     // Hash the channel bindings if they exist otherwise they remain zeros.\n     if (!channel_bindings.empty()) {\n-      GenerateChannelBindingHashV2(channel_bindings, channel_bindings_hash);\n+      GenerateChannelBindingHashV2(\n+          channel_bindings,\n+          base::make_span<kChannelBindingsHashLen>(channel_bindings_hash));\n     }\n \n     av_pairs->emplace_back(TargetInfoAvId::kChannelBindings,""}<_**next**_>{""sha"": ""68b627848ba41484dcbed5c60515cabb7d8b0c28"", ""filename"": ""net/ntlm/ntlm_client.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/net/ntlm/ntlm_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/net/ntlm/ntlm_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/net/ntlm/ntlm_client.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -6,12 +6,14 @@\n \n #include <string.h>\n \n+#include \""base/containers/span.h\""\n #include \""base/logging.h\""\n #include \""base/md5.h\""\n #include \""base/strings/utf_string_conversions.h\""\n #include \""net/ntlm/ntlm.h\""\n #include \""net/ntlm/ntlm_buffer_reader.h\""\n #include \""net/ntlm/ntlm_buffer_writer.h\""\n+#include \""net/ntlm/ntlm_constants.h\""\n \n namespace net {\n namespace ntlm {\n@@ -221,7 +223,8 @@ std::vector<uint8_t> NtlmClient::GenerateAuthenticateMessage(\n     uint8_t v2_hash[kNtlmHashLen];\n     GenerateNtlmHashV2(domain, username, password, v2_hash);\n     v2_proof_input = GenerateProofInputV2(timestamp, client_challenge);\n-    GenerateNtlmProofV2(v2_hash, server_challenge, v2_proof_input,\n+    GenerateNtlmProofV2(v2_hash, server_challenge,\n+                        base::make_span<kProofInputLenV2>(v2_proof_input),\n                         updated_target_info, v2_proof);\n     GenerateSessionBaseKeyV2(v2_hash, v2_proof, v2_session_key);\n   } else {""}","void VirtualAuthenticator::AddRegistration(
    blink::test::mojom::RegisteredKeyPtr registration,
    AddRegistrationCallback callback) {
  if (registration->application_parameter.size() != device::kRpIdHashLength) {
    std::move(callback).Run(false);
    return;
  }

  bool success = false;
  std::tie(std::ignore, success) = state_->registrations.emplace(
      std::move(registration->key_handle),
       ::device::VirtualFidoDevice::RegistrationData(
           crypto::ECPrivateKey::CreateFromPrivateKeyInfo(
               registration->private_key),
          base::make_span<device::kRpIdHashLength>(
              registration->application_parameter),
          registration->counter));
   std::move(callback).Run(success);
 }
","void VirtualAuthenticator::AddRegistration(
    blink::test::mojom::RegisteredKeyPtr registration,
    AddRegistrationCallback callback) {
  if (registration->application_parameter.size() != device::kRpIdHashLength) {
    std::move(callback).Run(false);
    return;
  }

  bool success = false;
  std::tie(std::ignore, success) = state_->registrations.emplace(
      std::move(registration->key_handle),
       ::device::VirtualFidoDevice::RegistrationData(
           crypto::ECPrivateKey::CreateFromPrivateKeyInfo(
               registration->private_key),
          registration->application_parameter, registration->counter));
   std::move(callback).Run(success);
 }
",C,"          base::make_span<device::kRpIdHashLength>(
              registration->application_parameter),
          registration->counter));
","          registration->application_parameter, registration->counter));
",,"@@ -7,6 +7,7 @@
 #include <utility>
 #include <vector>
 
+#include ""base/containers/span.h""
 #include ""base/guid.h""
 #include ""crypto/ec_private_key.h""
 #include ""device/fido/virtual_u2f_device.h""
@@ -64,7 +65,9 @@ void VirtualAuthenticator::AddRegistration(
       ::device::VirtualFidoDevice::RegistrationData(
           crypto::ECPrivateKey::CreateFromPrivateKeyInfo(
               registration->private_key),
-          registration->application_parameter, registration->counter));
+          base::make_span<device::kRpIdHashLength>(
+              registration->application_parameter),
+          registration->counter));
   std::move(callback).Run(success);
 }
 ",Chrome,9cfe470d793da6e09b966d435c8fa2ba1625d5fe,6ffc06bf9e0ecbdbab1587819b9184bd377c1037,1,"void VirtualAuthenticator::AddRegistration(
    blink::test::mojom::RegisteredKeyPtr registration,
    AddRegistrationCallback callback) {
  if (registration->application_parameter.size() != device::kRpIdHashLength) {
    std::move(callback).Run(false);
    return;
  }

  bool success = false;
  std::tie(std::ignore, success) = state_->registrations.emplace(
      std::move(registration->key_handle),
       ::device::VirtualFidoDevice::RegistrationData(
           crypto::ECPrivateKey::CreateFromPrivateKeyInfo(
               registration->private_key),
//flaw_line_below:
          registration->application_parameter, registration->counter));
//fix_flaw_line_below:
//          base::make_span<device::kRpIdHashLength>(
//fix_flaw_line_below:
//              registration->application_parameter),
//fix_flaw_line_below:
//          registration->counter));
   std::move(callback).Run(success);
 }
"
8506,186242,,Remote,Not required,Partial,CVE-2016-1671,https://www.cvedetails.com/cve/CVE-2016-1671/,CWE-22,Medium,Partial,Partial,,2016-05-14,6.8,"Google Chrome before 50.0.2661.102 on Android mishandles / (slash) and  (backslash) characters, which allows attackers to conduct directory traversal attacks via a file: URL, related to net/base/escape.cc and net/base/filename_util.cc.",2016-11-30,Dir. Trav. ,2,https://github.com/chromium/chromium/commit/9cfe470d793da6e09b966d435c8fa2ba1625d5fe,9cfe470d793da6e09b966d435c8fa2ba1625d5fe,"[base] Make dynamic container to static span conversion explicit

This change disallows implicit conversions from dynamic containers to
static spans. This conversion can cause CHECK failures, and thus should
be done carefully. Requiring explicit construction makes it more obvious
when this happens. To aid usability, appropriate base::make_span<size_t>
overloads are added.

Bug: 877931
Change-Id: Id9f526bc57bfd30a52d14df827b0445ca087381d
Reviewed-on: https://chromium-review.googlesource.com/1189985
Reviewed-by: Ryan Sleevi <rsleevi@chromium.org>
Reviewed-by: Balazs Engedy <engedy@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Commit-Queue: Jan Wilken Dörrie <jdoerrie@chromium.org>
Cr-Commit-Position: refs/heads/master@{#586657}",2,device/fido/cable/fido_cable_handshake_handler.cc,"{""sha"": ""2f01162f08c3b186f5ebc35dfbe146920bdda5ea"", ""filename"": ""base/containers/span.h"", ""status"": ""modified"", ""additions"": 69, ""deletions"": 9, ""changes"": 78, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/containers/span.h?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -71,13 +71,31 @@ using EnableIfSpanCompatibleArray =\n                      ContainerHasConvertibleData<Array, T>::value>;\n \n // SFINAE check if Container can be converted to a span<T>.\n+template <typename Container, typename T>\n+using IsSpanCompatibleContainer =\n+    std::conditional_t<!IsSpan<Container>::value &&\n+                           !IsStdArray<Container>::value &&\n+                           !IsCArray<Container>::value &&\n+                           ContainerHasConvertibleData<Container, T>::value &&\n+                           ContainerHasIntegralSize<Container>::value,\n+                       std::true_type,\n+                       std::false_type>;\n+\n template <typename Container, typename T>\n using EnableIfSpanCompatibleContainer =\n-    std::enable_if_t<!internal::IsSpan<Container>::value &&\n-                     !internal::IsStdArray<Container>::value &&\n-                     !internal::IsCArray<Container>::value &&\n-                     ContainerHasConvertibleData<Container, T>::value &&\n-                     ContainerHasIntegralSize<Container>::value>;\n+    std::enable_if_t<IsSpanCompatibleContainer<Container, T>::value>;\n+\n+template <typename Container, typename T, size_t Extent>\n+using EnableIfSpanCompatibleContainerAndSpanIsDynamic =\n+    std::enable_if_t<IsSpanCompatibleContainer<Container, T>::value &&\n+                         Extent == dynamic_extent,\n+                     bool>;\n+\n+template <typename Container, typename T, size_t Extent>\n+using EnableIfSpanCompatibleContainerAndSpanIsStatic =\n+    std::enable_if_t<IsSpanCompatibleContainer<Container, T>::value &&\n+                         Extent != dynamic_extent,\n+                     bool>;\n \n // A helper template for storing the size of a span. Spans with static extents\n // don't require additional storage, since the extent itself is specified in the\n@@ -171,6 +189,10 @@ struct ExtentStorage<dynamic_extent> {\n // Differences in constants and types:\n // - index_type is aliased to size_t\n //\n+// Differences from [span.cons]:\n+// - Constructing a static span (i.e. Extent != dynamic_extent) from a dynamic\n+//   sized container (e.g. std::vector) requires an explicit conversion.\n+//\n // Differences from [span.sub]:\n // - using size_t instead of ptrdiff_t for indexing\n //\n@@ -245,15 +267,36 @@ class span : public internal::ExtentStorage<Extent> {\n \n   // Conversion from a container that has compatible base::data() and integral\n   // base::size().\n-  template <typename Container,\n-            typename = internal::EnableIfSpanCompatibleContainer<Container&, T>>\n+  template <\n+      typename Container,\n+      internal::EnableIfSpanCompatibleContainerAndSpanIsDynamic<Container&,\n+                                                                T,\n+                                                                Extent> = false>\n   constexpr span(Container& container) noexcept\n       : span(base::data(container), base::size(container)) {}\n \n   template <\n       typename Container,\n-      typename = internal::EnableIfSpanCompatibleContainer<const Container&, T>>\n-  span(const Container& container) noexcept\n+      internal::EnableIfSpanCompatibleContainerAndSpanIsStatic<Container&,\n+                                                               T,\n+                                                               Extent> = false>\n+  constexpr explicit span(Container& container) noexcept\n+      : span(base::data(container), base::size(container)) {}\n+\n+  template <typename Container,\n+            internal::EnableIfSpanCompatibleContainerAndSpanIsDynamic<\n+                const Container&,\n+                T,\n+                Extent> = false>\n+  constexpr span(const Container& container) noexcept\n+      : span(base::data(container), base::size(container)) {}\n+\n+  template <\n+      typename Container,\n+      internal::EnableIfSpanCompatibleContainerAndSpanIsStatic<const Container&,\n+                                                               T,\n+                                                               Extent> = false>\n+  constexpr explicit span(const Container& container) noexcept\n       : span(base::data(container), base::size(container)) {}\n \n   constexpr span(const span& other) noexcept = default;\n@@ -467,6 +510,23 @@ constexpr span<T> make_span(const Container& container) noexcept {\n   return container;\n }\n \n+template <size_t N,\n+          typename Container,\n+          typename T = typename Container::value_type,\n+          typename = internal::EnableIfSpanCompatibleContainer<Container&, T>>\n+constexpr span<T, N> make_span(Container& container) noexcept {\n+  return span<T, N>(container);\n+}\n+\n+template <\n+    size_t N,\n+    typename Container,\n+    typename T = const typename Container::value_type,\n+    typename = internal::EnableIfSpanCompatibleContainer<const Container&, T>>\n+constexpr span<T, N> make_span(const Container& container) noexcept {\n+  return span<T, N>(container);\n+}\n+\n template <typename T, size_t X>\n constexpr span<T, X> make_span(const span<T, X>& span) noexcept {\n   return span;""}<_**next**_>{""sha"": ""d9499fd8ba2ae0e0618b2383606f91fbfb69db5b"", ""filename"": ""base/containers/span_unittest.cc"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 0, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/containers/span_unittest.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -1101,13 +1101,27 @@ TEST(SpanTest, MakeSpanFromConstContainer) {\n   static_assert(decltype(make_span(vector))::extent == dynamic_extent, \""\"");\n }\n \n+TEST(SpanTest, MakeStaticSpanFromConstContainer) {\n+  const std::vector<int> vector = {-1, -2, -3, -4, -5};\n+  span<const int, 5> span(vector);\n+  EXPECT_EQ(span, make_span<5>(vector));\n+  static_assert(decltype(make_span<5>(vector))::extent == 5, \""\"");\n+}\n+\n TEST(SpanTest, MakeSpanFromContainer) {\n   std::vector<int> vector = {-1, -2, -3, -4, -5};\n   span<int> span(vector);\n   EXPECT_EQ(span, make_span(vector));\n   static_assert(decltype(make_span(vector))::extent == dynamic_extent, \""\"");\n }\n \n+TEST(SpanTest, MakeStaticSpanFromContainer) {\n+  std::vector<int> vector = {-1, -2, -3, -4, -5};\n+  span<int, 5> span(vector);\n+  EXPECT_EQ(span, make_span<5>(vector));\n+  static_assert(decltype(make_span<5>(vector))::extent == 5, \""\"");\n+}\n+\n TEST(SpanTest, MakeSpanFromDynamicSpan) {\n   static constexpr int kArray[] = {1, 2, 3, 4, 5};\n   constexpr span<const int> span(kArray);""}<_**next**_>{""sha"": ""f78685a97b7c4a5df7498f58c890c4fbe1ced32d"", ""filename"": ""base/containers/span_unittest.nc"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span_unittest.nc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span_unittest.nc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/containers/span_unittest.nc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -102,6 +102,22 @@ void WontCompile() {\n   span<int> span(v);\n }\n \n+#elif defined(NCTEST_IMPLICIT_CONVERSION_FROM_DYNAMIC_CONST_CONTAINER_TO_STATIC_SPAN_DISALLOWED) // [r\""fatal error: no viable conversion from 'const std::vector<int>' to 'span<const int, 3>'\""]\n+\n+// A dynamic const container should not be implicitly convertible to a static span.\n+void WontCompile() {\n+  const std::vector<int> v = {1, 2, 3};\n+  span<const int, 3> span = v;\n+}\n+\n+#elif defined(NCTEST_IMPLICIT_CONVERSION_FROM_DYNAMIC_MUTABLE_CONTAINER_TO_STATIC_SPAN_DISALLOWED) // [r\""fatal error: no viable conversion from 'std::vector<int>' to 'span<int, 3>'\""]\n+\n+// A dynamic mutable container should not be implicitly convertible to a static span.\n+void WontCompile() {\n+  std::vector<int> v = {1, 2, 3};\n+  span<int, 3> span = v;\n+}\n+\n #elif defined(NCTEST_STD_SET_CONVERSION_DISALLOWED)  // [r\""fatal error: no matching constructor for initialization of 'span<int>'\""]\n \n // A std::set() should not satisfy the requirements for conversion to a span.""}<_**next**_>{""sha"": ""4fbc6ae976ee383b7500de891e28f3896997f2f9"", ""filename"": ""content/browser/webauth/virtual_authenticator.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/content/browser/webauth/virtual_authenticator.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/content/browser/webauth/virtual_authenticator.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/webauth/virtual_authenticator.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -7,6 +7,7 @@\n #include <utility>\n #include <vector>\n \n+#include \""base/containers/span.h\""\n #include \""base/guid.h\""\n #include \""crypto/ec_private_key.h\""\n #include \""device/fido/virtual_u2f_device.h\""\n@@ -64,7 +65,9 @@ void VirtualAuthenticator::AddRegistration(\n       ::device::VirtualFidoDevice::RegistrationData(\n           crypto::ECPrivateKey::CreateFromPrivateKeyInfo(\n               registration->private_key),\n-          registration->application_parameter, registration->counter));\n+          base::make_span<device::kRpIdHashLength>(\n+              registration->application_parameter),\n+          registration->counter));\n   std::move(callback).Run(success);\n }\n ""}<_**next**_>{""sha"": ""a227377a0969ed8ee5ce31777e5c1b4a5b03cad8"", ""filename"": ""device/fido/cable/fido_cable_handshake_handler.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/cable/fido_cable_handshake_handler.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/cable/fido_cable_handshake_handler.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/device/fido/cable/fido_cable_handshake_handler.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -7,6 +7,7 @@\n #include <algorithm>\n #include <utility>\n \n+#include \""base/containers/span.h\""\n #include \""base/threading/thread_task_runner_handle.h\""\n #include \""components/cbor/cbor_reader.h\""\n #include \""components/cbor/cbor_values.h\""\n@@ -149,8 +150,8 @@ bool FidoCableHandshakeHandler::ValidateAuthenticatorHandshakeMessage(\n   }\n \n   cable_device_->SetEncryptionData(\n-      GetEncryptionKeyAfterSuccessfulHandshake(\n-          authenticator_random_nonce->second.GetBytestring()),\n+      GetEncryptionKeyAfterSuccessfulHandshake(base::make_span<16>(\n+          authenticator_random_nonce->second.GetBytestring())),\n       nonce_);\n \n   return true;""}<_**next**_>{""sha"": ""fa8b455c25273efdf83f572932482048c44cffdc"", ""filename"": ""device/fido/ctap_response_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/ctap_response_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/ctap_response_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/device/fido/ctap_response_unittest.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -574,8 +574,7 @@ TEST(CTAPResponseTest, TestReadGetInfoResponseWithIncorrectFormat) {\n \n TEST(CTAPResponseTest, TestSerializeGetInfoResponse) {\n   AuthenticatorGetInfoResponse response(\n-      {ProtocolVersion::kCtap, ProtocolVersion::kU2f},\n-      fido_parsing_utils::Materialize(kTestDeviceAaguid));\n+      {ProtocolVersion::kCtap, ProtocolVersion::kU2f}, kTestDeviceAaguid);\n   response.SetExtensions({\""uvm\"", \""hmac-secret\""});\n   AuthenticatorSupportedOptions options;\n   options.SetSupportsResidentKey(true);""}<_**next**_>{""sha"": ""e4ee349100db016cf767e95a218976b18477e32c"", ""filename"": ""device/fido/device_response_converter.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/device_response_converter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/device_response_converter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/device/fido/device_response_converter.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -8,6 +8,7 @@\n #include <string>\n #include <utility>\n \n+#include \""base/containers/span.h\""\n #include \""base/numerics/safe_conversions.h\""\n #include \""base/optional.h\""\n #include \""base/stl_util.h\""\n@@ -186,8 +187,9 @@ base::Optional<AuthenticatorGetInfoResponse> ReadCTAPGetInfoResponse(\n     return base::nullopt;\n   }\n \n-  AuthenticatorGetInfoResponse response(std::move(protocol_versions),\n-                                        it->second.GetBytestring());\n+  AuthenticatorGetInfoResponse response(\n+      std::move(protocol_versions),\n+      base::make_span<kAaguidLength>(it->second.GetBytestring()));\n \n   it = response_map.find(CBOR(2));\n   if (it != response_map.end()) {""}<_**next**_>{""sha"": ""ceb35ae0df020daa578e513e483dc748c071cbfc"", ""filename"": ""device/fido/make_credential_task_unittest.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/make_credential_task_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/make_credential_task_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/device/fido/make_credential_task_unittest.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -137,8 +137,7 @@ TEST_F(FidoMakeCredentialTaskTest, TestDefaultU2fRegisterOperationWithoutFlag) {\n \n TEST_F(FidoMakeCredentialTaskTest, DefaultToU2fWhenClientPinSet) {\n   AuthenticatorGetInfoResponse device_info(\n-      {ProtocolVersion::kCtap, ProtocolVersion::kU2f},\n-      fido_parsing_utils::Materialize(kTestDeviceAaguid));\n+      {ProtocolVersion::kCtap, ProtocolVersion::kU2f}, kTestDeviceAaguid);\n   AuthenticatorSupportedOptions options;\n   options.SetClientPinAvailability(\n       AuthenticatorSupportedOptions::ClientPinAvailability::\n@@ -159,8 +158,7 @@ TEST_F(FidoMakeCredentialTaskTest, DefaultToU2fWhenClientPinSet) {\n \n TEST_F(FidoMakeCredentialTaskTest, EnforceClientPinWhenUserVerificationSet) {\n   AuthenticatorGetInfoResponse device_info(\n-      {ProtocolVersion::kCtap, ProtocolVersion::kU2f},\n-      fido_parsing_utils::Materialize(kTestDeviceAaguid));\n+      {ProtocolVersion::kCtap, ProtocolVersion::kU2f}, kTestDeviceAaguid);\n   AuthenticatorSupportedOptions options;\n   options.SetClientPinAvailability(\n       AuthenticatorSupportedOptions::ClientPinAvailability::""}<_**next**_>{""sha"": ""4f9f422a5e0d90aee010a61605f30bfeb17a96ec"", ""filename"": ""net/ntlm/ntlm.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/net/ntlm/ntlm.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/net/ntlm/ntlm.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/net/ntlm/ntlm.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -6,11 +6,13 @@\n \n #include <string.h>\n \n+#include \""base/containers/span.h\""\n #include \""base/logging.h\""\n #include \""base/md5.h\""\n #include \""base/strings/utf_string_conversions.h\""\n #include \""net/base/net_string_util.h\""\n #include \""net/ntlm/ntlm_buffer_writer.h\""\n+#include \""net/ntlm/ntlm_constants.h\""\n #include \""third_party/boringssl/src/include/openssl/des.h\""\n #include \""third_party/boringssl/src/include/openssl/hmac.h\""\n #include \""third_party/boringssl/src/include/openssl/md4.h\""\n@@ -95,7 +97,9 @@ void UpdateTargetInfoAvPairs(bool is_mic_enabled,\n \n     // Hash the channel bindings if they exist otherwise they remain zeros.\n     if (!channel_bindings.empty()) {\n-      GenerateChannelBindingHashV2(channel_bindings, channel_bindings_hash);\n+      GenerateChannelBindingHashV2(\n+          channel_bindings,\n+          base::make_span<kChannelBindingsHashLen>(channel_bindings_hash));\n     }\n \n     av_pairs->emplace_back(TargetInfoAvId::kChannelBindings,""}<_**next**_>{""sha"": ""68b627848ba41484dcbed5c60515cabb7d8b0c28"", ""filename"": ""net/ntlm/ntlm_client.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/net/ntlm/ntlm_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/net/ntlm/ntlm_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/net/ntlm/ntlm_client.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -6,12 +6,14 @@\n \n #include <string.h>\n \n+#include \""base/containers/span.h\""\n #include \""base/logging.h\""\n #include \""base/md5.h\""\n #include \""base/strings/utf_string_conversions.h\""\n #include \""net/ntlm/ntlm.h\""\n #include \""net/ntlm/ntlm_buffer_reader.h\""\n #include \""net/ntlm/ntlm_buffer_writer.h\""\n+#include \""net/ntlm/ntlm_constants.h\""\n \n namespace net {\n namespace ntlm {\n@@ -221,7 +223,8 @@ std::vector<uint8_t> NtlmClient::GenerateAuthenticateMessage(\n     uint8_t v2_hash[kNtlmHashLen];\n     GenerateNtlmHashV2(domain, username, password, v2_hash);\n     v2_proof_input = GenerateProofInputV2(timestamp, client_challenge);\n-    GenerateNtlmProofV2(v2_hash, server_challenge, v2_proof_input,\n+    GenerateNtlmProofV2(v2_hash, server_challenge,\n+                        base::make_span<kProofInputLenV2>(v2_proof_input),\n                         updated_target_info, v2_proof);\n     GenerateSessionBaseKeyV2(v2_hash, v2_proof, v2_session_key);\n   } else {""}","bool FidoCableHandshakeHandler::ValidateAuthenticatorHandshakeMessage(
    base::span<const uint8_t> response) {
  crypto::HMAC hmac(crypto::HMAC::SHA256);
  if (!hmac.Init(handshake_key_))
    return false;

  if (response.size() != kCableAuthenticatorHandshakeMessageSize) {
    return false;
  }

  const auto authenticator_hello = response.first(
      kCableAuthenticatorHandshakeMessageSize - kCableHandshakeMacMessageSize);
  if (!hmac.VerifyTruncated(
          fido_parsing_utils::ConvertToStringPiece(authenticator_hello),
          fido_parsing_utils::ConvertToStringPiece(
              response.subspan(authenticator_hello.size())))) {
    return false;
  }

  const auto authenticator_hello_cbor =
      cbor::CBORReader::Read(authenticator_hello);
  if (!authenticator_hello_cbor || !authenticator_hello_cbor->is_map() ||
      authenticator_hello_cbor->GetMap().size() != 2) {
    return false;
  }

  const auto authenticator_hello_msg =
      authenticator_hello_cbor->GetMap().find(cbor::CBORValue(0));
  if (authenticator_hello_msg == authenticator_hello_cbor->GetMap().end() ||
      !authenticator_hello_msg->second.is_string() ||
      authenticator_hello_msg->second.GetString() !=
          kCableAuthenticatorHelloMessage) {
    return false;
  }

  const auto authenticator_random_nonce =
      authenticator_hello_cbor->GetMap().find(cbor::CBORValue(1));
  if (authenticator_random_nonce == authenticator_hello_cbor->GetMap().end() ||
      !authenticator_random_nonce->second.is_bytestring() ||
      authenticator_random_nonce->second.GetBytestring().size() != 16) {
    return false;
   }
 
   cable_device_->SetEncryptionData(
      GetEncryptionKeyAfterSuccessfulHandshake(base::make_span<16>(
          authenticator_random_nonce->second.GetBytestring())),
       nonce_);
 
   return true;
}
","bool FidoCableHandshakeHandler::ValidateAuthenticatorHandshakeMessage(
    base::span<const uint8_t> response) {
  crypto::HMAC hmac(crypto::HMAC::SHA256);
  if (!hmac.Init(handshake_key_))
    return false;

  if (response.size() != kCableAuthenticatorHandshakeMessageSize) {
    return false;
  }

  const auto authenticator_hello = response.first(
      kCableAuthenticatorHandshakeMessageSize - kCableHandshakeMacMessageSize);
  if (!hmac.VerifyTruncated(
          fido_parsing_utils::ConvertToStringPiece(authenticator_hello),
          fido_parsing_utils::ConvertToStringPiece(
              response.subspan(authenticator_hello.size())))) {
    return false;
  }

  const auto authenticator_hello_cbor =
      cbor::CBORReader::Read(authenticator_hello);
  if (!authenticator_hello_cbor || !authenticator_hello_cbor->is_map() ||
      authenticator_hello_cbor->GetMap().size() != 2) {
    return false;
  }

  const auto authenticator_hello_msg =
      authenticator_hello_cbor->GetMap().find(cbor::CBORValue(0));
  if (authenticator_hello_msg == authenticator_hello_cbor->GetMap().end() ||
      !authenticator_hello_msg->second.is_string() ||
      authenticator_hello_msg->second.GetString() !=
          kCableAuthenticatorHelloMessage) {
    return false;
  }

  const auto authenticator_random_nonce =
      authenticator_hello_cbor->GetMap().find(cbor::CBORValue(1));
  if (authenticator_random_nonce == authenticator_hello_cbor->GetMap().end() ||
      !authenticator_random_nonce->second.is_bytestring() ||
      authenticator_random_nonce->second.GetBytestring().size() != 16) {
    return false;
   }
 
   cable_device_->SetEncryptionData(
      GetEncryptionKeyAfterSuccessfulHandshake(
          authenticator_random_nonce->second.GetBytestring()),
       nonce_);
 
   return true;
}
",C,"      GetEncryptionKeyAfterSuccessfulHandshake(base::make_span<16>(
          authenticator_random_nonce->second.GetBytestring())),
","      GetEncryptionKeyAfterSuccessfulHandshake(
          authenticator_random_nonce->second.GetBytestring()),
",,"@@ -7,6 +7,7 @@
 #include <algorithm>
 #include <utility>
 
+#include ""base/containers/span.h""
 #include ""base/threading/thread_task_runner_handle.h""
 #include ""components/cbor/cbor_reader.h""
 #include ""components/cbor/cbor_values.h""
@@ -149,8 +150,8 @@ bool FidoCableHandshakeHandler::ValidateAuthenticatorHandshakeMessage(
   }
 
   cable_device_->SetEncryptionData(
-      GetEncryptionKeyAfterSuccessfulHandshake(
-          authenticator_random_nonce->second.GetBytestring()),
+      GetEncryptionKeyAfterSuccessfulHandshake(base::make_span<16>(
+          authenticator_random_nonce->second.GetBytestring())),
       nonce_);
 
   return true;",Chrome,9cfe470d793da6e09b966d435c8fa2ba1625d5fe,6ffc06bf9e0ecbdbab1587819b9184bd377c1037,1,"bool FidoCableHandshakeHandler::ValidateAuthenticatorHandshakeMessage(
    base::span<const uint8_t> response) {
  crypto::HMAC hmac(crypto::HMAC::SHA256);
  if (!hmac.Init(handshake_key_))
    return false;

  if (response.size() != kCableAuthenticatorHandshakeMessageSize) {
    return false;
  }

  const auto authenticator_hello = response.first(
      kCableAuthenticatorHandshakeMessageSize - kCableHandshakeMacMessageSize);
  if (!hmac.VerifyTruncated(
          fido_parsing_utils::ConvertToStringPiece(authenticator_hello),
          fido_parsing_utils::ConvertToStringPiece(
              response.subspan(authenticator_hello.size())))) {
    return false;
  }

  const auto authenticator_hello_cbor =
      cbor::CBORReader::Read(authenticator_hello);
  if (!authenticator_hello_cbor || !authenticator_hello_cbor->is_map() ||
      authenticator_hello_cbor->GetMap().size() != 2) {
    return false;
  }

  const auto authenticator_hello_msg =
      authenticator_hello_cbor->GetMap().find(cbor::CBORValue(0));
  if (authenticator_hello_msg == authenticator_hello_cbor->GetMap().end() ||
      !authenticator_hello_msg->second.is_string() ||
      authenticator_hello_msg->second.GetString() !=
          kCableAuthenticatorHelloMessage) {
    return false;
  }

  const auto authenticator_random_nonce =
      authenticator_hello_cbor->GetMap().find(cbor::CBORValue(1));
  if (authenticator_random_nonce == authenticator_hello_cbor->GetMap().end() ||
      !authenticator_random_nonce->second.is_bytestring() ||
      authenticator_random_nonce->second.GetBytestring().size() != 16) {
    return false;
   }
 
   cable_device_->SetEncryptionData(
//flaw_line_below:
      GetEncryptionKeyAfterSuccessfulHandshake(
//flaw_line_below:
          authenticator_random_nonce->second.GetBytestring()),
//fix_flaw_line_below:
//      GetEncryptionKeyAfterSuccessfulHandshake(base::make_span<16>(
//fix_flaw_line_below:
//          authenticator_random_nonce->second.GetBytestring())),
       nonce_);
 
   return true;
}
"
8507,186243,,Remote,Not required,Partial,CVE-2016-1671,https://www.cvedetails.com/cve/CVE-2016-1671/,CWE-22,Medium,Partial,Partial,,2016-05-14,6.8,"Google Chrome before 50.0.2661.102 on Android mishandles / (slash) and  (backslash) characters, which allows attackers to conduct directory traversal attacks via a file: URL, related to net/base/escape.cc and net/base/filename_util.cc.",2016-11-30,Dir. Trav. ,3,https://github.com/chromium/chromium/commit/9cfe470d793da6e09b966d435c8fa2ba1625d5fe,9cfe470d793da6e09b966d435c8fa2ba1625d5fe,"[base] Make dynamic container to static span conversion explicit

This change disallows implicit conversions from dynamic containers to
static spans. This conversion can cause CHECK failures, and thus should
be done carefully. Requiring explicit construction makes it more obvious
when this happens. To aid usability, appropriate base::make_span<size_t>
overloads are added.

Bug: 877931
Change-Id: Id9f526bc57bfd30a52d14df827b0445ca087381d
Reviewed-on: https://chromium-review.googlesource.com/1189985
Reviewed-by: Ryan Sleevi <rsleevi@chromium.org>
Reviewed-by: Balazs Engedy <engedy@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Commit-Queue: Jan Wilken Dörrie <jdoerrie@chromium.org>
Cr-Commit-Position: refs/heads/master@{#586657}",2,device/fido/device_response_converter.cc,"{""sha"": ""2f01162f08c3b186f5ebc35dfbe146920bdda5ea"", ""filename"": ""base/containers/span.h"", ""status"": ""modified"", ""additions"": 69, ""deletions"": 9, ""changes"": 78, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/containers/span.h?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -71,13 +71,31 @@ using EnableIfSpanCompatibleArray =\n                      ContainerHasConvertibleData<Array, T>::value>;\n \n // SFINAE check if Container can be converted to a span<T>.\n+template <typename Container, typename T>\n+using IsSpanCompatibleContainer =\n+    std::conditional_t<!IsSpan<Container>::value &&\n+                           !IsStdArray<Container>::value &&\n+                           !IsCArray<Container>::value &&\n+                           ContainerHasConvertibleData<Container, T>::value &&\n+                           ContainerHasIntegralSize<Container>::value,\n+                       std::true_type,\n+                       std::false_type>;\n+\n template <typename Container, typename T>\n using EnableIfSpanCompatibleContainer =\n-    std::enable_if_t<!internal::IsSpan<Container>::value &&\n-                     !internal::IsStdArray<Container>::value &&\n-                     !internal::IsCArray<Container>::value &&\n-                     ContainerHasConvertibleData<Container, T>::value &&\n-                     ContainerHasIntegralSize<Container>::value>;\n+    std::enable_if_t<IsSpanCompatibleContainer<Container, T>::value>;\n+\n+template <typename Container, typename T, size_t Extent>\n+using EnableIfSpanCompatibleContainerAndSpanIsDynamic =\n+    std::enable_if_t<IsSpanCompatibleContainer<Container, T>::value &&\n+                         Extent == dynamic_extent,\n+                     bool>;\n+\n+template <typename Container, typename T, size_t Extent>\n+using EnableIfSpanCompatibleContainerAndSpanIsStatic =\n+    std::enable_if_t<IsSpanCompatibleContainer<Container, T>::value &&\n+                         Extent != dynamic_extent,\n+                     bool>;\n \n // A helper template for storing the size of a span. Spans with static extents\n // don't require additional storage, since the extent itself is specified in the\n@@ -171,6 +189,10 @@ struct ExtentStorage<dynamic_extent> {\n // Differences in constants and types:\n // - index_type is aliased to size_t\n //\n+// Differences from [span.cons]:\n+// - Constructing a static span (i.e. Extent != dynamic_extent) from a dynamic\n+//   sized container (e.g. std::vector) requires an explicit conversion.\n+//\n // Differences from [span.sub]:\n // - using size_t instead of ptrdiff_t for indexing\n //\n@@ -245,15 +267,36 @@ class span : public internal::ExtentStorage<Extent> {\n \n   // Conversion from a container that has compatible base::data() and integral\n   // base::size().\n-  template <typename Container,\n-            typename = internal::EnableIfSpanCompatibleContainer<Container&, T>>\n+  template <\n+      typename Container,\n+      internal::EnableIfSpanCompatibleContainerAndSpanIsDynamic<Container&,\n+                                                                T,\n+                                                                Extent> = false>\n   constexpr span(Container& container) noexcept\n       : span(base::data(container), base::size(container)) {}\n \n   template <\n       typename Container,\n-      typename = internal::EnableIfSpanCompatibleContainer<const Container&, T>>\n-  span(const Container& container) noexcept\n+      internal::EnableIfSpanCompatibleContainerAndSpanIsStatic<Container&,\n+                                                               T,\n+                                                               Extent> = false>\n+  constexpr explicit span(Container& container) noexcept\n+      : span(base::data(container), base::size(container)) {}\n+\n+  template <typename Container,\n+            internal::EnableIfSpanCompatibleContainerAndSpanIsDynamic<\n+                const Container&,\n+                T,\n+                Extent> = false>\n+  constexpr span(const Container& container) noexcept\n+      : span(base::data(container), base::size(container)) {}\n+\n+  template <\n+      typename Container,\n+      internal::EnableIfSpanCompatibleContainerAndSpanIsStatic<const Container&,\n+                                                               T,\n+                                                               Extent> = false>\n+  constexpr explicit span(const Container& container) noexcept\n       : span(base::data(container), base::size(container)) {}\n \n   constexpr span(const span& other) noexcept = default;\n@@ -467,6 +510,23 @@ constexpr span<T> make_span(const Container& container) noexcept {\n   return container;\n }\n \n+template <size_t N,\n+          typename Container,\n+          typename T = typename Container::value_type,\n+          typename = internal::EnableIfSpanCompatibleContainer<Container&, T>>\n+constexpr span<T, N> make_span(Container& container) noexcept {\n+  return span<T, N>(container);\n+}\n+\n+template <\n+    size_t N,\n+    typename Container,\n+    typename T = const typename Container::value_type,\n+    typename = internal::EnableIfSpanCompatibleContainer<const Container&, T>>\n+constexpr span<T, N> make_span(const Container& container) noexcept {\n+  return span<T, N>(container);\n+}\n+\n template <typename T, size_t X>\n constexpr span<T, X> make_span(const span<T, X>& span) noexcept {\n   return span;""}<_**next**_>{""sha"": ""d9499fd8ba2ae0e0618b2383606f91fbfb69db5b"", ""filename"": ""base/containers/span_unittest.cc"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 0, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/containers/span_unittest.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -1101,13 +1101,27 @@ TEST(SpanTest, MakeSpanFromConstContainer) {\n   static_assert(decltype(make_span(vector))::extent == dynamic_extent, \""\"");\n }\n \n+TEST(SpanTest, MakeStaticSpanFromConstContainer) {\n+  const std::vector<int> vector = {-1, -2, -3, -4, -5};\n+  span<const int, 5> span(vector);\n+  EXPECT_EQ(span, make_span<5>(vector));\n+  static_assert(decltype(make_span<5>(vector))::extent == 5, \""\"");\n+}\n+\n TEST(SpanTest, MakeSpanFromContainer) {\n   std::vector<int> vector = {-1, -2, -3, -4, -5};\n   span<int> span(vector);\n   EXPECT_EQ(span, make_span(vector));\n   static_assert(decltype(make_span(vector))::extent == dynamic_extent, \""\"");\n }\n \n+TEST(SpanTest, MakeStaticSpanFromContainer) {\n+  std::vector<int> vector = {-1, -2, -3, -4, -5};\n+  span<int, 5> span(vector);\n+  EXPECT_EQ(span, make_span<5>(vector));\n+  static_assert(decltype(make_span<5>(vector))::extent == 5, \""\"");\n+}\n+\n TEST(SpanTest, MakeSpanFromDynamicSpan) {\n   static constexpr int kArray[] = {1, 2, 3, 4, 5};\n   constexpr span<const int> span(kArray);""}<_**next**_>{""sha"": ""f78685a97b7c4a5df7498f58c890c4fbe1ced32d"", ""filename"": ""base/containers/span_unittest.nc"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span_unittest.nc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span_unittest.nc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/containers/span_unittest.nc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -102,6 +102,22 @@ void WontCompile() {\n   span<int> span(v);\n }\n \n+#elif defined(NCTEST_IMPLICIT_CONVERSION_FROM_DYNAMIC_CONST_CONTAINER_TO_STATIC_SPAN_DISALLOWED) // [r\""fatal error: no viable conversion from 'const std::vector<int>' to 'span<const int, 3>'\""]\n+\n+// A dynamic const container should not be implicitly convertible to a static span.\n+void WontCompile() {\n+  const std::vector<int> v = {1, 2, 3};\n+  span<const int, 3> span = v;\n+}\n+\n+#elif defined(NCTEST_IMPLICIT_CONVERSION_FROM_DYNAMIC_MUTABLE_CONTAINER_TO_STATIC_SPAN_DISALLOWED) // [r\""fatal error: no viable conversion from 'std::vector<int>' to 'span<int, 3>'\""]\n+\n+// A dynamic mutable container should not be implicitly convertible to a static span.\n+void WontCompile() {\n+  std::vector<int> v = {1, 2, 3};\n+  span<int, 3> span = v;\n+}\n+\n #elif defined(NCTEST_STD_SET_CONVERSION_DISALLOWED)  // [r\""fatal error: no matching constructor for initialization of 'span<int>'\""]\n \n // A std::set() should not satisfy the requirements for conversion to a span.""}<_**next**_>{""sha"": ""4fbc6ae976ee383b7500de891e28f3896997f2f9"", ""filename"": ""content/browser/webauth/virtual_authenticator.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/content/browser/webauth/virtual_authenticator.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/content/browser/webauth/virtual_authenticator.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/webauth/virtual_authenticator.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -7,6 +7,7 @@\n #include <utility>\n #include <vector>\n \n+#include \""base/containers/span.h\""\n #include \""base/guid.h\""\n #include \""crypto/ec_private_key.h\""\n #include \""device/fido/virtual_u2f_device.h\""\n@@ -64,7 +65,9 @@ void VirtualAuthenticator::AddRegistration(\n       ::device::VirtualFidoDevice::RegistrationData(\n           crypto::ECPrivateKey::CreateFromPrivateKeyInfo(\n               registration->private_key),\n-          registration->application_parameter, registration->counter));\n+          base::make_span<device::kRpIdHashLength>(\n+              registration->application_parameter),\n+          registration->counter));\n   std::move(callback).Run(success);\n }\n ""}<_**next**_>{""sha"": ""a227377a0969ed8ee5ce31777e5c1b4a5b03cad8"", ""filename"": ""device/fido/cable/fido_cable_handshake_handler.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/cable/fido_cable_handshake_handler.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/cable/fido_cable_handshake_handler.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/device/fido/cable/fido_cable_handshake_handler.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -7,6 +7,7 @@\n #include <algorithm>\n #include <utility>\n \n+#include \""base/containers/span.h\""\n #include \""base/threading/thread_task_runner_handle.h\""\n #include \""components/cbor/cbor_reader.h\""\n #include \""components/cbor/cbor_values.h\""\n@@ -149,8 +150,8 @@ bool FidoCableHandshakeHandler::ValidateAuthenticatorHandshakeMessage(\n   }\n \n   cable_device_->SetEncryptionData(\n-      GetEncryptionKeyAfterSuccessfulHandshake(\n-          authenticator_random_nonce->second.GetBytestring()),\n+      GetEncryptionKeyAfterSuccessfulHandshake(base::make_span<16>(\n+          authenticator_random_nonce->second.GetBytestring())),\n       nonce_);\n \n   return true;""}<_**next**_>{""sha"": ""fa8b455c25273efdf83f572932482048c44cffdc"", ""filename"": ""device/fido/ctap_response_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/ctap_response_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/ctap_response_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/device/fido/ctap_response_unittest.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -574,8 +574,7 @@ TEST(CTAPResponseTest, TestReadGetInfoResponseWithIncorrectFormat) {\n \n TEST(CTAPResponseTest, TestSerializeGetInfoResponse) {\n   AuthenticatorGetInfoResponse response(\n-      {ProtocolVersion::kCtap, ProtocolVersion::kU2f},\n-      fido_parsing_utils::Materialize(kTestDeviceAaguid));\n+      {ProtocolVersion::kCtap, ProtocolVersion::kU2f}, kTestDeviceAaguid);\n   response.SetExtensions({\""uvm\"", \""hmac-secret\""});\n   AuthenticatorSupportedOptions options;\n   options.SetSupportsResidentKey(true);""}<_**next**_>{""sha"": ""e4ee349100db016cf767e95a218976b18477e32c"", ""filename"": ""device/fido/device_response_converter.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/device_response_converter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/device_response_converter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/device/fido/device_response_converter.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -8,6 +8,7 @@\n #include <string>\n #include <utility>\n \n+#include \""base/containers/span.h\""\n #include \""base/numerics/safe_conversions.h\""\n #include \""base/optional.h\""\n #include \""base/stl_util.h\""\n@@ -186,8 +187,9 @@ base::Optional<AuthenticatorGetInfoResponse> ReadCTAPGetInfoResponse(\n     return base::nullopt;\n   }\n \n-  AuthenticatorGetInfoResponse response(std::move(protocol_versions),\n-                                        it->second.GetBytestring());\n+  AuthenticatorGetInfoResponse response(\n+      std::move(protocol_versions),\n+      base::make_span<kAaguidLength>(it->second.GetBytestring()));\n \n   it = response_map.find(CBOR(2));\n   if (it != response_map.end()) {""}<_**next**_>{""sha"": ""ceb35ae0df020daa578e513e483dc748c071cbfc"", ""filename"": ""device/fido/make_credential_task_unittest.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/make_credential_task_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/make_credential_task_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/device/fido/make_credential_task_unittest.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -137,8 +137,7 @@ TEST_F(FidoMakeCredentialTaskTest, TestDefaultU2fRegisterOperationWithoutFlag) {\n \n TEST_F(FidoMakeCredentialTaskTest, DefaultToU2fWhenClientPinSet) {\n   AuthenticatorGetInfoResponse device_info(\n-      {ProtocolVersion::kCtap, ProtocolVersion::kU2f},\n-      fido_parsing_utils::Materialize(kTestDeviceAaguid));\n+      {ProtocolVersion::kCtap, ProtocolVersion::kU2f}, kTestDeviceAaguid);\n   AuthenticatorSupportedOptions options;\n   options.SetClientPinAvailability(\n       AuthenticatorSupportedOptions::ClientPinAvailability::\n@@ -159,8 +158,7 @@ TEST_F(FidoMakeCredentialTaskTest, DefaultToU2fWhenClientPinSet) {\n \n TEST_F(FidoMakeCredentialTaskTest, EnforceClientPinWhenUserVerificationSet) {\n   AuthenticatorGetInfoResponse device_info(\n-      {ProtocolVersion::kCtap, ProtocolVersion::kU2f},\n-      fido_parsing_utils::Materialize(kTestDeviceAaguid));\n+      {ProtocolVersion::kCtap, ProtocolVersion::kU2f}, kTestDeviceAaguid);\n   AuthenticatorSupportedOptions options;\n   options.SetClientPinAvailability(\n       AuthenticatorSupportedOptions::ClientPinAvailability::""}<_**next**_>{""sha"": ""4f9f422a5e0d90aee010a61605f30bfeb17a96ec"", ""filename"": ""net/ntlm/ntlm.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/net/ntlm/ntlm.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/net/ntlm/ntlm.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/net/ntlm/ntlm.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -6,11 +6,13 @@\n \n #include <string.h>\n \n+#include \""base/containers/span.h\""\n #include \""base/logging.h\""\n #include \""base/md5.h\""\n #include \""base/strings/utf_string_conversions.h\""\n #include \""net/base/net_string_util.h\""\n #include \""net/ntlm/ntlm_buffer_writer.h\""\n+#include \""net/ntlm/ntlm_constants.h\""\n #include \""third_party/boringssl/src/include/openssl/des.h\""\n #include \""third_party/boringssl/src/include/openssl/hmac.h\""\n #include \""third_party/boringssl/src/include/openssl/md4.h\""\n@@ -95,7 +97,9 @@ void UpdateTargetInfoAvPairs(bool is_mic_enabled,\n \n     // Hash the channel bindings if they exist otherwise they remain zeros.\n     if (!channel_bindings.empty()) {\n-      GenerateChannelBindingHashV2(channel_bindings, channel_bindings_hash);\n+      GenerateChannelBindingHashV2(\n+          channel_bindings,\n+          base::make_span<kChannelBindingsHashLen>(channel_bindings_hash));\n     }\n \n     av_pairs->emplace_back(TargetInfoAvId::kChannelBindings,""}<_**next**_>{""sha"": ""68b627848ba41484dcbed5c60515cabb7d8b0c28"", ""filename"": ""net/ntlm/ntlm_client.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/net/ntlm/ntlm_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/net/ntlm/ntlm_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/net/ntlm/ntlm_client.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -6,12 +6,14 @@\n \n #include <string.h>\n \n+#include \""base/containers/span.h\""\n #include \""base/logging.h\""\n #include \""base/md5.h\""\n #include \""base/strings/utf_string_conversions.h\""\n #include \""net/ntlm/ntlm.h\""\n #include \""net/ntlm/ntlm_buffer_reader.h\""\n #include \""net/ntlm/ntlm_buffer_writer.h\""\n+#include \""net/ntlm/ntlm_constants.h\""\n \n namespace net {\n namespace ntlm {\n@@ -221,7 +223,8 @@ std::vector<uint8_t> NtlmClient::GenerateAuthenticateMessage(\n     uint8_t v2_hash[kNtlmHashLen];\n     GenerateNtlmHashV2(domain, username, password, v2_hash);\n     v2_proof_input = GenerateProofInputV2(timestamp, client_challenge);\n-    GenerateNtlmProofV2(v2_hash, server_challenge, v2_proof_input,\n+    GenerateNtlmProofV2(v2_hash, server_challenge,\n+                        base::make_span<kProofInputLenV2>(v2_proof_input),\n                         updated_target_info, v2_proof);\n     GenerateSessionBaseKeyV2(v2_hash, v2_proof, v2_session_key);\n   } else {""}","base::Optional<AuthenticatorGetInfoResponse> ReadCTAPGetInfoResponse(
    base::span<const uint8_t> buffer) {
  if (buffer.size() <= kResponseCodeLength ||
      GetResponseCode(buffer) != CtapDeviceResponseCode::kSuccess)
    return base::nullopt;

  base::Optional<CBOR> decoded_response =
      cbor::CBORReader::Read(buffer.subspan(1));

  if (!decoded_response || !decoded_response->is_map())
    return base::nullopt;

  const auto& response_map = decoded_response->GetMap();

  auto it = response_map.find(CBOR(1));
  if (it == response_map.end() || !it->second.is_array() ||
      it->second.GetArray().size() > 2) {
    return base::nullopt;
  }

  base::flat_set<ProtocolVersion> protocol_versions;
  for (const auto& version : it->second.GetArray()) {
    if (!version.is_string())
      return base::nullopt;

    auto protocol = ConvertStringToProtocolVersion(version.GetString());
    if (protocol == ProtocolVersion::kUnknown) {
      VLOG(2) << ""Unexpected protocol version received."";
      continue;
    }

    if (!protocol_versions.insert(protocol).second)
      return base::nullopt;
  }

  if (protocol_versions.empty())
    return base::nullopt;

  it = response_map.find(CBOR(3));
  if (it == response_map.end() || !it->second.is_bytestring() ||
      it->second.GetBytestring().size() != kAaguidLength) {
     return base::nullopt;
   }
 
  AuthenticatorGetInfoResponse response(
      std::move(protocol_versions),
      base::make_span<kAaguidLength>(it->second.GetBytestring()));
 
   it = response_map.find(CBOR(2));
   if (it != response_map.end()) {
    if (!it->second.is_array())
      return base::nullopt;

    std::vector<std::string> extensions;
    for (const auto& extension : it->second.GetArray()) {
      if (!extension.is_string())
        return base::nullopt;

      extensions.push_back(extension.GetString());
    }
    response.SetExtensions(std::move(extensions));
  }

  AuthenticatorSupportedOptions options;
  it = response_map.find(CBOR(4));
  if (it != response_map.end()) {
    if (!it->second.is_map())
      return base::nullopt;

    const auto& option_map = it->second.GetMap();
    auto option_map_it = option_map.find(CBOR(kPlatformDeviceMapKey));
    if (option_map_it != option_map.end()) {
      if (!option_map_it->second.is_bool())
        return base::nullopt;

      options.SetIsPlatformDevice(option_map_it->second.GetBool());
    }

    option_map_it = option_map.find(CBOR(kResidentKeyMapKey));
    if (option_map_it != option_map.end()) {
      if (!option_map_it->second.is_bool())
        return base::nullopt;

      options.SetSupportsResidentKey(option_map_it->second.GetBool());
    }

    option_map_it = option_map.find(CBOR(kUserPresenceMapKey));
    if (option_map_it != option_map.end()) {
      if (!option_map_it->second.is_bool())
        return base::nullopt;

      options.SetUserPresenceRequired(option_map_it->second.GetBool());
    }

    option_map_it = option_map.find(CBOR(kUserVerificationMapKey));
    if (option_map_it != option_map.end()) {
      if (!option_map_it->second.is_bool())
        return base::nullopt;

      if (option_map_it->second.GetBool()) {
        options.SetUserVerificationAvailability(
            AuthenticatorSupportedOptions::UserVerificationAvailability::
                kSupportedAndConfigured);
      } else {
        options.SetUserVerificationAvailability(
            AuthenticatorSupportedOptions::UserVerificationAvailability::
                kSupportedButNotConfigured);
      }
    }

    option_map_it = option_map.find(CBOR(kClientPinMapKey));
    if (option_map_it != option_map.end()) {
      if (!option_map_it->second.is_bool())
        return base::nullopt;

      if (option_map_it->second.GetBool()) {
        options.SetClientPinAvailability(
            AuthenticatorSupportedOptions::ClientPinAvailability::
                kSupportedAndPinSet);
      } else {
        options.SetClientPinAvailability(
            AuthenticatorSupportedOptions::ClientPinAvailability::
                kSupportedButPinNotSet);
      }
    }
    response.SetOptions(std::move(options));
  }

  it = response_map.find(CBOR(5));
  if (it != response_map.end()) {
    if (!it->second.is_unsigned())
      return base::nullopt;

    response.SetMaxMsgSize(it->second.GetUnsigned());
  }

  it = response_map.find(CBOR(6));
  if (it != response_map.end()) {
    if (!it->second.is_array())
      return base::nullopt;

    std::vector<uint8_t> supported_pin_protocols;
    for (const auto& protocol : it->second.GetArray()) {
      if (!protocol.is_unsigned())
        return base::nullopt;

      supported_pin_protocols.push_back(protocol.GetUnsigned());
    }
    response.SetPinProtocols(std::move(supported_pin_protocols));
  }

  return base::Optional<AuthenticatorGetInfoResponse>(std::move(response));
}
","base::Optional<AuthenticatorGetInfoResponse> ReadCTAPGetInfoResponse(
    base::span<const uint8_t> buffer) {
  if (buffer.size() <= kResponseCodeLength ||
      GetResponseCode(buffer) != CtapDeviceResponseCode::kSuccess)
    return base::nullopt;

  base::Optional<CBOR> decoded_response =
      cbor::CBORReader::Read(buffer.subspan(1));

  if (!decoded_response || !decoded_response->is_map())
    return base::nullopt;

  const auto& response_map = decoded_response->GetMap();

  auto it = response_map.find(CBOR(1));
  if (it == response_map.end() || !it->second.is_array() ||
      it->second.GetArray().size() > 2) {
    return base::nullopt;
  }

  base::flat_set<ProtocolVersion> protocol_versions;
  for (const auto& version : it->second.GetArray()) {
    if (!version.is_string())
      return base::nullopt;

    auto protocol = ConvertStringToProtocolVersion(version.GetString());
    if (protocol == ProtocolVersion::kUnknown) {
      VLOG(2) << ""Unexpected protocol version received."";
      continue;
    }

    if (!protocol_versions.insert(protocol).second)
      return base::nullopt;
  }

  if (protocol_versions.empty())
    return base::nullopt;

  it = response_map.find(CBOR(3));
  if (it == response_map.end() || !it->second.is_bytestring() ||
      it->second.GetBytestring().size() != kAaguidLength) {
     return base::nullopt;
   }
 
  AuthenticatorGetInfoResponse response(std::move(protocol_versions),
                                        it->second.GetBytestring());
 
   it = response_map.find(CBOR(2));
   if (it != response_map.end()) {
    if (!it->second.is_array())
      return base::nullopt;

    std::vector<std::string> extensions;
    for (const auto& extension : it->second.GetArray()) {
      if (!extension.is_string())
        return base::nullopt;

      extensions.push_back(extension.GetString());
    }
    response.SetExtensions(std::move(extensions));
  }

  AuthenticatorSupportedOptions options;
  it = response_map.find(CBOR(4));
  if (it != response_map.end()) {
    if (!it->second.is_map())
      return base::nullopt;

    const auto& option_map = it->second.GetMap();
    auto option_map_it = option_map.find(CBOR(kPlatformDeviceMapKey));
    if (option_map_it != option_map.end()) {
      if (!option_map_it->second.is_bool())
        return base::nullopt;

      options.SetIsPlatformDevice(option_map_it->second.GetBool());
    }

    option_map_it = option_map.find(CBOR(kResidentKeyMapKey));
    if (option_map_it != option_map.end()) {
      if (!option_map_it->second.is_bool())
        return base::nullopt;

      options.SetSupportsResidentKey(option_map_it->second.GetBool());
    }

    option_map_it = option_map.find(CBOR(kUserPresenceMapKey));
    if (option_map_it != option_map.end()) {
      if (!option_map_it->second.is_bool())
        return base::nullopt;

      options.SetUserPresenceRequired(option_map_it->second.GetBool());
    }

    option_map_it = option_map.find(CBOR(kUserVerificationMapKey));
    if (option_map_it != option_map.end()) {
      if (!option_map_it->second.is_bool())
        return base::nullopt;

      if (option_map_it->second.GetBool()) {
        options.SetUserVerificationAvailability(
            AuthenticatorSupportedOptions::UserVerificationAvailability::
                kSupportedAndConfigured);
      } else {
        options.SetUserVerificationAvailability(
            AuthenticatorSupportedOptions::UserVerificationAvailability::
                kSupportedButNotConfigured);
      }
    }

    option_map_it = option_map.find(CBOR(kClientPinMapKey));
    if (option_map_it != option_map.end()) {
      if (!option_map_it->second.is_bool())
        return base::nullopt;

      if (option_map_it->second.GetBool()) {
        options.SetClientPinAvailability(
            AuthenticatorSupportedOptions::ClientPinAvailability::
                kSupportedAndPinSet);
      } else {
        options.SetClientPinAvailability(
            AuthenticatorSupportedOptions::ClientPinAvailability::
                kSupportedButPinNotSet);
      }
    }
    response.SetOptions(std::move(options));
  }

  it = response_map.find(CBOR(5));
  if (it != response_map.end()) {
    if (!it->second.is_unsigned())
      return base::nullopt;

    response.SetMaxMsgSize(it->second.GetUnsigned());
  }

  it = response_map.find(CBOR(6));
  if (it != response_map.end()) {
    if (!it->second.is_array())
      return base::nullopt;

    std::vector<uint8_t> supported_pin_protocols;
    for (const auto& protocol : it->second.GetArray()) {
      if (!protocol.is_unsigned())
        return base::nullopt;

      supported_pin_protocols.push_back(protocol.GetUnsigned());
    }
    response.SetPinProtocols(std::move(supported_pin_protocols));
  }

  return base::Optional<AuthenticatorGetInfoResponse>(std::move(response));
}
",C,"  AuthenticatorGetInfoResponse response(
      std::move(protocol_versions),
      base::make_span<kAaguidLength>(it->second.GetBytestring()));
","  AuthenticatorGetInfoResponse response(std::move(protocol_versions),
                                        it->second.GetBytestring());
",,"@@ -8,6 +8,7 @@
 #include <string>
 #include <utility>
 
+#include ""base/containers/span.h""
 #include ""base/numerics/safe_conversions.h""
 #include ""base/optional.h""
 #include ""base/stl_util.h""
@@ -186,8 +187,9 @@ base::Optional<AuthenticatorGetInfoResponse> ReadCTAPGetInfoResponse(
     return base::nullopt;
   }
 
-  AuthenticatorGetInfoResponse response(std::move(protocol_versions),
-                                        it->second.GetBytestring());
+  AuthenticatorGetInfoResponse response(
+      std::move(protocol_versions),
+      base::make_span<kAaguidLength>(it->second.GetBytestring()));
 
   it = response_map.find(CBOR(2));
   if (it != response_map.end()) {",Chrome,9cfe470d793da6e09b966d435c8fa2ba1625d5fe,6ffc06bf9e0ecbdbab1587819b9184bd377c1037,1,"base::Optional<AuthenticatorGetInfoResponse> ReadCTAPGetInfoResponse(
    base::span<const uint8_t> buffer) {
  if (buffer.size() <= kResponseCodeLength ||
      GetResponseCode(buffer) != CtapDeviceResponseCode::kSuccess)
    return base::nullopt;

  base::Optional<CBOR> decoded_response =
      cbor::CBORReader::Read(buffer.subspan(1));

  if (!decoded_response || !decoded_response->is_map())
    return base::nullopt;

  const auto& response_map = decoded_response->GetMap();

  auto it = response_map.find(CBOR(1));
  if (it == response_map.end() || !it->second.is_array() ||
      it->second.GetArray().size() > 2) {
    return base::nullopt;
  }

  base::flat_set<ProtocolVersion> protocol_versions;
  for (const auto& version : it->second.GetArray()) {
    if (!version.is_string())
      return base::nullopt;

    auto protocol = ConvertStringToProtocolVersion(version.GetString());
    if (protocol == ProtocolVersion::kUnknown) {
      VLOG(2) << ""Unexpected protocol version received."";
      continue;
    }

    if (!protocol_versions.insert(protocol).second)
      return base::nullopt;
  }

  if (protocol_versions.empty())
    return base::nullopt;

  it = response_map.find(CBOR(3));
  if (it == response_map.end() || !it->second.is_bytestring() ||
      it->second.GetBytestring().size() != kAaguidLength) {
     return base::nullopt;
   }
 
//flaw_line_below:
  AuthenticatorGetInfoResponse response(std::move(protocol_versions),
//flaw_line_below:
                                        it->second.GetBytestring());
//fix_flaw_line_below:
//  AuthenticatorGetInfoResponse response(
//fix_flaw_line_below:
//      std::move(protocol_versions),
//fix_flaw_line_below:
//      base::make_span<kAaguidLength>(it->second.GetBytestring()));
 
   it = response_map.find(CBOR(2));
   if (it != response_map.end()) {
    if (!it->second.is_array())
      return base::nullopt;

    std::vector<std::string> extensions;
    for (const auto& extension : it->second.GetArray()) {
      if (!extension.is_string())
        return base::nullopt;

      extensions.push_back(extension.GetString());
    }
    response.SetExtensions(std::move(extensions));
  }

  AuthenticatorSupportedOptions options;
  it = response_map.find(CBOR(4));
  if (it != response_map.end()) {
    if (!it->second.is_map())
      return base::nullopt;

    const auto& option_map = it->second.GetMap();
    auto option_map_it = option_map.find(CBOR(kPlatformDeviceMapKey));
    if (option_map_it != option_map.end()) {
      if (!option_map_it->second.is_bool())
        return base::nullopt;

      options.SetIsPlatformDevice(option_map_it->second.GetBool());
    }

    option_map_it = option_map.find(CBOR(kResidentKeyMapKey));
    if (option_map_it != option_map.end()) {
      if (!option_map_it->second.is_bool())
        return base::nullopt;

      options.SetSupportsResidentKey(option_map_it->second.GetBool());
    }

    option_map_it = option_map.find(CBOR(kUserPresenceMapKey));
    if (option_map_it != option_map.end()) {
      if (!option_map_it->second.is_bool())
        return base::nullopt;

      options.SetUserPresenceRequired(option_map_it->second.GetBool());
    }

    option_map_it = option_map.find(CBOR(kUserVerificationMapKey));
    if (option_map_it != option_map.end()) {
      if (!option_map_it->second.is_bool())
        return base::nullopt;

      if (option_map_it->second.GetBool()) {
        options.SetUserVerificationAvailability(
            AuthenticatorSupportedOptions::UserVerificationAvailability::
                kSupportedAndConfigured);
      } else {
        options.SetUserVerificationAvailability(
            AuthenticatorSupportedOptions::UserVerificationAvailability::
                kSupportedButNotConfigured);
      }
    }

    option_map_it = option_map.find(CBOR(kClientPinMapKey));
    if (option_map_it != option_map.end()) {
      if (!option_map_it->second.is_bool())
        return base::nullopt;

      if (option_map_it->second.GetBool()) {
        options.SetClientPinAvailability(
            AuthenticatorSupportedOptions::ClientPinAvailability::
                kSupportedAndPinSet);
      } else {
        options.SetClientPinAvailability(
            AuthenticatorSupportedOptions::ClientPinAvailability::
                kSupportedButPinNotSet);
      }
    }
    response.SetOptions(std::move(options));
  }

  it = response_map.find(CBOR(5));
  if (it != response_map.end()) {
    if (!it->second.is_unsigned())
      return base::nullopt;

    response.SetMaxMsgSize(it->second.GetUnsigned());
  }

  it = response_map.find(CBOR(6));
  if (it != response_map.end()) {
    if (!it->second.is_array())
      return base::nullopt;

    std::vector<uint8_t> supported_pin_protocols;
    for (const auto& protocol : it->second.GetArray()) {
      if (!protocol.is_unsigned())
        return base::nullopt;

      supported_pin_protocols.push_back(protocol.GetUnsigned());
    }
    response.SetPinProtocols(std::move(supported_pin_protocols));
  }

  return base::Optional<AuthenticatorGetInfoResponse>(std::move(response));
}
"
8508,186244,,Remote,Not required,Partial,CVE-2016-1671,https://www.cvedetails.com/cve/CVE-2016-1671/,CWE-22,Medium,Partial,Partial,,2016-05-14,6.8,"Google Chrome before 50.0.2661.102 on Android mishandles / (slash) and  (backslash) characters, which allows attackers to conduct directory traversal attacks via a file: URL, related to net/base/escape.cc and net/base/filename_util.cc.",2016-11-30,Dir. Trav. ,3,https://github.com/chromium/chromium/commit/9cfe470d793da6e09b966d435c8fa2ba1625d5fe,9cfe470d793da6e09b966d435c8fa2ba1625d5fe,"[base] Make dynamic container to static span conversion explicit

This change disallows implicit conversions from dynamic containers to
static spans. This conversion can cause CHECK failures, and thus should
be done carefully. Requiring explicit construction makes it more obvious
when this happens. To aid usability, appropriate base::make_span<size_t>
overloads are added.

Bug: 877931
Change-Id: Id9f526bc57bfd30a52d14df827b0445ca087381d
Reviewed-on: https://chromium-review.googlesource.com/1189985
Reviewed-by: Ryan Sleevi <rsleevi@chromium.org>
Reviewed-by: Balazs Engedy <engedy@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Commit-Queue: Jan Wilken Dörrie <jdoerrie@chromium.org>
Cr-Commit-Position: refs/heads/master@{#586657}",1,net/ntlm/ntlm.cc,"{""sha"": ""2f01162f08c3b186f5ebc35dfbe146920bdda5ea"", ""filename"": ""base/containers/span.h"", ""status"": ""modified"", ""additions"": 69, ""deletions"": 9, ""changes"": 78, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/containers/span.h?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -71,13 +71,31 @@ using EnableIfSpanCompatibleArray =\n                      ContainerHasConvertibleData<Array, T>::value>;\n \n // SFINAE check if Container can be converted to a span<T>.\n+template <typename Container, typename T>\n+using IsSpanCompatibleContainer =\n+    std::conditional_t<!IsSpan<Container>::value &&\n+                           !IsStdArray<Container>::value &&\n+                           !IsCArray<Container>::value &&\n+                           ContainerHasConvertibleData<Container, T>::value &&\n+                           ContainerHasIntegralSize<Container>::value,\n+                       std::true_type,\n+                       std::false_type>;\n+\n template <typename Container, typename T>\n using EnableIfSpanCompatibleContainer =\n-    std::enable_if_t<!internal::IsSpan<Container>::value &&\n-                     !internal::IsStdArray<Container>::value &&\n-                     !internal::IsCArray<Container>::value &&\n-                     ContainerHasConvertibleData<Container, T>::value &&\n-                     ContainerHasIntegralSize<Container>::value>;\n+    std::enable_if_t<IsSpanCompatibleContainer<Container, T>::value>;\n+\n+template <typename Container, typename T, size_t Extent>\n+using EnableIfSpanCompatibleContainerAndSpanIsDynamic =\n+    std::enable_if_t<IsSpanCompatibleContainer<Container, T>::value &&\n+                         Extent == dynamic_extent,\n+                     bool>;\n+\n+template <typename Container, typename T, size_t Extent>\n+using EnableIfSpanCompatibleContainerAndSpanIsStatic =\n+    std::enable_if_t<IsSpanCompatibleContainer<Container, T>::value &&\n+                         Extent != dynamic_extent,\n+                     bool>;\n \n // A helper template for storing the size of a span. Spans with static extents\n // don't require additional storage, since the extent itself is specified in the\n@@ -171,6 +189,10 @@ struct ExtentStorage<dynamic_extent> {\n // Differences in constants and types:\n // - index_type is aliased to size_t\n //\n+// Differences from [span.cons]:\n+// - Constructing a static span (i.e. Extent != dynamic_extent) from a dynamic\n+//   sized container (e.g. std::vector) requires an explicit conversion.\n+//\n // Differences from [span.sub]:\n // - using size_t instead of ptrdiff_t for indexing\n //\n@@ -245,15 +267,36 @@ class span : public internal::ExtentStorage<Extent> {\n \n   // Conversion from a container that has compatible base::data() and integral\n   // base::size().\n-  template <typename Container,\n-            typename = internal::EnableIfSpanCompatibleContainer<Container&, T>>\n+  template <\n+      typename Container,\n+      internal::EnableIfSpanCompatibleContainerAndSpanIsDynamic<Container&,\n+                                                                T,\n+                                                                Extent> = false>\n   constexpr span(Container& container) noexcept\n       : span(base::data(container), base::size(container)) {}\n \n   template <\n       typename Container,\n-      typename = internal::EnableIfSpanCompatibleContainer<const Container&, T>>\n-  span(const Container& container) noexcept\n+      internal::EnableIfSpanCompatibleContainerAndSpanIsStatic<Container&,\n+                                                               T,\n+                                                               Extent> = false>\n+  constexpr explicit span(Container& container) noexcept\n+      : span(base::data(container), base::size(container)) {}\n+\n+  template <typename Container,\n+            internal::EnableIfSpanCompatibleContainerAndSpanIsDynamic<\n+                const Container&,\n+                T,\n+                Extent> = false>\n+  constexpr span(const Container& container) noexcept\n+      : span(base::data(container), base::size(container)) {}\n+\n+  template <\n+      typename Container,\n+      internal::EnableIfSpanCompatibleContainerAndSpanIsStatic<const Container&,\n+                                                               T,\n+                                                               Extent> = false>\n+  constexpr explicit span(const Container& container) noexcept\n       : span(base::data(container), base::size(container)) {}\n \n   constexpr span(const span& other) noexcept = default;\n@@ -467,6 +510,23 @@ constexpr span<T> make_span(const Container& container) noexcept {\n   return container;\n }\n \n+template <size_t N,\n+          typename Container,\n+          typename T = typename Container::value_type,\n+          typename = internal::EnableIfSpanCompatibleContainer<Container&, T>>\n+constexpr span<T, N> make_span(Container& container) noexcept {\n+  return span<T, N>(container);\n+}\n+\n+template <\n+    size_t N,\n+    typename Container,\n+    typename T = const typename Container::value_type,\n+    typename = internal::EnableIfSpanCompatibleContainer<const Container&, T>>\n+constexpr span<T, N> make_span(const Container& container) noexcept {\n+  return span<T, N>(container);\n+}\n+\n template <typename T, size_t X>\n constexpr span<T, X> make_span(const span<T, X>& span) noexcept {\n   return span;""}<_**next**_>{""sha"": ""d9499fd8ba2ae0e0618b2383606f91fbfb69db5b"", ""filename"": ""base/containers/span_unittest.cc"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 0, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/containers/span_unittest.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -1101,13 +1101,27 @@ TEST(SpanTest, MakeSpanFromConstContainer) {\n   static_assert(decltype(make_span(vector))::extent == dynamic_extent, \""\"");\n }\n \n+TEST(SpanTest, MakeStaticSpanFromConstContainer) {\n+  const std::vector<int> vector = {-1, -2, -3, -4, -5};\n+  span<const int, 5> span(vector);\n+  EXPECT_EQ(span, make_span<5>(vector));\n+  static_assert(decltype(make_span<5>(vector))::extent == 5, \""\"");\n+}\n+\n TEST(SpanTest, MakeSpanFromContainer) {\n   std::vector<int> vector = {-1, -2, -3, -4, -5};\n   span<int> span(vector);\n   EXPECT_EQ(span, make_span(vector));\n   static_assert(decltype(make_span(vector))::extent == dynamic_extent, \""\"");\n }\n \n+TEST(SpanTest, MakeStaticSpanFromContainer) {\n+  std::vector<int> vector = {-1, -2, -3, -4, -5};\n+  span<int, 5> span(vector);\n+  EXPECT_EQ(span, make_span<5>(vector));\n+  static_assert(decltype(make_span<5>(vector))::extent == 5, \""\"");\n+}\n+\n TEST(SpanTest, MakeSpanFromDynamicSpan) {\n   static constexpr int kArray[] = {1, 2, 3, 4, 5};\n   constexpr span<const int> span(kArray);""}<_**next**_>{""sha"": ""f78685a97b7c4a5df7498f58c890c4fbe1ced32d"", ""filename"": ""base/containers/span_unittest.nc"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span_unittest.nc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span_unittest.nc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/containers/span_unittest.nc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -102,6 +102,22 @@ void WontCompile() {\n   span<int> span(v);\n }\n \n+#elif defined(NCTEST_IMPLICIT_CONVERSION_FROM_DYNAMIC_CONST_CONTAINER_TO_STATIC_SPAN_DISALLOWED) // [r\""fatal error: no viable conversion from 'const std::vector<int>' to 'span<const int, 3>'\""]\n+\n+// A dynamic const container should not be implicitly convertible to a static span.\n+void WontCompile() {\n+  const std::vector<int> v = {1, 2, 3};\n+  span<const int, 3> span = v;\n+}\n+\n+#elif defined(NCTEST_IMPLICIT_CONVERSION_FROM_DYNAMIC_MUTABLE_CONTAINER_TO_STATIC_SPAN_DISALLOWED) // [r\""fatal error: no viable conversion from 'std::vector<int>' to 'span<int, 3>'\""]\n+\n+// A dynamic mutable container should not be implicitly convertible to a static span.\n+void WontCompile() {\n+  std::vector<int> v = {1, 2, 3};\n+  span<int, 3> span = v;\n+}\n+\n #elif defined(NCTEST_STD_SET_CONVERSION_DISALLOWED)  // [r\""fatal error: no matching constructor for initialization of 'span<int>'\""]\n \n // A std::set() should not satisfy the requirements for conversion to a span.""}<_**next**_>{""sha"": ""4fbc6ae976ee383b7500de891e28f3896997f2f9"", ""filename"": ""content/browser/webauth/virtual_authenticator.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/content/browser/webauth/virtual_authenticator.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/content/browser/webauth/virtual_authenticator.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/webauth/virtual_authenticator.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -7,6 +7,7 @@\n #include <utility>\n #include <vector>\n \n+#include \""base/containers/span.h\""\n #include \""base/guid.h\""\n #include \""crypto/ec_private_key.h\""\n #include \""device/fido/virtual_u2f_device.h\""\n@@ -64,7 +65,9 @@ void VirtualAuthenticator::AddRegistration(\n       ::device::VirtualFidoDevice::RegistrationData(\n           crypto::ECPrivateKey::CreateFromPrivateKeyInfo(\n               registration->private_key),\n-          registration->application_parameter, registration->counter));\n+          base::make_span<device::kRpIdHashLength>(\n+              registration->application_parameter),\n+          registration->counter));\n   std::move(callback).Run(success);\n }\n ""}<_**next**_>{""sha"": ""a227377a0969ed8ee5ce31777e5c1b4a5b03cad8"", ""filename"": ""device/fido/cable/fido_cable_handshake_handler.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/cable/fido_cable_handshake_handler.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/cable/fido_cable_handshake_handler.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/device/fido/cable/fido_cable_handshake_handler.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -7,6 +7,7 @@\n #include <algorithm>\n #include <utility>\n \n+#include \""base/containers/span.h\""\n #include \""base/threading/thread_task_runner_handle.h\""\n #include \""components/cbor/cbor_reader.h\""\n #include \""components/cbor/cbor_values.h\""\n@@ -149,8 +150,8 @@ bool FidoCableHandshakeHandler::ValidateAuthenticatorHandshakeMessage(\n   }\n \n   cable_device_->SetEncryptionData(\n-      GetEncryptionKeyAfterSuccessfulHandshake(\n-          authenticator_random_nonce->second.GetBytestring()),\n+      GetEncryptionKeyAfterSuccessfulHandshake(base::make_span<16>(\n+          authenticator_random_nonce->second.GetBytestring())),\n       nonce_);\n \n   return true;""}<_**next**_>{""sha"": ""fa8b455c25273efdf83f572932482048c44cffdc"", ""filename"": ""device/fido/ctap_response_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/ctap_response_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/ctap_response_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/device/fido/ctap_response_unittest.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -574,8 +574,7 @@ TEST(CTAPResponseTest, TestReadGetInfoResponseWithIncorrectFormat) {\n \n TEST(CTAPResponseTest, TestSerializeGetInfoResponse) {\n   AuthenticatorGetInfoResponse response(\n-      {ProtocolVersion::kCtap, ProtocolVersion::kU2f},\n-      fido_parsing_utils::Materialize(kTestDeviceAaguid));\n+      {ProtocolVersion::kCtap, ProtocolVersion::kU2f}, kTestDeviceAaguid);\n   response.SetExtensions({\""uvm\"", \""hmac-secret\""});\n   AuthenticatorSupportedOptions options;\n   options.SetSupportsResidentKey(true);""}<_**next**_>{""sha"": ""e4ee349100db016cf767e95a218976b18477e32c"", ""filename"": ""device/fido/device_response_converter.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/device_response_converter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/device_response_converter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/device/fido/device_response_converter.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -8,6 +8,7 @@\n #include <string>\n #include <utility>\n \n+#include \""base/containers/span.h\""\n #include \""base/numerics/safe_conversions.h\""\n #include \""base/optional.h\""\n #include \""base/stl_util.h\""\n@@ -186,8 +187,9 @@ base::Optional<AuthenticatorGetInfoResponse> ReadCTAPGetInfoResponse(\n     return base::nullopt;\n   }\n \n-  AuthenticatorGetInfoResponse response(std::move(protocol_versions),\n-                                        it->second.GetBytestring());\n+  AuthenticatorGetInfoResponse response(\n+      std::move(protocol_versions),\n+      base::make_span<kAaguidLength>(it->second.GetBytestring()));\n \n   it = response_map.find(CBOR(2));\n   if (it != response_map.end()) {""}<_**next**_>{""sha"": ""ceb35ae0df020daa578e513e483dc748c071cbfc"", ""filename"": ""device/fido/make_credential_task_unittest.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/make_credential_task_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/make_credential_task_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/device/fido/make_credential_task_unittest.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -137,8 +137,7 @@ TEST_F(FidoMakeCredentialTaskTest, TestDefaultU2fRegisterOperationWithoutFlag) {\n \n TEST_F(FidoMakeCredentialTaskTest, DefaultToU2fWhenClientPinSet) {\n   AuthenticatorGetInfoResponse device_info(\n-      {ProtocolVersion::kCtap, ProtocolVersion::kU2f},\n-      fido_parsing_utils::Materialize(kTestDeviceAaguid));\n+      {ProtocolVersion::kCtap, ProtocolVersion::kU2f}, kTestDeviceAaguid);\n   AuthenticatorSupportedOptions options;\n   options.SetClientPinAvailability(\n       AuthenticatorSupportedOptions::ClientPinAvailability::\n@@ -159,8 +158,7 @@ TEST_F(FidoMakeCredentialTaskTest, DefaultToU2fWhenClientPinSet) {\n \n TEST_F(FidoMakeCredentialTaskTest, EnforceClientPinWhenUserVerificationSet) {\n   AuthenticatorGetInfoResponse device_info(\n-      {ProtocolVersion::kCtap, ProtocolVersion::kU2f},\n-      fido_parsing_utils::Materialize(kTestDeviceAaguid));\n+      {ProtocolVersion::kCtap, ProtocolVersion::kU2f}, kTestDeviceAaguid);\n   AuthenticatorSupportedOptions options;\n   options.SetClientPinAvailability(\n       AuthenticatorSupportedOptions::ClientPinAvailability::""}<_**next**_>{""sha"": ""4f9f422a5e0d90aee010a61605f30bfeb17a96ec"", ""filename"": ""net/ntlm/ntlm.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/net/ntlm/ntlm.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/net/ntlm/ntlm.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/net/ntlm/ntlm.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -6,11 +6,13 @@\n \n #include <string.h>\n \n+#include \""base/containers/span.h\""\n #include \""base/logging.h\""\n #include \""base/md5.h\""\n #include \""base/strings/utf_string_conversions.h\""\n #include \""net/base/net_string_util.h\""\n #include \""net/ntlm/ntlm_buffer_writer.h\""\n+#include \""net/ntlm/ntlm_constants.h\""\n #include \""third_party/boringssl/src/include/openssl/des.h\""\n #include \""third_party/boringssl/src/include/openssl/hmac.h\""\n #include \""third_party/boringssl/src/include/openssl/md4.h\""\n@@ -95,7 +97,9 @@ void UpdateTargetInfoAvPairs(bool is_mic_enabled,\n \n     // Hash the channel bindings if they exist otherwise they remain zeros.\n     if (!channel_bindings.empty()) {\n-      GenerateChannelBindingHashV2(channel_bindings, channel_bindings_hash);\n+      GenerateChannelBindingHashV2(\n+          channel_bindings,\n+          base::make_span<kChannelBindingsHashLen>(channel_bindings_hash));\n     }\n \n     av_pairs->emplace_back(TargetInfoAvId::kChannelBindings,""}<_**next**_>{""sha"": ""68b627848ba41484dcbed5c60515cabb7d8b0c28"", ""filename"": ""net/ntlm/ntlm_client.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/net/ntlm/ntlm_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/net/ntlm/ntlm_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/net/ntlm/ntlm_client.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -6,12 +6,14 @@\n \n #include <string.h>\n \n+#include \""base/containers/span.h\""\n #include \""base/logging.h\""\n #include \""base/md5.h\""\n #include \""base/strings/utf_string_conversions.h\""\n #include \""net/ntlm/ntlm.h\""\n #include \""net/ntlm/ntlm_buffer_reader.h\""\n #include \""net/ntlm/ntlm_buffer_writer.h\""\n+#include \""net/ntlm/ntlm_constants.h\""\n \n namespace net {\n namespace ntlm {\n@@ -221,7 +223,8 @@ std::vector<uint8_t> NtlmClient::GenerateAuthenticateMessage(\n     uint8_t v2_hash[kNtlmHashLen];\n     GenerateNtlmHashV2(domain, username, password, v2_hash);\n     v2_proof_input = GenerateProofInputV2(timestamp, client_challenge);\n-    GenerateNtlmProofV2(v2_hash, server_challenge, v2_proof_input,\n+    GenerateNtlmProofV2(v2_hash, server_challenge,\n+                        base::make_span<kProofInputLenV2>(v2_proof_input),\n                         updated_target_info, v2_proof);\n     GenerateSessionBaseKeyV2(v2_hash, v2_proof, v2_session_key);\n   } else {""}","void UpdateTargetInfoAvPairs(bool is_mic_enabled,
                             bool is_epa_enabled,
                             const std::string& channel_bindings,
                             const std::string& spn,
                             std::vector<AvPair>* av_pairs,
                             uint64_t* server_timestamp,
                             size_t* target_info_len) {
  *server_timestamp = UINT64_MAX;
  *target_info_len = 0;

  bool need_flags_added = is_mic_enabled;
  for (AvPair& pair : *av_pairs) {
    *target_info_len += pair.avlen + kAvPairHeaderLen;
    switch (pair.avid) {
      case TargetInfoAvId::kFlags:
        if (is_mic_enabled) {
          pair.flags = pair.flags | TargetInfoAvFlags::kMicPresent;
        }

        need_flags_added = false;
        break;
      case TargetInfoAvId::kTimestamp:
        *server_timestamp = pair.timestamp;
        break;
      case TargetInfoAvId::kEol:
      case TargetInfoAvId::kChannelBindings:
      case TargetInfoAvId::kTargetName:
        NOTREACHED();
        break;
      default:
        break;
    }
  }

  if (need_flags_added) {
    DCHECK(is_mic_enabled);
    AvPair flags_pair(TargetInfoAvId::kFlags, sizeof(uint32_t));
    flags_pair.flags = TargetInfoAvFlags::kMicPresent;

    av_pairs->push_back(flags_pair);
    *target_info_len += kAvPairHeaderLen + flags_pair.avlen;
  }

  if (is_epa_enabled) {
    std::vector<uint8_t> channel_bindings_hash(kChannelBindingsHashLen, 0);
 
     if (!channel_bindings.empty()) {
      GenerateChannelBindingHashV2(
          channel_bindings,
          base::make_span<kChannelBindingsHashLen>(channel_bindings_hash));
     }
 
     av_pairs->emplace_back(TargetInfoAvId::kChannelBindings,
                           std::move(channel_bindings_hash));

    base::string16 spn16 = base::UTF8ToUTF16(spn);
    NtlmBufferWriter spn_writer(spn16.length() * 2);
    bool spn_writer_result =
        spn_writer.WriteUtf16String(spn16) && spn_writer.IsEndOfBuffer();
    DCHECK(spn_writer_result);

    av_pairs->emplace_back(TargetInfoAvId::kTargetName, spn_writer.Pass());

    *target_info_len +=
        (2 * kAvPairHeaderLen) + kChannelBindingsHashLen + (spn16.length() * 2);
  }

  *target_info_len += kAvPairHeaderLen;
}
","void UpdateTargetInfoAvPairs(bool is_mic_enabled,
                             bool is_epa_enabled,
                             const std::string& channel_bindings,
                             const std::string& spn,
                             std::vector<AvPair>* av_pairs,
                             uint64_t* server_timestamp,
                             size_t* target_info_len) {
  *server_timestamp = UINT64_MAX;
  *target_info_len = 0;

  bool need_flags_added = is_mic_enabled;
  for (AvPair& pair : *av_pairs) {
    *target_info_len += pair.avlen + kAvPairHeaderLen;
    switch (pair.avid) {
      case TargetInfoAvId::kFlags:
        if (is_mic_enabled) {
          pair.flags = pair.flags | TargetInfoAvFlags::kMicPresent;
        }

        need_flags_added = false;
        break;
      case TargetInfoAvId::kTimestamp:
        *server_timestamp = pair.timestamp;
        break;
      case TargetInfoAvId::kEol:
      case TargetInfoAvId::kChannelBindings:
      case TargetInfoAvId::kTargetName:
        NOTREACHED();
        break;
      default:
        break;
    }
  }

  if (need_flags_added) {
    DCHECK(is_mic_enabled);
    AvPair flags_pair(TargetInfoAvId::kFlags, sizeof(uint32_t));
    flags_pair.flags = TargetInfoAvFlags::kMicPresent;

    av_pairs->push_back(flags_pair);
    *target_info_len += kAvPairHeaderLen + flags_pair.avlen;
  }

  if (is_epa_enabled) {
    std::vector<uint8_t> channel_bindings_hash(kChannelBindingsHashLen, 0);
 
     if (!channel_bindings.empty()) {
      GenerateChannelBindingHashV2(channel_bindings, channel_bindings_hash);
     }
 
     av_pairs->emplace_back(TargetInfoAvId::kChannelBindings,
                           std::move(channel_bindings_hash));

    base::string16 spn16 = base::UTF8ToUTF16(spn);
    NtlmBufferWriter spn_writer(spn16.length() * 2);
    bool spn_writer_result =
        spn_writer.WriteUtf16String(spn16) && spn_writer.IsEndOfBuffer();
    DCHECK(spn_writer_result);

    av_pairs->emplace_back(TargetInfoAvId::kTargetName, spn_writer.Pass());

    *target_info_len +=
        (2 * kAvPairHeaderLen) + kChannelBindingsHashLen + (spn16.length() * 2);
  }

  *target_info_len += kAvPairHeaderLen;
}
",C,"      GenerateChannelBindingHashV2(
          channel_bindings,
          base::make_span<kChannelBindingsHashLen>(channel_bindings_hash));
","      GenerateChannelBindingHashV2(channel_bindings, channel_bindings_hash);
",,"@@ -6,11 +6,13 @@
 
 #include <string.h>
 
+#include ""base/containers/span.h""
 #include ""base/logging.h""
 #include ""base/md5.h""
 #include ""base/strings/utf_string_conversions.h""
 #include ""net/base/net_string_util.h""
 #include ""net/ntlm/ntlm_buffer_writer.h""
+#include ""net/ntlm/ntlm_constants.h""
 #include ""third_party/boringssl/src/include/openssl/des.h""
 #include ""third_party/boringssl/src/include/openssl/hmac.h""
 #include ""third_party/boringssl/src/include/openssl/md4.h""
@@ -95,7 +97,9 @@ void UpdateTargetInfoAvPairs(bool is_mic_enabled,
 
     // Hash the channel bindings if they exist otherwise they remain zeros.
     if (!channel_bindings.empty()) {
-      GenerateChannelBindingHashV2(channel_bindings, channel_bindings_hash);
+      GenerateChannelBindingHashV2(
+          channel_bindings,
+          base::make_span<kChannelBindingsHashLen>(channel_bindings_hash));
     }
 
     av_pairs->emplace_back(TargetInfoAvId::kChannelBindings,",Chrome,9cfe470d793da6e09b966d435c8fa2ba1625d5fe,6ffc06bf9e0ecbdbab1587819b9184bd377c1037,1,"void UpdateTargetInfoAvPairs(bool is_mic_enabled,
                             bool is_epa_enabled,
                             const std::string& channel_bindings,
                             const std::string& spn,
                             std::vector<AvPair>* av_pairs,
                             uint64_t* server_timestamp,
                             size_t* target_info_len) {
  // Do a pass to update flags and calculate current length and
  // pull out the server timestamp if it is there.
  *server_timestamp = UINT64_MAX;
  *target_info_len = 0;

  bool need_flags_added = is_mic_enabled;
  for (AvPair& pair : *av_pairs) {
    *target_info_len += pair.avlen + kAvPairHeaderLen;
    switch (pair.avid) {
      case TargetInfoAvId::kFlags:
        // The parsing phase already set the payload to the |flags| field.
        if (is_mic_enabled) {
          pair.flags = pair.flags | TargetInfoAvFlags::kMicPresent;
        }

        need_flags_added = false;
        break;
      case TargetInfoAvId::kTimestamp:
        // The parsing phase already set the payload to the |timestamp| field.
        *server_timestamp = pair.timestamp;
        break;
      case TargetInfoAvId::kEol:
      case TargetInfoAvId::kChannelBindings:
      case TargetInfoAvId::kTargetName:
        // The terminator, |kEol|, should already have been removed from the
        // end of the list and would have been rejected if it has been inside
        // the list. Additionally |kChannelBindings| and |kTargetName| pairs
        // would have been rejected during the initial parsing. See
        // |NtlmBufferReader::ReadTargetInfo|.
        NOTREACHED();
        break;
      default:
        // Ignore entries we don't care about.
        break;
    }
  }

  if (need_flags_added) {
    DCHECK(is_mic_enabled);
    AvPair flags_pair(TargetInfoAvId::kFlags, sizeof(uint32_t));
    flags_pair.flags = TargetInfoAvFlags::kMicPresent;

    av_pairs->push_back(flags_pair);
    *target_info_len += kAvPairHeaderLen + flags_pair.avlen;
  }

  if (is_epa_enabled) {
    std::vector<uint8_t> channel_bindings_hash(kChannelBindingsHashLen, 0);
 
     // Hash the channel bindings if they exist otherwise they remain zeros.
     if (!channel_bindings.empty()) {
//flaw_line_below:
      GenerateChannelBindingHashV2(channel_bindings, channel_bindings_hash);
//fix_flaw_line_below:
//      GenerateChannelBindingHashV2(
//fix_flaw_line_below:
//          channel_bindings,
//fix_flaw_line_below:
//          base::make_span<kChannelBindingsHashLen>(channel_bindings_hash));
     }
 
     av_pairs->emplace_back(TargetInfoAvId::kChannelBindings,
                           std::move(channel_bindings_hash));

    // Convert the SPN to little endian unicode.
    base::string16 spn16 = base::UTF8ToUTF16(spn);
    NtlmBufferWriter spn_writer(spn16.length() * 2);
    bool spn_writer_result =
        spn_writer.WriteUtf16String(spn16) && spn_writer.IsEndOfBuffer();
    DCHECK(spn_writer_result);

    av_pairs->emplace_back(TargetInfoAvId::kTargetName, spn_writer.Pass());

    // Add the length of the two new AV Pairs to the total length.
    *target_info_len +=
        (2 * kAvPairHeaderLen) + kChannelBindingsHashLen + (spn16.length() * 2);
  }

  // Add extra space for the terminator at the end.
  *target_info_len += kAvPairHeaderLen;
}
"
8509,186245,,Remote,Not required,Partial,CVE-2016-1671,https://www.cvedetails.com/cve/CVE-2016-1671/,CWE-22,Medium,Partial,Partial,,2016-05-14,6.8,"Google Chrome before 50.0.2661.102 on Android mishandles / (slash) and  (backslash) characters, which allows attackers to conduct directory traversal attacks via a file: URL, related to net/base/escape.cc and net/base/filename_util.cc.",2016-11-30,Dir. Trav. ,2,https://github.com/chromium/chromium/commit/9cfe470d793da6e09b966d435c8fa2ba1625d5fe,9cfe470d793da6e09b966d435c8fa2ba1625d5fe,"[base] Make dynamic container to static span conversion explicit

This change disallows implicit conversions from dynamic containers to
static spans. This conversion can cause CHECK failures, and thus should
be done carefully. Requiring explicit construction makes it more obvious
when this happens. To aid usability, appropriate base::make_span<size_t>
overloads are added.

Bug: 877931
Change-Id: Id9f526bc57bfd30a52d14df827b0445ca087381d
Reviewed-on: https://chromium-review.googlesource.com/1189985
Reviewed-by: Ryan Sleevi <rsleevi@chromium.org>
Reviewed-by: Balazs Engedy <engedy@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Commit-Queue: Jan Wilken Dörrie <jdoerrie@chromium.org>
Cr-Commit-Position: refs/heads/master@{#586657}",1,net/ntlm/ntlm_client.cc,"{""sha"": ""2f01162f08c3b186f5ebc35dfbe146920bdda5ea"", ""filename"": ""base/containers/span.h"", ""status"": ""modified"", ""additions"": 69, ""deletions"": 9, ""changes"": 78, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/containers/span.h?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -71,13 +71,31 @@ using EnableIfSpanCompatibleArray =\n                      ContainerHasConvertibleData<Array, T>::value>;\n \n // SFINAE check if Container can be converted to a span<T>.\n+template <typename Container, typename T>\n+using IsSpanCompatibleContainer =\n+    std::conditional_t<!IsSpan<Container>::value &&\n+                           !IsStdArray<Container>::value &&\n+                           !IsCArray<Container>::value &&\n+                           ContainerHasConvertibleData<Container, T>::value &&\n+                           ContainerHasIntegralSize<Container>::value,\n+                       std::true_type,\n+                       std::false_type>;\n+\n template <typename Container, typename T>\n using EnableIfSpanCompatibleContainer =\n-    std::enable_if_t<!internal::IsSpan<Container>::value &&\n-                     !internal::IsStdArray<Container>::value &&\n-                     !internal::IsCArray<Container>::value &&\n-                     ContainerHasConvertibleData<Container, T>::value &&\n-                     ContainerHasIntegralSize<Container>::value>;\n+    std::enable_if_t<IsSpanCompatibleContainer<Container, T>::value>;\n+\n+template <typename Container, typename T, size_t Extent>\n+using EnableIfSpanCompatibleContainerAndSpanIsDynamic =\n+    std::enable_if_t<IsSpanCompatibleContainer<Container, T>::value &&\n+                         Extent == dynamic_extent,\n+                     bool>;\n+\n+template <typename Container, typename T, size_t Extent>\n+using EnableIfSpanCompatibleContainerAndSpanIsStatic =\n+    std::enable_if_t<IsSpanCompatibleContainer<Container, T>::value &&\n+                         Extent != dynamic_extent,\n+                     bool>;\n \n // A helper template for storing the size of a span. Spans with static extents\n // don't require additional storage, since the extent itself is specified in the\n@@ -171,6 +189,10 @@ struct ExtentStorage<dynamic_extent> {\n // Differences in constants and types:\n // - index_type is aliased to size_t\n //\n+// Differences from [span.cons]:\n+// - Constructing a static span (i.e. Extent != dynamic_extent) from a dynamic\n+//   sized container (e.g. std::vector) requires an explicit conversion.\n+//\n // Differences from [span.sub]:\n // - using size_t instead of ptrdiff_t for indexing\n //\n@@ -245,15 +267,36 @@ class span : public internal::ExtentStorage<Extent> {\n \n   // Conversion from a container that has compatible base::data() and integral\n   // base::size().\n-  template <typename Container,\n-            typename = internal::EnableIfSpanCompatibleContainer<Container&, T>>\n+  template <\n+      typename Container,\n+      internal::EnableIfSpanCompatibleContainerAndSpanIsDynamic<Container&,\n+                                                                T,\n+                                                                Extent> = false>\n   constexpr span(Container& container) noexcept\n       : span(base::data(container), base::size(container)) {}\n \n   template <\n       typename Container,\n-      typename = internal::EnableIfSpanCompatibleContainer<const Container&, T>>\n-  span(const Container& container) noexcept\n+      internal::EnableIfSpanCompatibleContainerAndSpanIsStatic<Container&,\n+                                                               T,\n+                                                               Extent> = false>\n+  constexpr explicit span(Container& container) noexcept\n+      : span(base::data(container), base::size(container)) {}\n+\n+  template <typename Container,\n+            internal::EnableIfSpanCompatibleContainerAndSpanIsDynamic<\n+                const Container&,\n+                T,\n+                Extent> = false>\n+  constexpr span(const Container& container) noexcept\n+      : span(base::data(container), base::size(container)) {}\n+\n+  template <\n+      typename Container,\n+      internal::EnableIfSpanCompatibleContainerAndSpanIsStatic<const Container&,\n+                                                               T,\n+                                                               Extent> = false>\n+  constexpr explicit span(const Container& container) noexcept\n       : span(base::data(container), base::size(container)) {}\n \n   constexpr span(const span& other) noexcept = default;\n@@ -467,6 +510,23 @@ constexpr span<T> make_span(const Container& container) noexcept {\n   return container;\n }\n \n+template <size_t N,\n+          typename Container,\n+          typename T = typename Container::value_type,\n+          typename = internal::EnableIfSpanCompatibleContainer<Container&, T>>\n+constexpr span<T, N> make_span(Container& container) noexcept {\n+  return span<T, N>(container);\n+}\n+\n+template <\n+    size_t N,\n+    typename Container,\n+    typename T = const typename Container::value_type,\n+    typename = internal::EnableIfSpanCompatibleContainer<const Container&, T>>\n+constexpr span<T, N> make_span(const Container& container) noexcept {\n+  return span<T, N>(container);\n+}\n+\n template <typename T, size_t X>\n constexpr span<T, X> make_span(const span<T, X>& span) noexcept {\n   return span;""}<_**next**_>{""sha"": ""d9499fd8ba2ae0e0618b2383606f91fbfb69db5b"", ""filename"": ""base/containers/span_unittest.cc"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 0, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/containers/span_unittest.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -1101,13 +1101,27 @@ TEST(SpanTest, MakeSpanFromConstContainer) {\n   static_assert(decltype(make_span(vector))::extent == dynamic_extent, \""\"");\n }\n \n+TEST(SpanTest, MakeStaticSpanFromConstContainer) {\n+  const std::vector<int> vector = {-1, -2, -3, -4, -5};\n+  span<const int, 5> span(vector);\n+  EXPECT_EQ(span, make_span<5>(vector));\n+  static_assert(decltype(make_span<5>(vector))::extent == 5, \""\"");\n+}\n+\n TEST(SpanTest, MakeSpanFromContainer) {\n   std::vector<int> vector = {-1, -2, -3, -4, -5};\n   span<int> span(vector);\n   EXPECT_EQ(span, make_span(vector));\n   static_assert(decltype(make_span(vector))::extent == dynamic_extent, \""\"");\n }\n \n+TEST(SpanTest, MakeStaticSpanFromContainer) {\n+  std::vector<int> vector = {-1, -2, -3, -4, -5};\n+  span<int, 5> span(vector);\n+  EXPECT_EQ(span, make_span<5>(vector));\n+  static_assert(decltype(make_span<5>(vector))::extent == 5, \""\"");\n+}\n+\n TEST(SpanTest, MakeSpanFromDynamicSpan) {\n   static constexpr int kArray[] = {1, 2, 3, 4, 5};\n   constexpr span<const int> span(kArray);""}<_**next**_>{""sha"": ""f78685a97b7c4a5df7498f58c890c4fbe1ced32d"", ""filename"": ""base/containers/span_unittest.nc"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span_unittest.nc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/base/containers/span_unittest.nc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/base/containers/span_unittest.nc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -102,6 +102,22 @@ void WontCompile() {\n   span<int> span(v);\n }\n \n+#elif defined(NCTEST_IMPLICIT_CONVERSION_FROM_DYNAMIC_CONST_CONTAINER_TO_STATIC_SPAN_DISALLOWED) // [r\""fatal error: no viable conversion from 'const std::vector<int>' to 'span<const int, 3>'\""]\n+\n+// A dynamic const container should not be implicitly convertible to a static span.\n+void WontCompile() {\n+  const std::vector<int> v = {1, 2, 3};\n+  span<const int, 3> span = v;\n+}\n+\n+#elif defined(NCTEST_IMPLICIT_CONVERSION_FROM_DYNAMIC_MUTABLE_CONTAINER_TO_STATIC_SPAN_DISALLOWED) // [r\""fatal error: no viable conversion from 'std::vector<int>' to 'span<int, 3>'\""]\n+\n+// A dynamic mutable container should not be implicitly convertible to a static span.\n+void WontCompile() {\n+  std::vector<int> v = {1, 2, 3};\n+  span<int, 3> span = v;\n+}\n+\n #elif defined(NCTEST_STD_SET_CONVERSION_DISALLOWED)  // [r\""fatal error: no matching constructor for initialization of 'span<int>'\""]\n \n // A std::set() should not satisfy the requirements for conversion to a span.""}<_**next**_>{""sha"": ""4fbc6ae976ee383b7500de891e28f3896997f2f9"", ""filename"": ""content/browser/webauth/virtual_authenticator.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/content/browser/webauth/virtual_authenticator.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/content/browser/webauth/virtual_authenticator.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/webauth/virtual_authenticator.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -7,6 +7,7 @@\n #include <utility>\n #include <vector>\n \n+#include \""base/containers/span.h\""\n #include \""base/guid.h\""\n #include \""crypto/ec_private_key.h\""\n #include \""device/fido/virtual_u2f_device.h\""\n@@ -64,7 +65,9 @@ void VirtualAuthenticator::AddRegistration(\n       ::device::VirtualFidoDevice::RegistrationData(\n           crypto::ECPrivateKey::CreateFromPrivateKeyInfo(\n               registration->private_key),\n-          registration->application_parameter, registration->counter));\n+          base::make_span<device::kRpIdHashLength>(\n+              registration->application_parameter),\n+          registration->counter));\n   std::move(callback).Run(success);\n }\n ""}<_**next**_>{""sha"": ""a227377a0969ed8ee5ce31777e5c1b4a5b03cad8"", ""filename"": ""device/fido/cable/fido_cable_handshake_handler.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/cable/fido_cable_handshake_handler.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/cable/fido_cable_handshake_handler.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/device/fido/cable/fido_cable_handshake_handler.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -7,6 +7,7 @@\n #include <algorithm>\n #include <utility>\n \n+#include \""base/containers/span.h\""\n #include \""base/threading/thread_task_runner_handle.h\""\n #include \""components/cbor/cbor_reader.h\""\n #include \""components/cbor/cbor_values.h\""\n@@ -149,8 +150,8 @@ bool FidoCableHandshakeHandler::ValidateAuthenticatorHandshakeMessage(\n   }\n \n   cable_device_->SetEncryptionData(\n-      GetEncryptionKeyAfterSuccessfulHandshake(\n-          authenticator_random_nonce->second.GetBytestring()),\n+      GetEncryptionKeyAfterSuccessfulHandshake(base::make_span<16>(\n+          authenticator_random_nonce->second.GetBytestring())),\n       nonce_);\n \n   return true;""}<_**next**_>{""sha"": ""fa8b455c25273efdf83f572932482048c44cffdc"", ""filename"": ""device/fido/ctap_response_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/ctap_response_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/ctap_response_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/device/fido/ctap_response_unittest.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -574,8 +574,7 @@ TEST(CTAPResponseTest, TestReadGetInfoResponseWithIncorrectFormat) {\n \n TEST(CTAPResponseTest, TestSerializeGetInfoResponse) {\n   AuthenticatorGetInfoResponse response(\n-      {ProtocolVersion::kCtap, ProtocolVersion::kU2f},\n-      fido_parsing_utils::Materialize(kTestDeviceAaguid));\n+      {ProtocolVersion::kCtap, ProtocolVersion::kU2f}, kTestDeviceAaguid);\n   response.SetExtensions({\""uvm\"", \""hmac-secret\""});\n   AuthenticatorSupportedOptions options;\n   options.SetSupportsResidentKey(true);""}<_**next**_>{""sha"": ""e4ee349100db016cf767e95a218976b18477e32c"", ""filename"": ""device/fido/device_response_converter.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/device_response_converter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/device_response_converter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/device/fido/device_response_converter.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -8,6 +8,7 @@\n #include <string>\n #include <utility>\n \n+#include \""base/containers/span.h\""\n #include \""base/numerics/safe_conversions.h\""\n #include \""base/optional.h\""\n #include \""base/stl_util.h\""\n@@ -186,8 +187,9 @@ base::Optional<AuthenticatorGetInfoResponse> ReadCTAPGetInfoResponse(\n     return base::nullopt;\n   }\n \n-  AuthenticatorGetInfoResponse response(std::move(protocol_versions),\n-                                        it->second.GetBytestring());\n+  AuthenticatorGetInfoResponse response(\n+      std::move(protocol_versions),\n+      base::make_span<kAaguidLength>(it->second.GetBytestring()));\n \n   it = response_map.find(CBOR(2));\n   if (it != response_map.end()) {""}<_**next**_>{""sha"": ""ceb35ae0df020daa578e513e483dc748c071cbfc"", ""filename"": ""device/fido/make_credential_task_unittest.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 4, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/make_credential_task_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/device/fido/make_credential_task_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/device/fido/make_credential_task_unittest.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -137,8 +137,7 @@ TEST_F(FidoMakeCredentialTaskTest, TestDefaultU2fRegisterOperationWithoutFlag) {\n \n TEST_F(FidoMakeCredentialTaskTest, DefaultToU2fWhenClientPinSet) {\n   AuthenticatorGetInfoResponse device_info(\n-      {ProtocolVersion::kCtap, ProtocolVersion::kU2f},\n-      fido_parsing_utils::Materialize(kTestDeviceAaguid));\n+      {ProtocolVersion::kCtap, ProtocolVersion::kU2f}, kTestDeviceAaguid);\n   AuthenticatorSupportedOptions options;\n   options.SetClientPinAvailability(\n       AuthenticatorSupportedOptions::ClientPinAvailability::\n@@ -159,8 +158,7 @@ TEST_F(FidoMakeCredentialTaskTest, DefaultToU2fWhenClientPinSet) {\n \n TEST_F(FidoMakeCredentialTaskTest, EnforceClientPinWhenUserVerificationSet) {\n   AuthenticatorGetInfoResponse device_info(\n-      {ProtocolVersion::kCtap, ProtocolVersion::kU2f},\n-      fido_parsing_utils::Materialize(kTestDeviceAaguid));\n+      {ProtocolVersion::kCtap, ProtocolVersion::kU2f}, kTestDeviceAaguid);\n   AuthenticatorSupportedOptions options;\n   options.SetClientPinAvailability(\n       AuthenticatorSupportedOptions::ClientPinAvailability::""}<_**next**_>{""sha"": ""4f9f422a5e0d90aee010a61605f30bfeb17a96ec"", ""filename"": ""net/ntlm/ntlm.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/net/ntlm/ntlm.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/net/ntlm/ntlm.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/net/ntlm/ntlm.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -6,11 +6,13 @@\n \n #include <string.h>\n \n+#include \""base/containers/span.h\""\n #include \""base/logging.h\""\n #include \""base/md5.h\""\n #include \""base/strings/utf_string_conversions.h\""\n #include \""net/base/net_string_util.h\""\n #include \""net/ntlm/ntlm_buffer_writer.h\""\n+#include \""net/ntlm/ntlm_constants.h\""\n #include \""third_party/boringssl/src/include/openssl/des.h\""\n #include \""third_party/boringssl/src/include/openssl/hmac.h\""\n #include \""third_party/boringssl/src/include/openssl/md4.h\""\n@@ -95,7 +97,9 @@ void UpdateTargetInfoAvPairs(bool is_mic_enabled,\n \n     // Hash the channel bindings if they exist otherwise they remain zeros.\n     if (!channel_bindings.empty()) {\n-      GenerateChannelBindingHashV2(channel_bindings, channel_bindings_hash);\n+      GenerateChannelBindingHashV2(\n+          channel_bindings,\n+          base::make_span<kChannelBindingsHashLen>(channel_bindings_hash));\n     }\n \n     av_pairs->emplace_back(TargetInfoAvId::kChannelBindings,""}<_**next**_>{""sha"": ""68b627848ba41484dcbed5c60515cabb7d8b0c28"", ""filename"": ""net/ntlm/ntlm_client.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/net/ntlm/ntlm_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9cfe470d793da6e09b966d435c8fa2ba1625d5fe/net/ntlm/ntlm_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/net/ntlm/ntlm_client.cc?ref=9cfe470d793da6e09b966d435c8fa2ba1625d5fe"", ""patch"": ""@@ -6,12 +6,14 @@\n \n #include <string.h>\n \n+#include \""base/containers/span.h\""\n #include \""base/logging.h\""\n #include \""base/md5.h\""\n #include \""base/strings/utf_string_conversions.h\""\n #include \""net/ntlm/ntlm.h\""\n #include \""net/ntlm/ntlm_buffer_reader.h\""\n #include \""net/ntlm/ntlm_buffer_writer.h\""\n+#include \""net/ntlm/ntlm_constants.h\""\n \n namespace net {\n namespace ntlm {\n@@ -221,7 +223,8 @@ std::vector<uint8_t> NtlmClient::GenerateAuthenticateMessage(\n     uint8_t v2_hash[kNtlmHashLen];\n     GenerateNtlmHashV2(domain, username, password, v2_hash);\n     v2_proof_input = GenerateProofInputV2(timestamp, client_challenge);\n-    GenerateNtlmProofV2(v2_hash, server_challenge, v2_proof_input,\n+    GenerateNtlmProofV2(v2_hash, server_challenge,\n+                        base::make_span<kProofInputLenV2>(v2_proof_input),\n                         updated_target_info, v2_proof);\n     GenerateSessionBaseKeyV2(v2_hash, v2_proof, v2_session_key);\n   } else {""}","std::vector<uint8_t> NtlmClient::GenerateAuthenticateMessage(
    const base::string16& domain,
    const base::string16& username,
    const base::string16& password,
    const std::string& hostname,
    const std::string& channel_bindings,
    const std::string& spn,
    uint64_t client_time,
    base::span<const uint8_t, kChallengeLen> client_challenge,
    base::span<const uint8_t> server_challenge_message) const {
  if (hostname.length() > kMaxFqdnLen || domain.length() > kMaxFqdnLen ||
      username.length() > kMaxUsernameLen ||
      password.length() > kMaxPasswordLen) {
    return {};
  }

  NegotiateFlags challenge_flags;
  uint8_t server_challenge[kChallengeLen];
  uint8_t lm_response[kResponseLenV1];
  uint8_t ntlm_response[kResponseLenV1];

  std::vector<uint8_t> updated_target_info;
  std::vector<uint8_t> v2_proof_input;
  uint8_t v2_proof[kNtlmProofLenV2];
  uint8_t v2_session_key[kSessionKeyLenV2];

  if (IsNtlmV2()) {
    std::vector<AvPair> av_pairs;
    if (!ParseChallengeMessageV2(server_challenge_message, &challenge_flags,
                                 server_challenge, &av_pairs)) {
      return {};
    }

    uint64_t timestamp;
    updated_target_info =
        GenerateUpdatedTargetInfo(IsMicEnabled(), IsEpaEnabled(),
                                  channel_bindings, spn, av_pairs, &timestamp);

    memset(lm_response, 0, kResponseLenV1);
    if (timestamp == UINT64_MAX) {
      timestamp = client_time;
    }

     uint8_t v2_hash[kNtlmHashLen];
     GenerateNtlmHashV2(domain, username, password, v2_hash);
     v2_proof_input = GenerateProofInputV2(timestamp, client_challenge);
    GenerateNtlmProofV2(v2_hash, server_challenge,
                        base::make_span<kProofInputLenV2>(v2_proof_input),
                         updated_target_info, v2_proof);
     GenerateSessionBaseKeyV2(v2_hash, v2_proof, v2_session_key);
   } else {
    if (!ParseChallengeMessage(server_challenge_message, &challenge_flags,
                               server_challenge)) {
      return {};
    }

    GenerateResponsesV1WithSessionSecurity(password, server_challenge,
                                           client_challenge, lm_response,
                                           ntlm_response);
  }

  NegotiateFlags authenticate_flags = (challenge_flags & negotiate_flags_) |
                                      NegotiateFlags::kExtendedSessionSecurity;

  bool is_unicode = (authenticate_flags & NegotiateFlags::kUnicode) ==
                    NegotiateFlags::kUnicode;

  SecurityBuffer lm_info;
  SecurityBuffer ntlm_info;
  SecurityBuffer domain_info;
  SecurityBuffer username_info;
  SecurityBuffer hostname_info;
  SecurityBuffer session_key_info;
  size_t authenticate_message_len;

  CalculatePayloadLayout(is_unicode, domain, username, hostname,
                         updated_target_info.size(), &lm_info, &ntlm_info,
                         &domain_info, &username_info, &hostname_info,
                         &session_key_info, &authenticate_message_len);

  NtlmBufferWriter authenticate_writer(authenticate_message_len);
  bool writer_result = WriteAuthenticateMessage(
      &authenticate_writer, lm_info, ntlm_info, domain_info, username_info,
      hostname_info, session_key_info, authenticate_flags);
  DCHECK(writer_result);

  if (IsNtlmV2()) {
    writer_result = authenticate_writer.WriteZeros(kVersionFieldLen) &&
                    authenticate_writer.WriteZeros(kMicLenV2);

    DCHECK(writer_result);
  }

  DCHECK(authenticate_writer.GetCursor() == GetAuthenticateHeaderLength());
  DCHECK(GetAuthenticateHeaderLength() == lm_info.offset);

  if (IsNtlmV2()) {
    writer_result =
        WriteResponsePayloadsV2(&authenticate_writer, lm_response, v2_proof,
                                v2_proof_input, updated_target_info);
  } else {
    DCHECK_EQ(kResponseLenV1, lm_info.length);
    DCHECK_EQ(kResponseLenV1, ntlm_info.length);
    writer_result =
        WriteResponsePayloads(&authenticate_writer, lm_response, ntlm_response);
  }

  DCHECK(writer_result);
  DCHECK_EQ(authenticate_writer.GetCursor(), domain_info.offset);

  writer_result = WriteStringPayloads(&authenticate_writer, is_unicode, domain,
                                      username, hostname);
  DCHECK(writer_result);
  DCHECK(authenticate_writer.IsEndOfBuffer());
  DCHECK_EQ(authenticate_message_len, authenticate_writer.GetLength());

  std::vector<uint8_t> auth_msg = authenticate_writer.Pass();

  if (IsMicEnabled()) {
    DCHECK_LT(kMicOffsetV2 + kMicLenV2, authenticate_message_len);

    base::span<uint8_t, kMicLenV2> mic(
        const_cast<uint8_t*>(auth_msg.data()) + kMicOffsetV2, kMicLenV2);
    GenerateMicV2(v2_session_key, negotiate_message_, server_challenge_message,
                  auth_msg, mic);
  }

  return auth_msg;
}
","std::vector<uint8_t> NtlmClient::GenerateAuthenticateMessage(
    const base::string16& domain,
    const base::string16& username,
    const base::string16& password,
    const std::string& hostname,
    const std::string& channel_bindings,
    const std::string& spn,
    uint64_t client_time,
    base::span<const uint8_t, kChallengeLen> client_challenge,
    base::span<const uint8_t> server_challenge_message) const {
  if (hostname.length() > kMaxFqdnLen || domain.length() > kMaxFqdnLen ||
      username.length() > kMaxUsernameLen ||
      password.length() > kMaxPasswordLen) {
    return {};
  }

  NegotiateFlags challenge_flags;
  uint8_t server_challenge[kChallengeLen];
  uint8_t lm_response[kResponseLenV1];
  uint8_t ntlm_response[kResponseLenV1];

  std::vector<uint8_t> updated_target_info;
  std::vector<uint8_t> v2_proof_input;
  uint8_t v2_proof[kNtlmProofLenV2];
  uint8_t v2_session_key[kSessionKeyLenV2];

  if (IsNtlmV2()) {
    std::vector<AvPair> av_pairs;
    if (!ParseChallengeMessageV2(server_challenge_message, &challenge_flags,
                                 server_challenge, &av_pairs)) {
      return {};
    }

    uint64_t timestamp;
    updated_target_info =
        GenerateUpdatedTargetInfo(IsMicEnabled(), IsEpaEnabled(),
                                  channel_bindings, spn, av_pairs, &timestamp);

    memset(lm_response, 0, kResponseLenV1);
    if (timestamp == UINT64_MAX) {
      timestamp = client_time;
    }

     uint8_t v2_hash[kNtlmHashLen];
     GenerateNtlmHashV2(domain, username, password, v2_hash);
     v2_proof_input = GenerateProofInputV2(timestamp, client_challenge);
    GenerateNtlmProofV2(v2_hash, server_challenge, v2_proof_input,
                         updated_target_info, v2_proof);
     GenerateSessionBaseKeyV2(v2_hash, v2_proof, v2_session_key);
   } else {
    if (!ParseChallengeMessage(server_challenge_message, &challenge_flags,
                               server_challenge)) {
      return {};
    }

    GenerateResponsesV1WithSessionSecurity(password, server_challenge,
                                           client_challenge, lm_response,
                                           ntlm_response);
  }

  NegotiateFlags authenticate_flags = (challenge_flags & negotiate_flags_) |
                                      NegotiateFlags::kExtendedSessionSecurity;

  bool is_unicode = (authenticate_flags & NegotiateFlags::kUnicode) ==
                    NegotiateFlags::kUnicode;

  SecurityBuffer lm_info;
  SecurityBuffer ntlm_info;
  SecurityBuffer domain_info;
  SecurityBuffer username_info;
  SecurityBuffer hostname_info;
  SecurityBuffer session_key_info;
  size_t authenticate_message_len;

  CalculatePayloadLayout(is_unicode, domain, username, hostname,
                         updated_target_info.size(), &lm_info, &ntlm_info,
                         &domain_info, &username_info, &hostname_info,
                         &session_key_info, &authenticate_message_len);

  NtlmBufferWriter authenticate_writer(authenticate_message_len);
  bool writer_result = WriteAuthenticateMessage(
      &authenticate_writer, lm_info, ntlm_info, domain_info, username_info,
      hostname_info, session_key_info, authenticate_flags);
  DCHECK(writer_result);

  if (IsNtlmV2()) {
    writer_result = authenticate_writer.WriteZeros(kVersionFieldLen) &&
                    authenticate_writer.WriteZeros(kMicLenV2);

    DCHECK(writer_result);
  }

  DCHECK(authenticate_writer.GetCursor() == GetAuthenticateHeaderLength());
  DCHECK(GetAuthenticateHeaderLength() == lm_info.offset);

  if (IsNtlmV2()) {
    writer_result =
        WriteResponsePayloadsV2(&authenticate_writer, lm_response, v2_proof,
                                v2_proof_input, updated_target_info);
  } else {
    DCHECK_EQ(kResponseLenV1, lm_info.length);
    DCHECK_EQ(kResponseLenV1, ntlm_info.length);
    writer_result =
        WriteResponsePayloads(&authenticate_writer, lm_response, ntlm_response);
  }

  DCHECK(writer_result);
  DCHECK_EQ(authenticate_writer.GetCursor(), domain_info.offset);

  writer_result = WriteStringPayloads(&authenticate_writer, is_unicode, domain,
                                      username, hostname);
  DCHECK(writer_result);
  DCHECK(authenticate_writer.IsEndOfBuffer());
  DCHECK_EQ(authenticate_message_len, authenticate_writer.GetLength());

  std::vector<uint8_t> auth_msg = authenticate_writer.Pass();

  if (IsMicEnabled()) {
    DCHECK_LT(kMicOffsetV2 + kMicLenV2, authenticate_message_len);

    base::span<uint8_t, kMicLenV2> mic(
        const_cast<uint8_t*>(auth_msg.data()) + kMicOffsetV2, kMicLenV2);
    GenerateMicV2(v2_session_key, negotiate_message_, server_challenge_message,
                  auth_msg, mic);
  }

  return auth_msg;
}
",C,"    GenerateNtlmProofV2(v2_hash, server_challenge,
                        base::make_span<kProofInputLenV2>(v2_proof_input),
","    GenerateNtlmProofV2(v2_hash, server_challenge, v2_proof_input,
",,"@@ -6,12 +6,14 @@
 
 #include <string.h>
 
+#include ""base/containers/span.h""
 #include ""base/logging.h""
 #include ""base/md5.h""
 #include ""base/strings/utf_string_conversions.h""
 #include ""net/ntlm/ntlm.h""
 #include ""net/ntlm/ntlm_buffer_reader.h""
 #include ""net/ntlm/ntlm_buffer_writer.h""
+#include ""net/ntlm/ntlm_constants.h""
 
 namespace net {
 namespace ntlm {
@@ -221,7 +223,8 @@ std::vector<uint8_t> NtlmClient::GenerateAuthenticateMessage(
     uint8_t v2_hash[kNtlmHashLen];
     GenerateNtlmHashV2(domain, username, password, v2_hash);
     v2_proof_input = GenerateProofInputV2(timestamp, client_challenge);
-    GenerateNtlmProofV2(v2_hash, server_challenge, v2_proof_input,
+    GenerateNtlmProofV2(v2_hash, server_challenge,
+                        base::make_span<kProofInputLenV2>(v2_proof_input),
                         updated_target_info, v2_proof);
     GenerateSessionBaseKeyV2(v2_hash, v2_proof, v2_session_key);
   } else {",Chrome,9cfe470d793da6e09b966d435c8fa2ba1625d5fe,6ffc06bf9e0ecbdbab1587819b9184bd377c1037,1,"std::vector<uint8_t> NtlmClient::GenerateAuthenticateMessage(
    const base::string16& domain,
    const base::string16& username,
    const base::string16& password,
    const std::string& hostname,
    const std::string& channel_bindings,
    const std::string& spn,
    uint64_t client_time,
    base::span<const uint8_t, kChallengeLen> client_challenge,
    base::span<const uint8_t> server_challenge_message) const {
  // Limit the size of strings that are accepted. As an absolute limit any
  // field represented by a |SecurityBuffer| or |AvPair| must be less than
  // UINT16_MAX bytes long. The strings are restricted to the maximum sizes
  // without regard to encoding. As such this isn't intended to restrict all
  // invalid inputs, only to allow all possible valid inputs.
  //
  // |domain| and |hostname| can be no longer than 255 characters.
  // |username| can be no longer than 104 characters. See [1].
  // |password| can be no longer than 256 characters. See [2].
  //
  // [1] - https://technet.microsoft.com/en-us/library/bb726984.aspx
  // [2] - https://technet.microsoft.com/en-us/library/cc512606.aspx
  if (hostname.length() > kMaxFqdnLen || domain.length() > kMaxFqdnLen ||
      username.length() > kMaxUsernameLen ||
      password.length() > kMaxPasswordLen) {
    return {};
  }

  NegotiateFlags challenge_flags;
  uint8_t server_challenge[kChallengeLen];
  uint8_t lm_response[kResponseLenV1];
  uint8_t ntlm_response[kResponseLenV1];

  // Response fields only for NTLMv2
  std::vector<uint8_t> updated_target_info;
  std::vector<uint8_t> v2_proof_input;
  uint8_t v2_proof[kNtlmProofLenV2];
  uint8_t v2_session_key[kSessionKeyLenV2];

  if (IsNtlmV2()) {
    std::vector<AvPair> av_pairs;
    if (!ParseChallengeMessageV2(server_challenge_message, &challenge_flags,
                                 server_challenge, &av_pairs)) {
      return {};
    }

    uint64_t timestamp;
    updated_target_info =
        GenerateUpdatedTargetInfo(IsMicEnabled(), IsEpaEnabled(),
                                  channel_bindings, spn, av_pairs, &timestamp);

    memset(lm_response, 0, kResponseLenV1);
    if (timestamp == UINT64_MAX) {
      // If the server didn't send a time, then use the clients time.
      timestamp = client_time;
    }

     uint8_t v2_hash[kNtlmHashLen];
     GenerateNtlmHashV2(domain, username, password, v2_hash);
     v2_proof_input = GenerateProofInputV2(timestamp, client_challenge);
//flaw_line_below:
    GenerateNtlmProofV2(v2_hash, server_challenge, v2_proof_input,
//fix_flaw_line_below:
//    GenerateNtlmProofV2(v2_hash, server_challenge,
//fix_flaw_line_below:
//                        base::make_span<kProofInputLenV2>(v2_proof_input),
                         updated_target_info, v2_proof);
     GenerateSessionBaseKeyV2(v2_hash, v2_proof, v2_session_key);
   } else {
    if (!ParseChallengeMessage(server_challenge_message, &challenge_flags,
                               server_challenge)) {
      return {};
    }

    // Calculate the responses for the authenticate message.
    GenerateResponsesV1WithSessionSecurity(password, server_challenge,
                                           client_challenge, lm_response,
                                           ntlm_response);
  }

  // Always use extended session security even if the server tries to downgrade.
  NegotiateFlags authenticate_flags = (challenge_flags & negotiate_flags_) |
                                      NegotiateFlags::kExtendedSessionSecurity;

  // Calculate all the payload lengths and offsets.
  bool is_unicode = (authenticate_flags & NegotiateFlags::kUnicode) ==
                    NegotiateFlags::kUnicode;

  SecurityBuffer lm_info;
  SecurityBuffer ntlm_info;
  SecurityBuffer domain_info;
  SecurityBuffer username_info;
  SecurityBuffer hostname_info;
  SecurityBuffer session_key_info;
  size_t authenticate_message_len;

  CalculatePayloadLayout(is_unicode, domain, username, hostname,
                         updated_target_info.size(), &lm_info, &ntlm_info,
                         &domain_info, &username_info, &hostname_info,
                         &session_key_info, &authenticate_message_len);

  NtlmBufferWriter authenticate_writer(authenticate_message_len);
  bool writer_result = WriteAuthenticateMessage(
      &authenticate_writer, lm_info, ntlm_info, domain_info, username_info,
      hostname_info, session_key_info, authenticate_flags);
  DCHECK(writer_result);

  if (IsNtlmV2()) {
    // Write the optional (for V1) Version and MIC fields. Note that they
    // could also safely be sent in V1. However, the server should never try to
    // read them, because neither the version negotiate flag nor the
    // |TargetInfoAvFlags::kMicPresent| in the target info are set.
    //
    // Version is never supported so it is filled with zeros. MIC is a hash
    // calculated over all 3 messages while the MIC is set to zeros then
    // backfilled at the end if the MIC feature is enabled.
    writer_result = authenticate_writer.WriteZeros(kVersionFieldLen) &&
                    authenticate_writer.WriteZeros(kMicLenV2);

    DCHECK(writer_result);
  }

  // Verify the location in the payload buffer.
  DCHECK(authenticate_writer.GetCursor() == GetAuthenticateHeaderLength());
  DCHECK(GetAuthenticateHeaderLength() == lm_info.offset);

  if (IsNtlmV2()) {
    // Write the response payloads for V2.
    writer_result =
        WriteResponsePayloadsV2(&authenticate_writer, lm_response, v2_proof,
                                v2_proof_input, updated_target_info);
  } else {
    // Write the response payloads.
    DCHECK_EQ(kResponseLenV1, lm_info.length);
    DCHECK_EQ(kResponseLenV1, ntlm_info.length);
    writer_result =
        WriteResponsePayloads(&authenticate_writer, lm_response, ntlm_response);
  }

  DCHECK(writer_result);
  DCHECK_EQ(authenticate_writer.GetCursor(), domain_info.offset);

  writer_result = WriteStringPayloads(&authenticate_writer, is_unicode, domain,
                                      username, hostname);
  DCHECK(writer_result);
  DCHECK(authenticate_writer.IsEndOfBuffer());
  DCHECK_EQ(authenticate_message_len, authenticate_writer.GetLength());

  std::vector<uint8_t> auth_msg = authenticate_writer.Pass();

  // Backfill the MIC if enabled.
  if (IsMicEnabled()) {
    // The MIC has to be generated over all 3 completed messages with the MIC
    // set to zeros.
    DCHECK_LT(kMicOffsetV2 + kMicLenV2, authenticate_message_len);

    base::span<uint8_t, kMicLenV2> mic(
        const_cast<uint8_t*>(auth_msg.data()) + kMicOffsetV2, kMicLenV2);
    GenerateMicV2(v2_session_key, negotiate_message_, server_challenge_message,
                  auth_msg, mic);
  }

  return auth_msg;
}
"
