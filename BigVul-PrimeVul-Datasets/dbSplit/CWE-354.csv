,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix
76,177812,,Remote,Not required,Partial,CVE-2017-15994,https://www.cvedetails.com/cve/CVE-2017-15994/,CWE-354,Low,Partial,Partial,,2017-10-29,7.5,"rsync 3.1.3-development before 2017-10-24 mishandles archaic checksums, which makes it easier for remote attackers to bypass intended access restrictions. NOTE: the rsync development branch has significant use beyond the rsync developers, e.g., the code has been copied for use in various GitHub projects.",2019-10-02,Bypass,1,https://git.samba.org/?p=rsync.git;a=commit;h=c252546ceeb0925eb8a4061315e3ff0a8c55b48b,c252546ceeb0925eb8a4061315e3ff0a8c55b48b,,0,,,"void sum_update(const char *p, int32 len)
{
	switch (cursum_type) {
	  case CSUM_MD5:
		md5_update(&md, (uchar *)p, len);
		break;
          case CSUM_MD4:
          case CSUM_MD4_OLD:
          case CSUM_MD4_BUSTED:
         case CSUM_MD4_ARCHAIC:
                if (len + sumresidue < CSUM_CHUNK) {
                        memcpy(md.buffer + sumresidue, p, len);
                        sumresidue += len;
		}

		if (sumresidue) {
			int32 i = CSUM_CHUNK - sumresidue;
			memcpy(md.buffer + sumresidue, p, i);
			mdfour_update(&md, (uchar *)md.buffer, CSUM_CHUNK);
			len -= i;
			p += i;
		}

		while (len >= CSUM_CHUNK) {
			mdfour_update(&md, (uchar *)p, CSUM_CHUNK);
			len -= CSUM_CHUNK;
			p += CSUM_CHUNK;
		}

		sumresidue = len;
		if (sumresidue)
			memcpy(md.buffer, p, sumresidue);
		break;
	  case CSUM_NONE:
		break;
	}
}
","void sum_update(const char *p, int32 len)
{
	switch (cursum_type) {
	  case CSUM_MD5:
		md5_update(&md, (uchar *)p, len);
		break;
          case CSUM_MD4:
          case CSUM_MD4_OLD:
          case CSUM_MD4_BUSTED:
                if (len + sumresidue < CSUM_CHUNK) {
                        memcpy(md.buffer + sumresidue, p, len);
                        sumresidue += len;
		}

		if (sumresidue) {
			int32 i = CSUM_CHUNK - sumresidue;
			memcpy(md.buffer + sumresidue, p, i);
			mdfour_update(&md, (uchar *)md.buffer, CSUM_CHUNK);
			len -= i;
			p += i;
		}

		while (len >= CSUM_CHUNK) {
			mdfour_update(&md, (uchar *)p, CSUM_CHUNK);
			len -= CSUM_CHUNK;
			p += CSUM_CHUNK;
		}

		sumresidue = len;
		if (sumresidue)
			memcpy(md.buffer, p, sumresidue);
		break;
	  case CSUM_NONE:
		break;
	}
}
",C,"         case CSUM_MD4_ARCHAIC:
",,7b8a4ecd6ff9cdf4e5d3850ebf822f1e989255b3,"@@ -295,6 +295,7 @@ void sum_update(const char *p, int32 len)
          case CSUM_MD4:
          case CSUM_MD4_OLD:
          case CSUM_MD4_BUSTED:
+         case CSUM_MD4_ARCHAIC:
                if (len + sumresidue < CSUM_CHUNK) {
                        memcpy(md.buffer + sumresidue, p, len);
                        sumresidue += len;",samba,https://git.samba.org/?p=rsync.git;a=blob;f=checksum.c;h=c119f972525341c2165c4b5bcb42612c8c983333;hb=c119f972525341c2165c4b5bcb42612c8c983333,https://git.samba.org/?p=rsync.git;a=blob;f=checksum.c;h=93826944034f5967b7c3b727994d3b54361854b0;hb=93826944034f5967b7c3b727994d3b54361854b0,1,"void sum_update(const char *p, int32 len)
{
	switch (cursum_type) {
	  case CSUM_MD5:
		md5_update(&md, (uchar *)p, len);
		break;
          case CSUM_MD4:
          case CSUM_MD4_OLD:
          case CSUM_MD4_BUSTED:
//fix_flaw_line_below:
//         case CSUM_MD4_ARCHAIC:
                if (len + sumresidue < CSUM_CHUNK) {
                        memcpy(md.buffer + sumresidue, p, len);
                        sumresidue += len;
		}

		if (sumresidue) {
			int32 i = CSUM_CHUNK - sumresidue;
			memcpy(md.buffer + sumresidue, p, i);
			mdfour_update(&md, (uchar *)md.buffer, CSUM_CHUNK);
			len -= i;
			p += i;
		}

		while (len >= CSUM_CHUNK) {
			mdfour_update(&md, (uchar *)p, CSUM_CHUNK);
			len -= CSUM_CHUNK;
			p += CSUM_CHUNK;
		}

		sumresidue = len;
		if (sumresidue)
			memcpy(md.buffer, p, sumresidue);
		break;
	  case CSUM_NONE:
		break;
	}
}
"
77,177813,,Remote,Not required,Partial,CVE-2017-15994,https://www.cvedetails.com/cve/CVE-2017-15994/,CWE-354,Low,Partial,Partial,,2017-10-29,7.5,"rsync 3.1.3-development before 2017-10-24 mishandles archaic checksums, which makes it easier for remote attackers to bypass intended access restrictions. NOTE: the rsync development branch has significant use beyond the rsync developers, e.g., the code has been copied for use in various GitHub projects.",2019-10-02,Bypass,5,https://git.samba.org/?p=rsync.git;a=commit;h=9a480deec4d20277d8e20bc55515ef0640ca1e55 ,9a480deec4d20277d8e20bc55515ef0640ca1e55,,0,,,"char *auth_server(int f_in, int f_out, int module, const char *host,
		  const char *addr, const char *leader)
{
	char *users = lp_auth_users(module);
	char challenge[MAX_DIGEST_LEN*2];
	char line[BIGPATHBUFLEN];
	char **auth_uid_groups = NULL;
	int auth_uid_groups_cnt = -1;
	const char *err = NULL;
	int group_match = -1;
	char *tok, *pass;
	char opt_ch = '\0';

	/* if no auth list then allow anyone in! */
	if (!users || !*users)
        if (!users || !*users)
                return """";
 
       if (protocol_version < 21) { /* Don't allow a weak checksum for the password. */
               rprintf(FERROR, ""ERROR: protocol version is too old!\n"");
               exit_cleanup(RERR_PROTOCOL);
       }

        gen_challenge(addr, challenge);
 
        io_printf(f_out, ""%s%s\n"", leader, challenge);
		return NULL;
	}
","char *auth_server(int f_in, int f_out, int module, const char *host,
		  const char *addr, const char *leader)
{
	char *users = lp_auth_users(module);
	char challenge[MAX_DIGEST_LEN*2];
	char line[BIGPATHBUFLEN];
	char **auth_uid_groups = NULL;
	int auth_uid_groups_cnt = -1;
	const char *err = NULL;
	int group_match = -1;
	char *tok, *pass;
	char opt_ch = '\0';

	/* if no auth list then allow anyone in! */
	if (!users || !*users)
        if (!users || !*users)
                return """";
 
        gen_challenge(addr, challenge);
 
        io_printf(f_out, ""%s%s\n"", leader, challenge);
		return NULL;
	}
",C,"       if (protocol_version < 21) { /* Don't allow a weak checksum for the password. */
               rprintf(FERROR, ""ERROR: protocol version is too old!\n"");
               exit_cleanup(RERR_PROTOCOL);
       }

",,c252546ceeb0925eb8a4061315e3ff0a8c55b48b,"@@ -22,6 +22,7 @@
 #include ""itypes.h""
 
 extern int read_only;
+extern int protocol_version;
 extern char *password_file;
 
 /***************************************************************************
@@ -237,6 +238,11 @@ char *auth_server(int f_in, int f_out, int module, const char *host,
        if (!users || !*users)
                return """";
 
+       if (protocol_version < 21) { /* Don't allow a weak checksum for the password. */
+               rprintf(FERROR, ""ERROR: protocol version is too old!\n"");
+               exit_cleanup(RERR_PROTOCOL);
+       }
+
        gen_challenge(addr, challenge);
 
        io_printf(f_out, ""%s%s\n"", leader, challenge);",samba,https://git.samba.org/?p=rsync.git;a=blob;f=authenticate.c;h=a106b0f60a8cb88e37080bc5e2a58ce28c66f379;hb=a106b0f60a8cb88e37080bc5e2a58ce28c66f379,https://git.samba.org/?p=rsync.git;a=blob;f=authenticate.c;h=d60ee20b6b53a9351efbdf175f36525ead220de6;hb=d60ee20b6b53a9351efbdf175f36525ead220de6,1,"char *auth_server(int f_in, int f_out, int module, const char *host,
		  const char *addr, const char *leader)
{
	char *users = lp_auth_users(module);
	char challenge[MAX_DIGEST_LEN*2];
	char line[BIGPATHBUFLEN];
	char **auth_uid_groups = NULL;
	int auth_uid_groups_cnt = -1;
	const char *err = NULL;
	int group_match = -1;
	char *tok, *pass;
	char opt_ch = '\0';

	/* if no auth list then allow anyone in! */
	if (!users || !*users)
        if (!users || !*users)
                return """";
 
//fix_flaw_line_below:
//       if (protocol_version < 21) { /* Don't allow a weak checksum for the password. */
//fix_flaw_line_below:
//               rprintf(FERROR, ""ERROR: protocol version is too old!\n"");
//fix_flaw_line_below:
//               exit_cleanup(RERR_PROTOCOL);
//fix_flaw_line_below:
//       }
//fix_flaw_line_below:
//
        gen_challenge(addr, challenge);
 
        io_printf(f_out, ""%s%s\n"", leader, challenge);
		return NULL;
	}
"
78,177814,,Remote,Not required,Partial,CVE-2017-15994,https://www.cvedetails.com/cve/CVE-2017-15994/,CWE-354,Low,Partial,Partial,,2017-10-29,7.5,"rsync 3.1.3-development before 2017-10-24 mishandles archaic checksums, which makes it easier for remote attackers to bypass intended access restrictions. NOTE: the rsync development branch has significant use beyond the rsync developers, e.g., the code has been copied for use in various GitHub projects.",2019-10-02,Bypass,1,https://git.samba.org/?p=rsync.git;a=commit;h=7b8a4ecd6ff9cdf4e5d3850ebf822f1e989255b3,7b8a4ecd6ff9cdf4e5d3850ebf822f1e989255b3,,1,,,"int csum_len_for_type(int cst)
{
        switch (cst) {
          case CSUM_NONE:
                return 1;
         case CSUM_MD4_ARCHAIC:
                return 2;
          case CSUM_MD4:
          case CSUM_MD4_OLD:
	  case CSUM_MD4_BUSTED:
		return MD4_DIGEST_LEN;
	  case CSUM_MD5:
		return MD5_DIGEST_LEN;
	}
	return 0;
}
","int csum_len_for_type(int cst)
{
        switch (cst) {
          case CSUM_NONE:
                return 1;
         case CSUM_ARCHAIC:
                return 2;
          case CSUM_MD4:
          case CSUM_MD4_OLD:
	  case CSUM_MD4_BUSTED:
		return MD4_DIGEST_LEN;
	  case CSUM_MD5:
		return MD5_DIGEST_LEN;
	}
	return 0;
}
",C,"         case CSUM_MD4_ARCHAIC:
","         case CSUM_ARCHAIC:
",17b849c97aa24f30d572ac5ea552e8cb5a27e9fe,"@@ -27,7 +27,7 @@ extern int proper_seed_order;
 extern char *checksum_choice;
 
 #define CSUM_NONE 0
-#define CSUM_ARCHAIC 1
+#define CSUM_MD4_ARCHAIC 1
 #define CSUM_MD4_BUSTED 2
 #define CSUM_MD4_OLD 3
 #define CSUM_MD4 4
@@ -60,7 +60,7 @@ int parse_csum_name(const char *name, int len)
                        return CSUM_MD4_OLD;
                if (protocol_version >= 21)
                        return CSUM_MD4_BUSTED;
-               return CSUM_ARCHAIC;
+               return CSUM_MD4_ARCHAIC;
        }
        if (len == 3 && strncasecmp(name, ""md4"", 3) == 0)
                return CSUM_MD4;
@@ -78,7 +78,7 @@ int csum_len_for_type(int cst)
        switch (cst) {
          case CSUM_NONE:
                return 1;
-         case CSUM_ARCHAIC:
+         case CSUM_MD4_ARCHAIC:
                return 2;
          case CSUM_MD4:
          case CSUM_MD4_OLD:
@@ -143,7 +143,8 @@ void get_checksum2(char *buf, int32 len, char *sum)
          }
          case CSUM_MD4:
          case CSUM_MD4_OLD:
-         case CSUM_MD4_BUSTED: {
+         case CSUM_MD4_BUSTED:
+         case CSUM_MD4_ARCHAIC: {
                int32 i;
                static char *buf1;
                static int32 len1;
@@ -174,7 +175,7 @@ void get_checksum2(char *buf, int32 len, char *sum)
                 * are multiples of 64.  This is fixed by calling mdfour_update()
                 * even when there are no more bytes.
                 */
-               if (len - i > 0 || xfersum_type != CSUM_MD4_BUSTED)
+               if (len - i > 0 || xfersum_type > CSUM_MD4_BUSTED)
                        mdfour_update(&m, (uchar *)(buf1+i), len-i);
 
                mdfour_result(&m, (uchar *)sum);
@@ -217,6 +218,7 @@ void file_checksum(const char *fname, const STRUCT_STAT *st_p, char *sum)
          case CSUM_MD4:
          case CSUM_MD4_OLD:
          case CSUM_MD4_BUSTED:
+         case CSUM_MD4_ARCHAIC:
                mdfour_begin(&m);
 
                for (i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
@@ -229,7 +231,7 @@ void file_checksum(const char *fname, const STRUCT_STAT *st_p, char *sum)
                 * are multiples of 64.  This is fixed by calling mdfour_update()
                 * even when there are no more bytes. */
                remainder = (int32)(len - i);
-               if (remainder > 0 || checksum_type != CSUM_MD4_BUSTED)
+               if (remainder > 0 || checksum_type > CSUM_MD4_BUSTED)
                        mdfour_update(&m, (uchar *)map_ptr(buf, i, remainder), remainder);
 
                mdfour_result(&m, (uchar *)sum);
@@ -265,6 +267,7 @@ void sum_init(int csum_type, int seed)
                break;
          case CSUM_MD4_OLD:
          case CSUM_MD4_BUSTED:
+         case CSUM_MD4_ARCHAIC:
                mdfour_begin(&md);
                sumresidue = 0;
                SIVAL(s, 0, seed);
@@ -321,6 +324,10 @@ void sum_update(const char *p, int32 len)
        }
 }
 
+/* NOTE: all the callers of sum_end() pass in a pointer to a buffer that is
+ * MAX_DIGEST_LEN in size, so even if the csum-len is shorter that that (i.e.
+ * CSUM_MD4_ARCHAIC), we don't have to worry about limiting the data we write
+ * into the ""sum"" buffer. */
 int sum_end(char *sum)
 {
        switch (cursum_type) {
@@ -333,6 +340,7 @@ int sum_end(char *sum)
                mdfour_result(&md, (uchar *)sum);
                break;
          case CSUM_MD4_BUSTED:
+         case CSUM_MD4_ARCHAIC:
                if (sumresidue)
                        mdfour_update(&md, (uchar *)md.buffer, sumresidue);
                mdfour_result(&md, (uchar *)sum);",samba,https://git.samba.org/?p=rsync.git;a=blob;f=checksum.c;h=93826944034f5967b7c3b727994d3b54361854b0;hb=93826944034f5967b7c3b727994d3b54361854b0,https://git.samba.org/?p=rsync.git;a=blob;f=checksum.c;h=8b3883363d64b9a685c13361b2142e7f365259b5;hb=8b3883363d64b9a685c13361b2142e7f365259b5,1,"int csum_len_for_type(int cst)
{
        switch (cst) {
          case CSUM_NONE:
                return 1;
//flaw_line_below:
         case CSUM_ARCHAIC:
//fix_flaw_line_below:
//         case CSUM_MD4_ARCHAIC:
                return 2;
          case CSUM_MD4:
          case CSUM_MD4_OLD:
	  case CSUM_MD4_BUSTED:
		return MD4_DIGEST_LEN;
	  case CSUM_MD5:
		return MD5_DIGEST_LEN;
	}
	return 0;
}
"
79,177815,,Remote,Not required,Partial,CVE-2017-15994,https://www.cvedetails.com/cve/CVE-2017-15994/,CWE-354,Low,Partial,Partial,,2017-10-29,7.5,"rsync 3.1.3-development before 2017-10-24 mishandles archaic checksums, which makes it easier for remote attackers to bypass intended access restrictions. NOTE: the rsync development branch has significant use beyond the rsync developers, e.g., the code has been copied for use in various GitHub projects.",2019-10-02,Bypass,2,https://git.samba.org/?p=rsync.git;a=commit;h=7b8a4ecd6ff9cdf4e5d3850ebf822f1e989255b3,7b8a4ecd6ff9cdf4e5d3850ebf822f1e989255b3,,1,,,"void file_checksum(const char *fname, const STRUCT_STAT *st_p, char *sum)
{
	struct map_struct *buf;
	OFF_T i, len = st_p->st_size;
	md_context m;
	int32 remainder;
	int fd;

	memset(sum, 0, MAX_DIGEST_LEN);

	fd = do_open(fname, O_RDONLY, 0);
	if (fd == -1)
		return;

	buf = map_file(fd, len, MAX_MAP_SIZE, CSUM_CHUNK);

	switch (checksum_type) {
	  case CSUM_MD5:
		md5_begin(&m);

		for (i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
			md5_update(&m, (uchar *)map_ptr(buf, i, CSUM_CHUNK),
				   CSUM_CHUNK);
		}

		remainder = (int32)(len - i);
		if (remainder > 0)
			md5_update(&m, (uchar *)map_ptr(buf, i, remainder), remainder);

		md5_result(&m, (uchar *)sum);
		break;
	  case CSUM_MD4:
          case CSUM_MD4:
          case CSUM_MD4_OLD:
          case CSUM_MD4_BUSTED:
         case CSUM_MD4_ARCHAIC:
                mdfour_begin(&m);
 
                for (i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
		}

		/* Prior to version 27 an incorrect MD4 checksum was computed
		 * by failing to call mdfour_tail() for block sizes that
		 * are multiples of 64.  This is fixed by calling mdfour_update()
		 * even when there are no more bytes. */
                 * are multiples of 64.  This is fixed by calling mdfour_update()
                 * even when there are no more bytes. */
                remainder = (int32)(len - i);
               if (remainder > 0 || checksum_type > CSUM_MD4_BUSTED)
                        mdfour_update(&m, (uchar *)map_ptr(buf, i, remainder), remainder);
 
                mdfour_result(&m, (uchar *)sum);
		rprintf(FERROR, ""invalid checksum-choice for the --checksum option (%d)\n"", checksum_type);
		exit_cleanup(RERR_UNSUPPORTED);
	}

	close(fd);
	unmap_file(buf);
}
","void file_checksum(const char *fname, const STRUCT_STAT *st_p, char *sum)
{
	struct map_struct *buf;
	OFF_T i, len = st_p->st_size;
	md_context m;
	int32 remainder;
	int fd;

	memset(sum, 0, MAX_DIGEST_LEN);

	fd = do_open(fname, O_RDONLY, 0);
	if (fd == -1)
		return;

	buf = map_file(fd, len, MAX_MAP_SIZE, CSUM_CHUNK);

	switch (checksum_type) {
	  case CSUM_MD5:
		md5_begin(&m);

		for (i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
			md5_update(&m, (uchar *)map_ptr(buf, i, CSUM_CHUNK),
				   CSUM_CHUNK);
		}

		remainder = (int32)(len - i);
		if (remainder > 0)
			md5_update(&m, (uchar *)map_ptr(buf, i, remainder), remainder);

		md5_result(&m, (uchar *)sum);
		break;
	  case CSUM_MD4:
          case CSUM_MD4:
          case CSUM_MD4_OLD:
          case CSUM_MD4_BUSTED:
                mdfour_begin(&m);
 
                for (i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
		}

		/* Prior to version 27 an incorrect MD4 checksum was computed
		 * by failing to call mdfour_tail() for block sizes that
		 * are multiples of 64.  This is fixed by calling mdfour_update()
		 * even when there are no more bytes. */
                 * are multiples of 64.  This is fixed by calling mdfour_update()
                 * even when there are no more bytes. */
                remainder = (int32)(len - i);
               if (remainder > 0 || checksum_type != CSUM_MD4_BUSTED)
                        mdfour_update(&m, (uchar *)map_ptr(buf, i, remainder), remainder);
 
                mdfour_result(&m, (uchar *)sum);
		rprintf(FERROR, ""invalid checksum-choice for the --checksum option (%d)\n"", checksum_type);
		exit_cleanup(RERR_UNSUPPORTED);
	}

	close(fd);
	unmap_file(buf);
}
",C,"         case CSUM_MD4_ARCHAIC:
               if (remainder > 0 || checksum_type > CSUM_MD4_BUSTED)
","               if (remainder > 0 || checksum_type != CSUM_MD4_BUSTED)
",17b849c97aa24f30d572ac5ea552e8cb5a27e9fe,"@@ -27,7 +27,7 @@ extern int proper_seed_order;
 extern char *checksum_choice;
 
 #define CSUM_NONE 0
-#define CSUM_ARCHAIC 1
+#define CSUM_MD4_ARCHAIC 1
 #define CSUM_MD4_BUSTED 2
 #define CSUM_MD4_OLD 3
 #define CSUM_MD4 4
@@ -60,7 +60,7 @@ int parse_csum_name(const char *name, int len)
                        return CSUM_MD4_OLD;
                if (protocol_version >= 21)
                        return CSUM_MD4_BUSTED;
-               return CSUM_ARCHAIC;
+               return CSUM_MD4_ARCHAIC;
        }
        if (len == 3 && strncasecmp(name, ""md4"", 3) == 0)
                return CSUM_MD4;
@@ -78,7 +78,7 @@ int csum_len_for_type(int cst)
        switch (cst) {
          case CSUM_NONE:
                return 1;
-         case CSUM_ARCHAIC:
+         case CSUM_MD4_ARCHAIC:
                return 2;
          case CSUM_MD4:
          case CSUM_MD4_OLD:
@@ -143,7 +143,8 @@ void get_checksum2(char *buf, int32 len, char *sum)
          }
          case CSUM_MD4:
          case CSUM_MD4_OLD:
-         case CSUM_MD4_BUSTED: {
+         case CSUM_MD4_BUSTED:
+         case CSUM_MD4_ARCHAIC: {
                int32 i;
                static char *buf1;
                static int32 len1;
@@ -174,7 +175,7 @@ void get_checksum2(char *buf, int32 len, char *sum)
                 * are multiples of 64.  This is fixed by calling mdfour_update()
                 * even when there are no more bytes.
                 */
-               if (len - i > 0 || xfersum_type != CSUM_MD4_BUSTED)
+               if (len - i > 0 || xfersum_type > CSUM_MD4_BUSTED)
                        mdfour_update(&m, (uchar *)(buf1+i), len-i);
 
                mdfour_result(&m, (uchar *)sum);
@@ -217,6 +218,7 @@ void file_checksum(const char *fname, const STRUCT_STAT *st_p, char *sum)
          case CSUM_MD4:
          case CSUM_MD4_OLD:
          case CSUM_MD4_BUSTED:
+         case CSUM_MD4_ARCHAIC:
                mdfour_begin(&m);
 
                for (i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
@@ -229,7 +231,7 @@ void file_checksum(const char *fname, const STRUCT_STAT *st_p, char *sum)
                 * are multiples of 64.  This is fixed by calling mdfour_update()
                 * even when there are no more bytes. */
                remainder = (int32)(len - i);
-               if (remainder > 0 || checksum_type != CSUM_MD4_BUSTED)
+               if (remainder > 0 || checksum_type > CSUM_MD4_BUSTED)
                        mdfour_update(&m, (uchar *)map_ptr(buf, i, remainder), remainder);
 
                mdfour_result(&m, (uchar *)sum);
@@ -265,6 +267,7 @@ void sum_init(int csum_type, int seed)
                break;
          case CSUM_MD4_OLD:
          case CSUM_MD4_BUSTED:
+         case CSUM_MD4_ARCHAIC:
                mdfour_begin(&md);
                sumresidue = 0;
                SIVAL(s, 0, seed);
@@ -321,6 +324,10 @@ void sum_update(const char *p, int32 len)
        }
 }
 
+/* NOTE: all the callers of sum_end() pass in a pointer to a buffer that is
+ * MAX_DIGEST_LEN in size, so even if the csum-len is shorter that that (i.e.
+ * CSUM_MD4_ARCHAIC), we don't have to worry about limiting the data we write
+ * into the ""sum"" buffer. */
 int sum_end(char *sum)
 {
        switch (cursum_type) {
@@ -333,6 +340,7 @@ int sum_end(char *sum)
                mdfour_result(&md, (uchar *)sum);
                break;
          case CSUM_MD4_BUSTED:
+         case CSUM_MD4_ARCHAIC:
                if (sumresidue)
                        mdfour_update(&md, (uchar *)md.buffer, sumresidue);
                mdfour_result(&md, (uchar *)sum);",samba,https://git.samba.org/?p=rsync.git;a=blob;f=checksum.c;h=93826944034f5967b7c3b727994d3b54361854b0;hb=93826944034f5967b7c3b727994d3b54361854b0,https://git.samba.org/?p=rsync.git;a=blob;f=checksum.c;h=8b3883363d64b9a685c13361b2142e7f365259b5;hb=8b3883363d64b9a685c13361b2142e7f365259b5,1,"void file_checksum(const char *fname, const STRUCT_STAT *st_p, char *sum)
{
	struct map_struct *buf;
	OFF_T i, len = st_p->st_size;
	md_context m;
	int32 remainder;
	int fd;

	memset(sum, 0, MAX_DIGEST_LEN);

	fd = do_open(fname, O_RDONLY, 0);
	if (fd == -1)
		return;

	buf = map_file(fd, len, MAX_MAP_SIZE, CSUM_CHUNK);

	switch (checksum_type) {
	  case CSUM_MD5:
		md5_begin(&m);

		for (i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
			md5_update(&m, (uchar *)map_ptr(buf, i, CSUM_CHUNK),
				   CSUM_CHUNK);
		}

		remainder = (int32)(len - i);
		if (remainder > 0)
			md5_update(&m, (uchar *)map_ptr(buf, i, remainder), remainder);

		md5_result(&m, (uchar *)sum);
		break;
	  case CSUM_MD4:
          case CSUM_MD4:
          case CSUM_MD4_OLD:
          case CSUM_MD4_BUSTED:
//fix_flaw_line_below:
//         case CSUM_MD4_ARCHAIC:
                mdfour_begin(&m);
 
                for (i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
		}

		/* Prior to version 27 an incorrect MD4 checksum was computed
		 * by failing to call mdfour_tail() for block sizes that
		 * are multiples of 64.  This is fixed by calling mdfour_update()
		 * even when there are no more bytes. */
                 * are multiples of 64.  This is fixed by calling mdfour_update()
                 * even when there are no more bytes. */
                remainder = (int32)(len - i);
//flaw_line_below:
               if (remainder > 0 || checksum_type != CSUM_MD4_BUSTED)
//fix_flaw_line_below:
//               if (remainder > 0 || checksum_type > CSUM_MD4_BUSTED)
                        mdfour_update(&m, (uchar *)map_ptr(buf, i, remainder), remainder);
 
                mdfour_result(&m, (uchar *)sum);
		rprintf(FERROR, ""invalid checksum-choice for the --checksum option (%d)\n"", checksum_type);
		exit_cleanup(RERR_UNSUPPORTED);
	}

	close(fd);
	unmap_file(buf);
}
"
80,177816,,Remote,Not required,Partial,CVE-2017-15994,https://www.cvedetails.com/cve/CVE-2017-15994/,CWE-354,Low,Partial,Partial,,2017-10-29,7.5,"rsync 3.1.3-development before 2017-10-24 mishandles archaic checksums, which makes it easier for remote attackers to bypass intended access restrictions. NOTE: the rsync development branch has significant use beyond the rsync developers, e.g., the code has been copied for use in various GitHub projects.",2019-10-02,Bypass,3,https://git.samba.org/?p=rsync.git;a=commit;h=7b8a4ecd6ff9cdf4e5d3850ebf822f1e989255b3,7b8a4ecd6ff9cdf4e5d3850ebf822f1e989255b3,,2,,,"void get_checksum2(char *buf, int32 len, char *sum)
{
	md_context m;

	switch (xfersum_type) {
	  case CSUM_MD5: {
		uchar seedbuf[4];
		md5_begin(&m);
		if (proper_seed_order) {
			if (checksum_seed) {
				SIVALu(seedbuf, 0, checksum_seed);
				md5_update(&m, seedbuf, 4);
			}
			md5_update(&m, (uchar *)buf, len);
		} else {
			md5_update(&m, (uchar *)buf, len);
			if (checksum_seed) {
				SIVALu(seedbuf, 0, checksum_seed);
				md5_update(&m, seedbuf, 4);
			}
		}
		md5_result(&m, (uchar *)sum);
		break;
          }
          case CSUM_MD4:
          case CSUM_MD4_OLD:
         case CSUM_MD4_BUSTED:
         case CSUM_MD4_ARCHAIC: {
                int32 i;
                static char *buf1;
                static int32 len1;
		mdfour_begin(&m);

		if (len > len1) {
			if (buf1)
				free(buf1);
			buf1 = new_array(char, len+4);
			len1 = len;
			if (!buf1)
				out_of_memory(""get_checksum2"");
		}

		memcpy(buf1, buf, len);
		if (checksum_seed) {
			SIVAL(buf1,len,checksum_seed);
			len += 4;
		}

		for (i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK)
			mdfour_update(&m, (uchar *)(buf1+i), CSUM_CHUNK);

		/*
		 * Prior to version 27 an incorrect MD4 checksum was computed
		 * by failing to call mdfour_tail() for block sizes that
		 * are multiples of 64.  This is fixed by calling mdfour_update()
                 * are multiples of 64.  This is fixed by calling mdfour_update()
                 * even when there are no more bytes.
                 */
               if (len - i > 0 || xfersum_type > CSUM_MD4_BUSTED)
                        mdfour_update(&m, (uchar *)(buf1+i), len-i);
 
                mdfour_result(&m, (uchar *)sum);
	  }
	}
}
","void get_checksum2(char *buf, int32 len, char *sum)
{
	md_context m;

	switch (xfersum_type) {
	  case CSUM_MD5: {
		uchar seedbuf[4];
		md5_begin(&m);
		if (proper_seed_order) {
			if (checksum_seed) {
				SIVALu(seedbuf, 0, checksum_seed);
				md5_update(&m, seedbuf, 4);
			}
			md5_update(&m, (uchar *)buf, len);
		} else {
			md5_update(&m, (uchar *)buf, len);
			if (checksum_seed) {
				SIVALu(seedbuf, 0, checksum_seed);
				md5_update(&m, seedbuf, 4);
			}
		}
		md5_result(&m, (uchar *)sum);
		break;
          }
          case CSUM_MD4:
          case CSUM_MD4_OLD:
         case CSUM_MD4_BUSTED: {
                int32 i;
                static char *buf1;
                static int32 len1;
		mdfour_begin(&m);

		if (len > len1) {
			if (buf1)
				free(buf1);
			buf1 = new_array(char, len+4);
			len1 = len;
			if (!buf1)
				out_of_memory(""get_checksum2"");
		}

		memcpy(buf1, buf, len);
		if (checksum_seed) {
			SIVAL(buf1,len,checksum_seed);
			len += 4;
		}

		for (i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK)
			mdfour_update(&m, (uchar *)(buf1+i), CSUM_CHUNK);

		/*
		 * Prior to version 27 an incorrect MD4 checksum was computed
		 * by failing to call mdfour_tail() for block sizes that
		 * are multiples of 64.  This is fixed by calling mdfour_update()
                 * are multiples of 64.  This is fixed by calling mdfour_update()
                 * even when there are no more bytes.
                 */
               if (len - i > 0 || xfersum_type != CSUM_MD4_BUSTED)
                        mdfour_update(&m, (uchar *)(buf1+i), len-i);
 
                mdfour_result(&m, (uchar *)sum);
	  }
	}
}
",C,"         case CSUM_MD4_BUSTED:
         case CSUM_MD4_ARCHAIC: {
               if (len - i > 0 || xfersum_type > CSUM_MD4_BUSTED)
","         case CSUM_MD4_BUSTED: {
               if (len - i > 0 || xfersum_type != CSUM_MD4_BUSTED)
",17b849c97aa24f30d572ac5ea552e8cb5a27e9fe,"@@ -27,7 +27,7 @@ extern int proper_seed_order;
 extern char *checksum_choice;
 
 #define CSUM_NONE 0
-#define CSUM_ARCHAIC 1
+#define CSUM_MD4_ARCHAIC 1
 #define CSUM_MD4_BUSTED 2
 #define CSUM_MD4_OLD 3
 #define CSUM_MD4 4
@@ -60,7 +60,7 @@ int parse_csum_name(const char *name, int len)
                        return CSUM_MD4_OLD;
                if (protocol_version >= 21)
                        return CSUM_MD4_BUSTED;
-               return CSUM_ARCHAIC;
+               return CSUM_MD4_ARCHAIC;
        }
        if (len == 3 && strncasecmp(name, ""md4"", 3) == 0)
                return CSUM_MD4;
@@ -78,7 +78,7 @@ int csum_len_for_type(int cst)
        switch (cst) {
          case CSUM_NONE:
                return 1;
-         case CSUM_ARCHAIC:
+         case CSUM_MD4_ARCHAIC:
                return 2;
          case CSUM_MD4:
          case CSUM_MD4_OLD:
@@ -143,7 +143,8 @@ void get_checksum2(char *buf, int32 len, char *sum)
          }
          case CSUM_MD4:
          case CSUM_MD4_OLD:
-         case CSUM_MD4_BUSTED: {
+         case CSUM_MD4_BUSTED:
+         case CSUM_MD4_ARCHAIC: {
                int32 i;
                static char *buf1;
                static int32 len1;
@@ -174,7 +175,7 @@ void get_checksum2(char *buf, int32 len, char *sum)
                 * are multiples of 64.  This is fixed by calling mdfour_update()
                 * even when there are no more bytes.
                 */
-               if (len - i > 0 || xfersum_type != CSUM_MD4_BUSTED)
+               if (len - i > 0 || xfersum_type > CSUM_MD4_BUSTED)
                        mdfour_update(&m, (uchar *)(buf1+i), len-i);
 
                mdfour_result(&m, (uchar *)sum);
@@ -217,6 +218,7 @@ void file_checksum(const char *fname, const STRUCT_STAT *st_p, char *sum)
          case CSUM_MD4:
          case CSUM_MD4_OLD:
          case CSUM_MD4_BUSTED:
+         case CSUM_MD4_ARCHAIC:
                mdfour_begin(&m);
 
                for (i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
@@ -229,7 +231,7 @@ void file_checksum(const char *fname, const STRUCT_STAT *st_p, char *sum)
                 * are multiples of 64.  This is fixed by calling mdfour_update()
                 * even when there are no more bytes. */
                remainder = (int32)(len - i);
-               if (remainder > 0 || checksum_type != CSUM_MD4_BUSTED)
+               if (remainder > 0 || checksum_type > CSUM_MD4_BUSTED)
                        mdfour_update(&m, (uchar *)map_ptr(buf, i, remainder), remainder);
 
                mdfour_result(&m, (uchar *)sum);
@@ -265,6 +267,7 @@ void sum_init(int csum_type, int seed)
                break;
          case CSUM_MD4_OLD:
          case CSUM_MD4_BUSTED:
+         case CSUM_MD4_ARCHAIC:
                mdfour_begin(&md);
                sumresidue = 0;
                SIVAL(s, 0, seed);
@@ -321,6 +324,10 @@ void sum_update(const char *p, int32 len)
        }
 }
 
+/* NOTE: all the callers of sum_end() pass in a pointer to a buffer that is
+ * MAX_DIGEST_LEN in size, so even if the csum-len is shorter that that (i.e.
+ * CSUM_MD4_ARCHAIC), we don't have to worry about limiting the data we write
+ * into the ""sum"" buffer. */
 int sum_end(char *sum)
 {
        switch (cursum_type) {
@@ -333,6 +340,7 @@ int sum_end(char *sum)
                mdfour_result(&md, (uchar *)sum);
                break;
          case CSUM_MD4_BUSTED:
+         case CSUM_MD4_ARCHAIC:
                if (sumresidue)
                        mdfour_update(&md, (uchar *)md.buffer, sumresidue);
                mdfour_result(&md, (uchar *)sum);",samba,https://git.samba.org/?p=rsync.git;a=blob;f=checksum.c;h=93826944034f5967b7c3b727994d3b54361854b0;hb=93826944034f5967b7c3b727994d3b54361854b0,https://git.samba.org/?p=rsync.git;a=blob;f=checksum.c;h=8b3883363d64b9a685c13361b2142e7f365259b5;hb=8b3883363d64b9a685c13361b2142e7f365259b5,1,"void get_checksum2(char *buf, int32 len, char *sum)
{
	md_context m;

	switch (xfersum_type) {
	  case CSUM_MD5: {
		uchar seedbuf[4];
		md5_begin(&m);
		if (proper_seed_order) {
			if (checksum_seed) {
				SIVALu(seedbuf, 0, checksum_seed);
				md5_update(&m, seedbuf, 4);
			}
			md5_update(&m, (uchar *)buf, len);
		} else {
			md5_update(&m, (uchar *)buf, len);
			if (checksum_seed) {
				SIVALu(seedbuf, 0, checksum_seed);
				md5_update(&m, seedbuf, 4);
			}
		}
		md5_result(&m, (uchar *)sum);
		break;
          }
          case CSUM_MD4:
          case CSUM_MD4_OLD:
//flaw_line_below:
         case CSUM_MD4_BUSTED: {
//fix_flaw_line_below:
//         case CSUM_MD4_BUSTED:
//fix_flaw_line_below:
//         case CSUM_MD4_ARCHAIC: {
                int32 i;
                static char *buf1;
                static int32 len1;
		mdfour_begin(&m);

		if (len > len1) {
			if (buf1)
				free(buf1);
			buf1 = new_array(char, len+4);
			len1 = len;
			if (!buf1)
				out_of_memory(""get_checksum2"");
		}

		memcpy(buf1, buf, len);
		if (checksum_seed) {
			SIVAL(buf1,len,checksum_seed);
			len += 4;
		}

		for (i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK)
			mdfour_update(&m, (uchar *)(buf1+i), CSUM_CHUNK);

		/*
		 * Prior to version 27 an incorrect MD4 checksum was computed
		 * by failing to call mdfour_tail() for block sizes that
		 * are multiples of 64.  This is fixed by calling mdfour_update()
                 * are multiples of 64.  This is fixed by calling mdfour_update()
                 * even when there are no more bytes.
                 */
//flaw_line_below:
               if (len - i > 0 || xfersum_type != CSUM_MD4_BUSTED)
//fix_flaw_line_below:
//               if (len - i > 0 || xfersum_type > CSUM_MD4_BUSTED)
                        mdfour_update(&m, (uchar *)(buf1+i), len-i);
 
                mdfour_result(&m, (uchar *)sum);
	  }
	}
}
"
81,177817,,Remote,Not required,Partial,CVE-2017-15994,https://www.cvedetails.com/cve/CVE-2017-15994/,CWE-354,Low,Partial,Partial,,2017-10-29,7.5,"rsync 3.1.3-development before 2017-10-24 mishandles archaic checksums, which makes it easier for remote attackers to bypass intended access restrictions. NOTE: the rsync development branch has significant use beyond the rsync developers, e.g., the code has been copied for use in various GitHub projects.",2019-10-02,Bypass,1,https://git.samba.org/?p=rsync.git;a=commit;h=7b8a4ecd6ff9cdf4e5d3850ebf822f1e989255b3,7b8a4ecd6ff9cdf4e5d3850ebf822f1e989255b3,,1,,,"int parse_csum_name(const char *name, int len)
{
	if (len < 0 && name)
		len = strlen(name);

	if (!name || (len == 4 && strncasecmp(name, ""auto"", 4) == 0)) {
		if (protocol_version >= 30)
			return CSUM_MD5;
		if (protocol_version >= 27)
                        return CSUM_MD4_OLD;
                if (protocol_version >= 21)
                        return CSUM_MD4_BUSTED;
               return CSUM_MD4_ARCHAIC;
        }
        if (len == 3 && strncasecmp(name, ""md4"", 3) == 0)
                return CSUM_MD4;
	if (len == 3 && strncasecmp(name, ""md5"", 3) == 0)
		return CSUM_MD5;
	if (len == 4 && strncasecmp(name, ""none"", 4) == 0)
		return CSUM_NONE;

	rprintf(FERROR, ""unknown checksum name: %s\n"", name);
	exit_cleanup(RERR_UNSUPPORTED);
}
","int parse_csum_name(const char *name, int len)
{
	if (len < 0 && name)
		len = strlen(name);

	if (!name || (len == 4 && strncasecmp(name, ""auto"", 4) == 0)) {
		if (protocol_version >= 30)
			return CSUM_MD5;
		if (protocol_version >= 27)
                        return CSUM_MD4_OLD;
                if (protocol_version >= 21)
                        return CSUM_MD4_BUSTED;
               return CSUM_ARCHAIC;
        }
        if (len == 3 && strncasecmp(name, ""md4"", 3) == 0)
                return CSUM_MD4;
	if (len == 3 && strncasecmp(name, ""md5"", 3) == 0)
		return CSUM_MD5;
	if (len == 4 && strncasecmp(name, ""none"", 4) == 0)
		return CSUM_NONE;

	rprintf(FERROR, ""unknown checksum name: %s\n"", name);
	exit_cleanup(RERR_UNSUPPORTED);
}
",C,"               return CSUM_MD4_ARCHAIC;
","               return CSUM_ARCHAIC;
",17b849c97aa24f30d572ac5ea552e8cb5a27e9fe,"@@ -27,7 +27,7 @@ extern int proper_seed_order;
 extern char *checksum_choice;
 
 #define CSUM_NONE 0
-#define CSUM_ARCHAIC 1
+#define CSUM_MD4_ARCHAIC 1
 #define CSUM_MD4_BUSTED 2
 #define CSUM_MD4_OLD 3
 #define CSUM_MD4 4
@@ -60,7 +60,7 @@ int parse_csum_name(const char *name, int len)
                        return CSUM_MD4_OLD;
                if (protocol_version >= 21)
                        return CSUM_MD4_BUSTED;
-               return CSUM_ARCHAIC;
+               return CSUM_MD4_ARCHAIC;
        }
        if (len == 3 && strncasecmp(name, ""md4"", 3) == 0)
                return CSUM_MD4;
@@ -78,7 +78,7 @@ int csum_len_for_type(int cst)
        switch (cst) {
          case CSUM_NONE:
                return 1;
-         case CSUM_ARCHAIC:
+         case CSUM_MD4_ARCHAIC:
                return 2;
          case CSUM_MD4:
          case CSUM_MD4_OLD:
@@ -143,7 +143,8 @@ void get_checksum2(char *buf, int32 len, char *sum)
          }
          case CSUM_MD4:
          case CSUM_MD4_OLD:
-         case CSUM_MD4_BUSTED: {
+         case CSUM_MD4_BUSTED:
+         case CSUM_MD4_ARCHAIC: {
                int32 i;
                static char *buf1;
                static int32 len1;
@@ -174,7 +175,7 @@ void get_checksum2(char *buf, int32 len, char *sum)
                 * are multiples of 64.  This is fixed by calling mdfour_update()
                 * even when there are no more bytes.
                 */
-               if (len - i > 0 || xfersum_type != CSUM_MD4_BUSTED)
+               if (len - i > 0 || xfersum_type > CSUM_MD4_BUSTED)
                        mdfour_update(&m, (uchar *)(buf1+i), len-i);
 
                mdfour_result(&m, (uchar *)sum);
@@ -217,6 +218,7 @@ void file_checksum(const char *fname, const STRUCT_STAT *st_p, char *sum)
          case CSUM_MD4:
          case CSUM_MD4_OLD:
          case CSUM_MD4_BUSTED:
+         case CSUM_MD4_ARCHAIC:
                mdfour_begin(&m);
 
                for (i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
@@ -229,7 +231,7 @@ void file_checksum(const char *fname, const STRUCT_STAT *st_p, char *sum)
                 * are multiples of 64.  This is fixed by calling mdfour_update()
                 * even when there are no more bytes. */
                remainder = (int32)(len - i);
-               if (remainder > 0 || checksum_type != CSUM_MD4_BUSTED)
+               if (remainder > 0 || checksum_type > CSUM_MD4_BUSTED)
                        mdfour_update(&m, (uchar *)map_ptr(buf, i, remainder), remainder);
 
                mdfour_result(&m, (uchar *)sum);
@@ -265,6 +267,7 @@ void sum_init(int csum_type, int seed)
                break;
          case CSUM_MD4_OLD:
          case CSUM_MD4_BUSTED:
+         case CSUM_MD4_ARCHAIC:
                mdfour_begin(&md);
                sumresidue = 0;
                SIVAL(s, 0, seed);
@@ -321,6 +324,10 @@ void sum_update(const char *p, int32 len)
        }
 }
 
+/* NOTE: all the callers of sum_end() pass in a pointer to a buffer that is
+ * MAX_DIGEST_LEN in size, so even if the csum-len is shorter that that (i.e.
+ * CSUM_MD4_ARCHAIC), we don't have to worry about limiting the data we write
+ * into the ""sum"" buffer. */
 int sum_end(char *sum)
 {
        switch (cursum_type) {
@@ -333,6 +340,7 @@ int sum_end(char *sum)
                mdfour_result(&md, (uchar *)sum);
                break;
          case CSUM_MD4_BUSTED:
+         case CSUM_MD4_ARCHAIC:
                if (sumresidue)
                        mdfour_update(&md, (uchar *)md.buffer, sumresidue);
                mdfour_result(&md, (uchar *)sum);",samba,https://git.samba.org/?p=rsync.git;a=blob;f=checksum.c;h=93826944034f5967b7c3b727994d3b54361854b0;hb=93826944034f5967b7c3b727994d3b54361854b0,https://git.samba.org/?p=rsync.git;a=blob;f=checksum.c;h=8b3883363d64b9a685c13361b2142e7f365259b5;hb=8b3883363d64b9a685c13361b2142e7f365259b5,1,"int parse_csum_name(const char *name, int len)
{
	if (len < 0 && name)
		len = strlen(name);

	if (!name || (len == 4 && strncasecmp(name, ""auto"", 4) == 0)) {
		if (protocol_version >= 30)
			return CSUM_MD5;
		if (protocol_version >= 27)
                        return CSUM_MD4_OLD;
                if (protocol_version >= 21)
                        return CSUM_MD4_BUSTED;
//flaw_line_below:
               return CSUM_ARCHAIC;
//fix_flaw_line_below:
//               return CSUM_MD4_ARCHAIC;
        }
        if (len == 3 && strncasecmp(name, ""md4"", 3) == 0)
                return CSUM_MD4;
	if (len == 3 && strncasecmp(name, ""md5"", 3) == 0)
		return CSUM_MD5;
	if (len == 4 && strncasecmp(name, ""none"", 4) == 0)
		return CSUM_NONE;

	rprintf(FERROR, ""unknown checksum name: %s\n"", name);
	exit_cleanup(RERR_UNSUPPORTED);
}
"
82,177818,,Remote,Not required,Partial,CVE-2017-15994,https://www.cvedetails.com/cve/CVE-2017-15994/,CWE-354,Low,Partial,Partial,,2017-10-29,7.5,"rsync 3.1.3-development before 2017-10-24 mishandles archaic checksums, which makes it easier for remote attackers to bypass intended access restrictions. NOTE: the rsync development branch has significant use beyond the rsync developers, e.g., the code has been copied for use in various GitHub projects.",2019-10-02,Bypass,1,https://git.samba.org/?p=rsync.git;a=commit;h=7b8a4ecd6ff9cdf4e5d3850ebf822f1e989255b3,7b8a4ecd6ff9cdf4e5d3850ebf822f1e989255b3,,0,,,"void sum_init(int csum_type, int seed)
{
	char s[4];

	if (csum_type < 0)
		csum_type = parse_csum_name(NULL, 0);
	cursum_type = csum_type;

	switch (csum_type) {
	  case CSUM_MD5:
		md5_begin(&md);
		break;
	  case CSUM_MD4:
		mdfour_begin(&md);
		sumresidue = 0;
		break;
	  case CSUM_MD4_OLD:
                break;
          case CSUM_MD4_OLD:
          case CSUM_MD4_BUSTED:
         case CSUM_MD4_ARCHAIC:
                mdfour_begin(&md);
                sumresidue = 0;
                SIVAL(s, 0, seed);
		break;
	}
}
","void sum_init(int csum_type, int seed)
{
	char s[4];

	if (csum_type < 0)
		csum_type = parse_csum_name(NULL, 0);
	cursum_type = csum_type;

	switch (csum_type) {
	  case CSUM_MD5:
		md5_begin(&md);
		break;
	  case CSUM_MD4:
		mdfour_begin(&md);
		sumresidue = 0;
		break;
	  case CSUM_MD4_OLD:
                break;
          case CSUM_MD4_OLD:
          case CSUM_MD4_BUSTED:
                mdfour_begin(&md);
                sumresidue = 0;
                SIVAL(s, 0, seed);
		break;
	}
}
",C,"         case CSUM_MD4_ARCHAIC:
",,17b849c97aa24f30d572ac5ea552e8cb5a27e9fe,"@@ -27,7 +27,7 @@ extern int proper_seed_order;
 extern char *checksum_choice;
 
 #define CSUM_NONE 0
-#define CSUM_ARCHAIC 1
+#define CSUM_MD4_ARCHAIC 1
 #define CSUM_MD4_BUSTED 2
 #define CSUM_MD4_OLD 3
 #define CSUM_MD4 4
@@ -60,7 +60,7 @@ int parse_csum_name(const char *name, int len)
                        return CSUM_MD4_OLD;
                if (protocol_version >= 21)
                        return CSUM_MD4_BUSTED;
-               return CSUM_ARCHAIC;
+               return CSUM_MD4_ARCHAIC;
        }
        if (len == 3 && strncasecmp(name, ""md4"", 3) == 0)
                return CSUM_MD4;
@@ -78,7 +78,7 @@ int csum_len_for_type(int cst)
        switch (cst) {
          case CSUM_NONE:
                return 1;
-         case CSUM_ARCHAIC:
+         case CSUM_MD4_ARCHAIC:
                return 2;
          case CSUM_MD4:
          case CSUM_MD4_OLD:
@@ -143,7 +143,8 @@ void get_checksum2(char *buf, int32 len, char *sum)
          }
          case CSUM_MD4:
          case CSUM_MD4_OLD:
-         case CSUM_MD4_BUSTED: {
+         case CSUM_MD4_BUSTED:
+         case CSUM_MD4_ARCHAIC: {
                int32 i;
                static char *buf1;
                static int32 len1;
@@ -174,7 +175,7 @@ void get_checksum2(char *buf, int32 len, char *sum)
                 * are multiples of 64.  This is fixed by calling mdfour_update()
                 * even when there are no more bytes.
                 */
-               if (len - i > 0 || xfersum_type != CSUM_MD4_BUSTED)
+               if (len - i > 0 || xfersum_type > CSUM_MD4_BUSTED)
                        mdfour_update(&m, (uchar *)(buf1+i), len-i);
 
                mdfour_result(&m, (uchar *)sum);
@@ -217,6 +218,7 @@ void file_checksum(const char *fname, const STRUCT_STAT *st_p, char *sum)
          case CSUM_MD4:
          case CSUM_MD4_OLD:
          case CSUM_MD4_BUSTED:
+         case CSUM_MD4_ARCHAIC:
                mdfour_begin(&m);
 
                for (i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
@@ -229,7 +231,7 @@ void file_checksum(const char *fname, const STRUCT_STAT *st_p, char *sum)
                 * are multiples of 64.  This is fixed by calling mdfour_update()
                 * even when there are no more bytes. */
                remainder = (int32)(len - i);
-               if (remainder > 0 || checksum_type != CSUM_MD4_BUSTED)
+               if (remainder > 0 || checksum_type > CSUM_MD4_BUSTED)
                        mdfour_update(&m, (uchar *)map_ptr(buf, i, remainder), remainder);
 
                mdfour_result(&m, (uchar *)sum);
@@ -265,6 +267,7 @@ void sum_init(int csum_type, int seed)
                break;
          case CSUM_MD4_OLD:
          case CSUM_MD4_BUSTED:
+         case CSUM_MD4_ARCHAIC:
                mdfour_begin(&md);
                sumresidue = 0;
                SIVAL(s, 0, seed);
@@ -321,6 +324,10 @@ void sum_update(const char *p, int32 len)
        }
 }
 
+/* NOTE: all the callers of sum_end() pass in a pointer to a buffer that is
+ * MAX_DIGEST_LEN in size, so even if the csum-len is shorter that that (i.e.
+ * CSUM_MD4_ARCHAIC), we don't have to worry about limiting the data we write
+ * into the ""sum"" buffer. */
 int sum_end(char *sum)
 {
        switch (cursum_type) {
@@ -333,6 +340,7 @@ int sum_end(char *sum)
                mdfour_result(&md, (uchar *)sum);
                break;
          case CSUM_MD4_BUSTED:
+         case CSUM_MD4_ARCHAIC:
                if (sumresidue)
                        mdfour_update(&md, (uchar *)md.buffer, sumresidue);
                mdfour_result(&md, (uchar *)sum);",samba,https://git.samba.org/?p=rsync.git;a=blob;f=checksum.c;h=93826944034f5967b7c3b727994d3b54361854b0;hb=93826944034f5967b7c3b727994d3b54361854b0,https://git.samba.org/?p=rsync.git;a=blob;f=checksum.c;h=8b3883363d64b9a685c13361b2142e7f365259b5;hb=8b3883363d64b9a685c13361b2142e7f365259b5,1,"void sum_init(int csum_type, int seed)
{
	char s[4];

	if (csum_type < 0)
		csum_type = parse_csum_name(NULL, 0);
	cursum_type = csum_type;

	switch (csum_type) {
	  case CSUM_MD5:
		md5_begin(&md);
		break;
	  case CSUM_MD4:
		mdfour_begin(&md);
		sumresidue = 0;
		break;
	  case CSUM_MD4_OLD:
                break;
          case CSUM_MD4_OLD:
          case CSUM_MD4_BUSTED:
//fix_flaw_line_below:
//         case CSUM_MD4_ARCHAIC:
                mdfour_begin(&md);
                sumresidue = 0;
                SIVAL(s, 0, seed);
		break;
	}
}
"
