,Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix
3,177739,,Remote,Not required,Partial,CVE-2013-6449,https://www.cvedetails.com/cve/CVE-2013-6449/,CWE-310,Medium,,,,2013-12-23,4.3,"The ssl_get_algorithm2 function in ssl/s3_lib.c in OpenSSL before 1.0.2 obtains a certain version number from an incorrect data structure, which allows remote attackers to cause a denial of service (daemon crash) via crafted traffic from a TLS 1.2 client.",2018-10-09,DoS,1,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=ca989269a2876bae79393bd54c3e72d49975fc75,ca989269a2876bae79393bd54c3e72d49975fc75,,1,,," long ssl_get_algorithm2(SSL *s)
        {
        long alg2 = s->s3->tmp.new_cipher->algorithm2;
       if (s->method->version == TLS1_2_VERSION &&
            alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF))
                return SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256;
        return alg2;
	}
"," long ssl_get_algorithm2(SSL *s)
        {
        long alg2 = s->s3->tmp.new_cipher->algorithm2;
       if (TLS1_get_version(s) >= TLS1_2_VERSION &&
            alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF))
                return SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256;
        return alg2;
	}
",C,"       if (s->method->version == TLS1_2_VERSION &&
","       if (TLS1_get_version(s) >= TLS1_2_VERSION &&
",2ec4181ba92fc6b828687d2dc47c13dcd35a5d93,"@@ -4286,7 +4286,7 @@ need to go to SSL_ST_ACCEPT.
 long ssl_get_algorithm2(SSL *s)
        {
        long alg2 = s->s3->tmp.new_cipher->algorithm2;
-       if (TLS1_get_version(s) >= TLS1_2_VERSION &&
+       if (s->method->version == TLS1_2_VERSION &&
            alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF))
                return SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256;
        return alg2;",openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=ssl/s3_lib.c;h=c4ef2738d7b11b77af88e8d2fd8a29a125590640;hb=c4ef2738d7b11b77af88e8d2fd8a29a125590640,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=ssl/s3_lib.c;h=bf832bb6cc89a83cf22f6020014d53531882f7f9;hb=bf832bb6cc89a83cf22f6020014d53531882f7f9,1," long ssl_get_algorithm2(SSL *s)
        {
        long alg2 = s->s3->tmp.new_cipher->algorithm2;
//flaw_line_below:
       if (TLS1_get_version(s) >= TLS1_2_VERSION &&
//fix_flaw_line_below:
//       if (s->method->version == TLS1_2_VERSION &&
            alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF))
                return SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256;
        return alg2;
	}
"
227,177963,,Remote,Not required,Partial,CVE-2013-0166,https://www.cvedetails.com/cve/CVE-2013-0166/,CWE-310,Low,,,,2013-02-08,5.0,"OpenSSL before 0.9.8y, 1.0.0 before 1.0.0k, and 1.0.1 before 1.0.1d does not properly perform signature verification for OCSP responses, which allows remote OCSP servers to cause a denial of service (NULL pointer dereference and application crash) via an invalid key.",2018-08-08,DoS,6,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=62e4506a7d4cec1c8e1ff687f6b220f6a62a57c7,62e4506a7d4cec1c8e1ff687f6b220f6a62a57c7,,0,,,"int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,
		ASN1_BIT_STRING *signature, void *asn, EVP_PKEY *pkey)
	{
	EVP_MD_CTX ctx;
	unsigned char *buf_in=NULL;
	int ret= -1,inl;
 
        int mdnid, pknid;
 
       if (!pkey)
               {
               ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);
               return -1;
               }

        EVP_MD_CTX_init(&ctx);
 
        /* Convert signature OID into digest and public key OIDs */
		{
		if (!pkey->ameth || !pkey->ameth->item_verify)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);
			goto err;
			}
		ret = pkey->ameth->item_verify(&ctx, it, asn, a,
							signature, pkey);
		/* Return value of 2 means carry on, anything else means we
		 * exit straight away: either a fatal error of the underlying
		 * verification routine handles all verification.
		 */
		if (ret != 2)
			goto err;
		ret = -1;
		}
	else
		{
		const EVP_MD *type;
		type=EVP_get_digestbynid(mdnid);
		if (type == NULL)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);
			goto err;
			}

		/* Check public key OID matches public key type */
		if (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);
			goto err;
			}

		if (!EVP_DigestVerifyInit(&ctx, NULL, type, NULL, pkey))
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
			ret=0;
			goto err;
			}

		}

	inl = ASN1_item_i2d(asn, &buf_in, it);
	
	if (buf_in == NULL)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);
		goto err;
		}

	if (!EVP_DigestVerifyUpdate(&ctx,buf_in,inl))
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}

	OPENSSL_cleanse(buf_in,(unsigned int)inl);
	OPENSSL_free(buf_in);

	if (EVP_DigestVerifyFinal(&ctx,signature->data,
			(size_t)signature->length) <= 0)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}
	/* we don't need to zero the 'ctx' because we just checked
	 * public information */
	/* memset(&ctx,0,sizeof(ctx)); */
	ret=1;
err:
	EVP_MD_CTX_cleanup(&ctx);
	return(ret);
	}
","int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,
		ASN1_BIT_STRING *signature, void *asn, EVP_PKEY *pkey)
	{
	EVP_MD_CTX ctx;
	unsigned char *buf_in=NULL;
	int ret= -1,inl;
 
        int mdnid, pknid;
 
        EVP_MD_CTX_init(&ctx);
 
        /* Convert signature OID into digest and public key OIDs */
		{
		if (!pkey->ameth || !pkey->ameth->item_verify)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);
			goto err;
			}
		ret = pkey->ameth->item_verify(&ctx, it, asn, a,
							signature, pkey);
		/* Return value of 2 means carry on, anything else means we
		 * exit straight away: either a fatal error of the underlying
		 * verification routine handles all verification.
		 */
		if (ret != 2)
			goto err;
		ret = -1;
		}
	else
		{
		const EVP_MD *type;
		type=EVP_get_digestbynid(mdnid);
		if (type == NULL)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);
			goto err;
			}

		/* Check public key OID matches public key type */
		if (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);
			goto err;
			}

		if (!EVP_DigestVerifyInit(&ctx, NULL, type, NULL, pkey))
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
			ret=0;
			goto err;
			}

		}

	inl = ASN1_item_i2d(asn, &buf_in, it);
	
	if (buf_in == NULL)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);
		goto err;
		}

	if (!EVP_DigestVerifyUpdate(&ctx,buf_in,inl))
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}

	OPENSSL_cleanse(buf_in,(unsigned int)inl);
	OPENSSL_free(buf_in);

	if (EVP_DigestVerifyFinal(&ctx,signature->data,
			(size_t)signature->length) <= 0)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}
	/* we don't need to zero the 'ctx' because we just checked
	 * public information */
	/* memset(&ctx,0,sizeof(ctx)); */
	ret=1;
err:
	EVP_MD_CTX_cleanup(&ctx);
	return(ret);
	}
",C,"       if (!pkey)
               {
               ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);
               return -1;
               }

",,014265eb02e26f35c8db58e2ccbf100b0b2f0072,"@@ -140,6 +140,12 @@ int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,
 
        int mdnid, pknid;
 
+       if (!pkey)
+               {
+               ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);
+               return -1;
+               }
+
        EVP_MD_CTX_init(&ctx);
 
        /* Convert signature OID into digest and public key OIDs */",openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/asn1/a_verify.c;h=fc84cd3d191bcec17bc4553eaeb0ef963cc540b4;hb=62e4506a7d4cec1c8e1ff687f6b220f6a62a57c7,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/asn1/a_verify.c;h=432722e4099e6d9ecdc73646e8b931826705b69d,1,"int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,
		ASN1_BIT_STRING *signature, void *asn, EVP_PKEY *pkey)
	{
	EVP_MD_CTX ctx;
	unsigned char *buf_in=NULL;
	int ret= -1,inl;
 
        int mdnid, pknid;
 
//fix_flaw_line_below:
//       if (!pkey)
//fix_flaw_line_below:
//               {
//fix_flaw_line_below:
//               ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);
//fix_flaw_line_below:
//               return -1;
//fix_flaw_line_below:
//               }
//fix_flaw_line_below:
//
        EVP_MD_CTX_init(&ctx);
 
        /* Convert signature OID into digest and public key OIDs */
		{
		if (!pkey->ameth || !pkey->ameth->item_verify)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);
			goto err;
			}
		ret = pkey->ameth->item_verify(&ctx, it, asn, a,
							signature, pkey);
		/* Return value of 2 means carry on, anything else means we
		 * exit straight away: either a fatal error of the underlying
		 * verification routine handles all verification.
		 */
		if (ret != 2)
			goto err;
		ret = -1;
		}
	else
		{
		const EVP_MD *type;
		type=EVP_get_digestbynid(mdnid);
		if (type == NULL)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);
			goto err;
			}

		/* Check public key OID matches public key type */
		if (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);
			goto err;
			}

		if (!EVP_DigestVerifyInit(&ctx, NULL, type, NULL, pkey))
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
			ret=0;
			goto err;
			}

		}

	inl = ASN1_item_i2d(asn, &buf_in, it);
	
	if (buf_in == NULL)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);
		goto err;
		}

	if (!EVP_DigestVerifyUpdate(&ctx,buf_in,inl))
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}

	OPENSSL_cleanse(buf_in,(unsigned int)inl);
	OPENSSL_free(buf_in);

	if (EVP_DigestVerifyFinal(&ctx,signature->data,
			(size_t)signature->length) <= 0)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}
	/* we don't need to zero the 'ctx' because we just checked
	 * public information */
	/* memset(&ctx,0,sizeof(ctx)); */
	ret=1;
err:
	EVP_MD_CTX_cleanup(&ctx);
	return(ret);
	}
"
228,177964,,Remote,Not required,Partial,CVE-2013-0166,https://www.cvedetails.com/cve/CVE-2013-0166/,CWE-310,Low,,,,2013-02-08,5.0,"OpenSSL before 0.9.8y, 1.0.0 before 1.0.0k, and 1.0.1 before 1.0.1d does not properly perform signature verification for OCSP responses, which allows remote OCSP servers to cause a denial of service (NULL pointer dereference and application crash) via an invalid key.",2018-08-08,DoS,6,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=66e8211c0b1347970096e04b18aa52567c325200,66e8211c0b1347970096e04b18aa52567c325200,,0,,,"int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a, ASN1_BIT_STRING *signature,
	     void *asn, EVP_PKEY *pkey)
	{
	EVP_MD_CTX ctx;
	const EVP_MD *type;
        unsigned char *buf_in=NULL;
        int ret= -1,i,inl;
 
       if (!pkey)
               {
               ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);
               return -1;
               }

        EVP_MD_CTX_init(&ctx);
        i=OBJ_obj2nid(a->algorithm);
        type=EVP_get_digestbyname(OBJ_nid2sn(i));
	if (!EVP_VerifyInit_ex(&ctx,type, NULL))
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}

	inl = ASN1_item_i2d(asn, &buf_in, it);
	
	if (buf_in == NULL)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);
		goto err;
		}

	EVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);

	OPENSSL_cleanse(buf_in,(unsigned int)inl);
	OPENSSL_free(buf_in);

	if (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,
			(unsigned int)signature->length,pkey) <= 0)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}
	/* we don't need to zero the 'ctx' because we just checked
	 * public information */
	/* memset(&ctx,0,sizeof(ctx)); */
	ret=1;
err:
	EVP_MD_CTX_cleanup(&ctx);
	return(ret);
	}
","int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a, ASN1_BIT_STRING *signature,
	     void *asn, EVP_PKEY *pkey)
	{
	EVP_MD_CTX ctx;
	const EVP_MD *type;
        unsigned char *buf_in=NULL;
        int ret= -1,i,inl;
 
        EVP_MD_CTX_init(&ctx);
        i=OBJ_obj2nid(a->algorithm);
        type=EVP_get_digestbyname(OBJ_nid2sn(i));
	if (!EVP_VerifyInit_ex(&ctx,type, NULL))
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}

	inl = ASN1_item_i2d(asn, &buf_in, it);
	
	if (buf_in == NULL)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);
		goto err;
		}

	EVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);

	OPENSSL_cleanse(buf_in,(unsigned int)inl);
	OPENSSL_free(buf_in);

	if (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,
			(unsigned int)signature->length,pkey) <= 0)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}
	/* we don't need to zero the 'ctx' because we just checked
	 * public information */
	/* memset(&ctx,0,sizeof(ctx)); */
	ret=1;
err:
	EVP_MD_CTX_cleanup(&ctx);
	return(ret);
	}
",C,"       if (!pkey)
               {
               ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);
               return -1;
               }

",,dd2dee60f343a28cd93e065c7dae7619885515ff,"@@ -138,6 +138,12 @@ int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a, ASN1_BIT_STRING *signat
        unsigned char *buf_in=NULL;
        int ret= -1,i,inl;
 
+       if (!pkey)
+               {
+               ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);
+               return -1;
+               }
+
        EVP_MD_CTX_init(&ctx);
        i=OBJ_obj2nid(a->algorithm);
        type=EVP_get_digestbyname(OBJ_nid2sn(i));",openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/asn1/a_verify.c;h=7ded69b170f665825ee1d58135c12862c756f5f2;hb=66e8211c0b1347970096e04b18aa52567c325200,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/asn1/a_verify.c;h=da3efaaf8de524d0aea44ed505182109076a164f,1,"int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a, ASN1_BIT_STRING *signature,
	     void *asn, EVP_PKEY *pkey)
	{
	EVP_MD_CTX ctx;
	const EVP_MD *type;
        unsigned char *buf_in=NULL;
        int ret= -1,i,inl;
 
//fix_flaw_line_below:
//       if (!pkey)
//fix_flaw_line_below:
//               {
//fix_flaw_line_below:
//               ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);
//fix_flaw_line_below:
//               return -1;
//fix_flaw_line_below:
//               }
//fix_flaw_line_below:
//
        EVP_MD_CTX_init(&ctx);
        i=OBJ_obj2nid(a->algorithm);
        type=EVP_get_digestbyname(OBJ_nid2sn(i));
	if (!EVP_VerifyInit_ex(&ctx,type, NULL))
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}

	inl = ASN1_item_i2d(asn, &buf_in, it);
	
	if (buf_in == NULL)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);
		goto err;
		}

	EVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);

	OPENSSL_cleanse(buf_in,(unsigned int)inl);
	OPENSSL_free(buf_in);

	if (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,
			(unsigned int)signature->length,pkey) <= 0)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}
	/* we don't need to zero the 'ctx' because we just checked
	 * public information */
	/* memset(&ctx,0,sizeof(ctx)); */
	ret=1;
err:
	EVP_MD_CTX_cleanup(&ctx);
	return(ret);
	}
"
229,177965,,Remote,Not required,Partial,CVE-2013-0166,https://www.cvedetails.com/cve/CVE-2013-0166/,CWE-310,Low,,,,2013-02-08,5.0,"OpenSSL before 0.9.8y, 1.0.0 before 1.0.0k, and 1.0.1 before 1.0.1d does not properly perform signature verification for OCSP responses, which allows remote OCSP servers to cause a denial of service (NULL pointer dereference and application crash) via an invalid key.",2018-08-08,DoS,6,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=ebc71865f0506a293242bd4aec97cdc7a8ef24b0,ebc71865f0506a293242bd4aec97cdc7a8ef24b0,,0,,,"int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a, ASN1_BIT_STRING *signature,
	     void *asn, EVP_PKEY *pkey)
	{
	EVP_MD_CTX ctx;
	const EVP_MD *type = NULL;
	unsigned char *buf_in=NULL;
	int ret= -1,inl;
 
        int mdnid, pknid;
 
       if (!pkey)
               {
               ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);
               return -1;
               }

        EVP_MD_CTX_init(&ctx);
 
        /* Convert signature OID into digest and public key OIDs */
	if (type == NULL)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);
		goto err;
		}

	/* Check public key OID matches public key type */
	if (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);
		goto err;
		}

	if (!EVP_VerifyInit_ex(&ctx,type, NULL))
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}

	inl = ASN1_item_i2d(asn, &buf_in, it);
	
	if (buf_in == NULL)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);
		goto err;
		}

	EVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);

	OPENSSL_cleanse(buf_in,(unsigned int)inl);
	OPENSSL_free(buf_in);

	if (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,
			(unsigned int)signature->length,pkey) <= 0)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}
	/* we don't need to zero the 'ctx' because we just checked
	 * public information */
	/* memset(&ctx,0,sizeof(ctx)); */
	ret=1;
err:
	EVP_MD_CTX_cleanup(&ctx);
	return(ret);
	}
","int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a, ASN1_BIT_STRING *signature,
	     void *asn, EVP_PKEY *pkey)
	{
	EVP_MD_CTX ctx;
	const EVP_MD *type = NULL;
	unsigned char *buf_in=NULL;
	int ret= -1,inl;
 
        int mdnid, pknid;
 
        EVP_MD_CTX_init(&ctx);
 
        /* Convert signature OID into digest and public key OIDs */
	if (type == NULL)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);
		goto err;
		}

	/* Check public key OID matches public key type */
	if (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);
		goto err;
		}

	if (!EVP_VerifyInit_ex(&ctx,type, NULL))
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}

	inl = ASN1_item_i2d(asn, &buf_in, it);
	
	if (buf_in == NULL)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);
		goto err;
		}

	EVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);

	OPENSSL_cleanse(buf_in,(unsigned int)inl);
	OPENSSL_free(buf_in);

	if (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,
			(unsigned int)signature->length,pkey) <= 0)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}
	/* we don't need to zero the 'ctx' because we just checked
	 * public information */
	/* memset(&ctx,0,sizeof(ctx)); */
	ret=1;
err:
	EVP_MD_CTX_cleanup(&ctx);
	return(ret);
	}
",C,"       if (!pkey)
               {
               ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);
               return -1;
               }

",,1dfa62d4c871a9007904812e06bdddb2d530ff64,"@@ -136,6 +136,12 @@ int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a, ASN1_BIT_STRING *signat
 
        int mdnid, pknid;
 
+       if (!pkey)
+               {
+               ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);
+               return -1;
+               }
+
        EVP_MD_CTX_init(&ctx);
 
        /* Convert signature OID into digest and public key OIDs */",openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/asn1/a_verify.c;h=097ec813ac24dbb42956a037ab5ecaab8fa3f995;hb=ebc71865f0506a293242bd4aec97cdc7a8ef24b0,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/asn1/a_verify.c;h=cecdb13c70901ab77367c563a1000dcaecaf0cff,1,"int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a, ASN1_BIT_STRING *signature,
	     void *asn, EVP_PKEY *pkey)
	{
	EVP_MD_CTX ctx;
	const EVP_MD *type = NULL;
	unsigned char *buf_in=NULL;
	int ret= -1,inl;
 
        int mdnid, pknid;
 
//fix_flaw_line_below:
//       if (!pkey)
//fix_flaw_line_below:
//               {
//fix_flaw_line_below:
//               ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);
//fix_flaw_line_below:
//               return -1;
//fix_flaw_line_below:
//               }
//fix_flaw_line_below:
//
        EVP_MD_CTX_init(&ctx);
 
        /* Convert signature OID into digest and public key OIDs */
	if (type == NULL)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);
		goto err;
		}

	/* Check public key OID matches public key type */
	if (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);
		goto err;
		}

	if (!EVP_VerifyInit_ex(&ctx,type, NULL))
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}

	inl = ASN1_item_i2d(asn, &buf_in, it);
	
	if (buf_in == NULL)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);
		goto err;
		}

	EVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);

	OPENSSL_cleanse(buf_in,(unsigned int)inl);
	OPENSSL_free(buf_in);

	if (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,
			(unsigned int)signature->length,pkey) <= 0)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}
	/* we don't need to zero the 'ctx' because we just checked
	 * public information */
	/* memset(&ctx,0,sizeof(ctx)); */
	ret=1;
err:
	EVP_MD_CTX_cleanup(&ctx);
	return(ret);
	}
"
248,177984,,Remote,Not required,,CVE-2015-0285,https://www.cvedetails.com/cve/CVE-2015-0285/,CWE-310,Medium,Partial,,,2015-03-19,4.3,"The ssl3_client_hello function in s3_clnt.c in OpenSSL 1.0.2 before 1.0.2a does not ensure that the PRNG is seeded before proceeding with a handshake, which makes it easier for remote attackers to defeat cryptographic protection mechanisms by sniffing the network and then conducting a brute-force attack.",2018-11-29,,3,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=e1b568dd2462f7cacf98f3d117936c34e2849a6b,e1b568dd2462f7cacf98f3d117936c34e2849a6b,,2,,,"int ssl3_client_hello(SSL *s)
{
    unsigned char *buf;
    unsigned char *p, *d;
    int i;
    unsigned long l;
    int al = 0;
#ifndef OPENSSL_NO_COMP
    int j;
    SSL_COMP *comp;
#endif

    buf = (unsigned char *)s->init_buf->data;
    if (s->state == SSL3_ST_CW_CLNT_HELLO_A) {
        SSL_SESSION *sess = s->session;
        if ((sess == NULL) ||
            (sess->ssl_version != s->version) ||
            !sess->session_id_length || (sess->not_resumable)) {
            if (!ssl_get_new_session(s, 0))
                goto err;
        }
        if (s->method->version == DTLS_ANY_VERSION) {
            /* Determine which DTLS version to use */
            int options = s->options;
            /* If DTLS 1.2 disabled correct the version number */
            if (options & SSL_OP_NO_DTLSv1_2) {
                if (tls1_suiteb(s)) {
                    SSLerr(SSL_F_SSL3_CLIENT_HELLO,
                           SSL_R_ONLY_DTLS_1_2_ALLOWED_IN_SUITEB_MODE);
                    goto err;
                }
                /*
                 * Disabling all versions is silly: return an error.
                 */
                if (options & SSL_OP_NO_DTLSv1) {
                    SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_WRONG_SSL_VERSION);
                    goto err;
                }
                /*
                 * Update method so we don't use any DTLS 1.2 features.
                 */
                s->method = DTLSv1_client_method();
                s->version = DTLS1_VERSION;
            } else {
                /*
                 * We only support one version: update method
                 */
                if (options & SSL_OP_NO_DTLSv1)
                    s->method = DTLSv1_2_client_method();
                s->version = DTLS1_2_VERSION;
            }
            s->client_version = s->version;
        }
        /* else use the pre-loaded session */

        p = s->s3->client_random;

        /*
         * for DTLS if client_random is initialized, reuse it, we are
         * required to use same upon reply to HelloVerify
         */
        if (SSL_IS_DTLS(s)) {
            size_t idx;
            i = 1;
            for (idx = 0; idx < sizeof(s->s3->client_random); idx++) {
                if (p[idx]) {
                    i = 0;
                    break;
                }
            }
         } else
             i = 1;
 
        if (i && ssl_fill_hello_random(s, 0, p,
                                       sizeof(s->s3->client_random)) <= 0)
            goto err;
 
         /* Do the message type and length last */
         d = p = ssl_handshake_start(s);
        /*-
         * version indicates the negotiated version: for example from
         * an SSLv2/v3 compatible client hello). The client_version
         * field is the maximum version we permit and it is also
         * used in RSA encrypted premaster secrets. Some servers can
         * choke if we initially report a higher version then
         * renegotiate to a lower one in the premaster secret. This
         * didn't happen with TLS 1.0 as most servers supported it
         * but it can with TLS 1.1 or later if the server only supports
         * 1.0.
         *
         * Possible scenario with previous logic:
         *      1. Client hello indicates TLS 1.2
         *      2. Server hello says TLS 1.0
         *      3. RSA encrypted premaster secret uses 1.2.
         *      4. Handhaked proceeds using TLS 1.0.
         *      5. Server sends hello request to renegotiate.
         *      6. Client hello indicates TLS v1.0 as we now
         *         know that is maximum server supports.
         *      7. Server chokes on RSA encrypted premaster secret
         *         containing version 1.0.
         *
         * For interoperability it should be OK to always use the
         * maximum version we support in client hello and then rely
         * on the checking of version to ensure the servers isn't
         * being inconsistent: for example initially negotiating with
         * TLS 1.0 and renegotiating with TLS 1.2. We do this by using
         * client_version in client hello and not resetting it to
         * the negotiated version.
         */
        *(p++) = s->client_version >> 8;
        *(p++) = s->client_version & 0xff;

        /* Random stuff */
        memcpy(p, s->s3->client_random, SSL3_RANDOM_SIZE);
        p += SSL3_RANDOM_SIZE;

        /* Session ID */
        if (s->new_session)
            i = 0;
        else
            i = s->session->session_id_length;
        *(p++) = i;
        if (i != 0) {
            if (i > (int)sizeof(s->session->session_id)) {
                SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
                goto err;
            }
            memcpy(p, s->session->session_id, i);
            p += i;
        }

        /* cookie stuff for DTLS */
        if (SSL_IS_DTLS(s)) {
            if (s->d1->cookie_len > sizeof(s->d1->cookie)) {
                SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
                goto err;
            }
            *(p++) = s->d1->cookie_len;
            memcpy(p, s->d1->cookie, s->d1->cookie_len);
            p += s->d1->cookie_len;
        }

        /* Ciphers supported */
        i = ssl_cipher_list_to_bytes(s, SSL_get_ciphers(s), &(p[2]), 0);
        if (i == 0) {
            SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_NO_CIPHERS_AVAILABLE);
            goto err;
        }
#ifdef OPENSSL_MAX_TLS1_2_CIPHER_LENGTH
        /*
         * Some servers hang if client hello > 256 bytes as hack workaround
         * chop number of supported ciphers to keep it well below this if we
         * use TLS v1.2
         */
        if (TLS1_get_version(s) >= TLS1_2_VERSION
            && i > OPENSSL_MAX_TLS1_2_CIPHER_LENGTH)
            i = OPENSSL_MAX_TLS1_2_CIPHER_LENGTH & ~1;
#endif
        s2n(i, p);
        p += i;

        /* COMPRESSION */
#ifdef OPENSSL_NO_COMP
        *(p++) = 1;
#else

        if (!ssl_allow_compression(s) || !s->ctx->comp_methods)
            j = 0;
        else
            j = sk_SSL_COMP_num(s->ctx->comp_methods);
        *(p++) = 1 + j;
        for (i = 0; i < j; i++) {
            comp = sk_SSL_COMP_value(s->ctx->comp_methods, i);
            *(p++) = comp->id;
        }
#endif
        *(p++) = 0;             /* Add the NULL method */

#ifndef OPENSSL_NO_TLSEXT
        /* TLS extensions */
        if (ssl_prepare_clienthello_tlsext(s) <= 0) {
            SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);
            goto err;
        }
        if ((p =
             ssl_add_clienthello_tlsext(s, p, buf + SSL3_RT_MAX_PLAIN_LENGTH,
                                        &al)) == NULL) {
            ssl3_send_alert(s, SSL3_AL_FATAL, al);
            SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
            goto err;
        }
#endif

        l = p - d;
        ssl_set_handshake_header(s, SSL3_MT_CLIENT_HELLO, l);
        s->state = SSL3_ST_CW_CLNT_HELLO_B;
    }

    /* SSL3_ST_CW_CLNT_HELLO_B */
    return ssl_do_write(s);
 err:
    return (-1);
}
","int ssl3_client_hello(SSL *s)
{
    unsigned char *buf;
    unsigned char *p, *d;
    int i;
    unsigned long l;
    int al = 0;
#ifndef OPENSSL_NO_COMP
    int j;
    SSL_COMP *comp;
#endif

    buf = (unsigned char *)s->init_buf->data;
    if (s->state == SSL3_ST_CW_CLNT_HELLO_A) {
        SSL_SESSION *sess = s->session;
        if ((sess == NULL) ||
            (sess->ssl_version != s->version) ||
            !sess->session_id_length || (sess->not_resumable)) {
            if (!ssl_get_new_session(s, 0))
                goto err;
        }
        if (s->method->version == DTLS_ANY_VERSION) {
            /* Determine which DTLS version to use */
            int options = s->options;
            /* If DTLS 1.2 disabled correct the version number */
            if (options & SSL_OP_NO_DTLSv1_2) {
                if (tls1_suiteb(s)) {
                    SSLerr(SSL_F_SSL3_CLIENT_HELLO,
                           SSL_R_ONLY_DTLS_1_2_ALLOWED_IN_SUITEB_MODE);
                    goto err;
                }
                /*
                 * Disabling all versions is silly: return an error.
                 */
                if (options & SSL_OP_NO_DTLSv1) {
                    SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_WRONG_SSL_VERSION);
                    goto err;
                }
                /*
                 * Update method so we don't use any DTLS 1.2 features.
                 */
                s->method = DTLSv1_client_method();
                s->version = DTLS1_VERSION;
            } else {
                /*
                 * We only support one version: update method
                 */
                if (options & SSL_OP_NO_DTLSv1)
                    s->method = DTLSv1_2_client_method();
                s->version = DTLS1_2_VERSION;
            }
            s->client_version = s->version;
        }
        /* else use the pre-loaded session */

        p = s->s3->client_random;

        /*
         * for DTLS if client_random is initialized, reuse it, we are
         * required to use same upon reply to HelloVerify
         */
        if (SSL_IS_DTLS(s)) {
            size_t idx;
            i = 1;
            for (idx = 0; idx < sizeof(s->s3->client_random); idx++) {
                if (p[idx]) {
                    i = 0;
                    break;
                }
            }
         } else
             i = 1;
 
        if (i)
            ssl_fill_hello_random(s, 0, p, sizeof(s->s3->client_random));
 
         /* Do the message type and length last */
         d = p = ssl_handshake_start(s);
        /*-
         * version indicates the negotiated version: for example from
         * an SSLv2/v3 compatible client hello). The client_version
         * field is the maximum version we permit and it is also
         * used in RSA encrypted premaster secrets. Some servers can
         * choke if we initially report a higher version then
         * renegotiate to a lower one in the premaster secret. This
         * didn't happen with TLS 1.0 as most servers supported it
         * but it can with TLS 1.1 or later if the server only supports
         * 1.0.
         *
         * Possible scenario with previous logic:
         *      1. Client hello indicates TLS 1.2
         *      2. Server hello says TLS 1.0
         *      3. RSA encrypted premaster secret uses 1.2.
         *      4. Handhaked proceeds using TLS 1.0.
         *      5. Server sends hello request to renegotiate.
         *      6. Client hello indicates TLS v1.0 as we now
         *         know that is maximum server supports.
         *      7. Server chokes on RSA encrypted premaster secret
         *         containing version 1.0.
         *
         * For interoperability it should be OK to always use the
         * maximum version we support in client hello and then rely
         * on the checking of version to ensure the servers isn't
         * being inconsistent: for example initially negotiating with
         * TLS 1.0 and renegotiating with TLS 1.2. We do this by using
         * client_version in client hello and not resetting it to
         * the negotiated version.
         */
        *(p++) = s->client_version >> 8;
        *(p++) = s->client_version & 0xff;

        /* Random stuff */
        memcpy(p, s->s3->client_random, SSL3_RANDOM_SIZE);
        p += SSL3_RANDOM_SIZE;

        /* Session ID */
        if (s->new_session)
            i = 0;
        else
            i = s->session->session_id_length;
        *(p++) = i;
        if (i != 0) {
            if (i > (int)sizeof(s->session->session_id)) {
                SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
                goto err;
            }
            memcpy(p, s->session->session_id, i);
            p += i;
        }

        /* cookie stuff for DTLS */
        if (SSL_IS_DTLS(s)) {
            if (s->d1->cookie_len > sizeof(s->d1->cookie)) {
                SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
                goto err;
            }
            *(p++) = s->d1->cookie_len;
            memcpy(p, s->d1->cookie, s->d1->cookie_len);
            p += s->d1->cookie_len;
        }

        /* Ciphers supported */
        i = ssl_cipher_list_to_bytes(s, SSL_get_ciphers(s), &(p[2]), 0);
        if (i == 0) {
            SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_NO_CIPHERS_AVAILABLE);
            goto err;
        }
#ifdef OPENSSL_MAX_TLS1_2_CIPHER_LENGTH
        /*
         * Some servers hang if client hello > 256 bytes as hack workaround
         * chop number of supported ciphers to keep it well below this if we
         * use TLS v1.2
         */
        if (TLS1_get_version(s) >= TLS1_2_VERSION
            && i > OPENSSL_MAX_TLS1_2_CIPHER_LENGTH)
            i = OPENSSL_MAX_TLS1_2_CIPHER_LENGTH & ~1;
#endif
        s2n(i, p);
        p += i;

        /* COMPRESSION */
#ifdef OPENSSL_NO_COMP
        *(p++) = 1;
#else

        if (!ssl_allow_compression(s) || !s->ctx->comp_methods)
            j = 0;
        else
            j = sk_SSL_COMP_num(s->ctx->comp_methods);
        *(p++) = 1 + j;
        for (i = 0; i < j; i++) {
            comp = sk_SSL_COMP_value(s->ctx->comp_methods, i);
            *(p++) = comp->id;
        }
#endif
        *(p++) = 0;             /* Add the NULL method */

#ifndef OPENSSL_NO_TLSEXT
        /* TLS extensions */
        if (ssl_prepare_clienthello_tlsext(s) <= 0) {
            SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);
            goto err;
        }
        if ((p =
             ssl_add_clienthello_tlsext(s, p, buf + SSL3_RT_MAX_PLAIN_LENGTH,
                                        &al)) == NULL) {
            ssl3_send_alert(s, SSL3_AL_FATAL, al);
            SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
            goto err;
        }
#endif

        l = p - d;
        ssl_set_handshake_header(s, SSL3_MT_CLIENT_HELLO, l);
        s->state = SSL3_ST_CW_CLNT_HELLO_B;
    }

    /* SSL3_ST_CW_CLNT_HELLO_B */
    return ssl_do_write(s);
 err:
    return (-1);
}
",C,"        if (i && ssl_fill_hello_random(s, 0, p,
                                       sizeof(s->s3->client_random)) <= 0)
            goto err;
","        if (i)
            ssl_fill_hello_random(s, 0, p, sizeof(s->s3->client_random));
",0b142f022e2c5072295e00ebc11c5b707a726d74,"@@ -719,8 +719,9 @@ int ssl3_client_hello(SSL *s)
         } else
             i = 1;
 
-        if (i)
-            ssl_fill_hello_random(s, 0, p, sizeof(s->s3->client_random));
+        if (i && ssl_fill_hello_random(s, 0, p,
+                                       sizeof(s->s3->client_random)) <= 0)
+            goto err;
 
         /* Do the message type and length last */
         d = p = ssl_handshake_start(s);",openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=ssl/s3_clnt.c;h=750217fff6af064615e8c193523123c2388026fe;hb=750217fff6af064615e8c193523123c2388026fe,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=ssl/s3_clnt.c;h=1e437b2e1e9abb36657fc5f73ca0a7567ebccc7f;hb=1e437b2e1e9abb36657fc5f73ca0a7567ebccc7f,1,"int ssl3_client_hello(SSL *s)
{
    unsigned char *buf;
    unsigned char *p, *d;
    int i;
    unsigned long l;
    int al = 0;
#ifndef OPENSSL_NO_COMP
    int j;
    SSL_COMP *comp;
#endif

    buf = (unsigned char *)s->init_buf->data;
    if (s->state == SSL3_ST_CW_CLNT_HELLO_A) {
        SSL_SESSION *sess = s->session;
        if ((sess == NULL) ||
            (sess->ssl_version != s->version) ||
            !sess->session_id_length || (sess->not_resumable)) {
            if (!ssl_get_new_session(s, 0))
                goto err;
        }
        if (s->method->version == DTLS_ANY_VERSION) {
            /* Determine which DTLS version to use */
            int options = s->options;
            /* If DTLS 1.2 disabled correct the version number */
            if (options & SSL_OP_NO_DTLSv1_2) {
                if (tls1_suiteb(s)) {
                    SSLerr(SSL_F_SSL3_CLIENT_HELLO,
                           SSL_R_ONLY_DTLS_1_2_ALLOWED_IN_SUITEB_MODE);
                    goto err;
                }
                /*
                 * Disabling all versions is silly: return an error.
                 */
                if (options & SSL_OP_NO_DTLSv1) {
                    SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_WRONG_SSL_VERSION);
                    goto err;
                }
                /*
                 * Update method so we don't use any DTLS 1.2 features.
                 */
                s->method = DTLSv1_client_method();
                s->version = DTLS1_VERSION;
            } else {
                /*
                 * We only support one version: update method
                 */
                if (options & SSL_OP_NO_DTLSv1)
                    s->method = DTLSv1_2_client_method();
                s->version = DTLS1_2_VERSION;
            }
            s->client_version = s->version;
        }
        /* else use the pre-loaded session */

        p = s->s3->client_random;

        /*
         * for DTLS if client_random is initialized, reuse it, we are
         * required to use same upon reply to HelloVerify
         */
        if (SSL_IS_DTLS(s)) {
            size_t idx;
            i = 1;
            for (idx = 0; idx < sizeof(s->s3->client_random); idx++) {
                if (p[idx]) {
                    i = 0;
                    break;
                }
            }
         } else
             i = 1;
 
//flaw_line_below:
        if (i)
//flaw_line_below:
            ssl_fill_hello_random(s, 0, p, sizeof(s->s3->client_random));
//fix_flaw_line_below:
//        if (i && ssl_fill_hello_random(s, 0, p,
//fix_flaw_line_below:
//                                       sizeof(s->s3->client_random)) <= 0)
//fix_flaw_line_below:
//            goto err;
 
         /* Do the message type and length last */
         d = p = ssl_handshake_start(s);
        /*-
         * version indicates the negotiated version: for example from
         * an SSLv2/v3 compatible client hello). The client_version
         * field is the maximum version we permit and it is also
         * used in RSA encrypted premaster secrets. Some servers can
         * choke if we initially report a higher version then
         * renegotiate to a lower one in the premaster secret. This
         * didn't happen with TLS 1.0 as most servers supported it
         * but it can with TLS 1.1 or later if the server only supports
         * 1.0.
         *
         * Possible scenario with previous logic:
         *      1. Client hello indicates TLS 1.2
         *      2. Server hello says TLS 1.0
         *      3. RSA encrypted premaster secret uses 1.2.
         *      4. Handhaked proceeds using TLS 1.0.
         *      5. Server sends hello request to renegotiate.
         *      6. Client hello indicates TLS v1.0 as we now
         *         know that is maximum server supports.
         *      7. Server chokes on RSA encrypted premaster secret
         *         containing version 1.0.
         *
         * For interoperability it should be OK to always use the
         * maximum version we support in client hello and then rely
         * on the checking of version to ensure the servers isn't
         * being inconsistent: for example initially negotiating with
         * TLS 1.0 and renegotiating with TLS 1.2. We do this by using
         * client_version in client hello and not resetting it to
         * the negotiated version.
         */
        *(p++) = s->client_version >> 8;
        *(p++) = s->client_version & 0xff;

        /* Random stuff */
        memcpy(p, s->s3->client_random, SSL3_RANDOM_SIZE);
        p += SSL3_RANDOM_SIZE;

        /* Session ID */
        if (s->new_session)
            i = 0;
        else
            i = s->session->session_id_length;
        *(p++) = i;
        if (i != 0) {
            if (i > (int)sizeof(s->session->session_id)) {
                SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
                goto err;
            }
            memcpy(p, s->session->session_id, i);
            p += i;
        }

        /* cookie stuff for DTLS */
        if (SSL_IS_DTLS(s)) {
            if (s->d1->cookie_len > sizeof(s->d1->cookie)) {
                SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
                goto err;
            }
            *(p++) = s->d1->cookie_len;
            memcpy(p, s->d1->cookie, s->d1->cookie_len);
            p += s->d1->cookie_len;
        }

        /* Ciphers supported */
        i = ssl_cipher_list_to_bytes(s, SSL_get_ciphers(s), &(p[2]), 0);
        if (i == 0) {
            SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_NO_CIPHERS_AVAILABLE);
            goto err;
        }
#ifdef OPENSSL_MAX_TLS1_2_CIPHER_LENGTH
        /*
         * Some servers hang if client hello > 256 bytes as hack workaround
         * chop number of supported ciphers to keep it well below this if we
         * use TLS v1.2
         */
        if (TLS1_get_version(s) >= TLS1_2_VERSION
            && i > OPENSSL_MAX_TLS1_2_CIPHER_LENGTH)
            i = OPENSSL_MAX_TLS1_2_CIPHER_LENGTH & ~1;
#endif
        s2n(i, p);
        p += i;

        /* COMPRESSION */
#ifdef OPENSSL_NO_COMP
        *(p++) = 1;
#else

        if (!ssl_allow_compression(s) || !s->ctx->comp_methods)
            j = 0;
        else
            j = sk_SSL_COMP_num(s->ctx->comp_methods);
        *(p++) = 1 + j;
        for (i = 0; i < j; i++) {
            comp = sk_SSL_COMP_value(s->ctx->comp_methods, i);
            *(p++) = comp->id;
        }
#endif
        *(p++) = 0;             /* Add the NULL method */

#ifndef OPENSSL_NO_TLSEXT
        /* TLS extensions */
        if (ssl_prepare_clienthello_tlsext(s) <= 0) {
            SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);
            goto err;
        }
        if ((p =
             ssl_add_clienthello_tlsext(s, p, buf + SSL3_RT_MAX_PLAIN_LENGTH,
                                        &al)) == NULL) {
            ssl3_send_alert(s, SSL3_AL_FATAL, al);
            SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
            goto err;
        }
#endif

        l = p - d;
        ssl_set_handshake_header(s, SSL3_MT_CLIENT_HELLO, l);
        s->state = SSL3_ST_CW_CLNT_HELLO_B;
    }

    /* SSL3_ST_CW_CLNT_HELLO_B */
    return ssl_do_write(s);
 err:
    return (-1);
}
"
303,178039,,Remote,Not required,Partial,CVE-2012-2686,https://www.cvedetails.com/cve/CVE-2012-2686/,CWE-310,Low,,,,2013-02-08,5.0,crypto/evp/e_aes_cbc_hmac_sha1.c in the AES-NI functionality in the TLS 1.1 and 1.2 implementations in OpenSSL 1.0.1 before 1.0.1d allows remote attackers to cause a denial of service (application crash) via crafted CBC data.,2018-08-08,DoS,0,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=125093b59f3c2a2d33785b5563d929d0472f1721,125093b59f3c2a2d33785b5563d929d0472f1721,,2,,,"void OpenSSL_add_all_ciphers(void)
	{

#ifndef OPENSSL_NO_DES
	EVP_add_cipher(EVP_des_cfb());
	EVP_add_cipher(EVP_des_cfb1());
	EVP_add_cipher(EVP_des_cfb8());
	EVP_add_cipher(EVP_des_ede_cfb());
	EVP_add_cipher(EVP_des_ede3_cfb());
	EVP_add_cipher(EVP_des_ede3_cfb1());
	EVP_add_cipher(EVP_des_ede3_cfb8());

	EVP_add_cipher(EVP_des_ofb());
	EVP_add_cipher(EVP_des_ede_ofb());
	EVP_add_cipher(EVP_des_ede3_ofb());

	EVP_add_cipher(EVP_desx_cbc());
	EVP_add_cipher_alias(SN_desx_cbc,""DESX"");
	EVP_add_cipher_alias(SN_desx_cbc,""desx"");

	EVP_add_cipher(EVP_des_cbc());
	EVP_add_cipher_alias(SN_des_cbc,""DES"");
	EVP_add_cipher_alias(SN_des_cbc,""des"");
	EVP_add_cipher(EVP_des_ede_cbc());
	EVP_add_cipher(EVP_des_ede3_cbc());
	EVP_add_cipher_alias(SN_des_ede3_cbc,""DES3"");
	EVP_add_cipher_alias(SN_des_ede3_cbc,""des3"");

	EVP_add_cipher(EVP_des_ecb());
	EVP_add_cipher(EVP_des_ede());
	EVP_add_cipher(EVP_des_ede3());
#endif

#ifndef OPENSSL_NO_RC4
	EVP_add_cipher(EVP_rc4());
	EVP_add_cipher(EVP_rc4_40());
#ifndef OPENSSL_NO_MD5
	EVP_add_cipher(EVP_rc4_hmac_md5());
#endif
#endif

#ifndef OPENSSL_NO_IDEA
	EVP_add_cipher(EVP_idea_ecb());
	EVP_add_cipher(EVP_idea_cfb());
	EVP_add_cipher(EVP_idea_ofb());
	EVP_add_cipher(EVP_idea_cbc());
	EVP_add_cipher_alias(SN_idea_cbc,""IDEA"");
	EVP_add_cipher_alias(SN_idea_cbc,""idea"");
#endif

#ifndef OPENSSL_NO_SEED
	EVP_add_cipher(EVP_seed_ecb());
	EVP_add_cipher(EVP_seed_cfb());
	EVP_add_cipher(EVP_seed_ofb());
	EVP_add_cipher(EVP_seed_cbc());
	EVP_add_cipher_alias(SN_seed_cbc,""SEED"");
	EVP_add_cipher_alias(SN_seed_cbc,""seed"");
#endif

#ifndef OPENSSL_NO_RC2
	EVP_add_cipher(EVP_rc2_ecb());
	EVP_add_cipher(EVP_rc2_cfb());
	EVP_add_cipher(EVP_rc2_ofb());
	EVP_add_cipher(EVP_rc2_cbc());
	EVP_add_cipher(EVP_rc2_40_cbc());
	EVP_add_cipher(EVP_rc2_64_cbc());
	EVP_add_cipher_alias(SN_rc2_cbc,""RC2"");
	EVP_add_cipher_alias(SN_rc2_cbc,""rc2"");
#endif

#ifndef OPENSSL_NO_BF
	EVP_add_cipher(EVP_bf_ecb());
	EVP_add_cipher(EVP_bf_cfb());
	EVP_add_cipher(EVP_bf_ofb());
	EVP_add_cipher(EVP_bf_cbc());
	EVP_add_cipher_alias(SN_bf_cbc,""BF"");
	EVP_add_cipher_alias(SN_bf_cbc,""bf"");
	EVP_add_cipher_alias(SN_bf_cbc,""blowfish"");
#endif

#ifndef OPENSSL_NO_CAST
	EVP_add_cipher(EVP_cast5_ecb());
	EVP_add_cipher(EVP_cast5_cfb());
	EVP_add_cipher(EVP_cast5_ofb());
	EVP_add_cipher(EVP_cast5_cbc());
	EVP_add_cipher_alias(SN_cast5_cbc,""CAST"");
	EVP_add_cipher_alias(SN_cast5_cbc,""cast"");
	EVP_add_cipher_alias(SN_cast5_cbc,""CAST-cbc"");
	EVP_add_cipher_alias(SN_cast5_cbc,""cast-cbc"");
#endif

#ifndef OPENSSL_NO_RC5
	EVP_add_cipher(EVP_rc5_32_12_16_ecb());
	EVP_add_cipher(EVP_rc5_32_12_16_cfb());
	EVP_add_cipher(EVP_rc5_32_12_16_ofb());
	EVP_add_cipher(EVP_rc5_32_12_16_cbc());
	EVP_add_cipher_alias(SN_rc5_cbc,""rc5"");
	EVP_add_cipher_alias(SN_rc5_cbc,""RC5"");
#endif

#ifndef OPENSSL_NO_AES
	EVP_add_cipher(EVP_aes_128_ecb());
	EVP_add_cipher(EVP_aes_128_cbc());
	EVP_add_cipher(EVP_aes_128_cfb());
	EVP_add_cipher(EVP_aes_128_cfb1());
	EVP_add_cipher(EVP_aes_128_cfb8());
	EVP_add_cipher(EVP_aes_128_ofb());
	EVP_add_cipher(EVP_aes_128_ctr());
	EVP_add_cipher(EVP_aes_128_gcm());
	EVP_add_cipher(EVP_aes_128_xts());
	EVP_add_cipher_alias(SN_aes_128_cbc,""AES128"");
	EVP_add_cipher_alias(SN_aes_128_cbc,""aes128"");
	EVP_add_cipher(EVP_aes_192_ecb());
	EVP_add_cipher(EVP_aes_192_cbc());
	EVP_add_cipher(EVP_aes_192_cfb());
	EVP_add_cipher(EVP_aes_192_cfb1());
	EVP_add_cipher(EVP_aes_192_cfb8());
	EVP_add_cipher(EVP_aes_192_ofb());
	EVP_add_cipher(EVP_aes_192_ctr());
	EVP_add_cipher(EVP_aes_192_gcm());
	EVP_add_cipher_alias(SN_aes_192_cbc,""AES192"");
	EVP_add_cipher_alias(SN_aes_192_cbc,""aes192"");
	EVP_add_cipher(EVP_aes_256_ecb());
	EVP_add_cipher(EVP_aes_256_cbc());
	EVP_add_cipher(EVP_aes_256_cfb());
	EVP_add_cipher(EVP_aes_256_cfb1());
	EVP_add_cipher(EVP_aes_256_cfb8());
	EVP_add_cipher(EVP_aes_256_ofb());
	EVP_add_cipher(EVP_aes_256_ctr());
	EVP_add_cipher(EVP_aes_256_gcm());
        EVP_add_cipher(EVP_aes_256_xts());
        EVP_add_cipher_alias(SN_aes_256_cbc,""AES256"");
        EVP_add_cipher_alias(SN_aes_256_cbc,""aes256"");
 #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)
        EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());
        EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());
 #endif
 #endif
 
 #ifndef OPENSSL_NO_CAMELLIA
        EVP_add_cipher(EVP_camellia_128_ecb());
#ifndef OPENSSL_NO_CAMELLIA
	EVP_add_cipher(EVP_camellia_128_ecb());
	EVP_add_cipher(EVP_camellia_128_cbc());
	EVP_add_cipher(EVP_camellia_128_cfb());
	EVP_add_cipher(EVP_camellia_128_cfb1());
	EVP_add_cipher(EVP_camellia_128_cfb8());
	EVP_add_cipher(EVP_camellia_128_ofb());
	EVP_add_cipher_alias(SN_camellia_128_cbc,""CAMELLIA128"");
	EVP_add_cipher_alias(SN_camellia_128_cbc,""camellia128"");
	EVP_add_cipher(EVP_camellia_192_ecb());
	EVP_add_cipher(EVP_camellia_192_cbc());
	EVP_add_cipher(EVP_camellia_192_cfb());
	EVP_add_cipher(EVP_camellia_192_cfb1());
	EVP_add_cipher(EVP_camellia_192_cfb8());
	EVP_add_cipher(EVP_camellia_192_ofb());
	EVP_add_cipher_alias(SN_camellia_192_cbc,""CAMELLIA192"");
	EVP_add_cipher_alias(SN_camellia_192_cbc,""camellia192"");
	EVP_add_cipher(EVP_camellia_256_ecb());
	EVP_add_cipher(EVP_camellia_256_cbc());
	EVP_add_cipher(EVP_camellia_256_cfb());
	EVP_add_cipher(EVP_camellia_256_cfb1());
	EVP_add_cipher(EVP_camellia_256_cfb8());
	EVP_add_cipher(EVP_camellia_256_ofb());
	EVP_add_cipher_alias(SN_camellia_256_cbc,""CAMELLIA256"");
	EVP_add_cipher_alias(SN_camellia_256_cbc,""camellia256"");
#endif
	}
","void OpenSSL_add_all_ciphers(void)
	{

#ifndef OPENSSL_NO_DES
	EVP_add_cipher(EVP_des_cfb());
	EVP_add_cipher(EVP_des_cfb1());
	EVP_add_cipher(EVP_des_cfb8());
	EVP_add_cipher(EVP_des_ede_cfb());
	EVP_add_cipher(EVP_des_ede3_cfb());
	EVP_add_cipher(EVP_des_ede3_cfb1());
	EVP_add_cipher(EVP_des_ede3_cfb8());

	EVP_add_cipher(EVP_des_ofb());
	EVP_add_cipher(EVP_des_ede_ofb());
	EVP_add_cipher(EVP_des_ede3_ofb());

	EVP_add_cipher(EVP_desx_cbc());
	EVP_add_cipher_alias(SN_desx_cbc,""DESX"");
	EVP_add_cipher_alias(SN_desx_cbc,""desx"");

	EVP_add_cipher(EVP_des_cbc());
	EVP_add_cipher_alias(SN_des_cbc,""DES"");
	EVP_add_cipher_alias(SN_des_cbc,""des"");
	EVP_add_cipher(EVP_des_ede_cbc());
	EVP_add_cipher(EVP_des_ede3_cbc());
	EVP_add_cipher_alias(SN_des_ede3_cbc,""DES3"");
	EVP_add_cipher_alias(SN_des_ede3_cbc,""des3"");

	EVP_add_cipher(EVP_des_ecb());
	EVP_add_cipher(EVP_des_ede());
	EVP_add_cipher(EVP_des_ede3());
#endif

#ifndef OPENSSL_NO_RC4
	EVP_add_cipher(EVP_rc4());
	EVP_add_cipher(EVP_rc4_40());
#ifndef OPENSSL_NO_MD5
	EVP_add_cipher(EVP_rc4_hmac_md5());
#endif
#endif

#ifndef OPENSSL_NO_IDEA
	EVP_add_cipher(EVP_idea_ecb());
	EVP_add_cipher(EVP_idea_cfb());
	EVP_add_cipher(EVP_idea_ofb());
	EVP_add_cipher(EVP_idea_cbc());
	EVP_add_cipher_alias(SN_idea_cbc,""IDEA"");
	EVP_add_cipher_alias(SN_idea_cbc,""idea"");
#endif

#ifndef OPENSSL_NO_SEED
	EVP_add_cipher(EVP_seed_ecb());
	EVP_add_cipher(EVP_seed_cfb());
	EVP_add_cipher(EVP_seed_ofb());
	EVP_add_cipher(EVP_seed_cbc());
	EVP_add_cipher_alias(SN_seed_cbc,""SEED"");
	EVP_add_cipher_alias(SN_seed_cbc,""seed"");
#endif

#ifndef OPENSSL_NO_RC2
	EVP_add_cipher(EVP_rc2_ecb());
	EVP_add_cipher(EVP_rc2_cfb());
	EVP_add_cipher(EVP_rc2_ofb());
	EVP_add_cipher(EVP_rc2_cbc());
	EVP_add_cipher(EVP_rc2_40_cbc());
	EVP_add_cipher(EVP_rc2_64_cbc());
	EVP_add_cipher_alias(SN_rc2_cbc,""RC2"");
	EVP_add_cipher_alias(SN_rc2_cbc,""rc2"");
#endif

#ifndef OPENSSL_NO_BF
	EVP_add_cipher(EVP_bf_ecb());
	EVP_add_cipher(EVP_bf_cfb());
	EVP_add_cipher(EVP_bf_ofb());
	EVP_add_cipher(EVP_bf_cbc());
	EVP_add_cipher_alias(SN_bf_cbc,""BF"");
	EVP_add_cipher_alias(SN_bf_cbc,""bf"");
	EVP_add_cipher_alias(SN_bf_cbc,""blowfish"");
#endif

#ifndef OPENSSL_NO_CAST
	EVP_add_cipher(EVP_cast5_ecb());
	EVP_add_cipher(EVP_cast5_cfb());
	EVP_add_cipher(EVP_cast5_ofb());
	EVP_add_cipher(EVP_cast5_cbc());
	EVP_add_cipher_alias(SN_cast5_cbc,""CAST"");
	EVP_add_cipher_alias(SN_cast5_cbc,""cast"");
	EVP_add_cipher_alias(SN_cast5_cbc,""CAST-cbc"");
	EVP_add_cipher_alias(SN_cast5_cbc,""cast-cbc"");
#endif

#ifndef OPENSSL_NO_RC5
	EVP_add_cipher(EVP_rc5_32_12_16_ecb());
	EVP_add_cipher(EVP_rc5_32_12_16_cfb());
	EVP_add_cipher(EVP_rc5_32_12_16_ofb());
	EVP_add_cipher(EVP_rc5_32_12_16_cbc());
	EVP_add_cipher_alias(SN_rc5_cbc,""rc5"");
	EVP_add_cipher_alias(SN_rc5_cbc,""RC5"");
#endif

#ifndef OPENSSL_NO_AES
	EVP_add_cipher(EVP_aes_128_ecb());
	EVP_add_cipher(EVP_aes_128_cbc());
	EVP_add_cipher(EVP_aes_128_cfb());
	EVP_add_cipher(EVP_aes_128_cfb1());
	EVP_add_cipher(EVP_aes_128_cfb8());
	EVP_add_cipher(EVP_aes_128_ofb());
	EVP_add_cipher(EVP_aes_128_ctr());
	EVP_add_cipher(EVP_aes_128_gcm());
	EVP_add_cipher(EVP_aes_128_xts());
	EVP_add_cipher_alias(SN_aes_128_cbc,""AES128"");
	EVP_add_cipher_alias(SN_aes_128_cbc,""aes128"");
	EVP_add_cipher(EVP_aes_192_ecb());
	EVP_add_cipher(EVP_aes_192_cbc());
	EVP_add_cipher(EVP_aes_192_cfb());
	EVP_add_cipher(EVP_aes_192_cfb1());
	EVP_add_cipher(EVP_aes_192_cfb8());
	EVP_add_cipher(EVP_aes_192_ofb());
	EVP_add_cipher(EVP_aes_192_ctr());
	EVP_add_cipher(EVP_aes_192_gcm());
	EVP_add_cipher_alias(SN_aes_192_cbc,""AES192"");
	EVP_add_cipher_alias(SN_aes_192_cbc,""aes192"");
	EVP_add_cipher(EVP_aes_256_ecb());
	EVP_add_cipher(EVP_aes_256_cbc());
	EVP_add_cipher(EVP_aes_256_cfb());
	EVP_add_cipher(EVP_aes_256_cfb1());
	EVP_add_cipher(EVP_aes_256_cfb8());
	EVP_add_cipher(EVP_aes_256_ofb());
	EVP_add_cipher(EVP_aes_256_ctr());
	EVP_add_cipher(EVP_aes_256_gcm());
        EVP_add_cipher(EVP_aes_256_xts());
        EVP_add_cipher_alias(SN_aes_256_cbc,""AES256"");
        EVP_add_cipher_alias(SN_aes_256_cbc,""aes256"");
#if 0  /* Disabled because of timing side-channel leaks. */
 #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)
        EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());
        EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());
 #endif
 #endif
#endif
 
 #ifndef OPENSSL_NO_CAMELLIA
        EVP_add_cipher(EVP_camellia_128_ecb());
#ifndef OPENSSL_NO_CAMELLIA
	EVP_add_cipher(EVP_camellia_128_ecb());
	EVP_add_cipher(EVP_camellia_128_cbc());
	EVP_add_cipher(EVP_camellia_128_cfb());
	EVP_add_cipher(EVP_camellia_128_cfb1());
	EVP_add_cipher(EVP_camellia_128_cfb8());
	EVP_add_cipher(EVP_camellia_128_ofb());
	EVP_add_cipher_alias(SN_camellia_128_cbc,""CAMELLIA128"");
	EVP_add_cipher_alias(SN_camellia_128_cbc,""camellia128"");
	EVP_add_cipher(EVP_camellia_192_ecb());
	EVP_add_cipher(EVP_camellia_192_cbc());
	EVP_add_cipher(EVP_camellia_192_cfb());
	EVP_add_cipher(EVP_camellia_192_cfb1());
	EVP_add_cipher(EVP_camellia_192_cfb8());
	EVP_add_cipher(EVP_camellia_192_ofb());
	EVP_add_cipher_alias(SN_camellia_192_cbc,""CAMELLIA192"");
	EVP_add_cipher_alias(SN_camellia_192_cbc,""camellia192"");
	EVP_add_cipher(EVP_camellia_256_ecb());
	EVP_add_cipher(EVP_camellia_256_cbc());
	EVP_add_cipher(EVP_camellia_256_cfb());
	EVP_add_cipher(EVP_camellia_256_cfb1());
	EVP_add_cipher(EVP_camellia_256_cfb8());
	EVP_add_cipher(EVP_camellia_256_ofb());
	EVP_add_cipher_alias(SN_camellia_256_cbc,""CAMELLIA256"");
	EVP_add_cipher_alias(SN_camellia_256_cbc,""camellia256"");
#endif
	}
",C,,"#if 0  /* Disabled because of timing side-channel leaks. */
#endif
",f3e99ea072126338c5b7b96c1e5a07d56d000463,"@@ -195,13 +195,11 @@ void OpenSSL_add_all_ciphers(void)
        EVP_add_cipher(EVP_aes_256_xts());
        EVP_add_cipher_alias(SN_aes_256_cbc,""AES256"");
        EVP_add_cipher_alias(SN_aes_256_cbc,""aes256"");
-#if 0  /* Disabled because of timing side-channel leaks. */
 #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)
        EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());
        EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());
 #endif
 #endif
-#endif
 
 #ifndef OPENSSL_NO_CAMELLIA
        EVP_add_cipher(EVP_camellia_128_ecb());",openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/evp/c_allc.c;h=2a45d435e58eb72ce1b319144f3c5275a2a64e14;hb=125093b59f3c2a2d33785b5563d929d0472f1721,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/evp/c_allc.c;h=e230e6081e3ccf8ff5d99a6088c164d63ce11499,1,"void OpenSSL_add_all_ciphers(void)
	{

#ifndef OPENSSL_NO_DES
	EVP_add_cipher(EVP_des_cfb());
	EVP_add_cipher(EVP_des_cfb1());
	EVP_add_cipher(EVP_des_cfb8());
	EVP_add_cipher(EVP_des_ede_cfb());
	EVP_add_cipher(EVP_des_ede3_cfb());
	EVP_add_cipher(EVP_des_ede3_cfb1());
	EVP_add_cipher(EVP_des_ede3_cfb8());

	EVP_add_cipher(EVP_des_ofb());
	EVP_add_cipher(EVP_des_ede_ofb());
	EVP_add_cipher(EVP_des_ede3_ofb());

	EVP_add_cipher(EVP_desx_cbc());
	EVP_add_cipher_alias(SN_desx_cbc,""DESX"");
	EVP_add_cipher_alias(SN_desx_cbc,""desx"");

	EVP_add_cipher(EVP_des_cbc());
	EVP_add_cipher_alias(SN_des_cbc,""DES"");
	EVP_add_cipher_alias(SN_des_cbc,""des"");
	EVP_add_cipher(EVP_des_ede_cbc());
	EVP_add_cipher(EVP_des_ede3_cbc());
	EVP_add_cipher_alias(SN_des_ede3_cbc,""DES3"");
	EVP_add_cipher_alias(SN_des_ede3_cbc,""des3"");

	EVP_add_cipher(EVP_des_ecb());
	EVP_add_cipher(EVP_des_ede());
	EVP_add_cipher(EVP_des_ede3());
#endif

#ifndef OPENSSL_NO_RC4
	EVP_add_cipher(EVP_rc4());
	EVP_add_cipher(EVP_rc4_40());
#ifndef OPENSSL_NO_MD5
	EVP_add_cipher(EVP_rc4_hmac_md5());
#endif
#endif

#ifndef OPENSSL_NO_IDEA
	EVP_add_cipher(EVP_idea_ecb());
	EVP_add_cipher(EVP_idea_cfb());
	EVP_add_cipher(EVP_idea_ofb());
	EVP_add_cipher(EVP_idea_cbc());
	EVP_add_cipher_alias(SN_idea_cbc,""IDEA"");
	EVP_add_cipher_alias(SN_idea_cbc,""idea"");
#endif

#ifndef OPENSSL_NO_SEED
	EVP_add_cipher(EVP_seed_ecb());
	EVP_add_cipher(EVP_seed_cfb());
	EVP_add_cipher(EVP_seed_ofb());
	EVP_add_cipher(EVP_seed_cbc());
	EVP_add_cipher_alias(SN_seed_cbc,""SEED"");
	EVP_add_cipher_alias(SN_seed_cbc,""seed"");
#endif

#ifndef OPENSSL_NO_RC2
	EVP_add_cipher(EVP_rc2_ecb());
	EVP_add_cipher(EVP_rc2_cfb());
	EVP_add_cipher(EVP_rc2_ofb());
	EVP_add_cipher(EVP_rc2_cbc());
	EVP_add_cipher(EVP_rc2_40_cbc());
	EVP_add_cipher(EVP_rc2_64_cbc());
	EVP_add_cipher_alias(SN_rc2_cbc,""RC2"");
	EVP_add_cipher_alias(SN_rc2_cbc,""rc2"");
#endif

#ifndef OPENSSL_NO_BF
	EVP_add_cipher(EVP_bf_ecb());
	EVP_add_cipher(EVP_bf_cfb());
	EVP_add_cipher(EVP_bf_ofb());
	EVP_add_cipher(EVP_bf_cbc());
	EVP_add_cipher_alias(SN_bf_cbc,""BF"");
	EVP_add_cipher_alias(SN_bf_cbc,""bf"");
	EVP_add_cipher_alias(SN_bf_cbc,""blowfish"");
#endif

#ifndef OPENSSL_NO_CAST
	EVP_add_cipher(EVP_cast5_ecb());
	EVP_add_cipher(EVP_cast5_cfb());
	EVP_add_cipher(EVP_cast5_ofb());
	EVP_add_cipher(EVP_cast5_cbc());
	EVP_add_cipher_alias(SN_cast5_cbc,""CAST"");
	EVP_add_cipher_alias(SN_cast5_cbc,""cast"");
	EVP_add_cipher_alias(SN_cast5_cbc,""CAST-cbc"");
	EVP_add_cipher_alias(SN_cast5_cbc,""cast-cbc"");
#endif

#ifndef OPENSSL_NO_RC5
	EVP_add_cipher(EVP_rc5_32_12_16_ecb());
	EVP_add_cipher(EVP_rc5_32_12_16_cfb());
	EVP_add_cipher(EVP_rc5_32_12_16_ofb());
	EVP_add_cipher(EVP_rc5_32_12_16_cbc());
	EVP_add_cipher_alias(SN_rc5_cbc,""rc5"");
	EVP_add_cipher_alias(SN_rc5_cbc,""RC5"");
#endif

#ifndef OPENSSL_NO_AES
	EVP_add_cipher(EVP_aes_128_ecb());
	EVP_add_cipher(EVP_aes_128_cbc());
	EVP_add_cipher(EVP_aes_128_cfb());
	EVP_add_cipher(EVP_aes_128_cfb1());
	EVP_add_cipher(EVP_aes_128_cfb8());
	EVP_add_cipher(EVP_aes_128_ofb());
	EVP_add_cipher(EVP_aes_128_ctr());
	EVP_add_cipher(EVP_aes_128_gcm());
	EVP_add_cipher(EVP_aes_128_xts());
	EVP_add_cipher_alias(SN_aes_128_cbc,""AES128"");
	EVP_add_cipher_alias(SN_aes_128_cbc,""aes128"");
	EVP_add_cipher(EVP_aes_192_ecb());
	EVP_add_cipher(EVP_aes_192_cbc());
	EVP_add_cipher(EVP_aes_192_cfb());
	EVP_add_cipher(EVP_aes_192_cfb1());
	EVP_add_cipher(EVP_aes_192_cfb8());
	EVP_add_cipher(EVP_aes_192_ofb());
	EVP_add_cipher(EVP_aes_192_ctr());
	EVP_add_cipher(EVP_aes_192_gcm());
	EVP_add_cipher_alias(SN_aes_192_cbc,""AES192"");
	EVP_add_cipher_alias(SN_aes_192_cbc,""aes192"");
	EVP_add_cipher(EVP_aes_256_ecb());
	EVP_add_cipher(EVP_aes_256_cbc());
	EVP_add_cipher(EVP_aes_256_cfb());
	EVP_add_cipher(EVP_aes_256_cfb1());
	EVP_add_cipher(EVP_aes_256_cfb8());
	EVP_add_cipher(EVP_aes_256_ofb());
	EVP_add_cipher(EVP_aes_256_ctr());
	EVP_add_cipher(EVP_aes_256_gcm());
        EVP_add_cipher(EVP_aes_256_xts());
        EVP_add_cipher_alias(SN_aes_256_cbc,""AES256"");
        EVP_add_cipher_alias(SN_aes_256_cbc,""aes256"");
//flaw_line_below:
#if 0  /* Disabled because of timing side-channel leaks. */
 #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)
        EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());
        EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());
 #endif
 #endif
//flaw_line_below:
#endif
 
 #ifndef OPENSSL_NO_CAMELLIA
        EVP_add_cipher(EVP_camellia_128_ecb());
#ifndef OPENSSL_NO_CAMELLIA
	EVP_add_cipher(EVP_camellia_128_ecb());
	EVP_add_cipher(EVP_camellia_128_cbc());
	EVP_add_cipher(EVP_camellia_128_cfb());
	EVP_add_cipher(EVP_camellia_128_cfb1());
	EVP_add_cipher(EVP_camellia_128_cfb8());
	EVP_add_cipher(EVP_camellia_128_ofb());
	EVP_add_cipher_alias(SN_camellia_128_cbc,""CAMELLIA128"");
	EVP_add_cipher_alias(SN_camellia_128_cbc,""camellia128"");
	EVP_add_cipher(EVP_camellia_192_ecb());
	EVP_add_cipher(EVP_camellia_192_cbc());
	EVP_add_cipher(EVP_camellia_192_cfb());
	EVP_add_cipher(EVP_camellia_192_cfb1());
	EVP_add_cipher(EVP_camellia_192_cfb8());
	EVP_add_cipher(EVP_camellia_192_ofb());
	EVP_add_cipher_alias(SN_camellia_192_cbc,""CAMELLIA192"");
	EVP_add_cipher_alias(SN_camellia_192_cbc,""camellia192"");
	EVP_add_cipher(EVP_camellia_256_ecb());
	EVP_add_cipher(EVP_camellia_256_cbc());
	EVP_add_cipher(EVP_camellia_256_cfb());
	EVP_add_cipher(EVP_camellia_256_cfb1());
	EVP_add_cipher(EVP_camellia_256_cfb8());
	EVP_add_cipher(EVP_camellia_256_ofb());
	EVP_add_cipher_alias(SN_camellia_256_cbc,""CAMELLIA256"");
	EVP_add_cipher_alias(SN_camellia_256_cbc,""camellia256"");
#endif
	}
"
304,178040,,Remote,Not required,Partial,CVE-2012-2686,https://www.cvedetails.com/cve/CVE-2012-2686/,CWE-310,Low,,,,2013-02-08,5.0,crypto/evp/e_aes_cbc_hmac_sha1.c in the AES-NI functionality in the TLS 1.1 and 1.2 implementations in OpenSSL 1.0.1 before 1.0.1d allows remote attackers to cause a denial of service (application crash) via crafted CBC data.,2018-08-08,DoS,15,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=125093b59f3c2a2d33785b5563d929d0472f1721,125093b59f3c2a2d33785b5563d929d0472f1721,,0,,,"int tls1_cbc_remove_padding(const SSL* s,
			    SSL3_RECORD *rec,
			    unsigned block_size,
			    unsigned mac_size)
	{
	unsigned padding_length, good, to_check, i;
	const char has_explicit_iv =
		s->version >= TLS1_1_VERSION || s->version == DTLS1_VERSION;
	const unsigned overhead = 1 /* padding length byte */ +
				  mac_size +
				  (has_explicit_iv ? block_size : 0);

	/* These lengths are all public so we can test them in non-constant
	 * time. */
        if (overhead > rec->length)
                return 0;
 
       /* We can always safely skip the explicit IV. We check at the beginning
        * of this function that the record has at least enough space for the
        * IV, MAC and padding length byte. (These can be checked in
        * non-constant time because it's all public information.) So, if the
        * padding was invalid, then we didn't change |rec->length| and this is
        * safe. If the padding was valid then we know that we have at least
        * overhead+padding_length bytes of space and so this is still safe
        * because overhead accounts for the explicit IV. */
       if (has_explicit_iv)
               {
               rec->data += block_size;
               rec->input += block_size;
               rec->length -= block_size;
               }

        padding_length = rec->data[rec->length-1];
 
        /* NB: if compression is in operation the first packet may not be of
			padding_length--;
			}
","int tls1_cbc_remove_padding(const SSL* s,
			    SSL3_RECORD *rec,
			    unsigned block_size,
			    unsigned mac_size)
	{
	unsigned padding_length, good, to_check, i;
	const char has_explicit_iv =
		s->version >= TLS1_1_VERSION || s->version == DTLS1_VERSION;
	const unsigned overhead = 1 /* padding length byte */ +
				  mac_size +
				  (has_explicit_iv ? block_size : 0);

	/* These lengths are all public so we can test them in non-constant
	 * time. */
        if (overhead > rec->length)
                return 0;
 
        padding_length = rec->data[rec->length-1];
 
        /* NB: if compression is in operation the first packet may not be of
			padding_length--;
			}
",C,"       /* We can always safely skip the explicit IV. We check at the beginning
        * of this function that the record has at least enough space for the
        * IV, MAC and padding length byte. (These can be checked in
        * non-constant time because it's all public information.) So, if the
        * padding was invalid, then we didn't change |rec->length| and this is
        * safe. If the padding was valid then we know that we have at least
        * overhead+padding_length bytes of space and so this is still safe
        * because overhead accounts for the explicit IV. */
       if (has_explicit_iv)
               {
               rec->data += block_size;
               rec->input += block_size;
               rec->length -= block_size;
               }

",,f3e99ea072126338c5b7b96c1e5a07d56d000463,"@@ -150,6 +150,21 @@ int tls1_cbc_remove_padding(const SSL* s,
        if (overhead > rec->length)
                return 0;
 
+       /* We can always safely skip the explicit IV. We check at the beginning
+        * of this function that the record has at least enough space for the
+        * IV, MAC and padding length byte. (These can be checked in
+        * non-constant time because it's all public information.) So, if the
+        * padding was invalid, then we didn't change |rec->length| and this is
+        * safe. If the padding was valid then we know that we have at least
+        * overhead+padding_length bytes of space and so this is still safe
+        * because overhead accounts for the explicit IV. */
+       if (has_explicit_iv)
+               {
+               rec->data += block_size;
+               rec->input += block_size;
+               rec->length -= block_size;
+               }
+
        padding_length = rec->data[rec->length-1];
 
        /* NB: if compression is in operation the first packet may not be of
@@ -172,6 +187,13 @@ int tls1_cbc_remove_padding(const SSL* s,
                        }
                }
 
+       if (EVP_CIPHER_flags(s->enc_read_ctx->cipher)&EVP_CIPH_FLAG_AEAD_CIPHER)
+               {
+               /* padding is already verified */
+               rec->length -= padding_length;
+               return 1;
+               }
+
        good = constant_time_ge(rec->length, overhead+padding_length);
        /* The padding consists of a length byte at the end of the record and
         * then that many bytes of padding, all with the same value as the
@@ -209,21 +231,6 @@ int tls1_cbc_remove_padding(const SSL* s,
        rec->length -= padding_length;
        rec->type |= padding_length<<8; /* kludge: pass padding length */
 
-       /* We can always safely skip the explicit IV. We check at the beginning
-        * of this function that the record has at least enough space for the
-        * IV, MAC and padding length byte. (These can be checked in
-        * non-constant time because it's all public information.) So, if the
-        * padding was invalid, then we didn't change |rec->length| and this is
-        * safe. If the padding was valid then we know that we have at least
-        * overhead+padding_length bytes of space and so this is still safe
-        * because overhead accounts for the explicit IV. */
-       if (has_explicit_iv)
-               {
-               rec->data += block_size;
-               rec->input += block_size;
-               rec->length -= block_size;
-               }
-
        return (int)((good & 1) | (~good & -1));
        }",openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=ssl/s3_cbc.c;h=3c2c16539d56dc645bc9871ee8f17212f79a501e;hb=125093b59f3c2a2d33785b5563d929d0472f1721,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=ssl/s3_cbc.c;h=b91d84098d8c81fdac34dda7faaf761c23f4c6a7,1,"int tls1_cbc_remove_padding(const SSL* s,
			    SSL3_RECORD *rec,
			    unsigned block_size,
			    unsigned mac_size)
	{
	unsigned padding_length, good, to_check, i;
	const char has_explicit_iv =
		s->version >= TLS1_1_VERSION || s->version == DTLS1_VERSION;
	const unsigned overhead = 1 /* padding length byte */ +
				  mac_size +
				  (has_explicit_iv ? block_size : 0);

	/* These lengths are all public so we can test them in non-constant
	 * time. */
        if (overhead > rec->length)
                return 0;
 
//fix_flaw_line_below:
//       /* We can always safely skip the explicit IV. We check at the beginning
//fix_flaw_line_below:
//        * of this function that the record has at least enough space for the
//fix_flaw_line_below:
//        * IV, MAC and padding length byte. (These can be checked in
//fix_flaw_line_below:
//        * non-constant time because it's all public information.) So, if the
//fix_flaw_line_below:
//        * padding was invalid, then we didn't change |rec->length| and this is
//fix_flaw_line_below:
//        * safe. If the padding was valid then we know that we have at least
//fix_flaw_line_below:
//        * overhead+padding_length bytes of space and so this is still safe
//fix_flaw_line_below:
//        * because overhead accounts for the explicit IV. */
//fix_flaw_line_below:
//       if (has_explicit_iv)
//fix_flaw_line_below:
//               {
//fix_flaw_line_below:
//               rec->data += block_size;
//fix_flaw_line_below:
//               rec->input += block_size;
//fix_flaw_line_below:
//               rec->length -= block_size;
//fix_flaw_line_below:
//               }
//fix_flaw_line_below:
//
        padding_length = rec->data[rec->length-1];
 
        /* NB: if compression is in operation the first packet may not be of
			padding_length--;
			}
"
305,178041,,Remote,Not required,Partial,CVE-2012-2686,https://www.cvedetails.com/cve/CVE-2012-2686/,CWE-310,Low,,,,2013-02-08,5.0,crypto/evp/e_aes_cbc_hmac_sha1.c in the AES-NI functionality in the TLS 1.1 and 1.2 implementations in OpenSSL 1.0.1 before 1.0.1d allows remote attackers to cause a denial of service (application crash) via crafted CBC data.,2018-08-08,DoS,0,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=125093b59f3c2a2d33785b5563d929d0472f1721,125093b59f3c2a2d33785b5563d929d0472f1721,,2,,,"int SSL_library_init(void)
	{

#ifndef OPENSSL_NO_DES
	EVP_add_cipher(EVP_des_cbc());
	EVP_add_cipher(EVP_des_ede3_cbc());
#endif
#ifndef OPENSSL_NO_IDEA
	EVP_add_cipher(EVP_idea_cbc());
#endif
#ifndef OPENSSL_NO_RC4
	EVP_add_cipher(EVP_rc4());
#if !defined(OPENSSL_NO_MD5) && (defined(__x86_64) || defined(__x86_64__))
	EVP_add_cipher(EVP_rc4_hmac_md5());
#endif
#endif  
#ifndef OPENSSL_NO_RC2
	EVP_add_cipher(EVP_rc2_cbc());
	/* Not actually used for SSL/TLS but this makes PKCS#12 work
	 * if an application only calls SSL_library_init().
	 */
	EVP_add_cipher(EVP_rc2_40_cbc());
#endif
#ifndef OPENSSL_NO_AES
	EVP_add_cipher(EVP_aes_128_cbc());
	EVP_add_cipher(EVP_aes_192_cbc());
        EVP_add_cipher(EVP_aes_256_cbc());
        EVP_add_cipher(EVP_aes_128_gcm());
        EVP_add_cipher(EVP_aes_256_gcm());
 #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)
        EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());
        EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());
 #endif
 
 #endif
 #ifndef OPENSSL_NO_CAMELLIA
#endif
#ifndef OPENSSL_NO_CAMELLIA
	EVP_add_cipher(EVP_camellia_128_cbc());
	EVP_add_cipher(EVP_camellia_256_cbc());
#endif

#ifndef OPENSSL_NO_SEED
	EVP_add_cipher(EVP_seed_cbc());
#endif
  
#ifndef OPENSSL_NO_MD5
	EVP_add_digest(EVP_md5());
	EVP_add_digest_alias(SN_md5,""ssl2-md5"");
	EVP_add_digest_alias(SN_md5,""ssl3-md5"");
#endif
#ifndef OPENSSL_NO_SHA
	EVP_add_digest(EVP_sha1()); /* RSA with sha1 */
	EVP_add_digest_alias(SN_sha1,""ssl3-sha1"");
	EVP_add_digest_alias(SN_sha1WithRSAEncryption,SN_sha1WithRSA);
#endif
#ifndef OPENSSL_NO_SHA256
	EVP_add_digest(EVP_sha224());
	EVP_add_digest(EVP_sha256());
#endif
#ifndef OPENSSL_NO_SHA512
	EVP_add_digest(EVP_sha384());
	EVP_add_digest(EVP_sha512());
#endif
#if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_DSA)
	EVP_add_digest(EVP_dss1()); /* DSA with sha1 */
	EVP_add_digest_alias(SN_dsaWithSHA1,SN_dsaWithSHA1_2);
	EVP_add_digest_alias(SN_dsaWithSHA1,""DSS1"");
	EVP_add_digest_alias(SN_dsaWithSHA1,""dss1"");
#endif
#ifndef OPENSSL_NO_ECDSA
	EVP_add_digest(EVP_ecdsa());
#endif
	/* If you want support for phased out ciphers, add the following */
#if 0
	EVP_add_digest(EVP_sha());
	EVP_add_digest(EVP_dss());
#endif
#ifndef OPENSSL_NO_COMP
	/* This will initialise the built-in compression algorithms.
	   The value returned is a STACK_OF(SSL_COMP), but that can
	   be discarded safely */
	(void)SSL_COMP_get_compression_methods();
#endif
	/* initialize cipher/digest methods table */
	ssl_load_ciphers();
	return(1);
	}
","int SSL_library_init(void)
	{

#ifndef OPENSSL_NO_DES
	EVP_add_cipher(EVP_des_cbc());
	EVP_add_cipher(EVP_des_ede3_cbc());
#endif
#ifndef OPENSSL_NO_IDEA
	EVP_add_cipher(EVP_idea_cbc());
#endif
#ifndef OPENSSL_NO_RC4
	EVP_add_cipher(EVP_rc4());
#if !defined(OPENSSL_NO_MD5) && (defined(__x86_64) || defined(__x86_64__))
	EVP_add_cipher(EVP_rc4_hmac_md5());
#endif
#endif  
#ifndef OPENSSL_NO_RC2
	EVP_add_cipher(EVP_rc2_cbc());
	/* Not actually used for SSL/TLS but this makes PKCS#12 work
	 * if an application only calls SSL_library_init().
	 */
	EVP_add_cipher(EVP_rc2_40_cbc());
#endif
#ifndef OPENSSL_NO_AES
	EVP_add_cipher(EVP_aes_128_cbc());
	EVP_add_cipher(EVP_aes_192_cbc());
        EVP_add_cipher(EVP_aes_256_cbc());
        EVP_add_cipher(EVP_aes_128_gcm());
        EVP_add_cipher(EVP_aes_256_gcm());
#if 0 /* Disabled because of timing side-channel leaks. */
 #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)
        EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());
        EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());
 #endif
#endif
 
 #endif
 #ifndef OPENSSL_NO_CAMELLIA
#endif
#ifndef OPENSSL_NO_CAMELLIA
	EVP_add_cipher(EVP_camellia_128_cbc());
	EVP_add_cipher(EVP_camellia_256_cbc());
#endif

#ifndef OPENSSL_NO_SEED
	EVP_add_cipher(EVP_seed_cbc());
#endif
  
#ifndef OPENSSL_NO_MD5
	EVP_add_digest(EVP_md5());
	EVP_add_digest_alias(SN_md5,""ssl2-md5"");
	EVP_add_digest_alias(SN_md5,""ssl3-md5"");
#endif
#ifndef OPENSSL_NO_SHA
	EVP_add_digest(EVP_sha1()); /* RSA with sha1 */
	EVP_add_digest_alias(SN_sha1,""ssl3-sha1"");
	EVP_add_digest_alias(SN_sha1WithRSAEncryption,SN_sha1WithRSA);
#endif
#ifndef OPENSSL_NO_SHA256
	EVP_add_digest(EVP_sha224());
	EVP_add_digest(EVP_sha256());
#endif
#ifndef OPENSSL_NO_SHA512
	EVP_add_digest(EVP_sha384());
	EVP_add_digest(EVP_sha512());
#endif
#if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_DSA)
	EVP_add_digest(EVP_dss1()); /* DSA with sha1 */
	EVP_add_digest_alias(SN_dsaWithSHA1,SN_dsaWithSHA1_2);
	EVP_add_digest_alias(SN_dsaWithSHA1,""DSS1"");
	EVP_add_digest_alias(SN_dsaWithSHA1,""dss1"");
#endif
#ifndef OPENSSL_NO_ECDSA
	EVP_add_digest(EVP_ecdsa());
#endif
	/* If you want support for phased out ciphers, add the following */
#if 0
	EVP_add_digest(EVP_sha());
	EVP_add_digest(EVP_dss());
#endif
#ifndef OPENSSL_NO_COMP
	/* This will initialise the built-in compression algorithms.
	   The value returned is a STACK_OF(SSL_COMP), but that can
	   be discarded safely */
	(void)SSL_COMP_get_compression_methods();
#endif
	/* initialize cipher/digest methods table */
	ssl_load_ciphers();
	return(1);
	}
",C,,"#if 0 /* Disabled because of timing side-channel leaks. */
#endif
",f3e99ea072126338c5b7b96c1e5a07d56d000463,"@@ -90,12 +90,10 @@ int SSL_library_init(void)
        EVP_add_cipher(EVP_aes_256_cbc());
        EVP_add_cipher(EVP_aes_128_gcm());
        EVP_add_cipher(EVP_aes_256_gcm());
-#if 0 /* Disabled because of timing side-channel leaks. */
 #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)
        EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());
        EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());
 #endif
-#endif
 
 #endif
 #ifndef OPENSSL_NO_CAMELLIA",openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=ssl/ssl_algs.c;h=9c34d19725b133bdfe771e7696b69f9e783236e7;hb=125093b59f3c2a2d33785b5563d929d0472f1721,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=ssl/ssl_algs.c;h=41ccbaac30d7aa5974bb480eee0d343bf053d8ed,1,"int SSL_library_init(void)
	{

#ifndef OPENSSL_NO_DES
	EVP_add_cipher(EVP_des_cbc());
	EVP_add_cipher(EVP_des_ede3_cbc());
#endif
#ifndef OPENSSL_NO_IDEA
	EVP_add_cipher(EVP_idea_cbc());
#endif
#ifndef OPENSSL_NO_RC4
	EVP_add_cipher(EVP_rc4());
#if !defined(OPENSSL_NO_MD5) && (defined(__x86_64) || defined(__x86_64__))
	EVP_add_cipher(EVP_rc4_hmac_md5());
#endif
#endif  
#ifndef OPENSSL_NO_RC2
	EVP_add_cipher(EVP_rc2_cbc());
	/* Not actually used for SSL/TLS but this makes PKCS#12 work
	 * if an application only calls SSL_library_init().
	 */
	EVP_add_cipher(EVP_rc2_40_cbc());
#endif
#ifndef OPENSSL_NO_AES
	EVP_add_cipher(EVP_aes_128_cbc());
	EVP_add_cipher(EVP_aes_192_cbc());
        EVP_add_cipher(EVP_aes_256_cbc());
        EVP_add_cipher(EVP_aes_128_gcm());
        EVP_add_cipher(EVP_aes_256_gcm());
//flaw_line_below:
#if 0 /* Disabled because of timing side-channel leaks. */
 #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)
        EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());
        EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());
 #endif
//flaw_line_below:
#endif
 
 #endif
 #ifndef OPENSSL_NO_CAMELLIA
#endif
#ifndef OPENSSL_NO_CAMELLIA
	EVP_add_cipher(EVP_camellia_128_cbc());
	EVP_add_cipher(EVP_camellia_256_cbc());
#endif

#ifndef OPENSSL_NO_SEED
	EVP_add_cipher(EVP_seed_cbc());
#endif
  
#ifndef OPENSSL_NO_MD5
	EVP_add_digest(EVP_md5());
	EVP_add_digest_alias(SN_md5,""ssl2-md5"");
	EVP_add_digest_alias(SN_md5,""ssl3-md5"");
#endif
#ifndef OPENSSL_NO_SHA
	EVP_add_digest(EVP_sha1()); /* RSA with sha1 */
	EVP_add_digest_alias(SN_sha1,""ssl3-sha1"");
	EVP_add_digest_alias(SN_sha1WithRSAEncryption,SN_sha1WithRSA);
#endif
#ifndef OPENSSL_NO_SHA256
	EVP_add_digest(EVP_sha224());
	EVP_add_digest(EVP_sha256());
#endif
#ifndef OPENSSL_NO_SHA512
	EVP_add_digest(EVP_sha384());
	EVP_add_digest(EVP_sha512());
#endif
#if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_DSA)
	EVP_add_digest(EVP_dss1()); /* DSA with sha1 */
	EVP_add_digest_alias(SN_dsaWithSHA1,SN_dsaWithSHA1_2);
	EVP_add_digest_alias(SN_dsaWithSHA1,""DSS1"");
	EVP_add_digest_alias(SN_dsaWithSHA1,""dss1"");
#endif
#ifndef OPENSSL_NO_ECDSA
	EVP_add_digest(EVP_ecdsa());
#endif
	/* If you want support for phased out ciphers, add the following */
#if 0
	EVP_add_digest(EVP_sha());
	EVP_add_digest(EVP_dss());
#endif
#ifndef OPENSSL_NO_COMP
	/* This will initialise the built-in compression algorithms.
	   The value returned is a STACK_OF(SSL_COMP), but that can
	   be discarded safely */
	(void)SSL_COMP_get_compression_methods();
#endif
	/* initialize cipher/digest methods table */
	ssl_load_ciphers();
	return(1);
	}
"
463,178199,,Remote,Not required,,CVE-2012-2143,https://www.cvedetails.com/cve/CVE-2012-2143/,CWE-310,Medium,,Partial,,2012-07-05,4.3,"The crypt_des (aka DES-based crypt) function in FreeBSD before 9.0-RELEASE-p2, as used in PHP, PostgreSQL, and other products, does not process the complete cleartext password if this password contains a 0x80 character, which makes it easier for context-dependent attackers to obtain access via an authentication attempt with an initial substring of the intended password, as demonstrated by a Unicode password.",2016-12-07,,2,https://git.postgresql.org/gitweb/?p=postgresql.git&a=commit&h=932ded2ed51e8333852e370c7a6dad75d9f236f9,932ded2ed51e8333852e370c7a6dad75d9f236f9,,1,,,"px_crypt_des(const char *key, const char *setting)
{
	int			i;
	uint32		count,
				salt,
				l,
				r0,
				r1,
				keybuf[2];
	char	   *p;
	uint8	   *q;
	static char output[21];

	if (!des_initialised)
		des_init();


	/*
	 * Copy the key, shifting each character up by one bit and padding with
	 * zeros.
	 */
    q = (uint8 *) keybuf;
    while (q - (uint8 *) keybuf - 8)
    {
       *q++ = *key << 1;
       if (*key != '\0')
            key++;
    }
    if (des_setkey((char *) keybuf))

#ifndef DISABLE_XDES
	if (*setting == _PASSWORD_EFMT1)
	{
		/*
		 * ""new""-style: setting - underscore, 4 bytes of count, 4 bytes of
		 * salt key - unlimited characters
		 */
		for (i = 1, count = 0L; i < 5; i++)
			count |= ascii_to_bin(setting[i]) << (i - 1) * 6;

		for (i = 5, salt = 0L; i < 9; i++)
			salt |= ascii_to_bin(setting[i]) << (i - 5) * 6;

		while (*key)
		{
			/*
			 * Encrypt the key with itself.
			 */
			if (des_cipher((char *) keybuf, (char *) keybuf, 0L, 1))
				return (NULL);

			/*
			 * And XOR with the next 8 characters of the key.
			 */
			q = (uint8 *) keybuf;
			while (q - (uint8 *) keybuf - 8 && *key)
				*q++ ^= *key++ << 1;

			if (des_setkey((char *) keybuf))
				return (NULL);
		}
		strncpy(output, setting, 9);

		/*
		 * Double check that we weren't given a short setting. If we were, the
		 * above code will probably have created weird values for count and
		 * salt, but we don't really care. Just make sure the output string
		 * doesn't have an extra NUL in it.
		 */
		output[9] = '\0';
		p = output + strlen(output);
	}
	else
#endif   /* !DISABLE_XDES */
	{
		/*
		 * ""old""-style: setting - 2 bytes of salt key - up to 8 characters
		 */
		count = 25;

		salt = (ascii_to_bin(setting[1]) << 6)
			| ascii_to_bin(setting[0]);

		output[0] = setting[0];

		/*
		 * If the encrypted password that the salt was extracted from is only
		 * 1 character long, the salt will be corrupted.  We need to ensure
		 * that the output string doesn't have an extra NUL in it!
		 */
		output[1] = setting[1] ? setting[1] : output[0];

		p = output + 2;
	}
	setup_salt(salt);

	/*
	 * Do it.
	 */
	if (do_des(0L, 0L, &r0, &r1, count))
		return (NULL);

	/*
	 * Now encode the result...
	 */
	l = (r0 >> 8);
	*p++ = _crypt_a64[(l >> 18) & 0x3f];
	*p++ = _crypt_a64[(l >> 12) & 0x3f];
	*p++ = _crypt_a64[(l >> 6) & 0x3f];
	*p++ = _crypt_a64[l & 0x3f];

	l = (r0 << 16) | ((r1 >> 16) & 0xffff);
	*p++ = _crypt_a64[(l >> 18) & 0x3f];
	*p++ = _crypt_a64[(l >> 12) & 0x3f];
	*p++ = _crypt_a64[(l >> 6) & 0x3f];
	*p++ = _crypt_a64[l & 0x3f];

	l = r1 << 2;
	*p++ = _crypt_a64[(l >> 12) & 0x3f];
	*p++ = _crypt_a64[(l >> 6) & 0x3f];
	*p++ = _crypt_a64[l & 0x3f];
	*p = 0;

	return (output);
}
","px_crypt_des(const char *key, const char *setting)
{
	int			i;
	uint32		count,
				salt,
				l,
				r0,
				r1,
				keybuf[2];
	char	   *p;
	uint8	   *q;
	static char output[21];

	if (!des_initialised)
		des_init();


	/*
	 * Copy the key, shifting each character up by one bit and padding with
	 * zeros.
	 */
    q = (uint8 *) keybuf;
    while (q - (uint8 *) keybuf - 8)
    {
       if ((*q++ = *key << 1))
            key++;
    }
    if (des_setkey((char *) keybuf))

#ifndef DISABLE_XDES
	if (*setting == _PASSWORD_EFMT1)
	{
		/*
		 * ""new""-style: setting - underscore, 4 bytes of count, 4 bytes of
		 * salt key - unlimited characters
		 */
		for (i = 1, count = 0L; i < 5; i++)
			count |= ascii_to_bin(setting[i]) << (i - 1) * 6;

		for (i = 5, salt = 0L; i < 9; i++)
			salt |= ascii_to_bin(setting[i]) << (i - 5) * 6;

		while (*key)
		{
			/*
			 * Encrypt the key with itself.
			 */
			if (des_cipher((char *) keybuf, (char *) keybuf, 0L, 1))
				return (NULL);

			/*
			 * And XOR with the next 8 characters of the key.
			 */
			q = (uint8 *) keybuf;
			while (q - (uint8 *) keybuf - 8 && *key)
				*q++ ^= *key++ << 1;

			if (des_setkey((char *) keybuf))
				return (NULL);
		}
		strncpy(output, setting, 9);

		/*
		 * Double check that we weren't given a short setting. If we were, the
		 * above code will probably have created weird values for count and
		 * salt, but we don't really care. Just make sure the output string
		 * doesn't have an extra NUL in it.
		 */
		output[9] = '\0';
		p = output + strlen(output);
	}
	else
#endif   /* !DISABLE_XDES */
	{
		/*
		 * ""old""-style: setting - 2 bytes of salt key - up to 8 characters
		 */
		count = 25;

		salt = (ascii_to_bin(setting[1]) << 6)
			| ascii_to_bin(setting[0]);

		output[0] = setting[0];

		/*
		 * If the encrypted password that the salt was extracted from is only
		 * 1 character long, the salt will be corrupted.  We need to ensure
		 * that the output string doesn't have an extra NUL in it!
		 */
		output[1] = setting[1] ? setting[1] : output[0];

		p = output + 2;
	}
	setup_salt(salt);

	/*
	 * Do it.
	 */
	if (do_des(0L, 0L, &r0, &r1, count))
		return (NULL);

	/*
	 * Now encode the result...
	 */
	l = (r0 >> 8);
	*p++ = _crypt_a64[(l >> 18) & 0x3f];
	*p++ = _crypt_a64[(l >> 12) & 0x3f];
	*p++ = _crypt_a64[(l >> 6) & 0x3f];
	*p++ = _crypt_a64[l & 0x3f];

	l = (r0 << 16) | ((r1 >> 16) & 0xffff);
	*p++ = _crypt_a64[(l >> 18) & 0x3f];
	*p++ = _crypt_a64[(l >> 12) & 0x3f];
	*p++ = _crypt_a64[(l >> 6) & 0x3f];
	*p++ = _crypt_a64[l & 0x3f];

	l = r1 << 2;
	*p++ = _crypt_a64[(l >> 12) & 0x3f];
	*p++ = _crypt_a64[(l >> 6) & 0x3f];
	*p++ = _crypt_a64[l & 0x3f];
	*p = 0;

	return (output);
}
",C,"       *q++ = *key << 1;
       if (*key != '\0')
","       if ((*q++ = *key << 1))
",d1996ed5e8bfaf1314e7817015668029c07d3b9b,"@@ -670,7 +670,8 @@ px_crypt_des(const char *key, const char *setting)
    q = (uint8 *) keybuf;
    while (q - (uint8 *) keybuf - 8)
    {
-       if ((*q++ = *key << 1))
+       *q++ = *key << 1;
+       if (*key != '\0')
            key++;
    }
    if (des_setkey((char *) keybuf))",postgresql,https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=contrib/pgcrypto/crypt-des.c;h=cc2e76a71f7b9907072f30a6a2c389068e3c9d37;hb=932ded2ed51e8333852e370c7a6dad75d9f236f9,https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=contrib/pgcrypto/crypt-des.c;h=cea80b55e998fc490cf4d93e1483d31aca19bd17,1,"px_crypt_des(const char *key, const char *setting)
{
	int			i;
	uint32		count,
				salt,
				l,
				r0,
				r1,
				keybuf[2];
	char	   *p;
	uint8	   *q;
	static char output[21];

	if (!des_initialised)
		des_init();


	/*
	 * Copy the key, shifting each character up by one bit and padding with
	 * zeros.
	 */
    q = (uint8 *) keybuf;
    while (q - (uint8 *) keybuf - 8)
    {
//flaw_line_below:
       if ((*q++ = *key << 1))
//fix_flaw_line_below:
//       *q++ = *key << 1;
//fix_flaw_line_below:
//       if (*key != '\0')
            key++;
    }
    if (des_setkey((char *) keybuf))

#ifndef DISABLE_XDES
	if (*setting == _PASSWORD_EFMT1)
	{
		/*
		 * ""new""-style: setting - underscore, 4 bytes of count, 4 bytes of
		 * salt key - unlimited characters
		 */
		for (i = 1, count = 0L; i < 5; i++)
			count |= ascii_to_bin(setting[i]) << (i - 1) * 6;

		for (i = 5, salt = 0L; i < 9; i++)
			salt |= ascii_to_bin(setting[i]) << (i - 5) * 6;

		while (*key)
		{
			/*
			 * Encrypt the key with itself.
			 */
			if (des_cipher((char *) keybuf, (char *) keybuf, 0L, 1))
				return (NULL);

			/*
			 * And XOR with the next 8 characters of the key.
			 */
			q = (uint8 *) keybuf;
			while (q - (uint8 *) keybuf - 8 && *key)
				*q++ ^= *key++ << 1;

			if (des_setkey((char *) keybuf))
				return (NULL);
		}
		strncpy(output, setting, 9);

		/*
		 * Double check that we weren't given a short setting. If we were, the
		 * above code will probably have created weird values for count and
		 * salt, but we don't really care. Just make sure the output string
		 * doesn't have an extra NUL in it.
		 */
		output[9] = '\0';
		p = output + strlen(output);
	}
	else
#endif   /* !DISABLE_XDES */
	{
		/*
		 * ""old""-style: setting - 2 bytes of salt key - up to 8 characters
		 */
		count = 25;

		salt = (ascii_to_bin(setting[1]) << 6)
			| ascii_to_bin(setting[0]);

		output[0] = setting[0];

		/*
		 * If the encrypted password that the salt was extracted from is only
		 * 1 character long, the salt will be corrupted.  We need to ensure
		 * that the output string doesn't have an extra NUL in it!
		 */
		output[1] = setting[1] ? setting[1] : output[0];

		p = output + 2;
	}
	setup_salt(salt);

	/*
	 * Do it.
	 */
	if (do_des(0L, 0L, &r0, &r1, count))
		return (NULL);

	/*
	 * Now encode the result...
	 */
	l = (r0 >> 8);
	*p++ = _crypt_a64[(l >> 18) & 0x3f];
	*p++ = _crypt_a64[(l >> 12) & 0x3f];
	*p++ = _crypt_a64[(l >> 6) & 0x3f];
	*p++ = _crypt_a64[l & 0x3f];

	l = (r0 << 16) | ((r1 >> 16) & 0xffff);
	*p++ = _crypt_a64[(l >> 18) & 0x3f];
	*p++ = _crypt_a64[(l >> 12) & 0x3f];
	*p++ = _crypt_a64[(l >> 6) & 0x3f];
	*p++ = _crypt_a64[l & 0x3f];

	l = r1 << 2;
	*p++ = _crypt_a64[(l >> 12) & 0x3f];
	*p++ = _crypt_a64[(l >> 6) & 0x3f];
	*p++ = _crypt_a64[l & 0x3f];
	*p = 0;

	return (output);
}
"
464,178200,,Remote,Not required,,CVE-2012-2143,https://www.cvedetails.com/cve/CVE-2012-2143/,CWE-310,Medium,,Partial,,2012-07-05,4.3,"The crypt_des (aka DES-based crypt) function in FreeBSD before 9.0-RELEASE-p2, as used in PHP, PostgreSQL, and other products, does not process the complete cleartext password if this password contains a 0x80 character, which makes it easier for context-dependent attackers to obtain access via an authentication attempt with an initial substring of the intended password, as demonstrated by a Unicode password.",2016-12-07,,2,https://git.php.net/?p=php-src.git;a=commit;h=aab49e934de1fff046e659cbec46e3d053b41c34,aab49e934de1fff046e659cbec46e3d053b41c34,,1,,,"_crypt_extended_r(const char *key, const char *setting,
	struct php_crypt_extended_data *data)
{
	int		i;
	uint32_t	count, salt, l, r0, r1, keybuf[2];
	u_char		*p, *q;

	if (!data->initialized)
		des_init_local(data);

	/*
	 * Copy the key, shifting each character up by one bit
	 * and padding with zeros.
         */
        q = (u_char *) keybuf;
        while (q - (u_char *) keybuf < sizeof(keybuf)) {
               *q++ = *key << 1;
               if (*key)
                        key++;
        }
        if (des_setkey((u_char *) keybuf, data))

	if (*setting == _PASSWORD_EFMT1) {
		/*
		 * ""new""-style:
		 *	setting - underscore, 4 chars of count, 4 chars of salt
		 *	key - unlimited characters
		 */
		for (i = 1, count = 0; i < 5; i++) {
			int value = ascii_to_bin(setting[i]);
			if (ascii64[value] != setting[i])
				return(NULL);
			count |= value << (i - 1) * 6;
		}
		if (!count)
			return(NULL);

		for (i = 5, salt = 0; i < 9; i++) {
			int value = ascii_to_bin(setting[i]);
			if (ascii64[value] != setting[i])
				return(NULL);
			salt |= value << (i - 5) * 6;
		}

		while (*key) {
			/*
			 * Encrypt the key with itself.
			 */
			if (des_cipher((u_char *) keybuf, (u_char *) keybuf,
			    0, 1, data))
				return(NULL);
			/*
			 * And XOR with the next 8 characters of the key.
			 */
			q = (u_char *) keybuf;
			while (q - (u_char *) keybuf < sizeof(keybuf) && *key)
				*q++ ^= *key++ << 1;

			if (des_setkey((u_char *) keybuf, data))
				return(NULL);
		}
		memcpy(data->output, setting, 9);
		data->output[9] = '\0';
		p = (u_char *) data->output + 9;
	} else {
		/*
		 * ""old""-style:
		 *	setting - 2 chars of salt
		 *	key - up to 8 characters
		 */
		count = 25;

		if (ascii_is_unsafe(setting[0]) || ascii_is_unsafe(setting[1]))
			return(NULL);

		salt = (ascii_to_bin(setting[1]) << 6)
		     |  ascii_to_bin(setting[0]);

		data->output[0] = setting[0];
		data->output[1] = setting[1];
		p = (u_char *) data->output + 2;
	}
	setup_salt(salt, data);
	/*
	 * Do it.
	 */
	if (do_des(0, 0, &r0, &r1, count, data))
		return(NULL);
	/*
	 * Now encode the result...
	 */
	l = (r0 >> 8);
	*p++ = ascii64[(l >> 18) & 0x3f];
	*p++ = ascii64[(l >> 12) & 0x3f];
	*p++ = ascii64[(l >> 6) & 0x3f];
	*p++ = ascii64[l & 0x3f];

	l = (r0 << 16) | ((r1 >> 16) & 0xffff);
	*p++ = ascii64[(l >> 18) & 0x3f];
	*p++ = ascii64[(l >> 12) & 0x3f];
	*p++ = ascii64[(l >> 6) & 0x3f];
	*p++ = ascii64[l & 0x3f];

	l = r1 << 2;
	*p++ = ascii64[(l >> 12) & 0x3f];
	*p++ = ascii64[(l >> 6) & 0x3f];
	*p++ = ascii64[l & 0x3f];
	*p = 0;

	return(data->output);
}
","_crypt_extended_r(const char *key, const char *setting,
	struct php_crypt_extended_data *data)
{
	int		i;
	uint32_t	count, salt, l, r0, r1, keybuf[2];
	u_char		*p, *q;

	if (!data->initialized)
		des_init_local(data);

	/*
	 * Copy the key, shifting each character up by one bit
	 * and padding with zeros.
         */
        q = (u_char *) keybuf;
        while (q - (u_char *) keybuf < sizeof(keybuf)) {
               if ((*q++ = *key << 1))
                        key++;
        }
        if (des_setkey((u_char *) keybuf, data))

	if (*setting == _PASSWORD_EFMT1) {
		/*
		 * ""new""-style:
		 *	setting - underscore, 4 chars of count, 4 chars of salt
		 *	key - unlimited characters
		 */
		for (i = 1, count = 0; i < 5; i++) {
			int value = ascii_to_bin(setting[i]);
			if (ascii64[value] != setting[i])
				return(NULL);
			count |= value << (i - 1) * 6;
		}
		if (!count)
			return(NULL);

		for (i = 5, salt = 0; i < 9; i++) {
			int value = ascii_to_bin(setting[i]);
			if (ascii64[value] != setting[i])
				return(NULL);
			salt |= value << (i - 5) * 6;
		}

		while (*key) {
			/*
			 * Encrypt the key with itself.
			 */
			if (des_cipher((u_char *) keybuf, (u_char *) keybuf,
			    0, 1, data))
				return(NULL);
			/*
			 * And XOR with the next 8 characters of the key.
			 */
			q = (u_char *) keybuf;
			while (q - (u_char *) keybuf < sizeof(keybuf) && *key)
				*q++ ^= *key++ << 1;

			if (des_setkey((u_char *) keybuf, data))
				return(NULL);
		}
		memcpy(data->output, setting, 9);
		data->output[9] = '\0';
		p = (u_char *) data->output + 9;
	} else {
		/*
		 * ""old""-style:
		 *	setting - 2 chars of salt
		 *	key - up to 8 characters
		 */
		count = 25;

		if (ascii_is_unsafe(setting[0]) || ascii_is_unsafe(setting[1]))
			return(NULL);

		salt = (ascii_to_bin(setting[1]) << 6)
		     |  ascii_to_bin(setting[0]);

		data->output[0] = setting[0];
		data->output[1] = setting[1];
		p = (u_char *) data->output + 2;
	}
	setup_salt(salt, data);
	/*
	 * Do it.
	 */
	if (do_des(0, 0, &r0, &r1, count, data))
		return(NULL);
	/*
	 * Now encode the result...
	 */
	l = (r0 >> 8);
	*p++ = ascii64[(l >> 18) & 0x3f];
	*p++ = ascii64[(l >> 12) & 0x3f];
	*p++ = ascii64[(l >> 6) & 0x3f];
	*p++ = ascii64[l & 0x3f];

	l = (r0 << 16) | ((r1 >> 16) & 0xffff);
	*p++ = ascii64[(l >> 18) & 0x3f];
	*p++ = ascii64[(l >> 12) & 0x3f];
	*p++ = ascii64[(l >> 6) & 0x3f];
	*p++ = ascii64[l & 0x3f];

	l = r1 << 2;
	*p++ = ascii64[(l >> 12) & 0x3f];
	*p++ = ascii64[(l >> 6) & 0x3f];
	*p++ = ascii64[l & 0x3f];
	*p = 0;

	return(data->output);
}
",C,"               *q++ = *key << 1;
               if (*key)
","               if ((*q++ = *key << 1))
",8d5e953a19a08e562448f2a0562228fd1be60715,"@@ -629,7 +629,8 @@ _crypt_extended_r(const char *key, const char *setting,
         */
        q = (u_char *) keybuf;
        while (q - (u_char *) keybuf < sizeof(keybuf)) {
-               if ((*q++ = *key << 1))
+               *q++ = *key << 1;
+               if (*key)
                        key++;
        }
        if (des_setkey((u_char *) keybuf, data))",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/standard/crypt_freesec.c;h=0a5c3ba5fa793df68dccfeef127d27466ac0856b;hb=aab49e934de1fff046e659cbec46e3d053b41c34,https://git.php.net/?p=php-src.git;a=blob;f=ext/standard/crypt_freesec.c;h=49c397cca1a96be9ee002e9a0899ae4bdd1c661a,1,"_crypt_extended_r(const char *key, const char *setting,
	struct php_crypt_extended_data *data)
{
	int		i;
	uint32_t	count, salt, l, r0, r1, keybuf[2];
	u_char		*p, *q;

	if (!data->initialized)
		des_init_local(data);

	/*
	 * Copy the key, shifting each character up by one bit
	 * and padding with zeros.
         */
        q = (u_char *) keybuf;
        while (q - (u_char *) keybuf < sizeof(keybuf)) {
//flaw_line_below:
               if ((*q++ = *key << 1))
//fix_flaw_line_below:
//               *q++ = *key << 1;
//fix_flaw_line_below:
//               if (*key)
                        key++;
        }
        if (des_setkey((u_char *) keybuf, data))

	if (*setting == _PASSWORD_EFMT1) {
		/*
		 * ""new""-style:
		 *	setting - underscore, 4 chars of count, 4 chars of salt
		 *	key - unlimited characters
		 */
		for (i = 1, count = 0; i < 5; i++) {
			int value = ascii_to_bin(setting[i]);
			if (ascii64[value] != setting[i])
				return(NULL);
			count |= value << (i - 1) * 6;
		}
		if (!count)
			return(NULL);

		for (i = 5, salt = 0; i < 9; i++) {
			int value = ascii_to_bin(setting[i]);
			if (ascii64[value] != setting[i])
				return(NULL);
			salt |= value << (i - 5) * 6;
		}

		while (*key) {
			/*
			 * Encrypt the key with itself.
			 */
			if (des_cipher((u_char *) keybuf, (u_char *) keybuf,
			    0, 1, data))
				return(NULL);
			/*
			 * And XOR with the next 8 characters of the key.
			 */
			q = (u_char *) keybuf;
			while (q - (u_char *) keybuf < sizeof(keybuf) && *key)
				*q++ ^= *key++ << 1;

			if (des_setkey((u_char *) keybuf, data))
				return(NULL);
		}
		memcpy(data->output, setting, 9);
		data->output[9] = '\0';
		p = (u_char *) data->output + 9;
	} else {
		/*
		 * ""old""-style:
		 *	setting - 2 chars of salt
		 *	key - up to 8 characters
		 */
		count = 25;

		if (ascii_is_unsafe(setting[0]) || ascii_is_unsafe(setting[1]))
			return(NULL);

		salt = (ascii_to_bin(setting[1]) << 6)
		     |  ascii_to_bin(setting[0]);

		data->output[0] = setting[0];
		data->output[1] = setting[1];
		p = (u_char *) data->output + 2;
	}
	setup_salt(salt, data);
	/*
	 * Do it.
	 */
	if (do_des(0, 0, &r0, &r1, count, data))
		return(NULL);
	/*
	 * Now encode the result...
	 */
	l = (r0 >> 8);
	*p++ = ascii64[(l >> 18) & 0x3f];
	*p++ = ascii64[(l >> 12) & 0x3f];
	*p++ = ascii64[(l >> 6) & 0x3f];
	*p++ = ascii64[l & 0x3f];

	l = (r0 << 16) | ((r1 >> 16) & 0xffff);
	*p++ = ascii64[(l >> 18) & 0x3f];
	*p++ = ascii64[(l >> 12) & 0x3f];
	*p++ = ascii64[(l >> 6) & 0x3f];
	*p++ = ascii64[l & 0x3f];

	l = r1 << 2;
	*p++ = ascii64[(l >> 12) & 0x3f];
	*p++ = ascii64[(l >> 6) & 0x3f];
	*p++ = ascii64[l & 0x3f];
	*p = 0;

	return(data->output);
}
"
517,178253,,Remote,Not required,Partial,CVE-2012-1573,https://www.cvedetails.com/cve/CVE-2012-1573/,CWE-310,Low,,,,2012-03-26,5.0,"gnutls_cipher.c in libgnutls in GnuTLS before 2.12.17 and 3.x before 3.0.15 does not properly handle data encrypted with a block cipher, which allows remote attackers to cause a denial of service (heap memory corruption and application crash) via a crafted record, as demonstrated by a crafted GenericBlockCipher structure.",2018-01-17,DoS Mem. Corr.,5,https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commit;h=422214868061370aeeb0ac9cd0f021a5c350a57d,422214868061370aeeb0ac9cd0f021a5c350a57d,,5,,,"_gnutls_ciphertext2compressed (gnutls_session_t session,
                               opaque * compress_data,
                               int compress_size,
                               gnutls_datum_t ciphertext, uint8_t type,
                               record_parameters_st * params)
{
  uint8_t MAC[MAX_HASH_SIZE];
  uint16_t c_length;
  uint8_t pad;
  int length;
  uint16_t blocksize;
  int ret, i, pad_failed = 0;
  opaque preamble[PREAMBLE_SIZE];
  int preamble_size;
  int ver = gnutls_protocol_get_version (session);
  int hash_size = _gnutls_hash_get_algo_len (params->mac_algorithm);

  blocksize = gnutls_cipher_get_block_size (params->cipher_algorithm);


  /* actual decryption (inplace)
   */
  switch (_gnutls_cipher_is_block (params->cipher_algorithm))
    {
    case CIPHER_STREAM:
      if ((ret =
           _gnutls_cipher_decrypt (&params->read.cipher_state,
                                   ciphertext.data, ciphertext.size)) < 0)
        {
          gnutls_assert ();
          return ret;
        }

      length = ciphertext.size - hash_size;

      break;
    case CIPHER_BLOCK:
      if ((ciphertext.size < blocksize) || (ciphertext.size % blocksize != 0))
        {
          gnutls_assert ();
          return GNUTLS_E_DECRYPTION_FAILED;
        }

      if ((ret =
           _gnutls_cipher_decrypt (&params->read.cipher_state,
                                   ciphertext.data, ciphertext.size)) < 0)
        {
          gnutls_assert ();
          return ret;
        }

      /* ignore the IV in TLS 1.1.
       */
      if (_gnutls_version_has_explicit_iv
          (session->security_parameters.version))
         {
           ciphertext.size -= blocksize;
           ciphertext.data += blocksize;
         }
 
      if (ciphertext.size < hash_size)
        {
          gnutls_assert ();
          return GNUTLS_E_DECRYPTION_FAILED;
        }
       pad = ciphertext.data[ciphertext.size - 1] + 1;   /* pad */
 
       if ((int) pad > (int) ciphertext.size - hash_size)
      if ((int) pad > (int) ciphertext.size - hash_size)
        {
          gnutls_assert ();
          _gnutls_record_log
            (""REC[%p]: Short record length %d > %d - %d (under attack?)\n"",
             session, pad, ciphertext.size, hash_size);
          /* We do not fail here. We check below for the
           * the pad_failed. If zero means success.
           */
          pad_failed = GNUTLS_E_DECRYPTION_FAILED;
        }

      length = ciphertext.size - hash_size - pad;

      /* Check the pading bytes (TLS 1.x)
       */
      if (_gnutls_version_has_variable_padding (ver) && pad_failed == 0)
        for (i = 2; i < pad; i++)
          {
            if (ciphertext.data[ciphertext.size - i] !=
                ciphertext.data[ciphertext.size - 1])
              pad_failed = GNUTLS_E_DECRYPTION_FAILED;
          }
      break;
    default:
      gnutls_assert ();
      return GNUTLS_E_INTERNAL_ERROR;
    }

  if (length < 0)
    length = 0;
  c_length = _gnutls_conv_uint16 ((uint16_t) length);

  /* Pass the type, version, length and compressed through
   * MAC.
   */
  if (params->mac_algorithm != GNUTLS_MAC_NULL)
    {
      digest_hd_st td;

      ret = mac_init (&td, params->mac_algorithm,
                      params->read.mac_secret.data,
                      params->read.mac_secret.size, ver);

      if (ret < 0)
        {
          gnutls_assert ();
          return GNUTLS_E_INTERNAL_ERROR;
        }

      preamble_size =
        make_preamble (UINT64DATA
                       (params->read.sequence_number), type,
                       c_length, ver, preamble);
      mac_hash (&td, preamble, preamble_size, ver);
      if (length > 0)
        mac_hash (&td, ciphertext.data, length, ver);

      mac_deinit (&td, MAC, ver);
    }

  /* This one was introduced to avoid a timing attack against the TLS
   * 1.0 protocol.
   */
  if (pad_failed != 0)
    {
      gnutls_assert ();
      return pad_failed;
    }

  /* HMAC was not the same. 
   */
  if (memcmp (MAC, &ciphertext.data[length], hash_size) != 0)
    {
      gnutls_assert ();
      return GNUTLS_E_DECRYPTION_FAILED;
    }

  /* copy the decrypted stuff to compress_data.
   */
  if (compress_size < length)
    {
      gnutls_assert ();
      return GNUTLS_E_DECOMPRESSION_FAILED;
    }
  memcpy (compress_data, ciphertext.data, length);

  return length;
}
","_gnutls_ciphertext2compressed (gnutls_session_t session,
                               opaque * compress_data,
                               int compress_size,
                               gnutls_datum_t ciphertext, uint8_t type,
                               record_parameters_st * params)
{
  uint8_t MAC[MAX_HASH_SIZE];
  uint16_t c_length;
  uint8_t pad;
  int length;
  uint16_t blocksize;
  int ret, i, pad_failed = 0;
  opaque preamble[PREAMBLE_SIZE];
  int preamble_size;
  int ver = gnutls_protocol_get_version (session);
  int hash_size = _gnutls_hash_get_algo_len (params->mac_algorithm);

  blocksize = gnutls_cipher_get_block_size (params->cipher_algorithm);


  /* actual decryption (inplace)
   */
  switch (_gnutls_cipher_is_block (params->cipher_algorithm))
    {
    case CIPHER_STREAM:
      if ((ret =
           _gnutls_cipher_decrypt (&params->read.cipher_state,
                                   ciphertext.data, ciphertext.size)) < 0)
        {
          gnutls_assert ();
          return ret;
        }

      length = ciphertext.size - hash_size;

      break;
    case CIPHER_BLOCK:
      if ((ciphertext.size < blocksize) || (ciphertext.size % blocksize != 0))
        {
          gnutls_assert ();
          return GNUTLS_E_DECRYPTION_FAILED;
        }

      if ((ret =
           _gnutls_cipher_decrypt (&params->read.cipher_state,
                                   ciphertext.data, ciphertext.size)) < 0)
        {
          gnutls_assert ();
          return ret;
        }

      /* ignore the IV in TLS 1.1.
       */
      if (_gnutls_version_has_explicit_iv
          (session->security_parameters.version))
         {
           ciphertext.size -= blocksize;
           ciphertext.data += blocksize;
          if (ciphertext.size == 0)
            {
              gnutls_assert ();
              return GNUTLS_E_DECRYPTION_FAILED;
            }
         }
 
       pad = ciphertext.data[ciphertext.size - 1] + 1;   /* pad */
 
       if ((int) pad > (int) ciphertext.size - hash_size)
      if ((int) pad > (int) ciphertext.size - hash_size)
        {
          gnutls_assert ();
          _gnutls_record_log
            (""REC[%p]: Short record length %d > %d - %d (under attack?)\n"",
             session, pad, ciphertext.size, hash_size);
          /* We do not fail here. We check below for the
           * the pad_failed. If zero means success.
           */
          pad_failed = GNUTLS_E_DECRYPTION_FAILED;
        }

      length = ciphertext.size - hash_size - pad;

      /* Check the pading bytes (TLS 1.x)
       */
      if (_gnutls_version_has_variable_padding (ver) && pad_failed == 0)
        for (i = 2; i < pad; i++)
          {
            if (ciphertext.data[ciphertext.size - i] !=
                ciphertext.data[ciphertext.size - 1])
              pad_failed = GNUTLS_E_DECRYPTION_FAILED;
          }
      break;
    default:
      gnutls_assert ();
      return GNUTLS_E_INTERNAL_ERROR;
    }

  if (length < 0)
    length = 0;
  c_length = _gnutls_conv_uint16 ((uint16_t) length);

  /* Pass the type, version, length and compressed through
   * MAC.
   */
  if (params->mac_algorithm != GNUTLS_MAC_NULL)
    {
      digest_hd_st td;

      ret = mac_init (&td, params->mac_algorithm,
                      params->read.mac_secret.data,
                      params->read.mac_secret.size, ver);

      if (ret < 0)
        {
          gnutls_assert ();
          return GNUTLS_E_INTERNAL_ERROR;
        }

      preamble_size =
        make_preamble (UINT64DATA
                       (params->read.sequence_number), type,
                       c_length, ver, preamble);
      mac_hash (&td, preamble, preamble_size, ver);
      if (length > 0)
        mac_hash (&td, ciphertext.data, length, ver);

      mac_deinit (&td, MAC, ver);
    }

  /* This one was introduced to avoid a timing attack against the TLS
   * 1.0 protocol.
   */
  if (pad_failed != 0)
    {
      gnutls_assert ();
      return pad_failed;
    }

  /* HMAC was not the same. 
   */
  if (memcmp (MAC, &ciphertext.data[length], hash_size) != 0)
    {
      gnutls_assert ();
      return GNUTLS_E_DECRYPTION_FAILED;
    }

  /* copy the decrypted stuff to compress_data.
   */
  if (compress_size < length)
    {
      gnutls_assert ();
      return GNUTLS_E_DECOMPRESSION_FAILED;
    }
  memcpy (compress_data, ciphertext.data, length);

  return length;
}
",C,"      if (ciphertext.size < hash_size)
        {
          gnutls_assert ();
          return GNUTLS_E_DECRYPTION_FAILED;
        }
","          if (ciphertext.size == 0)
            {
              gnutls_assert ();
              return GNUTLS_E_DECRYPTION_FAILED;
            }
",cfea38b5482c21fe6ddffaddc59a0040f80bd578,"@@ -511,14 +511,13 @@ _gnutls_ciphertext2compressed (gnutls_session_t session,
         {
           ciphertext.size -= blocksize;
           ciphertext.data += blocksize;
-
-          if (ciphertext.size == 0)
-            {
-              gnutls_assert ();
-              return GNUTLS_E_DECRYPTION_FAILED;
-            }
         }
 
+      if (ciphertext.size < hash_size)
+        {
+          gnutls_assert ();
+          return GNUTLS_E_DECRYPTION_FAILED;
+        }
       pad = ciphertext.data[ciphertext.size - 1] + 1;   /* pad */
 
       if ((int) pad > (int) ciphertext.size - hash_size)",savannah,https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=blob;f=lib/gnutls_cipher.c;h=6b832083648d83d585a195edbc19c6d12f52791f;hb=422214868061370aeeb0ac9cd0f021a5c350a57d,https://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=blob;f=lib/gnutls_cipher.c;h=22d02f64f08050da0ef4ff1bb5d2c57fc1f92602,1,"_gnutls_ciphertext2compressed (gnutls_session_t session,
                               opaque * compress_data,
                               int compress_size,
                               gnutls_datum_t ciphertext, uint8_t type,
                               record_parameters_st * params)
{
  uint8_t MAC[MAX_HASH_SIZE];
  uint16_t c_length;
  uint8_t pad;
  int length;
  uint16_t blocksize;
  int ret, i, pad_failed = 0;
  opaque preamble[PREAMBLE_SIZE];
  int preamble_size;
  int ver = gnutls_protocol_get_version (session);
  int hash_size = _gnutls_hash_get_algo_len (params->mac_algorithm);

  blocksize = gnutls_cipher_get_block_size (params->cipher_algorithm);


  /* actual decryption (inplace)
   */
  switch (_gnutls_cipher_is_block (params->cipher_algorithm))
    {
    case CIPHER_STREAM:
      if ((ret =
           _gnutls_cipher_decrypt (&params->read.cipher_state,
                                   ciphertext.data, ciphertext.size)) < 0)
        {
          gnutls_assert ();
          return ret;
        }

      length = ciphertext.size - hash_size;

      break;
    case CIPHER_BLOCK:
      if ((ciphertext.size < blocksize) || (ciphertext.size % blocksize != 0))
        {
          gnutls_assert ();
          return GNUTLS_E_DECRYPTION_FAILED;
        }

      if ((ret =
           _gnutls_cipher_decrypt (&params->read.cipher_state,
                                   ciphertext.data, ciphertext.size)) < 0)
        {
          gnutls_assert ();
          return ret;
        }

      /* ignore the IV in TLS 1.1.
       */
      if (_gnutls_version_has_explicit_iv
          (session->security_parameters.version))
         {
           ciphertext.size -= blocksize;
           ciphertext.data += blocksize;
//flaw_line_below:

//flaw_line_below:
          if (ciphertext.size == 0)
//flaw_line_below:
            {
//flaw_line_below:
              gnutls_assert ();
//flaw_line_below:
              return GNUTLS_E_DECRYPTION_FAILED;
//flaw_line_below:
            }
         }
 
//fix_flaw_line_below:
//      if (ciphertext.size < hash_size)
//fix_flaw_line_below:
//        {
//fix_flaw_line_below:
//          gnutls_assert ();
//fix_flaw_line_below:
//          return GNUTLS_E_DECRYPTION_FAILED;
//fix_flaw_line_below:
//        }
       pad = ciphertext.data[ciphertext.size - 1] + 1;   /* pad */
 
       if ((int) pad > (int) ciphertext.size - hash_size)
      if ((int) pad > (int) ciphertext.size - hash_size)
        {
          gnutls_assert ();
          _gnutls_record_log
            (""REC[%p]: Short record length %d > %d - %d (under attack?)\n"",
             session, pad, ciphertext.size, hash_size);
          /* We do not fail here. We check below for the
           * the pad_failed. If zero means success.
           */
          pad_failed = GNUTLS_E_DECRYPTION_FAILED;
        }

      length = ciphertext.size - hash_size - pad;

      /* Check the pading bytes (TLS 1.x)
       */
      if (_gnutls_version_has_variable_padding (ver) && pad_failed == 0)
        for (i = 2; i < pad; i++)
          {
            if (ciphertext.data[ciphertext.size - i] !=
                ciphertext.data[ciphertext.size - 1])
              pad_failed = GNUTLS_E_DECRYPTION_FAILED;
          }
      break;
    default:
      gnutls_assert ();
      return GNUTLS_E_INTERNAL_ERROR;
    }

  if (length < 0)
    length = 0;
  c_length = _gnutls_conv_uint16 ((uint16_t) length);

  /* Pass the type, version, length and compressed through
   * MAC.
   */
  if (params->mac_algorithm != GNUTLS_MAC_NULL)
    {
      digest_hd_st td;

      ret = mac_init (&td, params->mac_algorithm,
                      params->read.mac_secret.data,
                      params->read.mac_secret.size, ver);

      if (ret < 0)
        {
          gnutls_assert ();
          return GNUTLS_E_INTERNAL_ERROR;
        }

      preamble_size =
        make_preamble (UINT64DATA
                       (params->read.sequence_number), type,
                       c_length, ver, preamble);
      mac_hash (&td, preamble, preamble_size, ver);
      if (length > 0)
        mac_hash (&td, ciphertext.data, length, ver);

      mac_deinit (&td, MAC, ver);
    }

  /* This one was introduced to avoid a timing attack against the TLS
   * 1.0 protocol.
   */
  if (pad_failed != 0)
    {
      gnutls_assert ();
      return pad_failed;
    }

  /* HMAC was not the same. 
   */
  if (memcmp (MAC, &ciphertext.data[length], hash_size) != 0)
    {
      gnutls_assert ();
      return GNUTLS_E_DECRYPTION_FAILED;
    }

  /* copy the decrypted stuff to compress_data.
   */
  if (compress_size < length)
    {
      gnutls_assert ();
      return GNUTLS_E_DECOMPRESSION_FAILED;
    }
  memcpy (compress_data, ciphertext.data, length);

  return length;
}
"
592,178328,,Remote,Not required,,CVE-2014-3568,https://www.cvedetails.com/cve/CVE-2014-3568/,CWE-310,Medium,,Partial,,2014-10-18,4.3,"OpenSSL before 0.9.8zc, 1.0.0 before 1.0.0o, and 1.0.1 before 1.0.1j does not properly enforce the no-ssl3 build option, which allows remote attackers to bypass intended access restrictions via an SSL 3.0 handshake, related to s23_clnt.c and s23_srvr.c.",2017-11-14,Bypass,3,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=26a59d9b46574e457870197dffa802871b4c8fc7,26a59d9b46574e457870197dffa802871b4c8fc7,,1,,,"static const SSL_METHOD *ssl23_get_client_method(int ver)
	{
#ifndef OPENSSL_NO_SSL2
        if (ver == SSL2_VERSION)
                return(SSLv2_client_method());
 #endif
#ifndef OPENSSL_NO_SSL3
        if (ver == SSL3_VERSION)
                return(SSLv3_client_method());
#endif
       if (ver == TLS1_VERSION)
                return(TLSv1_client_method());
        else if (ver == TLS1_1_VERSION)
                return(TLSv1_1_client_method());
	else
		return(NULL);
	}
","static const SSL_METHOD *ssl23_get_client_method(int ver)
	{
#ifndef OPENSSL_NO_SSL2
        if (ver == SSL2_VERSION)
                return(SSLv2_client_method());
 #endif
        if (ver == SSL3_VERSION)
                return(SSLv3_client_method());
       else if (ver == TLS1_VERSION)
                return(TLSv1_client_method());
        else if (ver == TLS1_1_VERSION)
                return(TLSv1_1_client_method());
	else
		return(NULL);
	}
",C,"#ifndef OPENSSL_NO_SSL3
#endif
       if (ver == TLS1_VERSION)
","       else if (ver == TLS1_VERSION)
",7fd4ce6a997be5f5c9e744ac527725c2850de203,"@@ -125,9 +125,11 @@ static const SSL_METHOD *ssl23_get_client_method(int ver)
        if (ver == SSL2_VERSION)
                return(SSLv2_client_method());
 #endif
+#ifndef OPENSSL_NO_SSL3
        if (ver == SSL3_VERSION)
                return(SSLv3_client_method());
-       else if (ver == TLS1_VERSION)
+#endif
+       if (ver == TLS1_VERSION)
                return(TLSv1_client_method());
        else if (ver == TLS1_1_VERSION)
                return(TLSv1_1_client_method());
@@ -698,6 +700,7 @@ static int ssl23_get_server_hello(SSL *s)
                {
                /* we have sslv3 or tls1 (server hello or alert) */
 
+#ifndef OPENSSL_NO_SSL3
                if ((p[2] == SSL3_VERSION_MINOR) &&
                        !(s->options & SSL_OP_NO_SSLv3))
                        {
@@ -712,7 +715,9 @@ static int ssl23_get_server_hello(SSL *s)
                        s->version=SSL3_VERSION;
                        s->method=SSLv3_client_method();
                        }
-               else if ((p[2] == TLS1_VERSION_MINOR) &&
+               else
+#endif
+               if ((p[2] == TLS1_VERSION_MINOR) &&
                        !(s->options & SSL_OP_NO_TLSv1))
                        {
                        s->version=TLS1_VERSION;",openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=ssl/s23_clnt.c;h=86ab3de1c1236ec0959df7e8eddfb988da2d1b24;hb=26a59d9b46574e457870197dffa802871b4c8fc7,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=ssl/s23_clnt.c;h=d4e43c3568bb5e7a04bbaeff1f4a2b7ac22dc367,1,"static const SSL_METHOD *ssl23_get_client_method(int ver)
	{
#ifndef OPENSSL_NO_SSL2
        if (ver == SSL2_VERSION)
                return(SSLv2_client_method());
 #endif
//fix_flaw_line_below:
//#ifndef OPENSSL_NO_SSL3
        if (ver == SSL3_VERSION)
                return(SSLv3_client_method());
//flaw_line_below:
       else if (ver == TLS1_VERSION)
//fix_flaw_line_below:
//#endif
//fix_flaw_line_below:
//       if (ver == TLS1_VERSION)
                return(TLSv1_client_method());
        else if (ver == TLS1_1_VERSION)
                return(TLSv1_1_client_method());
	else
		return(NULL);
	}
"
593,178329,,Remote,Not required,,CVE-2014-3568,https://www.cvedetails.com/cve/CVE-2014-3568/,CWE-310,Medium,,Partial,,2014-10-18,4.3,"OpenSSL before 0.9.8zc, 1.0.0 before 1.0.0o, and 1.0.1 before 1.0.1j does not properly enforce the no-ssl3 build option, which allows remote attackers to bypass intended access restrictions via an SSL 3.0 handshake, related to s23_clnt.c and s23_srvr.c.",2017-11-14,Bypass,6,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=26a59d9b46574e457870197dffa802871b4c8fc7,26a59d9b46574e457870197dffa802871b4c8fc7,,8,,,"int ssl23_get_client_hello(SSL *s)
	{
	char buf_space[11]; /* Request this many bytes in initial read.
	                     * We can detect SSL 3.0/TLS 1.0 Client Hellos
	                     * ('type == 3') correctly only when the following
	                     * is in a single record, which is not guaranteed by
	                     * the protocol specification:
	                     * Byte  Content
	                     *  0     type            \
	                     *  1/2   version          > record header
	                     *  3/4   length          /
	                     *  5     msg_type        \
	                     *  6-8   length           > Client Hello message
	                     *  9/10  client_version  /
	                     */
	char *buf= &(buf_space[0]);
	unsigned char *p,*d,*d_len,*dd;
	unsigned int i;
	unsigned int csl,sil,cl;
	int n=0,j;
	int type=0;
	int v[2];

	if (s->state ==	SSL23_ST_SR_CLNT_HELLO_A)
		{
		/* read the initial header */
		v[0]=v[1]=0;

		if (!ssl3_setup_buffers(s)) goto err;

		n=ssl23_read_bytes(s, sizeof buf_space);
		if (n != sizeof buf_space) return(n); /* n == -1 || n == 0 */

		p=s->packet;

		memcpy(buf,p,n);

		if ((p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO))
			{
			/*
			 * SSLv2 header
			 */
			if ((p[3] == 0x00) && (p[4] == 0x02))
				{
				v[0]=p[3]; v[1]=p[4];
				/* SSLv2 */
				if (!(s->options & SSL_OP_NO_SSLv2))
					type=1;
				}
			else if (p[3] == SSL3_VERSION_MAJOR)
				{
				v[0]=p[3]; v[1]=p[4];
				/* SSLv3/TLSv1 */
				if (p[4] >= TLS1_VERSION_MINOR)
					{
					if (p[4] >= TLS1_2_VERSION_MINOR &&
					   !(s->options & SSL_OP_NO_TLSv1_2))
						{
						s->version=TLS1_2_VERSION;
						s->state=SSL23_ST_SR_CLNT_HELLO_B;
						}
					else if (p[4] >= TLS1_1_VERSION_MINOR &&
					   !(s->options & SSL_OP_NO_TLSv1_1))
						{
						s->version=TLS1_1_VERSION;
						/* type=2; */ /* done later to survive restarts */
						s->state=SSL23_ST_SR_CLNT_HELLO_B;
						}
					else if (!(s->options & SSL_OP_NO_TLSv1))
						{
						s->version=TLS1_VERSION;
						/* type=2; */ /* done later to survive restarts */
						s->state=SSL23_ST_SR_CLNT_HELLO_B;
						}
					else if (!(s->options & SSL_OP_NO_SSLv3))
						{
						s->version=SSL3_VERSION;
						/* type=2; */
						s->state=SSL23_ST_SR_CLNT_HELLO_B;
						}
					else if (!(s->options & SSL_OP_NO_SSLv2))
						{
						type=1;
						}
					}
				else if (!(s->options & SSL_OP_NO_SSLv3))
					{
					s->version=SSL3_VERSION;
					/* type=2; */
					s->state=SSL23_ST_SR_CLNT_HELLO_B;
					}
				else if (!(s->options & SSL_OP_NO_SSLv2))
					type=1;

				}
			}
		else if ((p[0] == SSL3_RT_HANDSHAKE) &&
			 (p[1] == SSL3_VERSION_MAJOR) &&
			 (p[5] == SSL3_MT_CLIENT_HELLO) &&
			 ((p[3] == 0 && p[4] < 5 /* silly record length? */)
				|| (p[9] >= p[1])))
			{
			/*
			 * SSLv3 or tls1 header
			 */
			
			v[0]=p[1]; /* major version (= SSL3_VERSION_MAJOR) */
			/* We must look at client_version inside the Client Hello message
			 * to get the correct minor version.
			 * However if we have only a pathologically small fragment of the
			 * Client Hello message, this would be difficult, and we'd have
			 * to read more records to find out.
			 * No known SSL 3.0 client fragments ClientHello like this,
			 * so we simply reject such connections to avoid
			 * protocol version downgrade attacks. */
			if (p[3] == 0 && p[4] < 6)
				{
				SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_SMALL);
				goto err;
				}
			/* if major version number > 3 set minor to a value
			 * which will use the highest version 3 we support.
			 * If TLS 2.0 ever appears we will need to revise
			 * this....
			 */
			if (p[9] > SSL3_VERSION_MAJOR)
				v[1]=0xff;
			else
				v[1]=p[10]; /* minor version according to client_version */
			if (v[1] >= TLS1_VERSION_MINOR)
				{
				if (v[1] >= TLS1_2_VERSION_MINOR &&
					!(s->options & SSL_OP_NO_TLSv1_2))
					{
					s->version=TLS1_2_VERSION;
					type=3;
					}
				else if (v[1] >= TLS1_1_VERSION_MINOR &&
					!(s->options & SSL_OP_NO_TLSv1_1))
					{
					s->version=TLS1_1_VERSION;
					type=3;
					}
				else if (!(s->options & SSL_OP_NO_TLSv1))
					{
					s->version=TLS1_VERSION;
					type=3;
					}
				else if (!(s->options & SSL_OP_NO_SSLv3))
					{
					s->version=SSL3_VERSION;
					type=3;
					}
				}
			else
				{
				/* client requests SSL 3.0 */
				if (!(s->options & SSL_OP_NO_SSLv3))
					{
					s->version=SSL3_VERSION;
					type=3;
					}
				else if (!(s->options & SSL_OP_NO_TLSv1))
					{
					/* we won't be able to use TLS of course,
					 * but this will send an appropriate alert */
					s->version=TLS1_VERSION;
					type=3;
					}
				}
			}
		else if ((strncmp(""GET "", (char *)p,4) == 0) ||
			 (strncmp(""POST "",(char *)p,5) == 0) ||
			 (strncmp(""HEAD "",(char *)p,5) == 0) ||
			 (strncmp(""PUT "", (char *)p,4) == 0))
			{
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTP_REQUEST);
			goto err;
			}
		else if (strncmp(""CONNECT"",(char *)p,7) == 0)
			{
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTPS_PROXY_REQUEST);
			goto err;
			}
		}

	/* ensure that TLS_MAX_VERSION is up-to-date */
	OPENSSL_assert(s->version <= TLS_MAX_VERSION);

#ifdef OPENSSL_FIPS
	if (FIPS_mode() && (s->version < TLS1_VERSION))
		{
		SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,
					SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
		goto err;
		}
#endif

	if (s->state == SSL23_ST_SR_CLNT_HELLO_B)
		{
		/* we have SSLv3/TLSv1 in an SSLv2 header
		 * (other cases skip this state) */

		type=2;
		p=s->packet;
		v[0] = p[3]; /* == SSL3_VERSION_MAJOR */
		v[1] = p[4];

		/* An SSLv3/TLSv1 backwards-compatible CLIENT-HELLO in an SSLv2
		 * header is sent directly on the wire, not wrapped as a TLS
		 * record. It's format is:
		 * Byte  Content
		 * 0-1   msg_length
		 * 2     msg_type
		 * 3-4   version
		 * 5-6   cipher_spec_length
		 * 7-8   session_id_length
		 * 9-10  challenge_length
		 * ...   ...
		 */
		n=((p[0]&0x7f)<<8)|p[1];
		if (n > (1024*4))
			{
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_LARGE);
			goto err;
			}
		if (n < 9)
			{
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH);
			goto err;
			}

		j=ssl23_read_bytes(s,n+2);
		/* We previously read 11 bytes, so if j > 0, we must have
		 * j == n+2 == s->packet_length. We have at least 11 valid
		 * packet bytes. */
		if (j <= 0) return(j);

		ssl3_finish_mac(s, s->packet+2, s->packet_length-2);
		if (s->msg_callback)
			s->msg_callback(0, SSL2_VERSION, 0, s->packet+2, s->packet_length-2, s, s->msg_callback_arg); /* CLIENT-HELLO */

		p=s->packet;
		p+=5;
		n2s(p,csl);
		n2s(p,sil);
		n2s(p,cl);
		d=(unsigned char *)s->init_buf->data;
		if ((csl+sil+cl+11) != s->packet_length) /* We can't have TLS extensions in SSL 2.0 format
		                                          * Client Hello, can we? Error condition should be
		                                          * '>' otherweise */
			{
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH);
			goto err;
			}

		/* record header: msg_type ... */
		*(d++) = SSL3_MT_CLIENT_HELLO;
		/* ... and length (actual value will be written later) */
		d_len = d;
		d += 3;

		/* client_version */
		*(d++) = SSL3_VERSION_MAJOR; /* == v[0] */
		*(d++) = v[1];

		/* lets populate the random area */
		/* get the challenge_length */
		i=(cl > SSL3_RANDOM_SIZE)?SSL3_RANDOM_SIZE:cl;
		memset(d,0,SSL3_RANDOM_SIZE);
		memcpy(&(d[SSL3_RANDOM_SIZE-i]),&(p[csl+sil]),i);
		d+=SSL3_RANDOM_SIZE;

		/* no session-id reuse */
		*(d++)=0;

		/* ciphers */
		j=0;
		dd=d;
		d+=2;
		for (i=0; i<csl; i+=3)
			{
			if (p[i] != 0) continue;
			*(d++)=p[i+1];
			*(d++)=p[i+2];
			j+=2;
			}
		s2n(j,dd);

		/* COMPRESSION */
		*(d++)=1;
		*(d++)=0;
		
#if 0
                /* copy any remaining data with may be extensions */
	        p = p+csl+sil+cl;
		while (p <  s->packet+s->packet_length)
			{
			*(d++)=*(p++);
			}
#endif

		i = (d-(unsigned char *)s->init_buf->data) - 4;
		l2n3((long)i, d_len);

		/* get the data reused from the init_buf */
		s->s3->tmp.reuse_message=1;
		s->s3->tmp.message_type=SSL3_MT_CLIENT_HELLO;
		s->s3->tmp.message_size=i;
		}

	/* imaginary new state (for program structure): */
	/* s->state = SSL23_SR_CLNT_HELLO_C */

	if (type == 1)
		{
#ifdef OPENSSL_NO_SSL2
		SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);
		goto err;
#else
		/* we are talking sslv2 */
		/* we need to clean up the SSLv3/TLSv1 setup and put in the
		 * sslv2 stuff. */

		if (s->s2 == NULL)
			{
			if (!ssl2_new(s))
				goto err;
			}
		else
			ssl2_clear(s);

		if (s->s3 != NULL) ssl3_free(s);

		if (!BUF_MEM_grow_clean(s->init_buf,
			SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))
			{
			goto err;
			}

		s->state=SSL2_ST_GET_CLIENT_HELLO_A;
		if (s->options & SSL_OP_NO_TLSv1 && s->options & SSL_OP_NO_SSLv3)
			s->s2->ssl2_rollback=0;
		else
			/* reject SSL 2.0 session if client supports SSL 3.0 or TLS 1.0
			 * (SSL 3.0 draft/RFC 2246, App. E.2) */
			s->s2->ssl2_rollback=1;

		/* setup the n bytes we have read so we get them from
		 * the sslv2 buffer */
		s->rstate=SSL_ST_READ_HEADER;
		s->packet_length=n;
		s->packet= &(s->s2->rbuf[0]);
		memcpy(s->packet,buf,n);
		s->s2->rbuf_left=n;
		s->s2->rbuf_offs=0;

		s->method=SSLv2_server_method();
		s->handshake_func=s->method->ssl_accept;
#endif
		}

	if ((type == 2) || (type == 3))
		{
        if ((type == 2) || (type == 3))
                {
                /* we have SSLv3/TLSv1 (type 2: SSL2 style, type 3: SSL3/TLS style) */
                s->method = ssl23_get_server_method(s->version);
               if (s->method == NULL)
                       {
                       SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);
                       goto err;
                       }
 
                if (!ssl_init_wbio_buffer(s,1)) goto err;
 
			s->packet_length=n;
			if (s->s3->rbuf.buf == NULL)
				if (!ssl3_setup_read_buffer(s))
					goto err;

			s->packet= &(s->s3->rbuf.buf[0]);
			memcpy(s->packet,buf,n);
			s->s3->rbuf.left=n;
			s->s3->rbuf.offset=0;
			}
		else
			{
			s->packet_length=0;
			s->s3->rbuf.left=0;
			s->s3->rbuf.offset=0;
			}
		if (s->version == TLS1_2_VERSION)
			s->method = TLSv1_2_server_method();
		else if (s->version == TLS1_1_VERSION)
			s->method = TLSv1_1_server_method();
		else if (s->version == TLS1_VERSION)
                        s->s3->rbuf.left=0;
                        s->s3->rbuf.offset=0;
                        }
 #if 0 /* ssl3_get_client_hello does this */
                s->client_version=(v[0]<<8)|v[1];
 #endif
		s->handshake_func=s->method->ssl_accept;
		}
","int ssl23_get_client_hello(SSL *s)
	{
	char buf_space[11]; /* Request this many bytes in initial read.
	                     * We can detect SSL 3.0/TLS 1.0 Client Hellos
	                     * ('type == 3') correctly only when the following
	                     * is in a single record, which is not guaranteed by
	                     * the protocol specification:
	                     * Byte  Content
	                     *  0     type            \
	                     *  1/2   version          > record header
	                     *  3/4   length          /
	                     *  5     msg_type        \
	                     *  6-8   length           > Client Hello message
	                     *  9/10  client_version  /
	                     */
	char *buf= &(buf_space[0]);
	unsigned char *p,*d,*d_len,*dd;
	unsigned int i;
	unsigned int csl,sil,cl;
	int n=0,j;
	int type=0;
	int v[2];

	if (s->state ==	SSL23_ST_SR_CLNT_HELLO_A)
		{
		/* read the initial header */
		v[0]=v[1]=0;

		if (!ssl3_setup_buffers(s)) goto err;

		n=ssl23_read_bytes(s, sizeof buf_space);
		if (n != sizeof buf_space) return(n); /* n == -1 || n == 0 */

		p=s->packet;

		memcpy(buf,p,n);

		if ((p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO))
			{
			/*
			 * SSLv2 header
			 */
			if ((p[3] == 0x00) && (p[4] == 0x02))
				{
				v[0]=p[3]; v[1]=p[4];
				/* SSLv2 */
				if (!(s->options & SSL_OP_NO_SSLv2))
					type=1;
				}
			else if (p[3] == SSL3_VERSION_MAJOR)
				{
				v[0]=p[3]; v[1]=p[4];
				/* SSLv3/TLSv1 */
				if (p[4] >= TLS1_VERSION_MINOR)
					{
					if (p[4] >= TLS1_2_VERSION_MINOR &&
					   !(s->options & SSL_OP_NO_TLSv1_2))
						{
						s->version=TLS1_2_VERSION;
						s->state=SSL23_ST_SR_CLNT_HELLO_B;
						}
					else if (p[4] >= TLS1_1_VERSION_MINOR &&
					   !(s->options & SSL_OP_NO_TLSv1_1))
						{
						s->version=TLS1_1_VERSION;
						/* type=2; */ /* done later to survive restarts */
						s->state=SSL23_ST_SR_CLNT_HELLO_B;
						}
					else if (!(s->options & SSL_OP_NO_TLSv1))
						{
						s->version=TLS1_VERSION;
						/* type=2; */ /* done later to survive restarts */
						s->state=SSL23_ST_SR_CLNT_HELLO_B;
						}
					else if (!(s->options & SSL_OP_NO_SSLv3))
						{
						s->version=SSL3_VERSION;
						/* type=2; */
						s->state=SSL23_ST_SR_CLNT_HELLO_B;
						}
					else if (!(s->options & SSL_OP_NO_SSLv2))
						{
						type=1;
						}
					}
				else if (!(s->options & SSL_OP_NO_SSLv3))
					{
					s->version=SSL3_VERSION;
					/* type=2; */
					s->state=SSL23_ST_SR_CLNT_HELLO_B;
					}
				else if (!(s->options & SSL_OP_NO_SSLv2))
					type=1;

				}
			}
		else if ((p[0] == SSL3_RT_HANDSHAKE) &&
			 (p[1] == SSL3_VERSION_MAJOR) &&
			 (p[5] == SSL3_MT_CLIENT_HELLO) &&
			 ((p[3] == 0 && p[4] < 5 /* silly record length? */)
				|| (p[9] >= p[1])))
			{
			/*
			 * SSLv3 or tls1 header
			 */
			
			v[0]=p[1]; /* major version (= SSL3_VERSION_MAJOR) */
			/* We must look at client_version inside the Client Hello message
			 * to get the correct minor version.
			 * However if we have only a pathologically small fragment of the
			 * Client Hello message, this would be difficult, and we'd have
			 * to read more records to find out.
			 * No known SSL 3.0 client fragments ClientHello like this,
			 * so we simply reject such connections to avoid
			 * protocol version downgrade attacks. */
			if (p[3] == 0 && p[4] < 6)
				{
				SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_SMALL);
				goto err;
				}
			/* if major version number > 3 set minor to a value
			 * which will use the highest version 3 we support.
			 * If TLS 2.0 ever appears we will need to revise
			 * this....
			 */
			if (p[9] > SSL3_VERSION_MAJOR)
				v[1]=0xff;
			else
				v[1]=p[10]; /* minor version according to client_version */
			if (v[1] >= TLS1_VERSION_MINOR)
				{
				if (v[1] >= TLS1_2_VERSION_MINOR &&
					!(s->options & SSL_OP_NO_TLSv1_2))
					{
					s->version=TLS1_2_VERSION;
					type=3;
					}
				else if (v[1] >= TLS1_1_VERSION_MINOR &&
					!(s->options & SSL_OP_NO_TLSv1_1))
					{
					s->version=TLS1_1_VERSION;
					type=3;
					}
				else if (!(s->options & SSL_OP_NO_TLSv1))
					{
					s->version=TLS1_VERSION;
					type=3;
					}
				else if (!(s->options & SSL_OP_NO_SSLv3))
					{
					s->version=SSL3_VERSION;
					type=3;
					}
				}
			else
				{
				/* client requests SSL 3.0 */
				if (!(s->options & SSL_OP_NO_SSLv3))
					{
					s->version=SSL3_VERSION;
					type=3;
					}
				else if (!(s->options & SSL_OP_NO_TLSv1))
					{
					/* we won't be able to use TLS of course,
					 * but this will send an appropriate alert */
					s->version=TLS1_VERSION;
					type=3;
					}
				}
			}
		else if ((strncmp(""GET "", (char *)p,4) == 0) ||
			 (strncmp(""POST "",(char *)p,5) == 0) ||
			 (strncmp(""HEAD "",(char *)p,5) == 0) ||
			 (strncmp(""PUT "", (char *)p,4) == 0))
			{
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTP_REQUEST);
			goto err;
			}
		else if (strncmp(""CONNECT"",(char *)p,7) == 0)
			{
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTPS_PROXY_REQUEST);
			goto err;
			}
		}

	/* ensure that TLS_MAX_VERSION is up-to-date */
	OPENSSL_assert(s->version <= TLS_MAX_VERSION);

#ifdef OPENSSL_FIPS
	if (FIPS_mode() && (s->version < TLS1_VERSION))
		{
		SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,
					SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
		goto err;
		}
#endif

	if (s->state == SSL23_ST_SR_CLNT_HELLO_B)
		{
		/* we have SSLv3/TLSv1 in an SSLv2 header
		 * (other cases skip this state) */

		type=2;
		p=s->packet;
		v[0] = p[3]; /* == SSL3_VERSION_MAJOR */
		v[1] = p[4];

		/* An SSLv3/TLSv1 backwards-compatible CLIENT-HELLO in an SSLv2
		 * header is sent directly on the wire, not wrapped as a TLS
		 * record. It's format is:
		 * Byte  Content
		 * 0-1   msg_length
		 * 2     msg_type
		 * 3-4   version
		 * 5-6   cipher_spec_length
		 * 7-8   session_id_length
		 * 9-10  challenge_length
		 * ...   ...
		 */
		n=((p[0]&0x7f)<<8)|p[1];
		if (n > (1024*4))
			{
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_LARGE);
			goto err;
			}
		if (n < 9)
			{
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH);
			goto err;
			}

		j=ssl23_read_bytes(s,n+2);
		/* We previously read 11 bytes, so if j > 0, we must have
		 * j == n+2 == s->packet_length. We have at least 11 valid
		 * packet bytes. */
		if (j <= 0) return(j);

		ssl3_finish_mac(s, s->packet+2, s->packet_length-2);
		if (s->msg_callback)
			s->msg_callback(0, SSL2_VERSION, 0, s->packet+2, s->packet_length-2, s, s->msg_callback_arg); /* CLIENT-HELLO */

		p=s->packet;
		p+=5;
		n2s(p,csl);
		n2s(p,sil);
		n2s(p,cl);
		d=(unsigned char *)s->init_buf->data;
		if ((csl+sil+cl+11) != s->packet_length) /* We can't have TLS extensions in SSL 2.0 format
		                                          * Client Hello, can we? Error condition should be
		                                          * '>' otherweise */
			{
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH);
			goto err;
			}

		/* record header: msg_type ... */
		*(d++) = SSL3_MT_CLIENT_HELLO;
		/* ... and length (actual value will be written later) */
		d_len = d;
		d += 3;

		/* client_version */
		*(d++) = SSL3_VERSION_MAJOR; /* == v[0] */
		*(d++) = v[1];

		/* lets populate the random area */
		/* get the challenge_length */
		i=(cl > SSL3_RANDOM_SIZE)?SSL3_RANDOM_SIZE:cl;
		memset(d,0,SSL3_RANDOM_SIZE);
		memcpy(&(d[SSL3_RANDOM_SIZE-i]),&(p[csl+sil]),i);
		d+=SSL3_RANDOM_SIZE;

		/* no session-id reuse */
		*(d++)=0;

		/* ciphers */
		j=0;
		dd=d;
		d+=2;
		for (i=0; i<csl; i+=3)
			{
			if (p[i] != 0) continue;
			*(d++)=p[i+1];
			*(d++)=p[i+2];
			j+=2;
			}
		s2n(j,dd);

		/* COMPRESSION */
		*(d++)=1;
		*(d++)=0;
		
#if 0
                /* copy any remaining data with may be extensions */
	        p = p+csl+sil+cl;
		while (p <  s->packet+s->packet_length)
			{
			*(d++)=*(p++);
			}
#endif

		i = (d-(unsigned char *)s->init_buf->data) - 4;
		l2n3((long)i, d_len);

		/* get the data reused from the init_buf */
		s->s3->tmp.reuse_message=1;
		s->s3->tmp.message_type=SSL3_MT_CLIENT_HELLO;
		s->s3->tmp.message_size=i;
		}

	/* imaginary new state (for program structure): */
	/* s->state = SSL23_SR_CLNT_HELLO_C */

	if (type == 1)
		{
#ifdef OPENSSL_NO_SSL2
		SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);
		goto err;
#else
		/* we are talking sslv2 */
		/* we need to clean up the SSLv3/TLSv1 setup and put in the
		 * sslv2 stuff. */

		if (s->s2 == NULL)
			{
			if (!ssl2_new(s))
				goto err;
			}
		else
			ssl2_clear(s);

		if (s->s3 != NULL) ssl3_free(s);

		if (!BUF_MEM_grow_clean(s->init_buf,
			SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))
			{
			goto err;
			}

		s->state=SSL2_ST_GET_CLIENT_HELLO_A;
		if (s->options & SSL_OP_NO_TLSv1 && s->options & SSL_OP_NO_SSLv3)
			s->s2->ssl2_rollback=0;
		else
			/* reject SSL 2.0 session if client supports SSL 3.0 or TLS 1.0
			 * (SSL 3.0 draft/RFC 2246, App. E.2) */
			s->s2->ssl2_rollback=1;

		/* setup the n bytes we have read so we get them from
		 * the sslv2 buffer */
		s->rstate=SSL_ST_READ_HEADER;
		s->packet_length=n;
		s->packet= &(s->s2->rbuf[0]);
		memcpy(s->packet,buf,n);
		s->s2->rbuf_left=n;
		s->s2->rbuf_offs=0;

		s->method=SSLv2_server_method();
		s->handshake_func=s->method->ssl_accept;
#endif
		}

	if ((type == 2) || (type == 3))
		{
        if ((type == 2) || (type == 3))
                {
                /* we have SSLv3/TLSv1 (type 2: SSL2 style, type 3: SSL3/TLS style) */
 
                if (!ssl_init_wbio_buffer(s,1)) goto err;
 
			s->packet_length=n;
			if (s->s3->rbuf.buf == NULL)
				if (!ssl3_setup_read_buffer(s))
					goto err;

			s->packet= &(s->s3->rbuf.buf[0]);
			memcpy(s->packet,buf,n);
			s->s3->rbuf.left=n;
			s->s3->rbuf.offset=0;
			}
		else
			{
			s->packet_length=0;
			s->s3->rbuf.left=0;
			s->s3->rbuf.offset=0;
			}
		if (s->version == TLS1_2_VERSION)
			s->method = TLSv1_2_server_method();
		else if (s->version == TLS1_1_VERSION)
			s->method = TLSv1_1_server_method();
		else if (s->version == TLS1_VERSION)
                        s->s3->rbuf.left=0;
                        s->s3->rbuf.offset=0;
                        }
               if (s->version == TLS1_2_VERSION)
                       s->method = TLSv1_2_server_method();
               else if (s->version == TLS1_1_VERSION)
                       s->method = TLSv1_1_server_method();
               else if (s->version == TLS1_VERSION)
                       s->method = TLSv1_server_method();
               else
                       s->method = SSLv3_server_method();
 #if 0 /* ssl3_get_client_hello does this */
                s->client_version=(v[0]<<8)|v[1];
 #endif
		s->handshake_func=s->method->ssl_accept;
		}
",C,"                s->method = ssl23_get_server_method(s->version);
               if (s->method == NULL)
                       {
                       SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);
                       goto err;
                       }
","               if (s->version == TLS1_2_VERSION)
                       s->method = TLSv1_2_server_method();
               else if (s->version == TLS1_1_VERSION)
                       s->method = TLSv1_1_server_method();
               else if (s->version == TLS1_VERSION)
                       s->method = TLSv1_server_method();
               else
                       s->method = SSLv3_server_method();
",7fd4ce6a997be5f5c9e744ac527725c2850de203,"@@ -127,9 +127,11 @@ static const SSL_METHOD *ssl23_get_server_method(int ver)
        if (ver == SSL2_VERSION)
                return(SSLv2_server_method());
 #endif
+#ifndef OPENSSL_NO_SSL3
        if (ver == SSL3_VERSION)
                return(SSLv3_server_method());
-       else if (ver == TLS1_VERSION)
+#endif
+       if (ver == TLS1_VERSION)
                return(TLSv1_server_method());
        else if (ver == TLS1_1_VERSION)
                return(TLSv1_1_server_method());
@@ -600,6 +602,12 @@ int ssl23_get_client_hello(SSL *s)
        if ((type == 2) || (type == 3))
                {
                /* we have SSLv3/TLSv1 (type 2: SSL2 style, type 3: SSL3/TLS style) */
+                s->method = ssl23_get_server_method(s->version);
+               if (s->method == NULL)
+                       {
+                       SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);
+                       goto err;
+                       }
 
                if (!ssl_init_wbio_buffer(s,1)) goto err;
 
@@ -627,14 +635,6 @@ int ssl23_get_client_hello(SSL *s)
                        s->s3->rbuf.left=0;
                        s->s3->rbuf.offset=0;
                        }
-               if (s->version == TLS1_2_VERSION)
-                       s->method = TLSv1_2_server_method();
-               else if (s->version == TLS1_1_VERSION)
-                       s->method = TLSv1_1_server_method();
-               else if (s->version == TLS1_VERSION)
-                       s->method = TLSv1_server_method();
-               else
-                       s->method = SSLv3_server_method();
 #if 0 /* ssl3_get_client_hello does this */
                s->client_version=(v[0]<<8)|v[1];
 #endif",openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=ssl/s23_srvr.c;h=93ca7d53cda4734bf9e98a4b6b5c079652625b33;hb=26a59d9b46574e457870197dffa802871b4c8fc7,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=ssl/s23_srvr.c;h=567a6b10057756e81c36648e5359487b86df0178,1,"int ssl23_get_client_hello(SSL *s)
	{
	char buf_space[11]; /* Request this many bytes in initial read.
	                     * We can detect SSL 3.0/TLS 1.0 Client Hellos
	                     * ('type == 3') correctly only when the following
	                     * is in a single record, which is not guaranteed by
	                     * the protocol specification:
	                     * Byte  Content
	                     *  0     type            \
	                     *  1/2   version          > record header
	                     *  3/4   length          /
	                     *  5     msg_type        \
	                     *  6-8   length           > Client Hello message
	                     *  9/10  client_version  /
	                     */
	char *buf= &(buf_space[0]);
	unsigned char *p,*d,*d_len,*dd;
	unsigned int i;
	unsigned int csl,sil,cl;
	int n=0,j;
	int type=0;
	int v[2];

	if (s->state ==	SSL23_ST_SR_CLNT_HELLO_A)
		{
		/* read the initial header */
		v[0]=v[1]=0;

		if (!ssl3_setup_buffers(s)) goto err;

		n=ssl23_read_bytes(s, sizeof buf_space);
		if (n != sizeof buf_space) return(n); /* n == -1 || n == 0 */

		p=s->packet;

		memcpy(buf,p,n);

		if ((p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO))
			{
			/*
			 * SSLv2 header
			 */
			if ((p[3] == 0x00) && (p[4] == 0x02))
				{
				v[0]=p[3]; v[1]=p[4];
				/* SSLv2 */
				if (!(s->options & SSL_OP_NO_SSLv2))
					type=1;
				}
			else if (p[3] == SSL3_VERSION_MAJOR)
				{
				v[0]=p[3]; v[1]=p[4];
				/* SSLv3/TLSv1 */
				if (p[4] >= TLS1_VERSION_MINOR)
					{
					if (p[4] >= TLS1_2_VERSION_MINOR &&
					   !(s->options & SSL_OP_NO_TLSv1_2))
						{
						s->version=TLS1_2_VERSION;
						s->state=SSL23_ST_SR_CLNT_HELLO_B;
						}
					else if (p[4] >= TLS1_1_VERSION_MINOR &&
					   !(s->options & SSL_OP_NO_TLSv1_1))
						{
						s->version=TLS1_1_VERSION;
						/* type=2; */ /* done later to survive restarts */
						s->state=SSL23_ST_SR_CLNT_HELLO_B;
						}
					else if (!(s->options & SSL_OP_NO_TLSv1))
						{
						s->version=TLS1_VERSION;
						/* type=2; */ /* done later to survive restarts */
						s->state=SSL23_ST_SR_CLNT_HELLO_B;
						}
					else if (!(s->options & SSL_OP_NO_SSLv3))
						{
						s->version=SSL3_VERSION;
						/* type=2; */
						s->state=SSL23_ST_SR_CLNT_HELLO_B;
						}
					else if (!(s->options & SSL_OP_NO_SSLv2))
						{
						type=1;
						}
					}
				else if (!(s->options & SSL_OP_NO_SSLv3))
					{
					s->version=SSL3_VERSION;
					/* type=2; */
					s->state=SSL23_ST_SR_CLNT_HELLO_B;
					}
				else if (!(s->options & SSL_OP_NO_SSLv2))
					type=1;

				}
			}
		else if ((p[0] == SSL3_RT_HANDSHAKE) &&
			 (p[1] == SSL3_VERSION_MAJOR) &&
			 (p[5] == SSL3_MT_CLIENT_HELLO) &&
			 ((p[3] == 0 && p[4] < 5 /* silly record length? */)
				|| (p[9] >= p[1])))
			{
			/*
			 * SSLv3 or tls1 header
			 */
			
			v[0]=p[1]; /* major version (= SSL3_VERSION_MAJOR) */
			/* We must look at client_version inside the Client Hello message
			 * to get the correct minor version.
			 * However if we have only a pathologically small fragment of the
			 * Client Hello message, this would be difficult, and we'd have
			 * to read more records to find out.
			 * No known SSL 3.0 client fragments ClientHello like this,
			 * so we simply reject such connections to avoid
			 * protocol version downgrade attacks. */
			if (p[3] == 0 && p[4] < 6)
				{
				SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_SMALL);
				goto err;
				}
			/* if major version number > 3 set minor to a value
			 * which will use the highest version 3 we support.
			 * If TLS 2.0 ever appears we will need to revise
			 * this....
			 */
			if (p[9] > SSL3_VERSION_MAJOR)
				v[1]=0xff;
			else
				v[1]=p[10]; /* minor version according to client_version */
			if (v[1] >= TLS1_VERSION_MINOR)
				{
				if (v[1] >= TLS1_2_VERSION_MINOR &&
					!(s->options & SSL_OP_NO_TLSv1_2))
					{
					s->version=TLS1_2_VERSION;
					type=3;
					}
				else if (v[1] >= TLS1_1_VERSION_MINOR &&
					!(s->options & SSL_OP_NO_TLSv1_1))
					{
					s->version=TLS1_1_VERSION;
					type=3;
					}
				else if (!(s->options & SSL_OP_NO_TLSv1))
					{
					s->version=TLS1_VERSION;
					type=3;
					}
				else if (!(s->options & SSL_OP_NO_SSLv3))
					{
					s->version=SSL3_VERSION;
					type=3;
					}
				}
			else
				{
				/* client requests SSL 3.0 */
				if (!(s->options & SSL_OP_NO_SSLv3))
					{
					s->version=SSL3_VERSION;
					type=3;
					}
				else if (!(s->options & SSL_OP_NO_TLSv1))
					{
					/* we won't be able to use TLS of course,
					 * but this will send an appropriate alert */
					s->version=TLS1_VERSION;
					type=3;
					}
				}
			}
		else if ((strncmp(""GET "", (char *)p,4) == 0) ||
			 (strncmp(""POST "",(char *)p,5) == 0) ||
			 (strncmp(""HEAD "",(char *)p,5) == 0) ||
			 (strncmp(""PUT "", (char *)p,4) == 0))
			{
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTP_REQUEST);
			goto err;
			}
		else if (strncmp(""CONNECT"",(char *)p,7) == 0)
			{
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTPS_PROXY_REQUEST);
			goto err;
			}
		}

	/* ensure that TLS_MAX_VERSION is up-to-date */
	OPENSSL_assert(s->version <= TLS_MAX_VERSION);

#ifdef OPENSSL_FIPS
	if (FIPS_mode() && (s->version < TLS1_VERSION))
		{
		SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,
					SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
		goto err;
		}
#endif

	if (s->state == SSL23_ST_SR_CLNT_HELLO_B)
		{
		/* we have SSLv3/TLSv1 in an SSLv2 header
		 * (other cases skip this state) */

		type=2;
		p=s->packet;
		v[0] = p[3]; /* == SSL3_VERSION_MAJOR */
		v[1] = p[4];

		/* An SSLv3/TLSv1 backwards-compatible CLIENT-HELLO in an SSLv2
		 * header is sent directly on the wire, not wrapped as a TLS
		 * record. It's format is:
		 * Byte  Content
		 * 0-1   msg_length
		 * 2     msg_type
		 * 3-4   version
		 * 5-6   cipher_spec_length
		 * 7-8   session_id_length
		 * 9-10  challenge_length
		 * ...   ...
		 */
		n=((p[0]&0x7f)<<8)|p[1];
		if (n > (1024*4))
			{
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_LARGE);
			goto err;
			}
		if (n < 9)
			{
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH);
			goto err;
			}

		j=ssl23_read_bytes(s,n+2);
		/* We previously read 11 bytes, so if j > 0, we must have
		 * j == n+2 == s->packet_length. We have at least 11 valid
		 * packet bytes. */
		if (j <= 0) return(j);

		ssl3_finish_mac(s, s->packet+2, s->packet_length-2);
		if (s->msg_callback)
			s->msg_callback(0, SSL2_VERSION, 0, s->packet+2, s->packet_length-2, s, s->msg_callback_arg); /* CLIENT-HELLO */

		p=s->packet;
		p+=5;
		n2s(p,csl);
		n2s(p,sil);
		n2s(p,cl);
		d=(unsigned char *)s->init_buf->data;
		if ((csl+sil+cl+11) != s->packet_length) /* We can't have TLS extensions in SSL 2.0 format
		                                          * Client Hello, can we? Error condition should be
		                                          * '>' otherweise */
			{
			SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH);
			goto err;
			}

		/* record header: msg_type ... */
		*(d++) = SSL3_MT_CLIENT_HELLO;
		/* ... and length (actual value will be written later) */
		d_len = d;
		d += 3;

		/* client_version */
		*(d++) = SSL3_VERSION_MAJOR; /* == v[0] */
		*(d++) = v[1];

		/* lets populate the random area */
		/* get the challenge_length */
		i=(cl > SSL3_RANDOM_SIZE)?SSL3_RANDOM_SIZE:cl;
		memset(d,0,SSL3_RANDOM_SIZE);
		memcpy(&(d[SSL3_RANDOM_SIZE-i]),&(p[csl+sil]),i);
		d+=SSL3_RANDOM_SIZE;

		/* no session-id reuse */
		*(d++)=0;

		/* ciphers */
		j=0;
		dd=d;
		d+=2;
		for (i=0; i<csl; i+=3)
			{
			if (p[i] != 0) continue;
			*(d++)=p[i+1];
			*(d++)=p[i+2];
			j+=2;
			}
		s2n(j,dd);

		/* COMPRESSION */
		*(d++)=1;
		*(d++)=0;
		
#if 0
                /* copy any remaining data with may be extensions */
	        p = p+csl+sil+cl;
		while (p <  s->packet+s->packet_length)
			{
			*(d++)=*(p++);
			}
#endif

		i = (d-(unsigned char *)s->init_buf->data) - 4;
		l2n3((long)i, d_len);

		/* get the data reused from the init_buf */
		s->s3->tmp.reuse_message=1;
		s->s3->tmp.message_type=SSL3_MT_CLIENT_HELLO;
		s->s3->tmp.message_size=i;
		}

	/* imaginary new state (for program structure): */
	/* s->state = SSL23_SR_CLNT_HELLO_C */

	if (type == 1)
		{
#ifdef OPENSSL_NO_SSL2
		SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);
		goto err;
#else
		/* we are talking sslv2 */
		/* we need to clean up the SSLv3/TLSv1 setup and put in the
		 * sslv2 stuff. */

		if (s->s2 == NULL)
			{
			if (!ssl2_new(s))
				goto err;
			}
		else
			ssl2_clear(s);

		if (s->s3 != NULL) ssl3_free(s);

		if (!BUF_MEM_grow_clean(s->init_buf,
			SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))
			{
			goto err;
			}

		s->state=SSL2_ST_GET_CLIENT_HELLO_A;
		if (s->options & SSL_OP_NO_TLSv1 && s->options & SSL_OP_NO_SSLv3)
			s->s2->ssl2_rollback=0;
		else
			/* reject SSL 2.0 session if client supports SSL 3.0 or TLS 1.0
			 * (SSL 3.0 draft/RFC 2246, App. E.2) */
			s->s2->ssl2_rollback=1;

		/* setup the n bytes we have read so we get them from
		 * the sslv2 buffer */
		s->rstate=SSL_ST_READ_HEADER;
		s->packet_length=n;
		s->packet= &(s->s2->rbuf[0]);
		memcpy(s->packet,buf,n);
		s->s2->rbuf_left=n;
		s->s2->rbuf_offs=0;

		s->method=SSLv2_server_method();
		s->handshake_func=s->method->ssl_accept;
#endif
		}

	if ((type == 2) || (type == 3))
		{
        if ((type == 2) || (type == 3))
                {
                /* we have SSLv3/TLSv1 (type 2: SSL2 style, type 3: SSL3/TLS style) */
//fix_flaw_line_below:
//                s->method = ssl23_get_server_method(s->version);
//fix_flaw_line_below:
//               if (s->method == NULL)
//fix_flaw_line_below:
//                       {
//fix_flaw_line_below:
//                       SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);
//fix_flaw_line_below:
//                       goto err;
//fix_flaw_line_below:
//                       }
 
                if (!ssl_init_wbio_buffer(s,1)) goto err;
 
			s->packet_length=n;
			if (s->s3->rbuf.buf == NULL)
				if (!ssl3_setup_read_buffer(s))
					goto err;

			s->packet= &(s->s3->rbuf.buf[0]);
			memcpy(s->packet,buf,n);
			s->s3->rbuf.left=n;
			s->s3->rbuf.offset=0;
			}
		else
			{
			s->packet_length=0;
			s->s3->rbuf.left=0;
			s->s3->rbuf.offset=0;
			}
		if (s->version == TLS1_2_VERSION)
			s->method = TLSv1_2_server_method();
		else if (s->version == TLS1_1_VERSION)
			s->method = TLSv1_1_server_method();
		else if (s->version == TLS1_VERSION)
                        s->s3->rbuf.left=0;
                        s->s3->rbuf.offset=0;
                        }
//flaw_line_below:
               if (s->version == TLS1_2_VERSION)
//flaw_line_below:
                       s->method = TLSv1_2_server_method();
//flaw_line_below:
               else if (s->version == TLS1_1_VERSION)
//flaw_line_below:
                       s->method = TLSv1_1_server_method();
//flaw_line_below:
               else if (s->version == TLS1_VERSION)
//flaw_line_below:
                       s->method = TLSv1_server_method();
//flaw_line_below:
               else
//flaw_line_below:
                       s->method = SSLv3_server_method();
 #if 0 /* ssl3_get_client_hello does this */
                s->client_version=(v[0]<<8)|v[1];
 #endif
		s->handshake_func=s->method->ssl_accept;
		}
"
594,178330,,Remote,Not required,,CVE-2014-3568,https://www.cvedetails.com/cve/CVE-2014-3568/,CWE-310,Medium,,Partial,,2014-10-18,4.3,"OpenSSL before 0.9.8zc, 1.0.0 before 1.0.0o, and 1.0.1 before 1.0.1j does not properly enforce the no-ssl3 build option, which allows remote attackers to bypass intended access restrictions via an SSL 3.0 handshake, related to s23_clnt.c and s23_srvr.c.",2017-11-14,Bypass,3,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=26a59d9b46574e457870197dffa802871b4c8fc7,26a59d9b46574e457870197dffa802871b4c8fc7,,1,,,"static const SSL_METHOD *ssl23_get_server_method(int ver)
	{
#ifndef OPENSSL_NO_SSL2
        if (ver == SSL2_VERSION)
                return(SSLv2_server_method());
 #endif
#ifndef OPENSSL_NO_SSL3
        if (ver == SSL3_VERSION)
                return(SSLv3_server_method());
#endif
       if (ver == TLS1_VERSION)
                return(TLSv1_server_method());
        else if (ver == TLS1_1_VERSION)
                return(TLSv1_1_server_method());
	else
		return(NULL);
	}
","static const SSL_METHOD *ssl23_get_server_method(int ver)
	{
#ifndef OPENSSL_NO_SSL2
        if (ver == SSL2_VERSION)
                return(SSLv2_server_method());
 #endif
        if (ver == SSL3_VERSION)
                return(SSLv3_server_method());
       else if (ver == TLS1_VERSION)
                return(TLSv1_server_method());
        else if (ver == TLS1_1_VERSION)
                return(TLSv1_1_server_method());
	else
		return(NULL);
	}
",C,"#ifndef OPENSSL_NO_SSL3
#endif
       if (ver == TLS1_VERSION)
","       else if (ver == TLS1_VERSION)
",7fd4ce6a997be5f5c9e744ac527725c2850de203,"@@ -127,9 +127,11 @@ static const SSL_METHOD *ssl23_get_server_method(int ver)
        if (ver == SSL2_VERSION)
                return(SSLv2_server_method());
 #endif
+#ifndef OPENSSL_NO_SSL3
        if (ver == SSL3_VERSION)
                return(SSLv3_server_method());
-       else if (ver == TLS1_VERSION)
+#endif
+       if (ver == TLS1_VERSION)
                return(TLSv1_server_method());
        else if (ver == TLS1_1_VERSION)
                return(TLSv1_1_server_method());
@@ -600,6 +602,12 @@ int ssl23_get_client_hello(SSL *s)
        if ((type == 2) || (type == 3))
                {
                /* we have SSLv3/TLSv1 (type 2: SSL2 style, type 3: SSL3/TLS style) */
+                s->method = ssl23_get_server_method(s->version);
+               if (s->method == NULL)
+                       {
+                       SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);
+                       goto err;
+                       }
 
                if (!ssl_init_wbio_buffer(s,1)) goto err;
 
@@ -627,14 +635,6 @@ int ssl23_get_client_hello(SSL *s)
                        s->s3->rbuf.left=0;
                        s->s3->rbuf.offset=0;
                        }
-               if (s->version == TLS1_2_VERSION)
-                       s->method = TLSv1_2_server_method();
-               else if (s->version == TLS1_1_VERSION)
-                       s->method = TLSv1_1_server_method();
-               else if (s->version == TLS1_VERSION)
-                       s->method = TLSv1_server_method();
-               else
-                       s->method = SSLv3_server_method();
 #if 0 /* ssl3_get_client_hello does this */
                s->client_version=(v[0]<<8)|v[1];
 #endif",openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=ssl/s23_srvr.c;h=93ca7d53cda4734bf9e98a4b6b5c079652625b33;hb=26a59d9b46574e457870197dffa802871b4c8fc7,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=ssl/s23_srvr.c;h=567a6b10057756e81c36648e5359487b86df0178,1,"static const SSL_METHOD *ssl23_get_server_method(int ver)
	{
#ifndef OPENSSL_NO_SSL2
        if (ver == SSL2_VERSION)
                return(SSLv2_server_method());
 #endif
//fix_flaw_line_below:
//#ifndef OPENSSL_NO_SSL3
        if (ver == SSL3_VERSION)
                return(SSLv3_server_method());
//flaw_line_below:
       else if (ver == TLS1_VERSION)
//fix_flaw_line_below:
//#endif
//fix_flaw_line_below:
//       if (ver == TLS1_VERSION)
                return(TLSv1_server_method());
        else if (ver == TLS1_1_VERSION)
                return(TLSv1_1_server_method());
	else
		return(NULL);
	}
"
650,178386,,Remote,Not required,,CVE-2016-2107,https://www.cvedetails.com/cve/CVE-2016-2107/,CWE-310,High,Partial,,,2016-05-04,2.6,"The AES-NI implementation in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h does not consider memory allocation during a certain padding check, which allows remote attackers to obtain sensitive cleartext information via a padding-oracle attack against an AES CBC session. NOTE: this vulnerability exists because of an incorrect fix for CVE-2013-0169.",2018-10-30,+Info,2,https://git.openssl.org/?p=openssl.git;a=commit;h=68595c0c2886e7942a14f98c17a55a88afb6c292,68595c0c2886e7942a14f98c17a55a88afb6c292,,0,,,"static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                                      const unsigned char *in, size_t len)
{
    EVP_AES_HMAC_SHA1 *key = data(ctx);
    unsigned int l;
    size_t plen = key->payload_length, iv = 0, /* explicit IV in TLS 1.1 and
                                                * later */
        sha_off = 0;
#  if defined(STITCHED_CALL)
    size_t aes_off = 0, blocks;

    sha_off = SHA_CBLOCK - key->md.num;
#  endif

    key->payload_length = NO_PAYLOAD_LENGTH;

    if (len % AES_BLOCK_SIZE)
        return 0;

    if (ctx->encrypt) {
        if (plen == NO_PAYLOAD_LENGTH)
            plen = len;
        else if (len !=
                 ((plen + SHA_DIGEST_LENGTH +
                   AES_BLOCK_SIZE) & -AES_BLOCK_SIZE))
            return 0;
        else if (key->aux.tls_ver >= TLS1_1_VERSION)
            iv = AES_BLOCK_SIZE;

#  if defined(STITCHED_CALL)
        if (plen > (sha_off + iv)
            && (blocks = (plen - (sha_off + iv)) / SHA_CBLOCK)) {
            SHA1_Update(&key->md, in + iv, sha_off);

            aesni_cbc_sha1_enc(in, out, blocks, &key->ks,
                               ctx->iv, &key->md, in + iv + sha_off);
            blocks *= SHA_CBLOCK;
            aes_off += blocks;
            sha_off += blocks;
            key->md.Nh += blocks >> 29;
            key->md.Nl += blocks <<= 3;
            if (key->md.Nl < (unsigned int)blocks)
                key->md.Nh++;
        } else {
            sha_off = 0;
        }
#  endif
        sha_off += iv;
        SHA1_Update(&key->md, in + sha_off, plen - sha_off);

        if (plen != len) {      /* ""TLS"" mode of operation */
            if (in != out)
                memcpy(out + aes_off, in + aes_off, plen - aes_off);

            /* calculate HMAC and append it to payload */
            SHA1_Final(out + plen, &key->md);
            key->md = key->tail;
            SHA1_Update(&key->md, out + plen, SHA_DIGEST_LENGTH);
            SHA1_Final(out + plen, &key->md);

            /* pad the payload|hmac */
            plen += SHA_DIGEST_LENGTH;
            for (l = len - plen - 1; plen < len; plen++)
                out[plen] = l;
            /* encrypt HMAC|padding at once */
            aesni_cbc_encrypt(out + aes_off, out + aes_off, len - aes_off,
                              &key->ks, ctx->iv, 1);
        } else {
            aesni_cbc_encrypt(in + aes_off, out + aes_off, len - aes_off,
                              &key->ks, ctx->iv, 1);
        }
    } else {
        union {
            unsigned int u[SHA_DIGEST_LENGTH / sizeof(unsigned int)];
            unsigned char c[32 + SHA_DIGEST_LENGTH];
        } mac, *pmac;

        /* arrange cache line alignment */
        pmac = (void *)(((size_t)mac.c + 31) & ((size_t)0 - 32));

        if (plen != NO_PAYLOAD_LENGTH) { /* ""TLS"" mode of operation */
            size_t inp_len, mask, j, i;
            unsigned int res, maxpad, pad, bitlen;
            int ret = 1;
            union {
                unsigned int u[SHA_LBLOCK];
                unsigned char c[SHA_CBLOCK];
            } *data = (void *)key->md.data;
#  if defined(STITCHED_DECRYPT_CALL)
            unsigned char tail_iv[AES_BLOCK_SIZE];
            int stitch = 0;
#  endif

            if ((key->aux.tls_aad[plen - 4] << 8 | key->aux.tls_aad[plen - 3])
                >= TLS1_1_VERSION) {
                if (len < (AES_BLOCK_SIZE + SHA_DIGEST_LENGTH + 1))
                    return 0;

                /* omit explicit iv */
                memcpy(ctx->iv, in, AES_BLOCK_SIZE);
                in += AES_BLOCK_SIZE;
                out += AES_BLOCK_SIZE;
                len -= AES_BLOCK_SIZE;
            } else if (len < (SHA_DIGEST_LENGTH + 1))
                return 0;

#  if defined(STITCHED_DECRYPT_CALL)
            if (len >= 1024 && ctx->key_len == 32) {
                /* decrypt last block */
                memcpy(tail_iv, in + len - 2 * AES_BLOCK_SIZE,
                       AES_BLOCK_SIZE);
                aesni_cbc_encrypt(in + len - AES_BLOCK_SIZE,
                                  out + len - AES_BLOCK_SIZE, AES_BLOCK_SIZE,
                                  &key->ks, tail_iv, 0);
                stitch = 1;
            } else
#  endif
                /* decrypt HMAC|padding at once */
                aesni_cbc_encrypt(in, out, len, &key->ks, ctx->iv, 0);

            /* figure out payload length */
            pad = out[len - 1];
            maxpad = len - (SHA_DIGEST_LENGTH + 1);
            maxpad |= (255 - maxpad) >> (sizeof(maxpad) * 8 - 8);
             maxpad |= (255 - maxpad) >> (sizeof(maxpad) * 8 - 8);
             maxpad &= 255;
 
            ret &= constant_time_ge(maxpad, pad);

             inp_len = len - (SHA_DIGEST_LENGTH + pad + 1);
             mask = (0 - ((inp_len - len) >> (sizeof(inp_len) * 8 - 1)));
             inp_len &= mask;
            key->aux.tls_aad[plen - 1] = inp_len;

            /* calculate HMAC */
            key->md = key->head;
            SHA1_Update(&key->md, key->aux.tls_aad, plen);

#  if defined(STITCHED_DECRYPT_CALL)
            if (stitch) {
                blocks = (len - (256 + 32 + SHA_CBLOCK)) / SHA_CBLOCK;
                aes_off = len - AES_BLOCK_SIZE - blocks * SHA_CBLOCK;
                sha_off = SHA_CBLOCK - plen;

                aesni_cbc_encrypt(in, out, aes_off, &key->ks, ctx->iv, 0);

                SHA1_Update(&key->md, out, sha_off);
                aesni256_cbc_sha1_dec(in + aes_off,
                                      out + aes_off, blocks, &key->ks,
                                      ctx->iv, &key->md, out + sha_off);

                sha_off += blocks *= SHA_CBLOCK;
                out += sha_off;
                len -= sha_off;
                inp_len -= sha_off;

                key->md.Nl += (blocks << 3); /* at most 18 bits */
                memcpy(ctx->iv, tail_iv, AES_BLOCK_SIZE);
            }
#  endif

#  if 1
            len -= SHA_DIGEST_LENGTH; /* amend mac */
            if (len >= (256 + SHA_CBLOCK)) {
                j = (len - (256 + SHA_CBLOCK)) & (0 - SHA_CBLOCK);
                j += SHA_CBLOCK - key->md.num;
                SHA1_Update(&key->md, out, j);
                out += j;
                len -= j;
                inp_len -= j;
            }

            /* but pretend as if we hashed padded payload */
            bitlen = key->md.Nl + (inp_len << 3); /* at most 18 bits */
#   ifdef BSWAP4
            bitlen = BSWAP4(bitlen);
#   else
            mac.c[0] = 0;
            mac.c[1] = (unsigned char)(bitlen >> 16);
            mac.c[2] = (unsigned char)(bitlen >> 8);
            mac.c[3] = (unsigned char)bitlen;
            bitlen = mac.u[0];
#   endif

            pmac->u[0] = 0;
            pmac->u[1] = 0;
            pmac->u[2] = 0;
            pmac->u[3] = 0;
            pmac->u[4] = 0;

            for (res = key->md.num, j = 0; j < len; j++) {
                size_t c = out[j];
                mask = (j - inp_len) >> (sizeof(j) * 8 - 8);
                c &= mask;
                c |= 0x80 & ~mask & ~((inp_len - j) >> (sizeof(j) * 8 - 8));
                data->c[res++] = (unsigned char)c;

                if (res != SHA_CBLOCK)
                    continue;

                /* j is not incremented yet */
                mask = 0 - ((inp_len + 7 - j) >> (sizeof(j) * 8 - 1));
                data->u[SHA_LBLOCK - 1] |= bitlen & mask;
                sha1_block_data_order(&key->md, data, 1);
                mask &= 0 - ((j - inp_len - 72) >> (sizeof(j) * 8 - 1));
                pmac->u[0] |= key->md.h0 & mask;
                pmac->u[1] |= key->md.h1 & mask;
                pmac->u[2] |= key->md.h2 & mask;
                pmac->u[3] |= key->md.h3 & mask;
                pmac->u[4] |= key->md.h4 & mask;
                res = 0;
            }

            for (i = res; i < SHA_CBLOCK; i++, j++)
                data->c[i] = 0;

            if (res > SHA_CBLOCK - 8) {
                mask = 0 - ((inp_len + 8 - j) >> (sizeof(j) * 8 - 1));
                data->u[SHA_LBLOCK - 1] |= bitlen & mask;
                sha1_block_data_order(&key->md, data, 1);
                mask &= 0 - ((j - inp_len - 73) >> (sizeof(j) * 8 - 1));
                pmac->u[0] |= key->md.h0 & mask;
                pmac->u[1] |= key->md.h1 & mask;
                pmac->u[2] |= key->md.h2 & mask;
                pmac->u[3] |= key->md.h3 & mask;
                pmac->u[4] |= key->md.h4 & mask;

                memset(data, 0, SHA_CBLOCK);
                j += 64;
            }
            data->u[SHA_LBLOCK - 1] = bitlen;
            sha1_block_data_order(&key->md, data, 1);
            mask = 0 - ((j - inp_len - 73) >> (sizeof(j) * 8 - 1));
            pmac->u[0] |= key->md.h0 & mask;
            pmac->u[1] |= key->md.h1 & mask;
            pmac->u[2] |= key->md.h2 & mask;
            pmac->u[3] |= key->md.h3 & mask;
            pmac->u[4] |= key->md.h4 & mask;

#   ifdef BSWAP4
            pmac->u[0] = BSWAP4(pmac->u[0]);
            pmac->u[1] = BSWAP4(pmac->u[1]);
            pmac->u[2] = BSWAP4(pmac->u[2]);
            pmac->u[3] = BSWAP4(pmac->u[3]);
            pmac->u[4] = BSWAP4(pmac->u[4]);
#   else
            for (i = 0; i < 5; i++) {
                res = pmac->u[i];
                pmac->c[4 * i + 0] = (unsigned char)(res >> 24);
                pmac->c[4 * i + 1] = (unsigned char)(res >> 16);
                pmac->c[4 * i + 2] = (unsigned char)(res >> 8);
                pmac->c[4 * i + 3] = (unsigned char)res;
            }
#   endif
            len += SHA_DIGEST_LENGTH;
#  else
            SHA1_Update(&key->md, out, inp_len);
            res = key->md.num;
            SHA1_Final(pmac->c, &key->md);

            {
                unsigned int inp_blocks, pad_blocks;

                /* but pretend as if we hashed padded payload */
                inp_blocks =
                    1 + ((SHA_CBLOCK - 9 - res) >> (sizeof(res) * 8 - 1));
                res += (unsigned int)(len - inp_len);
                pad_blocks = res / SHA_CBLOCK;
                res %= SHA_CBLOCK;
                pad_blocks +=
                    1 + ((SHA_CBLOCK - 9 - res) >> (sizeof(res) * 8 - 1));
                for (; inp_blocks < pad_blocks; inp_blocks++)
                    sha1_block_data_order(&key->md, data, 1);
            }
#  endif
            key->md = key->tail;
            SHA1_Update(&key->md, pmac->c, SHA_DIGEST_LENGTH);
            SHA1_Final(pmac->c, &key->md);

            /* verify HMAC */
            out += inp_len;
            len -= inp_len;
#  if 1
            {
                unsigned char *p = out + len - 1 - maxpad - SHA_DIGEST_LENGTH;
                size_t off = out - p;
                unsigned int c, cmask;

                maxpad += SHA_DIGEST_LENGTH;
                for (res = 0, i = 0, j = 0; j < maxpad; j++) {
                    c = p[j];
                    cmask =
                        ((int)(j - off - SHA_DIGEST_LENGTH)) >> (sizeof(int) *
                                                                 8 - 1);
                    res |= (c ^ pad) & ~cmask; /* ... and padding */
                    cmask &= ((int)(off - 1 - j)) >> (sizeof(int) * 8 - 1);
                    res |= (c ^ pmac->c[i]) & cmask;
                    i += 1 & cmask;
                }
                maxpad -= SHA_DIGEST_LENGTH;

                res = 0 - ((0 - res) >> (sizeof(res) * 8 - 1));
                ret &= (int)~res;
            }
#  else
            for (res = 0, i = 0; i < SHA_DIGEST_LENGTH; i++)
                res |= out[i] ^ pmac->c[i];
            res = 0 - ((0 - res) >> (sizeof(res) * 8 - 1));
            ret &= (int)~res;

            /* verify padding */
            pad = (pad & ~res) | (maxpad & res);
            out = out + len - 1 - pad;
            for (res = 0, i = 0; i < pad; i++)
                res |= out[i] ^ pad;

            res = (0 - res) >> (sizeof(res) * 8 - 1);
            ret &= (int)~res;
#  endif
            return ret;
        } else {
#  if defined(STITCHED_DECRYPT_CALL)
            if (len >= 1024 && ctx->key_len == 32) {
                if (sha_off %= SHA_CBLOCK)
                    blocks = (len - 3 * SHA_CBLOCK) / SHA_CBLOCK;
                else
                    blocks = (len - 2 * SHA_CBLOCK) / SHA_CBLOCK;
                aes_off = len - blocks * SHA_CBLOCK;

                aesni_cbc_encrypt(in, out, aes_off, &key->ks, ctx->iv, 0);
                SHA1_Update(&key->md, out, sha_off);
                aesni256_cbc_sha1_dec(in + aes_off,
                                      out + aes_off, blocks, &key->ks,
                                      ctx->iv, &key->md, out + sha_off);

                sha_off += blocks *= SHA_CBLOCK;
                out += sha_off;
                len -= sha_off;

                key->md.Nh += blocks >> 29;
                key->md.Nl += blocks <<= 3;
                if (key->md.Nl < (unsigned int)blocks)
                    key->md.Nh++;
            } else
#  endif
                /* decrypt HMAC|padding at once */
                aesni_cbc_encrypt(in, out, len, &key->ks, ctx->iv, 0);

            SHA1_Update(&key->md, out, len);
        }
    }

    return 1;
}
","static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                                      const unsigned char *in, size_t len)
{
    EVP_AES_HMAC_SHA1 *key = data(ctx);
    unsigned int l;
    size_t plen = key->payload_length, iv = 0, /* explicit IV in TLS 1.1 and
                                                * later */
        sha_off = 0;
#  if defined(STITCHED_CALL)
    size_t aes_off = 0, blocks;

    sha_off = SHA_CBLOCK - key->md.num;
#  endif

    key->payload_length = NO_PAYLOAD_LENGTH;

    if (len % AES_BLOCK_SIZE)
        return 0;

    if (ctx->encrypt) {
        if (plen == NO_PAYLOAD_LENGTH)
            plen = len;
        else if (len !=
                 ((plen + SHA_DIGEST_LENGTH +
                   AES_BLOCK_SIZE) & -AES_BLOCK_SIZE))
            return 0;
        else if (key->aux.tls_ver >= TLS1_1_VERSION)
            iv = AES_BLOCK_SIZE;

#  if defined(STITCHED_CALL)
        if (plen > (sha_off + iv)
            && (blocks = (plen - (sha_off + iv)) / SHA_CBLOCK)) {
            SHA1_Update(&key->md, in + iv, sha_off);

            aesni_cbc_sha1_enc(in, out, blocks, &key->ks,
                               ctx->iv, &key->md, in + iv + sha_off);
            blocks *= SHA_CBLOCK;
            aes_off += blocks;
            sha_off += blocks;
            key->md.Nh += blocks >> 29;
            key->md.Nl += blocks <<= 3;
            if (key->md.Nl < (unsigned int)blocks)
                key->md.Nh++;
        } else {
            sha_off = 0;
        }
#  endif
        sha_off += iv;
        SHA1_Update(&key->md, in + sha_off, plen - sha_off);

        if (plen != len) {      /* ""TLS"" mode of operation */
            if (in != out)
                memcpy(out + aes_off, in + aes_off, plen - aes_off);

            /* calculate HMAC and append it to payload */
            SHA1_Final(out + plen, &key->md);
            key->md = key->tail;
            SHA1_Update(&key->md, out + plen, SHA_DIGEST_LENGTH);
            SHA1_Final(out + plen, &key->md);

            /* pad the payload|hmac */
            plen += SHA_DIGEST_LENGTH;
            for (l = len - plen - 1; plen < len; plen++)
                out[plen] = l;
            /* encrypt HMAC|padding at once */
            aesni_cbc_encrypt(out + aes_off, out + aes_off, len - aes_off,
                              &key->ks, ctx->iv, 1);
        } else {
            aesni_cbc_encrypt(in + aes_off, out + aes_off, len - aes_off,
                              &key->ks, ctx->iv, 1);
        }
    } else {
        union {
            unsigned int u[SHA_DIGEST_LENGTH / sizeof(unsigned int)];
            unsigned char c[32 + SHA_DIGEST_LENGTH];
        } mac, *pmac;

        /* arrange cache line alignment */
        pmac = (void *)(((size_t)mac.c + 31) & ((size_t)0 - 32));

        if (plen != NO_PAYLOAD_LENGTH) { /* ""TLS"" mode of operation */
            size_t inp_len, mask, j, i;
            unsigned int res, maxpad, pad, bitlen;
            int ret = 1;
            union {
                unsigned int u[SHA_LBLOCK];
                unsigned char c[SHA_CBLOCK];
            } *data = (void *)key->md.data;
#  if defined(STITCHED_DECRYPT_CALL)
            unsigned char tail_iv[AES_BLOCK_SIZE];
            int stitch = 0;
#  endif

            if ((key->aux.tls_aad[plen - 4] << 8 | key->aux.tls_aad[plen - 3])
                >= TLS1_1_VERSION) {
                if (len < (AES_BLOCK_SIZE + SHA_DIGEST_LENGTH + 1))
                    return 0;

                /* omit explicit iv */
                memcpy(ctx->iv, in, AES_BLOCK_SIZE);
                in += AES_BLOCK_SIZE;
                out += AES_BLOCK_SIZE;
                len -= AES_BLOCK_SIZE;
            } else if (len < (SHA_DIGEST_LENGTH + 1))
                return 0;

#  if defined(STITCHED_DECRYPT_CALL)
            if (len >= 1024 && ctx->key_len == 32) {
                /* decrypt last block */
                memcpy(tail_iv, in + len - 2 * AES_BLOCK_SIZE,
                       AES_BLOCK_SIZE);
                aesni_cbc_encrypt(in + len - AES_BLOCK_SIZE,
                                  out + len - AES_BLOCK_SIZE, AES_BLOCK_SIZE,
                                  &key->ks, tail_iv, 0);
                stitch = 1;
            } else
#  endif
                /* decrypt HMAC|padding at once */
                aesni_cbc_encrypt(in, out, len, &key->ks, ctx->iv, 0);

            /* figure out payload length */
            pad = out[len - 1];
            maxpad = len - (SHA_DIGEST_LENGTH + 1);
            maxpad |= (255 - maxpad) >> (sizeof(maxpad) * 8 - 8);
             maxpad |= (255 - maxpad) >> (sizeof(maxpad) * 8 - 8);
             maxpad &= 255;
 
             inp_len = len - (SHA_DIGEST_LENGTH + pad + 1);
             mask = (0 - ((inp_len - len) >> (sizeof(inp_len) * 8 - 1)));
             inp_len &= mask;
            key->aux.tls_aad[plen - 1] = inp_len;

            /* calculate HMAC */
            key->md = key->head;
            SHA1_Update(&key->md, key->aux.tls_aad, plen);

#  if defined(STITCHED_DECRYPT_CALL)
            if (stitch) {
                blocks = (len - (256 + 32 + SHA_CBLOCK)) / SHA_CBLOCK;
                aes_off = len - AES_BLOCK_SIZE - blocks * SHA_CBLOCK;
                sha_off = SHA_CBLOCK - plen;

                aesni_cbc_encrypt(in, out, aes_off, &key->ks, ctx->iv, 0);

                SHA1_Update(&key->md, out, sha_off);
                aesni256_cbc_sha1_dec(in + aes_off,
                                      out + aes_off, blocks, &key->ks,
                                      ctx->iv, &key->md, out + sha_off);

                sha_off += blocks *= SHA_CBLOCK;
                out += sha_off;
                len -= sha_off;
                inp_len -= sha_off;

                key->md.Nl += (blocks << 3); /* at most 18 bits */
                memcpy(ctx->iv, tail_iv, AES_BLOCK_SIZE);
            }
#  endif

#  if 1
            len -= SHA_DIGEST_LENGTH; /* amend mac */
            if (len >= (256 + SHA_CBLOCK)) {
                j = (len - (256 + SHA_CBLOCK)) & (0 - SHA_CBLOCK);
                j += SHA_CBLOCK - key->md.num;
                SHA1_Update(&key->md, out, j);
                out += j;
                len -= j;
                inp_len -= j;
            }

            /* but pretend as if we hashed padded payload */
            bitlen = key->md.Nl + (inp_len << 3); /* at most 18 bits */
#   ifdef BSWAP4
            bitlen = BSWAP4(bitlen);
#   else
            mac.c[0] = 0;
            mac.c[1] = (unsigned char)(bitlen >> 16);
            mac.c[2] = (unsigned char)(bitlen >> 8);
            mac.c[3] = (unsigned char)bitlen;
            bitlen = mac.u[0];
#   endif

            pmac->u[0] = 0;
            pmac->u[1] = 0;
            pmac->u[2] = 0;
            pmac->u[3] = 0;
            pmac->u[4] = 0;

            for (res = key->md.num, j = 0; j < len; j++) {
                size_t c = out[j];
                mask = (j - inp_len) >> (sizeof(j) * 8 - 8);
                c &= mask;
                c |= 0x80 & ~mask & ~((inp_len - j) >> (sizeof(j) * 8 - 8));
                data->c[res++] = (unsigned char)c;

                if (res != SHA_CBLOCK)
                    continue;

                /* j is not incremented yet */
                mask = 0 - ((inp_len + 7 - j) >> (sizeof(j) * 8 - 1));
                data->u[SHA_LBLOCK - 1] |= bitlen & mask;
                sha1_block_data_order(&key->md, data, 1);
                mask &= 0 - ((j - inp_len - 72) >> (sizeof(j) * 8 - 1));
                pmac->u[0] |= key->md.h0 & mask;
                pmac->u[1] |= key->md.h1 & mask;
                pmac->u[2] |= key->md.h2 & mask;
                pmac->u[3] |= key->md.h3 & mask;
                pmac->u[4] |= key->md.h4 & mask;
                res = 0;
            }

            for (i = res; i < SHA_CBLOCK; i++, j++)
                data->c[i] = 0;

            if (res > SHA_CBLOCK - 8) {
                mask = 0 - ((inp_len + 8 - j) >> (sizeof(j) * 8 - 1));
                data->u[SHA_LBLOCK - 1] |= bitlen & mask;
                sha1_block_data_order(&key->md, data, 1);
                mask &= 0 - ((j - inp_len - 73) >> (sizeof(j) * 8 - 1));
                pmac->u[0] |= key->md.h0 & mask;
                pmac->u[1] |= key->md.h1 & mask;
                pmac->u[2] |= key->md.h2 & mask;
                pmac->u[3] |= key->md.h3 & mask;
                pmac->u[4] |= key->md.h4 & mask;

                memset(data, 0, SHA_CBLOCK);
                j += 64;
            }
            data->u[SHA_LBLOCK - 1] = bitlen;
            sha1_block_data_order(&key->md, data, 1);
            mask = 0 - ((j - inp_len - 73) >> (sizeof(j) * 8 - 1));
            pmac->u[0] |= key->md.h0 & mask;
            pmac->u[1] |= key->md.h1 & mask;
            pmac->u[2] |= key->md.h2 & mask;
            pmac->u[3] |= key->md.h3 & mask;
            pmac->u[4] |= key->md.h4 & mask;

#   ifdef BSWAP4
            pmac->u[0] = BSWAP4(pmac->u[0]);
            pmac->u[1] = BSWAP4(pmac->u[1]);
            pmac->u[2] = BSWAP4(pmac->u[2]);
            pmac->u[3] = BSWAP4(pmac->u[3]);
            pmac->u[4] = BSWAP4(pmac->u[4]);
#   else
            for (i = 0; i < 5; i++) {
                res = pmac->u[i];
                pmac->c[4 * i + 0] = (unsigned char)(res >> 24);
                pmac->c[4 * i + 1] = (unsigned char)(res >> 16);
                pmac->c[4 * i + 2] = (unsigned char)(res >> 8);
                pmac->c[4 * i + 3] = (unsigned char)res;
            }
#   endif
            len += SHA_DIGEST_LENGTH;
#  else
            SHA1_Update(&key->md, out, inp_len);
            res = key->md.num;
            SHA1_Final(pmac->c, &key->md);

            {
                unsigned int inp_blocks, pad_blocks;

                /* but pretend as if we hashed padded payload */
                inp_blocks =
                    1 + ((SHA_CBLOCK - 9 - res) >> (sizeof(res) * 8 - 1));
                res += (unsigned int)(len - inp_len);
                pad_blocks = res / SHA_CBLOCK;
                res %= SHA_CBLOCK;
                pad_blocks +=
                    1 + ((SHA_CBLOCK - 9 - res) >> (sizeof(res) * 8 - 1));
                for (; inp_blocks < pad_blocks; inp_blocks++)
                    sha1_block_data_order(&key->md, data, 1);
            }
#  endif
            key->md = key->tail;
            SHA1_Update(&key->md, pmac->c, SHA_DIGEST_LENGTH);
            SHA1_Final(pmac->c, &key->md);

            /* verify HMAC */
            out += inp_len;
            len -= inp_len;
#  if 1
            {
                unsigned char *p = out + len - 1 - maxpad - SHA_DIGEST_LENGTH;
                size_t off = out - p;
                unsigned int c, cmask;

                maxpad += SHA_DIGEST_LENGTH;
                for (res = 0, i = 0, j = 0; j < maxpad; j++) {
                    c = p[j];
                    cmask =
                        ((int)(j - off - SHA_DIGEST_LENGTH)) >> (sizeof(int) *
                                                                 8 - 1);
                    res |= (c ^ pad) & ~cmask; /* ... and padding */
                    cmask &= ((int)(off - 1 - j)) >> (sizeof(int) * 8 - 1);
                    res |= (c ^ pmac->c[i]) & cmask;
                    i += 1 & cmask;
                }
                maxpad -= SHA_DIGEST_LENGTH;

                res = 0 - ((0 - res) >> (sizeof(res) * 8 - 1));
                ret &= (int)~res;
            }
#  else
            for (res = 0, i = 0; i < SHA_DIGEST_LENGTH; i++)
                res |= out[i] ^ pmac->c[i];
            res = 0 - ((0 - res) >> (sizeof(res) * 8 - 1));
            ret &= (int)~res;

            /* verify padding */
            pad = (pad & ~res) | (maxpad & res);
            out = out + len - 1 - pad;
            for (res = 0, i = 0; i < pad; i++)
                res |= out[i] ^ pad;

            res = (0 - res) >> (sizeof(res) * 8 - 1);
            ret &= (int)~res;
#  endif
            return ret;
        } else {
#  if defined(STITCHED_DECRYPT_CALL)
            if (len >= 1024 && ctx->key_len == 32) {
                if (sha_off %= SHA_CBLOCK)
                    blocks = (len - 3 * SHA_CBLOCK) / SHA_CBLOCK;
                else
                    blocks = (len - 2 * SHA_CBLOCK) / SHA_CBLOCK;
                aes_off = len - blocks * SHA_CBLOCK;

                aesni_cbc_encrypt(in, out, aes_off, &key->ks, ctx->iv, 0);
                SHA1_Update(&key->md, out, sha_off);
                aesni256_cbc_sha1_dec(in + aes_off,
                                      out + aes_off, blocks, &key->ks,
                                      ctx->iv, &key->md, out + sha_off);

                sha_off += blocks *= SHA_CBLOCK;
                out += sha_off;
                len -= sha_off;

                key->md.Nh += blocks >> 29;
                key->md.Nl += blocks <<= 3;
                if (key->md.Nl < (unsigned int)blocks)
                    key->md.Nh++;
            } else
#  endif
                /* decrypt HMAC|padding at once */
                aesni_cbc_encrypt(in, out, len, &key->ks, ctx->iv, 0);

            SHA1_Update(&key->md, out, len);
        }
    }

    return 1;
}
",C,"            ret &= constant_time_ge(maxpad, pad);

",,643e8e972e54fa358935e5f8b7f5a8be9616d56b,"@@ -60,6 +60,7 @@
 # include <openssl/sha.h>
 # include <openssl/rand.h>
 # include ""modes_lcl.h""
+# include ""constant_time_locl.h""
 
 # ifndef EVP_CIPH_FLAG_AEAD_CIPHER
 #  define EVP_CIPH_FLAG_AEAD_CIPHER       0x200000
@@ -578,6 +579,8 @@ static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
             maxpad |= (255 - maxpad) >> (sizeof(maxpad) * 8 - 8);
             maxpad &= 255;
 
+            ret &= constant_time_ge(maxpad, pad);
+
             inp_len = len - (SHA_DIGEST_LENGTH + pad + 1);
             mask = (0 - ((inp_len - len) >> (sizeof(inp_len) * 8 - 1)));
             inp_len &= mask;",openssl,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/evp/e_aes_cbc_hmac_sha1.c;h=6dfd590a4a2c8e2d58ac40927a62874cdd3720df;hb=68595c0c2886e7942a14f98c17a55a88afb6c292,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/evp/e_aes_cbc_hmac_sha1.c;h=8330964ee16b0061b810afb2d001709cb53984e5,1,"static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                                      const unsigned char *in, size_t len)
{
    EVP_AES_HMAC_SHA1 *key = data(ctx);
    unsigned int l;
    size_t plen = key->payload_length, iv = 0, /* explicit IV in TLS 1.1 and
                                                * later */
        sha_off = 0;
#  if defined(STITCHED_CALL)
    size_t aes_off = 0, blocks;

    sha_off = SHA_CBLOCK - key->md.num;
#  endif

    key->payload_length = NO_PAYLOAD_LENGTH;

    if (len % AES_BLOCK_SIZE)
        return 0;

    if (ctx->encrypt) {
        if (plen == NO_PAYLOAD_LENGTH)
            plen = len;
        else if (len !=
                 ((plen + SHA_DIGEST_LENGTH +
                   AES_BLOCK_SIZE) & -AES_BLOCK_SIZE))
            return 0;
        else if (key->aux.tls_ver >= TLS1_1_VERSION)
            iv = AES_BLOCK_SIZE;

#  if defined(STITCHED_CALL)
        if (plen > (sha_off + iv)
            && (blocks = (plen - (sha_off + iv)) / SHA_CBLOCK)) {
            SHA1_Update(&key->md, in + iv, sha_off);

            aesni_cbc_sha1_enc(in, out, blocks, &key->ks,
                               ctx->iv, &key->md, in + iv + sha_off);
            blocks *= SHA_CBLOCK;
            aes_off += blocks;
            sha_off += blocks;
            key->md.Nh += blocks >> 29;
            key->md.Nl += blocks <<= 3;
            if (key->md.Nl < (unsigned int)blocks)
                key->md.Nh++;
        } else {
            sha_off = 0;
        }
#  endif
        sha_off += iv;
        SHA1_Update(&key->md, in + sha_off, plen - sha_off);

        if (plen != len) {      /* ""TLS"" mode of operation */
            if (in != out)
                memcpy(out + aes_off, in + aes_off, plen - aes_off);

            /* calculate HMAC and append it to payload */
            SHA1_Final(out + plen, &key->md);
            key->md = key->tail;
            SHA1_Update(&key->md, out + plen, SHA_DIGEST_LENGTH);
            SHA1_Final(out + plen, &key->md);

            /* pad the payload|hmac */
            plen += SHA_DIGEST_LENGTH;
            for (l = len - plen - 1; plen < len; plen++)
                out[plen] = l;
            /* encrypt HMAC|padding at once */
            aesni_cbc_encrypt(out + aes_off, out + aes_off, len - aes_off,
                              &key->ks, ctx->iv, 1);
        } else {
            aesni_cbc_encrypt(in + aes_off, out + aes_off, len - aes_off,
                              &key->ks, ctx->iv, 1);
        }
    } else {
        union {
            unsigned int u[SHA_DIGEST_LENGTH / sizeof(unsigned int)];
            unsigned char c[32 + SHA_DIGEST_LENGTH];
        } mac, *pmac;

        /* arrange cache line alignment */
        pmac = (void *)(((size_t)mac.c + 31) & ((size_t)0 - 32));

        if (plen != NO_PAYLOAD_LENGTH) { /* ""TLS"" mode of operation */
            size_t inp_len, mask, j, i;
            unsigned int res, maxpad, pad, bitlen;
            int ret = 1;
            union {
                unsigned int u[SHA_LBLOCK];
                unsigned char c[SHA_CBLOCK];
            } *data = (void *)key->md.data;
#  if defined(STITCHED_DECRYPT_CALL)
            unsigned char tail_iv[AES_BLOCK_SIZE];
            int stitch = 0;
#  endif

            if ((key->aux.tls_aad[plen - 4] << 8 | key->aux.tls_aad[plen - 3])
                >= TLS1_1_VERSION) {
                if (len < (AES_BLOCK_SIZE + SHA_DIGEST_LENGTH + 1))
                    return 0;

                /* omit explicit iv */
                memcpy(ctx->iv, in, AES_BLOCK_SIZE);
                in += AES_BLOCK_SIZE;
                out += AES_BLOCK_SIZE;
                len -= AES_BLOCK_SIZE;
            } else if (len < (SHA_DIGEST_LENGTH + 1))
                return 0;

#  if defined(STITCHED_DECRYPT_CALL)
            if (len >= 1024 && ctx->key_len == 32) {
                /* decrypt last block */
                memcpy(tail_iv, in + len - 2 * AES_BLOCK_SIZE,
                       AES_BLOCK_SIZE);
                aesni_cbc_encrypt(in + len - AES_BLOCK_SIZE,
                                  out + len - AES_BLOCK_SIZE, AES_BLOCK_SIZE,
                                  &key->ks, tail_iv, 0);
                stitch = 1;
            } else
#  endif
                /* decrypt HMAC|padding at once */
                aesni_cbc_encrypt(in, out, len, &key->ks, ctx->iv, 0);

            /* figure out payload length */
            pad = out[len - 1];
            maxpad = len - (SHA_DIGEST_LENGTH + 1);
            maxpad |= (255 - maxpad) >> (sizeof(maxpad) * 8 - 8);
             maxpad |= (255 - maxpad) >> (sizeof(maxpad) * 8 - 8);
             maxpad &= 255;
 
//fix_flaw_line_below:
//            ret &= constant_time_ge(maxpad, pad);
//fix_flaw_line_below:
//
             inp_len = len - (SHA_DIGEST_LENGTH + pad + 1);
             mask = (0 - ((inp_len - len) >> (sizeof(inp_len) * 8 - 1)));
             inp_len &= mask;
            key->aux.tls_aad[plen - 1] = inp_len;

            /* calculate HMAC */
            key->md = key->head;
            SHA1_Update(&key->md, key->aux.tls_aad, plen);

#  if defined(STITCHED_DECRYPT_CALL)
            if (stitch) {
                blocks = (len - (256 + 32 + SHA_CBLOCK)) / SHA_CBLOCK;
                aes_off = len - AES_BLOCK_SIZE - blocks * SHA_CBLOCK;
                sha_off = SHA_CBLOCK - plen;

                aesni_cbc_encrypt(in, out, aes_off, &key->ks, ctx->iv, 0);

                SHA1_Update(&key->md, out, sha_off);
                aesni256_cbc_sha1_dec(in + aes_off,
                                      out + aes_off, blocks, &key->ks,
                                      ctx->iv, &key->md, out + sha_off);

                sha_off += blocks *= SHA_CBLOCK;
                out += sha_off;
                len -= sha_off;
                inp_len -= sha_off;

                key->md.Nl += (blocks << 3); /* at most 18 bits */
                memcpy(ctx->iv, tail_iv, AES_BLOCK_SIZE);
            }
#  endif

#  if 1
            len -= SHA_DIGEST_LENGTH; /* amend mac */
            if (len >= (256 + SHA_CBLOCK)) {
                j = (len - (256 + SHA_CBLOCK)) & (0 - SHA_CBLOCK);
                j += SHA_CBLOCK - key->md.num;
                SHA1_Update(&key->md, out, j);
                out += j;
                len -= j;
                inp_len -= j;
            }

            /* but pretend as if we hashed padded payload */
            bitlen = key->md.Nl + (inp_len << 3); /* at most 18 bits */
#   ifdef BSWAP4
            bitlen = BSWAP4(bitlen);
#   else
            mac.c[0] = 0;
            mac.c[1] = (unsigned char)(bitlen >> 16);
            mac.c[2] = (unsigned char)(bitlen >> 8);
            mac.c[3] = (unsigned char)bitlen;
            bitlen = mac.u[0];
#   endif

            pmac->u[0] = 0;
            pmac->u[1] = 0;
            pmac->u[2] = 0;
            pmac->u[3] = 0;
            pmac->u[4] = 0;

            for (res = key->md.num, j = 0; j < len; j++) {
                size_t c = out[j];
                mask = (j - inp_len) >> (sizeof(j) * 8 - 8);
                c &= mask;
                c |= 0x80 & ~mask & ~((inp_len - j) >> (sizeof(j) * 8 - 8));
                data->c[res++] = (unsigned char)c;

                if (res != SHA_CBLOCK)
                    continue;

                /* j is not incremented yet */
                mask = 0 - ((inp_len + 7 - j) >> (sizeof(j) * 8 - 1));
                data->u[SHA_LBLOCK - 1] |= bitlen & mask;
                sha1_block_data_order(&key->md, data, 1);
                mask &= 0 - ((j - inp_len - 72) >> (sizeof(j) * 8 - 1));
                pmac->u[0] |= key->md.h0 & mask;
                pmac->u[1] |= key->md.h1 & mask;
                pmac->u[2] |= key->md.h2 & mask;
                pmac->u[3] |= key->md.h3 & mask;
                pmac->u[4] |= key->md.h4 & mask;
                res = 0;
            }

            for (i = res; i < SHA_CBLOCK; i++, j++)
                data->c[i] = 0;

            if (res > SHA_CBLOCK - 8) {
                mask = 0 - ((inp_len + 8 - j) >> (sizeof(j) * 8 - 1));
                data->u[SHA_LBLOCK - 1] |= bitlen & mask;
                sha1_block_data_order(&key->md, data, 1);
                mask &= 0 - ((j - inp_len - 73) >> (sizeof(j) * 8 - 1));
                pmac->u[0] |= key->md.h0 & mask;
                pmac->u[1] |= key->md.h1 & mask;
                pmac->u[2] |= key->md.h2 & mask;
                pmac->u[3] |= key->md.h3 & mask;
                pmac->u[4] |= key->md.h4 & mask;

                memset(data, 0, SHA_CBLOCK);
                j += 64;
            }
            data->u[SHA_LBLOCK - 1] = bitlen;
            sha1_block_data_order(&key->md, data, 1);
            mask = 0 - ((j - inp_len - 73) >> (sizeof(j) * 8 - 1));
            pmac->u[0] |= key->md.h0 & mask;
            pmac->u[1] |= key->md.h1 & mask;
            pmac->u[2] |= key->md.h2 & mask;
            pmac->u[3] |= key->md.h3 & mask;
            pmac->u[4] |= key->md.h4 & mask;

#   ifdef BSWAP4
            pmac->u[0] = BSWAP4(pmac->u[0]);
            pmac->u[1] = BSWAP4(pmac->u[1]);
            pmac->u[2] = BSWAP4(pmac->u[2]);
            pmac->u[3] = BSWAP4(pmac->u[3]);
            pmac->u[4] = BSWAP4(pmac->u[4]);
#   else
            for (i = 0; i < 5; i++) {
                res = pmac->u[i];
                pmac->c[4 * i + 0] = (unsigned char)(res >> 24);
                pmac->c[4 * i + 1] = (unsigned char)(res >> 16);
                pmac->c[4 * i + 2] = (unsigned char)(res >> 8);
                pmac->c[4 * i + 3] = (unsigned char)res;
            }
#   endif
            len += SHA_DIGEST_LENGTH;
#  else
            SHA1_Update(&key->md, out, inp_len);
            res = key->md.num;
            SHA1_Final(pmac->c, &key->md);

            {
                unsigned int inp_blocks, pad_blocks;

                /* but pretend as if we hashed padded payload */
                inp_blocks =
                    1 + ((SHA_CBLOCK - 9 - res) >> (sizeof(res) * 8 - 1));
                res += (unsigned int)(len - inp_len);
                pad_blocks = res / SHA_CBLOCK;
                res %= SHA_CBLOCK;
                pad_blocks +=
                    1 + ((SHA_CBLOCK - 9 - res) >> (sizeof(res) * 8 - 1));
                for (; inp_blocks < pad_blocks; inp_blocks++)
                    sha1_block_data_order(&key->md, data, 1);
            }
#  endif
            key->md = key->tail;
            SHA1_Update(&key->md, pmac->c, SHA_DIGEST_LENGTH);
            SHA1_Final(pmac->c, &key->md);

            /* verify HMAC */
            out += inp_len;
            len -= inp_len;
#  if 1
            {
                unsigned char *p = out + len - 1 - maxpad - SHA_DIGEST_LENGTH;
                size_t off = out - p;
                unsigned int c, cmask;

                maxpad += SHA_DIGEST_LENGTH;
                for (res = 0, i = 0, j = 0; j < maxpad; j++) {
                    c = p[j];
                    cmask =
                        ((int)(j - off - SHA_DIGEST_LENGTH)) >> (sizeof(int) *
                                                                 8 - 1);
                    res |= (c ^ pad) & ~cmask; /* ... and padding */
                    cmask &= ((int)(off - 1 - j)) >> (sizeof(int) * 8 - 1);
                    res |= (c ^ pmac->c[i]) & cmask;
                    i += 1 & cmask;
                }
                maxpad -= SHA_DIGEST_LENGTH;

                res = 0 - ((0 - res) >> (sizeof(res) * 8 - 1));
                ret &= (int)~res;
            }
#  else
            for (res = 0, i = 0; i < SHA_DIGEST_LENGTH; i++)
                res |= out[i] ^ pmac->c[i];
            res = 0 - ((0 - res) >> (sizeof(res) * 8 - 1));
            ret &= (int)~res;

            /* verify padding */
            pad = (pad & ~res) | (maxpad & res);
            out = out + len - 1 - pad;
            for (res = 0, i = 0; i < pad; i++)
                res |= out[i] ^ pad;

            res = (0 - res) >> (sizeof(res) * 8 - 1);
            ret &= (int)~res;
#  endif
            return ret;
        } else {
#  if defined(STITCHED_DECRYPT_CALL)
            if (len >= 1024 && ctx->key_len == 32) {
                if (sha_off %= SHA_CBLOCK)
                    blocks = (len - 3 * SHA_CBLOCK) / SHA_CBLOCK;
                else
                    blocks = (len - 2 * SHA_CBLOCK) / SHA_CBLOCK;
                aes_off = len - blocks * SHA_CBLOCK;

                aesni_cbc_encrypt(in, out, aes_off, &key->ks, ctx->iv, 0);
                SHA1_Update(&key->md, out, sha_off);
                aesni256_cbc_sha1_dec(in + aes_off,
                                      out + aes_off, blocks, &key->ks,
                                      ctx->iv, &key->md, out + sha_off);

                sha_off += blocks *= SHA_CBLOCK;
                out += sha_off;
                len -= sha_off;

                key->md.Nh += blocks >> 29;
                key->md.Nl += blocks <<= 3;
                if (key->md.Nl < (unsigned int)blocks)
                    key->md.Nh++;
            } else
#  endif
                /* decrypt HMAC|padding at once */
                aesni_cbc_encrypt(in, out, len, &key->ks, ctx->iv, 0);

            SHA1_Update(&key->md, out, len);
        }
    }

    return 1;
}
"
651,178387,,Remote,Not required,,CVE-2016-2107,https://www.cvedetails.com/cve/CVE-2016-2107/,CWE-310,High,Partial,,,2016-05-04,2.6,"The AES-NI implementation in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h does not consider memory allocation during a certain padding check, which allows remote attackers to obtain sensitive cleartext information via a padding-oracle attack against an AES CBC session. NOTE: this vulnerability exists because of an incorrect fix for CVE-2013-0169.",2018-10-30,+Info,2,https://git.openssl.org/?p=openssl.git;a=commit;h=68595c0c2886e7942a14f98c17a55a88afb6c292,68595c0c2886e7942a14f98c17a55a88afb6c292,,0,,,"static int aesni_cbc_hmac_sha256_cipher(EVP_CIPHER_CTX *ctx,
                                        unsigned char *out,
                                        const unsigned char *in, size_t len)
{
    EVP_AES_HMAC_SHA256 *key = data(ctx);
    unsigned int l;
    size_t plen = key->payload_length, iv = 0, /* explicit IV in TLS 1.1 and
                                                * later */
        sha_off = 0;
#  if defined(STITCHED_CALL)
    size_t aes_off = 0, blocks;

    sha_off = SHA256_CBLOCK - key->md.num;
#  endif

    key->payload_length = NO_PAYLOAD_LENGTH;

    if (len % AES_BLOCK_SIZE)
        return 0;

    if (ctx->encrypt) {
        if (plen == NO_PAYLOAD_LENGTH)
            plen = len;
        else if (len !=
                 ((plen + SHA256_DIGEST_LENGTH +
                   AES_BLOCK_SIZE) & -AES_BLOCK_SIZE))
            return 0;
        else if (key->aux.tls_ver >= TLS1_1_VERSION)
            iv = AES_BLOCK_SIZE;

#  if defined(STITCHED_CALL)
        /*
         * Assembly stitch handles AVX-capable processors, but its
         * performance is not optimal on AMD Jaguar, ~40% worse, for
         * unknown reasons. Incidentally processor in question supports
         * AVX, but not AMD-specific XOP extension, which can be used
         * to identify it and avoid stitch invocation. So that after we
         * establish that current CPU supports AVX, we even see if it's
         * either even XOP-capable Bulldozer-based or GenuineIntel one.
         */
        if (OPENSSL_ia32cap_P[1] & (1 << (60 - 32)) && /* AVX? */
            ((OPENSSL_ia32cap_P[1] & (1 << (43 - 32))) /* XOP? */
             | (OPENSSL_ia32cap_P[0] & (1<<30))) &&    /* ""Intel CPU""? */
            plen > (sha_off + iv) &&
            (blocks = (plen - (sha_off + iv)) / SHA256_CBLOCK)) {
            SHA256_Update(&key->md, in + iv, sha_off);

            (void)aesni_cbc_sha256_enc(in, out, blocks, &key->ks,
                                       ctx->iv, &key->md, in + iv + sha_off);
            blocks *= SHA256_CBLOCK;
            aes_off += blocks;
            sha_off += blocks;
            key->md.Nh += blocks >> 29;
            key->md.Nl += blocks <<= 3;
            if (key->md.Nl < (unsigned int)blocks)
                key->md.Nh++;
        } else {
            sha_off = 0;
        }
#  endif
        sha_off += iv;
        SHA256_Update(&key->md, in + sha_off, plen - sha_off);

        if (plen != len) {      /* ""TLS"" mode of operation */
            if (in != out)
                memcpy(out + aes_off, in + aes_off, plen - aes_off);

            /* calculate HMAC and append it to payload */
            SHA256_Final(out + plen, &key->md);
            key->md = key->tail;
            SHA256_Update(&key->md, out + plen, SHA256_DIGEST_LENGTH);
            SHA256_Final(out + plen, &key->md);

            /* pad the payload|hmac */
            plen += SHA256_DIGEST_LENGTH;
            for (l = len - plen - 1; plen < len; plen++)
                out[plen] = l;
            /* encrypt HMAC|padding at once */
            aesni_cbc_encrypt(out + aes_off, out + aes_off, len - aes_off,
                              &key->ks, ctx->iv, 1);
        } else {
            aesni_cbc_encrypt(in + aes_off, out + aes_off, len - aes_off,
                              &key->ks, ctx->iv, 1);
        }
    } else {
        union {
            unsigned int u[SHA256_DIGEST_LENGTH / sizeof(unsigned int)];
            unsigned char c[64 + SHA256_DIGEST_LENGTH];
        } mac, *pmac;

        /* arrange cache line alignment */
        pmac = (void *)(((size_t)mac.c + 63) & ((size_t)0 - 64));

        /* decrypt HMAC|padding at once */
        aesni_cbc_encrypt(in, out, len, &key->ks, ctx->iv, 0);

        if (plen != NO_PAYLOAD_LENGTH) { /* ""TLS"" mode of operation */
            size_t inp_len, mask, j, i;
            unsigned int res, maxpad, pad, bitlen;
            int ret = 1;
            union {
                unsigned int u[SHA_LBLOCK];
                unsigned char c[SHA256_CBLOCK];
            } *data = (void *)key->md.data;

            if ((key->aux.tls_aad[plen - 4] << 8 | key->aux.tls_aad[plen - 3])
                >= TLS1_1_VERSION)
                iv = AES_BLOCK_SIZE;

            if (len < (iv + SHA256_DIGEST_LENGTH + 1))
                return 0;

            /* omit explicit iv */
            out += iv;
            len -= iv;

            /* figure out payload length */
            pad = out[len - 1];
            maxpad = len - (SHA256_DIGEST_LENGTH + 1);
            maxpad |= (255 - maxpad) >> (sizeof(maxpad) * 8 - 8);
             maxpad |= (255 - maxpad) >> (sizeof(maxpad) * 8 - 8);
             maxpad &= 255;
 
            ret &= constant_time_ge(maxpad, pad);

             inp_len = len - (SHA256_DIGEST_LENGTH + pad + 1);
             mask = (0 - ((inp_len - len) >> (sizeof(inp_len) * 8 - 1)));
             inp_len &= mask;
            key->aux.tls_aad[plen - 1] = inp_len;

            /* calculate HMAC */
            key->md = key->head;
            SHA256_Update(&key->md, key->aux.tls_aad, plen);

#  if 1
            len -= SHA256_DIGEST_LENGTH; /* amend mac */
            if (len >= (256 + SHA256_CBLOCK)) {
                j = (len - (256 + SHA256_CBLOCK)) & (0 - SHA256_CBLOCK);
                j += SHA256_CBLOCK - key->md.num;
                SHA256_Update(&key->md, out, j);
                out += j;
                len -= j;
                inp_len -= j;
            }

            /* but pretend as if we hashed padded payload */
            bitlen = key->md.Nl + (inp_len << 3); /* at most 18 bits */
#   ifdef BSWAP4
            bitlen = BSWAP4(bitlen);
#   else
            mac.c[0] = 0;
            mac.c[1] = (unsigned char)(bitlen >> 16);
            mac.c[2] = (unsigned char)(bitlen >> 8);
            mac.c[3] = (unsigned char)bitlen;
            bitlen = mac.u[0];
#   endif

            pmac->u[0] = 0;
            pmac->u[1] = 0;
            pmac->u[2] = 0;
            pmac->u[3] = 0;
            pmac->u[4] = 0;
            pmac->u[5] = 0;
            pmac->u[6] = 0;
            pmac->u[7] = 0;

            for (res = key->md.num, j = 0; j < len; j++) {
                size_t c = out[j];
                mask = (j - inp_len) >> (sizeof(j) * 8 - 8);
                c &= mask;
                c |= 0x80 & ~mask & ~((inp_len - j) >> (sizeof(j) * 8 - 8));
                data->c[res++] = (unsigned char)c;

                if (res != SHA256_CBLOCK)
                    continue;

                /* j is not incremented yet */
                mask = 0 - ((inp_len + 7 - j) >> (sizeof(j) * 8 - 1));
                data->u[SHA_LBLOCK - 1] |= bitlen & mask;
                sha256_block_data_order(&key->md, data, 1);
                mask &= 0 - ((j - inp_len - 72) >> (sizeof(j) * 8 - 1));
                pmac->u[0] |= key->md.h[0] & mask;
                pmac->u[1] |= key->md.h[1] & mask;
                pmac->u[2] |= key->md.h[2] & mask;
                pmac->u[3] |= key->md.h[3] & mask;
                pmac->u[4] |= key->md.h[4] & mask;
                pmac->u[5] |= key->md.h[5] & mask;
                pmac->u[6] |= key->md.h[6] & mask;
                pmac->u[7] |= key->md.h[7] & mask;
                res = 0;
            }

            for (i = res; i < SHA256_CBLOCK; i++, j++)
                data->c[i] = 0;

            if (res > SHA256_CBLOCK - 8) {
                mask = 0 - ((inp_len + 8 - j) >> (sizeof(j) * 8 - 1));
                data->u[SHA_LBLOCK - 1] |= bitlen & mask;
                sha256_block_data_order(&key->md, data, 1);
                mask &= 0 - ((j - inp_len - 73) >> (sizeof(j) * 8 - 1));
                pmac->u[0] |= key->md.h[0] & mask;
                pmac->u[1] |= key->md.h[1] & mask;
                pmac->u[2] |= key->md.h[2] & mask;
                pmac->u[3] |= key->md.h[3] & mask;
                pmac->u[4] |= key->md.h[4] & mask;
                pmac->u[5] |= key->md.h[5] & mask;
                pmac->u[6] |= key->md.h[6] & mask;
                pmac->u[7] |= key->md.h[7] & mask;

                memset(data, 0, SHA256_CBLOCK);
                j += 64;
            }
            data->u[SHA_LBLOCK - 1] = bitlen;
            sha256_block_data_order(&key->md, data, 1);
            mask = 0 - ((j - inp_len - 73) >> (sizeof(j) * 8 - 1));
            pmac->u[0] |= key->md.h[0] & mask;
            pmac->u[1] |= key->md.h[1] & mask;
            pmac->u[2] |= key->md.h[2] & mask;
            pmac->u[3] |= key->md.h[3] & mask;
            pmac->u[4] |= key->md.h[4] & mask;
            pmac->u[5] |= key->md.h[5] & mask;
            pmac->u[6] |= key->md.h[6] & mask;
            pmac->u[7] |= key->md.h[7] & mask;

#   ifdef BSWAP4
            pmac->u[0] = BSWAP4(pmac->u[0]);
            pmac->u[1] = BSWAP4(pmac->u[1]);
            pmac->u[2] = BSWAP4(pmac->u[2]);
            pmac->u[3] = BSWAP4(pmac->u[3]);
            pmac->u[4] = BSWAP4(pmac->u[4]);
            pmac->u[5] = BSWAP4(pmac->u[5]);
            pmac->u[6] = BSWAP4(pmac->u[6]);
            pmac->u[7] = BSWAP4(pmac->u[7]);
#   else
            for (i = 0; i < 8; i++) {
                res = pmac->u[i];
                pmac->c[4 * i + 0] = (unsigned char)(res >> 24);
                pmac->c[4 * i + 1] = (unsigned char)(res >> 16);
                pmac->c[4 * i + 2] = (unsigned char)(res >> 8);
                pmac->c[4 * i + 3] = (unsigned char)res;
            }
#   endif
            len += SHA256_DIGEST_LENGTH;
#  else
            SHA256_Update(&key->md, out, inp_len);
            res = key->md.num;
            SHA256_Final(pmac->c, &key->md);

            {
                unsigned int inp_blocks, pad_blocks;

                /* but pretend as if we hashed padded payload */
                inp_blocks =
                    1 + ((SHA256_CBLOCK - 9 - res) >> (sizeof(res) * 8 - 1));
                res += (unsigned int)(len - inp_len);
                pad_blocks = res / SHA256_CBLOCK;
                res %= SHA256_CBLOCK;
                pad_blocks +=
                    1 + ((SHA256_CBLOCK - 9 - res) >> (sizeof(res) * 8 - 1));
                for (; inp_blocks < pad_blocks; inp_blocks++)
                    sha1_block_data_order(&key->md, data, 1);
            }
#  endif
            key->md = key->tail;
            SHA256_Update(&key->md, pmac->c, SHA256_DIGEST_LENGTH);
            SHA256_Final(pmac->c, &key->md);

            /* verify HMAC */
            out += inp_len;
            len -= inp_len;
#  if 1
            {
                unsigned char *p =
                    out + len - 1 - maxpad - SHA256_DIGEST_LENGTH;
                size_t off = out - p;
                unsigned int c, cmask;

                maxpad += SHA256_DIGEST_LENGTH;
                for (res = 0, i = 0, j = 0; j < maxpad; j++) {
                    c = p[j];
                    cmask =
                        ((int)(j - off - SHA256_DIGEST_LENGTH)) >>
                        (sizeof(int) * 8 - 1);
                    res |= (c ^ pad) & ~cmask; /* ... and padding */
                    cmask &= ((int)(off - 1 - j)) >> (sizeof(int) * 8 - 1);
                    res |= (c ^ pmac->c[i]) & cmask;
                    i += 1 & cmask;
                }
                maxpad -= SHA256_DIGEST_LENGTH;

                res = 0 - ((0 - res) >> (sizeof(res) * 8 - 1));
                ret &= (int)~res;
            }
#  else
            for (res = 0, i = 0; i < SHA256_DIGEST_LENGTH; i++)
                res |= out[i] ^ pmac->c[i];
            res = 0 - ((0 - res) >> (sizeof(res) * 8 - 1));
            ret &= (int)~res;

            /* verify padding */
            pad = (pad & ~res) | (maxpad & res);
            out = out + len - 1 - pad;
            for (res = 0, i = 0; i < pad; i++)
                res |= out[i] ^ pad;

            res = (0 - res) >> (sizeof(res) * 8 - 1);
            ret &= (int)~res;
#  endif
            return ret;
        } else {
            SHA256_Update(&key->md, out, len);
        }
    }

    return 1;
}
","static int aesni_cbc_hmac_sha256_cipher(EVP_CIPHER_CTX *ctx,
                                        unsigned char *out,
                                        const unsigned char *in, size_t len)
{
    EVP_AES_HMAC_SHA256 *key = data(ctx);
    unsigned int l;
    size_t plen = key->payload_length, iv = 0, /* explicit IV in TLS 1.1 and
                                                * later */
        sha_off = 0;
#  if defined(STITCHED_CALL)
    size_t aes_off = 0, blocks;

    sha_off = SHA256_CBLOCK - key->md.num;
#  endif

    key->payload_length = NO_PAYLOAD_LENGTH;

    if (len % AES_BLOCK_SIZE)
        return 0;

    if (ctx->encrypt) {
        if (plen == NO_PAYLOAD_LENGTH)
            plen = len;
        else if (len !=
                 ((plen + SHA256_DIGEST_LENGTH +
                   AES_BLOCK_SIZE) & -AES_BLOCK_SIZE))
            return 0;
        else if (key->aux.tls_ver >= TLS1_1_VERSION)
            iv = AES_BLOCK_SIZE;

#  if defined(STITCHED_CALL)
        /*
         * Assembly stitch handles AVX-capable processors, but its
         * performance is not optimal on AMD Jaguar, ~40% worse, for
         * unknown reasons. Incidentally processor in question supports
         * AVX, but not AMD-specific XOP extension, which can be used
         * to identify it and avoid stitch invocation. So that after we
         * establish that current CPU supports AVX, we even see if it's
         * either even XOP-capable Bulldozer-based or GenuineIntel one.
         */
        if (OPENSSL_ia32cap_P[1] & (1 << (60 - 32)) && /* AVX? */
            ((OPENSSL_ia32cap_P[1] & (1 << (43 - 32))) /* XOP? */
             | (OPENSSL_ia32cap_P[0] & (1<<30))) &&    /* ""Intel CPU""? */
            plen > (sha_off + iv) &&
            (blocks = (plen - (sha_off + iv)) / SHA256_CBLOCK)) {
            SHA256_Update(&key->md, in + iv, sha_off);

            (void)aesni_cbc_sha256_enc(in, out, blocks, &key->ks,
                                       ctx->iv, &key->md, in + iv + sha_off);
            blocks *= SHA256_CBLOCK;
            aes_off += blocks;
            sha_off += blocks;
            key->md.Nh += blocks >> 29;
            key->md.Nl += blocks <<= 3;
            if (key->md.Nl < (unsigned int)blocks)
                key->md.Nh++;
        } else {
            sha_off = 0;
        }
#  endif
        sha_off += iv;
        SHA256_Update(&key->md, in + sha_off, plen - sha_off);

        if (plen != len) {      /* ""TLS"" mode of operation */
            if (in != out)
                memcpy(out + aes_off, in + aes_off, plen - aes_off);

            /* calculate HMAC and append it to payload */
            SHA256_Final(out + plen, &key->md);
            key->md = key->tail;
            SHA256_Update(&key->md, out + plen, SHA256_DIGEST_LENGTH);
            SHA256_Final(out + plen, &key->md);

            /* pad the payload|hmac */
            plen += SHA256_DIGEST_LENGTH;
            for (l = len - plen - 1; plen < len; plen++)
                out[plen] = l;
            /* encrypt HMAC|padding at once */
            aesni_cbc_encrypt(out + aes_off, out + aes_off, len - aes_off,
                              &key->ks, ctx->iv, 1);
        } else {
            aesni_cbc_encrypt(in + aes_off, out + aes_off, len - aes_off,
                              &key->ks, ctx->iv, 1);
        }
    } else {
        union {
            unsigned int u[SHA256_DIGEST_LENGTH / sizeof(unsigned int)];
            unsigned char c[64 + SHA256_DIGEST_LENGTH];
        } mac, *pmac;

        /* arrange cache line alignment */
        pmac = (void *)(((size_t)mac.c + 63) & ((size_t)0 - 64));

        /* decrypt HMAC|padding at once */
        aesni_cbc_encrypt(in, out, len, &key->ks, ctx->iv, 0);

        if (plen != NO_PAYLOAD_LENGTH) { /* ""TLS"" mode of operation */
            size_t inp_len, mask, j, i;
            unsigned int res, maxpad, pad, bitlen;
            int ret = 1;
            union {
                unsigned int u[SHA_LBLOCK];
                unsigned char c[SHA256_CBLOCK];
            } *data = (void *)key->md.data;

            if ((key->aux.tls_aad[plen - 4] << 8 | key->aux.tls_aad[plen - 3])
                >= TLS1_1_VERSION)
                iv = AES_BLOCK_SIZE;

            if (len < (iv + SHA256_DIGEST_LENGTH + 1))
                return 0;

            /* omit explicit iv */
            out += iv;
            len -= iv;

            /* figure out payload length */
            pad = out[len - 1];
            maxpad = len - (SHA256_DIGEST_LENGTH + 1);
            maxpad |= (255 - maxpad) >> (sizeof(maxpad) * 8 - 8);
             maxpad |= (255 - maxpad) >> (sizeof(maxpad) * 8 - 8);
             maxpad &= 255;
 
             inp_len = len - (SHA256_DIGEST_LENGTH + pad + 1);
             mask = (0 - ((inp_len - len) >> (sizeof(inp_len) * 8 - 1)));
             inp_len &= mask;
            key->aux.tls_aad[plen - 1] = inp_len;

            /* calculate HMAC */
            key->md = key->head;
            SHA256_Update(&key->md, key->aux.tls_aad, plen);

#  if 1
            len -= SHA256_DIGEST_LENGTH; /* amend mac */
            if (len >= (256 + SHA256_CBLOCK)) {
                j = (len - (256 + SHA256_CBLOCK)) & (0 - SHA256_CBLOCK);
                j += SHA256_CBLOCK - key->md.num;
                SHA256_Update(&key->md, out, j);
                out += j;
                len -= j;
                inp_len -= j;
            }

            /* but pretend as if we hashed padded payload */
            bitlen = key->md.Nl + (inp_len << 3); /* at most 18 bits */
#   ifdef BSWAP4
            bitlen = BSWAP4(bitlen);
#   else
            mac.c[0] = 0;
            mac.c[1] = (unsigned char)(bitlen >> 16);
            mac.c[2] = (unsigned char)(bitlen >> 8);
            mac.c[3] = (unsigned char)bitlen;
            bitlen = mac.u[0];
#   endif

            pmac->u[0] = 0;
            pmac->u[1] = 0;
            pmac->u[2] = 0;
            pmac->u[3] = 0;
            pmac->u[4] = 0;
            pmac->u[5] = 0;
            pmac->u[6] = 0;
            pmac->u[7] = 0;

            for (res = key->md.num, j = 0; j < len; j++) {
                size_t c = out[j];
                mask = (j - inp_len) >> (sizeof(j) * 8 - 8);
                c &= mask;
                c |= 0x80 & ~mask & ~((inp_len - j) >> (sizeof(j) * 8 - 8));
                data->c[res++] = (unsigned char)c;

                if (res != SHA256_CBLOCK)
                    continue;

                /* j is not incremented yet */
                mask = 0 - ((inp_len + 7 - j) >> (sizeof(j) * 8 - 1));
                data->u[SHA_LBLOCK - 1] |= bitlen & mask;
                sha256_block_data_order(&key->md, data, 1);
                mask &= 0 - ((j - inp_len - 72) >> (sizeof(j) * 8 - 1));
                pmac->u[0] |= key->md.h[0] & mask;
                pmac->u[1] |= key->md.h[1] & mask;
                pmac->u[2] |= key->md.h[2] & mask;
                pmac->u[3] |= key->md.h[3] & mask;
                pmac->u[4] |= key->md.h[4] & mask;
                pmac->u[5] |= key->md.h[5] & mask;
                pmac->u[6] |= key->md.h[6] & mask;
                pmac->u[7] |= key->md.h[7] & mask;
                res = 0;
            }

            for (i = res; i < SHA256_CBLOCK; i++, j++)
                data->c[i] = 0;

            if (res > SHA256_CBLOCK - 8) {
                mask = 0 - ((inp_len + 8 - j) >> (sizeof(j) * 8 - 1));
                data->u[SHA_LBLOCK - 1] |= bitlen & mask;
                sha256_block_data_order(&key->md, data, 1);
                mask &= 0 - ((j - inp_len - 73) >> (sizeof(j) * 8 - 1));
                pmac->u[0] |= key->md.h[0] & mask;
                pmac->u[1] |= key->md.h[1] & mask;
                pmac->u[2] |= key->md.h[2] & mask;
                pmac->u[3] |= key->md.h[3] & mask;
                pmac->u[4] |= key->md.h[4] & mask;
                pmac->u[5] |= key->md.h[5] & mask;
                pmac->u[6] |= key->md.h[6] & mask;
                pmac->u[7] |= key->md.h[7] & mask;

                memset(data, 0, SHA256_CBLOCK);
                j += 64;
            }
            data->u[SHA_LBLOCK - 1] = bitlen;
            sha256_block_data_order(&key->md, data, 1);
            mask = 0 - ((j - inp_len - 73) >> (sizeof(j) * 8 - 1));
            pmac->u[0] |= key->md.h[0] & mask;
            pmac->u[1] |= key->md.h[1] & mask;
            pmac->u[2] |= key->md.h[2] & mask;
            pmac->u[3] |= key->md.h[3] & mask;
            pmac->u[4] |= key->md.h[4] & mask;
            pmac->u[5] |= key->md.h[5] & mask;
            pmac->u[6] |= key->md.h[6] & mask;
            pmac->u[7] |= key->md.h[7] & mask;

#   ifdef BSWAP4
            pmac->u[0] = BSWAP4(pmac->u[0]);
            pmac->u[1] = BSWAP4(pmac->u[1]);
            pmac->u[2] = BSWAP4(pmac->u[2]);
            pmac->u[3] = BSWAP4(pmac->u[3]);
            pmac->u[4] = BSWAP4(pmac->u[4]);
            pmac->u[5] = BSWAP4(pmac->u[5]);
            pmac->u[6] = BSWAP4(pmac->u[6]);
            pmac->u[7] = BSWAP4(pmac->u[7]);
#   else
            for (i = 0; i < 8; i++) {
                res = pmac->u[i];
                pmac->c[4 * i + 0] = (unsigned char)(res >> 24);
                pmac->c[4 * i + 1] = (unsigned char)(res >> 16);
                pmac->c[4 * i + 2] = (unsigned char)(res >> 8);
                pmac->c[4 * i + 3] = (unsigned char)res;
            }
#   endif
            len += SHA256_DIGEST_LENGTH;
#  else
            SHA256_Update(&key->md, out, inp_len);
            res = key->md.num;
            SHA256_Final(pmac->c, &key->md);

            {
                unsigned int inp_blocks, pad_blocks;

                /* but pretend as if we hashed padded payload */
                inp_blocks =
                    1 + ((SHA256_CBLOCK - 9 - res) >> (sizeof(res) * 8 - 1));
                res += (unsigned int)(len - inp_len);
                pad_blocks = res / SHA256_CBLOCK;
                res %= SHA256_CBLOCK;
                pad_blocks +=
                    1 + ((SHA256_CBLOCK - 9 - res) >> (sizeof(res) * 8 - 1));
                for (; inp_blocks < pad_blocks; inp_blocks++)
                    sha1_block_data_order(&key->md, data, 1);
            }
#  endif
            key->md = key->tail;
            SHA256_Update(&key->md, pmac->c, SHA256_DIGEST_LENGTH);
            SHA256_Final(pmac->c, &key->md);

            /* verify HMAC */
            out += inp_len;
            len -= inp_len;
#  if 1
            {
                unsigned char *p =
                    out + len - 1 - maxpad - SHA256_DIGEST_LENGTH;
                size_t off = out - p;
                unsigned int c, cmask;

                maxpad += SHA256_DIGEST_LENGTH;
                for (res = 0, i = 0, j = 0; j < maxpad; j++) {
                    c = p[j];
                    cmask =
                        ((int)(j - off - SHA256_DIGEST_LENGTH)) >>
                        (sizeof(int) * 8 - 1);
                    res |= (c ^ pad) & ~cmask; /* ... and padding */
                    cmask &= ((int)(off - 1 - j)) >> (sizeof(int) * 8 - 1);
                    res |= (c ^ pmac->c[i]) & cmask;
                    i += 1 & cmask;
                }
                maxpad -= SHA256_DIGEST_LENGTH;

                res = 0 - ((0 - res) >> (sizeof(res) * 8 - 1));
                ret &= (int)~res;
            }
#  else
            for (res = 0, i = 0; i < SHA256_DIGEST_LENGTH; i++)
                res |= out[i] ^ pmac->c[i];
            res = 0 - ((0 - res) >> (sizeof(res) * 8 - 1));
            ret &= (int)~res;

            /* verify padding */
            pad = (pad & ~res) | (maxpad & res);
            out = out + len - 1 - pad;
            for (res = 0, i = 0; i < pad; i++)
                res |= out[i] ^ pad;

            res = (0 - res) >> (sizeof(res) * 8 - 1);
            ret &= (int)~res;
#  endif
            return ret;
        } else {
            SHA256_Update(&key->md, out, len);
        }
    }

    return 1;
}
",C,"            ret &= constant_time_ge(maxpad, pad);

",,643e8e972e54fa358935e5f8b7f5a8be9616d56b,"@@ -60,6 +60,7 @@
 # include <openssl/sha.h>
 # include <openssl/rand.h>
 # include ""modes_lcl.h""
+# include ""constant_time_locl.h""
 
 # ifndef EVP_CIPH_FLAG_AEAD_CIPHER
 #  define EVP_CIPH_FLAG_AEAD_CIPHER       0x200000
@@ -589,6 +590,8 @@ static int aesni_cbc_hmac_sha256_cipher(EVP_CIPHER_CTX *ctx,
             maxpad |= (255 - maxpad) >> (sizeof(maxpad) * 8 - 8);
             maxpad &= 255;
 
+            ret &= constant_time_ge(maxpad, pad);
+
             inp_len = len - (SHA256_DIGEST_LENGTH + pad + 1);
             mask = (0 - ((inp_len - len) >> (sizeof(inp_len) * 8 - 1)));
             inp_len &= mask;",openssl,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/evp/e_aes_cbc_hmac_sha256.c;h=46c9d033895b873e9206519145aa1c133bcb5918;hb=68595c0c2886e7942a14f98c17a55a88afb6c292,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/evp/e_aes_cbc_hmac_sha256.c;h=37800213c764eb84f68bbe9eb9a3f601952755fd,1,"static int aesni_cbc_hmac_sha256_cipher(EVP_CIPHER_CTX *ctx,
                                        unsigned char *out,
                                        const unsigned char *in, size_t len)
{
    EVP_AES_HMAC_SHA256 *key = data(ctx);
    unsigned int l;
    size_t plen = key->payload_length, iv = 0, /* explicit IV in TLS 1.1 and
                                                * later */
        sha_off = 0;
#  if defined(STITCHED_CALL)
    size_t aes_off = 0, blocks;

    sha_off = SHA256_CBLOCK - key->md.num;
#  endif

    key->payload_length = NO_PAYLOAD_LENGTH;

    if (len % AES_BLOCK_SIZE)
        return 0;

    if (ctx->encrypt) {
        if (plen == NO_PAYLOAD_LENGTH)
            plen = len;
        else if (len !=
                 ((plen + SHA256_DIGEST_LENGTH +
                   AES_BLOCK_SIZE) & -AES_BLOCK_SIZE))
            return 0;
        else if (key->aux.tls_ver >= TLS1_1_VERSION)
            iv = AES_BLOCK_SIZE;

#  if defined(STITCHED_CALL)
        /*
         * Assembly stitch handles AVX-capable processors, but its
         * performance is not optimal on AMD Jaguar, ~40% worse, for
         * unknown reasons. Incidentally processor in question supports
         * AVX, but not AMD-specific XOP extension, which can be used
         * to identify it and avoid stitch invocation. So that after we
         * establish that current CPU supports AVX, we even see if it's
         * either even XOP-capable Bulldozer-based or GenuineIntel one.
         */
        if (OPENSSL_ia32cap_P[1] & (1 << (60 - 32)) && /* AVX? */
            ((OPENSSL_ia32cap_P[1] & (1 << (43 - 32))) /* XOP? */
             | (OPENSSL_ia32cap_P[0] & (1<<30))) &&    /* ""Intel CPU""? */
            plen > (sha_off + iv) &&
            (blocks = (plen - (sha_off + iv)) / SHA256_CBLOCK)) {
            SHA256_Update(&key->md, in + iv, sha_off);

            (void)aesni_cbc_sha256_enc(in, out, blocks, &key->ks,
                                       ctx->iv, &key->md, in + iv + sha_off);
            blocks *= SHA256_CBLOCK;
            aes_off += blocks;
            sha_off += blocks;
            key->md.Nh += blocks >> 29;
            key->md.Nl += blocks <<= 3;
            if (key->md.Nl < (unsigned int)blocks)
                key->md.Nh++;
        } else {
            sha_off = 0;
        }
#  endif
        sha_off += iv;
        SHA256_Update(&key->md, in + sha_off, plen - sha_off);

        if (plen != len) {      /* ""TLS"" mode of operation */
            if (in != out)
                memcpy(out + aes_off, in + aes_off, plen - aes_off);

            /* calculate HMAC and append it to payload */
            SHA256_Final(out + plen, &key->md);
            key->md = key->tail;
            SHA256_Update(&key->md, out + plen, SHA256_DIGEST_LENGTH);
            SHA256_Final(out + plen, &key->md);

            /* pad the payload|hmac */
            plen += SHA256_DIGEST_LENGTH;
            for (l = len - plen - 1; plen < len; plen++)
                out[plen] = l;
            /* encrypt HMAC|padding at once */
            aesni_cbc_encrypt(out + aes_off, out + aes_off, len - aes_off,
                              &key->ks, ctx->iv, 1);
        } else {
            aesni_cbc_encrypt(in + aes_off, out + aes_off, len - aes_off,
                              &key->ks, ctx->iv, 1);
        }
    } else {
        union {
            unsigned int u[SHA256_DIGEST_LENGTH / sizeof(unsigned int)];
            unsigned char c[64 + SHA256_DIGEST_LENGTH];
        } mac, *pmac;

        /* arrange cache line alignment */
        pmac = (void *)(((size_t)mac.c + 63) & ((size_t)0 - 64));

        /* decrypt HMAC|padding at once */
        aesni_cbc_encrypt(in, out, len, &key->ks, ctx->iv, 0);

        if (plen != NO_PAYLOAD_LENGTH) { /* ""TLS"" mode of operation */
            size_t inp_len, mask, j, i;
            unsigned int res, maxpad, pad, bitlen;
            int ret = 1;
            union {
                unsigned int u[SHA_LBLOCK];
                unsigned char c[SHA256_CBLOCK];
            } *data = (void *)key->md.data;

            if ((key->aux.tls_aad[plen - 4] << 8 | key->aux.tls_aad[plen - 3])
                >= TLS1_1_VERSION)
                iv = AES_BLOCK_SIZE;

            if (len < (iv + SHA256_DIGEST_LENGTH + 1))
                return 0;

            /* omit explicit iv */
            out += iv;
            len -= iv;

            /* figure out payload length */
            pad = out[len - 1];
            maxpad = len - (SHA256_DIGEST_LENGTH + 1);
            maxpad |= (255 - maxpad) >> (sizeof(maxpad) * 8 - 8);
             maxpad |= (255 - maxpad) >> (sizeof(maxpad) * 8 - 8);
             maxpad &= 255;
 
//fix_flaw_line_below:
//            ret &= constant_time_ge(maxpad, pad);
//fix_flaw_line_below:
//
             inp_len = len - (SHA256_DIGEST_LENGTH + pad + 1);
             mask = (0 - ((inp_len - len) >> (sizeof(inp_len) * 8 - 1)));
             inp_len &= mask;
            key->aux.tls_aad[plen - 1] = inp_len;

            /* calculate HMAC */
            key->md = key->head;
            SHA256_Update(&key->md, key->aux.tls_aad, plen);

#  if 1
            len -= SHA256_DIGEST_LENGTH; /* amend mac */
            if (len >= (256 + SHA256_CBLOCK)) {
                j = (len - (256 + SHA256_CBLOCK)) & (0 - SHA256_CBLOCK);
                j += SHA256_CBLOCK - key->md.num;
                SHA256_Update(&key->md, out, j);
                out += j;
                len -= j;
                inp_len -= j;
            }

            /* but pretend as if we hashed padded payload */
            bitlen = key->md.Nl + (inp_len << 3); /* at most 18 bits */
#   ifdef BSWAP4
            bitlen = BSWAP4(bitlen);
#   else
            mac.c[0] = 0;
            mac.c[1] = (unsigned char)(bitlen >> 16);
            mac.c[2] = (unsigned char)(bitlen >> 8);
            mac.c[3] = (unsigned char)bitlen;
            bitlen = mac.u[0];
#   endif

            pmac->u[0] = 0;
            pmac->u[1] = 0;
            pmac->u[2] = 0;
            pmac->u[3] = 0;
            pmac->u[4] = 0;
            pmac->u[5] = 0;
            pmac->u[6] = 0;
            pmac->u[7] = 0;

            for (res = key->md.num, j = 0; j < len; j++) {
                size_t c = out[j];
                mask = (j - inp_len) >> (sizeof(j) * 8 - 8);
                c &= mask;
                c |= 0x80 & ~mask & ~((inp_len - j) >> (sizeof(j) * 8 - 8));
                data->c[res++] = (unsigned char)c;

                if (res != SHA256_CBLOCK)
                    continue;

                /* j is not incremented yet */
                mask = 0 - ((inp_len + 7 - j) >> (sizeof(j) * 8 - 1));
                data->u[SHA_LBLOCK - 1] |= bitlen & mask;
                sha256_block_data_order(&key->md, data, 1);
                mask &= 0 - ((j - inp_len - 72) >> (sizeof(j) * 8 - 1));
                pmac->u[0] |= key->md.h[0] & mask;
                pmac->u[1] |= key->md.h[1] & mask;
                pmac->u[2] |= key->md.h[2] & mask;
                pmac->u[3] |= key->md.h[3] & mask;
                pmac->u[4] |= key->md.h[4] & mask;
                pmac->u[5] |= key->md.h[5] & mask;
                pmac->u[6] |= key->md.h[6] & mask;
                pmac->u[7] |= key->md.h[7] & mask;
                res = 0;
            }

            for (i = res; i < SHA256_CBLOCK; i++, j++)
                data->c[i] = 0;

            if (res > SHA256_CBLOCK - 8) {
                mask = 0 - ((inp_len + 8 - j) >> (sizeof(j) * 8 - 1));
                data->u[SHA_LBLOCK - 1] |= bitlen & mask;
                sha256_block_data_order(&key->md, data, 1);
                mask &= 0 - ((j - inp_len - 73) >> (sizeof(j) * 8 - 1));
                pmac->u[0] |= key->md.h[0] & mask;
                pmac->u[1] |= key->md.h[1] & mask;
                pmac->u[2] |= key->md.h[2] & mask;
                pmac->u[3] |= key->md.h[3] & mask;
                pmac->u[4] |= key->md.h[4] & mask;
                pmac->u[5] |= key->md.h[5] & mask;
                pmac->u[6] |= key->md.h[6] & mask;
                pmac->u[7] |= key->md.h[7] & mask;

                memset(data, 0, SHA256_CBLOCK);
                j += 64;
            }
            data->u[SHA_LBLOCK - 1] = bitlen;
            sha256_block_data_order(&key->md, data, 1);
            mask = 0 - ((j - inp_len - 73) >> (sizeof(j) * 8 - 1));
            pmac->u[0] |= key->md.h[0] & mask;
            pmac->u[1] |= key->md.h[1] & mask;
            pmac->u[2] |= key->md.h[2] & mask;
            pmac->u[3] |= key->md.h[3] & mask;
            pmac->u[4] |= key->md.h[4] & mask;
            pmac->u[5] |= key->md.h[5] & mask;
            pmac->u[6] |= key->md.h[6] & mask;
            pmac->u[7] |= key->md.h[7] & mask;

#   ifdef BSWAP4
            pmac->u[0] = BSWAP4(pmac->u[0]);
            pmac->u[1] = BSWAP4(pmac->u[1]);
            pmac->u[2] = BSWAP4(pmac->u[2]);
            pmac->u[3] = BSWAP4(pmac->u[3]);
            pmac->u[4] = BSWAP4(pmac->u[4]);
            pmac->u[5] = BSWAP4(pmac->u[5]);
            pmac->u[6] = BSWAP4(pmac->u[6]);
            pmac->u[7] = BSWAP4(pmac->u[7]);
#   else
            for (i = 0; i < 8; i++) {
                res = pmac->u[i];
                pmac->c[4 * i + 0] = (unsigned char)(res >> 24);
                pmac->c[4 * i + 1] = (unsigned char)(res >> 16);
                pmac->c[4 * i + 2] = (unsigned char)(res >> 8);
                pmac->c[4 * i + 3] = (unsigned char)res;
            }
#   endif
            len += SHA256_DIGEST_LENGTH;
#  else
            SHA256_Update(&key->md, out, inp_len);
            res = key->md.num;
            SHA256_Final(pmac->c, &key->md);

            {
                unsigned int inp_blocks, pad_blocks;

                /* but pretend as if we hashed padded payload */
                inp_blocks =
                    1 + ((SHA256_CBLOCK - 9 - res) >> (sizeof(res) * 8 - 1));
                res += (unsigned int)(len - inp_len);
                pad_blocks = res / SHA256_CBLOCK;
                res %= SHA256_CBLOCK;
                pad_blocks +=
                    1 + ((SHA256_CBLOCK - 9 - res) >> (sizeof(res) * 8 - 1));
                for (; inp_blocks < pad_blocks; inp_blocks++)
                    sha1_block_data_order(&key->md, data, 1);
            }
#  endif
            key->md = key->tail;
            SHA256_Update(&key->md, pmac->c, SHA256_DIGEST_LENGTH);
            SHA256_Final(pmac->c, &key->md);

            /* verify HMAC */
            out += inp_len;
            len -= inp_len;
#  if 1
            {
                unsigned char *p =
                    out + len - 1 - maxpad - SHA256_DIGEST_LENGTH;
                size_t off = out - p;
                unsigned int c, cmask;

                maxpad += SHA256_DIGEST_LENGTH;
                for (res = 0, i = 0, j = 0; j < maxpad; j++) {
                    c = p[j];
                    cmask =
                        ((int)(j - off - SHA256_DIGEST_LENGTH)) >>
                        (sizeof(int) * 8 - 1);
                    res |= (c ^ pad) & ~cmask; /* ... and padding */
                    cmask &= ((int)(off - 1 - j)) >> (sizeof(int) * 8 - 1);
                    res |= (c ^ pmac->c[i]) & cmask;
                    i += 1 & cmask;
                }
                maxpad -= SHA256_DIGEST_LENGTH;

                res = 0 - ((0 - res) >> (sizeof(res) * 8 - 1));
                ret &= (int)~res;
            }
#  else
            for (res = 0, i = 0; i < SHA256_DIGEST_LENGTH; i++)
                res |= out[i] ^ pmac->c[i];
            res = 0 - ((0 - res) >> (sizeof(res) * 8 - 1));
            ret &= (int)~res;

            /* verify padding */
            pad = (pad & ~res) | (maxpad & res);
            out = out + len - 1 - pad;
            for (res = 0, i = 0; i < pad; i++)
                res |= out[i] ^ pad;

            res = (0 - res) >> (sizeof(res) * 8 - 1);
            ret &= (int)~res;
#  endif
            return ret;
        } else {
            SHA256_Update(&key->md, out, len);
        }
    }

    return 1;
}
"
708,178444,,Remote,Not required,,CVE-2015-8867,https://www.cvedetails.com/cve/CVE-2015-8867/,CWE-310,Low,Partial,,,2016-05-21,5.0,"The openssl_random_pseudo_bytes function in ext/openssl/openssl.c in PHP before 5.4.44, 5.5.x before 5.5.28, and 5.6.x before 5.6.12 incorrectly relies on the deprecated RAND_pseudo_bytes function, which makes it easier for remote attackers to defeat cryptographic protection mechanisms via unspecified vectors.",2018-01-04,,2,https://git.php.net/?p=php-src.git;a=commit;h=16023f3e3b9c06cf677c3c980e8d574e4c162827,16023f3e3b9c06cf677c3c980e8d574e4c162827,,4,,,"PHP_FUNCTION(openssl_random_pseudo_bytes)
{
        long buffer_length;
        unsigned char *buffer = NULL;
        zval *zstrong_result_returned = NULL;
 
        if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l|z"", &buffer_length, &zstrong_result_returned) == FAILURE) {
                return;
		return;
	}

	if (buffer_length <= 0) {
		RETURN_FALSE;
	}

	if (zstrong_result_returned) {
		zval_dtor(zstrong_result_returned);
		ZVAL_BOOL(zstrong_result_returned, 0);
	}
        buffer = emalloc(buffer_length + 1);
 
 #ifdef PHP_WIN32
        /* random/urandom equivalent on Windows */
        if (php_win32_get_random_bytes(buffer, (size_t) buffer_length) == FAILURE) {
                efree(buffer);
	if (php_win32_get_random_bytes(buffer, (size_t) buffer_length) == FAILURE) {
		efree(buffer);
		if (zstrong_result_returned) {
                RETURN_FALSE;
        }
 #else
       if (RAND_bytes(buffer, buffer_length) <= 0) {
                efree(buffer);
                if (zstrong_result_returned) {
                        ZVAL_BOOL(zstrong_result_returned, 0);
		if (zstrong_result_returned) {
			ZVAL_BOOL(zstrong_result_returned, 0);
		}
		RETURN_FALSE;
	}
#endif
        RETVAL_STRINGL((char *)buffer, buffer_length, 0);
 
        if (zstrong_result_returned) {
               ZVAL_BOOL(zstrong_result_returned, 1);
        }
 }
 /* }}} */
","PHP_FUNCTION(openssl_random_pseudo_bytes)
{
        long buffer_length;
        unsigned char *buffer = NULL;
        zval *zstrong_result_returned = NULL;
       int strong_result = 0;
 
        if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l|z"", &buffer_length, &zstrong_result_returned) == FAILURE) {
                return;
		return;
	}

	if (buffer_length <= 0) {
		RETURN_FALSE;
	}

	if (zstrong_result_returned) {
		zval_dtor(zstrong_result_returned);
		ZVAL_BOOL(zstrong_result_returned, 0);
	}
        buffer = emalloc(buffer_length + 1);
 
 #ifdef PHP_WIN32
       strong_result = 1;
        /* random/urandom equivalent on Windows */
        if (php_win32_get_random_bytes(buffer, (size_t) buffer_length) == FAILURE) {
                efree(buffer);
	if (php_win32_get_random_bytes(buffer, (size_t) buffer_length) == FAILURE) {
		efree(buffer);
		if (zstrong_result_returned) {
                RETURN_FALSE;
        }
 #else
       if ((strong_result = RAND_pseudo_bytes(buffer, buffer_length)) < 0) {
                efree(buffer);
                if (zstrong_result_returned) {
                        ZVAL_BOOL(zstrong_result_returned, 0);
		if (zstrong_result_returned) {
			ZVAL_BOOL(zstrong_result_returned, 0);
		}
		RETURN_FALSE;
	}
#endif
        RETVAL_STRINGL((char *)buffer, buffer_length, 0);
 
        if (zstrong_result_returned) {
               ZVAL_BOOL(zstrong_result_returned, strong_result);
        }
 }
 /* }}} */
",C,"       if (RAND_bytes(buffer, buffer_length) <= 0) {
               ZVAL_BOOL(zstrong_result_returned, 1);
","       int strong_result = 0;
       strong_result = 1;
       if ((strong_result = RAND_pseudo_bytes(buffer, buffer_length)) < 0) {
               ZVAL_BOOL(zstrong_result_returned, strong_result);
",7a4584d3f6e1474c5482824990ed619d6c6883c9,"@@ -5070,7 +5070,6 @@ PHP_FUNCTION(openssl_random_pseudo_bytes)
        long buffer_length;
        unsigned char *buffer = NULL;
        zval *zstrong_result_returned = NULL;
-       int strong_result = 0;
 
        if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l|z"", &buffer_length, &zstrong_result_returned) == FAILURE) {
                return;
@@ -5088,7 +5087,6 @@ PHP_FUNCTION(openssl_random_pseudo_bytes)
        buffer = emalloc(buffer_length + 1);
 
 #ifdef PHP_WIN32
-       strong_result = 1;
        /* random/urandom equivalent on Windows */
        if (php_win32_get_random_bytes(buffer, (size_t) buffer_length) == FAILURE) {
                efree(buffer);
@@ -5098,7 +5096,7 @@ PHP_FUNCTION(openssl_random_pseudo_bytes)
                RETURN_FALSE;
        }
 #else
-       if ((strong_result = RAND_pseudo_bytes(buffer, buffer_length)) < 0) {
+       if (RAND_bytes(buffer, buffer_length) <= 0) {
                efree(buffer);
                if (zstrong_result_returned) {
                        ZVAL_BOOL(zstrong_result_returned, 0);
@@ -5111,7 +5109,7 @@ PHP_FUNCTION(openssl_random_pseudo_bytes)
        RETVAL_STRINGL((char *)buffer, buffer_length, 0);
 
        if (zstrong_result_returned) {
-               ZVAL_BOOL(zstrong_result_returned, strong_result);
+               ZVAL_BOOL(zstrong_result_returned, 1);
        }
 }
 /* }}} */",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/openssl/openssl.c;h=c0e3d8a981501cb87db12c7c6dcdac49d98643e4;hb=16023f3e3b9c06cf677c3c980e8d574e4c162827,https://git.php.net/?p=php-src.git;a=blob;f=ext/openssl/openssl.c;h=216a56a59fb2811f620ecef579b512bfa4c8469a,1,"PHP_FUNCTION(openssl_random_pseudo_bytes)
{
        long buffer_length;
        unsigned char *buffer = NULL;
        zval *zstrong_result_returned = NULL;
//flaw_line_below:
       int strong_result = 0;
 
        if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l|z"", &buffer_length, &zstrong_result_returned) == FAILURE) {
                return;
		return;
	}

	if (buffer_length <= 0) {
		RETURN_FALSE;
	}

	if (zstrong_result_returned) {
		zval_dtor(zstrong_result_returned);
		ZVAL_BOOL(zstrong_result_returned, 0);
	}
        buffer = emalloc(buffer_length + 1);
 
 #ifdef PHP_WIN32
//flaw_line_below:
       strong_result = 1;
        /* random/urandom equivalent on Windows */
        if (php_win32_get_random_bytes(buffer, (size_t) buffer_length) == FAILURE) {
                efree(buffer);
	if (php_win32_get_random_bytes(buffer, (size_t) buffer_length) == FAILURE) {
		efree(buffer);
		if (zstrong_result_returned) {
                RETURN_FALSE;
        }
 #else
//flaw_line_below:
       if ((strong_result = RAND_pseudo_bytes(buffer, buffer_length)) < 0) {
//fix_flaw_line_below:
//       if (RAND_bytes(buffer, buffer_length) <= 0) {
                efree(buffer);
                if (zstrong_result_returned) {
                        ZVAL_BOOL(zstrong_result_returned, 0);
		if (zstrong_result_returned) {
			ZVAL_BOOL(zstrong_result_returned, 0);
		}
		RETURN_FALSE;
	}
#endif
        RETVAL_STRINGL((char *)buffer, buffer_length, 0);
 
        if (zstrong_result_returned) {
//flaw_line_below:
               ZVAL_BOOL(zstrong_result_returned, strong_result);
//fix_flaw_line_below:
//               ZVAL_BOOL(zstrong_result_returned, 1);
        }
 }
 /* }}} */
"
716,178452,,Remote,Not required,,CVE-2014-0224,https://www.cvedetails.com/cve/CVE-2014-0224/,CWE-310,Medium,Partial,Partial,,2014-06-05,5.8,"OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h does not properly restrict processing of ChangeCipherSpec messages, which allows man-in-the-middle attackers to trigger use of a zero-length master key in certain OpenSSL-to-OpenSSL communications, and consequently hijack sessions or obtain sensitive information, via a crafted TLS handshake, aka the ""CCS Injection"" vulnerability.",2019-10-09,+Info,1,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=bc8923b1ec9c467755cd86f7848c50ee8812e441,bc8923b1ec9c467755cd86f7848c50ee8812e441,,0,,,"int ssl3_connect(SSL *s)
	{
	BUF_MEM *buf=NULL;
	unsigned long Time=(unsigned long)time(NULL);
	void (*cb)(const SSL *ssl,int type,int val)=NULL;
	int ret= -1;
	int new_state,state,skip=0;

	RAND_add(&Time,sizeof(Time),0);
	ERR_clear_error();
	clear_sys_error();

	if (s->info_callback != NULL)
		cb=s->info_callback;
	else if (s->ctx->info_callback != NULL)
		cb=s->ctx->info_callback;
	
	s->in_handshake++;
	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s); 

#ifndef OPENSSL_NO_HEARTBEATS
	/* If we're awaiting a HeartbeatResponse, pretend we
	 * already got and don't await it anymore, because
	 * Heartbeats don't make sense during handshakes anyway.
	 */
	if (s->tlsext_hb_pending)
		{
		s->tlsext_hb_pending = 0;
		s->tlsext_hb_seq++;
		}
#endif

	for (;;)
		{
		state=s->state;

		switch(s->state)
			{
		case SSL_ST_RENEGOTIATE:
			s->renegotiate=1;
			s->state=SSL_ST_CONNECT;
			s->ctx->stats.sess_connect_renegotiate++;
			/* break */
		case SSL_ST_BEFORE:
		case SSL_ST_CONNECT:
		case SSL_ST_BEFORE|SSL_ST_CONNECT:
		case SSL_ST_OK|SSL_ST_CONNECT:

			s->server=0;
			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);

			if ((s->version & 0xff00 ) != 0x0300)
				{
				SSLerr(SSL_F_SSL3_CONNECT, ERR_R_INTERNAL_ERROR);
				ret = -1;
				goto end;
				}
				
			/* s->version=SSL3_VERSION; */
			s->type=SSL_ST_CONNECT;

			if (s->init_buf == NULL)
				{
				if ((buf=BUF_MEM_new()) == NULL)
					{
					ret= -1;
					goto end;
					}
				if (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))
					{
					ret= -1;
					goto end;
					}
				s->init_buf=buf;
				buf=NULL;
				}

			if (!ssl3_setup_buffers(s)) { ret= -1; goto end; }

			/* setup buffing BIO */
			if (!ssl_init_wbio_buffer(s,0)) { ret= -1; goto end; }

			/* don't push the buffering BIO quite yet */

			ssl3_init_finished_mac(s);

			s->state=SSL3_ST_CW_CLNT_HELLO_A;
			s->ctx->stats.sess_connect++;
			s->init_num=0;
			break;

		case SSL3_ST_CW_CLNT_HELLO_A:
		case SSL3_ST_CW_CLNT_HELLO_B:

			s->shutdown=0;
			ret=ssl3_client_hello(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_SRVR_HELLO_A;
			s->init_num=0;

			/* turn on buffering for the next lot of output */
			if (s->bbio != s->wbio)
				s->wbio=BIO_push(s->bbio,s->wbio);

			break;

		case SSL3_ST_CR_SRVR_HELLO_A:
		case SSL3_ST_CR_SRVR_HELLO_B:
			ret=ssl3_get_server_hello(s);
			if (ret <= 0) goto end;

			if (s->hit)
				{
				s->state=SSL3_ST_CR_FINISHED_A;
#ifndef OPENSSL_NO_TLSEXT
				if (s->tlsext_ticket_expected)
					{
					/* receive renewed session ticket */
					s->state=SSL3_ST_CR_SESSION_TICKET_A;
					}
#endif
				}
			else
				s->state=SSL3_ST_CR_CERT_A;
			s->init_num=0;
			break;

		case SSL3_ST_CR_CERT_A:
		case SSL3_ST_CR_CERT_B:
#ifndef OPENSSL_NO_TLSEXT
			ret=ssl3_check_finished(s);
			if (ret <= 0) goto end;
			if (ret == 2)
				{
				s->hit = 1;
				if (s->tlsext_ticket_expected)
					s->state=SSL3_ST_CR_SESSION_TICKET_A;
				else
					s->state=SSL3_ST_CR_FINISHED_A;
				s->init_num=0;
				break;
				}
#endif
			/* Check if it is anon DH/ECDH */
			/* or PSK */
			if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&
			    !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
				{
				ret=ssl3_get_server_certificate(s);
				if (ret <= 0) goto end;
#ifndef OPENSSL_NO_TLSEXT
				if (s->tlsext_status_expected)
					s->state=SSL3_ST_CR_CERT_STATUS_A;
				else
					s->state=SSL3_ST_CR_KEY_EXCH_A;
				}
			else
				{
				skip = 1;
				s->state=SSL3_ST_CR_KEY_EXCH_A;
				}
#else
				}
			else
				skip=1;

			s->state=SSL3_ST_CR_KEY_EXCH_A;
#endif
			s->init_num=0;
			break;

		case SSL3_ST_CR_KEY_EXCH_A:
		case SSL3_ST_CR_KEY_EXCH_B:
			ret=ssl3_get_key_exchange(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_CERT_REQ_A;
			s->init_num=0;

			/* at this point we check that we have the
			 * required stuff from the server */
			if (!ssl3_check_cert_and_algorithm(s))
				{
				ret= -1;
				goto end;
				}
			break;

		case SSL3_ST_CR_CERT_REQ_A:
		case SSL3_ST_CR_CERT_REQ_B:
			ret=ssl3_get_certificate_request(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_SRVR_DONE_A;
			s->init_num=0;
			break;

		case SSL3_ST_CR_SRVR_DONE_A:
		case SSL3_ST_CR_SRVR_DONE_B:
			ret=ssl3_get_server_done(s);
			if (ret <= 0) goto end;
#ifndef OPENSSL_NO_SRP
			if (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kSRP)
				{
				if ((ret = SRP_Calc_A_param(s))<=0)
					{
					SSLerr(SSL_F_SSL3_CONNECT,SSL_R_SRP_A_CALC);
					ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_INTERNAL_ERROR);
					goto end;
					}
				}
#endif
			if (s->s3->tmp.cert_req)
				s->state=SSL3_ST_CW_CERT_A;
			else
				s->state=SSL3_ST_CW_KEY_EXCH_A;
			s->init_num=0;

			break;

		case SSL3_ST_CW_CERT_A:
		case SSL3_ST_CW_CERT_B:
		case SSL3_ST_CW_CERT_C:
		case SSL3_ST_CW_CERT_D:
			ret=ssl3_send_client_certificate(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CW_KEY_EXCH_A;
			s->init_num=0;
			break;

		case SSL3_ST_CW_KEY_EXCH_A:
		case SSL3_ST_CW_KEY_EXCH_B:
			ret=ssl3_send_client_key_exchange(s);
			if (ret <= 0) goto end;
			/* EAY EAY EAY need to check for DH fix cert
			 * sent back */
			/* For TLS, cert_req is set to 2, so a cert chain
			 * of nothing is sent, but no verify packet is sent */
			/* XXX: For now, we do not support client 
			 * authentication in ECDH cipher suites with
			 * ECDH (rather than ECDSA) certificates.
			 * We need to skip the certificate verify 
			 * message when client's ECDH public key is sent 
			 * inside the client certificate.
			 */
			if (s->s3->tmp.cert_req == 1)
				{
				s->state=SSL3_ST_CW_CERT_VRFY_A;
				}
			else
				{
				s->state=SSL3_ST_CW_CHANGE_A;
				s->s3->change_cipher_spec=0;
				}
			if (s->s3->flags & TLS1_FLAGS_SKIP_CERT_VERIFY)
				{
				s->state=SSL3_ST_CW_CHANGE_A;
				s->s3->change_cipher_spec=0;
				}

			s->init_num=0;
			break;

		case SSL3_ST_CW_CERT_VRFY_A:
		case SSL3_ST_CW_CERT_VRFY_B:
			ret=ssl3_send_client_verify(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CW_CHANGE_A;
			s->init_num=0;
			s->s3->change_cipher_spec=0;
			break;

		case SSL3_ST_CW_CHANGE_A:
		case SSL3_ST_CW_CHANGE_B:
			ret=ssl3_send_change_cipher_spec(s,
				SSL3_ST_CW_CHANGE_A,SSL3_ST_CW_CHANGE_B);
			if (ret <= 0) goto end;

#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
			s->state=SSL3_ST_CW_FINISHED_A;
#else
			if (s->s3->next_proto_neg_seen)
				s->state=SSL3_ST_CW_NEXT_PROTO_A;
			else
				s->state=SSL3_ST_CW_FINISHED_A;
#endif
			s->init_num=0;

			s->session->cipher=s->s3->tmp.new_cipher;
#ifdef OPENSSL_NO_COMP
			s->session->compress_meth=0;
#else
			if (s->s3->tmp.new_compression == NULL)
				s->session->compress_meth=0;
			else
				s->session->compress_meth=
					s->s3->tmp.new_compression->id;
#endif
			if (!s->method->ssl3_enc->setup_key_block(s))
				{
				ret= -1;
				goto end;
				}

			if (!s->method->ssl3_enc->change_cipher_state(s,
				SSL3_CHANGE_CIPHER_CLIENT_WRITE))
				{
				ret= -1;
				goto end;
				}

			break;

#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
		case SSL3_ST_CW_NEXT_PROTO_A:
		case SSL3_ST_CW_NEXT_PROTO_B:
			ret=ssl3_send_next_proto(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CW_FINISHED_A;
			break;
#endif

		case SSL3_ST_CW_FINISHED_A:
		case SSL3_ST_CW_FINISHED_B:
			ret=ssl3_send_finished(s,
				SSL3_ST_CW_FINISHED_A,SSL3_ST_CW_FINISHED_B,
				s->method->ssl3_enc->client_finished_label,
				s->method->ssl3_enc->client_finished_label_len);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CW_FLUSH;

			/* clear flags */
			s->s3->flags&= ~SSL3_FLAGS_POP_BUFFER;
			if (s->hit)
				{
				s->s3->tmp.next_state=SSL_ST_OK;
				if (s->s3->flags & SSL3_FLAGS_DELAY_CLIENT_FINISHED)
					{
					s->state=SSL_ST_OK;
					s->s3->flags|=SSL3_FLAGS_POP_BUFFER;
					s->s3->delay_buf_pop_ret=0;
					}
				}
			else
				{
#ifndef OPENSSL_NO_TLSEXT
				/* Allow NewSessionTicket if ticket expected */
				if (s->tlsext_ticket_expected)
					s->s3->tmp.next_state=SSL3_ST_CR_SESSION_TICKET_A;
				else
#endif
				
				s->s3->tmp.next_state=SSL3_ST_CR_FINISHED_A;
				}
			s->init_num=0;
			break;

#ifndef OPENSSL_NO_TLSEXT
		case SSL3_ST_CR_SESSION_TICKET_A:
		case SSL3_ST_CR_SESSION_TICKET_B:
			ret=ssl3_get_new_session_ticket(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_FINISHED_A;
			s->init_num=0;
		break;

		case SSL3_ST_CR_CERT_STATUS_A:
		case SSL3_ST_CR_CERT_STATUS_B:
			ret=ssl3_get_cert_status(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_KEY_EXCH_A;
			s->init_num=0;
		break;
#endif

                case SSL3_ST_CR_FINISHED_A:
                case SSL3_ST_CR_FINISHED_B:
 
                       s->s3->flags |= SSL3_FLAGS_CCS_OK;
                        ret=ssl3_get_finished(s,SSL3_ST_CR_FINISHED_A,
                                SSL3_ST_CR_FINISHED_B);
                        if (ret <= 0) goto end;
			if (s->hit)
				s->state=SSL3_ST_CW_CHANGE_A;
			else
				s->state=SSL_ST_OK;
			s->init_num=0;
			break;

		case SSL3_ST_CW_FLUSH:
			s->rwstate=SSL_WRITING;
			if (BIO_flush(s->wbio) <= 0)
				{
				ret= -1;
				goto end;
				}
			s->rwstate=SSL_NOTHING;
			s->state=s->s3->tmp.next_state;
			break;

		case SSL_ST_OK:
			/* clean a few things up */
			ssl3_cleanup_key_block(s);

			if (s->init_buf != NULL)
				{
				BUF_MEM_free(s->init_buf);
				s->init_buf=NULL;
				}

			/* If we are not 'joining' the last two packets,
			 * remove the buffering now */
			if (!(s->s3->flags & SSL3_FLAGS_POP_BUFFER))
				ssl_free_wbio_buffer(s);
			/* else do it later in ssl3_write */

			s->init_num=0;
			s->renegotiate=0;
			s->new_session=0;

			ssl_update_cache(s,SSL_SESS_CACHE_CLIENT);
			if (s->hit) s->ctx->stats.sess_hit++;

			ret=1;
			/* s->server=0; */
			s->handshake_func=ssl3_connect;
			s->ctx->stats.sess_connect_good++;

			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);

			goto end;
			/* break; */
			
		default:
			SSLerr(SSL_F_SSL3_CONNECT,SSL_R_UNKNOWN_STATE);
			ret= -1;
			goto end;
			/* break; */
			}

		/* did we do anything */
		if (!s->s3->tmp.reuse_message && !skip)
			{
			if (s->debug)
				{
				if ((ret=BIO_flush(s->wbio)) <= 0)
					goto end;
				}

			if ((cb != NULL) && (s->state != state))
				{
				new_state=s->state;
				s->state=state;
				cb(s,SSL_CB_CONNECT_LOOP,1);
				s->state=new_state;
				}
			}
		skip=0;
		}
","int ssl3_connect(SSL *s)
	{
	BUF_MEM *buf=NULL;
	unsigned long Time=(unsigned long)time(NULL);
	void (*cb)(const SSL *ssl,int type,int val)=NULL;
	int ret= -1;
	int new_state,state,skip=0;

	RAND_add(&Time,sizeof(Time),0);
	ERR_clear_error();
	clear_sys_error();

	if (s->info_callback != NULL)
		cb=s->info_callback;
	else if (s->ctx->info_callback != NULL)
		cb=s->ctx->info_callback;
	
	s->in_handshake++;
	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s); 

#ifndef OPENSSL_NO_HEARTBEATS
	/* If we're awaiting a HeartbeatResponse, pretend we
	 * already got and don't await it anymore, because
	 * Heartbeats don't make sense during handshakes anyway.
	 */
	if (s->tlsext_hb_pending)
		{
		s->tlsext_hb_pending = 0;
		s->tlsext_hb_seq++;
		}
#endif

	for (;;)
		{
		state=s->state;

		switch(s->state)
			{
		case SSL_ST_RENEGOTIATE:
			s->renegotiate=1;
			s->state=SSL_ST_CONNECT;
			s->ctx->stats.sess_connect_renegotiate++;
			/* break */
		case SSL_ST_BEFORE:
		case SSL_ST_CONNECT:
		case SSL_ST_BEFORE|SSL_ST_CONNECT:
		case SSL_ST_OK|SSL_ST_CONNECT:

			s->server=0;
			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);

			if ((s->version & 0xff00 ) != 0x0300)
				{
				SSLerr(SSL_F_SSL3_CONNECT, ERR_R_INTERNAL_ERROR);
				ret = -1;
				goto end;
				}
				
			/* s->version=SSL3_VERSION; */
			s->type=SSL_ST_CONNECT;

			if (s->init_buf == NULL)
				{
				if ((buf=BUF_MEM_new()) == NULL)
					{
					ret= -1;
					goto end;
					}
				if (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))
					{
					ret= -1;
					goto end;
					}
				s->init_buf=buf;
				buf=NULL;
				}

			if (!ssl3_setup_buffers(s)) { ret= -1; goto end; }

			/* setup buffing BIO */
			if (!ssl_init_wbio_buffer(s,0)) { ret= -1; goto end; }

			/* don't push the buffering BIO quite yet */

			ssl3_init_finished_mac(s);

			s->state=SSL3_ST_CW_CLNT_HELLO_A;
			s->ctx->stats.sess_connect++;
			s->init_num=0;
			break;

		case SSL3_ST_CW_CLNT_HELLO_A:
		case SSL3_ST_CW_CLNT_HELLO_B:

			s->shutdown=0;
			ret=ssl3_client_hello(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_SRVR_HELLO_A;
			s->init_num=0;

			/* turn on buffering for the next lot of output */
			if (s->bbio != s->wbio)
				s->wbio=BIO_push(s->bbio,s->wbio);

			break;

		case SSL3_ST_CR_SRVR_HELLO_A:
		case SSL3_ST_CR_SRVR_HELLO_B:
			ret=ssl3_get_server_hello(s);
			if (ret <= 0) goto end;

			if (s->hit)
				{
				s->state=SSL3_ST_CR_FINISHED_A;
#ifndef OPENSSL_NO_TLSEXT
				if (s->tlsext_ticket_expected)
					{
					/* receive renewed session ticket */
					s->state=SSL3_ST_CR_SESSION_TICKET_A;
					}
#endif
				}
			else
				s->state=SSL3_ST_CR_CERT_A;
			s->init_num=0;
			break;

		case SSL3_ST_CR_CERT_A:
		case SSL3_ST_CR_CERT_B:
#ifndef OPENSSL_NO_TLSEXT
			ret=ssl3_check_finished(s);
			if (ret <= 0) goto end;
			if (ret == 2)
				{
				s->hit = 1;
				if (s->tlsext_ticket_expected)
					s->state=SSL3_ST_CR_SESSION_TICKET_A;
				else
					s->state=SSL3_ST_CR_FINISHED_A;
				s->init_num=0;
				break;
				}
#endif
			/* Check if it is anon DH/ECDH */
			/* or PSK */
			if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&
			    !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
				{
				ret=ssl3_get_server_certificate(s);
				if (ret <= 0) goto end;
#ifndef OPENSSL_NO_TLSEXT
				if (s->tlsext_status_expected)
					s->state=SSL3_ST_CR_CERT_STATUS_A;
				else
					s->state=SSL3_ST_CR_KEY_EXCH_A;
				}
			else
				{
				skip = 1;
				s->state=SSL3_ST_CR_KEY_EXCH_A;
				}
#else
				}
			else
				skip=1;

			s->state=SSL3_ST_CR_KEY_EXCH_A;
#endif
			s->init_num=0;
			break;

		case SSL3_ST_CR_KEY_EXCH_A:
		case SSL3_ST_CR_KEY_EXCH_B:
			ret=ssl3_get_key_exchange(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_CERT_REQ_A;
			s->init_num=0;

			/* at this point we check that we have the
			 * required stuff from the server */
			if (!ssl3_check_cert_and_algorithm(s))
				{
				ret= -1;
				goto end;
				}
			break;

		case SSL3_ST_CR_CERT_REQ_A:
		case SSL3_ST_CR_CERT_REQ_B:
			ret=ssl3_get_certificate_request(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_SRVR_DONE_A;
			s->init_num=0;
			break;

		case SSL3_ST_CR_SRVR_DONE_A:
		case SSL3_ST_CR_SRVR_DONE_B:
			ret=ssl3_get_server_done(s);
			if (ret <= 0) goto end;
#ifndef OPENSSL_NO_SRP
			if (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kSRP)
				{
				if ((ret = SRP_Calc_A_param(s))<=0)
					{
					SSLerr(SSL_F_SSL3_CONNECT,SSL_R_SRP_A_CALC);
					ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_INTERNAL_ERROR);
					goto end;
					}
				}
#endif
			if (s->s3->tmp.cert_req)
				s->state=SSL3_ST_CW_CERT_A;
			else
				s->state=SSL3_ST_CW_KEY_EXCH_A;
			s->init_num=0;

			break;

		case SSL3_ST_CW_CERT_A:
		case SSL3_ST_CW_CERT_B:
		case SSL3_ST_CW_CERT_C:
		case SSL3_ST_CW_CERT_D:
			ret=ssl3_send_client_certificate(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CW_KEY_EXCH_A;
			s->init_num=0;
			break;

		case SSL3_ST_CW_KEY_EXCH_A:
		case SSL3_ST_CW_KEY_EXCH_B:
			ret=ssl3_send_client_key_exchange(s);
			if (ret <= 0) goto end;
			/* EAY EAY EAY need to check for DH fix cert
			 * sent back */
			/* For TLS, cert_req is set to 2, so a cert chain
			 * of nothing is sent, but no verify packet is sent */
			/* XXX: For now, we do not support client 
			 * authentication in ECDH cipher suites with
			 * ECDH (rather than ECDSA) certificates.
			 * We need to skip the certificate verify 
			 * message when client's ECDH public key is sent 
			 * inside the client certificate.
			 */
			if (s->s3->tmp.cert_req == 1)
				{
				s->state=SSL3_ST_CW_CERT_VRFY_A;
				}
			else
				{
				s->state=SSL3_ST_CW_CHANGE_A;
				s->s3->change_cipher_spec=0;
				}
			if (s->s3->flags & TLS1_FLAGS_SKIP_CERT_VERIFY)
				{
				s->state=SSL3_ST_CW_CHANGE_A;
				s->s3->change_cipher_spec=0;
				}

			s->init_num=0;
			break;

		case SSL3_ST_CW_CERT_VRFY_A:
		case SSL3_ST_CW_CERT_VRFY_B:
			ret=ssl3_send_client_verify(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CW_CHANGE_A;
			s->init_num=0;
			s->s3->change_cipher_spec=0;
			break;

		case SSL3_ST_CW_CHANGE_A:
		case SSL3_ST_CW_CHANGE_B:
			ret=ssl3_send_change_cipher_spec(s,
				SSL3_ST_CW_CHANGE_A,SSL3_ST_CW_CHANGE_B);
			if (ret <= 0) goto end;

#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
			s->state=SSL3_ST_CW_FINISHED_A;
#else
			if (s->s3->next_proto_neg_seen)
				s->state=SSL3_ST_CW_NEXT_PROTO_A;
			else
				s->state=SSL3_ST_CW_FINISHED_A;
#endif
			s->init_num=0;

			s->session->cipher=s->s3->tmp.new_cipher;
#ifdef OPENSSL_NO_COMP
			s->session->compress_meth=0;
#else
			if (s->s3->tmp.new_compression == NULL)
				s->session->compress_meth=0;
			else
				s->session->compress_meth=
					s->s3->tmp.new_compression->id;
#endif
			if (!s->method->ssl3_enc->setup_key_block(s))
				{
				ret= -1;
				goto end;
				}

			if (!s->method->ssl3_enc->change_cipher_state(s,
				SSL3_CHANGE_CIPHER_CLIENT_WRITE))
				{
				ret= -1;
				goto end;
				}

			break;

#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
		case SSL3_ST_CW_NEXT_PROTO_A:
		case SSL3_ST_CW_NEXT_PROTO_B:
			ret=ssl3_send_next_proto(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CW_FINISHED_A;
			break;
#endif

		case SSL3_ST_CW_FINISHED_A:
		case SSL3_ST_CW_FINISHED_B:
			ret=ssl3_send_finished(s,
				SSL3_ST_CW_FINISHED_A,SSL3_ST_CW_FINISHED_B,
				s->method->ssl3_enc->client_finished_label,
				s->method->ssl3_enc->client_finished_label_len);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CW_FLUSH;

			/* clear flags */
			s->s3->flags&= ~SSL3_FLAGS_POP_BUFFER;
			if (s->hit)
				{
				s->s3->tmp.next_state=SSL_ST_OK;
				if (s->s3->flags & SSL3_FLAGS_DELAY_CLIENT_FINISHED)
					{
					s->state=SSL_ST_OK;
					s->s3->flags|=SSL3_FLAGS_POP_BUFFER;
					s->s3->delay_buf_pop_ret=0;
					}
				}
			else
				{
#ifndef OPENSSL_NO_TLSEXT
				/* Allow NewSessionTicket if ticket expected */
				if (s->tlsext_ticket_expected)
					s->s3->tmp.next_state=SSL3_ST_CR_SESSION_TICKET_A;
				else
#endif
				
				s->s3->tmp.next_state=SSL3_ST_CR_FINISHED_A;
				}
			s->init_num=0;
			break;

#ifndef OPENSSL_NO_TLSEXT
		case SSL3_ST_CR_SESSION_TICKET_A:
		case SSL3_ST_CR_SESSION_TICKET_B:
			ret=ssl3_get_new_session_ticket(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_FINISHED_A;
			s->init_num=0;
		break;

		case SSL3_ST_CR_CERT_STATUS_A:
		case SSL3_ST_CR_CERT_STATUS_B:
			ret=ssl3_get_cert_status(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_KEY_EXCH_A;
			s->init_num=0;
		break;
#endif

                case SSL3_ST_CR_FINISHED_A:
                case SSL3_ST_CR_FINISHED_B:
 
                        ret=ssl3_get_finished(s,SSL3_ST_CR_FINISHED_A,
                                SSL3_ST_CR_FINISHED_B);
                        if (ret <= 0) goto end;
			if (s->hit)
				s->state=SSL3_ST_CW_CHANGE_A;
			else
				s->state=SSL_ST_OK;
			s->init_num=0;
			break;

		case SSL3_ST_CW_FLUSH:
			s->rwstate=SSL_WRITING;
			if (BIO_flush(s->wbio) <= 0)
				{
				ret= -1;
				goto end;
				}
			s->rwstate=SSL_NOTHING;
			s->state=s->s3->tmp.next_state;
			break;

		case SSL_ST_OK:
			/* clean a few things up */
			ssl3_cleanup_key_block(s);

			if (s->init_buf != NULL)
				{
				BUF_MEM_free(s->init_buf);
				s->init_buf=NULL;
				}

			/* If we are not 'joining' the last two packets,
			 * remove the buffering now */
			if (!(s->s3->flags & SSL3_FLAGS_POP_BUFFER))
				ssl_free_wbio_buffer(s);
			/* else do it later in ssl3_write */

			s->init_num=0;
			s->renegotiate=0;
			s->new_session=0;

			ssl_update_cache(s,SSL_SESS_CACHE_CLIENT);
			if (s->hit) s->ctx->stats.sess_hit++;

			ret=1;
			/* s->server=0; */
			s->handshake_func=ssl3_connect;
			s->ctx->stats.sess_connect_good++;

			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);

			goto end;
			/* break; */
			
		default:
			SSLerr(SSL_F_SSL3_CONNECT,SSL_R_UNKNOWN_STATE);
			ret= -1;
			goto end;
			/* break; */
			}

		/* did we do anything */
		if (!s->s3->tmp.reuse_message && !skip)
			{
			if (s->debug)
				{
				if ((ret=BIO_flush(s->wbio)) <= 0)
					goto end;
				}

			if ((cb != NULL) && (s->state != state))
				{
				new_state=s->state;
				s->state=state;
				cb(s,SSL_CB_CONNECT_LOOP,1);
				s->state=new_state;
				}
			}
		skip=0;
		}
",C,"                       s->s3->flags |= SSL3_FLAGS_CCS_OK;
",,1632ef744872edc2aa2a53d487d3e79c965a4ad3,"@@ -559,6 +559,7 @@ int ssl3_connect(SSL *s)
                case SSL3_ST_CR_FINISHED_A:
                case SSL3_ST_CR_FINISHED_B:
 
+                       s->s3->flags |= SSL3_FLAGS_CCS_OK;
                        ret=ssl3_get_finished(s,SSL3_ST_CR_FINISHED_A,
                                SSL3_ST_CR_FINISHED_B);
                        if (ret <= 0) goto end;
@@ -915,6 +916,7 @@ int ssl3_get_server_hello(SSL *s)
                SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT);
                goto f_err;
                }
+           s->s3->flags |= SSL3_FLAGS_CCS_OK;
            s->hit=1;
            }
        else    /* a miss or crap from the other end */",openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=ssl/s3_clnt.c;h=c99a4c495efe66c9e63319fdd8c022d1eb5979c3;hb=bc8923b1ec9c467755cd86f7848c50ee8812e441,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=ssl/s3_clnt.c;h=a6b3c01afa18ae7c26e87f45296131cc4e092dd3,1,"int ssl3_connect(SSL *s)
	{
	BUF_MEM *buf=NULL;
	unsigned long Time=(unsigned long)time(NULL);
	void (*cb)(const SSL *ssl,int type,int val)=NULL;
	int ret= -1;
	int new_state,state,skip=0;

	RAND_add(&Time,sizeof(Time),0);
	ERR_clear_error();
	clear_sys_error();

	if (s->info_callback != NULL)
		cb=s->info_callback;
	else if (s->ctx->info_callback != NULL)
		cb=s->ctx->info_callback;
	
	s->in_handshake++;
	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s); 

#ifndef OPENSSL_NO_HEARTBEATS
	/* If we're awaiting a HeartbeatResponse, pretend we
	 * already got and don't await it anymore, because
	 * Heartbeats don't make sense during handshakes anyway.
	 */
	if (s->tlsext_hb_pending)
		{
		s->tlsext_hb_pending = 0;
		s->tlsext_hb_seq++;
		}
#endif

	for (;;)
		{
		state=s->state;

		switch(s->state)
			{
		case SSL_ST_RENEGOTIATE:
			s->renegotiate=1;
			s->state=SSL_ST_CONNECT;
			s->ctx->stats.sess_connect_renegotiate++;
			/* break */
		case SSL_ST_BEFORE:
		case SSL_ST_CONNECT:
		case SSL_ST_BEFORE|SSL_ST_CONNECT:
		case SSL_ST_OK|SSL_ST_CONNECT:

			s->server=0;
			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);

			if ((s->version & 0xff00 ) != 0x0300)
				{
				SSLerr(SSL_F_SSL3_CONNECT, ERR_R_INTERNAL_ERROR);
				ret = -1;
				goto end;
				}
				
			/* s->version=SSL3_VERSION; */
			s->type=SSL_ST_CONNECT;

			if (s->init_buf == NULL)
				{
				if ((buf=BUF_MEM_new()) == NULL)
					{
					ret= -1;
					goto end;
					}
				if (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))
					{
					ret= -1;
					goto end;
					}
				s->init_buf=buf;
				buf=NULL;
				}

			if (!ssl3_setup_buffers(s)) { ret= -1; goto end; }

			/* setup buffing BIO */
			if (!ssl_init_wbio_buffer(s,0)) { ret= -1; goto end; }

			/* don't push the buffering BIO quite yet */

			ssl3_init_finished_mac(s);

			s->state=SSL3_ST_CW_CLNT_HELLO_A;
			s->ctx->stats.sess_connect++;
			s->init_num=0;
			break;

		case SSL3_ST_CW_CLNT_HELLO_A:
		case SSL3_ST_CW_CLNT_HELLO_B:

			s->shutdown=0;
			ret=ssl3_client_hello(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_SRVR_HELLO_A;
			s->init_num=0;

			/* turn on buffering for the next lot of output */
			if (s->bbio != s->wbio)
				s->wbio=BIO_push(s->bbio,s->wbio);

			break;

		case SSL3_ST_CR_SRVR_HELLO_A:
		case SSL3_ST_CR_SRVR_HELLO_B:
			ret=ssl3_get_server_hello(s);
			if (ret <= 0) goto end;

			if (s->hit)
				{
				s->state=SSL3_ST_CR_FINISHED_A;
#ifndef OPENSSL_NO_TLSEXT
				if (s->tlsext_ticket_expected)
					{
					/* receive renewed session ticket */
					s->state=SSL3_ST_CR_SESSION_TICKET_A;
					}
#endif
				}
			else
				s->state=SSL3_ST_CR_CERT_A;
			s->init_num=0;
			break;

		case SSL3_ST_CR_CERT_A:
		case SSL3_ST_CR_CERT_B:
#ifndef OPENSSL_NO_TLSEXT
			ret=ssl3_check_finished(s);
			if (ret <= 0) goto end;
			if (ret == 2)
				{
				s->hit = 1;
				if (s->tlsext_ticket_expected)
					s->state=SSL3_ST_CR_SESSION_TICKET_A;
				else
					s->state=SSL3_ST_CR_FINISHED_A;
				s->init_num=0;
				break;
				}
#endif
			/* Check if it is anon DH/ECDH */
			/* or PSK */
			if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&
			    !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
				{
				ret=ssl3_get_server_certificate(s);
				if (ret <= 0) goto end;
#ifndef OPENSSL_NO_TLSEXT
				if (s->tlsext_status_expected)
					s->state=SSL3_ST_CR_CERT_STATUS_A;
				else
					s->state=SSL3_ST_CR_KEY_EXCH_A;
				}
			else
				{
				skip = 1;
				s->state=SSL3_ST_CR_KEY_EXCH_A;
				}
#else
				}
			else
				skip=1;

			s->state=SSL3_ST_CR_KEY_EXCH_A;
#endif
			s->init_num=0;
			break;

		case SSL3_ST_CR_KEY_EXCH_A:
		case SSL3_ST_CR_KEY_EXCH_B:
			ret=ssl3_get_key_exchange(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_CERT_REQ_A;
			s->init_num=0;

			/* at this point we check that we have the
			 * required stuff from the server */
			if (!ssl3_check_cert_and_algorithm(s))
				{
				ret= -1;
				goto end;
				}
			break;

		case SSL3_ST_CR_CERT_REQ_A:
		case SSL3_ST_CR_CERT_REQ_B:
			ret=ssl3_get_certificate_request(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_SRVR_DONE_A;
			s->init_num=0;
			break;

		case SSL3_ST_CR_SRVR_DONE_A:
		case SSL3_ST_CR_SRVR_DONE_B:
			ret=ssl3_get_server_done(s);
			if (ret <= 0) goto end;
#ifndef OPENSSL_NO_SRP
			if (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kSRP)
				{
				if ((ret = SRP_Calc_A_param(s))<=0)
					{
					SSLerr(SSL_F_SSL3_CONNECT,SSL_R_SRP_A_CALC);
					ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_INTERNAL_ERROR);
					goto end;
					}
				}
#endif
			if (s->s3->tmp.cert_req)
				s->state=SSL3_ST_CW_CERT_A;
			else
				s->state=SSL3_ST_CW_KEY_EXCH_A;
			s->init_num=0;

			break;

		case SSL3_ST_CW_CERT_A:
		case SSL3_ST_CW_CERT_B:
		case SSL3_ST_CW_CERT_C:
		case SSL3_ST_CW_CERT_D:
			ret=ssl3_send_client_certificate(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CW_KEY_EXCH_A;
			s->init_num=0;
			break;

		case SSL3_ST_CW_KEY_EXCH_A:
		case SSL3_ST_CW_KEY_EXCH_B:
			ret=ssl3_send_client_key_exchange(s);
			if (ret <= 0) goto end;
			/* EAY EAY EAY need to check for DH fix cert
			 * sent back */
			/* For TLS, cert_req is set to 2, so a cert chain
			 * of nothing is sent, but no verify packet is sent */
			/* XXX: For now, we do not support client 
			 * authentication in ECDH cipher suites with
			 * ECDH (rather than ECDSA) certificates.
			 * We need to skip the certificate verify 
			 * message when client's ECDH public key is sent 
			 * inside the client certificate.
			 */
			if (s->s3->tmp.cert_req == 1)
				{
				s->state=SSL3_ST_CW_CERT_VRFY_A;
				}
			else
				{
				s->state=SSL3_ST_CW_CHANGE_A;
				s->s3->change_cipher_spec=0;
				}
			if (s->s3->flags & TLS1_FLAGS_SKIP_CERT_VERIFY)
				{
				s->state=SSL3_ST_CW_CHANGE_A;
				s->s3->change_cipher_spec=0;
				}

			s->init_num=0;
			break;

		case SSL3_ST_CW_CERT_VRFY_A:
		case SSL3_ST_CW_CERT_VRFY_B:
			ret=ssl3_send_client_verify(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CW_CHANGE_A;
			s->init_num=0;
			s->s3->change_cipher_spec=0;
			break;

		case SSL3_ST_CW_CHANGE_A:
		case SSL3_ST_CW_CHANGE_B:
			ret=ssl3_send_change_cipher_spec(s,
				SSL3_ST_CW_CHANGE_A,SSL3_ST_CW_CHANGE_B);
			if (ret <= 0) goto end;

#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
			s->state=SSL3_ST_CW_FINISHED_A;
#else
			if (s->s3->next_proto_neg_seen)
				s->state=SSL3_ST_CW_NEXT_PROTO_A;
			else
				s->state=SSL3_ST_CW_FINISHED_A;
#endif
			s->init_num=0;

			s->session->cipher=s->s3->tmp.new_cipher;
#ifdef OPENSSL_NO_COMP
			s->session->compress_meth=0;
#else
			if (s->s3->tmp.new_compression == NULL)
				s->session->compress_meth=0;
			else
				s->session->compress_meth=
					s->s3->tmp.new_compression->id;
#endif
			if (!s->method->ssl3_enc->setup_key_block(s))
				{
				ret= -1;
				goto end;
				}

			if (!s->method->ssl3_enc->change_cipher_state(s,
				SSL3_CHANGE_CIPHER_CLIENT_WRITE))
				{
				ret= -1;
				goto end;
				}

			break;

#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
		case SSL3_ST_CW_NEXT_PROTO_A:
		case SSL3_ST_CW_NEXT_PROTO_B:
			ret=ssl3_send_next_proto(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CW_FINISHED_A;
			break;
#endif

		case SSL3_ST_CW_FINISHED_A:
		case SSL3_ST_CW_FINISHED_B:
			ret=ssl3_send_finished(s,
				SSL3_ST_CW_FINISHED_A,SSL3_ST_CW_FINISHED_B,
				s->method->ssl3_enc->client_finished_label,
				s->method->ssl3_enc->client_finished_label_len);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CW_FLUSH;

			/* clear flags */
			s->s3->flags&= ~SSL3_FLAGS_POP_BUFFER;
			if (s->hit)
				{
				s->s3->tmp.next_state=SSL_ST_OK;
				if (s->s3->flags & SSL3_FLAGS_DELAY_CLIENT_FINISHED)
					{
					s->state=SSL_ST_OK;
					s->s3->flags|=SSL3_FLAGS_POP_BUFFER;
					s->s3->delay_buf_pop_ret=0;
					}
				}
			else
				{
#ifndef OPENSSL_NO_TLSEXT
				/* Allow NewSessionTicket if ticket expected */
				if (s->tlsext_ticket_expected)
					s->s3->tmp.next_state=SSL3_ST_CR_SESSION_TICKET_A;
				else
#endif
				
				s->s3->tmp.next_state=SSL3_ST_CR_FINISHED_A;
				}
			s->init_num=0;
			break;

#ifndef OPENSSL_NO_TLSEXT
		case SSL3_ST_CR_SESSION_TICKET_A:
		case SSL3_ST_CR_SESSION_TICKET_B:
			ret=ssl3_get_new_session_ticket(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_FINISHED_A;
			s->init_num=0;
		break;

		case SSL3_ST_CR_CERT_STATUS_A:
		case SSL3_ST_CR_CERT_STATUS_B:
			ret=ssl3_get_cert_status(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_CR_KEY_EXCH_A;
			s->init_num=0;
		break;
#endif

                case SSL3_ST_CR_FINISHED_A:
                case SSL3_ST_CR_FINISHED_B:
 
//fix_flaw_line_below:
//                       s->s3->flags |= SSL3_FLAGS_CCS_OK;
                        ret=ssl3_get_finished(s,SSL3_ST_CR_FINISHED_A,
                                SSL3_ST_CR_FINISHED_B);
                        if (ret <= 0) goto end;
			if (s->hit)
				s->state=SSL3_ST_CW_CHANGE_A;
			else
				s->state=SSL_ST_OK;
			s->init_num=0;
			break;

		case SSL3_ST_CW_FLUSH:
			s->rwstate=SSL_WRITING;
			if (BIO_flush(s->wbio) <= 0)
				{
				ret= -1;
				goto end;
				}
			s->rwstate=SSL_NOTHING;
			s->state=s->s3->tmp.next_state;
			break;

		case SSL_ST_OK:
			/* clean a few things up */
			ssl3_cleanup_key_block(s);

			if (s->init_buf != NULL)
				{
				BUF_MEM_free(s->init_buf);
				s->init_buf=NULL;
				}

			/* If we are not 'joining' the last two packets,
			 * remove the buffering now */
			if (!(s->s3->flags & SSL3_FLAGS_POP_BUFFER))
				ssl_free_wbio_buffer(s);
			/* else do it later in ssl3_write */

			s->init_num=0;
			s->renegotiate=0;
			s->new_session=0;

			ssl_update_cache(s,SSL_SESS_CACHE_CLIENT);
			if (s->hit) s->ctx->stats.sess_hit++;

			ret=1;
			/* s->server=0; */
			s->handshake_func=ssl3_connect;
			s->ctx->stats.sess_connect_good++;

			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);

			goto end;
			/* break; */
			
		default:
			SSLerr(SSL_F_SSL3_CONNECT,SSL_R_UNKNOWN_STATE);
			ret= -1;
			goto end;
			/* break; */
			}

		/* did we do anything */
		if (!s->s3->tmp.reuse_message && !skip)
			{
			if (s->debug)
				{
				if ((ret=BIO_flush(s->wbio)) <= 0)
					goto end;
				}

			if ((cb != NULL) && (s->state != state))
				{
				new_state=s->state;
				s->state=state;
				cb(s,SSL_CB_CONNECT_LOOP,1);
				s->state=new_state;
				}
			}
		skip=0;
		}
"
717,178453,,Remote,Not required,,CVE-2014-0224,https://www.cvedetails.com/cve/CVE-2014-0224/,CWE-310,Medium,Partial,Partial,,2014-06-05,5.8,"OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h does not properly restrict processing of ChangeCipherSpec messages, which allows man-in-the-middle attackers to trigger use of a zero-length master key in certain OpenSSL-to-OpenSSL communications, and consequently hijack sessions or obtain sensitive information, via a crafted TLS handshake, aka the ""CCS Injection"" vulnerability.",2019-10-09,+Info,5,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=bc8923b1ec9c467755cd86f7848c50ee8812e441,bc8923b1ec9c467755cd86f7848c50ee8812e441,,0,,,"int ssl3_accept(SSL *s)
	{
	BUF_MEM *buf;
	unsigned long alg_k,Time=(unsigned long)time(NULL);
	void (*cb)(const SSL *ssl,int type,int val)=NULL;
	int ret= -1;
	int new_state,state,skip=0;

	RAND_add(&Time,sizeof(Time),0);
	ERR_clear_error();
	clear_sys_error();

	if (s->info_callback != NULL)
		cb=s->info_callback;
	else if (s->ctx->info_callback != NULL)
		cb=s->ctx->info_callback;

	/* init things to blank */
	s->in_handshake++;
	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);

	if (s->cert == NULL)
		{
		SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_NO_CERTIFICATE_SET);
		return(-1);
		}

#ifndef OPENSSL_NO_HEARTBEATS
	/* If we're awaiting a HeartbeatResponse, pretend we
	 * already got and don't await it anymore, because
	 * Heartbeats don't make sense during handshakes anyway.
	 */
	if (s->tlsext_hb_pending)
		{
		s->tlsext_hb_pending = 0;
		s->tlsext_hb_seq++;
		}
#endif

	for (;;)
		{
		state=s->state;

		switch (s->state)
			{
		case SSL_ST_RENEGOTIATE:
			s->renegotiate=1;
			/* s->state=SSL_ST_ACCEPT; */

		case SSL_ST_BEFORE:
		case SSL_ST_ACCEPT:
		case SSL_ST_BEFORE|SSL_ST_ACCEPT:
		case SSL_ST_OK|SSL_ST_ACCEPT:

			s->server=1;
			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);

			if ((s->version>>8) != 3)
				{
				SSLerr(SSL_F_SSL3_ACCEPT, ERR_R_INTERNAL_ERROR);
				return -1;
				}
			s->type=SSL_ST_ACCEPT;

			if (s->init_buf == NULL)
				{
				if ((buf=BUF_MEM_new()) == NULL)
					{
					ret= -1;
					goto end;
					}
				if (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))
					{
					ret= -1;
					goto end;
					}
				s->init_buf=buf;
				}

			if (!ssl3_setup_buffers(s))
				{
				ret= -1;
				goto end;
				}

			s->init_num=0;
			s->s3->flags &= ~SSL3_FLAGS_SGC_RESTART_DONE;

			if (s->state != SSL_ST_RENEGOTIATE)
				{
				/* Ok, we now need to push on a buffering BIO so that
				 * the output is sent in a way that TCP likes :-)
				 */
				if (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }
				
				ssl3_init_finished_mac(s);
				s->state=SSL3_ST_SR_CLNT_HELLO_A;
				s->ctx->stats.sess_accept++;
				}
			else if (!s->s3->send_connection_binding &&
				!(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))
				{
				/* Server attempting to renegotiate with
				 * client that doesn't support secure
				 * renegotiation.
				 */
				SSLerr(SSL_F_SSL3_ACCEPT, SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);
				ret = -1;
				goto end;
				}
			else
				{
				/* s->state == SSL_ST_RENEGOTIATE,
				 * we will just send a HelloRequest */
				s->ctx->stats.sess_accept_renegotiate++;
				s->state=SSL3_ST_SW_HELLO_REQ_A;
				}
			break;

		case SSL3_ST_SW_HELLO_REQ_A:
		case SSL3_ST_SW_HELLO_REQ_B:

			s->shutdown=0;
			ret=ssl3_send_hello_request(s);
			if (ret <= 0) goto end;
			s->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C;
			s->state=SSL3_ST_SW_FLUSH;
			s->init_num=0;

			ssl3_init_finished_mac(s);
			break;

		case SSL3_ST_SW_HELLO_REQ_C:
			s->state=SSL_ST_OK;
			break;

		case SSL3_ST_SR_CLNT_HELLO_A:
		case SSL3_ST_SR_CLNT_HELLO_B:
		case SSL3_ST_SR_CLNT_HELLO_C:

			s->shutdown=0;
			if (s->rwstate != SSL_X509_LOOKUP)
			{
				ret=ssl3_get_client_hello(s);
				if (ret <= 0) goto end;
			}
#ifndef OPENSSL_NO_SRP
			{
			int al;
			if ((ret = ssl_check_srp_ext_ClientHello(s,&al))  < 0)
					{
					/* callback indicates firther work to be done */
					s->rwstate=SSL_X509_LOOKUP;
					goto end;
					}
			if (ret != SSL_ERROR_NONE)
				{
				ssl3_send_alert(s,SSL3_AL_FATAL,al);	
				/* This is not really an error but the only means to
                                   for a client to detect whether srp is supported. */
 				   if (al != TLS1_AD_UNKNOWN_PSK_IDENTITY) 	
					SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_CLIENTHELLO_TLSEXT);			
				ret = SSL_TLSEXT_ERR_ALERT_FATAL;			
				ret= -1;
				goto end;	
				}
			}
#endif		
			
			s->renegotiate = 2;
			s->state=SSL3_ST_SW_SRVR_HELLO_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_SRVR_HELLO_A:
		case SSL3_ST_SW_SRVR_HELLO_B:
			ret=ssl3_send_server_hello(s);
			if (ret <= 0) goto end;
#ifndef OPENSSL_NO_TLSEXT
			if (s->hit)
				{
				if (s->tlsext_ticket_expected)
					s->state=SSL3_ST_SW_SESSION_TICKET_A;
				else
					s->state=SSL3_ST_SW_CHANGE_A;
				}
#else
			if (s->hit)
					s->state=SSL3_ST_SW_CHANGE_A;
#endif
			else
				s->state=SSL3_ST_SW_CERT_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_CERT_A:
		case SSL3_ST_SW_CERT_B:
			/* Check if it is anon DH or anon ECDH, */
			/* normal PSK or KRB5 or SRP */
			if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)
				&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)
				&& !(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5))
				{
				ret=ssl3_send_server_certificate(s);
				if (ret <= 0) goto end;
#ifndef OPENSSL_NO_TLSEXT
				if (s->tlsext_status_expected)
					s->state=SSL3_ST_SW_CERT_STATUS_A;
				else
					s->state=SSL3_ST_SW_KEY_EXCH_A;
				}
			else
				{
				skip = 1;
				s->state=SSL3_ST_SW_KEY_EXCH_A;
				}
#else
				}
			else
				skip=1;

			s->state=SSL3_ST_SW_KEY_EXCH_A;
#endif
			s->init_num=0;
			break;

		case SSL3_ST_SW_KEY_EXCH_A:
		case SSL3_ST_SW_KEY_EXCH_B:
			alg_k = s->s3->tmp.new_cipher->algorithm_mkey;

			/* clear this, it may get reset by
			 * send_server_key_exchange */
			if ((s->options & SSL_OP_EPHEMERAL_RSA)
#ifndef OPENSSL_NO_KRB5
				&& !(alg_k & SSL_kKRB5)
#endif /* OPENSSL_NO_KRB5 */
				)
				/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key
				 * even when forbidden by protocol specs
				 * (handshake may fail as clients are not required to
				 * be able to handle this) */
				s->s3->tmp.use_rsa_tmp=1;
			else
				s->s3->tmp.use_rsa_tmp=0;


			/* only send if a DH key exchange, fortezza or
			 * RSA but we have a sign only certificate
			 *
			 * PSK: may send PSK identity hints
			 *
			 * For ECC ciphersuites, we send a serverKeyExchange
			 * message only if the cipher suite is either
			 * ECDH-anon or ECDHE. In other cases, the
			 * server certificate contains the server's
			 * public key for key exchange.
			 */
			if (s->s3->tmp.use_rsa_tmp
			/* PSK: send ServerKeyExchange if PSK identity
			 * hint if provided */
#ifndef OPENSSL_NO_PSK
			    || ((alg_k & SSL_kPSK) && s->ctx->psk_identity_hint)
#endif
#ifndef OPENSSL_NO_SRP
			    /* SRP: send ServerKeyExchange */
			    || (alg_k & SSL_kSRP)
#endif
			    || (alg_k & (SSL_kDHr|SSL_kDHd|SSL_kEDH))
			    || (alg_k & SSL_kEECDH)
			    || ((alg_k & SSL_kRSA)
				&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL
				    || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)
					&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)
					)
				    )
				)
			    )
				{
				ret=ssl3_send_server_key_exchange(s);
				if (ret <= 0) goto end;
				}
			else
				skip=1;

			s->state=SSL3_ST_SW_CERT_REQ_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_CERT_REQ_A:
		case SSL3_ST_SW_CERT_REQ_B:
			if (/* don't request cert unless asked for it: */
				!(s->verify_mode & SSL_VERIFY_PEER) ||
				/* if SSL_VERIFY_CLIENT_ONCE is set,
				 * don't request cert during re-negotiation: */
				((s->session->peer != NULL) &&
				 (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||
				/* never request cert in anonymous ciphersuites
				 * (see section ""Certificate request"" in SSL 3 drafts
				 * and in RFC 2246): */
				((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&
				 /* ... except when the application insists on verification
				  * (against the specs, but s3_clnt.c accepts this for SSL 3) */
				 !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||
				 /* never request cert in Kerberos ciphersuites */
				(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5)
				/* With normal PSK Certificates and
				 * Certificate Requests are omitted */
				|| (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
				{
				/* no cert request */
				skip=1;
				s->s3->tmp.cert_request=0;
				s->state=SSL3_ST_SW_SRVR_DONE_A;
				if (s->s3->handshake_buffer)
					if (!ssl3_digest_cached_records(s))
						return -1;
				}
			else
				{
				s->s3->tmp.cert_request=1;
				ret=ssl3_send_certificate_request(s);
				if (ret <= 0) goto end;
#ifndef NETSCAPE_HANG_BUG
				s->state=SSL3_ST_SW_SRVR_DONE_A;
#else
				s->state=SSL3_ST_SW_FLUSH;
				s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
#endif
				s->init_num=0;
				}
			break;

		case SSL3_ST_SW_SRVR_DONE_A:
		case SSL3_ST_SW_SRVR_DONE_B:
			ret=ssl3_send_server_done(s);
			if (ret <= 0) goto end;
			s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
			s->state=SSL3_ST_SW_FLUSH;
			s->init_num=0;
			break;
		
		case SSL3_ST_SW_FLUSH:

			/* This code originally checked to see if
			 * any data was pending using BIO_CTRL_INFO
			 * and then flushed. This caused problems
			 * as documented in PR#1939. The proposed
			 * fix doesn't completely resolve this issue
			 * as buggy implementations of BIO_CTRL_PENDING
			 * still exist. So instead we just flush
			 * unconditionally.
			 */

			s->rwstate=SSL_WRITING;
			if (BIO_flush(s->wbio) <= 0)
				{
				ret= -1;
				goto end;
				}
			s->rwstate=SSL_NOTHING;

			s->state=s->s3->tmp.next_state;
			break;

		case SSL3_ST_SR_CERT_A:
		case SSL3_ST_SR_CERT_B:
			/* Check for second client hello (MS SGC) */
			ret = ssl3_check_client_hello(s);
			if (ret <= 0)
				goto end;
			if (ret == 2)
				s->state = SSL3_ST_SR_CLNT_HELLO_C;
			else {
				if (s->s3->tmp.cert_request)
					{
					ret=ssl3_get_client_certificate(s);
					if (ret <= 0) goto end;
					}
				s->init_num=0;
				s->state=SSL3_ST_SR_KEY_EXCH_A;
			}
			break;

		case SSL3_ST_SR_KEY_EXCH_A:
		case SSL3_ST_SR_KEY_EXCH_B:
			ret=ssl3_get_client_key_exchange(s);
			if (ret <= 0)
				goto end;
			if (ret == 2)
				{
				/* For the ECDH ciphersuites when
				 * the client sends its ECDH pub key in
				 * a certificate, the CertificateVerify
				 * message is not sent.
				 * Also for GOST ciphersuites when
				 * the client uses its key from the certificate
				 * for key exchange.
				 */
#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
				s->state=SSL3_ST_SR_FINISHED_A;
#else
				if (s->s3->next_proto_neg_seen)
					s->state=SSL3_ST_SR_NEXT_PROTO_A;
				else
					s->state=SSL3_ST_SR_FINISHED_A;
#endif
				s->init_num = 0;
				}
			else if (TLS1_get_version(s) >= TLS1_2_VERSION)
				{
				s->state=SSL3_ST_SR_CERT_VRFY_A;
				s->init_num=0;
				if (!s->session->peer)
					break;
				/* For TLS v1.2 freeze the handshake buffer
				 * at this point and digest cached records.
				 */
				if (!s->s3->handshake_buffer)
					{
					SSLerr(SSL_F_SSL3_ACCEPT,ERR_R_INTERNAL_ERROR);
					return -1;
					}
				s->s3->flags |= TLS1_FLAGS_KEEP_HANDSHAKE;
				if (!ssl3_digest_cached_records(s))
					return -1;
				}
			else
				{
				int offset=0;
				int dgst_num;

				s->state=SSL3_ST_SR_CERT_VRFY_A;
				s->init_num=0;

				/* We need to get hashes here so if there is
				 * a client cert, it can be verified
				 * FIXME - digest processing for CertificateVerify
				 * should be generalized. But it is next step
				 */
				if (s->s3->handshake_buffer)
					if (!ssl3_digest_cached_records(s))
						return -1;
				for (dgst_num=0; dgst_num<SSL_MAX_DIGEST;dgst_num++)	
					if (s->s3->handshake_dgst[dgst_num]) 
						{
						int dgst_size;

						s->method->ssl3_enc->cert_verify_mac(s,EVP_MD_CTX_type(s->s3->handshake_dgst[dgst_num]),&(s->s3->tmp.cert_verify_md[offset]));
						dgst_size=EVP_MD_CTX_size(s->s3->handshake_dgst[dgst_num]);
						if (dgst_size < 0)
							{
							ret = -1;
							goto end;
							}
						offset+=dgst_size;
						}		
				}
			break;

                case SSL3_ST_SR_CERT_VRFY_A:
                case SSL3_ST_SR_CERT_VRFY_B:
 
                       s->s3->flags |= SSL3_FLAGS_CCS_OK;
                        /* we should decide if we expected this one */
                        ret=ssl3_get_cert_verify(s);
                        if (ret <= 0) goto end;
#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
			s->state=SSL3_ST_SR_FINISHED_A;
#else
			if (s->s3->next_proto_neg_seen)
				s->state=SSL3_ST_SR_NEXT_PROTO_A;
			else
				s->state=SSL3_ST_SR_FINISHED_A;
#endif
			s->init_num=0;
			break;

#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
		case SSL3_ST_SR_NEXT_PROTO_A:
		case SSL3_ST_SR_NEXT_PROTO_B:
			ret=ssl3_get_next_proto(s);
			if (ret <= 0) goto end;
			s->init_num = 0;
			s->state=SSL3_ST_SR_FINISHED_A;
			break;
#endif

 
                case SSL3_ST_SR_FINISHED_A:
                case SSL3_ST_SR_FINISHED_B:
                       s->s3->flags |= SSL3_FLAGS_CCS_OK;
                        ret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,
                                SSL3_ST_SR_FINISHED_B);
                        if (ret <= 0) goto end;
#ifndef OPENSSL_NO_TLSEXT
			else if (s->tlsext_ticket_expected)
				s->state=SSL3_ST_SW_SESSION_TICKET_A;
#endif
			else
				s->state=SSL3_ST_SW_CHANGE_A;
			s->init_num=0;
			break;

#ifndef OPENSSL_NO_TLSEXT
		case SSL3_ST_SW_SESSION_TICKET_A:
		case SSL3_ST_SW_SESSION_TICKET_B:
			ret=ssl3_send_newsession_ticket(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_CHANGE_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_CERT_STATUS_A:
		case SSL3_ST_SW_CERT_STATUS_B:
			ret=ssl3_send_cert_status(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_KEY_EXCH_A;
			s->init_num=0;
			break;

#endif

		case SSL3_ST_SW_CHANGE_A:
		case SSL3_ST_SW_CHANGE_B:

			s->session->cipher=s->s3->tmp.new_cipher;
			if (!s->method->ssl3_enc->setup_key_block(s))
				{ ret= -1; goto end; }

			ret=ssl3_send_change_cipher_spec(s,
				SSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);

			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_FINISHED_A;
			s->init_num=0;

			if (!s->method->ssl3_enc->change_cipher_state(s,
				SSL3_CHANGE_CIPHER_SERVER_WRITE))
				{
				ret= -1;
				goto end;
				}

			break;

		case SSL3_ST_SW_FINISHED_A:
		case SSL3_ST_SW_FINISHED_B:
			ret=ssl3_send_finished(s,
				SSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,
				s->method->ssl3_enc->server_finished_label,
				s->method->ssl3_enc->server_finished_label_len);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_FLUSH;
			if (s->hit)
				{
#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
				s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;
#else
                                s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;
 #else
                                if (s->s3->next_proto_neg_seen)
                                       {
                                       s->s3->flags |= SSL3_FLAGS_CCS_OK;
                                        s->s3->tmp.next_state=SSL3_ST_SR_NEXT_PROTO_A;
                                       }
                                else
                                        s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;
 #endif

		case SSL_ST_OK:
			/* clean a few things up */
			ssl3_cleanup_key_block(s);

			BUF_MEM_free(s->init_buf);
			s->init_buf=NULL;

			/* remove buffering on output */
			ssl_free_wbio_buffer(s);

			s->init_num=0;

			if (s->renegotiate == 2) /* skipped if we just sent a HelloRequest */
				{
				s->renegotiate=0;
				s->new_session=0;
				
				ssl_update_cache(s,SSL_SESS_CACHE_SERVER);
				
				s->ctx->stats.sess_accept_good++;
				/* s->server=1; */
				s->handshake_func=ssl3_accept;

				if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);
				}
			
			ret = 1;
			goto end;
			/* break; */

		default:
			SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_UNKNOWN_STATE);
			ret= -1;
			goto end;
			/* break; */
			}
		
		if (!s->s3->tmp.reuse_message && !skip)
			{
			if (s->debug)
				{
				if ((ret=BIO_flush(s->wbio)) <= 0)
					goto end;
				}


			if ((cb != NULL) && (s->state != state))
				{
				new_state=s->state;
				s->state=state;
				cb(s,SSL_CB_ACCEPT_LOOP,1);
				s->state=new_state;
				}
			}
		skip=0;
		}
end:
	/* BIO_flush(s->wbio); */

	s->in_handshake--;
	if (cb != NULL)
		cb(s,SSL_CB_ACCEPT_EXIT,ret);
	return(ret);
	}
","int ssl3_accept(SSL *s)
	{
	BUF_MEM *buf;
	unsigned long alg_k,Time=(unsigned long)time(NULL);
	void (*cb)(const SSL *ssl,int type,int val)=NULL;
	int ret= -1;
	int new_state,state,skip=0;

	RAND_add(&Time,sizeof(Time),0);
	ERR_clear_error();
	clear_sys_error();

	if (s->info_callback != NULL)
		cb=s->info_callback;
	else if (s->ctx->info_callback != NULL)
		cb=s->ctx->info_callback;

	/* init things to blank */
	s->in_handshake++;
	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);

	if (s->cert == NULL)
		{
		SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_NO_CERTIFICATE_SET);
		return(-1);
		}

#ifndef OPENSSL_NO_HEARTBEATS
	/* If we're awaiting a HeartbeatResponse, pretend we
	 * already got and don't await it anymore, because
	 * Heartbeats don't make sense during handshakes anyway.
	 */
	if (s->tlsext_hb_pending)
		{
		s->tlsext_hb_pending = 0;
		s->tlsext_hb_seq++;
		}
#endif

	for (;;)
		{
		state=s->state;

		switch (s->state)
			{
		case SSL_ST_RENEGOTIATE:
			s->renegotiate=1;
			/* s->state=SSL_ST_ACCEPT; */

		case SSL_ST_BEFORE:
		case SSL_ST_ACCEPT:
		case SSL_ST_BEFORE|SSL_ST_ACCEPT:
		case SSL_ST_OK|SSL_ST_ACCEPT:

			s->server=1;
			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);

			if ((s->version>>8) != 3)
				{
				SSLerr(SSL_F_SSL3_ACCEPT, ERR_R_INTERNAL_ERROR);
				return -1;
				}
			s->type=SSL_ST_ACCEPT;

			if (s->init_buf == NULL)
				{
				if ((buf=BUF_MEM_new()) == NULL)
					{
					ret= -1;
					goto end;
					}
				if (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))
					{
					ret= -1;
					goto end;
					}
				s->init_buf=buf;
				}

			if (!ssl3_setup_buffers(s))
				{
				ret= -1;
				goto end;
				}

			s->init_num=0;
			s->s3->flags &= ~SSL3_FLAGS_SGC_RESTART_DONE;

			if (s->state != SSL_ST_RENEGOTIATE)
				{
				/* Ok, we now need to push on a buffering BIO so that
				 * the output is sent in a way that TCP likes :-)
				 */
				if (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }
				
				ssl3_init_finished_mac(s);
				s->state=SSL3_ST_SR_CLNT_HELLO_A;
				s->ctx->stats.sess_accept++;
				}
			else if (!s->s3->send_connection_binding &&
				!(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))
				{
				/* Server attempting to renegotiate with
				 * client that doesn't support secure
				 * renegotiation.
				 */
				SSLerr(SSL_F_SSL3_ACCEPT, SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);
				ret = -1;
				goto end;
				}
			else
				{
				/* s->state == SSL_ST_RENEGOTIATE,
				 * we will just send a HelloRequest */
				s->ctx->stats.sess_accept_renegotiate++;
				s->state=SSL3_ST_SW_HELLO_REQ_A;
				}
			break;

		case SSL3_ST_SW_HELLO_REQ_A:
		case SSL3_ST_SW_HELLO_REQ_B:

			s->shutdown=0;
			ret=ssl3_send_hello_request(s);
			if (ret <= 0) goto end;
			s->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C;
			s->state=SSL3_ST_SW_FLUSH;
			s->init_num=0;

			ssl3_init_finished_mac(s);
			break;

		case SSL3_ST_SW_HELLO_REQ_C:
			s->state=SSL_ST_OK;
			break;

		case SSL3_ST_SR_CLNT_HELLO_A:
		case SSL3_ST_SR_CLNT_HELLO_B:
		case SSL3_ST_SR_CLNT_HELLO_C:

			s->shutdown=0;
			if (s->rwstate != SSL_X509_LOOKUP)
			{
				ret=ssl3_get_client_hello(s);
				if (ret <= 0) goto end;
			}
#ifndef OPENSSL_NO_SRP
			{
			int al;
			if ((ret = ssl_check_srp_ext_ClientHello(s,&al))  < 0)
					{
					/* callback indicates firther work to be done */
					s->rwstate=SSL_X509_LOOKUP;
					goto end;
					}
			if (ret != SSL_ERROR_NONE)
				{
				ssl3_send_alert(s,SSL3_AL_FATAL,al);	
				/* This is not really an error but the only means to
                                   for a client to detect whether srp is supported. */
 				   if (al != TLS1_AD_UNKNOWN_PSK_IDENTITY) 	
					SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_CLIENTHELLO_TLSEXT);			
				ret = SSL_TLSEXT_ERR_ALERT_FATAL;			
				ret= -1;
				goto end;	
				}
			}
#endif		
			
			s->renegotiate = 2;
			s->state=SSL3_ST_SW_SRVR_HELLO_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_SRVR_HELLO_A:
		case SSL3_ST_SW_SRVR_HELLO_B:
			ret=ssl3_send_server_hello(s);
			if (ret <= 0) goto end;
#ifndef OPENSSL_NO_TLSEXT
			if (s->hit)
				{
				if (s->tlsext_ticket_expected)
					s->state=SSL3_ST_SW_SESSION_TICKET_A;
				else
					s->state=SSL3_ST_SW_CHANGE_A;
				}
#else
			if (s->hit)
					s->state=SSL3_ST_SW_CHANGE_A;
#endif
			else
				s->state=SSL3_ST_SW_CERT_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_CERT_A:
		case SSL3_ST_SW_CERT_B:
			/* Check if it is anon DH or anon ECDH, */
			/* normal PSK or KRB5 or SRP */
			if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)
				&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)
				&& !(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5))
				{
				ret=ssl3_send_server_certificate(s);
				if (ret <= 0) goto end;
#ifndef OPENSSL_NO_TLSEXT
				if (s->tlsext_status_expected)
					s->state=SSL3_ST_SW_CERT_STATUS_A;
				else
					s->state=SSL3_ST_SW_KEY_EXCH_A;
				}
			else
				{
				skip = 1;
				s->state=SSL3_ST_SW_KEY_EXCH_A;
				}
#else
				}
			else
				skip=1;

			s->state=SSL3_ST_SW_KEY_EXCH_A;
#endif
			s->init_num=0;
			break;

		case SSL3_ST_SW_KEY_EXCH_A:
		case SSL3_ST_SW_KEY_EXCH_B:
			alg_k = s->s3->tmp.new_cipher->algorithm_mkey;

			/* clear this, it may get reset by
			 * send_server_key_exchange */
			if ((s->options & SSL_OP_EPHEMERAL_RSA)
#ifndef OPENSSL_NO_KRB5
				&& !(alg_k & SSL_kKRB5)
#endif /* OPENSSL_NO_KRB5 */
				)
				/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key
				 * even when forbidden by protocol specs
				 * (handshake may fail as clients are not required to
				 * be able to handle this) */
				s->s3->tmp.use_rsa_tmp=1;
			else
				s->s3->tmp.use_rsa_tmp=0;


			/* only send if a DH key exchange, fortezza or
			 * RSA but we have a sign only certificate
			 *
			 * PSK: may send PSK identity hints
			 *
			 * For ECC ciphersuites, we send a serverKeyExchange
			 * message only if the cipher suite is either
			 * ECDH-anon or ECDHE. In other cases, the
			 * server certificate contains the server's
			 * public key for key exchange.
			 */
			if (s->s3->tmp.use_rsa_tmp
			/* PSK: send ServerKeyExchange if PSK identity
			 * hint if provided */
#ifndef OPENSSL_NO_PSK
			    || ((alg_k & SSL_kPSK) && s->ctx->psk_identity_hint)
#endif
#ifndef OPENSSL_NO_SRP
			    /* SRP: send ServerKeyExchange */
			    || (alg_k & SSL_kSRP)
#endif
			    || (alg_k & (SSL_kDHr|SSL_kDHd|SSL_kEDH))
			    || (alg_k & SSL_kEECDH)
			    || ((alg_k & SSL_kRSA)
				&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL
				    || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)
					&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)
					)
				    )
				)
			    )
				{
				ret=ssl3_send_server_key_exchange(s);
				if (ret <= 0) goto end;
				}
			else
				skip=1;

			s->state=SSL3_ST_SW_CERT_REQ_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_CERT_REQ_A:
		case SSL3_ST_SW_CERT_REQ_B:
			if (/* don't request cert unless asked for it: */
				!(s->verify_mode & SSL_VERIFY_PEER) ||
				/* if SSL_VERIFY_CLIENT_ONCE is set,
				 * don't request cert during re-negotiation: */
				((s->session->peer != NULL) &&
				 (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||
				/* never request cert in anonymous ciphersuites
				 * (see section ""Certificate request"" in SSL 3 drafts
				 * and in RFC 2246): */
				((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&
				 /* ... except when the application insists on verification
				  * (against the specs, but s3_clnt.c accepts this for SSL 3) */
				 !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||
				 /* never request cert in Kerberos ciphersuites */
				(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5)
				/* With normal PSK Certificates and
				 * Certificate Requests are omitted */
				|| (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
				{
				/* no cert request */
				skip=1;
				s->s3->tmp.cert_request=0;
				s->state=SSL3_ST_SW_SRVR_DONE_A;
				if (s->s3->handshake_buffer)
					if (!ssl3_digest_cached_records(s))
						return -1;
				}
			else
				{
				s->s3->tmp.cert_request=1;
				ret=ssl3_send_certificate_request(s);
				if (ret <= 0) goto end;
#ifndef NETSCAPE_HANG_BUG
				s->state=SSL3_ST_SW_SRVR_DONE_A;
#else
				s->state=SSL3_ST_SW_FLUSH;
				s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
#endif
				s->init_num=0;
				}
			break;

		case SSL3_ST_SW_SRVR_DONE_A:
		case SSL3_ST_SW_SRVR_DONE_B:
			ret=ssl3_send_server_done(s);
			if (ret <= 0) goto end;
			s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
			s->state=SSL3_ST_SW_FLUSH;
			s->init_num=0;
			break;
		
		case SSL3_ST_SW_FLUSH:

			/* This code originally checked to see if
			 * any data was pending using BIO_CTRL_INFO
			 * and then flushed. This caused problems
			 * as documented in PR#1939. The proposed
			 * fix doesn't completely resolve this issue
			 * as buggy implementations of BIO_CTRL_PENDING
			 * still exist. So instead we just flush
			 * unconditionally.
			 */

			s->rwstate=SSL_WRITING;
			if (BIO_flush(s->wbio) <= 0)
				{
				ret= -1;
				goto end;
				}
			s->rwstate=SSL_NOTHING;

			s->state=s->s3->tmp.next_state;
			break;

		case SSL3_ST_SR_CERT_A:
		case SSL3_ST_SR_CERT_B:
			/* Check for second client hello (MS SGC) */
			ret = ssl3_check_client_hello(s);
			if (ret <= 0)
				goto end;
			if (ret == 2)
				s->state = SSL3_ST_SR_CLNT_HELLO_C;
			else {
				if (s->s3->tmp.cert_request)
					{
					ret=ssl3_get_client_certificate(s);
					if (ret <= 0) goto end;
					}
				s->init_num=0;
				s->state=SSL3_ST_SR_KEY_EXCH_A;
			}
			break;

		case SSL3_ST_SR_KEY_EXCH_A:
		case SSL3_ST_SR_KEY_EXCH_B:
			ret=ssl3_get_client_key_exchange(s);
			if (ret <= 0)
				goto end;
			if (ret == 2)
				{
				/* For the ECDH ciphersuites when
				 * the client sends its ECDH pub key in
				 * a certificate, the CertificateVerify
				 * message is not sent.
				 * Also for GOST ciphersuites when
				 * the client uses its key from the certificate
				 * for key exchange.
				 */
#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
				s->state=SSL3_ST_SR_FINISHED_A;
#else
				if (s->s3->next_proto_neg_seen)
					s->state=SSL3_ST_SR_NEXT_PROTO_A;
				else
					s->state=SSL3_ST_SR_FINISHED_A;
#endif
				s->init_num = 0;
				}
			else if (TLS1_get_version(s) >= TLS1_2_VERSION)
				{
				s->state=SSL3_ST_SR_CERT_VRFY_A;
				s->init_num=0;
				if (!s->session->peer)
					break;
				/* For TLS v1.2 freeze the handshake buffer
				 * at this point and digest cached records.
				 */
				if (!s->s3->handshake_buffer)
					{
					SSLerr(SSL_F_SSL3_ACCEPT,ERR_R_INTERNAL_ERROR);
					return -1;
					}
				s->s3->flags |= TLS1_FLAGS_KEEP_HANDSHAKE;
				if (!ssl3_digest_cached_records(s))
					return -1;
				}
			else
				{
				int offset=0;
				int dgst_num;

				s->state=SSL3_ST_SR_CERT_VRFY_A;
				s->init_num=0;

				/* We need to get hashes here so if there is
				 * a client cert, it can be verified
				 * FIXME - digest processing for CertificateVerify
				 * should be generalized. But it is next step
				 */
				if (s->s3->handshake_buffer)
					if (!ssl3_digest_cached_records(s))
						return -1;
				for (dgst_num=0; dgst_num<SSL_MAX_DIGEST;dgst_num++)	
					if (s->s3->handshake_dgst[dgst_num]) 
						{
						int dgst_size;

						s->method->ssl3_enc->cert_verify_mac(s,EVP_MD_CTX_type(s->s3->handshake_dgst[dgst_num]),&(s->s3->tmp.cert_verify_md[offset]));
						dgst_size=EVP_MD_CTX_size(s->s3->handshake_dgst[dgst_num]);
						if (dgst_size < 0)
							{
							ret = -1;
							goto end;
							}
						offset+=dgst_size;
						}		
				}
			break;

                case SSL3_ST_SR_CERT_VRFY_A:
                case SSL3_ST_SR_CERT_VRFY_B:
 
                        /* we should decide if we expected this one */
                        ret=ssl3_get_cert_verify(s);
                        if (ret <= 0) goto end;
#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
			s->state=SSL3_ST_SR_FINISHED_A;
#else
			if (s->s3->next_proto_neg_seen)
				s->state=SSL3_ST_SR_NEXT_PROTO_A;
			else
				s->state=SSL3_ST_SR_FINISHED_A;
#endif
			s->init_num=0;
			break;

#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
		case SSL3_ST_SR_NEXT_PROTO_A:
		case SSL3_ST_SR_NEXT_PROTO_B:
			ret=ssl3_get_next_proto(s);
			if (ret <= 0) goto end;
			s->init_num = 0;
			s->state=SSL3_ST_SR_FINISHED_A;
			break;
#endif

 
                case SSL3_ST_SR_FINISHED_A:
                case SSL3_ST_SR_FINISHED_B:
                        ret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,
                                SSL3_ST_SR_FINISHED_B);
                        if (ret <= 0) goto end;
#ifndef OPENSSL_NO_TLSEXT
			else if (s->tlsext_ticket_expected)
				s->state=SSL3_ST_SW_SESSION_TICKET_A;
#endif
			else
				s->state=SSL3_ST_SW_CHANGE_A;
			s->init_num=0;
			break;

#ifndef OPENSSL_NO_TLSEXT
		case SSL3_ST_SW_SESSION_TICKET_A:
		case SSL3_ST_SW_SESSION_TICKET_B:
			ret=ssl3_send_newsession_ticket(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_CHANGE_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_CERT_STATUS_A:
		case SSL3_ST_SW_CERT_STATUS_B:
			ret=ssl3_send_cert_status(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_KEY_EXCH_A;
			s->init_num=0;
			break;

#endif

		case SSL3_ST_SW_CHANGE_A:
		case SSL3_ST_SW_CHANGE_B:

			s->session->cipher=s->s3->tmp.new_cipher;
			if (!s->method->ssl3_enc->setup_key_block(s))
				{ ret= -1; goto end; }

			ret=ssl3_send_change_cipher_spec(s,
				SSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);

			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_FINISHED_A;
			s->init_num=0;

			if (!s->method->ssl3_enc->change_cipher_state(s,
				SSL3_CHANGE_CIPHER_SERVER_WRITE))
				{
				ret= -1;
				goto end;
				}

			break;

		case SSL3_ST_SW_FINISHED_A:
		case SSL3_ST_SW_FINISHED_B:
			ret=ssl3_send_finished(s,
				SSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,
				s->method->ssl3_enc->server_finished_label,
				s->method->ssl3_enc->server_finished_label_len);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_FLUSH;
			if (s->hit)
				{
#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
				s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;
#else
                                s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;
 #else
                                if (s->s3->next_proto_neg_seen)
                                        s->s3->tmp.next_state=SSL3_ST_SR_NEXT_PROTO_A;
                                else
                                        s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;
 #endif

		case SSL_ST_OK:
			/* clean a few things up */
			ssl3_cleanup_key_block(s);

			BUF_MEM_free(s->init_buf);
			s->init_buf=NULL;

			/* remove buffering on output */
			ssl_free_wbio_buffer(s);

			s->init_num=0;

			if (s->renegotiate == 2) /* skipped if we just sent a HelloRequest */
				{
				s->renegotiate=0;
				s->new_session=0;
				
				ssl_update_cache(s,SSL_SESS_CACHE_SERVER);
				
				s->ctx->stats.sess_accept_good++;
				/* s->server=1; */
				s->handshake_func=ssl3_accept;

				if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);
				}
			
			ret = 1;
			goto end;
			/* break; */

		default:
			SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_UNKNOWN_STATE);
			ret= -1;
			goto end;
			/* break; */
			}
		
		if (!s->s3->tmp.reuse_message && !skip)
			{
			if (s->debug)
				{
				if ((ret=BIO_flush(s->wbio)) <= 0)
					goto end;
				}


			if ((cb != NULL) && (s->state != state))
				{
				new_state=s->state;
				s->state=state;
				cb(s,SSL_CB_ACCEPT_LOOP,1);
				s->state=new_state;
				}
			}
		skip=0;
		}
end:
	/* BIO_flush(s->wbio); */

	s->in_handshake--;
	if (cb != NULL)
		cb(s,SSL_CB_ACCEPT_EXIT,ret);
	return(ret);
	}
",C,"                       s->s3->flags |= SSL3_FLAGS_CCS_OK;
                       s->s3->flags |= SSL3_FLAGS_CCS_OK;
                                       {
                                       s->s3->flags |= SSL3_FLAGS_CCS_OK;
                                       }
",,1632ef744872edc2aa2a53d487d3e79c965a4ad3,"@@ -673,6 +673,7 @@ int ssl3_accept(SSL *s)
                case SSL3_ST_SR_CERT_VRFY_A:
                case SSL3_ST_SR_CERT_VRFY_B:
 
+                       s->s3->flags |= SSL3_FLAGS_CCS_OK;
                        /* we should decide if we expected this one */
                        ret=ssl3_get_cert_verify(s);
                        if (ret <= 0) goto end;
@@ -700,6 +701,7 @@ int ssl3_accept(SSL *s)
 
                case SSL3_ST_SR_FINISHED_A:
                case SSL3_ST_SR_FINISHED_B:
+                       s->s3->flags |= SSL3_FLAGS_CCS_OK;
                        ret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,
                                SSL3_ST_SR_FINISHED_B);
                        if (ret <= 0) goto end;
@@ -770,7 +772,10 @@ int ssl3_accept(SSL *s)
                                s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;
 #else
                                if (s->s3->next_proto_neg_seen)
+                                       {
+                                       s->s3->flags |= SSL3_FLAGS_CCS_OK;
                                        s->s3->tmp.next_state=SSL3_ST_SR_NEXT_PROTO_A;
+                                       }
                                else
                                        s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;
 #endif",openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=ssl/s3_srvr.c;h=503bed3fe0b496eac84bac015db81392c55acc8c;hb=bc8923b1ec9c467755cd86f7848c50ee8812e441,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=ssl/s3_srvr.c;h=5ac4119b9d85e3d99c0e27a68fd90e3c61e89183,1,"int ssl3_accept(SSL *s)
	{
	BUF_MEM *buf;
	unsigned long alg_k,Time=(unsigned long)time(NULL);
	void (*cb)(const SSL *ssl,int type,int val)=NULL;
	int ret= -1;
	int new_state,state,skip=0;

	RAND_add(&Time,sizeof(Time),0);
	ERR_clear_error();
	clear_sys_error();

	if (s->info_callback != NULL)
		cb=s->info_callback;
	else if (s->ctx->info_callback != NULL)
		cb=s->ctx->info_callback;

	/* init things to blank */
	s->in_handshake++;
	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);

	if (s->cert == NULL)
		{
		SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_NO_CERTIFICATE_SET);
		return(-1);
		}

#ifndef OPENSSL_NO_HEARTBEATS
	/* If we're awaiting a HeartbeatResponse, pretend we
	 * already got and don't await it anymore, because
	 * Heartbeats don't make sense during handshakes anyway.
	 */
	if (s->tlsext_hb_pending)
		{
		s->tlsext_hb_pending = 0;
		s->tlsext_hb_seq++;
		}
#endif

	for (;;)
		{
		state=s->state;

		switch (s->state)
			{
		case SSL_ST_RENEGOTIATE:
			s->renegotiate=1;
			/* s->state=SSL_ST_ACCEPT; */

		case SSL_ST_BEFORE:
		case SSL_ST_ACCEPT:
		case SSL_ST_BEFORE|SSL_ST_ACCEPT:
		case SSL_ST_OK|SSL_ST_ACCEPT:

			s->server=1;
			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);

			if ((s->version>>8) != 3)
				{
				SSLerr(SSL_F_SSL3_ACCEPT, ERR_R_INTERNAL_ERROR);
				return -1;
				}
			s->type=SSL_ST_ACCEPT;

			if (s->init_buf == NULL)
				{
				if ((buf=BUF_MEM_new()) == NULL)
					{
					ret= -1;
					goto end;
					}
				if (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))
					{
					ret= -1;
					goto end;
					}
				s->init_buf=buf;
				}

			if (!ssl3_setup_buffers(s))
				{
				ret= -1;
				goto end;
				}

			s->init_num=0;
			s->s3->flags &= ~SSL3_FLAGS_SGC_RESTART_DONE;

			if (s->state != SSL_ST_RENEGOTIATE)
				{
				/* Ok, we now need to push on a buffering BIO so that
				 * the output is sent in a way that TCP likes :-)
				 */
				if (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }
				
				ssl3_init_finished_mac(s);
				s->state=SSL3_ST_SR_CLNT_HELLO_A;
				s->ctx->stats.sess_accept++;
				}
			else if (!s->s3->send_connection_binding &&
				!(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))
				{
				/* Server attempting to renegotiate with
				 * client that doesn't support secure
				 * renegotiation.
				 */
				SSLerr(SSL_F_SSL3_ACCEPT, SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);
				ret = -1;
				goto end;
				}
			else
				{
				/* s->state == SSL_ST_RENEGOTIATE,
				 * we will just send a HelloRequest */
				s->ctx->stats.sess_accept_renegotiate++;
				s->state=SSL3_ST_SW_HELLO_REQ_A;
				}
			break;

		case SSL3_ST_SW_HELLO_REQ_A:
		case SSL3_ST_SW_HELLO_REQ_B:

			s->shutdown=0;
			ret=ssl3_send_hello_request(s);
			if (ret <= 0) goto end;
			s->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C;
			s->state=SSL3_ST_SW_FLUSH;
			s->init_num=0;

			ssl3_init_finished_mac(s);
			break;

		case SSL3_ST_SW_HELLO_REQ_C:
			s->state=SSL_ST_OK;
			break;

		case SSL3_ST_SR_CLNT_HELLO_A:
		case SSL3_ST_SR_CLNT_HELLO_B:
		case SSL3_ST_SR_CLNT_HELLO_C:

			s->shutdown=0;
			if (s->rwstate != SSL_X509_LOOKUP)
			{
				ret=ssl3_get_client_hello(s);
				if (ret <= 0) goto end;
			}
#ifndef OPENSSL_NO_SRP
			{
			int al;
			if ((ret = ssl_check_srp_ext_ClientHello(s,&al))  < 0)
					{
					/* callback indicates firther work to be done */
					s->rwstate=SSL_X509_LOOKUP;
					goto end;
					}
			if (ret != SSL_ERROR_NONE)
				{
				ssl3_send_alert(s,SSL3_AL_FATAL,al);	
				/* This is not really an error but the only means to
                                   for a client to detect whether srp is supported. */
 				   if (al != TLS1_AD_UNKNOWN_PSK_IDENTITY) 	
					SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_CLIENTHELLO_TLSEXT);			
				ret = SSL_TLSEXT_ERR_ALERT_FATAL;			
				ret= -1;
				goto end;	
				}
			}
#endif		
			
			s->renegotiate = 2;
			s->state=SSL3_ST_SW_SRVR_HELLO_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_SRVR_HELLO_A:
		case SSL3_ST_SW_SRVR_HELLO_B:
			ret=ssl3_send_server_hello(s);
			if (ret <= 0) goto end;
#ifndef OPENSSL_NO_TLSEXT
			if (s->hit)
				{
				if (s->tlsext_ticket_expected)
					s->state=SSL3_ST_SW_SESSION_TICKET_A;
				else
					s->state=SSL3_ST_SW_CHANGE_A;
				}
#else
			if (s->hit)
					s->state=SSL3_ST_SW_CHANGE_A;
#endif
			else
				s->state=SSL3_ST_SW_CERT_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_CERT_A:
		case SSL3_ST_SW_CERT_B:
			/* Check if it is anon DH or anon ECDH, */
			/* normal PSK or KRB5 or SRP */
			if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)
				&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)
				&& !(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5))
				{
				ret=ssl3_send_server_certificate(s);
				if (ret <= 0) goto end;
#ifndef OPENSSL_NO_TLSEXT
				if (s->tlsext_status_expected)
					s->state=SSL3_ST_SW_CERT_STATUS_A;
				else
					s->state=SSL3_ST_SW_KEY_EXCH_A;
				}
			else
				{
				skip = 1;
				s->state=SSL3_ST_SW_KEY_EXCH_A;
				}
#else
				}
			else
				skip=1;

			s->state=SSL3_ST_SW_KEY_EXCH_A;
#endif
			s->init_num=0;
			break;

		case SSL3_ST_SW_KEY_EXCH_A:
		case SSL3_ST_SW_KEY_EXCH_B:
			alg_k = s->s3->tmp.new_cipher->algorithm_mkey;

			/* clear this, it may get reset by
			 * send_server_key_exchange */
			if ((s->options & SSL_OP_EPHEMERAL_RSA)
#ifndef OPENSSL_NO_KRB5
				&& !(alg_k & SSL_kKRB5)
#endif /* OPENSSL_NO_KRB5 */
				)
				/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key
				 * even when forbidden by protocol specs
				 * (handshake may fail as clients are not required to
				 * be able to handle this) */
				s->s3->tmp.use_rsa_tmp=1;
			else
				s->s3->tmp.use_rsa_tmp=0;


			/* only send if a DH key exchange, fortezza or
			 * RSA but we have a sign only certificate
			 *
			 * PSK: may send PSK identity hints
			 *
			 * For ECC ciphersuites, we send a serverKeyExchange
			 * message only if the cipher suite is either
			 * ECDH-anon or ECDHE. In other cases, the
			 * server certificate contains the server's
			 * public key for key exchange.
			 */
			if (s->s3->tmp.use_rsa_tmp
			/* PSK: send ServerKeyExchange if PSK identity
			 * hint if provided */
#ifndef OPENSSL_NO_PSK
			    || ((alg_k & SSL_kPSK) && s->ctx->psk_identity_hint)
#endif
#ifndef OPENSSL_NO_SRP
			    /* SRP: send ServerKeyExchange */
			    || (alg_k & SSL_kSRP)
#endif
			    || (alg_k & (SSL_kDHr|SSL_kDHd|SSL_kEDH))
			    || (alg_k & SSL_kEECDH)
			    || ((alg_k & SSL_kRSA)
				&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL
				    || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)
					&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)
					)
				    )
				)
			    )
				{
				ret=ssl3_send_server_key_exchange(s);
				if (ret <= 0) goto end;
				}
			else
				skip=1;

			s->state=SSL3_ST_SW_CERT_REQ_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_CERT_REQ_A:
		case SSL3_ST_SW_CERT_REQ_B:
			if (/* don't request cert unless asked for it: */
				!(s->verify_mode & SSL_VERIFY_PEER) ||
				/* if SSL_VERIFY_CLIENT_ONCE is set,
				 * don't request cert during re-negotiation: */
				((s->session->peer != NULL) &&
				 (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||
				/* never request cert in anonymous ciphersuites
				 * (see section ""Certificate request"" in SSL 3 drafts
				 * and in RFC 2246): */
				((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&
				 /* ... except when the application insists on verification
				  * (against the specs, but s3_clnt.c accepts this for SSL 3) */
				 !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||
				 /* never request cert in Kerberos ciphersuites */
				(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5)
				/* With normal PSK Certificates and
				 * Certificate Requests are omitted */
				|| (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
				{
				/* no cert request */
				skip=1;
				s->s3->tmp.cert_request=0;
				s->state=SSL3_ST_SW_SRVR_DONE_A;
				if (s->s3->handshake_buffer)
					if (!ssl3_digest_cached_records(s))
						return -1;
				}
			else
				{
				s->s3->tmp.cert_request=1;
				ret=ssl3_send_certificate_request(s);
				if (ret <= 0) goto end;
#ifndef NETSCAPE_HANG_BUG
				s->state=SSL3_ST_SW_SRVR_DONE_A;
#else
				s->state=SSL3_ST_SW_FLUSH;
				s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
#endif
				s->init_num=0;
				}
			break;

		case SSL3_ST_SW_SRVR_DONE_A:
		case SSL3_ST_SW_SRVR_DONE_B:
			ret=ssl3_send_server_done(s);
			if (ret <= 0) goto end;
			s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
			s->state=SSL3_ST_SW_FLUSH;
			s->init_num=0;
			break;
		
		case SSL3_ST_SW_FLUSH:

			/* This code originally checked to see if
			 * any data was pending using BIO_CTRL_INFO
			 * and then flushed. This caused problems
			 * as documented in PR#1939. The proposed
			 * fix doesn't completely resolve this issue
			 * as buggy implementations of BIO_CTRL_PENDING
			 * still exist. So instead we just flush
			 * unconditionally.
			 */

			s->rwstate=SSL_WRITING;
			if (BIO_flush(s->wbio) <= 0)
				{
				ret= -1;
				goto end;
				}
			s->rwstate=SSL_NOTHING;

			s->state=s->s3->tmp.next_state;
			break;

		case SSL3_ST_SR_CERT_A:
		case SSL3_ST_SR_CERT_B:
			/* Check for second client hello (MS SGC) */
			ret = ssl3_check_client_hello(s);
			if (ret <= 0)
				goto end;
			if (ret == 2)
				s->state = SSL3_ST_SR_CLNT_HELLO_C;
			else {
				if (s->s3->tmp.cert_request)
					{
					ret=ssl3_get_client_certificate(s);
					if (ret <= 0) goto end;
					}
				s->init_num=0;
				s->state=SSL3_ST_SR_KEY_EXCH_A;
			}
			break;

		case SSL3_ST_SR_KEY_EXCH_A:
		case SSL3_ST_SR_KEY_EXCH_B:
			ret=ssl3_get_client_key_exchange(s);
			if (ret <= 0)
				goto end;
			if (ret == 2)
				{
				/* For the ECDH ciphersuites when
				 * the client sends its ECDH pub key in
				 * a certificate, the CertificateVerify
				 * message is not sent.
				 * Also for GOST ciphersuites when
				 * the client uses its key from the certificate
				 * for key exchange.
				 */
#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
				s->state=SSL3_ST_SR_FINISHED_A;
#else
				if (s->s3->next_proto_neg_seen)
					s->state=SSL3_ST_SR_NEXT_PROTO_A;
				else
					s->state=SSL3_ST_SR_FINISHED_A;
#endif
				s->init_num = 0;
				}
			else if (TLS1_get_version(s) >= TLS1_2_VERSION)
				{
				s->state=SSL3_ST_SR_CERT_VRFY_A;
				s->init_num=0;
				if (!s->session->peer)
					break;
				/* For TLS v1.2 freeze the handshake buffer
				 * at this point and digest cached records.
				 */
				if (!s->s3->handshake_buffer)
					{
					SSLerr(SSL_F_SSL3_ACCEPT,ERR_R_INTERNAL_ERROR);
					return -1;
					}
				s->s3->flags |= TLS1_FLAGS_KEEP_HANDSHAKE;
				if (!ssl3_digest_cached_records(s))
					return -1;
				}
			else
				{
				int offset=0;
				int dgst_num;

				s->state=SSL3_ST_SR_CERT_VRFY_A;
				s->init_num=0;

				/* We need to get hashes here so if there is
				 * a client cert, it can be verified
				 * FIXME - digest processing for CertificateVerify
				 * should be generalized. But it is next step
				 */
				if (s->s3->handshake_buffer)
					if (!ssl3_digest_cached_records(s))
						return -1;
				for (dgst_num=0; dgst_num<SSL_MAX_DIGEST;dgst_num++)	
					if (s->s3->handshake_dgst[dgst_num]) 
						{
						int dgst_size;

						s->method->ssl3_enc->cert_verify_mac(s,EVP_MD_CTX_type(s->s3->handshake_dgst[dgst_num]),&(s->s3->tmp.cert_verify_md[offset]));
						dgst_size=EVP_MD_CTX_size(s->s3->handshake_dgst[dgst_num]);
						if (dgst_size < 0)
							{
							ret = -1;
							goto end;
							}
						offset+=dgst_size;
						}		
				}
			break;

                case SSL3_ST_SR_CERT_VRFY_A:
                case SSL3_ST_SR_CERT_VRFY_B:
 
//fix_flaw_line_below:
//                       s->s3->flags |= SSL3_FLAGS_CCS_OK;
                        /* we should decide if we expected this one */
                        ret=ssl3_get_cert_verify(s);
                        if (ret <= 0) goto end;
#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
			s->state=SSL3_ST_SR_FINISHED_A;
#else
			if (s->s3->next_proto_neg_seen)
				s->state=SSL3_ST_SR_NEXT_PROTO_A;
			else
				s->state=SSL3_ST_SR_FINISHED_A;
#endif
			s->init_num=0;
			break;

#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
		case SSL3_ST_SR_NEXT_PROTO_A:
		case SSL3_ST_SR_NEXT_PROTO_B:
			ret=ssl3_get_next_proto(s);
			if (ret <= 0) goto end;
			s->init_num = 0;
			s->state=SSL3_ST_SR_FINISHED_A;
			break;
#endif

 
                case SSL3_ST_SR_FINISHED_A:
                case SSL3_ST_SR_FINISHED_B:
//fix_flaw_line_below:
//                       s->s3->flags |= SSL3_FLAGS_CCS_OK;
                        ret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,
                                SSL3_ST_SR_FINISHED_B);
                        if (ret <= 0) goto end;
#ifndef OPENSSL_NO_TLSEXT
			else if (s->tlsext_ticket_expected)
				s->state=SSL3_ST_SW_SESSION_TICKET_A;
#endif
			else
				s->state=SSL3_ST_SW_CHANGE_A;
			s->init_num=0;
			break;

#ifndef OPENSSL_NO_TLSEXT
		case SSL3_ST_SW_SESSION_TICKET_A:
		case SSL3_ST_SW_SESSION_TICKET_B:
			ret=ssl3_send_newsession_ticket(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_CHANGE_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_CERT_STATUS_A:
		case SSL3_ST_SW_CERT_STATUS_B:
			ret=ssl3_send_cert_status(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_KEY_EXCH_A;
			s->init_num=0;
			break;

#endif

		case SSL3_ST_SW_CHANGE_A:
		case SSL3_ST_SW_CHANGE_B:

			s->session->cipher=s->s3->tmp.new_cipher;
			if (!s->method->ssl3_enc->setup_key_block(s))
				{ ret= -1; goto end; }

			ret=ssl3_send_change_cipher_spec(s,
				SSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);

			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_FINISHED_A;
			s->init_num=0;

			if (!s->method->ssl3_enc->change_cipher_state(s,
				SSL3_CHANGE_CIPHER_SERVER_WRITE))
				{
				ret= -1;
				goto end;
				}

			break;

		case SSL3_ST_SW_FINISHED_A:
		case SSL3_ST_SW_FINISHED_B:
			ret=ssl3_send_finished(s,
				SSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,
				s->method->ssl3_enc->server_finished_label,
				s->method->ssl3_enc->server_finished_label_len);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_FLUSH;
			if (s->hit)
				{
#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
				s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;
#else
                                s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;
 #else
                                if (s->s3->next_proto_neg_seen)
//fix_flaw_line_below:
//                                       {
//fix_flaw_line_below:
//                                       s->s3->flags |= SSL3_FLAGS_CCS_OK;
                                        s->s3->tmp.next_state=SSL3_ST_SR_NEXT_PROTO_A;
//fix_flaw_line_below:
//                                       }
                                else
                                        s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;
 #endif

		case SSL_ST_OK:
			/* clean a few things up */
			ssl3_cleanup_key_block(s);

			BUF_MEM_free(s->init_buf);
			s->init_buf=NULL;

			/* remove buffering on output */
			ssl_free_wbio_buffer(s);

			s->init_num=0;

			if (s->renegotiate == 2) /* skipped if we just sent a HelloRequest */
				{
				s->renegotiate=0;
				s->new_session=0;
				
				ssl_update_cache(s,SSL_SESS_CACHE_SERVER);
				
				s->ctx->stats.sess_accept_good++;
				/* s->server=1; */
				s->handshake_func=ssl3_accept;

				if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);
				}
			
			ret = 1;
			goto end;
			/* break; */

		default:
			SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_UNKNOWN_STATE);
			ret= -1;
			goto end;
			/* break; */
			}
		
		if (!s->s3->tmp.reuse_message && !skip)
			{
			if (s->debug)
				{
				if ((ret=BIO_flush(s->wbio)) <= 0)
					goto end;
				}


			if ((cb != NULL) && (s->state != state))
				{
				new_state=s->state;
				s->state=state;
				cb(s,SSL_CB_ACCEPT_LOOP,1);
				s->state=new_state;
				}
			}
		skip=0;
		}
end:
	/* BIO_flush(s->wbio); */

	s->in_handshake--;
	if (cb != NULL)
		cb(s,SSL_CB_ACCEPT_EXIT,ret);
	return(ret);
	}
"
757,178493,,Remote,Not required,,CVE-2015-3197,https://www.cvedetails.com/cve/CVE-2015-3197/,CWE-310,Medium,Partial,,,2016-02-14,4.3,"ssl/s2_srvr.c in OpenSSL 1.0.1 before 1.0.1r and 1.0.2 before 1.0.2f does not prevent use of disabled ciphers, which makes it easier for man-in-the-middle attackers to defeat cryptographic protection mechanisms by performing computations on SSLv2 traffic, related to the get_client_master_key and get_client_hello functions.",2017-11-20,,12,https://git.openssl.org/?p=openssl.git;a=commit;h=d81a1600588b726c2bdccda7efad3cc7a87d6245,d81a1600588b726c2bdccda7efad3cc7a87d6245,,1,,,"static int get_client_hello(SSL *s)
{
    int i, n;
    unsigned long len;
    unsigned char *p;
    STACK_OF(SSL_CIPHER) *cs;   /* a stack of SSL_CIPHERS */
    STACK_OF(SSL_CIPHER) *cl;   /* the ones we want to use */
    STACK_OF(SSL_CIPHER) *prio, *allow;
    int z;

    /*
     * This is a bit of a hack to check for the correct packet type the first
     * time round.
     */
    if (s->state == SSL2_ST_GET_CLIENT_HELLO_A) {
        s->first_packet = 1;
        s->state = SSL2_ST_GET_CLIENT_HELLO_B;
    }

    p = (unsigned char *)s->init_buf->data;
    if (s->state == SSL2_ST_GET_CLIENT_HELLO_B) {
        i = ssl2_read(s, (char *)&(p[s->init_num]), 9 - s->init_num);
        if (i < (9 - s->init_num))
            return (ssl2_part_read(s, SSL_F_GET_CLIENT_HELLO, i));
        s->init_num = 9;

        if (*(p++) != SSL2_MT_CLIENT_HELLO) {
            if (p[-1] != SSL2_MT_ERROR) {
                ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
                SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_READ_WRONG_PACKET_TYPE);
            } else
                SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_PEER_ERROR);
            return (-1);
        }
        n2s(p, i);
        if (i < s->version)
            s->version = i;
        n2s(p, i);
        s->s2->tmp.cipher_spec_length = i;
        n2s(p, i);
        s->s2->tmp.session_id_length = i;
        if ((i < 0) || (i > SSL_MAX_SSL_SESSION_ID_LENGTH)) {
            ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
            SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);
            return -1;
        }
        n2s(p, i);
        s->s2->challenge_length = i;
        if ((i < SSL2_MIN_CHALLENGE_LENGTH) ||
            (i > SSL2_MAX_CHALLENGE_LENGTH)) {
            ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
            SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_INVALID_CHALLENGE_LENGTH);
            return (-1);
        }
        s->state = SSL2_ST_GET_CLIENT_HELLO_C;
    }

    /* SSL2_ST_GET_CLIENT_HELLO_C */
    p = (unsigned char *)s->init_buf->data;
    len =
        9 + (unsigned long)s->s2->tmp.cipher_spec_length +
        (unsigned long)s->s2->challenge_length +
        (unsigned long)s->s2->tmp.session_id_length;
    if (len > SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER) {
        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_MESSAGE_TOO_LONG);
        return -1;
    }
    n = (int)len - s->init_num;
    i = ssl2_read(s, (char *)&(p[s->init_num]), n);
    if (i != n)
        return (ssl2_part_read(s, SSL_F_GET_CLIENT_HELLO, i));
    if (s->msg_callback) {
        /* CLIENT-HELLO */
        s->msg_callback(0, s->version, 0, p, (size_t)len, s,
                        s->msg_callback_arg);
    }
    p += 9;

    /*
     * get session-id before cipher stuff so we can get out session structure
     * if it is cached
     */
    /* session-id */
    if ((s->s2->tmp.session_id_length != 0) &&
        (s->s2->tmp.session_id_length != SSL2_SSL_SESSION_ID_LENGTH)) {
        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_BAD_SSL_SESSION_ID_LENGTH);
        return (-1);
    }

    if (s->s2->tmp.session_id_length == 0) {
        if (!ssl_get_new_session(s, 1)) {
            ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
            return (-1);
        }
    } else {
        i = ssl_get_prev_session(s, &(p[s->s2->tmp.cipher_spec_length]),
                                 s->s2->tmp.session_id_length, NULL);
        if (i == 1) {           /* previous session */
            s->hit = 1;
        } else if (i == -1) {
            ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
            return (-1);
        } else {
            if (s->cert == NULL) {
                ssl2_return_error(s, SSL2_PE_NO_CERTIFICATE);
                SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_NO_CERTIFICATE_SET);
                return (-1);
            }

            if (!ssl_get_new_session(s, 1)) {
                ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
                return (-1);
            }
        }
    }

    if (!s->hit) {
        cs = ssl_bytes_to_cipher_list(s, p, s->s2->tmp.cipher_spec_length,
                                      &s->session->ciphers);
        if (cs == NULL)
            goto mem_err;

        cl = SSL_get_ciphers(s);

        if (s->options & SSL_OP_CIPHER_SERVER_PREFERENCE) {
            prio = sk_SSL_CIPHER_dup(cl);
            if (prio == NULL)
                goto mem_err;
            allow = cs;
        } else {
             prio = cs;
             allow = cl;
         }

        /* Generate list of SSLv2 ciphers shared between client and server */
         for (z = 0; z < sk_SSL_CIPHER_num(prio); z++) {
            const SSL_CIPHER *cp = sk_SSL_CIPHER_value(prio, z);
            if ((cp->algorithm_ssl & SSL_SSLV2) == 0 ||
                sk_SSL_CIPHER_find(allow, cp) < 0) {
                 (void)sk_SSL_CIPHER_delete(prio, z);
                 z--;
             }
        }
        /*
             sk_SSL_CIPHER_free(s->session->ciphers);
             s->session->ciphers = prio;
         }

        /* Make sure we have at least one cipher in common */
        if (sk_SSL_CIPHER_num(s->session->ciphers) == 0) {
            ssl2_return_error(s, SSL2_PE_NO_CIPHER);
            SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_NO_CIPHER_MATCH);
            return -1;
        }
         /*
          * s->session->ciphers should now have a list of ciphers that are on
          * both the client and server. This list is ordered by the order the
    if (s->s2->challenge_length > sizeof s->s2->challenge) {
        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
        return -1;
    }
    memcpy(s->s2->challenge, p, (unsigned int)s->s2->challenge_length);
    return (1);
 mem_err:
    SSLerr(SSL_F_GET_CLIENT_HELLO, ERR_R_MALLOC_FAILURE);
    return (0);
}
","static int get_client_hello(SSL *s)
{
    int i, n;
    unsigned long len;
    unsigned char *p;
    STACK_OF(SSL_CIPHER) *cs;   /* a stack of SSL_CIPHERS */
    STACK_OF(SSL_CIPHER) *cl;   /* the ones we want to use */
    STACK_OF(SSL_CIPHER) *prio, *allow;
    int z;

    /*
     * This is a bit of a hack to check for the correct packet type the first
     * time round.
     */
    if (s->state == SSL2_ST_GET_CLIENT_HELLO_A) {
        s->first_packet = 1;
        s->state = SSL2_ST_GET_CLIENT_HELLO_B;
    }

    p = (unsigned char *)s->init_buf->data;
    if (s->state == SSL2_ST_GET_CLIENT_HELLO_B) {
        i = ssl2_read(s, (char *)&(p[s->init_num]), 9 - s->init_num);
        if (i < (9 - s->init_num))
            return (ssl2_part_read(s, SSL_F_GET_CLIENT_HELLO, i));
        s->init_num = 9;

        if (*(p++) != SSL2_MT_CLIENT_HELLO) {
            if (p[-1] != SSL2_MT_ERROR) {
                ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
                SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_READ_WRONG_PACKET_TYPE);
            } else
                SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_PEER_ERROR);
            return (-1);
        }
        n2s(p, i);
        if (i < s->version)
            s->version = i;
        n2s(p, i);
        s->s2->tmp.cipher_spec_length = i;
        n2s(p, i);
        s->s2->tmp.session_id_length = i;
        if ((i < 0) || (i > SSL_MAX_SSL_SESSION_ID_LENGTH)) {
            ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
            SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);
            return -1;
        }
        n2s(p, i);
        s->s2->challenge_length = i;
        if ((i < SSL2_MIN_CHALLENGE_LENGTH) ||
            (i > SSL2_MAX_CHALLENGE_LENGTH)) {
            ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
            SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_INVALID_CHALLENGE_LENGTH);
            return (-1);
        }
        s->state = SSL2_ST_GET_CLIENT_HELLO_C;
    }

    /* SSL2_ST_GET_CLIENT_HELLO_C */
    p = (unsigned char *)s->init_buf->data;
    len =
        9 + (unsigned long)s->s2->tmp.cipher_spec_length +
        (unsigned long)s->s2->challenge_length +
        (unsigned long)s->s2->tmp.session_id_length;
    if (len > SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER) {
        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_MESSAGE_TOO_LONG);
        return -1;
    }
    n = (int)len - s->init_num;
    i = ssl2_read(s, (char *)&(p[s->init_num]), n);
    if (i != n)
        return (ssl2_part_read(s, SSL_F_GET_CLIENT_HELLO, i));
    if (s->msg_callback) {
        /* CLIENT-HELLO */
        s->msg_callback(0, s->version, 0, p, (size_t)len, s,
                        s->msg_callback_arg);
    }
    p += 9;

    /*
     * get session-id before cipher stuff so we can get out session structure
     * if it is cached
     */
    /* session-id */
    if ((s->s2->tmp.session_id_length != 0) &&
        (s->s2->tmp.session_id_length != SSL2_SSL_SESSION_ID_LENGTH)) {
        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_BAD_SSL_SESSION_ID_LENGTH);
        return (-1);
    }

    if (s->s2->tmp.session_id_length == 0) {
        if (!ssl_get_new_session(s, 1)) {
            ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
            return (-1);
        }
    } else {
        i = ssl_get_prev_session(s, &(p[s->s2->tmp.cipher_spec_length]),
                                 s->s2->tmp.session_id_length, NULL);
        if (i == 1) {           /* previous session */
            s->hit = 1;
        } else if (i == -1) {
            ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
            return (-1);
        } else {
            if (s->cert == NULL) {
                ssl2_return_error(s, SSL2_PE_NO_CERTIFICATE);
                SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_NO_CERTIFICATE_SET);
                return (-1);
            }

            if (!ssl_get_new_session(s, 1)) {
                ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
                return (-1);
            }
        }
    }

    if (!s->hit) {
        cs = ssl_bytes_to_cipher_list(s, p, s->s2->tmp.cipher_spec_length,
                                      &s->session->ciphers);
        if (cs == NULL)
            goto mem_err;

        cl = SSL_get_ciphers(s);

        if (s->options & SSL_OP_CIPHER_SERVER_PREFERENCE) {
            prio = sk_SSL_CIPHER_dup(cl);
            if (prio == NULL)
                goto mem_err;
            allow = cs;
        } else {
             prio = cs;
             allow = cl;
         }
         for (z = 0; z < sk_SSL_CIPHER_num(prio); z++) {
            if (sk_SSL_CIPHER_find(allow, sk_SSL_CIPHER_value(prio, z)) < 0) {
                 (void)sk_SSL_CIPHER_delete(prio, z);
                 z--;
             }
        }
        /*
             sk_SSL_CIPHER_free(s->session->ciphers);
             s->session->ciphers = prio;
         }
         /*
          * s->session->ciphers should now have a list of ciphers that are on
          * both the client and server. This list is ordered by the order the
    if (s->s2->challenge_length > sizeof s->s2->challenge) {
        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
        return -1;
    }
    memcpy(s->s2->challenge, p, (unsigned int)s->s2->challenge_length);
    return (1);
 mem_err:
    SSLerr(SSL_F_GET_CLIENT_HELLO, ERR_R_MALLOC_FAILURE);
    return (0);
}
",C,"
        /* Generate list of SSLv2 ciphers shared between client and server */
            const SSL_CIPHER *cp = sk_SSL_CIPHER_value(prio, z);
            if ((cp->algorithm_ssl & SSL_SSLV2) == 0 ||
                sk_SSL_CIPHER_find(allow, cp) < 0) {

        /* Make sure we have at least one cipher in common */
        if (sk_SSL_CIPHER_num(s->session->ciphers) == 0) {
            ssl2_return_error(s, SSL2_PE_NO_CIPHER);
            SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_NO_CIPHER_MATCH);
            return -1;
        }
","            if (sk_SSL_CIPHER_find(allow, sk_SSL_CIPHER_value(prio, z)) < 0) {
",3665fa25436f55f9ed401ae92c2f3862fb10d952,"@@ -402,7 +402,7 @@ static int get_client_master_key(SSL *s)
         }
 
         cp = ssl2_get_cipher_by_char(p);
-        if (cp == NULL) {
+        if (cp == NULL || sk_SSL_CIPHER_find(s->session->ciphers, cp) < 0) {
             ssl2_return_error(s, SSL2_PE_NO_CIPHER);
             SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_NO_CIPHER_MATCH);
             return (-1);
@@ -692,8 +692,12 @@ static int get_client_hello(SSL *s)
             prio = cs;
             allow = cl;
         }
+
+        /* Generate list of SSLv2 ciphers shared between client and server */
         for (z = 0; z < sk_SSL_CIPHER_num(prio); z++) {
-            if (sk_SSL_CIPHER_find(allow, sk_SSL_CIPHER_value(prio, z)) < 0) {
+            const SSL_CIPHER *cp = sk_SSL_CIPHER_value(prio, z);
+            if ((cp->algorithm_ssl & SSL_SSLV2) == 0 ||
+                sk_SSL_CIPHER_find(allow, cp) < 0) {
                 (void)sk_SSL_CIPHER_delete(prio, z);
                 z--;
             }
@@ -702,6 +706,13 @@ static int get_client_hello(SSL *s)
             sk_SSL_CIPHER_free(s->session->ciphers);
             s->session->ciphers = prio;
         }
+
+        /* Make sure we have at least one cipher in common */
+        if (sk_SSL_CIPHER_num(s->session->ciphers) == 0) {
+            ssl2_return_error(s, SSL2_PE_NO_CIPHER);
+            SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_NO_CIPHER_MATCH);
+            return -1;
+        }
         /*
          * s->session->ciphers should now have a list of ciphers that are on
          * both the client and server. This list is ordered by the order the",openssl,https://git.openssl.org/?p=openssl.git;a=blob;f=ssl/s2_srvr.c;h=07e9df82820a9e67967ca2d73a60edcca12c0f38;hb=d81a1600588b726c2bdccda7efad3cc7a87d6245,https://git.openssl.org/?p=openssl.git;a=blob;f=ssl/s2_srvr.c;h=5e2e0acc357cfd92c8e998d86aa80262c4fd4eef,1,"static int get_client_hello(SSL *s)
{
    int i, n;
    unsigned long len;
    unsigned char *p;
    STACK_OF(SSL_CIPHER) *cs;   /* a stack of SSL_CIPHERS */
    STACK_OF(SSL_CIPHER) *cl;   /* the ones we want to use */
    STACK_OF(SSL_CIPHER) *prio, *allow;
    int z;

    /*
     * This is a bit of a hack to check for the correct packet type the first
     * time round.
     */
    if (s->state == SSL2_ST_GET_CLIENT_HELLO_A) {
        s->first_packet = 1;
        s->state = SSL2_ST_GET_CLIENT_HELLO_B;
    }

    p = (unsigned char *)s->init_buf->data;
    if (s->state == SSL2_ST_GET_CLIENT_HELLO_B) {
        i = ssl2_read(s, (char *)&(p[s->init_num]), 9 - s->init_num);
        if (i < (9 - s->init_num))
            return (ssl2_part_read(s, SSL_F_GET_CLIENT_HELLO, i));
        s->init_num = 9;

        if (*(p++) != SSL2_MT_CLIENT_HELLO) {
            if (p[-1] != SSL2_MT_ERROR) {
                ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
                SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_READ_WRONG_PACKET_TYPE);
            } else
                SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_PEER_ERROR);
            return (-1);
        }
        n2s(p, i);
        if (i < s->version)
            s->version = i;
        n2s(p, i);
        s->s2->tmp.cipher_spec_length = i;
        n2s(p, i);
        s->s2->tmp.session_id_length = i;
        if ((i < 0) || (i > SSL_MAX_SSL_SESSION_ID_LENGTH)) {
            ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
            SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);
            return -1;
        }
        n2s(p, i);
        s->s2->challenge_length = i;
        if ((i < SSL2_MIN_CHALLENGE_LENGTH) ||
            (i > SSL2_MAX_CHALLENGE_LENGTH)) {
            ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
            SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_INVALID_CHALLENGE_LENGTH);
            return (-1);
        }
        s->state = SSL2_ST_GET_CLIENT_HELLO_C;
    }

    /* SSL2_ST_GET_CLIENT_HELLO_C */
    p = (unsigned char *)s->init_buf->data;
    len =
        9 + (unsigned long)s->s2->tmp.cipher_spec_length +
        (unsigned long)s->s2->challenge_length +
        (unsigned long)s->s2->tmp.session_id_length;
    if (len > SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER) {
        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_MESSAGE_TOO_LONG);
        return -1;
    }
    n = (int)len - s->init_num;
    i = ssl2_read(s, (char *)&(p[s->init_num]), n);
    if (i != n)
        return (ssl2_part_read(s, SSL_F_GET_CLIENT_HELLO, i));
    if (s->msg_callback) {
        /* CLIENT-HELLO */
        s->msg_callback(0, s->version, 0, p, (size_t)len, s,
                        s->msg_callback_arg);
    }
    p += 9;

    /*
     * get session-id before cipher stuff so we can get out session structure
     * if it is cached
     */
    /* session-id */
    if ((s->s2->tmp.session_id_length != 0) &&
        (s->s2->tmp.session_id_length != SSL2_SSL_SESSION_ID_LENGTH)) {
        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_BAD_SSL_SESSION_ID_LENGTH);
        return (-1);
    }

    if (s->s2->tmp.session_id_length == 0) {
        if (!ssl_get_new_session(s, 1)) {
            ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
            return (-1);
        }
    } else {
        i = ssl_get_prev_session(s, &(p[s->s2->tmp.cipher_spec_length]),
                                 s->s2->tmp.session_id_length, NULL);
        if (i == 1) {           /* previous session */
            s->hit = 1;
        } else if (i == -1) {
            ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
            return (-1);
        } else {
            if (s->cert == NULL) {
                ssl2_return_error(s, SSL2_PE_NO_CERTIFICATE);
                SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_NO_CERTIFICATE_SET);
                return (-1);
            }

            if (!ssl_get_new_session(s, 1)) {
                ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
                return (-1);
            }
        }
    }

    if (!s->hit) {
        cs = ssl_bytes_to_cipher_list(s, p, s->s2->tmp.cipher_spec_length,
                                      &s->session->ciphers);
        if (cs == NULL)
            goto mem_err;

        cl = SSL_get_ciphers(s);

        if (s->options & SSL_OP_CIPHER_SERVER_PREFERENCE) {
            prio = sk_SSL_CIPHER_dup(cl);
            if (prio == NULL)
                goto mem_err;
            allow = cs;
        } else {
             prio = cs;
             allow = cl;
         }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        /* Generate list of SSLv2 ciphers shared between client and server */
         for (z = 0; z < sk_SSL_CIPHER_num(prio); z++) {
//flaw_line_below:
            if (sk_SSL_CIPHER_find(allow, sk_SSL_CIPHER_value(prio, z)) < 0) {
//fix_flaw_line_below:
//            const SSL_CIPHER *cp = sk_SSL_CIPHER_value(prio, z);
//fix_flaw_line_below:
//            if ((cp->algorithm_ssl & SSL_SSLV2) == 0 ||
//fix_flaw_line_below:
//                sk_SSL_CIPHER_find(allow, cp) < 0) {
                 (void)sk_SSL_CIPHER_delete(prio, z);
                 z--;
             }
        }
        /*
             sk_SSL_CIPHER_free(s->session->ciphers);
             s->session->ciphers = prio;
         }
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//        /* Make sure we have at least one cipher in common */
//fix_flaw_line_below:
//        if (sk_SSL_CIPHER_num(s->session->ciphers) == 0) {
//fix_flaw_line_below:
//            ssl2_return_error(s, SSL2_PE_NO_CIPHER);
//fix_flaw_line_below:
//            SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_NO_CIPHER_MATCH);
//fix_flaw_line_below:
//            return -1;
//fix_flaw_line_below:
//        }
         /*
          * s->session->ciphers should now have a list of ciphers that are on
          * both the client and server. This list is ordered by the order the
    if (s->s2->challenge_length > sizeof s->s2->challenge) {
        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
        return -1;
    }
    memcpy(s->s2->challenge, p, (unsigned int)s->s2->challenge_length);
    return (1);
 mem_err:
    SSLerr(SSL_F_GET_CLIENT_HELLO, ERR_R_MALLOC_FAILURE);
    return (0);
}
"
758,178494,,Remote,Not required,,CVE-2015-3197,https://www.cvedetails.com/cve/CVE-2015-3197/,CWE-310,Medium,Partial,,,2016-02-14,4.3,"ssl/s2_srvr.c in OpenSSL 1.0.1 before 1.0.1r and 1.0.2 before 1.0.2f does not prevent use of disabled ciphers, which makes it easier for man-in-the-middle attackers to defeat cryptographic protection mechanisms by performing computations on SSLv2 traffic, related to the get_client_master_key and get_client_hello functions.",2017-11-20,,1,https://git.openssl.org/?p=openssl.git;a=commit;h=d81a1600588b726c2bdccda7efad3cc7a87d6245,d81a1600588b726c2bdccda7efad3cc7a87d6245,,1,,,"static int get_client_master_key(SSL *s)
{
    int is_export, i, n, keya;
    unsigned int num_encrypted_key_bytes, key_length;
    unsigned long len;
    unsigned char *p;
    const SSL_CIPHER *cp;
    const EVP_CIPHER *c;
    const EVP_MD *md;
    unsigned char rand_premaster_secret[SSL_MAX_MASTER_KEY_LENGTH];
    unsigned char decrypt_good;
    size_t j;

    p = (unsigned char *)s->init_buf->data;
    if (s->state == SSL2_ST_GET_CLIENT_MASTER_KEY_A) {
        i = ssl2_read(s, (char *)&(p[s->init_num]), 10 - s->init_num);

        if (i < (10 - s->init_num))
            return (ssl2_part_read(s, SSL_F_GET_CLIENT_MASTER_KEY, i));
        s->init_num = 10;

        if (*(p++) != SSL2_MT_CLIENT_MASTER_KEY) {
            if (p[-1] != SSL2_MT_ERROR) {
                ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
                SSLerr(SSL_F_GET_CLIENT_MASTER_KEY,
                       SSL_R_READ_WRONG_PACKET_TYPE);
            } else
                SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_PEER_ERROR);
            return (-1);
         }
 
         cp = ssl2_get_cipher_by_char(p);
        if (cp == NULL || sk_SSL_CIPHER_find(s->session->ciphers, cp) < 0) {
             ssl2_return_error(s, SSL2_PE_NO_CIPHER);
             SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_NO_CIPHER_MATCH);
             return (-1);
        }
        s->session->cipher = cp;

        p += 3;
        n2s(p, i);
        s->s2->tmp.clear = i;
        n2s(p, i);
        s->s2->tmp.enc = i;
        n2s(p, i);
        if (i > SSL_MAX_KEY_ARG_LENGTH) {
            ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
            SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_KEY_ARG_TOO_LONG);
            return -1;
        }
        s->session->key_arg_length = i;
        s->state = SSL2_ST_GET_CLIENT_MASTER_KEY_B;
    }

    /* SSL2_ST_GET_CLIENT_MASTER_KEY_B */
    p = (unsigned char *)s->init_buf->data;
    if (s->init_buf->length < SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER) {
        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, ERR_R_INTERNAL_ERROR);
        return -1;
    }
    keya = s->session->key_arg_length;
    len =
        10 + (unsigned long)s->s2->tmp.clear + (unsigned long)s->s2->tmp.enc +
        (unsigned long)keya;
    if (len > SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER) {
        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_MESSAGE_TOO_LONG);
        return -1;
    }
    n = (int)len - s->init_num;
    i = ssl2_read(s, (char *)&(p[s->init_num]), n);
    if (i != n)
        return (ssl2_part_read(s, SSL_F_GET_CLIENT_MASTER_KEY, i));
    if (s->msg_callback) {
        /* CLIENT-MASTER-KEY */
        s->msg_callback(0, s->version, 0, p, (size_t)len, s,
                        s->msg_callback_arg);
    }
    p += 10;

    memcpy(s->session->key_arg, &(p[s->s2->tmp.clear + s->s2->tmp.enc]),
           (unsigned int)keya);

    if (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL) {
        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_NO_PRIVATEKEY);
        return (-1);
    }

    is_export = SSL_C_IS_EXPORT(s->session->cipher);

    if (!ssl_cipher_get_evp(s->session, &c, &md, NULL, NULL, NULL)) {
        ssl2_return_error(s, SSL2_PE_NO_CIPHER);
        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY,
               SSL_R_PROBLEMS_MAPPING_CIPHER_FUNCTIONS);
        return (0);
    }

    /*
     * The format of the CLIENT-MASTER-KEY message is
     * 1 byte message type
     * 3 bytes cipher
     * 2-byte clear key length (stored in s->s2->tmp.clear)
     * 2-byte encrypted key length (stored in s->s2->tmp.enc)
     * 2-byte key args length (IV etc)
     * clear key
     * encrypted key
     * key args
     *
     * If the cipher is an export cipher, then the encrypted key bytes
     * are a fixed portion of the total key (5 or 8 bytes). The size of
     * this portion is in |num_encrypted_key_bytes|. If the cipher is not an
     * export cipher, then the entire key material is encrypted (i.e., clear
     * key length must be zero).
     */
    key_length = (unsigned int)EVP_CIPHER_key_length(c);
    if (key_length > SSL_MAX_MASTER_KEY_LENGTH) {
        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, ERR_R_INTERNAL_ERROR);
        return -1;
    }

    if (s->session->cipher->algorithm2 & SSL2_CF_8_BYTE_ENC) {
        is_export = 1;
        num_encrypted_key_bytes = 8;
    } else if (is_export) {
        num_encrypted_key_bytes = 5;
    } else {
        num_encrypted_key_bytes = key_length;
    }

    if (s->s2->tmp.clear + num_encrypted_key_bytes != key_length) {
        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY,SSL_R_BAD_LENGTH);
        return -1;
    }
    /*
     * The encrypted blob must decrypt to the encrypted portion of the key.
     * Decryption can't be expanding, so if we don't have enough encrypted
     * bytes to fit the key in the buffer, stop now.
     */
    if (s->s2->tmp.enc < num_encrypted_key_bytes) {
        ssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY,SSL_R_LENGTH_TOO_SHORT);
        return -1;
    }

    /*
     * We must not leak whether a decryption failure occurs because of
     * Bleichenbacher's attack on PKCS #1 v1.5 RSA padding (see RFC 2246,
     * section 7.4.7.1). The code follows that advice of the TLS RFC and
     * generates a random premaster secret for the case that the decrypt
     * fails. See https://tools.ietf.org/html/rfc5246#section-7.4.7.1
     */

    /*
     * should be RAND_bytes, but we cannot work around a failure.
     */
    if (RAND_pseudo_bytes(rand_premaster_secret,
                          (int)num_encrypted_key_bytes) <= 0)
        return 0;

    i = ssl_rsa_private_decrypt(s->cert, s->s2->tmp.enc,
                                &(p[s->s2->tmp.clear]),
                                &(p[s->s2->tmp.clear]),
                                (s->s2->ssl2_rollback) ? RSA_SSLV23_PADDING :
                                RSA_PKCS1_PADDING);
    ERR_clear_error();
    /*
     * If a bad decrypt, continue with protocol but with a random master
     * secret (Bleichenbacher attack)
     */
    decrypt_good = constant_time_eq_int_8(i, (int)num_encrypted_key_bytes);
    for (j = 0; j < num_encrypted_key_bytes; j++) {
        p[s->s2->tmp.clear + j] =
                constant_time_select_8(decrypt_good, p[s->s2->tmp.clear + j],
                                       rand_premaster_secret[j]);
    }

    s->session->master_key_length = (int)key_length;
    memcpy(s->session->master_key, p, key_length);
    OPENSSL_cleanse(p, key_length);

    return 1;
}
","static int get_client_master_key(SSL *s)
{
    int is_export, i, n, keya;
    unsigned int num_encrypted_key_bytes, key_length;
    unsigned long len;
    unsigned char *p;
    const SSL_CIPHER *cp;
    const EVP_CIPHER *c;
    const EVP_MD *md;
    unsigned char rand_premaster_secret[SSL_MAX_MASTER_KEY_LENGTH];
    unsigned char decrypt_good;
    size_t j;

    p = (unsigned char *)s->init_buf->data;
    if (s->state == SSL2_ST_GET_CLIENT_MASTER_KEY_A) {
        i = ssl2_read(s, (char *)&(p[s->init_num]), 10 - s->init_num);

        if (i < (10 - s->init_num))
            return (ssl2_part_read(s, SSL_F_GET_CLIENT_MASTER_KEY, i));
        s->init_num = 10;

        if (*(p++) != SSL2_MT_CLIENT_MASTER_KEY) {
            if (p[-1] != SSL2_MT_ERROR) {
                ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
                SSLerr(SSL_F_GET_CLIENT_MASTER_KEY,
                       SSL_R_READ_WRONG_PACKET_TYPE);
            } else
                SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_PEER_ERROR);
            return (-1);
         }
 
         cp = ssl2_get_cipher_by_char(p);
        if (cp == NULL) {
             ssl2_return_error(s, SSL2_PE_NO_CIPHER);
             SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_NO_CIPHER_MATCH);
             return (-1);
        }
        s->session->cipher = cp;

        p += 3;
        n2s(p, i);
        s->s2->tmp.clear = i;
        n2s(p, i);
        s->s2->tmp.enc = i;
        n2s(p, i);
        if (i > SSL_MAX_KEY_ARG_LENGTH) {
            ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
            SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_KEY_ARG_TOO_LONG);
            return -1;
        }
        s->session->key_arg_length = i;
        s->state = SSL2_ST_GET_CLIENT_MASTER_KEY_B;
    }

    /* SSL2_ST_GET_CLIENT_MASTER_KEY_B */
    p = (unsigned char *)s->init_buf->data;
    if (s->init_buf->length < SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER) {
        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, ERR_R_INTERNAL_ERROR);
        return -1;
    }
    keya = s->session->key_arg_length;
    len =
        10 + (unsigned long)s->s2->tmp.clear + (unsigned long)s->s2->tmp.enc +
        (unsigned long)keya;
    if (len > SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER) {
        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_MESSAGE_TOO_LONG);
        return -1;
    }
    n = (int)len - s->init_num;
    i = ssl2_read(s, (char *)&(p[s->init_num]), n);
    if (i != n)
        return (ssl2_part_read(s, SSL_F_GET_CLIENT_MASTER_KEY, i));
    if (s->msg_callback) {
        /* CLIENT-MASTER-KEY */
        s->msg_callback(0, s->version, 0, p, (size_t)len, s,
                        s->msg_callback_arg);
    }
    p += 10;

    memcpy(s->session->key_arg, &(p[s->s2->tmp.clear + s->s2->tmp.enc]),
           (unsigned int)keya);

    if (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL) {
        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_NO_PRIVATEKEY);
        return (-1);
    }

    is_export = SSL_C_IS_EXPORT(s->session->cipher);

    if (!ssl_cipher_get_evp(s->session, &c, &md, NULL, NULL, NULL)) {
        ssl2_return_error(s, SSL2_PE_NO_CIPHER);
        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY,
               SSL_R_PROBLEMS_MAPPING_CIPHER_FUNCTIONS);
        return (0);
    }

    /*
     * The format of the CLIENT-MASTER-KEY message is
     * 1 byte message type
     * 3 bytes cipher
     * 2-byte clear key length (stored in s->s2->tmp.clear)
     * 2-byte encrypted key length (stored in s->s2->tmp.enc)
     * 2-byte key args length (IV etc)
     * clear key
     * encrypted key
     * key args
     *
     * If the cipher is an export cipher, then the encrypted key bytes
     * are a fixed portion of the total key (5 or 8 bytes). The size of
     * this portion is in |num_encrypted_key_bytes|. If the cipher is not an
     * export cipher, then the entire key material is encrypted (i.e., clear
     * key length must be zero).
     */
    key_length = (unsigned int)EVP_CIPHER_key_length(c);
    if (key_length > SSL_MAX_MASTER_KEY_LENGTH) {
        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, ERR_R_INTERNAL_ERROR);
        return -1;
    }

    if (s->session->cipher->algorithm2 & SSL2_CF_8_BYTE_ENC) {
        is_export = 1;
        num_encrypted_key_bytes = 8;
    } else if (is_export) {
        num_encrypted_key_bytes = 5;
    } else {
        num_encrypted_key_bytes = key_length;
    }

    if (s->s2->tmp.clear + num_encrypted_key_bytes != key_length) {
        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY,SSL_R_BAD_LENGTH);
        return -1;
    }
    /*
     * The encrypted blob must decrypt to the encrypted portion of the key.
     * Decryption can't be expanding, so if we don't have enough encrypted
     * bytes to fit the key in the buffer, stop now.
     */
    if (s->s2->tmp.enc < num_encrypted_key_bytes) {
        ssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY,SSL_R_LENGTH_TOO_SHORT);
        return -1;
    }

    /*
     * We must not leak whether a decryption failure occurs because of
     * Bleichenbacher's attack on PKCS #1 v1.5 RSA padding (see RFC 2246,
     * section 7.4.7.1). The code follows that advice of the TLS RFC and
     * generates a random premaster secret for the case that the decrypt
     * fails. See https://tools.ietf.org/html/rfc5246#section-7.4.7.1
     */

    /*
     * should be RAND_bytes, but we cannot work around a failure.
     */
    if (RAND_pseudo_bytes(rand_premaster_secret,
                          (int)num_encrypted_key_bytes) <= 0)
        return 0;

    i = ssl_rsa_private_decrypt(s->cert, s->s2->tmp.enc,
                                &(p[s->s2->tmp.clear]),
                                &(p[s->s2->tmp.clear]),
                                (s->s2->ssl2_rollback) ? RSA_SSLV23_PADDING :
                                RSA_PKCS1_PADDING);
    ERR_clear_error();
    /*
     * If a bad decrypt, continue with protocol but with a random master
     * secret (Bleichenbacher attack)
     */
    decrypt_good = constant_time_eq_int_8(i, (int)num_encrypted_key_bytes);
    for (j = 0; j < num_encrypted_key_bytes; j++) {
        p[s->s2->tmp.clear + j] =
                constant_time_select_8(decrypt_good, p[s->s2->tmp.clear + j],
                                       rand_premaster_secret[j]);
    }

    s->session->master_key_length = (int)key_length;
    memcpy(s->session->master_key, p, key_length);
    OPENSSL_cleanse(p, key_length);

    return 1;
}
",C,"        if (cp == NULL || sk_SSL_CIPHER_find(s->session->ciphers, cp) < 0) {
","        if (cp == NULL) {
",3665fa25436f55f9ed401ae92c2f3862fb10d952,"@@ -402,7 +402,7 @@ static int get_client_master_key(SSL *s)
         }
 
         cp = ssl2_get_cipher_by_char(p);
-        if (cp == NULL) {
+        if (cp == NULL || sk_SSL_CIPHER_find(s->session->ciphers, cp) < 0) {
             ssl2_return_error(s, SSL2_PE_NO_CIPHER);
             SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_NO_CIPHER_MATCH);
             return (-1);
@@ -692,8 +692,12 @@ static int get_client_hello(SSL *s)
             prio = cs;
             allow = cl;
         }
+
+        /* Generate list of SSLv2 ciphers shared between client and server */
         for (z = 0; z < sk_SSL_CIPHER_num(prio); z++) {
-            if (sk_SSL_CIPHER_find(allow, sk_SSL_CIPHER_value(prio, z)) < 0) {
+            const SSL_CIPHER *cp = sk_SSL_CIPHER_value(prio, z);
+            if ((cp->algorithm_ssl & SSL_SSLV2) == 0 ||
+                sk_SSL_CIPHER_find(allow, cp) < 0) {
                 (void)sk_SSL_CIPHER_delete(prio, z);
                 z--;
             }
@@ -702,6 +706,13 @@ static int get_client_hello(SSL *s)
             sk_SSL_CIPHER_free(s->session->ciphers);
             s->session->ciphers = prio;
         }
+
+        /* Make sure we have at least one cipher in common */
+        if (sk_SSL_CIPHER_num(s->session->ciphers) == 0) {
+            ssl2_return_error(s, SSL2_PE_NO_CIPHER);
+            SSLerr(SSL_F_GET_CLIENT_HELLO, SSL_R_NO_CIPHER_MATCH);
+            return -1;
+        }
         /*
          * s->session->ciphers should now have a list of ciphers that are on
          * both the client and server. This list is ordered by the order the",openssl,https://git.openssl.org/?p=openssl.git;a=blob;f=ssl/s2_srvr.c;h=07e9df82820a9e67967ca2d73a60edcca12c0f38;hb=d81a1600588b726c2bdccda7efad3cc7a87d6245,https://git.openssl.org/?p=openssl.git;a=blob;f=ssl/s2_srvr.c;h=5e2e0acc357cfd92c8e998d86aa80262c4fd4eef,1,"static int get_client_master_key(SSL *s)
{
    int is_export, i, n, keya;
    unsigned int num_encrypted_key_bytes, key_length;
    unsigned long len;
    unsigned char *p;
    const SSL_CIPHER *cp;
    const EVP_CIPHER *c;
    const EVP_MD *md;
    unsigned char rand_premaster_secret[SSL_MAX_MASTER_KEY_LENGTH];
    unsigned char decrypt_good;
    size_t j;

    p = (unsigned char *)s->init_buf->data;
    if (s->state == SSL2_ST_GET_CLIENT_MASTER_KEY_A) {
        i = ssl2_read(s, (char *)&(p[s->init_num]), 10 - s->init_num);

        if (i < (10 - s->init_num))
            return (ssl2_part_read(s, SSL_F_GET_CLIENT_MASTER_KEY, i));
        s->init_num = 10;

        if (*(p++) != SSL2_MT_CLIENT_MASTER_KEY) {
            if (p[-1] != SSL2_MT_ERROR) {
                ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
                SSLerr(SSL_F_GET_CLIENT_MASTER_KEY,
                       SSL_R_READ_WRONG_PACKET_TYPE);
            } else
                SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_PEER_ERROR);
            return (-1);
         }
 
         cp = ssl2_get_cipher_by_char(p);
//flaw_line_below:
        if (cp == NULL) {
//fix_flaw_line_below:
//        if (cp == NULL || sk_SSL_CIPHER_find(s->session->ciphers, cp) < 0) {
             ssl2_return_error(s, SSL2_PE_NO_CIPHER);
             SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_NO_CIPHER_MATCH);
             return (-1);
        }
        s->session->cipher = cp;

        p += 3;
        n2s(p, i);
        s->s2->tmp.clear = i;
        n2s(p, i);
        s->s2->tmp.enc = i;
        n2s(p, i);
        if (i > SSL_MAX_KEY_ARG_LENGTH) {
            ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
            SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_KEY_ARG_TOO_LONG);
            return -1;
        }
        s->session->key_arg_length = i;
        s->state = SSL2_ST_GET_CLIENT_MASTER_KEY_B;
    }

    /* SSL2_ST_GET_CLIENT_MASTER_KEY_B */
    p = (unsigned char *)s->init_buf->data;
    if (s->init_buf->length < SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER) {
        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, ERR_R_INTERNAL_ERROR);
        return -1;
    }
    keya = s->session->key_arg_length;
    len =
        10 + (unsigned long)s->s2->tmp.clear + (unsigned long)s->s2->tmp.enc +
        (unsigned long)keya;
    if (len > SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER) {
        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_MESSAGE_TOO_LONG);
        return -1;
    }
    n = (int)len - s->init_num;
    i = ssl2_read(s, (char *)&(p[s->init_num]), n);
    if (i != n)
        return (ssl2_part_read(s, SSL_F_GET_CLIENT_MASTER_KEY, i));
    if (s->msg_callback) {
        /* CLIENT-MASTER-KEY */
        s->msg_callback(0, s->version, 0, p, (size_t)len, s,
                        s->msg_callback_arg);
    }
    p += 10;

    memcpy(s->session->key_arg, &(p[s->s2->tmp.clear + s->s2->tmp.enc]),
           (unsigned int)keya);

    if (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL) {
        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_NO_PRIVATEKEY);
        return (-1);
    }

    is_export = SSL_C_IS_EXPORT(s->session->cipher);

    if (!ssl_cipher_get_evp(s->session, &c, &md, NULL, NULL, NULL)) {
        ssl2_return_error(s, SSL2_PE_NO_CIPHER);
        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY,
               SSL_R_PROBLEMS_MAPPING_CIPHER_FUNCTIONS);
        return (0);
    }

    /*
     * The format of the CLIENT-MASTER-KEY message is
     * 1 byte message type
     * 3 bytes cipher
     * 2-byte clear key length (stored in s->s2->tmp.clear)
     * 2-byte encrypted key length (stored in s->s2->tmp.enc)
     * 2-byte key args length (IV etc)
     * clear key
     * encrypted key
     * key args
     *
     * If the cipher is an export cipher, then the encrypted key bytes
     * are a fixed portion of the total key (5 or 8 bytes). The size of
     * this portion is in |num_encrypted_key_bytes|. If the cipher is not an
     * export cipher, then the entire key material is encrypted (i.e., clear
     * key length must be zero).
     */
    key_length = (unsigned int)EVP_CIPHER_key_length(c);
    if (key_length > SSL_MAX_MASTER_KEY_LENGTH) {
        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, ERR_R_INTERNAL_ERROR);
        return -1;
    }

    if (s->session->cipher->algorithm2 & SSL2_CF_8_BYTE_ENC) {
        is_export = 1;
        num_encrypted_key_bytes = 8;
    } else if (is_export) {
        num_encrypted_key_bytes = 5;
    } else {
        num_encrypted_key_bytes = key_length;
    }

    if (s->s2->tmp.clear + num_encrypted_key_bytes != key_length) {
        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY,SSL_R_BAD_LENGTH);
        return -1;
    }
    /*
     * The encrypted blob must decrypt to the encrypted portion of the key.
     * Decryption can't be expanding, so if we don't have enough encrypted
     * bytes to fit the key in the buffer, stop now.
     */
    if (s->s2->tmp.enc < num_encrypted_key_bytes) {
        ssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);
        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY,SSL_R_LENGTH_TOO_SHORT);
        return -1;
    }

    /*
     * We must not leak whether a decryption failure occurs because of
     * Bleichenbacher's attack on PKCS #1 v1.5 RSA padding (see RFC 2246,
     * section 7.4.7.1). The code follows that advice of the TLS RFC and
     * generates a random premaster secret for the case that the decrypt
     * fails. See https://tools.ietf.org/html/rfc5246#section-7.4.7.1
     */

    /*
     * should be RAND_bytes, but we cannot work around a failure.
     */
    if (RAND_pseudo_bytes(rand_premaster_secret,
                          (int)num_encrypted_key_bytes) <= 0)
        return 0;

    i = ssl_rsa_private_decrypt(s->cert, s->s2->tmp.enc,
                                &(p[s->s2->tmp.clear]),
                                &(p[s->s2->tmp.clear]),
                                (s->s2->ssl2_rollback) ? RSA_SSLV23_PADDING :
                                RSA_PKCS1_PADDING);
    ERR_clear_error();
    /*
     * If a bad decrypt, continue with protocol but with a random master
     * secret (Bleichenbacher attack)
     */
    decrypt_good = constant_time_eq_int_8(i, (int)num_encrypted_key_bytes);
    for (j = 0; j < num_encrypted_key_bytes; j++) {
        p[s->s2->tmp.clear + j] =
                constant_time_select_8(decrypt_good, p[s->s2->tmp.clear + j],
                                       rand_premaster_secret[j]);
    }

    s->session->master_key_length = (int)key_length;
    memcpy(s->session->master_key, p, key_length);
    OPENSSL_cleanse(p, key_length);

    return 1;
}
"
770,178506,,Remote,Not required,Partial,CVE-2013-6450,https://www.cvedetails.com/cve/CVE-2013-6450/,CWE-310,Medium,,Partial,,2014-01-01,5.8,"The DTLS retransmission implementation in OpenSSL 1.0.0 before 1.0.0l and 1.0.1 before 1.0.1f does not properly maintain data structures for digest and encryption contexts, which might allow man-in-the-middle attackers to trigger the use of a different context and cause a denial of service (application crash) by interfering with packet delivery, related to ssl/d1_both.c and ssl/t1_enc.c.",2018-10-09,DoS,6,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=34628967f1e65dc8f34e000f0f5518e21afbfc7b,34628967f1e65dc8f34e000f0f5518e21afbfc7b,,0,,," dtls1_hm_fragment_free(hm_fragment *frag)
        {

       if (frag->msg_header.is_ccs)
               {
               EVP_CIPHER_CTX_free(frag->msg_header.saved_retransmit_state.enc_write_ctx);
               EVP_MD_CTX_destroy(frag->msg_header.saved_retransmit_state.write_hash);
               }
        if (frag->fragment) OPENSSL_free(frag->fragment);
        if (frag->reassembly) OPENSSL_free(frag->reassembly);
        OPENSSL_free(frag);
	int curr_mtu;
	unsigned int len, frag_off, mac_size, blocksize;

	/* AHA!  Figure out the MTU, and stick to the right size */
	if (s->d1->mtu < dtls1_min_mtu() && !(SSL_get_options(s) & SSL_OP_NO_QUERY_MTU))
		{
		s->d1->mtu = 
			BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_QUERY_MTU, 0, NULL);

		/* I've seen the kernel return bogus numbers when it doesn't know
		 * (initial write), so just make sure we have a reasonable number */
		if (s->d1->mtu < dtls1_min_mtu())
			{
			s->d1->mtu = 0;
			s->d1->mtu = dtls1_guess_mtu(s->d1->mtu);
			BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SET_MTU, 
				s->d1->mtu, NULL);
			}
		}
#if 0 
	mtu = s->d1->mtu;

	fprintf(stderr, ""using MTU = %d\n"", mtu);

	mtu -= (DTLS1_HM_HEADER_LENGTH + DTLS1_RT_HEADER_LENGTH);

	curr_mtu = mtu - BIO_wpending(SSL_get_wbio(s));

	if ( curr_mtu > 0)
		mtu = curr_mtu;
	else if ( ( ret = BIO_flush(SSL_get_wbio(s))) <= 0)
		return ret;

	if ( BIO_wpending(SSL_get_wbio(s)) + s->init_num >= mtu)
		{
		ret = BIO_flush(SSL_get_wbio(s));
		if ( ret <= 0)
			return ret;
		mtu = s->d1->mtu - (DTLS1_HM_HEADER_LENGTH + DTLS1_RT_HEADER_LENGTH);
		}
#endif

	OPENSSL_assert(s->d1->mtu >= dtls1_min_mtu());  /* should have something reasonable now */

	if ( s->init_off == 0  && type == SSL3_RT_HANDSHAKE)
		OPENSSL_assert(s->init_num == 
			(int)s->d1->w_msg_hdr.msg_len + DTLS1_HM_HEADER_LENGTH);

	if (s->write_hash)
		mac_size = EVP_MD_CTX_size(s->write_hash);
	else
		mac_size = 0;

	if (s->enc_write_ctx && 
		(EVP_CIPHER_mode( s->enc_write_ctx->cipher) & EVP_CIPH_CBC_MODE))
		blocksize = 2 * EVP_CIPHER_block_size(s->enc_write_ctx->cipher);
	else
		blocksize = 0;

	frag_off = 0;
	while( s->init_num)
		{
		curr_mtu = s->d1->mtu - BIO_wpending(SSL_get_wbio(s)) - 
			DTLS1_RT_HEADER_LENGTH - mac_size - blocksize;

		if ( curr_mtu <= DTLS1_HM_HEADER_LENGTH)
			{
			/* grr.. we could get an error if MTU picked was wrong */
			ret = BIO_flush(SSL_get_wbio(s));
			if ( ret <= 0)
				return ret;
			curr_mtu = s->d1->mtu - DTLS1_RT_HEADER_LENGTH -
				mac_size - blocksize;
			}

		if ( s->init_num > curr_mtu)
			len = curr_mtu;
		else
			len = s->init_num;


		/* XDTLS: this function is too long.  split out the CCS part */
		if ( type == SSL3_RT_HANDSHAKE)
			{
			if ( s->init_off != 0)
				{
				OPENSSL_assert(s->init_off > DTLS1_HM_HEADER_LENGTH);
				s->init_off -= DTLS1_HM_HEADER_LENGTH;
				s->init_num += DTLS1_HM_HEADER_LENGTH;

				if ( s->init_num > curr_mtu)
					len = curr_mtu;
				else
					len = s->init_num;
				}

			dtls1_fix_message_header(s, frag_off, 
				len - DTLS1_HM_HEADER_LENGTH);

			dtls1_write_message_header(s, (unsigned char *)&s->init_buf->data[s->init_off]);

			OPENSSL_assert(len >= DTLS1_HM_HEADER_LENGTH);
			}

		ret=dtls1_write_bytes(s,type,&s->init_buf->data[s->init_off],
			len);
		if (ret < 0)
			{
			/* might need to update MTU here, but we don't know
			 * which previous packet caused the failure -- so can't
			 * really retransmit anything.  continue as if everything
			 * is fine and wait for an alert to handle the
			 * retransmit 
			 */
			if ( BIO_ctrl(SSL_get_wbio(s),
				BIO_CTRL_DGRAM_MTU_EXCEEDED, 0, NULL) > 0 )
				s->d1->mtu = BIO_ctrl(SSL_get_wbio(s),
					BIO_CTRL_DGRAM_QUERY_MTU, 0, NULL);
			else
				return(-1);
			}
		else
			{

			/* bad if this assert fails, only part of the handshake
			 * message got sent.  but why would this happen? */
			OPENSSL_assert(len == (unsigned int)ret);

			if (type == SSL3_RT_HANDSHAKE && ! s->d1->retransmitting)
				{
				/* should not be done for 'Hello Request's, but in that case
				 * we'll ignore the result anyway */
				unsigned char *p = (unsigned char *)&s->init_buf->data[s->init_off];
				const struct hm_header_st *msg_hdr = &s->d1->w_msg_hdr;
				int xlen;

				if (frag_off == 0 && s->version != DTLS1_BAD_VER)
					{
					/* reconstruct message header is if it
					 * is being sent in single fragment */
					*p++ = msg_hdr->type;
					l2n3(msg_hdr->msg_len,p);
					s2n (msg_hdr->seq,p);
					l2n3(0,p);
					l2n3(msg_hdr->msg_len,p);
					p  -= DTLS1_HM_HEADER_LENGTH;
					xlen = ret;
					}
				else
					{
					p  += DTLS1_HM_HEADER_LENGTH;
					xlen = ret - DTLS1_HM_HEADER_LENGTH;
					}

				ssl3_finish_mac(s, p, xlen);
				}

			if (ret == s->init_num)
				{
				if (s->msg_callback)
					s->msg_callback(1, s->version, type, s->init_buf->data, 
						(size_t)(s->init_off + s->init_num), s, 
						s->msg_callback_arg);

				s->init_off = 0;  /* done writing this message */
				s->init_num = 0;

				return(1);
				}
			s->init_off+=ret;
			s->init_num-=ret;
			frag_off += (ret -= DTLS1_HM_HEADER_LENGTH);
			}
		}
	return(0);
	}
"," dtls1_hm_fragment_free(hm_fragment *frag)
        {
        if (frag->fragment) OPENSSL_free(frag->fragment);
        if (frag->reassembly) OPENSSL_free(frag->reassembly);
        OPENSSL_free(frag);
	int curr_mtu;
	unsigned int len, frag_off, mac_size, blocksize;

	/* AHA!  Figure out the MTU, and stick to the right size */
	if (s->d1->mtu < dtls1_min_mtu() && !(SSL_get_options(s) & SSL_OP_NO_QUERY_MTU))
		{
		s->d1->mtu = 
			BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_QUERY_MTU, 0, NULL);

		/* I've seen the kernel return bogus numbers when it doesn't know
		 * (initial write), so just make sure we have a reasonable number */
		if (s->d1->mtu < dtls1_min_mtu())
			{
			s->d1->mtu = 0;
			s->d1->mtu = dtls1_guess_mtu(s->d1->mtu);
			BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SET_MTU, 
				s->d1->mtu, NULL);
			}
		}
#if 0 
	mtu = s->d1->mtu;

	fprintf(stderr, ""using MTU = %d\n"", mtu);

	mtu -= (DTLS1_HM_HEADER_LENGTH + DTLS1_RT_HEADER_LENGTH);

	curr_mtu = mtu - BIO_wpending(SSL_get_wbio(s));

	if ( curr_mtu > 0)
		mtu = curr_mtu;
	else if ( ( ret = BIO_flush(SSL_get_wbio(s))) <= 0)
		return ret;

	if ( BIO_wpending(SSL_get_wbio(s)) + s->init_num >= mtu)
		{
		ret = BIO_flush(SSL_get_wbio(s));
		if ( ret <= 0)
			return ret;
		mtu = s->d1->mtu - (DTLS1_HM_HEADER_LENGTH + DTLS1_RT_HEADER_LENGTH);
		}
#endif

	OPENSSL_assert(s->d1->mtu >= dtls1_min_mtu());  /* should have something reasonable now */

	if ( s->init_off == 0  && type == SSL3_RT_HANDSHAKE)
		OPENSSL_assert(s->init_num == 
			(int)s->d1->w_msg_hdr.msg_len + DTLS1_HM_HEADER_LENGTH);

	if (s->write_hash)
		mac_size = EVP_MD_CTX_size(s->write_hash);
	else
		mac_size = 0;

	if (s->enc_write_ctx && 
		(EVP_CIPHER_mode( s->enc_write_ctx->cipher) & EVP_CIPH_CBC_MODE))
		blocksize = 2 * EVP_CIPHER_block_size(s->enc_write_ctx->cipher);
	else
		blocksize = 0;

	frag_off = 0;
	while( s->init_num)
		{
		curr_mtu = s->d1->mtu - BIO_wpending(SSL_get_wbio(s)) - 
			DTLS1_RT_HEADER_LENGTH - mac_size - blocksize;

		if ( curr_mtu <= DTLS1_HM_HEADER_LENGTH)
			{
			/* grr.. we could get an error if MTU picked was wrong */
			ret = BIO_flush(SSL_get_wbio(s));
			if ( ret <= 0)
				return ret;
			curr_mtu = s->d1->mtu - DTLS1_RT_HEADER_LENGTH -
				mac_size - blocksize;
			}

		if ( s->init_num > curr_mtu)
			len = curr_mtu;
		else
			len = s->init_num;


		/* XDTLS: this function is too long.  split out the CCS part */
		if ( type == SSL3_RT_HANDSHAKE)
			{
			if ( s->init_off != 0)
				{
				OPENSSL_assert(s->init_off > DTLS1_HM_HEADER_LENGTH);
				s->init_off -= DTLS1_HM_HEADER_LENGTH;
				s->init_num += DTLS1_HM_HEADER_LENGTH;

				if ( s->init_num > curr_mtu)
					len = curr_mtu;
				else
					len = s->init_num;
				}

			dtls1_fix_message_header(s, frag_off, 
				len - DTLS1_HM_HEADER_LENGTH);

			dtls1_write_message_header(s, (unsigned char *)&s->init_buf->data[s->init_off]);

			OPENSSL_assert(len >= DTLS1_HM_HEADER_LENGTH);
			}

		ret=dtls1_write_bytes(s,type,&s->init_buf->data[s->init_off],
			len);
		if (ret < 0)
			{
			/* might need to update MTU here, but we don't know
			 * which previous packet caused the failure -- so can't
			 * really retransmit anything.  continue as if everything
			 * is fine and wait for an alert to handle the
			 * retransmit 
			 */
			if ( BIO_ctrl(SSL_get_wbio(s),
				BIO_CTRL_DGRAM_MTU_EXCEEDED, 0, NULL) > 0 )
				s->d1->mtu = BIO_ctrl(SSL_get_wbio(s),
					BIO_CTRL_DGRAM_QUERY_MTU, 0, NULL);
			else
				return(-1);
			}
		else
			{

			/* bad if this assert fails, only part of the handshake
			 * message got sent.  but why would this happen? */
			OPENSSL_assert(len == (unsigned int)ret);

			if (type == SSL3_RT_HANDSHAKE && ! s->d1->retransmitting)
				{
				/* should not be done for 'Hello Request's, but in that case
				 * we'll ignore the result anyway */
				unsigned char *p = (unsigned char *)&s->init_buf->data[s->init_off];
				const struct hm_header_st *msg_hdr = &s->d1->w_msg_hdr;
				int xlen;

				if (frag_off == 0 && s->version != DTLS1_BAD_VER)
					{
					/* reconstruct message header is if it
					 * is being sent in single fragment */
					*p++ = msg_hdr->type;
					l2n3(msg_hdr->msg_len,p);
					s2n (msg_hdr->seq,p);
					l2n3(0,p);
					l2n3(msg_hdr->msg_len,p);
					p  -= DTLS1_HM_HEADER_LENGTH;
					xlen = ret;
					}
				else
					{
					p  += DTLS1_HM_HEADER_LENGTH;
					xlen = ret - DTLS1_HM_HEADER_LENGTH;
					}

				ssl3_finish_mac(s, p, xlen);
				}

			if (ret == s->init_num)
				{
				if (s->msg_callback)
					s->msg_callback(1, s->version, type, s->init_buf->data, 
						(size_t)(s->init_off + s->init_num), s, 
						s->msg_callback_arg);

				s->init_off = 0;  /* done writing this message */
				s->init_num = 0;

				return(1);
				}
			s->init_off+=ret;
			s->init_num-=ret;
			frag_off += (ret -= DTLS1_HM_HEADER_LENGTH);
			}
		}
	return(0);
	}
",C,"
       if (frag->msg_header.is_ccs)
               {
               EVP_CIPHER_CTX_free(frag->msg_header.saved_retransmit_state.enc_write_ctx);
               EVP_MD_CTX_destroy(frag->msg_header.saved_retransmit_state.write_hash);
               }
",,a6c62f0c25a756c263a80ce52afbae888028e986,"@@ -214,6 +214,12 @@ dtls1_hm_fragment_new(unsigned long frag_len, int reassembly)
 static void
 dtls1_hm_fragment_free(hm_fragment *frag)
        {
+
+       if (frag->msg_header.is_ccs)
+               {
+               EVP_CIPHER_CTX_free(frag->msg_header.saved_retransmit_state.enc_write_ctx);
+               EVP_MD_CTX_destroy(frag->msg_header.saved_retransmit_state.write_hash);
+               }
        if (frag->fragment) OPENSSL_free(frag->fragment);
        if (frag->reassembly) OPENSSL_free(frag->reassembly);
        OPENSSL_free(frag);",openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=ssl/d1_both.c;h=7a5596a6b373aeabbd6d8d674f0e20b1618c5012;hb=34628967f1e65dc8f34e000f0f5518e21afbfc7b,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=ssl/d1_both.c;h=65ec0018ae64baa175f37ece77de8f5883ff516d,1," dtls1_hm_fragment_free(hm_fragment *frag)
        {
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//       if (frag->msg_header.is_ccs)
//fix_flaw_line_below:
//               {
//fix_flaw_line_below:
//               EVP_CIPHER_CTX_free(frag->msg_header.saved_retransmit_state.enc_write_ctx);
//fix_flaw_line_below:
//               EVP_MD_CTX_destroy(frag->msg_header.saved_retransmit_state.write_hash);
//fix_flaw_line_below:
//               }
        if (frag->fragment) OPENSSL_free(frag->fragment);
        if (frag->reassembly) OPENSSL_free(frag->reassembly);
        OPENSSL_free(frag);
	int curr_mtu;
	unsigned int len, frag_off, mac_size, blocksize;

	/* AHA!  Figure out the MTU, and stick to the right size */
	if (s->d1->mtu < dtls1_min_mtu() && !(SSL_get_options(s) & SSL_OP_NO_QUERY_MTU))
		{
		s->d1->mtu = 
			BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_QUERY_MTU, 0, NULL);

		/* I've seen the kernel return bogus numbers when it doesn't know
		 * (initial write), so just make sure we have a reasonable number */
		if (s->d1->mtu < dtls1_min_mtu())
			{
			s->d1->mtu = 0;
			s->d1->mtu = dtls1_guess_mtu(s->d1->mtu);
			BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SET_MTU, 
				s->d1->mtu, NULL);
			}
		}
#if 0 
	mtu = s->d1->mtu;

	fprintf(stderr, ""using MTU = %d\n"", mtu);

	mtu -= (DTLS1_HM_HEADER_LENGTH + DTLS1_RT_HEADER_LENGTH);

	curr_mtu = mtu - BIO_wpending(SSL_get_wbio(s));

	if ( curr_mtu > 0)
		mtu = curr_mtu;
	else if ( ( ret = BIO_flush(SSL_get_wbio(s))) <= 0)
		return ret;

	if ( BIO_wpending(SSL_get_wbio(s)) + s->init_num >= mtu)
		{
		ret = BIO_flush(SSL_get_wbio(s));
		if ( ret <= 0)
			return ret;
		mtu = s->d1->mtu - (DTLS1_HM_HEADER_LENGTH + DTLS1_RT_HEADER_LENGTH);
		}
#endif

	OPENSSL_assert(s->d1->mtu >= dtls1_min_mtu());  /* should have something reasonable now */

	if ( s->init_off == 0  && type == SSL3_RT_HANDSHAKE)
		OPENSSL_assert(s->init_num == 
			(int)s->d1->w_msg_hdr.msg_len + DTLS1_HM_HEADER_LENGTH);

	if (s->write_hash)
		mac_size = EVP_MD_CTX_size(s->write_hash);
	else
		mac_size = 0;

	if (s->enc_write_ctx && 
		(EVP_CIPHER_mode( s->enc_write_ctx->cipher) & EVP_CIPH_CBC_MODE))
		blocksize = 2 * EVP_CIPHER_block_size(s->enc_write_ctx->cipher);
	else
		blocksize = 0;

	frag_off = 0;
	while( s->init_num)
		{
		curr_mtu = s->d1->mtu - BIO_wpending(SSL_get_wbio(s)) - 
			DTLS1_RT_HEADER_LENGTH - mac_size - blocksize;

		if ( curr_mtu <= DTLS1_HM_HEADER_LENGTH)
			{
			/* grr.. we could get an error if MTU picked was wrong */
			ret = BIO_flush(SSL_get_wbio(s));
			if ( ret <= 0)
				return ret;
			curr_mtu = s->d1->mtu - DTLS1_RT_HEADER_LENGTH -
				mac_size - blocksize;
			}

		if ( s->init_num > curr_mtu)
			len = curr_mtu;
		else
			len = s->init_num;


		/* XDTLS: this function is too long.  split out the CCS part */
		if ( type == SSL3_RT_HANDSHAKE)
			{
			if ( s->init_off != 0)
				{
				OPENSSL_assert(s->init_off > DTLS1_HM_HEADER_LENGTH);
				s->init_off -= DTLS1_HM_HEADER_LENGTH;
				s->init_num += DTLS1_HM_HEADER_LENGTH;

				if ( s->init_num > curr_mtu)
					len = curr_mtu;
				else
					len = s->init_num;
				}

			dtls1_fix_message_header(s, frag_off, 
				len - DTLS1_HM_HEADER_LENGTH);

			dtls1_write_message_header(s, (unsigned char *)&s->init_buf->data[s->init_off]);

			OPENSSL_assert(len >= DTLS1_HM_HEADER_LENGTH);
			}

		ret=dtls1_write_bytes(s,type,&s->init_buf->data[s->init_off],
			len);
		if (ret < 0)
			{
			/* might need to update MTU here, but we don't know
			 * which previous packet caused the failure -- so can't
			 * really retransmit anything.  continue as if everything
			 * is fine and wait for an alert to handle the
			 * retransmit 
			 */
			if ( BIO_ctrl(SSL_get_wbio(s),
				BIO_CTRL_DGRAM_MTU_EXCEEDED, 0, NULL) > 0 )
				s->d1->mtu = BIO_ctrl(SSL_get_wbio(s),
					BIO_CTRL_DGRAM_QUERY_MTU, 0, NULL);
			else
				return(-1);
			}
		else
			{

			/* bad if this assert fails, only part of the handshake
			 * message got sent.  but why would this happen? */
			OPENSSL_assert(len == (unsigned int)ret);

			if (type == SSL3_RT_HANDSHAKE && ! s->d1->retransmitting)
				{
				/* should not be done for 'Hello Request's, but in that case
				 * we'll ignore the result anyway */
				unsigned char *p = (unsigned char *)&s->init_buf->data[s->init_off];
				const struct hm_header_st *msg_hdr = &s->d1->w_msg_hdr;
				int xlen;

				if (frag_off == 0 && s->version != DTLS1_BAD_VER)
					{
					/* reconstruct message header is if it
					 * is being sent in single fragment */
					*p++ = msg_hdr->type;
					l2n3(msg_hdr->msg_len,p);
					s2n (msg_hdr->seq,p);
					l2n3(0,p);
					l2n3(msg_hdr->msg_len,p);
					p  -= DTLS1_HM_HEADER_LENGTH;
					xlen = ret;
					}
				else
					{
					p  += DTLS1_HM_HEADER_LENGTH;
					xlen = ret - DTLS1_HM_HEADER_LENGTH;
					}

				ssl3_finish_mac(s, p, xlen);
				}

			if (ret == s->init_num)
				{
				if (s->msg_callback)
					s->msg_callback(1, s->version, type, s->init_buf->data, 
						(size_t)(s->init_off + s->init_num), s, 
						s->msg_callback_arg);

				s->init_off = 0;  /* done writing this message */
				s->init_num = 0;

				return(1);
				}
			s->init_off+=ret;
			s->init_num-=ret;
			frag_off += (ret -= DTLS1_HM_HEADER_LENGTH);
			}
		}
	return(0);
	}
"
771,178507,,Remote,Not required,Partial,CVE-2013-6450,https://www.cvedetails.com/cve/CVE-2013-6450/,CWE-310,Medium,,Partial,,2014-01-01,5.8,"The DTLS retransmission implementation in OpenSSL 1.0.0 before 1.0.0l and 1.0.1 before 1.0.1f does not properly maintain data structures for digest and encryption contexts, which might allow man-in-the-middle attackers to trigger the use of a different context and cause a denial of service (application crash) by interfering with packet delivery, related to ssl/d1_both.c and ssl/t1_enc.c.",2018-10-09,DoS,11,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=34628967f1e65dc8f34e000f0f5518e21afbfc7b,34628967f1e65dc8f34e000f0f5518e21afbfc7b,,6,,,"int tls1_change_cipher_state(SSL *s, int which)
	{
	static const unsigned char empty[]="""";
	unsigned char *p,*mac_secret;
	unsigned char *exp_label;
	unsigned char tmp1[EVP_MAX_KEY_LENGTH];
	unsigned char tmp2[EVP_MAX_KEY_LENGTH];
	unsigned char iv1[EVP_MAX_IV_LENGTH*2];
	unsigned char iv2[EVP_MAX_IV_LENGTH*2];
	unsigned char *ms,*key,*iv;
	int client_write;
	EVP_CIPHER_CTX *dd;
	const EVP_CIPHER *c;
#ifndef OPENSSL_NO_COMP
	const SSL_COMP *comp;
#endif
	const EVP_MD *m;
	int mac_type;
	int *mac_secret_size;
	EVP_MD_CTX *mac_ctx;
	EVP_PKEY *mac_key;
	int is_export,n,i,j,k,exp_label_len,cl;
	int reuse_dd = 0;

	is_export=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);
	c=s->s3->tmp.new_sym_enc;
	m=s->s3->tmp.new_hash;
	mac_type = s->s3->tmp.new_mac_pkey_type;
#ifndef OPENSSL_NO_COMP
	comp=s->s3->tmp.new_compression;
#endif

#ifdef KSSL_DEBUG
	printf(""tls1_change_cipher_state(which= %d) w/\n"", which);
	printf(""\talg= %ld/%ld, comp= %p\n"",
	       s->s3->tmp.new_cipher->algorithm_mkey,
	       s->s3->tmp.new_cipher->algorithm_auth,
	       comp);
	printf(""\tevp_cipher == %p ==? &d_cbc_ede_cipher3\n"", c);
	printf(""\tevp_cipher: nid, blksz= %d, %d, keylen=%d, ivlen=%d\n"",
                c->nid,c->block_size,c->key_len,c->iv_len);
	printf(""\tkey_block: len= %d, data= "", s->s3->tmp.key_block_length);
	{
        int i;
        for (i=0; i<s->s3->tmp.key_block_length; i++)
		printf(""%02x"", s->s3->tmp.key_block[i]);  printf(""\n"");
        }
#endif	/* KSSL_DEBUG */

	if (which & SSL3_CC_READ)
		{
		if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)
			s->mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM;
		else
			s->mac_flags &= ~SSL_MAC_FLAG_READ_MAC_STREAM;

		if (s->enc_read_ctx != NULL)
			reuse_dd = 1;
		else if ((s->enc_read_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
			goto err;
		else
			/* make sure it's intialized in case we exit later with an error */
			EVP_CIPHER_CTX_init(s->enc_read_ctx);
		dd= s->enc_read_ctx;
		mac_ctx=ssl_replace_hash(&s->read_hash,NULL);
#ifndef OPENSSL_NO_COMP
		if (s->expand != NULL)
			{
			COMP_CTX_free(s->expand);
			s->expand=NULL;
			}
		if (comp != NULL)
			{
			s->expand=COMP_CTX_new(comp->method);
			if (s->expand == NULL)
				{
				SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);
				goto err2;
				}
			if (s->s3->rrec.comp == NULL)
				s->s3->rrec.comp=(unsigned char *)
					OPENSSL_malloc(SSL3_RT_MAX_ENCRYPTED_LENGTH);
			if (s->s3->rrec.comp == NULL)
				goto err;
			}
#endif
		/* this is done by dtls1_reset_seq_numbers for DTLS1_VERSION */
 		if (s->version != DTLS1_VERSION)
			memset(&(s->s3->read_sequence[0]),0,8);
		mac_secret= &(s->s3->read_mac_secret[0]);
		mac_secret_size=&(s->s3->read_mac_secret_size);
		}
	else
		{
		if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)
                        s->mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM;
                        else
                        s->mac_flags &= ~SSL_MAC_FLAG_WRITE_MAC_STREAM;
               if (s->enc_write_ctx != NULL && !SSL_IS_DTLS(s))
                        reuse_dd = 1;
               else if ((s->enc_write_ctx=EVP_CIPHER_CTX_new()) == NULL)
                        goto err;
                dd= s->enc_write_ctx;
               if (SSL_IS_DTLS(s))
                       {
                       mac_ctx = EVP_MD_CTX_create();
                       if (!mac_ctx)
                               goto err;
                       s->write_hash = mac_ctx;
                       }
               else
                       mac_ctx = ssl_replace_hash(&s->write_hash,NULL);
 #ifndef OPENSSL_NO_COMP
                if (s->compress != NULL)
                        {
			s->compress=COMP_CTX_new(comp->method);
			if (s->compress == NULL)
				{
				SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);
				goto err2;
				}
			}
#endif
		/* this is done by dtls1_reset_seq_numbers for DTLS1_VERSION */
 		if (s->version != DTLS1_VERSION)
			memset(&(s->s3->write_sequence[0]),0,8);
		mac_secret= &(s->s3->write_mac_secret[0]);
		mac_secret_size = &(s->s3->write_mac_secret_size);
		}

	if (reuse_dd)
		EVP_CIPHER_CTX_cleanup(dd);

	p=s->s3->tmp.key_block;
	i=*mac_secret_size=s->s3->tmp.new_mac_secret_size;

	cl=EVP_CIPHER_key_length(c);
	j=is_export ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ?
	               cl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;
	/* Was j=(exp)?5:EVP_CIPHER_key_length(c); */
	/* If GCM mode only part of IV comes from PRF */
	if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)
		k = EVP_GCM_TLS_FIXED_IV_LEN;
	else
		k=EVP_CIPHER_iv_length(c);
	if (	(which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||
		(which == SSL3_CHANGE_CIPHER_SERVER_READ))
		{
		ms=  &(p[ 0]); n=i+i;
		key= &(p[ n]); n+=j+j;
		iv=  &(p[ n]); n+=k+k;
		exp_label=(unsigned char *)TLS_MD_CLIENT_WRITE_KEY_CONST;
		exp_label_len=TLS_MD_CLIENT_WRITE_KEY_CONST_SIZE;
		client_write=1;
		}
	else
		{
		n=i;
		ms=  &(p[ n]); n+=i+j;
		key= &(p[ n]); n+=j+k;
		iv=  &(p[ n]); n+=k;
		exp_label=(unsigned char *)TLS_MD_SERVER_WRITE_KEY_CONST;
		exp_label_len=TLS_MD_SERVER_WRITE_KEY_CONST_SIZE;
		client_write=0;
		}

	if (n > s->s3->tmp.key_block_length)
		{
		SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_INTERNAL_ERROR);
		goto err2;
		}

	memcpy(mac_secret,ms,i);

	if (!(EVP_CIPHER_flags(c)&EVP_CIPH_FLAG_AEAD_CIPHER))
		{
		mac_key = EVP_PKEY_new_mac_key(mac_type, NULL,
				mac_secret,*mac_secret_size);
		EVP_DigestSignInit(mac_ctx,NULL,m,NULL,mac_key);
		EVP_PKEY_free(mac_key);
		}
#ifdef TLS_DEBUG
printf(""which = %04X\nmac key="",which);
{ int z; for (z=0; z<i; z++) printf(""%02X%c"",ms[z],((z+1)%16)?' ':'\n'); }
#endif
	if (is_export)
		{
		/* In here I set both the read and write key/iv to the
		 * same value since only the correct one will be used :-).
		 */
		if (!tls1_PRF(ssl_get_algorithm2(s),
				exp_label,exp_label_len,
				s->s3->client_random,SSL3_RANDOM_SIZE,
				s->s3->server_random,SSL3_RANDOM_SIZE,
				NULL,0,NULL,0,
				key,j,tmp1,tmp2,EVP_CIPHER_key_length(c)))
			goto err2;
		key=tmp1;

		if (k > 0)
			{
			if (!tls1_PRF(ssl_get_algorithm2(s),
					TLS_MD_IV_BLOCK_CONST,TLS_MD_IV_BLOCK_CONST_SIZE,
					s->s3->client_random,SSL3_RANDOM_SIZE,
					s->s3->server_random,SSL3_RANDOM_SIZE,
					NULL,0,NULL,0,
					empty,0,iv1,iv2,k*2))
				goto err2;
			if (client_write)
				iv=iv1;
			else
				iv= &(iv1[k]);
			}
		}

	s->session->key_arg_length=0;
#ifdef KSSL_DEBUG
	{
        int i;
	printf(""EVP_CipherInit_ex(dd,c,key=,iv=,which)\n"");
	printf(""\tkey= ""); for (i=0; i<c->key_len; i++) printf(""%02x"", key[i]);
	printf(""\n"");
	printf(""\t iv= ""); for (i=0; i<c->iv_len; i++) printf(""%02x"", iv[i]);
	printf(""\n"");
	}
#endif	/* KSSL_DEBUG */

	if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)
		{
		EVP_CipherInit_ex(dd,c,NULL,key,NULL,(which & SSL3_CC_WRITE));
		EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_GCM_SET_IV_FIXED, k, iv);
		}
	else	
		EVP_CipherInit_ex(dd,c,NULL,key,iv,(which & SSL3_CC_WRITE));

	/* Needed for ""composite"" AEADs, such as RC4-HMAC-MD5 */
	if ((EVP_CIPHER_flags(c)&EVP_CIPH_FLAG_AEAD_CIPHER) && *mac_secret_size)
		EVP_CIPHER_CTX_ctrl(dd,EVP_CTRL_AEAD_SET_MAC_KEY,
				*mac_secret_size,mac_secret);

#ifdef TLS_DEBUG
printf(""which = %04X\nkey="",which);
{ int z; for (z=0; z<EVP_CIPHER_key_length(c); z++) printf(""%02X%c"",key[z],((z+1)%16)?' ':'\n'); }
printf(""\niv="");
{ int z; for (z=0; z<k; z++) printf(""%02X%c"",iv[z],((z+1)%16)?' ':'\n'); }
printf(""\n"");
#endif

	OPENSSL_cleanse(tmp1,sizeof(tmp1));
	OPENSSL_cleanse(tmp2,sizeof(tmp1));
	OPENSSL_cleanse(iv1,sizeof(iv1));
	OPENSSL_cleanse(iv2,sizeof(iv2));
	return(1);
err:
	SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_MALLOC_FAILURE);
err2:
	return(0);
	}
","int tls1_change_cipher_state(SSL *s, int which)
	{
	static const unsigned char empty[]="""";
	unsigned char *p,*mac_secret;
	unsigned char *exp_label;
	unsigned char tmp1[EVP_MAX_KEY_LENGTH];
	unsigned char tmp2[EVP_MAX_KEY_LENGTH];
	unsigned char iv1[EVP_MAX_IV_LENGTH*2];
	unsigned char iv2[EVP_MAX_IV_LENGTH*2];
	unsigned char *ms,*key,*iv;
	int client_write;
	EVP_CIPHER_CTX *dd;
	const EVP_CIPHER *c;
#ifndef OPENSSL_NO_COMP
	const SSL_COMP *comp;
#endif
	const EVP_MD *m;
	int mac_type;
	int *mac_secret_size;
	EVP_MD_CTX *mac_ctx;
	EVP_PKEY *mac_key;
	int is_export,n,i,j,k,exp_label_len,cl;
	int reuse_dd = 0;

	is_export=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);
	c=s->s3->tmp.new_sym_enc;
	m=s->s3->tmp.new_hash;
	mac_type = s->s3->tmp.new_mac_pkey_type;
#ifndef OPENSSL_NO_COMP
	comp=s->s3->tmp.new_compression;
#endif

#ifdef KSSL_DEBUG
	printf(""tls1_change_cipher_state(which= %d) w/\n"", which);
	printf(""\talg= %ld/%ld, comp= %p\n"",
	       s->s3->tmp.new_cipher->algorithm_mkey,
	       s->s3->tmp.new_cipher->algorithm_auth,
	       comp);
	printf(""\tevp_cipher == %p ==? &d_cbc_ede_cipher3\n"", c);
	printf(""\tevp_cipher: nid, blksz= %d, %d, keylen=%d, ivlen=%d\n"",
                c->nid,c->block_size,c->key_len,c->iv_len);
	printf(""\tkey_block: len= %d, data= "", s->s3->tmp.key_block_length);
	{
        int i;
        for (i=0; i<s->s3->tmp.key_block_length; i++)
		printf(""%02x"", s->s3->tmp.key_block[i]);  printf(""\n"");
        }
#endif	/* KSSL_DEBUG */

	if (which & SSL3_CC_READ)
		{
		if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)
			s->mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM;
		else
			s->mac_flags &= ~SSL_MAC_FLAG_READ_MAC_STREAM;

		if (s->enc_read_ctx != NULL)
			reuse_dd = 1;
		else if ((s->enc_read_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
			goto err;
		else
			/* make sure it's intialized in case we exit later with an error */
			EVP_CIPHER_CTX_init(s->enc_read_ctx);
		dd= s->enc_read_ctx;
		mac_ctx=ssl_replace_hash(&s->read_hash,NULL);
#ifndef OPENSSL_NO_COMP
		if (s->expand != NULL)
			{
			COMP_CTX_free(s->expand);
			s->expand=NULL;
			}
		if (comp != NULL)
			{
			s->expand=COMP_CTX_new(comp->method);
			if (s->expand == NULL)
				{
				SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);
				goto err2;
				}
			if (s->s3->rrec.comp == NULL)
				s->s3->rrec.comp=(unsigned char *)
					OPENSSL_malloc(SSL3_RT_MAX_ENCRYPTED_LENGTH);
			if (s->s3->rrec.comp == NULL)
				goto err;
			}
#endif
		/* this is done by dtls1_reset_seq_numbers for DTLS1_VERSION */
 		if (s->version != DTLS1_VERSION)
			memset(&(s->s3->read_sequence[0]),0,8);
		mac_secret= &(s->s3->read_mac_secret[0]);
		mac_secret_size=&(s->s3->read_mac_secret_size);
		}
	else
		{
		if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)
                        s->mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM;
                        else
                        s->mac_flags &= ~SSL_MAC_FLAG_WRITE_MAC_STREAM;
               if (s->enc_write_ctx != NULL)
                        reuse_dd = 1;
               else if ((s->enc_write_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
                        goto err;
               else
                       /* make sure it's intialized in case we exit later with an error */
                       EVP_CIPHER_CTX_init(s->enc_write_ctx);
                dd= s->enc_write_ctx;
               mac_ctx = ssl_replace_hash(&s->write_hash,NULL);
 #ifndef OPENSSL_NO_COMP
                if (s->compress != NULL)
                        {
			s->compress=COMP_CTX_new(comp->method);
			if (s->compress == NULL)
				{
				SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);
				goto err2;
				}
			}
#endif
		/* this is done by dtls1_reset_seq_numbers for DTLS1_VERSION */
 		if (s->version != DTLS1_VERSION)
			memset(&(s->s3->write_sequence[0]),0,8);
		mac_secret= &(s->s3->write_mac_secret[0]);
		mac_secret_size = &(s->s3->write_mac_secret_size);
		}

	if (reuse_dd)
		EVP_CIPHER_CTX_cleanup(dd);

	p=s->s3->tmp.key_block;
	i=*mac_secret_size=s->s3->tmp.new_mac_secret_size;

	cl=EVP_CIPHER_key_length(c);
	j=is_export ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ?
	               cl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;
	/* Was j=(exp)?5:EVP_CIPHER_key_length(c); */
	/* If GCM mode only part of IV comes from PRF */
	if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)
		k = EVP_GCM_TLS_FIXED_IV_LEN;
	else
		k=EVP_CIPHER_iv_length(c);
	if (	(which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||
		(which == SSL3_CHANGE_CIPHER_SERVER_READ))
		{
		ms=  &(p[ 0]); n=i+i;
		key= &(p[ n]); n+=j+j;
		iv=  &(p[ n]); n+=k+k;
		exp_label=(unsigned char *)TLS_MD_CLIENT_WRITE_KEY_CONST;
		exp_label_len=TLS_MD_CLIENT_WRITE_KEY_CONST_SIZE;
		client_write=1;
		}
	else
		{
		n=i;
		ms=  &(p[ n]); n+=i+j;
		key= &(p[ n]); n+=j+k;
		iv=  &(p[ n]); n+=k;
		exp_label=(unsigned char *)TLS_MD_SERVER_WRITE_KEY_CONST;
		exp_label_len=TLS_MD_SERVER_WRITE_KEY_CONST_SIZE;
		client_write=0;
		}

	if (n > s->s3->tmp.key_block_length)
		{
		SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_INTERNAL_ERROR);
		goto err2;
		}

	memcpy(mac_secret,ms,i);

	if (!(EVP_CIPHER_flags(c)&EVP_CIPH_FLAG_AEAD_CIPHER))
		{
		mac_key = EVP_PKEY_new_mac_key(mac_type, NULL,
				mac_secret,*mac_secret_size);
		EVP_DigestSignInit(mac_ctx,NULL,m,NULL,mac_key);
		EVP_PKEY_free(mac_key);
		}
#ifdef TLS_DEBUG
printf(""which = %04X\nmac key="",which);
{ int z; for (z=0; z<i; z++) printf(""%02X%c"",ms[z],((z+1)%16)?' ':'\n'); }
#endif
	if (is_export)
		{
		/* In here I set both the read and write key/iv to the
		 * same value since only the correct one will be used :-).
		 */
		if (!tls1_PRF(ssl_get_algorithm2(s),
				exp_label,exp_label_len,
				s->s3->client_random,SSL3_RANDOM_SIZE,
				s->s3->server_random,SSL3_RANDOM_SIZE,
				NULL,0,NULL,0,
				key,j,tmp1,tmp2,EVP_CIPHER_key_length(c)))
			goto err2;
		key=tmp1;

		if (k > 0)
			{
			if (!tls1_PRF(ssl_get_algorithm2(s),
					TLS_MD_IV_BLOCK_CONST,TLS_MD_IV_BLOCK_CONST_SIZE,
					s->s3->client_random,SSL3_RANDOM_SIZE,
					s->s3->server_random,SSL3_RANDOM_SIZE,
					NULL,0,NULL,0,
					empty,0,iv1,iv2,k*2))
				goto err2;
			if (client_write)
				iv=iv1;
			else
				iv= &(iv1[k]);
			}
		}

	s->session->key_arg_length=0;
#ifdef KSSL_DEBUG
	{
        int i;
	printf(""EVP_CipherInit_ex(dd,c,key=,iv=,which)\n"");
	printf(""\tkey= ""); for (i=0; i<c->key_len; i++) printf(""%02x"", key[i]);
	printf(""\n"");
	printf(""\t iv= ""); for (i=0; i<c->iv_len; i++) printf(""%02x"", iv[i]);
	printf(""\n"");
	}
#endif	/* KSSL_DEBUG */

	if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)
		{
		EVP_CipherInit_ex(dd,c,NULL,key,NULL,(which & SSL3_CC_WRITE));
		EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_GCM_SET_IV_FIXED, k, iv);
		}
	else	
		EVP_CipherInit_ex(dd,c,NULL,key,iv,(which & SSL3_CC_WRITE));

	/* Needed for ""composite"" AEADs, such as RC4-HMAC-MD5 */
	if ((EVP_CIPHER_flags(c)&EVP_CIPH_FLAG_AEAD_CIPHER) && *mac_secret_size)
		EVP_CIPHER_CTX_ctrl(dd,EVP_CTRL_AEAD_SET_MAC_KEY,
				*mac_secret_size,mac_secret);

#ifdef TLS_DEBUG
printf(""which = %04X\nkey="",which);
{ int z; for (z=0; z<EVP_CIPHER_key_length(c); z++) printf(""%02X%c"",key[z],((z+1)%16)?' ':'\n'); }
printf(""\niv="");
{ int z; for (z=0; z<k; z++) printf(""%02X%c"",iv[z],((z+1)%16)?' ':'\n'); }
printf(""\n"");
#endif

	OPENSSL_cleanse(tmp1,sizeof(tmp1));
	OPENSSL_cleanse(tmp2,sizeof(tmp1));
	OPENSSL_cleanse(iv1,sizeof(iv1));
	OPENSSL_cleanse(iv2,sizeof(iv2));
	return(1);
err:
	SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_MALLOC_FAILURE);
err2:
	return(0);
	}
",C,"               if (s->enc_write_ctx != NULL && !SSL_IS_DTLS(s))
               else if ((s->enc_write_ctx=EVP_CIPHER_CTX_new()) == NULL)
               if (SSL_IS_DTLS(s))
                       {
                       mac_ctx = EVP_MD_CTX_create();
                       if (!mac_ctx)
                               goto err;
                       s->write_hash = mac_ctx;
                       }
               else
                       mac_ctx = ssl_replace_hash(&s->write_hash,NULL);
","               if (s->enc_write_ctx != NULL)
               else if ((s->enc_write_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
               else
                       /* make sure it's intialized in case we exit later with an error */
                       EVP_CIPHER_CTX_init(s->enc_write_ctx);
               mac_ctx = ssl_replace_hash(&s->write_hash,NULL);
",a6c62f0c25a756c263a80ce52afbae888028e986,"@@ -414,15 +414,20 @@ int tls1_change_cipher_state(SSL *s, int which)
                        s->mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM;
                        else
                        s->mac_flags &= ~SSL_MAC_FLAG_WRITE_MAC_STREAM;
-               if (s->enc_write_ctx != NULL)
+               if (s->enc_write_ctx != NULL && !SSL_IS_DTLS(s))
                        reuse_dd = 1;
-               else if ((s->enc_write_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
+               else if ((s->enc_write_ctx=EVP_CIPHER_CTX_new()) == NULL)
                        goto err;
-               else
-                       /* make sure it's intialized in case we exit later with an error */
-                       EVP_CIPHER_CTX_init(s->enc_write_ctx);
                dd= s->enc_write_ctx;
-               mac_ctx = ssl_replace_hash(&s->write_hash,NULL);
+               if (SSL_IS_DTLS(s))
+                       {
+                       mac_ctx = EVP_MD_CTX_create();
+                       if (!mac_ctx)
+                               goto err;
+                       s->write_hash = mac_ctx;
+                       }
+               else
+                       mac_ctx = ssl_replace_hash(&s->write_hash,NULL);
 #ifndef OPENSSL_NO_COMP
                if (s->compress != NULL)
                        {",openssl,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=ssl/t1_enc.c;h=56db83430630b0dc2e67e302bc5d484046979de2;hb=34628967f1e65dc8f34e000f0f5518e21afbfc7b,https://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=ssl/t1_enc.c;h=72015f5aad67c56869ad0484df19eff628eca653,1,"int tls1_change_cipher_state(SSL *s, int which)
	{
	static const unsigned char empty[]="""";
	unsigned char *p,*mac_secret;
	unsigned char *exp_label;
	unsigned char tmp1[EVP_MAX_KEY_LENGTH];
	unsigned char tmp2[EVP_MAX_KEY_LENGTH];
	unsigned char iv1[EVP_MAX_IV_LENGTH*2];
	unsigned char iv2[EVP_MAX_IV_LENGTH*2];
	unsigned char *ms,*key,*iv;
	int client_write;
	EVP_CIPHER_CTX *dd;
	const EVP_CIPHER *c;
#ifndef OPENSSL_NO_COMP
	const SSL_COMP *comp;
#endif
	const EVP_MD *m;
	int mac_type;
	int *mac_secret_size;
	EVP_MD_CTX *mac_ctx;
	EVP_PKEY *mac_key;
	int is_export,n,i,j,k,exp_label_len,cl;
	int reuse_dd = 0;

	is_export=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);
	c=s->s3->tmp.new_sym_enc;
	m=s->s3->tmp.new_hash;
	mac_type = s->s3->tmp.new_mac_pkey_type;
#ifndef OPENSSL_NO_COMP
	comp=s->s3->tmp.new_compression;
#endif

#ifdef KSSL_DEBUG
	printf(""tls1_change_cipher_state(which= %d) w/\n"", which);
	printf(""\talg= %ld/%ld, comp= %p\n"",
	       s->s3->tmp.new_cipher->algorithm_mkey,
	       s->s3->tmp.new_cipher->algorithm_auth,
	       comp);
	printf(""\tevp_cipher == %p ==? &d_cbc_ede_cipher3\n"", c);
	printf(""\tevp_cipher: nid, blksz= %d, %d, keylen=%d, ivlen=%d\n"",
                c->nid,c->block_size,c->key_len,c->iv_len);
	printf(""\tkey_block: len= %d, data= "", s->s3->tmp.key_block_length);
	{
        int i;
        for (i=0; i<s->s3->tmp.key_block_length; i++)
		printf(""%02x"", s->s3->tmp.key_block[i]);  printf(""\n"");
        }
#endif	/* KSSL_DEBUG */

	if (which & SSL3_CC_READ)
		{
		if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)
			s->mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM;
		else
			s->mac_flags &= ~SSL_MAC_FLAG_READ_MAC_STREAM;

		if (s->enc_read_ctx != NULL)
			reuse_dd = 1;
		else if ((s->enc_read_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
			goto err;
		else
			/* make sure it's intialized in case we exit later with an error */
			EVP_CIPHER_CTX_init(s->enc_read_ctx);
		dd= s->enc_read_ctx;
		mac_ctx=ssl_replace_hash(&s->read_hash,NULL);
#ifndef OPENSSL_NO_COMP
		if (s->expand != NULL)
			{
			COMP_CTX_free(s->expand);
			s->expand=NULL;
			}
		if (comp != NULL)
			{
			s->expand=COMP_CTX_new(comp->method);
			if (s->expand == NULL)
				{
				SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);
				goto err2;
				}
			if (s->s3->rrec.comp == NULL)
				s->s3->rrec.comp=(unsigned char *)
					OPENSSL_malloc(SSL3_RT_MAX_ENCRYPTED_LENGTH);
			if (s->s3->rrec.comp == NULL)
				goto err;
			}
#endif
		/* this is done by dtls1_reset_seq_numbers for DTLS1_VERSION */
 		if (s->version != DTLS1_VERSION)
			memset(&(s->s3->read_sequence[0]),0,8);
		mac_secret= &(s->s3->read_mac_secret[0]);
		mac_secret_size=&(s->s3->read_mac_secret_size);
		}
	else
		{
		if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)
                        s->mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM;
                        else
                        s->mac_flags &= ~SSL_MAC_FLAG_WRITE_MAC_STREAM;
//flaw_line_below:
               if (s->enc_write_ctx != NULL)
//fix_flaw_line_below:
//               if (s->enc_write_ctx != NULL && !SSL_IS_DTLS(s))
                        reuse_dd = 1;
//flaw_line_below:
               else if ((s->enc_write_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
//fix_flaw_line_below:
//               else if ((s->enc_write_ctx=EVP_CIPHER_CTX_new()) == NULL)
                        goto err;
//flaw_line_below:
               else
//flaw_line_below:
                       /* make sure it's intialized in case we exit later with an error */
//flaw_line_below:
                       EVP_CIPHER_CTX_init(s->enc_write_ctx);
                dd= s->enc_write_ctx;
//flaw_line_below:
               mac_ctx = ssl_replace_hash(&s->write_hash,NULL);
//fix_flaw_line_below:
//               if (SSL_IS_DTLS(s))
//fix_flaw_line_below:
//                       {
//fix_flaw_line_below:
//                       mac_ctx = EVP_MD_CTX_create();
//fix_flaw_line_below:
//                       if (!mac_ctx)
//fix_flaw_line_below:
//                               goto err;
//fix_flaw_line_below:
//                       s->write_hash = mac_ctx;
//fix_flaw_line_below:
//                       }
//fix_flaw_line_below:
//               else
//fix_flaw_line_below:
//                       mac_ctx = ssl_replace_hash(&s->write_hash,NULL);
 #ifndef OPENSSL_NO_COMP
                if (s->compress != NULL)
                        {
			s->compress=COMP_CTX_new(comp->method);
			if (s->compress == NULL)
				{
				SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);
				goto err2;
				}
			}
#endif
		/* this is done by dtls1_reset_seq_numbers for DTLS1_VERSION */
 		if (s->version != DTLS1_VERSION)
			memset(&(s->s3->write_sequence[0]),0,8);
		mac_secret= &(s->s3->write_mac_secret[0]);
		mac_secret_size = &(s->s3->write_mac_secret_size);
		}

	if (reuse_dd)
		EVP_CIPHER_CTX_cleanup(dd);

	p=s->s3->tmp.key_block;
	i=*mac_secret_size=s->s3->tmp.new_mac_secret_size;

	cl=EVP_CIPHER_key_length(c);
	j=is_export ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ?
	               cl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;
	/* Was j=(exp)?5:EVP_CIPHER_key_length(c); */
	/* If GCM mode only part of IV comes from PRF */
	if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)
		k = EVP_GCM_TLS_FIXED_IV_LEN;
	else
		k=EVP_CIPHER_iv_length(c);
	if (	(which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||
		(which == SSL3_CHANGE_CIPHER_SERVER_READ))
		{
		ms=  &(p[ 0]); n=i+i;
		key= &(p[ n]); n+=j+j;
		iv=  &(p[ n]); n+=k+k;
		exp_label=(unsigned char *)TLS_MD_CLIENT_WRITE_KEY_CONST;
		exp_label_len=TLS_MD_CLIENT_WRITE_KEY_CONST_SIZE;
		client_write=1;
		}
	else
		{
		n=i;
		ms=  &(p[ n]); n+=i+j;
		key= &(p[ n]); n+=j+k;
		iv=  &(p[ n]); n+=k;
		exp_label=(unsigned char *)TLS_MD_SERVER_WRITE_KEY_CONST;
		exp_label_len=TLS_MD_SERVER_WRITE_KEY_CONST_SIZE;
		client_write=0;
		}

	if (n > s->s3->tmp.key_block_length)
		{
		SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_INTERNAL_ERROR);
		goto err2;
		}

	memcpy(mac_secret,ms,i);

	if (!(EVP_CIPHER_flags(c)&EVP_CIPH_FLAG_AEAD_CIPHER))
		{
		mac_key = EVP_PKEY_new_mac_key(mac_type, NULL,
				mac_secret,*mac_secret_size);
		EVP_DigestSignInit(mac_ctx,NULL,m,NULL,mac_key);
		EVP_PKEY_free(mac_key);
		}
#ifdef TLS_DEBUG
printf(""which = %04X\nmac key="",which);
{ int z; for (z=0; z<i; z++) printf(""%02X%c"",ms[z],((z+1)%16)?' ':'\n'); }
#endif
	if (is_export)
		{
		/* In here I set both the read and write key/iv to the
		 * same value since only the correct one will be used :-).
		 */
		if (!tls1_PRF(ssl_get_algorithm2(s),
				exp_label,exp_label_len,
				s->s3->client_random,SSL3_RANDOM_SIZE,
				s->s3->server_random,SSL3_RANDOM_SIZE,
				NULL,0,NULL,0,
				key,j,tmp1,tmp2,EVP_CIPHER_key_length(c)))
			goto err2;
		key=tmp1;

		if (k > 0)
			{
			if (!tls1_PRF(ssl_get_algorithm2(s),
					TLS_MD_IV_BLOCK_CONST,TLS_MD_IV_BLOCK_CONST_SIZE,
					s->s3->client_random,SSL3_RANDOM_SIZE,
					s->s3->server_random,SSL3_RANDOM_SIZE,
					NULL,0,NULL,0,
					empty,0,iv1,iv2,k*2))
				goto err2;
			if (client_write)
				iv=iv1;
			else
				iv= &(iv1[k]);
			}
		}

	s->session->key_arg_length=0;
#ifdef KSSL_DEBUG
	{
        int i;
	printf(""EVP_CipherInit_ex(dd,c,key=,iv=,which)\n"");
	printf(""\tkey= ""); for (i=0; i<c->key_len; i++) printf(""%02x"", key[i]);
	printf(""\n"");
	printf(""\t iv= ""); for (i=0; i<c->iv_len; i++) printf(""%02x"", iv[i]);
	printf(""\n"");
	}
#endif	/* KSSL_DEBUG */

	if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)
		{
		EVP_CipherInit_ex(dd,c,NULL,key,NULL,(which & SSL3_CC_WRITE));
		EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_GCM_SET_IV_FIXED, k, iv);
		}
	else	
		EVP_CipherInit_ex(dd,c,NULL,key,iv,(which & SSL3_CC_WRITE));

	/* Needed for ""composite"" AEADs, such as RC4-HMAC-MD5 */
	if ((EVP_CIPHER_flags(c)&EVP_CIPH_FLAG_AEAD_CIPHER) && *mac_secret_size)
		EVP_CIPHER_CTX_ctrl(dd,EVP_CTRL_AEAD_SET_MAC_KEY,
				*mac_secret_size,mac_secret);

#ifdef TLS_DEBUG
printf(""which = %04X\nkey="",which);
{ int z; for (z=0; z<EVP_CIPHER_key_length(c); z++) printf(""%02X%c"",key[z],((z+1)%16)?' ':'\n'); }
printf(""\niv="");
{ int z; for (z=0; z<k; z++) printf(""%02X%c"",iv[z],((z+1)%16)?' ':'\n'); }
printf(""\n"");
#endif

	OPENSSL_cleanse(tmp1,sizeof(tmp1));
	OPENSSL_cleanse(tmp2,sizeof(tmp1));
	OPENSSL_cleanse(iv1,sizeof(iv1));
	OPENSSL_cleanse(iv2,sizeof(iv2));
	return(1);
err:
	SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_MALLOC_FAILURE);
err2:
	return(0);
	}
"
781,178517,,Remote,Not required,,CVE-2000-1254,https://www.cvedetails.com/cve/CVE-2000-1254/,CWE-310,Low,Partial,,,2016-05-04,5.0,"crypto/rsa/rsa_gen.c in OpenSSL before 0.9.6 mishandles C bitwise-shift operations that exceed the size of an expression, which makes it easier for remote attackers to defeat cryptographic protection mechanisms by leveraging improper RSA key generation on 64-bit HP-UX platforms.",2017-02-01,,1,https://git.openssl.org/?p=openssl.git;a=commit;h=db82b8f9bd432a59aea8e1014694e15fc457c2bb,db82b8f9bd432a59aea8e1014694e15fc457c2bb,,1,,,"RSA *RSA_generate_key(int bits, unsigned long e_value,
	     void (*callback)(int,int,void *), void *cb_arg)
	{
	RSA *rsa=NULL;
	BIGNUM *r0=NULL,*r1=NULL,*r2=NULL,*r3=NULL,*tmp;
	int bitsp,bitsq,ok= -1,n=0,i;
	BN_CTX *ctx=NULL,*ctx2=NULL;

	ctx=BN_CTX_new();
	if (ctx == NULL) goto err;
	ctx2=BN_CTX_new();
	if (ctx2 == NULL) goto err;
	BN_CTX_start(ctx);
	r0 = BN_CTX_get(ctx);
	r1 = BN_CTX_get(ctx);
	r2 = BN_CTX_get(ctx);
	r3 = BN_CTX_get(ctx);
	if (r3 == NULL) goto err;

	bitsp=(bits+1)/2;
	bitsq=bits-bitsp;
	rsa=RSA_new();
	if (rsa == NULL) goto err;

	/* set e */ 
	rsa->e=BN_new();
	if (rsa->e == NULL) goto err;

#if 1
	/* The problem is when building with 8, 16, or 32 BN_ULONG,
         * unsigned long can be larger */
        for (i=0; i<sizeof(unsigned long)*8; i++)
                {
               if (e_value & (1UL<<i))
                        BN_set_bit(rsa->e,i);
                }
 #else
	if (!BN_set_word(rsa->e,e_value)) goto err;
#endif

	/* generate p and q */
	for (;;)
		{
		rsa->p=BN_generate_prime(NULL,bitsp,0,NULL,NULL,callback,cb_arg);
		if (rsa->p == NULL) goto err;
		if (!BN_sub(r2,rsa->p,BN_value_one())) goto err;
		if (!BN_gcd(r1,r2,rsa->e,ctx)) goto err;
		if (BN_is_one(r1)) break;
		if (callback != NULL) callback(2,n++,cb_arg);
		BN_free(rsa->p);
		}
	if (callback != NULL) callback(3,0,cb_arg);
	for (;;)
		{
		rsa->q=BN_generate_prime(NULL,bitsq,0,NULL,NULL,callback,cb_arg);
		if (rsa->q == NULL) goto err;
		if (!BN_sub(r2,rsa->q,BN_value_one())) goto err;
		if (!BN_gcd(r1,r2,rsa->e,ctx)) goto err;
		if (BN_is_one(r1) && (BN_cmp(rsa->p,rsa->q) != 0))
			break;
		if (callback != NULL) callback(2,n++,cb_arg);
		BN_free(rsa->q);
		}
	if (callback != NULL) callback(3,1,cb_arg);
	if (BN_cmp(rsa->p,rsa->q) < 0)
		{
		tmp=rsa->p;
		rsa->p=rsa->q;
		rsa->q=tmp;
		}

	/* calculate n */
	rsa->n=BN_new();
	if (rsa->n == NULL) goto err;
	if (!BN_mul(rsa->n,rsa->p,rsa->q,ctx)) goto err;

	/* calculate d */
	if (!BN_sub(r1,rsa->p,BN_value_one())) goto err;	/* p-1 */
	if (!BN_sub(r2,rsa->q,BN_value_one())) goto err;	/* q-1 */
	if (!BN_mul(r0,r1,r2,ctx)) goto err;	/* (p-1)(q-1) */

/* should not be needed, since gcd(p-1,e) == 1 and gcd(q-1,e) == 1 */
/*	for (;;)
		{
		if (!BN_gcd(r3,r0,rsa->e,ctx)) goto err;
		if (BN_is_one(r3)) break;

		if (1)
			{
			if (!BN_add_word(rsa->e,2L)) goto err;
			continue;
			}
		RSAerr(RSA_F_RSA_GENERATE_KEY,RSA_R_BAD_E_VALUE);
		goto err;
		}
*/
	rsa->d=BN_mod_inverse(NULL,rsa->e,r0,ctx2);	/* d */
	if (rsa->d == NULL) goto err;

	/* calculate d mod (p-1) */
	rsa->dmp1=BN_new();
	if (rsa->dmp1 == NULL) goto err;
	if (!BN_mod(rsa->dmp1,rsa->d,r1,ctx)) goto err;

	/* calculate d mod (q-1) */
	rsa->dmq1=BN_new();
	if (rsa->dmq1 == NULL) goto err;
	if (!BN_mod(rsa->dmq1,rsa->d,r2,ctx)) goto err;

	/* calculate inverse of q mod p */
	rsa->iqmp=BN_mod_inverse(NULL,rsa->q,rsa->p,ctx2);
	if (rsa->iqmp == NULL) goto err;

	ok=1;
err:
	if (ok == -1)
		{
		RSAerr(RSA_F_RSA_GENERATE_KEY,ERR_LIB_BN);
		ok=0;
		}
	BN_CTX_end(ctx);
	BN_CTX_free(ctx);
	BN_CTX_free(ctx2);
	
	if (!ok)
		{
		if (rsa != NULL) RSA_free(rsa);
		return(NULL);
		}
	else
		return(rsa);
	}
","RSA *RSA_generate_key(int bits, unsigned long e_value,
	     void (*callback)(int,int,void *), void *cb_arg)
	{
	RSA *rsa=NULL;
	BIGNUM *r0=NULL,*r1=NULL,*r2=NULL,*r3=NULL,*tmp;
	int bitsp,bitsq,ok= -1,n=0,i;
	BN_CTX *ctx=NULL,*ctx2=NULL;

	ctx=BN_CTX_new();
	if (ctx == NULL) goto err;
	ctx2=BN_CTX_new();
	if (ctx2 == NULL) goto err;
	BN_CTX_start(ctx);
	r0 = BN_CTX_get(ctx);
	r1 = BN_CTX_get(ctx);
	r2 = BN_CTX_get(ctx);
	r3 = BN_CTX_get(ctx);
	if (r3 == NULL) goto err;

	bitsp=(bits+1)/2;
	bitsq=bits-bitsp;
	rsa=RSA_new();
	if (rsa == NULL) goto err;

	/* set e */ 
	rsa->e=BN_new();
	if (rsa->e == NULL) goto err;

#if 1
	/* The problem is when building with 8, 16, or 32 BN_ULONG,
         * unsigned long can be larger */
        for (i=0; i<sizeof(unsigned long)*8; i++)
                {
               if (e_value & (1<<i))
                        BN_set_bit(rsa->e,i);
                }
 #else
	if (!BN_set_word(rsa->e,e_value)) goto err;
#endif

	/* generate p and q */
	for (;;)
		{
		rsa->p=BN_generate_prime(NULL,bitsp,0,NULL,NULL,callback,cb_arg);
		if (rsa->p == NULL) goto err;
		if (!BN_sub(r2,rsa->p,BN_value_one())) goto err;
		if (!BN_gcd(r1,r2,rsa->e,ctx)) goto err;
		if (BN_is_one(r1)) break;
		if (callback != NULL) callback(2,n++,cb_arg);
		BN_free(rsa->p);
		}
	if (callback != NULL) callback(3,0,cb_arg);
	for (;;)
		{
		rsa->q=BN_generate_prime(NULL,bitsq,0,NULL,NULL,callback,cb_arg);
		if (rsa->q == NULL) goto err;
		if (!BN_sub(r2,rsa->q,BN_value_one())) goto err;
		if (!BN_gcd(r1,r2,rsa->e,ctx)) goto err;
		if (BN_is_one(r1) && (BN_cmp(rsa->p,rsa->q) != 0))
			break;
		if (callback != NULL) callback(2,n++,cb_arg);
		BN_free(rsa->q);
		}
	if (callback != NULL) callback(3,1,cb_arg);
	if (BN_cmp(rsa->p,rsa->q) < 0)
		{
		tmp=rsa->p;
		rsa->p=rsa->q;
		rsa->q=tmp;
		}

	/* calculate n */
	rsa->n=BN_new();
	if (rsa->n == NULL) goto err;
	if (!BN_mul(rsa->n,rsa->p,rsa->q,ctx)) goto err;

	/* calculate d */
	if (!BN_sub(r1,rsa->p,BN_value_one())) goto err;	/* p-1 */
	if (!BN_sub(r2,rsa->q,BN_value_one())) goto err;	/* q-1 */
	if (!BN_mul(r0,r1,r2,ctx)) goto err;	/* (p-1)(q-1) */

/* should not be needed, since gcd(p-1,e) == 1 and gcd(q-1,e) == 1 */
/*	for (;;)
		{
		if (!BN_gcd(r3,r0,rsa->e,ctx)) goto err;
		if (BN_is_one(r3)) break;

		if (1)
			{
			if (!BN_add_word(rsa->e,2L)) goto err;
			continue;
			}
		RSAerr(RSA_F_RSA_GENERATE_KEY,RSA_R_BAD_E_VALUE);
		goto err;
		}
*/
	rsa->d=BN_mod_inverse(NULL,rsa->e,r0,ctx2);	/* d */
	if (rsa->d == NULL) goto err;

	/* calculate d mod (p-1) */
	rsa->dmp1=BN_new();
	if (rsa->dmp1 == NULL) goto err;
	if (!BN_mod(rsa->dmp1,rsa->d,r1,ctx)) goto err;

	/* calculate d mod (q-1) */
	rsa->dmq1=BN_new();
	if (rsa->dmq1 == NULL) goto err;
	if (!BN_mod(rsa->dmq1,rsa->d,r2,ctx)) goto err;

	/* calculate inverse of q mod p */
	rsa->iqmp=BN_mod_inverse(NULL,rsa->q,rsa->p,ctx2);
	if (rsa->iqmp == NULL) goto err;

	ok=1;
err:
	if (ok == -1)
		{
		RSAerr(RSA_F_RSA_GENERATE_KEY,ERR_LIB_BN);
		ok=0;
		}
	BN_CTX_end(ctx);
	BN_CTX_free(ctx);
	BN_CTX_free(ctx2);
	
	if (!ok)
		{
		if (rsa != NULL) RSA_free(rsa);
		return(NULL);
		}
	else
		return(rsa);
	}
",C,"               if (e_value & (1UL<<i))
","               if (e_value & (1<<i))
",a9ef75c50d35afc115d443ddc7dd35956fc5a2ef,"@@ -95,7 +95,7 @@ RSA *RSA_generate_key(int bits, unsigned long e_value,
         * unsigned long can be larger */
        for (i=0; i<sizeof(unsigned long)*8; i++)
                {
-               if (e_value & (1<<i))
+               if (e_value & (1UL<<i))
                        BN_set_bit(rsa->e,i);
                }
 #else",openssl,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/rsa/rsa_gen.c;h=00c25adbc588485e022a9a0b1608ca0b6ce16ba2;hb=db82b8f9bd432a59aea8e1014694e15fc457c2bb,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/rsa/rsa_gen.c;h=95e636d3f0233e3148e13c545d626539e5ccc8a7,1,"RSA *RSA_generate_key(int bits, unsigned long e_value,
	     void (*callback)(int,int,void *), void *cb_arg)
	{
	RSA *rsa=NULL;
	BIGNUM *r0=NULL,*r1=NULL,*r2=NULL,*r3=NULL,*tmp;
	int bitsp,bitsq,ok= -1,n=0,i;
	BN_CTX *ctx=NULL,*ctx2=NULL;

	ctx=BN_CTX_new();
	if (ctx == NULL) goto err;
	ctx2=BN_CTX_new();
	if (ctx2 == NULL) goto err;
	BN_CTX_start(ctx);
	r0 = BN_CTX_get(ctx);
	r1 = BN_CTX_get(ctx);
	r2 = BN_CTX_get(ctx);
	r3 = BN_CTX_get(ctx);
	if (r3 == NULL) goto err;

	bitsp=(bits+1)/2;
	bitsq=bits-bitsp;
	rsa=RSA_new();
	if (rsa == NULL) goto err;

	/* set e */ 
	rsa->e=BN_new();
	if (rsa->e == NULL) goto err;

#if 1
	/* The problem is when building with 8, 16, or 32 BN_ULONG,
         * unsigned long can be larger */
        for (i=0; i<sizeof(unsigned long)*8; i++)
                {
//flaw_line_below:
               if (e_value & (1<<i))
//fix_flaw_line_below:
//               if (e_value & (1UL<<i))
                        BN_set_bit(rsa->e,i);
                }
 #else
	if (!BN_set_word(rsa->e,e_value)) goto err;
#endif

	/* generate p and q */
	for (;;)
		{
		rsa->p=BN_generate_prime(NULL,bitsp,0,NULL,NULL,callback,cb_arg);
		if (rsa->p == NULL) goto err;
		if (!BN_sub(r2,rsa->p,BN_value_one())) goto err;
		if (!BN_gcd(r1,r2,rsa->e,ctx)) goto err;
		if (BN_is_one(r1)) break;
		if (callback != NULL) callback(2,n++,cb_arg);
		BN_free(rsa->p);
		}
	if (callback != NULL) callback(3,0,cb_arg);
	for (;;)
		{
		rsa->q=BN_generate_prime(NULL,bitsq,0,NULL,NULL,callback,cb_arg);
		if (rsa->q == NULL) goto err;
		if (!BN_sub(r2,rsa->q,BN_value_one())) goto err;
		if (!BN_gcd(r1,r2,rsa->e,ctx)) goto err;
		if (BN_is_one(r1) && (BN_cmp(rsa->p,rsa->q) != 0))
			break;
		if (callback != NULL) callback(2,n++,cb_arg);
		BN_free(rsa->q);
		}
	if (callback != NULL) callback(3,1,cb_arg);
	if (BN_cmp(rsa->p,rsa->q) < 0)
		{
		tmp=rsa->p;
		rsa->p=rsa->q;
		rsa->q=tmp;
		}

	/* calculate n */
	rsa->n=BN_new();
	if (rsa->n == NULL) goto err;
	if (!BN_mul(rsa->n,rsa->p,rsa->q,ctx)) goto err;

	/* calculate d */
	if (!BN_sub(r1,rsa->p,BN_value_one())) goto err;	/* p-1 */
	if (!BN_sub(r2,rsa->q,BN_value_one())) goto err;	/* q-1 */
	if (!BN_mul(r0,r1,r2,ctx)) goto err;	/* (p-1)(q-1) */

/* should not be needed, since gcd(p-1,e) == 1 and gcd(q-1,e) == 1 */
/*	for (;;)
		{
		if (!BN_gcd(r3,r0,rsa->e,ctx)) goto err;
		if (BN_is_one(r3)) break;

		if (1)
			{
			if (!BN_add_word(rsa->e,2L)) goto err;
			continue;
			}
		RSAerr(RSA_F_RSA_GENERATE_KEY,RSA_R_BAD_E_VALUE);
		goto err;
		}
*/
	rsa->d=BN_mod_inverse(NULL,rsa->e,r0,ctx2);	/* d */
	if (rsa->d == NULL) goto err;

	/* calculate d mod (p-1) */
	rsa->dmp1=BN_new();
	if (rsa->dmp1 == NULL) goto err;
	if (!BN_mod(rsa->dmp1,rsa->d,r1,ctx)) goto err;

	/* calculate d mod (q-1) */
	rsa->dmq1=BN_new();
	if (rsa->dmq1 == NULL) goto err;
	if (!BN_mod(rsa->dmq1,rsa->d,r2,ctx)) goto err;

	/* calculate inverse of q mod p */
	rsa->iqmp=BN_mod_inverse(NULL,rsa->q,rsa->p,ctx2);
	if (rsa->iqmp == NULL) goto err;

	ok=1;
err:
	if (ok == -1)
		{
		RSAerr(RSA_F_RSA_GENERATE_KEY,ERR_LIB_BN);
		ok=0;
		}
	BN_CTX_end(ctx);
	BN_CTX_free(ctx);
	BN_CTX_free(ctx2);
	
	if (!ok)
		{
		if (rsa != NULL) RSA_free(rsa);
		return(NULL);
		}
	else
		return(rsa);
	}
"
892,178628,,Remote,Not required,,CVE-2017-7526,https://www.cvedetails.com/cve/CVE-2017-7526/,CWE-310,Medium,Partial,,,2018-07-26,4.3,libgcrypt before version 1.7.8 is vulnerable to a cache side-channel attack resulting into a complete break of RSA-1024 while using the left-to-right method for computing the sliding-window expansion. The same attack is believed to work on RSA-2048 with moderately more computation. This side-channel requires that attacker can run arbitrary software on the hardware where the private RSA key is used.,2019-10-09,,26,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libgcrypt.git;a=commit;h=8725c99ffa41778f382ca97233183bcd687bb0ce,8725c99ffa41778f382ca97233183bcd687bb0ce,,4,,,"secret_core_crt (gcry_mpi_t M, gcry_mpi_t C,
                 gcry_mpi_t D, unsigned int Nlimbs,
                 gcry_mpi_t P, gcry_mpi_t Q, gcry_mpi_t U)
{
   gcry_mpi_t m1 = mpi_alloc_secure ( Nlimbs + 1 );
   gcry_mpi_t m2 = mpi_alloc_secure ( Nlimbs + 1 );
   gcry_mpi_t h  = mpi_alloc_secure ( Nlimbs + 1 );
  gcry_mpi_t D_blind = mpi_alloc_secure ( Nlimbs + 1 );
  gcry_mpi_t r;
  unsigned int r_nbits;

  r_nbits = mpi_get_nbits (P) / 4;
  if (r_nbits < 96)
    r_nbits = 96;
  r = mpi_alloc_secure ( (r_nbits + BITS_PER_MPI_LIMB-1)/BITS_PER_MPI_LIMB );

  /* d_blind = (d mod (p-1)) + (p-1) * r            */
  /* m1 = c ^ d_blind mod p */
  _gcry_mpi_randomize (r, r_nbits, GCRY_WEAK_RANDOM);
  mpi_set_highbit (r, r_nbits - 1);
   mpi_sub_ui ( h, P, 1 );
  mpi_mul ( D_blind, h, r );
   mpi_fdiv_r ( h, D, h );
  mpi_add ( D_blind, D_blind, h );
  mpi_powm ( m1, C, D_blind, P );
 
  /* d_blind = (d mod (q-1)) + (q-1) * r            */
  /* m2 = c ^ d_blind mod q */
  _gcry_mpi_randomize (r, r_nbits, GCRY_WEAK_RANDOM);
  mpi_set_highbit (r, r_nbits - 1);
   mpi_sub_ui ( h, Q, 1  );
  mpi_mul ( D_blind, h, r );
   mpi_fdiv_r ( h, D, h );
  mpi_add ( D_blind, D_blind, h );
  mpi_powm ( m2, C, D_blind, Q );

  mpi_free ( r );
  mpi_free ( D_blind );
 
   /* h = u * ( m2 - m1 ) mod q */
   mpi_sub ( h, m2, m1 );
  /* Remove superfluous leading zeroes from INPUT.  */
  mpi_normalize (input);

  if (!skey->p || !skey->q || !skey->u)
    {
      secret_core_std (output, input, skey->d, skey->n);
    }
  else
    {
      secret_core_crt (output, input, skey->d, mpi_get_nlimbs (skey->n),
                       skey->p, skey->q, skey->u);
    }
}
","secret_core_crt (gcry_mpi_t M, gcry_mpi_t C,
                 gcry_mpi_t D, unsigned int Nlimbs,
                 gcry_mpi_t P, gcry_mpi_t Q, gcry_mpi_t U)
{
   gcry_mpi_t m1 = mpi_alloc_secure ( Nlimbs + 1 );
   gcry_mpi_t m2 = mpi_alloc_secure ( Nlimbs + 1 );
   gcry_mpi_t h  = mpi_alloc_secure ( Nlimbs + 1 );
  /* m1 = c ^ (d mod (p-1)) mod p */
   mpi_sub_ui ( h, P, 1 );
   mpi_fdiv_r ( h, D, h );
  mpi_powm ( m1, C, h, P );
 
  /* m2 = c ^ (d mod (q-1)) mod q */
   mpi_sub_ui ( h, Q, 1  );
   mpi_fdiv_r ( h, D, h );
  mpi_powm ( m2, C, h, Q );
 
   /* h = u * ( m2 - m1 ) mod q */
   mpi_sub ( h, m2, m1 );
  /* Remove superfluous leading zeroes from INPUT.  */
  mpi_normalize (input);

  if (!skey->p || !skey->q || !skey->u)
    {
      secret_core_std (output, input, skey->d, skey->n);
    }
  else
    {
      secret_core_crt (output, input, skey->d, mpi_get_nlimbs (skey->n),
                       skey->p, skey->q, skey->u);
    }
}
",C,"  gcry_mpi_t D_blind = mpi_alloc_secure ( Nlimbs + 1 );
  gcry_mpi_t r;
  unsigned int r_nbits;

  r_nbits = mpi_get_nbits (P) / 4;
  if (r_nbits < 96)
    r_nbits = 96;
  r = mpi_alloc_secure ( (r_nbits + BITS_PER_MPI_LIMB-1)/BITS_PER_MPI_LIMB );

  /* d_blind = (d mod (p-1)) + (p-1) * r            */
  /* m1 = c ^ d_blind mod p */
  _gcry_mpi_randomize (r, r_nbits, GCRY_WEAK_RANDOM);
  mpi_set_highbit (r, r_nbits - 1);
  mpi_mul ( D_blind, h, r );
  mpi_add ( D_blind, D_blind, h );
  mpi_powm ( m1, C, D_blind, P );
  /* d_blind = (d mod (q-1)) + (q-1) * r            */
  /* m2 = c ^ d_blind mod q */
  _gcry_mpi_randomize (r, r_nbits, GCRY_WEAK_RANDOM);
  mpi_set_highbit (r, r_nbits - 1);
  mpi_mul ( D_blind, h, r );
  mpi_add ( D_blind, D_blind, h );
  mpi_powm ( m2, C, D_blind, Q );

  mpi_free ( r );
  mpi_free ( D_blind );
","  /* m1 = c ^ (d mod (p-1)) mod p */
  mpi_powm ( m1, C, h, P );
  /* m2 = c ^ (d mod (q-1)) mod q */
  mpi_powm ( m2, C, h, Q );
",78130828e9a140a9de4dafadbc844dbb64cb709a,"@@ -1019,16 +1019,37 @@ secret_core_crt (gcry_mpi_t M, gcry_mpi_t C,
   gcry_mpi_t m1 = mpi_alloc_secure ( Nlimbs + 1 );
   gcry_mpi_t m2 = mpi_alloc_secure ( Nlimbs + 1 );
   gcry_mpi_t h  = mpi_alloc_secure ( Nlimbs + 1 );
-
-  /* m1 = c ^ (d mod (p-1)) mod p */
+  gcry_mpi_t D_blind = mpi_alloc_secure ( Nlimbs + 1 );
+  gcry_mpi_t r;
+  unsigned int r_nbits;
+
+  r_nbits = mpi_get_nbits (P) / 4;
+  if (r_nbits < 96)
+    r_nbits = 96;
+  r = mpi_alloc_secure ( (r_nbits + BITS_PER_MPI_LIMB-1)/BITS_PER_MPI_LIMB );
+
+  /* d_blind = (d mod (p-1)) + (p-1) * r            */
+  /* m1 = c ^ d_blind mod p */
+  _gcry_mpi_randomize (r, r_nbits, GCRY_WEAK_RANDOM);
+  mpi_set_highbit (r, r_nbits - 1);
   mpi_sub_ui ( h, P, 1 );
+  mpi_mul ( D_blind, h, r );
   mpi_fdiv_r ( h, D, h );
-  mpi_powm ( m1, C, h, P );
+  mpi_add ( D_blind, D_blind, h );
+  mpi_powm ( m1, C, D_blind, P );
 
-  /* m2 = c ^ (d mod (q-1)) mod q */
+  /* d_blind = (d mod (q-1)) + (q-1) * r            */
+  /* m2 = c ^ d_blind mod q */
+  _gcry_mpi_randomize (r, r_nbits, GCRY_WEAK_RANDOM);
+  mpi_set_highbit (r, r_nbits - 1);
   mpi_sub_ui ( h, Q, 1  );
+  mpi_mul ( D_blind, h, r );
   mpi_fdiv_r ( h, D, h );
-  mpi_powm ( m2, C, h, Q );
+  mpi_add ( D_blind, D_blind, h );
+  mpi_powm ( m2, C, D_blind, Q );
+
+  mpi_free ( r );
+  mpi_free ( D_blind );
 
   /* h = u * ( m2 - m1 ) mod q */
   mpi_sub ( h, m2, m1 );",gnupg,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libgcrypt.git;a=blob;f=cipher/rsa.c;h=ce73f106b2699b498e5053a08d625349a7c34099;hb=ce73f106b2699b498e5053a08d625349a7c34099,https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libgcrypt.git;a=blob;f=cipher/rsa.c;h=9f83e8f239fb1f6467d7657ad4dda671fd395ade;hb=9f83e8f239fb1f6467d7657ad4dda671fd395ade,1,"secret_core_crt (gcry_mpi_t M, gcry_mpi_t C,
                 gcry_mpi_t D, unsigned int Nlimbs,
                 gcry_mpi_t P, gcry_mpi_t Q, gcry_mpi_t U)
{
   gcry_mpi_t m1 = mpi_alloc_secure ( Nlimbs + 1 );
   gcry_mpi_t m2 = mpi_alloc_secure ( Nlimbs + 1 );
   gcry_mpi_t h  = mpi_alloc_secure ( Nlimbs + 1 );
//flaw_line_below:

//flaw_line_below:
  /* m1 = c ^ (d mod (p-1)) mod p */
//fix_flaw_line_below:
//  gcry_mpi_t D_blind = mpi_alloc_secure ( Nlimbs + 1 );
//fix_flaw_line_below:
//  gcry_mpi_t r;
//fix_flaw_line_below:
//  unsigned int r_nbits;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  r_nbits = mpi_get_nbits (P) / 4;
//fix_flaw_line_below:
//  if (r_nbits < 96)
//fix_flaw_line_below:
//    r_nbits = 96;
//fix_flaw_line_below:
//  r = mpi_alloc_secure ( (r_nbits + BITS_PER_MPI_LIMB-1)/BITS_PER_MPI_LIMB );
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  /* d_blind = (d mod (p-1)) + (p-1) * r            */
//fix_flaw_line_below:
//  /* m1 = c ^ d_blind mod p */
//fix_flaw_line_below:
//  _gcry_mpi_randomize (r, r_nbits, GCRY_WEAK_RANDOM);
//fix_flaw_line_below:
//  mpi_set_highbit (r, r_nbits - 1);
   mpi_sub_ui ( h, P, 1 );
//fix_flaw_line_below:
//  mpi_mul ( D_blind, h, r );
   mpi_fdiv_r ( h, D, h );
//flaw_line_below:
  mpi_powm ( m1, C, h, P );
//fix_flaw_line_below:
//  mpi_add ( D_blind, D_blind, h );
//fix_flaw_line_below:
//  mpi_powm ( m1, C, D_blind, P );
 
//flaw_line_below:
  /* m2 = c ^ (d mod (q-1)) mod q */
//fix_flaw_line_below:
//  /* d_blind = (d mod (q-1)) + (q-1) * r            */
//fix_flaw_line_below:
//  /* m2 = c ^ d_blind mod q */
//fix_flaw_line_below:
//  _gcry_mpi_randomize (r, r_nbits, GCRY_WEAK_RANDOM);
//fix_flaw_line_below:
//  mpi_set_highbit (r, r_nbits - 1);
   mpi_sub_ui ( h, Q, 1  );
//fix_flaw_line_below:
//  mpi_mul ( D_blind, h, r );
   mpi_fdiv_r ( h, D, h );
//flaw_line_below:
  mpi_powm ( m2, C, h, Q );
//fix_flaw_line_below:
//  mpi_add ( D_blind, D_blind, h );
//fix_flaw_line_below:
//  mpi_powm ( m2, C, D_blind, Q );
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  mpi_free ( r );
//fix_flaw_line_below:
//  mpi_free ( D_blind );
 
   /* h = u * ( m2 - m1 ) mod q */
   mpi_sub ( h, m2, m1 );
  /* Remove superfluous leading zeroes from INPUT.  */
  mpi_normalize (input);

  if (!skey->p || !skey->q || !skey->u)
    {
      secret_core_std (output, input, skey->d, skey->n);
    }
  else
    {
      secret_core_crt (output, input, skey->d, mpi_get_nlimbs (skey->n),
                       skey->p, skey->q, skey->u);
    }
}
"
1425,179161,,Remote,Not required,,CVE-2013-4350,https://www.cvedetails.com/cve/CVE-2013-4350/,CWE-310,Low,Partial,,,2013-09-25,5.0,"The IPv6 SCTP implementation in net/sctp/ipv6.c in the Linux kernel through 3.11.1 uses data structures and function calls that do not trigger an intended configuration of IPsec encryption, which allows remote attackers to obtain sensitive information by sniffing the network.",2014-01-03,+Info ,7,https://github.com/torvalds/linux/commit/95ee62083cb6453e056562d91f597552021e6ae7,95ee62083cb6453e056562d91f597552021e6ae7,"net: sctp: fix ipv6 ipsec encryption bug in sctp_v6_xmit

Alan Chester reported an issue with IPv6 on SCTP that IPsec traffic is not
being encrypted, whereas on IPv4 it is. Setting up an AH + ESP transport
does not seem to have the desired effect:

SCTP + IPv4:

  22:14:20.809645 IP (tos 0x2,ECT(0), ttl 64, id 0, offset 0, flags [DF], proto AH (51), length 116)
    192.168.0.2 > 192.168.0.5: AH(spi=0x00000042,sumlen=16,seq=0x1): ESP(spi=0x00000044,seq=0x1), length 72
  22:14:20.813270 IP (tos 0x2,ECT(0), ttl 64, id 0, offset 0, flags [DF], proto AH (51), length 340)
    192.168.0.5 > 192.168.0.2: AH(spi=0x00000043,sumlen=16,seq=0x1):

SCTP + IPv6:

  22:31:19.215029 IP6 (class 0x02, hlim 64, next-header SCTP (132) payload length: 364)
    fe80::222:15ff:fe87:7fc.3333 > fe80::92e6:baff:fe0d:5a54.36767: sctp
    1) [INIT ACK] [init tag: 747759530] [rwnd: 62464] [OS: 10] [MIS: 10]

Moreover, Alan says:

  This problem was seen with both Racoon and Racoon2. Other people have seen
  this with OpenSwan. When IPsec is configured to encrypt all upper layer
  protocols the SCTP connection does not initialize. After using Wireshark to
  follow packets, this is because the SCTP packet leaves Box A unencrypted and
  Box B believes all upper layer protocols are to be encrypted so it drops
  this packet, causing the SCTP connection to fail to initialize. When IPsec
  is configured to encrypt just SCTP, the SCTP packets are observed unencrypted.

In fact, using `socat sctp6-listen:3333 -` on one end and transferring ""plaintext""
string on the other end, results in cleartext on the wire where SCTP eventually
does not report any errors, thus in the latter case that Alan reports, the
non-paranoid user might think he's communicating over an encrypted transport on
SCTP although he's not (tcpdump ... -X):

  ...
  0x0030: 5d70 8e1a 0003 001a 177d eb6c 0000 0000  ]p.......}.l....
  0x0040: 0000 0000 706c 6169 6e74 6578 740a 0000  ....plaintext...

Only in /proc/net/xfrm_stat we can see XfrmInTmplMismatch increasing on the
receiver side. Initial follow-up analysis from Alan's bug report was done by
Alexey Dobriyan. Also thanks to Vlad Yasevich for feedback on this.

SCTP has its own implementation of sctp_v6_xmit() not calling inet6_csk_xmit().
This has the implication that it probably never really got updated along with
changes in inet6_csk_xmit() and therefore does not seem to invoke xfrm handlers.

SCTP's IPv4 xmit however, properly calls ip_queue_xmit() to do the work. Since
a call to inet6_csk_xmit() would solve this problem, but result in unecessary
route lookups, let us just use the cached flowi6 instead that we got through
sctp_v6_get_dst(). Since all SCTP packets are being sent through sctp_packet_transmit(),
we do the route lookup / flow caching in sctp_transport_route(), hold it in
tp->dst and skb_dst_set() right after that. If we would alter fl6->daddr in
sctp_v6_xmit() to np->opt->srcrt, we possibly could run into the same effect
of not having xfrm layer pick it up, hence, use fl6_update_dst() in sctp_v6_get_dst()
instead to get the correct source routed dst entry, which we assign to the skb.

Also source address routing example from 625034113 (""sctp: fix sctp to work with
ipv6 source address routing"") still works with this patch! Nevertheless, in RFC5095
it is actually 'recommended' to not use that anyway due to traffic amplification [1].
So it seems we're not supposed to do that anyway in sctp_v6_xmit(). Moreover, if
we overwrite the flow destination here, the lower IPv6 layer will be unable to
put the correct destination address into IP header, as routing header is added in
ipv6_push_nfrag_opts() but then probably with wrong final destination. Things aside,
result of this patch is that we do not have any XfrmInTmplMismatch increase plus on
the wire with this patch it now looks like:

SCTP + IPv6:

  08:17:47.074080 IP6 2620:52:0:102f:7a2b:cbff:fe27:1b0a > 2620:52:0:102f:213:72ff:fe32:7eba:
    AH(spi=0x00005fb4,seq=0x1): ESP(spi=0x00005fb5,seq=0x1), length 72
  08:17:47.074264 IP6 2620:52:0:102f:213:72ff:fe32:7eba > 2620:52:0:102f:7a2b:cbff:fe27:1b0a:
    AH(spi=0x00003d54,seq=0x1): ESP(spi=0x00003d55,seq=0x1), length 296

This fixes Kernel Bugzilla 24412. This security issue seems to be present since
2.6.18 kernels. Lets just hope some big passive adversary in the wild didn't have
its fun with that. lksctp-tools IPv6 regression test suite passes as well with
this patch.

 [1] http://www.secdev.org/conf/IPv6_RH_security-csw07.pdf

Reported-by: Alan Chester <alan.chester@tekelec.com>
Reported-by: Alexey Dobriyan <adobriyan@gmail.com>
Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
Cc: Steffen Klassert <steffen.klassert@secunet.com>
Cc: Hannes Frederic Sowa <hannes@stressinduktion.org>
Acked-by: Vlad Yasevich <vyasevich@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",2,net/sctp/ipv6.c,"{""sha"": ""4f52e2ce263d0852bf01cc286560f8d13fbe208a"", ""filename"": ""net/sctp/ipv6.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 29, ""changes"": 42, ""blob_url"": ""https://github.com/torvalds/linux/blob/95ee62083cb6453e056562d91f597552021e6ae7/net/sctp/ipv6.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/95ee62083cb6453e056562d91f597552021e6ae7/net/sctp/ipv6.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/sctp/ipv6.c?ref=95ee62083cb6453e056562d91f597552021e6ae7"", ""patch"": ""@@ -204,44 +204,23 @@ static void sctp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n \t\tin6_dev_put(idev);\n }\n \n-/* Based on tcp_v6_xmit() in tcp_ipv6.c. */\n static int sctp_v6_xmit(struct sk_buff *skb, struct sctp_transport *transport)\n {\n \tstruct sock *sk = skb->sk;\n \tstruct ipv6_pinfo *np = inet6_sk(sk);\n-\tstruct flowi6 fl6;\n-\n-\tmemset(&fl6, 0, sizeof(fl6));\n-\n-\tfl6.flowi6_proto = sk->sk_protocol;\n-\n-\t/* Fill in the dest address from the route entry passed with the skb\n-\t * and the source address from the transport.\n-\t */\n-\tfl6.daddr = transport->ipaddr.v6.sin6_addr;\n-\tfl6.saddr = transport->saddr.v6.sin6_addr;\n-\n-\tfl6.flowlabel = np->flow_label;\n-\tIP6_ECN_flow_xmit(sk, fl6.flowlabel);\n-\tif (ipv6_addr_type(&fl6.saddr) & IPV6_ADDR_LINKLOCAL)\n-\t\tfl6.flowi6_oif = transport->saddr.v6.sin6_scope_id;\n-\telse\n-\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n-\n-\tif (np->opt && np->opt->srcrt) {\n-\t\tstruct rt0_hdr *rt0 = (struct rt0_hdr *) np->opt->srcrt;\n-\t\tfl6.daddr = *rt0->addr;\n-\t}\n+\tstruct flowi6 *fl6 = &transport->fl.u.ip6;\n \n \tpr_debug(\""%s: skb:%p, len:%d, src:%pI6 dst:%pI6\\n\"", __func__, skb,\n-\t\t skb->len, &fl6.saddr, &fl6.daddr);\n+\t\t skb->len, &fl6->saddr, &fl6->daddr);\n \n-\tSCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);\n+\tIP6_ECN_flow_xmit(sk, fl6->flowlabel);\n \n \tif (!(transport->param_flags & SPP_PMTUD_ENABLE))\n \t\tskb->local_df = 1;\n \n-\treturn ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n+\tSCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);\n+\n+\treturn ip6_xmit(sk, skb, fl6, np->opt, np->tclass);\n }\n \n /* Returns the dst cache entry for the given source and destination ip\n@@ -254,10 +233,12 @@ static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,\n \tstruct dst_entry *dst = NULL;\n \tstruct flowi6 *fl6 = &fl->u.ip6;\n \tstruct sctp_bind_addr *bp;\n+\tstruct ipv6_pinfo *np = inet6_sk(sk);\n \tstruct sctp_sockaddr_entry *laddr;\n \tunion sctp_addr *baddr = NULL;\n \tunion sctp_addr *daddr = &t->ipaddr;\n \tunion sctp_addr dst_saddr;\n+\tstruct in6_addr *final_p, final;\n \t__u8 matchlen = 0;\n \t__u8 bmatchlen;\n \tsctp_scope_t scope;\n@@ -281,7 +262,8 @@ static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,\n \t\tpr_debug(\""src=%pI6 - \"", &fl6->saddr);\n \t}\n \n-\tdst = ip6_dst_lookup_flow(sk, fl6, NULL, false);\n+\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n+\tdst = ip6_dst_lookup_flow(sk, fl6, final_p, false);\n \tif (!asoc || saddr)\n \t\tgoto out;\n \n@@ -333,10 +315,12 @@ static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,\n \t\t}\n \t}\n \trcu_read_unlock();\n+\n \tif (baddr) {\n \t\tfl6->saddr = baddr->v6.sin6_addr;\n \t\tfl6->fl6_sport = baddr->v6.sin6_port;\n-\t\tdst = ip6_dst_lookup_flow(sk, fl6, NULL, false);\n+\t\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n+\t\tdst = ip6_dst_lookup_flow(sk, fl6, final_p, false);\n \t}\n \n out:""}","static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,
			    struct flowi *fl, struct sock *sk)
{
	struct sctp_association *asoc = t->asoc;
 	struct dst_entry *dst = NULL;
 	struct flowi6 *fl6 = &fl->u.ip6;
 	struct sctp_bind_addr *bp;
	struct ipv6_pinfo *np = inet6_sk(sk);
 	struct sctp_sockaddr_entry *laddr;
 	union sctp_addr *baddr = NULL;
 	union sctp_addr *daddr = &t->ipaddr;
 	union sctp_addr dst_saddr;
	struct in6_addr *final_p, final;
 	__u8 matchlen = 0;
 	__u8 bmatchlen;
 	sctp_scope_t scope;

	memset(fl6, 0, sizeof(struct flowi6));
	fl6->daddr = daddr->v6.sin6_addr;
	fl6->fl6_dport = daddr->v6.sin6_port;
	fl6->flowi6_proto = IPPROTO_SCTP;
	if (ipv6_addr_type(&daddr->v6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
		fl6->flowi6_oif = daddr->v6.sin6_scope_id;

	pr_debug(""%s: dst=%pI6 "", __func__, &fl6->daddr);

	if (asoc)
		fl6->fl6_sport = htons(asoc->base.bind_addr.port);

	if (saddr) {
		fl6->saddr = saddr->v6.sin6_addr;
		fl6->fl6_sport = saddr->v6.sin6_port;

 		pr_debug(""src=%pI6 - "", &fl6->saddr);
 	}
 
	final_p = fl6_update_dst(fl6, np->opt, &final);
	dst = ip6_dst_lookup_flow(sk, fl6, final_p, false);
 	if (!asoc || saddr)
 		goto out;
 
	bp = &asoc->base.bind_addr;
	scope = sctp_scope(daddr);
	/* ip6_dst_lookup has filled in the fl6->saddr for us.  Check
	 * to see if we can use it.
	 */
	if (!IS_ERR(dst)) {
		/* Walk through the bind address list and look for a bind
		 * address that matches the source address of the returned dst.
		 */
		sctp_v6_to_addr(&dst_saddr, &fl6->saddr, htons(bp->port));
		rcu_read_lock();
		list_for_each_entry_rcu(laddr, &bp->address_list, list) {
			if (!laddr->valid || (laddr->state != SCTP_ADDR_SRC))
				continue;

			/* Do not compare against v4 addrs */
			if ((laddr->a.sa.sa_family == AF_INET6) &&
			    (sctp_v6_cmp_addr(&dst_saddr, &laddr->a))) {
				rcu_read_unlock();
				goto out;
			}
		}
		rcu_read_unlock();
		/* None of the bound addresses match the source address of the
		 * dst. So release it.
		 */
		dst_release(dst);
		dst = NULL;
	}

	/* Walk through the bind address list and try to get the
	 * best source address for a given destination.
	 */
	rcu_read_lock();
	list_for_each_entry_rcu(laddr, &bp->address_list, list) {
		if (!laddr->valid)
			continue;
		if ((laddr->state == SCTP_ADDR_SRC) &&
		    (laddr->a.sa.sa_family == AF_INET6) &&
		    (scope <= sctp_scope(&laddr->a))) {
			bmatchlen = sctp_v6_addr_match_len(daddr, &laddr->a);
			if (!baddr || (matchlen < bmatchlen)) {
				baddr = &laddr->a;
				matchlen = bmatchlen;
			}
 		}
 	}
 	rcu_read_unlock();

 	if (baddr) {
 		fl6->saddr = baddr->v6.sin6_addr;
 		fl6->fl6_sport = baddr->v6.sin6_port;
		final_p = fl6_update_dst(fl6, np->opt, &final);
		dst = ip6_dst_lookup_flow(sk, fl6, final_p, false);
 	}
 
 out:
	if (!IS_ERR_OR_NULL(dst)) {
		struct rt6_info *rt;

		rt = (struct rt6_info *)dst;
		t->dst = dst;
		t->dst_cookie = rt->rt6i_node ? rt->rt6i_node->fn_sernum : 0;
		pr_debug(""rt6_dst:%pI6 rt6_src:%pI6\n"", &rt->rt6i_dst.addr,
			 &fl6->saddr);
	} else {
		t->dst = NULL;

		pr_debug(""no route\n"");
	}
}
","static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,
			    struct flowi *fl, struct sock *sk)
{
	struct sctp_association *asoc = t->asoc;
 	struct dst_entry *dst = NULL;
 	struct flowi6 *fl6 = &fl->u.ip6;
 	struct sctp_bind_addr *bp;
 	struct sctp_sockaddr_entry *laddr;
 	union sctp_addr *baddr = NULL;
 	union sctp_addr *daddr = &t->ipaddr;
 	union sctp_addr dst_saddr;
 	__u8 matchlen = 0;
 	__u8 bmatchlen;
 	sctp_scope_t scope;

	memset(fl6, 0, sizeof(struct flowi6));
	fl6->daddr = daddr->v6.sin6_addr;
	fl6->fl6_dport = daddr->v6.sin6_port;
	fl6->flowi6_proto = IPPROTO_SCTP;
	if (ipv6_addr_type(&daddr->v6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
		fl6->flowi6_oif = daddr->v6.sin6_scope_id;

	pr_debug(""%s: dst=%pI6 "", __func__, &fl6->daddr);

	if (asoc)
		fl6->fl6_sport = htons(asoc->base.bind_addr.port);

	if (saddr) {
		fl6->saddr = saddr->v6.sin6_addr;
		fl6->fl6_sport = saddr->v6.sin6_port;

 		pr_debug(""src=%pI6 - "", &fl6->saddr);
 	}
 
	dst = ip6_dst_lookup_flow(sk, fl6, NULL, false);
 	if (!asoc || saddr)
 		goto out;
 
	bp = &asoc->base.bind_addr;
	scope = sctp_scope(daddr);
	/* ip6_dst_lookup has filled in the fl6->saddr for us.  Check
	 * to see if we can use it.
	 */
	if (!IS_ERR(dst)) {
		/* Walk through the bind address list and look for a bind
		 * address that matches the source address of the returned dst.
		 */
		sctp_v6_to_addr(&dst_saddr, &fl6->saddr, htons(bp->port));
		rcu_read_lock();
		list_for_each_entry_rcu(laddr, &bp->address_list, list) {
			if (!laddr->valid || (laddr->state != SCTP_ADDR_SRC))
				continue;

			/* Do not compare against v4 addrs */
			if ((laddr->a.sa.sa_family == AF_INET6) &&
			    (sctp_v6_cmp_addr(&dst_saddr, &laddr->a))) {
				rcu_read_unlock();
				goto out;
			}
		}
		rcu_read_unlock();
		/* None of the bound addresses match the source address of the
		 * dst. So release it.
		 */
		dst_release(dst);
		dst = NULL;
	}

	/* Walk through the bind address list and try to get the
	 * best source address for a given destination.
	 */
	rcu_read_lock();
	list_for_each_entry_rcu(laddr, &bp->address_list, list) {
		if (!laddr->valid)
			continue;
		if ((laddr->state == SCTP_ADDR_SRC) &&
		    (laddr->a.sa.sa_family == AF_INET6) &&
		    (scope <= sctp_scope(&laddr->a))) {
			bmatchlen = sctp_v6_addr_match_len(daddr, &laddr->a);
			if (!baddr || (matchlen < bmatchlen)) {
				baddr = &laddr->a;
				matchlen = bmatchlen;
			}
 		}
 	}
 	rcu_read_unlock();
 	if (baddr) {
 		fl6->saddr = baddr->v6.sin6_addr;
 		fl6->fl6_sport = baddr->v6.sin6_port;
		dst = ip6_dst_lookup_flow(sk, fl6, NULL, false);
 	}
 
 out:
	if (!IS_ERR_OR_NULL(dst)) {
		struct rt6_info *rt;

		rt = (struct rt6_info *)dst;
		t->dst = dst;
		t->dst_cookie = rt->rt6i_node ? rt->rt6i_node->fn_sernum : 0;
		pr_debug(""rt6_dst:%pI6 rt6_src:%pI6\n"", &rt->rt6i_dst.addr,
			 &fl6->saddr);
	} else {
		t->dst = NULL;

		pr_debug(""no route\n"");
	}
}
",C,"	struct ipv6_pinfo *np = inet6_sk(sk);
	struct in6_addr *final_p, final;
	final_p = fl6_update_dst(fl6, np->opt, &final);
	dst = ip6_dst_lookup_flow(sk, fl6, final_p, false);

		final_p = fl6_update_dst(fl6, np->opt, &final);
		dst = ip6_dst_lookup_flow(sk, fl6, final_p, false);
","	dst = ip6_dst_lookup_flow(sk, fl6, NULL, false);
		dst = ip6_dst_lookup_flow(sk, fl6, NULL, false);
",,"@@ -204,44 +204,23 @@ static void sctp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 		in6_dev_put(idev);
 }
 
-/* Based on tcp_v6_xmit() in tcp_ipv6.c. */
 static int sctp_v6_xmit(struct sk_buff *skb, struct sctp_transport *transport)
 {
 	struct sock *sk = skb->sk;
 	struct ipv6_pinfo *np = inet6_sk(sk);
-	struct flowi6 fl6;
-
-	memset(&fl6, 0, sizeof(fl6));
-
-	fl6.flowi6_proto = sk->sk_protocol;
-
-	/* Fill in the dest address from the route entry passed with the skb
-	 * and the source address from the transport.
-	 */
-	fl6.daddr = transport->ipaddr.v6.sin6_addr;
-	fl6.saddr = transport->saddr.v6.sin6_addr;
-
-	fl6.flowlabel = np->flow_label;
-	IP6_ECN_flow_xmit(sk, fl6.flowlabel);
-	if (ipv6_addr_type(&fl6.saddr) & IPV6_ADDR_LINKLOCAL)
-		fl6.flowi6_oif = transport->saddr.v6.sin6_scope_id;
-	else
-		fl6.flowi6_oif = sk->sk_bound_dev_if;
-
-	if (np->opt && np->opt->srcrt) {
-		struct rt0_hdr *rt0 = (struct rt0_hdr *) np->opt->srcrt;
-		fl6.daddr = *rt0->addr;
-	}
+	struct flowi6 *fl6 = &transport->fl.u.ip6;
 
 	pr_debug(""%s: skb:%p, len:%d, src:%pI6 dst:%pI6\n"", __func__, skb,
-		 skb->len, &fl6.saddr, &fl6.daddr);
+		 skb->len, &fl6->saddr, &fl6->daddr);
 
-	SCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);
+	IP6_ECN_flow_xmit(sk, fl6->flowlabel);
 
 	if (!(transport->param_flags & SPP_PMTUD_ENABLE))
 		skb->local_df = 1;
 
-	return ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);
+	SCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);
+
+	return ip6_xmit(sk, skb, fl6, np->opt, np->tclass);
 }
 
 /* Returns the dst cache entry for the given source and destination ip
@@ -254,10 +233,12 @@ static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,
 	struct dst_entry *dst = NULL;
 	struct flowi6 *fl6 = &fl->u.ip6;
 	struct sctp_bind_addr *bp;
+	struct ipv6_pinfo *np = inet6_sk(sk);
 	struct sctp_sockaddr_entry *laddr;
 	union sctp_addr *baddr = NULL;
 	union sctp_addr *daddr = &t->ipaddr;
 	union sctp_addr dst_saddr;
+	struct in6_addr *final_p, final;
 	__u8 matchlen = 0;
 	__u8 bmatchlen;
 	sctp_scope_t scope;
@@ -281,7 +262,8 @@ static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,
 		pr_debug(""src=%pI6 - "", &fl6->saddr);
 	}
 
-	dst = ip6_dst_lookup_flow(sk, fl6, NULL, false);
+	final_p = fl6_update_dst(fl6, np->opt, &final);
+	dst = ip6_dst_lookup_flow(sk, fl6, final_p, false);
 	if (!asoc || saddr)
 		goto out;
 
@@ -333,10 +315,12 @@ static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,
 		}
 	}
 	rcu_read_unlock();
+
 	if (baddr) {
 		fl6->saddr = baddr->v6.sin6_addr;
 		fl6->fl6_sport = baddr->v6.sin6_port;
-		dst = ip6_dst_lookup_flow(sk, fl6, NULL, false);
+		final_p = fl6_update_dst(fl6, np->opt, &final);
+		dst = ip6_dst_lookup_flow(sk, fl6, final_p, false);
 	}
 
 out:",linux,95ee62083cb6453e056562d91f597552021e6ae7,662ca437e714caaab855b12415d6ffd815985bc0,1,"static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,
			    struct flowi *fl, struct sock *sk)
{
	struct sctp_association *asoc = t->asoc;
 	struct dst_entry *dst = NULL;
 	struct flowi6 *fl6 = &fl->u.ip6;
 	struct sctp_bind_addr *bp;
//fix_flaw_line_below:
//	struct ipv6_pinfo *np = inet6_sk(sk);
 	struct sctp_sockaddr_entry *laddr;
 	union sctp_addr *baddr = NULL;
 	union sctp_addr *daddr = &t->ipaddr;
 	union sctp_addr dst_saddr;
//fix_flaw_line_below:
//	struct in6_addr *final_p, final;
 	__u8 matchlen = 0;
 	__u8 bmatchlen;
 	sctp_scope_t scope;

	memset(fl6, 0, sizeof(struct flowi6));
	fl6->daddr = daddr->v6.sin6_addr;
	fl6->fl6_dport = daddr->v6.sin6_port;
	fl6->flowi6_proto = IPPROTO_SCTP;
	if (ipv6_addr_type(&daddr->v6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
		fl6->flowi6_oif = daddr->v6.sin6_scope_id;

	pr_debug(""%s: dst=%pI6 "", __func__, &fl6->daddr);

	if (asoc)
		fl6->fl6_sport = htons(asoc->base.bind_addr.port);

	if (saddr) {
		fl6->saddr = saddr->v6.sin6_addr;
		fl6->fl6_sport = saddr->v6.sin6_port;

 		pr_debug(""src=%pI6 - "", &fl6->saddr);
 	}
 
//flaw_line_below:
	dst = ip6_dst_lookup_flow(sk, fl6, NULL, false);
//fix_flaw_line_below:
//	final_p = fl6_update_dst(fl6, np->opt, &final);
//fix_flaw_line_below:
//	dst = ip6_dst_lookup_flow(sk, fl6, final_p, false);
 	if (!asoc || saddr)
 		goto out;
 
	bp = &asoc->base.bind_addr;
	scope = sctp_scope(daddr);
	/* ip6_dst_lookup has filled in the fl6->saddr for us.  Check
	 * to see if we can use it.
	 */
	if (!IS_ERR(dst)) {
		/* Walk through the bind address list and look for a bind
		 * address that matches the source address of the returned dst.
		 */
		sctp_v6_to_addr(&dst_saddr, &fl6->saddr, htons(bp->port));
		rcu_read_lock();
		list_for_each_entry_rcu(laddr, &bp->address_list, list) {
			if (!laddr->valid || (laddr->state != SCTP_ADDR_SRC))
				continue;

			/* Do not compare against v4 addrs */
			if ((laddr->a.sa.sa_family == AF_INET6) &&
			    (sctp_v6_cmp_addr(&dst_saddr, &laddr->a))) {
				rcu_read_unlock();
				goto out;
			}
		}
		rcu_read_unlock();
		/* None of the bound addresses match the source address of the
		 * dst. So release it.
		 */
		dst_release(dst);
		dst = NULL;
	}

	/* Walk through the bind address list and try to get the
	 * best source address for a given destination.
	 */
	rcu_read_lock();
	list_for_each_entry_rcu(laddr, &bp->address_list, list) {
		if (!laddr->valid)
			continue;
		if ((laddr->state == SCTP_ADDR_SRC) &&
		    (laddr->a.sa.sa_family == AF_INET6) &&
		    (scope <= sctp_scope(&laddr->a))) {
			bmatchlen = sctp_v6_addr_match_len(daddr, &laddr->a);
			if (!baddr || (matchlen < bmatchlen)) {
				baddr = &laddr->a;
				matchlen = bmatchlen;
			}
 		}
 	}
 	rcu_read_unlock();
//fix_flaw_line_below:
//
 	if (baddr) {
 		fl6->saddr = baddr->v6.sin6_addr;
 		fl6->fl6_sport = baddr->v6.sin6_port;
//flaw_line_below:
		dst = ip6_dst_lookup_flow(sk, fl6, NULL, false);
//fix_flaw_line_below:
//		final_p = fl6_update_dst(fl6, np->opt, &final);
//fix_flaw_line_below:
//		dst = ip6_dst_lookup_flow(sk, fl6, final_p, false);
 	}
 
 out:
	if (!IS_ERR_OR_NULL(dst)) {
		struct rt6_info *rt;

		rt = (struct rt6_info *)dst;
		t->dst = dst;
		t->dst_cookie = rt->rt6i_node ? rt->rt6i_node->fn_sernum : 0;
		pr_debug(""rt6_dst:%pI6 rt6_src:%pI6\n"", &rt->rt6i_dst.addr,
			 &fl6->saddr);
	} else {
		t->dst = NULL;

		pr_debug(""no route\n"");
	}
}
"
1426,179162,,Remote,Not required,,CVE-2013-4350,https://www.cvedetails.com/cve/CVE-2013-4350/,CWE-310,Low,Partial,,,2013-09-25,5.0,"The IPv6 SCTP implementation in net/sctp/ipv6.c in the Linux kernel through 3.11.1 uses data structures and function calls that do not trigger an intended configuration of IPsec encryption, which allows remote attackers to obtain sensitive information by sniffing the network.",2014-01-03,+Info ,6,https://github.com/torvalds/linux/commit/95ee62083cb6453e056562d91f597552021e6ae7,95ee62083cb6453e056562d91f597552021e6ae7,"net: sctp: fix ipv6 ipsec encryption bug in sctp_v6_xmit

Alan Chester reported an issue with IPv6 on SCTP that IPsec traffic is not
being encrypted, whereas on IPv4 it is. Setting up an AH + ESP transport
does not seem to have the desired effect:

SCTP + IPv4:

  22:14:20.809645 IP (tos 0x2,ECT(0), ttl 64, id 0, offset 0, flags [DF], proto AH (51), length 116)
    192.168.0.2 > 192.168.0.5: AH(spi=0x00000042,sumlen=16,seq=0x1): ESP(spi=0x00000044,seq=0x1), length 72
  22:14:20.813270 IP (tos 0x2,ECT(0), ttl 64, id 0, offset 0, flags [DF], proto AH (51), length 340)
    192.168.0.5 > 192.168.0.2: AH(spi=0x00000043,sumlen=16,seq=0x1):

SCTP + IPv6:

  22:31:19.215029 IP6 (class 0x02, hlim 64, next-header SCTP (132) payload length: 364)
    fe80::222:15ff:fe87:7fc.3333 > fe80::92e6:baff:fe0d:5a54.36767: sctp
    1) [INIT ACK] [init tag: 747759530] [rwnd: 62464] [OS: 10] [MIS: 10]

Moreover, Alan says:

  This problem was seen with both Racoon and Racoon2. Other people have seen
  this with OpenSwan. When IPsec is configured to encrypt all upper layer
  protocols the SCTP connection does not initialize. After using Wireshark to
  follow packets, this is because the SCTP packet leaves Box A unencrypted and
  Box B believes all upper layer protocols are to be encrypted so it drops
  this packet, causing the SCTP connection to fail to initialize. When IPsec
  is configured to encrypt just SCTP, the SCTP packets are observed unencrypted.

In fact, using `socat sctp6-listen:3333 -` on one end and transferring ""plaintext""
string on the other end, results in cleartext on the wire where SCTP eventually
does not report any errors, thus in the latter case that Alan reports, the
non-paranoid user might think he's communicating over an encrypted transport on
SCTP although he's not (tcpdump ... -X):

  ...
  0x0030: 5d70 8e1a 0003 001a 177d eb6c 0000 0000  ]p.......}.l....
  0x0040: 0000 0000 706c 6169 6e74 6578 740a 0000  ....plaintext...

Only in /proc/net/xfrm_stat we can see XfrmInTmplMismatch increasing on the
receiver side. Initial follow-up analysis from Alan's bug report was done by
Alexey Dobriyan. Also thanks to Vlad Yasevich for feedback on this.

SCTP has its own implementation of sctp_v6_xmit() not calling inet6_csk_xmit().
This has the implication that it probably never really got updated along with
changes in inet6_csk_xmit() and therefore does not seem to invoke xfrm handlers.

SCTP's IPv4 xmit however, properly calls ip_queue_xmit() to do the work. Since
a call to inet6_csk_xmit() would solve this problem, but result in unecessary
route lookups, let us just use the cached flowi6 instead that we got through
sctp_v6_get_dst(). Since all SCTP packets are being sent through sctp_packet_transmit(),
we do the route lookup / flow caching in sctp_transport_route(), hold it in
tp->dst and skb_dst_set() right after that. If we would alter fl6->daddr in
sctp_v6_xmit() to np->opt->srcrt, we possibly could run into the same effect
of not having xfrm layer pick it up, hence, use fl6_update_dst() in sctp_v6_get_dst()
instead to get the correct source routed dst entry, which we assign to the skb.

Also source address routing example from 625034113 (""sctp: fix sctp to work with
ipv6 source address routing"") still works with this patch! Nevertheless, in RFC5095
it is actually 'recommended' to not use that anyway due to traffic amplification [1].
So it seems we're not supposed to do that anyway in sctp_v6_xmit(). Moreover, if
we overwrite the flow destination here, the lower IPv6 layer will be unable to
put the correct destination address into IP header, as routing header is added in
ipv6_push_nfrag_opts() but then probably with wrong final destination. Things aside,
result of this patch is that we do not have any XfrmInTmplMismatch increase plus on
the wire with this patch it now looks like:

SCTP + IPv6:

  08:17:47.074080 IP6 2620:52:0:102f:7a2b:cbff:fe27:1b0a > 2620:52:0:102f:213:72ff:fe32:7eba:
    AH(spi=0x00005fb4,seq=0x1): ESP(spi=0x00005fb5,seq=0x1), length 72
  08:17:47.074264 IP6 2620:52:0:102f:213:72ff:fe32:7eba > 2620:52:0:102f:7a2b:cbff:fe27:1b0a:
    AH(spi=0x00003d54,seq=0x1): ESP(spi=0x00003d55,seq=0x1), length 296

This fixes Kernel Bugzilla 24412. This security issue seems to be present since
2.6.18 kernels. Lets just hope some big passive adversary in the wild didn't have
its fun with that. lksctp-tools IPv6 regression test suite passes as well with
this patch.

 [1] http://www.secdev.org/conf/IPv6_RH_security-csw07.pdf

Reported-by: Alan Chester <alan.chester@tekelec.com>
Reported-by: Alexey Dobriyan <adobriyan@gmail.com>
Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
Cc: Steffen Klassert <steffen.klassert@secunet.com>
Cc: Hannes Frederic Sowa <hannes@stressinduktion.org>
Acked-by: Vlad Yasevich <vyasevich@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",21,net/sctp/ipv6.c,"{""sha"": ""4f52e2ce263d0852bf01cc286560f8d13fbe208a"", ""filename"": ""net/sctp/ipv6.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 29, ""changes"": 42, ""blob_url"": ""https://github.com/torvalds/linux/blob/95ee62083cb6453e056562d91f597552021e6ae7/net/sctp/ipv6.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/95ee62083cb6453e056562d91f597552021e6ae7/net/sctp/ipv6.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/sctp/ipv6.c?ref=95ee62083cb6453e056562d91f597552021e6ae7"", ""patch"": ""@@ -204,44 +204,23 @@ static void sctp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n \t\tin6_dev_put(idev);\n }\n \n-/* Based on tcp_v6_xmit() in tcp_ipv6.c. */\n static int sctp_v6_xmit(struct sk_buff *skb, struct sctp_transport *transport)\n {\n \tstruct sock *sk = skb->sk;\n \tstruct ipv6_pinfo *np = inet6_sk(sk);\n-\tstruct flowi6 fl6;\n-\n-\tmemset(&fl6, 0, sizeof(fl6));\n-\n-\tfl6.flowi6_proto = sk->sk_protocol;\n-\n-\t/* Fill in the dest address from the route entry passed with the skb\n-\t * and the source address from the transport.\n-\t */\n-\tfl6.daddr = transport->ipaddr.v6.sin6_addr;\n-\tfl6.saddr = transport->saddr.v6.sin6_addr;\n-\n-\tfl6.flowlabel = np->flow_label;\n-\tIP6_ECN_flow_xmit(sk, fl6.flowlabel);\n-\tif (ipv6_addr_type(&fl6.saddr) & IPV6_ADDR_LINKLOCAL)\n-\t\tfl6.flowi6_oif = transport->saddr.v6.sin6_scope_id;\n-\telse\n-\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n-\n-\tif (np->opt && np->opt->srcrt) {\n-\t\tstruct rt0_hdr *rt0 = (struct rt0_hdr *) np->opt->srcrt;\n-\t\tfl6.daddr = *rt0->addr;\n-\t}\n+\tstruct flowi6 *fl6 = &transport->fl.u.ip6;\n \n \tpr_debug(\""%s: skb:%p, len:%d, src:%pI6 dst:%pI6\\n\"", __func__, skb,\n-\t\t skb->len, &fl6.saddr, &fl6.daddr);\n+\t\t skb->len, &fl6->saddr, &fl6->daddr);\n \n-\tSCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);\n+\tIP6_ECN_flow_xmit(sk, fl6->flowlabel);\n \n \tif (!(transport->param_flags & SPP_PMTUD_ENABLE))\n \t\tskb->local_df = 1;\n \n-\treturn ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n+\tSCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);\n+\n+\treturn ip6_xmit(sk, skb, fl6, np->opt, np->tclass);\n }\n \n /* Returns the dst cache entry for the given source and destination ip\n@@ -254,10 +233,12 @@ static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,\n \tstruct dst_entry *dst = NULL;\n \tstruct flowi6 *fl6 = &fl->u.ip6;\n \tstruct sctp_bind_addr *bp;\n+\tstruct ipv6_pinfo *np = inet6_sk(sk);\n \tstruct sctp_sockaddr_entry *laddr;\n \tunion sctp_addr *baddr = NULL;\n \tunion sctp_addr *daddr = &t->ipaddr;\n \tunion sctp_addr dst_saddr;\n+\tstruct in6_addr *final_p, final;\n \t__u8 matchlen = 0;\n \t__u8 bmatchlen;\n \tsctp_scope_t scope;\n@@ -281,7 +262,8 @@ static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,\n \t\tpr_debug(\""src=%pI6 - \"", &fl6->saddr);\n \t}\n \n-\tdst = ip6_dst_lookup_flow(sk, fl6, NULL, false);\n+\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n+\tdst = ip6_dst_lookup_flow(sk, fl6, final_p, false);\n \tif (!asoc || saddr)\n \t\tgoto out;\n \n@@ -333,10 +315,12 @@ static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,\n \t\t}\n \t}\n \trcu_read_unlock();\n+\n \tif (baddr) {\n \t\tfl6->saddr = baddr->v6.sin6_addr;\n \t\tfl6->fl6_sport = baddr->v6.sin6_port;\n-\t\tdst = ip6_dst_lookup_flow(sk, fl6, NULL, false);\n+\t\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n+\t\tdst = ip6_dst_lookup_flow(sk, fl6, final_p, false);\n \t}\n \n out:""}"," static int sctp_v6_xmit(struct sk_buff *skb, struct sctp_transport *transport)
 {
 	struct sock *sk = skb->sk;
 	struct ipv6_pinfo *np = inet6_sk(sk);
	struct flowi6 *fl6 = &transport->fl.u.ip6;
 
 	pr_debug(""%s: skb:%p, len:%d, src:%pI6 dst:%pI6\n"", __func__, skb,
		 skb->len, &fl6->saddr, &fl6->daddr);
 
	IP6_ECN_flow_xmit(sk, fl6->flowlabel);
 
 	if (!(transport->param_flags & SPP_PMTUD_ENABLE))
 		skb->local_df = 1;
 
	SCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);

	return ip6_xmit(sk, skb, fl6, np->opt, np->tclass);
 }
"," static int sctp_v6_xmit(struct sk_buff *skb, struct sctp_transport *transport)
 {
 	struct sock *sk = skb->sk;
 	struct ipv6_pinfo *np = inet6_sk(sk);
	struct flowi6 fl6;
	memset(&fl6, 0, sizeof(fl6));
	fl6.flowi6_proto = sk->sk_protocol;
	/* Fill in the dest address from the route entry passed with the skb
	 * and the source address from the transport.
	 */
	fl6.daddr = transport->ipaddr.v6.sin6_addr;
	fl6.saddr = transport->saddr.v6.sin6_addr;
	fl6.flowlabel = np->flow_label;
	IP6_ECN_flow_xmit(sk, fl6.flowlabel);
	if (ipv6_addr_type(&fl6.saddr) & IPV6_ADDR_LINKLOCAL)
		fl6.flowi6_oif = transport->saddr.v6.sin6_scope_id;
	else
		fl6.flowi6_oif = sk->sk_bound_dev_if;
	if (np->opt && np->opt->srcrt) {
		struct rt0_hdr *rt0 = (struct rt0_hdr *) np->opt->srcrt;
		fl6.daddr = *rt0->addr;
	}
 
 	pr_debug(""%s: skb:%p, len:%d, src:%pI6 dst:%pI6\n"", __func__, skb,
		 skb->len, &fl6.saddr, &fl6.daddr);
 
	SCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);
 
 	if (!(transport->param_flags & SPP_PMTUD_ENABLE))
 		skb->local_df = 1;
 
	return ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);
 }
",C,"	struct flowi6 *fl6 = &transport->fl.u.ip6;
		 skb->len, &fl6->saddr, &fl6->daddr);
	IP6_ECN_flow_xmit(sk, fl6->flowlabel);
	SCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);

	return ip6_xmit(sk, skb, fl6, np->opt, np->tclass);
","	struct flowi6 fl6;
	memset(&fl6, 0, sizeof(fl6));
	fl6.flowi6_proto = sk->sk_protocol;
	/* Fill in the dest address from the route entry passed with the skb
	 * and the source address from the transport.
	 */
	fl6.daddr = transport->ipaddr.v6.sin6_addr;
	fl6.saddr = transport->saddr.v6.sin6_addr;
	fl6.flowlabel = np->flow_label;
	IP6_ECN_flow_xmit(sk, fl6.flowlabel);
	if (ipv6_addr_type(&fl6.saddr) & IPV6_ADDR_LINKLOCAL)
		fl6.flowi6_oif = transport->saddr.v6.sin6_scope_id;
	else
		fl6.flowi6_oif = sk->sk_bound_dev_if;
	if (np->opt && np->opt->srcrt) {
		struct rt0_hdr *rt0 = (struct rt0_hdr *) np->opt->srcrt;
		fl6.daddr = *rt0->addr;
	}
		 skb->len, &fl6.saddr, &fl6.daddr);
	SCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);
	return ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);
",,"@@ -204,44 +204,23 @@ static void sctp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 		in6_dev_put(idev);
 }
 
-/* Based on tcp_v6_xmit() in tcp_ipv6.c. */
 static int sctp_v6_xmit(struct sk_buff *skb, struct sctp_transport *transport)
 {
 	struct sock *sk = skb->sk;
 	struct ipv6_pinfo *np = inet6_sk(sk);
-	struct flowi6 fl6;
-
-	memset(&fl6, 0, sizeof(fl6));
-
-	fl6.flowi6_proto = sk->sk_protocol;
-
-	/* Fill in the dest address from the route entry passed with the skb
-	 * and the source address from the transport.
-	 */
-	fl6.daddr = transport->ipaddr.v6.sin6_addr;
-	fl6.saddr = transport->saddr.v6.sin6_addr;
-
-	fl6.flowlabel = np->flow_label;
-	IP6_ECN_flow_xmit(sk, fl6.flowlabel);
-	if (ipv6_addr_type(&fl6.saddr) & IPV6_ADDR_LINKLOCAL)
-		fl6.flowi6_oif = transport->saddr.v6.sin6_scope_id;
-	else
-		fl6.flowi6_oif = sk->sk_bound_dev_if;
-
-	if (np->opt && np->opt->srcrt) {
-		struct rt0_hdr *rt0 = (struct rt0_hdr *) np->opt->srcrt;
-		fl6.daddr = *rt0->addr;
-	}
+	struct flowi6 *fl6 = &transport->fl.u.ip6;
 
 	pr_debug(""%s: skb:%p, len:%d, src:%pI6 dst:%pI6\n"", __func__, skb,
-		 skb->len, &fl6.saddr, &fl6.daddr);
+		 skb->len, &fl6->saddr, &fl6->daddr);
 
-	SCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);
+	IP6_ECN_flow_xmit(sk, fl6->flowlabel);
 
 	if (!(transport->param_flags & SPP_PMTUD_ENABLE))
 		skb->local_df = 1;
 
-	return ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);
+	SCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);
+
+	return ip6_xmit(sk, skb, fl6, np->opt, np->tclass);
 }
 
 /* Returns the dst cache entry for the given source and destination ip
@@ -254,10 +233,12 @@ static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,
 	struct dst_entry *dst = NULL;
 	struct flowi6 *fl6 = &fl->u.ip6;
 	struct sctp_bind_addr *bp;
+	struct ipv6_pinfo *np = inet6_sk(sk);
 	struct sctp_sockaddr_entry *laddr;
 	union sctp_addr *baddr = NULL;
 	union sctp_addr *daddr = &t->ipaddr;
 	union sctp_addr dst_saddr;
+	struct in6_addr *final_p, final;
 	__u8 matchlen = 0;
 	__u8 bmatchlen;
 	sctp_scope_t scope;
@@ -281,7 +262,8 @@ static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,
 		pr_debug(""src=%pI6 - "", &fl6->saddr);
 	}
 
-	dst = ip6_dst_lookup_flow(sk, fl6, NULL, false);
+	final_p = fl6_update_dst(fl6, np->opt, &final);
+	dst = ip6_dst_lookup_flow(sk, fl6, final_p, false);
 	if (!asoc || saddr)
 		goto out;
 
@@ -333,10 +315,12 @@ static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,
 		}
 	}
 	rcu_read_unlock();
+
 	if (baddr) {
 		fl6->saddr = baddr->v6.sin6_addr;
 		fl6->fl6_sport = baddr->v6.sin6_port;
-		dst = ip6_dst_lookup_flow(sk, fl6, NULL, false);
+		final_p = fl6_update_dst(fl6, np->opt, &final);
+		dst = ip6_dst_lookup_flow(sk, fl6, final_p, false);
 	}
 
 out:",linux,95ee62083cb6453e056562d91f597552021e6ae7,662ca437e714caaab855b12415d6ffd815985bc0,1," static int sctp_v6_xmit(struct sk_buff *skb, struct sctp_transport *transport)
 {
 	struct sock *sk = skb->sk;
 	struct ipv6_pinfo *np = inet6_sk(sk);
//flaw_line_below:
	struct flowi6 fl6;
//flaw_line_below:

//flaw_line_below:
	memset(&fl6, 0, sizeof(fl6));
//flaw_line_below:

//flaw_line_below:
	fl6.flowi6_proto = sk->sk_protocol;
//flaw_line_below:

//flaw_line_below:
	/* Fill in the dest address from the route entry passed with the skb
//flaw_line_below:
	 * and the source address from the transport.
//flaw_line_below:
	 */
//flaw_line_below:
	fl6.daddr = transport->ipaddr.v6.sin6_addr;
//flaw_line_below:
	fl6.saddr = transport->saddr.v6.sin6_addr;
//flaw_line_below:

//flaw_line_below:
	fl6.flowlabel = np->flow_label;
//flaw_line_below:
	IP6_ECN_flow_xmit(sk, fl6.flowlabel);
//flaw_line_below:
	if (ipv6_addr_type(&fl6.saddr) & IPV6_ADDR_LINKLOCAL)
//flaw_line_below:
		fl6.flowi6_oif = transport->saddr.v6.sin6_scope_id;
//flaw_line_below:
	else
//flaw_line_below:
		fl6.flowi6_oif = sk->sk_bound_dev_if;
//flaw_line_below:

//flaw_line_below:
	if (np->opt && np->opt->srcrt) {
//flaw_line_below:
		struct rt0_hdr *rt0 = (struct rt0_hdr *) np->opt->srcrt;
//flaw_line_below:
		fl6.daddr = *rt0->addr;
//flaw_line_below:
	}
//fix_flaw_line_below:
//	struct flowi6 *fl6 = &transport->fl.u.ip6;
 
 	pr_debug(""%s: skb:%p, len:%d, src:%pI6 dst:%pI6\n"", __func__, skb,
//flaw_line_below:
		 skb->len, &fl6.saddr, &fl6.daddr);
//fix_flaw_line_below:
//		 skb->len, &fl6->saddr, &fl6->daddr);
 
//flaw_line_below:
	SCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);
//fix_flaw_line_below:
//	IP6_ECN_flow_xmit(sk, fl6->flowlabel);
 
 	if (!(transport->param_flags & SPP_PMTUD_ENABLE))
 		skb->local_df = 1;
 
//flaw_line_below:
	return ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);
//fix_flaw_line_below:
//	SCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	return ip6_xmit(sk, skb, fl6, np->opt, np->tclass);
 }
"
1497,179233,,Local,Not required,,CVE-2013-2548,https://www.cvedetails.com/cve/CVE-2013-2548/,CWE-310,Low,Partial,,,2013-03-15,2.1,"The crypto_report_one function in crypto/crypto_user.c in the report API in the crypto user configuration API in the Linux kernel through 3.8.2 uses an incorrect length value during a copy operation, which allows local users to obtain sensitive information from kernel memory by leveraging the CAP_NET_ADMIN capability.",2014-01-03,+Info ,3,https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,"crypto: user - fix info leaks in report API

Three errors resulting in kernel memory disclosure:

1/ The structures used for the netlink based crypto algorithm report API
are located on the stack. As snprintf() does not fill the remainder of
the buffer with null bytes, those stack bytes will be disclosed to users
of the API. Switch to strncpy() to fix this.

2/ crypto_report_one() does not initialize all field of struct
crypto_user_alg. Fix this to fix the heap info leak.

3/ For the module name we should copy only as many bytes as
module_name() returns -- not as much as the destination buffer could
hold. But the current code does not and therefore copies random data
from behind the end of the module name, as the module name is always
shorter than CRYPTO_MAX_ALG_NAME.

Also switch to use strncpy() to copy the algorithm's name and
driver_name. They are strings, after all.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Cc: Steffen Klassert <steffen.klassert@secunet.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",3,crypto/ablkcipher.c,"{""sha"": ""7d4a8d28277e181386981dcef2d73ec377aefe9a"", ""filename"": ""crypto/ablkcipher.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ablkcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ablkcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ablkcipher.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -388,9 +388,9 @@ static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""ablkcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_ablkcipher.geniv ?: \""<default>\"");\n+\tstrncpy(rblkcipher.type, \""ablkcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \""<default>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n@@ -469,9 +469,9 @@ static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""givcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_ablkcipher.geniv ?: \""<built-in>\"");\n+\tstrncpy(rblkcipher.type, \""givcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \""<built-in>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;""}<_**next**_>{""sha"": ""547491e35c63733f15ccb4697cf83109128125aa"", ""filename"": ""crypto/aead.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/aead.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/aead.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/aead.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -117,9 +117,8 @@ static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n-\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""aead\"");\n-\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t aead->geniv ?: \""<built-in>\"");\n+\tstrncpy(raead.type, \""aead\"", sizeof(raead.type));\n+\tstrncpy(raead.geniv, aead->geniv ?: \""<built-in>\"", sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;\n@@ -203,8 +202,8 @@ static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n-\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""nivaead\"");\n-\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"", aead->geniv);\n+\tstrncpy(raead.type, \""nivaead\"", sizeof(raead.type));\n+\tstrncpy(raead.geniv, aead->geniv, sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;""}<_**next**_>{""sha"": ""793a27f2493e5287c1275df40feaca7b7b14c87e"", ""filename"": ""crypto/ahash.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ahash.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ahash.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ahash.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -404,7 +404,7 @@ static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_hash rhash;\n \n-\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""ahash\"");\n+\tstrncpy(rhash.type, \""ahash\"", sizeof(rhash.type));\n \n \trhash.blocksize = alg->cra_blocksize;\n \trhash.digestsize = __crypto_hash_alg_common(alg)->digestsize;""}<_**next**_>{""sha"": ""a79e7e9ab86e890d7eed95f3038b4424323a70f5"", ""filename"": ""crypto/blkcipher.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/blkcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/blkcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/blkcipher.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -499,9 +499,9 @@ static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""blkcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_blkcipher.geniv ?: \""<default>\"");\n+\tstrncpy(rblkcipher.type, \""blkcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_blkcipher.geniv ?: \""<default>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;""}<_**next**_>{""sha"": ""f6d9baf77f0a41b76b0fc39aebf26365a1284bca"", ""filename"": ""crypto/crypto_user.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 11, ""changes"": 22, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/crypto_user.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/crypto_user.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crypto_user.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -75,7 +75,7 @@ static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_cipher rcipher;\n \n-\tsnprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""cipher\"");\n+\tstrncpy(rcipher.type, \""cipher\"", sizeof(rcipher.type));\n \n \trcipher.blocksize = alg->cra_blocksize;\n \trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n@@ -94,8 +94,7 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_comp rcomp;\n \n-\tsnprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""compression\"");\n-\n+\tstrncpy(rcomp.type, \""compression\"", sizeof(rcomp.type));\n \tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n \t\t    sizeof(struct crypto_report_comp), &rcomp))\n \t\tgoto nla_put_failure;\n@@ -108,12 +107,14 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n static int crypto_report_one(struct crypto_alg *alg,\n \t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n {\n-\tmemcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));\n-\tmemcpy(&ualg->cru_driver_name, &alg->cra_driver_name,\n-\t       sizeof(ualg->cru_driver_name));\n-\tmemcpy(&ualg->cru_module_name, module_name(alg->cra_module),\n-\t       CRYPTO_MAX_ALG_NAME);\n-\n+\tstrncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n+\tstrncpy(ualg->cru_driver_name, alg->cra_driver_name,\n+\t\tsizeof(ualg->cru_driver_name));\n+\tstrncpy(ualg->cru_module_name, module_name(alg->cra_module),\n+\t\tsizeof(ualg->cru_module_name));\n+\n+\tualg->cru_type = 0;\n+\tualg->cru_mask = 0;\n \tualg->cru_flags = alg->cra_flags;\n \tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n \n@@ -122,8 +123,7 @@ static int crypto_report_one(struct crypto_alg *alg,\n \tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n \t\tstruct crypto_report_larval rl;\n \n-\t\tsnprintf(rl.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""larval\"");\n-\n+\t\tstrncpy(rl.type, \""larval\"", sizeof(rl.type));\n \t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n \t\t\t    sizeof(struct crypto_report_larval), &rl))\n \t\t\tgoto nla_put_failure;""}<_**next**_>{""sha"": ""7140fe70c7af04b2f544839b734de9aa5c461533"", ""filename"": ""crypto/pcompress.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/pcompress.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/pcompress.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/pcompress.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -53,8 +53,7 @@ static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_comp rpcomp;\n \n-\tsnprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""pcomp\"");\n-\n+\tstrncpy(rpcomp.type, \""pcomp\"", sizeof(rpcomp.type));\n \tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n \t\t    sizeof(struct crypto_report_comp), &rpcomp))\n \t\tgoto nla_put_failure;""}<_**next**_>{""sha"": ""e0a25c2456de4f7f92fa4ac1cc4daf9c48b5b209"", ""filename"": ""crypto/rng.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/rng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/rng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rng.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -65,7 +65,7 @@ static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_rng rrng;\n \n-\tsnprintf(rrng.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""rng\"");\n+\tstrncpy(rrng.type, \""rng\"", sizeof(rrng.type));\n \n \trrng.seedsize = alg->cra_rng.seedsize;\n ""}<_**next**_>{""sha"": ""929058a68561264c389719e26a3d22704bbbe18e"", ""filename"": ""crypto/shash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/shash.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/shash.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/shash.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -530,7 +530,8 @@ static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_hash rhash;\n \tstruct shash_alg *salg = __crypto_shash_alg(alg);\n \n-\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""shash\"");\n+\tstrncpy(rhash.type, \""shash\"", sizeof(rhash.type));\n+\n \trhash.blocksize = alg->cra_blocksize;\n \trhash.digestsize = salg->digestsize;\n ""}","static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_blkcipher rblkcipher;
 
	strncpy(rblkcipher.type, ""ablkcipher"", sizeof(rblkcipher.type));
	strncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: ""<default>"",
		sizeof(rblkcipher.geniv));
 
 	rblkcipher.blocksize = alg->cra_blocksize;
 	rblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;
	rblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;
	rblkcipher.ivsize = alg->cra_ablkcipher.ivsize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,
		    sizeof(struct crypto_report_blkcipher), &rblkcipher))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
","static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_blkcipher rblkcipher;
 
	snprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""ablkcipher"");
	snprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, ""%s"",
		 alg->cra_ablkcipher.geniv ?: ""<default>"");
 
 	rblkcipher.blocksize = alg->cra_blocksize;
 	rblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;
	rblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;
	rblkcipher.ivsize = alg->cra_ablkcipher.ivsize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,
		    sizeof(struct crypto_report_blkcipher), &rblkcipher))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
",C,"	strncpy(rblkcipher.type, ""ablkcipher"", sizeof(rblkcipher.type));
	strncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: ""<default>"",
		sizeof(rblkcipher.geniv));
","	snprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""ablkcipher"");
	snprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, ""%s"",
		 alg->cra_ablkcipher.geniv ?: ""<default>"");
",,"@@ -388,9 +388,9 @@ static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_blkcipher rblkcipher;
 
-	snprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""ablkcipher"");
-	snprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, ""%s"",
-		 alg->cra_ablkcipher.geniv ?: ""<default>"");
+	strncpy(rblkcipher.type, ""ablkcipher"", sizeof(rblkcipher.type));
+	strncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: ""<default>"",
+		sizeof(rblkcipher.geniv));
 
 	rblkcipher.blocksize = alg->cra_blocksize;
 	rblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;
@@ -469,9 +469,9 @@ static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_blkcipher rblkcipher;
 
-	snprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""givcipher"");
-	snprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, ""%s"",
-		 alg->cra_ablkcipher.geniv ?: ""<built-in>"");
+	strncpy(rblkcipher.type, ""givcipher"", sizeof(rblkcipher.type));
+	strncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: ""<built-in>"",
+		sizeof(rblkcipher.geniv));
 
 	rblkcipher.blocksize = alg->cra_blocksize;
 	rblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;",linux,9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,7eb9c5df92361c55daab4d8d4e8468eb774e297b,1,"static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_blkcipher rblkcipher;
 
//flaw_line_below:
	snprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""ablkcipher"");
//flaw_line_below:
	snprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, ""%s"",
//flaw_line_below:
		 alg->cra_ablkcipher.geniv ?: ""<default>"");
//fix_flaw_line_below:
//	strncpy(rblkcipher.type, ""ablkcipher"", sizeof(rblkcipher.type));
//fix_flaw_line_below:
//	strncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: ""<default>"",
//fix_flaw_line_below:
//		sizeof(rblkcipher.geniv));
 
 	rblkcipher.blocksize = alg->cra_blocksize;
 	rblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;
	rblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;
	rblkcipher.ivsize = alg->cra_ablkcipher.ivsize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,
		    sizeof(struct crypto_report_blkcipher), &rblkcipher))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
"
1498,179234,,Local,Not required,,CVE-2013-2548,https://www.cvedetails.com/cve/CVE-2013-2548/,CWE-310,Low,Partial,,,2013-03-15,2.1,"The crypto_report_one function in crypto/crypto_user.c in the report API in the crypto user configuration API in the Linux kernel through 3.8.2 uses an incorrect length value during a copy operation, which allows local users to obtain sensitive information from kernel memory by leveraging the CAP_NET_ADMIN capability.",2014-01-03,+Info ,3,https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,"crypto: user - fix info leaks in report API

Three errors resulting in kernel memory disclosure:

1/ The structures used for the netlink based crypto algorithm report API
are located on the stack. As snprintf() does not fill the remainder of
the buffer with null bytes, those stack bytes will be disclosed to users
of the API. Switch to strncpy() to fix this.

2/ crypto_report_one() does not initialize all field of struct
crypto_user_alg. Fix this to fix the heap info leak.

3/ For the module name we should copy only as many bytes as
module_name() returns -- not as much as the destination buffer could
hold. But the current code does not and therefore copies random data
from behind the end of the module name, as the module name is always
shorter than CRYPTO_MAX_ALG_NAME.

Also switch to use strncpy() to copy the algorithm's name and
driver_name. They are strings, after all.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Cc: Steffen Klassert <steffen.klassert@secunet.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",3,crypto/ablkcipher.c,"{""sha"": ""7d4a8d28277e181386981dcef2d73ec377aefe9a"", ""filename"": ""crypto/ablkcipher.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ablkcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ablkcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ablkcipher.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -388,9 +388,9 @@ static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""ablkcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_ablkcipher.geniv ?: \""<default>\"");\n+\tstrncpy(rblkcipher.type, \""ablkcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \""<default>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n@@ -469,9 +469,9 @@ static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""givcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_ablkcipher.geniv ?: \""<built-in>\"");\n+\tstrncpy(rblkcipher.type, \""givcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \""<built-in>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;""}<_**next**_>{""sha"": ""547491e35c63733f15ccb4697cf83109128125aa"", ""filename"": ""crypto/aead.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/aead.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/aead.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/aead.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -117,9 +117,8 @@ static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n-\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""aead\"");\n-\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t aead->geniv ?: \""<built-in>\"");\n+\tstrncpy(raead.type, \""aead\"", sizeof(raead.type));\n+\tstrncpy(raead.geniv, aead->geniv ?: \""<built-in>\"", sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;\n@@ -203,8 +202,8 @@ static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n-\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""nivaead\"");\n-\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"", aead->geniv);\n+\tstrncpy(raead.type, \""nivaead\"", sizeof(raead.type));\n+\tstrncpy(raead.geniv, aead->geniv, sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;""}<_**next**_>{""sha"": ""793a27f2493e5287c1275df40feaca7b7b14c87e"", ""filename"": ""crypto/ahash.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ahash.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ahash.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ahash.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -404,7 +404,7 @@ static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_hash rhash;\n \n-\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""ahash\"");\n+\tstrncpy(rhash.type, \""ahash\"", sizeof(rhash.type));\n \n \trhash.blocksize = alg->cra_blocksize;\n \trhash.digestsize = __crypto_hash_alg_common(alg)->digestsize;""}<_**next**_>{""sha"": ""a79e7e9ab86e890d7eed95f3038b4424323a70f5"", ""filename"": ""crypto/blkcipher.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/blkcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/blkcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/blkcipher.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -499,9 +499,9 @@ static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""blkcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_blkcipher.geniv ?: \""<default>\"");\n+\tstrncpy(rblkcipher.type, \""blkcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_blkcipher.geniv ?: \""<default>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;""}<_**next**_>{""sha"": ""f6d9baf77f0a41b76b0fc39aebf26365a1284bca"", ""filename"": ""crypto/crypto_user.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 11, ""changes"": 22, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/crypto_user.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/crypto_user.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crypto_user.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -75,7 +75,7 @@ static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_cipher rcipher;\n \n-\tsnprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""cipher\"");\n+\tstrncpy(rcipher.type, \""cipher\"", sizeof(rcipher.type));\n \n \trcipher.blocksize = alg->cra_blocksize;\n \trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n@@ -94,8 +94,7 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_comp rcomp;\n \n-\tsnprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""compression\"");\n-\n+\tstrncpy(rcomp.type, \""compression\"", sizeof(rcomp.type));\n \tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n \t\t    sizeof(struct crypto_report_comp), &rcomp))\n \t\tgoto nla_put_failure;\n@@ -108,12 +107,14 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n static int crypto_report_one(struct crypto_alg *alg,\n \t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n {\n-\tmemcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));\n-\tmemcpy(&ualg->cru_driver_name, &alg->cra_driver_name,\n-\t       sizeof(ualg->cru_driver_name));\n-\tmemcpy(&ualg->cru_module_name, module_name(alg->cra_module),\n-\t       CRYPTO_MAX_ALG_NAME);\n-\n+\tstrncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n+\tstrncpy(ualg->cru_driver_name, alg->cra_driver_name,\n+\t\tsizeof(ualg->cru_driver_name));\n+\tstrncpy(ualg->cru_module_name, module_name(alg->cra_module),\n+\t\tsizeof(ualg->cru_module_name));\n+\n+\tualg->cru_type = 0;\n+\tualg->cru_mask = 0;\n \tualg->cru_flags = alg->cra_flags;\n \tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n \n@@ -122,8 +123,7 @@ static int crypto_report_one(struct crypto_alg *alg,\n \tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n \t\tstruct crypto_report_larval rl;\n \n-\t\tsnprintf(rl.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""larval\"");\n-\n+\t\tstrncpy(rl.type, \""larval\"", sizeof(rl.type));\n \t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n \t\t\t    sizeof(struct crypto_report_larval), &rl))\n \t\t\tgoto nla_put_failure;""}<_**next**_>{""sha"": ""7140fe70c7af04b2f544839b734de9aa5c461533"", ""filename"": ""crypto/pcompress.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/pcompress.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/pcompress.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/pcompress.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -53,8 +53,7 @@ static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_comp rpcomp;\n \n-\tsnprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""pcomp\"");\n-\n+\tstrncpy(rpcomp.type, \""pcomp\"", sizeof(rpcomp.type));\n \tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n \t\t    sizeof(struct crypto_report_comp), &rpcomp))\n \t\tgoto nla_put_failure;""}<_**next**_>{""sha"": ""e0a25c2456de4f7f92fa4ac1cc4daf9c48b5b209"", ""filename"": ""crypto/rng.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/rng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/rng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rng.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -65,7 +65,7 @@ static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_rng rrng;\n \n-\tsnprintf(rrng.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""rng\"");\n+\tstrncpy(rrng.type, \""rng\"", sizeof(rrng.type));\n \n \trrng.seedsize = alg->cra_rng.seedsize;\n ""}<_**next**_>{""sha"": ""929058a68561264c389719e26a3d22704bbbe18e"", ""filename"": ""crypto/shash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/shash.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/shash.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/shash.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -530,7 +530,8 @@ static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_hash rhash;\n \tstruct shash_alg *salg = __crypto_shash_alg(alg);\n \n-\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""shash\"");\n+\tstrncpy(rhash.type, \""shash\"", sizeof(rhash.type));\n+\n \trhash.blocksize = alg->cra_blocksize;\n \trhash.digestsize = salg->digestsize;\n ""}","static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_blkcipher rblkcipher;
 
	strncpy(rblkcipher.type, ""givcipher"", sizeof(rblkcipher.type));
	strncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: ""<built-in>"",
		sizeof(rblkcipher.geniv));
 
 	rblkcipher.blocksize = alg->cra_blocksize;
 	rblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;
	rblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;
	rblkcipher.ivsize = alg->cra_ablkcipher.ivsize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,
		    sizeof(struct crypto_report_blkcipher), &rblkcipher))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
","static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_blkcipher rblkcipher;
 
	snprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""givcipher"");
	snprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, ""%s"",
		 alg->cra_ablkcipher.geniv ?: ""<built-in>"");
 
 	rblkcipher.blocksize = alg->cra_blocksize;
 	rblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;
	rblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;
	rblkcipher.ivsize = alg->cra_ablkcipher.ivsize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,
		    sizeof(struct crypto_report_blkcipher), &rblkcipher))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
",C,"	strncpy(rblkcipher.type, ""givcipher"", sizeof(rblkcipher.type));
	strncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: ""<built-in>"",
		sizeof(rblkcipher.geniv));
","	snprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""givcipher"");
	snprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, ""%s"",
		 alg->cra_ablkcipher.geniv ?: ""<built-in>"");
",,"@@ -388,9 +388,9 @@ static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_blkcipher rblkcipher;
 
-	snprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""ablkcipher"");
-	snprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, ""%s"",
-		 alg->cra_ablkcipher.geniv ?: ""<default>"");
+	strncpy(rblkcipher.type, ""ablkcipher"", sizeof(rblkcipher.type));
+	strncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: ""<default>"",
+		sizeof(rblkcipher.geniv));
 
 	rblkcipher.blocksize = alg->cra_blocksize;
 	rblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;
@@ -469,9 +469,9 @@ static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_blkcipher rblkcipher;
 
-	snprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""givcipher"");
-	snprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, ""%s"",
-		 alg->cra_ablkcipher.geniv ?: ""<built-in>"");
+	strncpy(rblkcipher.type, ""givcipher"", sizeof(rblkcipher.type));
+	strncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: ""<built-in>"",
+		sizeof(rblkcipher.geniv));
 
 	rblkcipher.blocksize = alg->cra_blocksize;
 	rblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;",linux,9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,7eb9c5df92361c55daab4d8d4e8468eb774e297b,1,"static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_blkcipher rblkcipher;
 
//flaw_line_below:
	snprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""givcipher"");
//flaw_line_below:
	snprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, ""%s"",
//flaw_line_below:
		 alg->cra_ablkcipher.geniv ?: ""<built-in>"");
//fix_flaw_line_below:
//	strncpy(rblkcipher.type, ""givcipher"", sizeof(rblkcipher.type));
//fix_flaw_line_below:
//	strncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: ""<built-in>"",
//fix_flaw_line_below:
//		sizeof(rblkcipher.geniv));
 
 	rblkcipher.blocksize = alg->cra_blocksize;
 	rblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;
	rblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;
	rblkcipher.ivsize = alg->cra_ablkcipher.ivsize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,
		    sizeof(struct crypto_report_blkcipher), &rblkcipher))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
"
1499,179235,,Local,Not required,,CVE-2013-2548,https://www.cvedetails.com/cve/CVE-2013-2548/,CWE-310,Low,Partial,,,2013-03-15,2.1,"The crypto_report_one function in crypto/crypto_user.c in the report API in the crypto user configuration API in the Linux kernel through 3.8.2 uses an incorrect length value during a copy operation, which allows local users to obtain sensitive information from kernel memory by leveraging the CAP_NET_ADMIN capability.",2014-01-03,+Info ,2,https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,"crypto: user - fix info leaks in report API

Three errors resulting in kernel memory disclosure:

1/ The structures used for the netlink based crypto algorithm report API
are located on the stack. As snprintf() does not fill the remainder of
the buffer with null bytes, those stack bytes will be disclosed to users
of the API. Switch to strncpy() to fix this.

2/ crypto_report_one() does not initialize all field of struct
crypto_user_alg. Fix this to fix the heap info leak.

3/ For the module name we should copy only as many bytes as
module_name() returns -- not as much as the destination buffer could
hold. But the current code does not and therefore copies random data
from behind the end of the module name, as the module name is always
shorter than CRYPTO_MAX_ALG_NAME.

Also switch to use strncpy() to copy the algorithm's name and
driver_name. They are strings, after all.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Cc: Steffen Klassert <steffen.klassert@secunet.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",3,crypto/aead.c,"{""sha"": ""7d4a8d28277e181386981dcef2d73ec377aefe9a"", ""filename"": ""crypto/ablkcipher.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ablkcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ablkcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ablkcipher.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -388,9 +388,9 @@ static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""ablkcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_ablkcipher.geniv ?: \""<default>\"");\n+\tstrncpy(rblkcipher.type, \""ablkcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \""<default>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n@@ -469,9 +469,9 @@ static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""givcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_ablkcipher.geniv ?: \""<built-in>\"");\n+\tstrncpy(rblkcipher.type, \""givcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \""<built-in>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;""}<_**next**_>{""sha"": ""547491e35c63733f15ccb4697cf83109128125aa"", ""filename"": ""crypto/aead.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/aead.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/aead.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/aead.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -117,9 +117,8 @@ static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n-\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""aead\"");\n-\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t aead->geniv ?: \""<built-in>\"");\n+\tstrncpy(raead.type, \""aead\"", sizeof(raead.type));\n+\tstrncpy(raead.geniv, aead->geniv ?: \""<built-in>\"", sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;\n@@ -203,8 +202,8 @@ static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n-\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""nivaead\"");\n-\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"", aead->geniv);\n+\tstrncpy(raead.type, \""nivaead\"", sizeof(raead.type));\n+\tstrncpy(raead.geniv, aead->geniv, sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;""}<_**next**_>{""sha"": ""793a27f2493e5287c1275df40feaca7b7b14c87e"", ""filename"": ""crypto/ahash.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ahash.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ahash.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ahash.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -404,7 +404,7 @@ static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_hash rhash;\n \n-\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""ahash\"");\n+\tstrncpy(rhash.type, \""ahash\"", sizeof(rhash.type));\n \n \trhash.blocksize = alg->cra_blocksize;\n \trhash.digestsize = __crypto_hash_alg_common(alg)->digestsize;""}<_**next**_>{""sha"": ""a79e7e9ab86e890d7eed95f3038b4424323a70f5"", ""filename"": ""crypto/blkcipher.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/blkcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/blkcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/blkcipher.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -499,9 +499,9 @@ static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""blkcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_blkcipher.geniv ?: \""<default>\"");\n+\tstrncpy(rblkcipher.type, \""blkcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_blkcipher.geniv ?: \""<default>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;""}<_**next**_>{""sha"": ""f6d9baf77f0a41b76b0fc39aebf26365a1284bca"", ""filename"": ""crypto/crypto_user.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 11, ""changes"": 22, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/crypto_user.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/crypto_user.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crypto_user.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -75,7 +75,7 @@ static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_cipher rcipher;\n \n-\tsnprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""cipher\"");\n+\tstrncpy(rcipher.type, \""cipher\"", sizeof(rcipher.type));\n \n \trcipher.blocksize = alg->cra_blocksize;\n \trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n@@ -94,8 +94,7 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_comp rcomp;\n \n-\tsnprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""compression\"");\n-\n+\tstrncpy(rcomp.type, \""compression\"", sizeof(rcomp.type));\n \tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n \t\t    sizeof(struct crypto_report_comp), &rcomp))\n \t\tgoto nla_put_failure;\n@@ -108,12 +107,14 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n static int crypto_report_one(struct crypto_alg *alg,\n \t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n {\n-\tmemcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));\n-\tmemcpy(&ualg->cru_driver_name, &alg->cra_driver_name,\n-\t       sizeof(ualg->cru_driver_name));\n-\tmemcpy(&ualg->cru_module_name, module_name(alg->cra_module),\n-\t       CRYPTO_MAX_ALG_NAME);\n-\n+\tstrncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n+\tstrncpy(ualg->cru_driver_name, alg->cra_driver_name,\n+\t\tsizeof(ualg->cru_driver_name));\n+\tstrncpy(ualg->cru_module_name, module_name(alg->cra_module),\n+\t\tsizeof(ualg->cru_module_name));\n+\n+\tualg->cru_type = 0;\n+\tualg->cru_mask = 0;\n \tualg->cru_flags = alg->cra_flags;\n \tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n \n@@ -122,8 +123,7 @@ static int crypto_report_one(struct crypto_alg *alg,\n \tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n \t\tstruct crypto_report_larval rl;\n \n-\t\tsnprintf(rl.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""larval\"");\n-\n+\t\tstrncpy(rl.type, \""larval\"", sizeof(rl.type));\n \t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n \t\t\t    sizeof(struct crypto_report_larval), &rl))\n \t\t\tgoto nla_put_failure;""}<_**next**_>{""sha"": ""7140fe70c7af04b2f544839b734de9aa5c461533"", ""filename"": ""crypto/pcompress.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/pcompress.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/pcompress.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/pcompress.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -53,8 +53,7 @@ static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_comp rpcomp;\n \n-\tsnprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""pcomp\"");\n-\n+\tstrncpy(rpcomp.type, \""pcomp\"", sizeof(rpcomp.type));\n \tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n \t\t    sizeof(struct crypto_report_comp), &rpcomp))\n \t\tgoto nla_put_failure;""}<_**next**_>{""sha"": ""e0a25c2456de4f7f92fa4ac1cc4daf9c48b5b209"", ""filename"": ""crypto/rng.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/rng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/rng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rng.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -65,7 +65,7 @@ static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_rng rrng;\n \n-\tsnprintf(rrng.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""rng\"");\n+\tstrncpy(rrng.type, \""rng\"", sizeof(rrng.type));\n \n \trrng.seedsize = alg->cra_rng.seedsize;\n ""}<_**next**_>{""sha"": ""929058a68561264c389719e26a3d22704bbbe18e"", ""filename"": ""crypto/shash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/shash.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/shash.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/shash.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -530,7 +530,8 @@ static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_hash rhash;\n \tstruct shash_alg *salg = __crypto_shash_alg(alg);\n \n-\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""shash\"");\n+\tstrncpy(rhash.type, \""shash\"", sizeof(rhash.type));\n+\n \trhash.blocksize = alg->cra_blocksize;\n \trhash.digestsize = salg->digestsize;\n ""}","static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)
{
 	struct crypto_report_aead raead;
 	struct aead_alg *aead = &alg->cra_aead;
 
	strncpy(raead.type, ""aead"", sizeof(raead.type));
	strncpy(raead.geniv, aead->geniv ?: ""<built-in>"", sizeof(raead.geniv));
 
 	raead.blocksize = alg->cra_blocksize;
 	raead.maxauthsize = aead->maxauthsize;
	raead.ivsize = aead->ivsize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,
		    sizeof(struct crypto_report_aead), &raead))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
","static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)
{
 	struct crypto_report_aead raead;
 	struct aead_alg *aead = &alg->cra_aead;
 
	snprintf(raead.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""aead"");
	snprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, ""%s"",
		 aead->geniv ?: ""<built-in>"");
 
 	raead.blocksize = alg->cra_blocksize;
 	raead.maxauthsize = aead->maxauthsize;
	raead.ivsize = aead->ivsize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,
		    sizeof(struct crypto_report_aead), &raead))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
",C,"	strncpy(raead.type, ""aead"", sizeof(raead.type));
	strncpy(raead.geniv, aead->geniv ?: ""<built-in>"", sizeof(raead.geniv));
","	snprintf(raead.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""aead"");
	snprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, ""%s"",
		 aead->geniv ?: ""<built-in>"");
",,"@@ -117,9 +117,8 @@ static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)
 	struct crypto_report_aead raead;
 	struct aead_alg *aead = &alg->cra_aead;
 
-	snprintf(raead.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""aead"");
-	snprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, ""%s"",
-		 aead->geniv ?: ""<built-in>"");
+	strncpy(raead.type, ""aead"", sizeof(raead.type));
+	strncpy(raead.geniv, aead->geniv ?: ""<built-in>"", sizeof(raead.geniv));
 
 	raead.blocksize = alg->cra_blocksize;
 	raead.maxauthsize = aead->maxauthsize;
@@ -203,8 +202,8 @@ static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)
 	struct crypto_report_aead raead;
 	struct aead_alg *aead = &alg->cra_aead;
 
-	snprintf(raead.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""nivaead"");
-	snprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, ""%s"", aead->geniv);
+	strncpy(raead.type, ""nivaead"", sizeof(raead.type));
+	strncpy(raead.geniv, aead->geniv, sizeof(raead.geniv));
 
 	raead.blocksize = alg->cra_blocksize;
 	raead.maxauthsize = aead->maxauthsize;",linux,9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,7eb9c5df92361c55daab4d8d4e8468eb774e297b,1,"static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)
{
 	struct crypto_report_aead raead;
 	struct aead_alg *aead = &alg->cra_aead;
 
//flaw_line_below:
	snprintf(raead.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""aead"");
//flaw_line_below:
	snprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, ""%s"",
//flaw_line_below:
		 aead->geniv ?: ""<built-in>"");
//fix_flaw_line_below:
//	strncpy(raead.type, ""aead"", sizeof(raead.type));
//fix_flaw_line_below:
//	strncpy(raead.geniv, aead->geniv ?: ""<built-in>"", sizeof(raead.geniv));
 
 	raead.blocksize = alg->cra_blocksize;
 	raead.maxauthsize = aead->maxauthsize;
	raead.ivsize = aead->ivsize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,
		    sizeof(struct crypto_report_aead), &raead))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
"
1500,179236,,Local,Not required,,CVE-2013-2548,https://www.cvedetails.com/cve/CVE-2013-2548/,CWE-310,Low,Partial,,,2013-03-15,2.1,"The crypto_report_one function in crypto/crypto_user.c in the report API in the crypto user configuration API in the Linux kernel through 3.8.2 uses an incorrect length value during a copy operation, which allows local users to obtain sensitive information from kernel memory by leveraging the CAP_NET_ADMIN capability.",2014-01-03,+Info ,2,https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,"crypto: user - fix info leaks in report API

Three errors resulting in kernel memory disclosure:

1/ The structures used for the netlink based crypto algorithm report API
are located on the stack. As snprintf() does not fill the remainder of
the buffer with null bytes, those stack bytes will be disclosed to users
of the API. Switch to strncpy() to fix this.

2/ crypto_report_one() does not initialize all field of struct
crypto_user_alg. Fix this to fix the heap info leak.

3/ For the module name we should copy only as many bytes as
module_name() returns -- not as much as the destination buffer could
hold. But the current code does not and therefore copies random data
from behind the end of the module name, as the module name is always
shorter than CRYPTO_MAX_ALG_NAME.

Also switch to use strncpy() to copy the algorithm's name and
driver_name. They are strings, after all.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Cc: Steffen Klassert <steffen.klassert@secunet.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",2,crypto/aead.c,"{""sha"": ""7d4a8d28277e181386981dcef2d73ec377aefe9a"", ""filename"": ""crypto/ablkcipher.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ablkcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ablkcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ablkcipher.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -388,9 +388,9 @@ static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""ablkcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_ablkcipher.geniv ?: \""<default>\"");\n+\tstrncpy(rblkcipher.type, \""ablkcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \""<default>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n@@ -469,9 +469,9 @@ static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""givcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_ablkcipher.geniv ?: \""<built-in>\"");\n+\tstrncpy(rblkcipher.type, \""givcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \""<built-in>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;""}<_**next**_>{""sha"": ""547491e35c63733f15ccb4697cf83109128125aa"", ""filename"": ""crypto/aead.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/aead.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/aead.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/aead.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -117,9 +117,8 @@ static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n-\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""aead\"");\n-\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t aead->geniv ?: \""<built-in>\"");\n+\tstrncpy(raead.type, \""aead\"", sizeof(raead.type));\n+\tstrncpy(raead.geniv, aead->geniv ?: \""<built-in>\"", sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;\n@@ -203,8 +202,8 @@ static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n-\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""nivaead\"");\n-\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"", aead->geniv);\n+\tstrncpy(raead.type, \""nivaead\"", sizeof(raead.type));\n+\tstrncpy(raead.geniv, aead->geniv, sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;""}<_**next**_>{""sha"": ""793a27f2493e5287c1275df40feaca7b7b14c87e"", ""filename"": ""crypto/ahash.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ahash.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ahash.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ahash.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -404,7 +404,7 @@ static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_hash rhash;\n \n-\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""ahash\"");\n+\tstrncpy(rhash.type, \""ahash\"", sizeof(rhash.type));\n \n \trhash.blocksize = alg->cra_blocksize;\n \trhash.digestsize = __crypto_hash_alg_common(alg)->digestsize;""}<_**next**_>{""sha"": ""a79e7e9ab86e890d7eed95f3038b4424323a70f5"", ""filename"": ""crypto/blkcipher.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/blkcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/blkcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/blkcipher.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -499,9 +499,9 @@ static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""blkcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_blkcipher.geniv ?: \""<default>\"");\n+\tstrncpy(rblkcipher.type, \""blkcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_blkcipher.geniv ?: \""<default>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;""}<_**next**_>{""sha"": ""f6d9baf77f0a41b76b0fc39aebf26365a1284bca"", ""filename"": ""crypto/crypto_user.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 11, ""changes"": 22, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/crypto_user.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/crypto_user.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crypto_user.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -75,7 +75,7 @@ static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_cipher rcipher;\n \n-\tsnprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""cipher\"");\n+\tstrncpy(rcipher.type, \""cipher\"", sizeof(rcipher.type));\n \n \trcipher.blocksize = alg->cra_blocksize;\n \trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n@@ -94,8 +94,7 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_comp rcomp;\n \n-\tsnprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""compression\"");\n-\n+\tstrncpy(rcomp.type, \""compression\"", sizeof(rcomp.type));\n \tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n \t\t    sizeof(struct crypto_report_comp), &rcomp))\n \t\tgoto nla_put_failure;\n@@ -108,12 +107,14 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n static int crypto_report_one(struct crypto_alg *alg,\n \t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n {\n-\tmemcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));\n-\tmemcpy(&ualg->cru_driver_name, &alg->cra_driver_name,\n-\t       sizeof(ualg->cru_driver_name));\n-\tmemcpy(&ualg->cru_module_name, module_name(alg->cra_module),\n-\t       CRYPTO_MAX_ALG_NAME);\n-\n+\tstrncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n+\tstrncpy(ualg->cru_driver_name, alg->cra_driver_name,\n+\t\tsizeof(ualg->cru_driver_name));\n+\tstrncpy(ualg->cru_module_name, module_name(alg->cra_module),\n+\t\tsizeof(ualg->cru_module_name));\n+\n+\tualg->cru_type = 0;\n+\tualg->cru_mask = 0;\n \tualg->cru_flags = alg->cra_flags;\n \tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n \n@@ -122,8 +123,7 @@ static int crypto_report_one(struct crypto_alg *alg,\n \tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n \t\tstruct crypto_report_larval rl;\n \n-\t\tsnprintf(rl.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""larval\"");\n-\n+\t\tstrncpy(rl.type, \""larval\"", sizeof(rl.type));\n \t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n \t\t\t    sizeof(struct crypto_report_larval), &rl))\n \t\t\tgoto nla_put_failure;""}<_**next**_>{""sha"": ""7140fe70c7af04b2f544839b734de9aa5c461533"", ""filename"": ""crypto/pcompress.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/pcompress.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/pcompress.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/pcompress.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -53,8 +53,7 @@ static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_comp rpcomp;\n \n-\tsnprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""pcomp\"");\n-\n+\tstrncpy(rpcomp.type, \""pcomp\"", sizeof(rpcomp.type));\n \tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n \t\t    sizeof(struct crypto_report_comp), &rpcomp))\n \t\tgoto nla_put_failure;""}<_**next**_>{""sha"": ""e0a25c2456de4f7f92fa4ac1cc4daf9c48b5b209"", ""filename"": ""crypto/rng.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/rng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/rng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rng.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -65,7 +65,7 @@ static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_rng rrng;\n \n-\tsnprintf(rrng.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""rng\"");\n+\tstrncpy(rrng.type, \""rng\"", sizeof(rrng.type));\n \n \trrng.seedsize = alg->cra_rng.seedsize;\n ""}<_**next**_>{""sha"": ""929058a68561264c389719e26a3d22704bbbe18e"", ""filename"": ""crypto/shash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/shash.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/shash.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/shash.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -530,7 +530,8 @@ static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_hash rhash;\n \tstruct shash_alg *salg = __crypto_shash_alg(alg);\n \n-\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""shash\"");\n+\tstrncpy(rhash.type, \""shash\"", sizeof(rhash.type));\n+\n \trhash.blocksize = alg->cra_blocksize;\n \trhash.digestsize = salg->digestsize;\n ""}","static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)
{
 	struct crypto_report_aead raead;
 	struct aead_alg *aead = &alg->cra_aead;
 
	strncpy(raead.type, ""nivaead"", sizeof(raead.type));
	strncpy(raead.geniv, aead->geniv, sizeof(raead.geniv));
 
 	raead.blocksize = alg->cra_blocksize;
 	raead.maxauthsize = aead->maxauthsize;
	raead.ivsize = aead->ivsize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,
		    sizeof(struct crypto_report_aead), &raead))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
","static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)
{
 	struct crypto_report_aead raead;
 	struct aead_alg *aead = &alg->cra_aead;
 
	snprintf(raead.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""nivaead"");
	snprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, ""%s"", aead->geniv);
 
 	raead.blocksize = alg->cra_blocksize;
 	raead.maxauthsize = aead->maxauthsize;
	raead.ivsize = aead->ivsize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,
		    sizeof(struct crypto_report_aead), &raead))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
",C,"	strncpy(raead.type, ""nivaead"", sizeof(raead.type));
	strncpy(raead.geniv, aead->geniv, sizeof(raead.geniv));
","	snprintf(raead.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""nivaead"");
	snprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, ""%s"", aead->geniv);
",,"@@ -117,9 +117,8 @@ static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)
 	struct crypto_report_aead raead;
 	struct aead_alg *aead = &alg->cra_aead;
 
-	snprintf(raead.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""aead"");
-	snprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, ""%s"",
-		 aead->geniv ?: ""<built-in>"");
+	strncpy(raead.type, ""aead"", sizeof(raead.type));
+	strncpy(raead.geniv, aead->geniv ?: ""<built-in>"", sizeof(raead.geniv));
 
 	raead.blocksize = alg->cra_blocksize;
 	raead.maxauthsize = aead->maxauthsize;
@@ -203,8 +202,8 @@ static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)
 	struct crypto_report_aead raead;
 	struct aead_alg *aead = &alg->cra_aead;
 
-	snprintf(raead.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""nivaead"");
-	snprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, ""%s"", aead->geniv);
+	strncpy(raead.type, ""nivaead"", sizeof(raead.type));
+	strncpy(raead.geniv, aead->geniv, sizeof(raead.geniv));
 
 	raead.blocksize = alg->cra_blocksize;
 	raead.maxauthsize = aead->maxauthsize;",linux,9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,7eb9c5df92361c55daab4d8d4e8468eb774e297b,1,"static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)
{
 	struct crypto_report_aead raead;
 	struct aead_alg *aead = &alg->cra_aead;
 
//flaw_line_below:
	snprintf(raead.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""nivaead"");
//flaw_line_below:
	snprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, ""%s"", aead->geniv);
//fix_flaw_line_below:
//	strncpy(raead.type, ""nivaead"", sizeof(raead.type));
//fix_flaw_line_below:
//	strncpy(raead.geniv, aead->geniv, sizeof(raead.geniv));
 
 	raead.blocksize = alg->cra_blocksize;
 	raead.maxauthsize = aead->maxauthsize;
	raead.ivsize = aead->ivsize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,
		    sizeof(struct crypto_report_aead), &raead))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
"
1501,179237,,Local,Not required,,CVE-2013-2548,https://www.cvedetails.com/cve/CVE-2013-2548/,CWE-310,Low,Partial,,,2013-03-15,2.1,"The crypto_report_one function in crypto/crypto_user.c in the report API in the crypto user configuration API in the Linux kernel through 3.8.2 uses an incorrect length value during a copy operation, which allows local users to obtain sensitive information from kernel memory by leveraging the CAP_NET_ADMIN capability.",2014-01-03,+Info ,1,https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,"crypto: user - fix info leaks in report API

Three errors resulting in kernel memory disclosure:

1/ The structures used for the netlink based crypto algorithm report API
are located on the stack. As snprintf() does not fill the remainder of
the buffer with null bytes, those stack bytes will be disclosed to users
of the API. Switch to strncpy() to fix this.

2/ crypto_report_one() does not initialize all field of struct
crypto_user_alg. Fix this to fix the heap info leak.

3/ For the module name we should copy only as many bytes as
module_name() returns -- not as much as the destination buffer could
hold. But the current code does not and therefore copies random data
from behind the end of the module name, as the module name is always
shorter than CRYPTO_MAX_ALG_NAME.

Also switch to use strncpy() to copy the algorithm's name and
driver_name. They are strings, after all.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Cc: Steffen Klassert <steffen.klassert@secunet.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",1,crypto/ahash.c,"{""sha"": ""7d4a8d28277e181386981dcef2d73ec377aefe9a"", ""filename"": ""crypto/ablkcipher.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ablkcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ablkcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ablkcipher.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -388,9 +388,9 @@ static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""ablkcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_ablkcipher.geniv ?: \""<default>\"");\n+\tstrncpy(rblkcipher.type, \""ablkcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \""<default>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n@@ -469,9 +469,9 @@ static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""givcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_ablkcipher.geniv ?: \""<built-in>\"");\n+\tstrncpy(rblkcipher.type, \""givcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \""<built-in>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;""}<_**next**_>{""sha"": ""547491e35c63733f15ccb4697cf83109128125aa"", ""filename"": ""crypto/aead.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/aead.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/aead.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/aead.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -117,9 +117,8 @@ static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n-\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""aead\"");\n-\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t aead->geniv ?: \""<built-in>\"");\n+\tstrncpy(raead.type, \""aead\"", sizeof(raead.type));\n+\tstrncpy(raead.geniv, aead->geniv ?: \""<built-in>\"", sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;\n@@ -203,8 +202,8 @@ static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n-\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""nivaead\"");\n-\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"", aead->geniv);\n+\tstrncpy(raead.type, \""nivaead\"", sizeof(raead.type));\n+\tstrncpy(raead.geniv, aead->geniv, sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;""}<_**next**_>{""sha"": ""793a27f2493e5287c1275df40feaca7b7b14c87e"", ""filename"": ""crypto/ahash.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ahash.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ahash.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ahash.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -404,7 +404,7 @@ static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_hash rhash;\n \n-\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""ahash\"");\n+\tstrncpy(rhash.type, \""ahash\"", sizeof(rhash.type));\n \n \trhash.blocksize = alg->cra_blocksize;\n \trhash.digestsize = __crypto_hash_alg_common(alg)->digestsize;""}<_**next**_>{""sha"": ""a79e7e9ab86e890d7eed95f3038b4424323a70f5"", ""filename"": ""crypto/blkcipher.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/blkcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/blkcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/blkcipher.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -499,9 +499,9 @@ static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""blkcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_blkcipher.geniv ?: \""<default>\"");\n+\tstrncpy(rblkcipher.type, \""blkcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_blkcipher.geniv ?: \""<default>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;""}<_**next**_>{""sha"": ""f6d9baf77f0a41b76b0fc39aebf26365a1284bca"", ""filename"": ""crypto/crypto_user.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 11, ""changes"": 22, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/crypto_user.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/crypto_user.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crypto_user.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -75,7 +75,7 @@ static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_cipher rcipher;\n \n-\tsnprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""cipher\"");\n+\tstrncpy(rcipher.type, \""cipher\"", sizeof(rcipher.type));\n \n \trcipher.blocksize = alg->cra_blocksize;\n \trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n@@ -94,8 +94,7 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_comp rcomp;\n \n-\tsnprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""compression\"");\n-\n+\tstrncpy(rcomp.type, \""compression\"", sizeof(rcomp.type));\n \tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n \t\t    sizeof(struct crypto_report_comp), &rcomp))\n \t\tgoto nla_put_failure;\n@@ -108,12 +107,14 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n static int crypto_report_one(struct crypto_alg *alg,\n \t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n {\n-\tmemcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));\n-\tmemcpy(&ualg->cru_driver_name, &alg->cra_driver_name,\n-\t       sizeof(ualg->cru_driver_name));\n-\tmemcpy(&ualg->cru_module_name, module_name(alg->cra_module),\n-\t       CRYPTO_MAX_ALG_NAME);\n-\n+\tstrncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n+\tstrncpy(ualg->cru_driver_name, alg->cra_driver_name,\n+\t\tsizeof(ualg->cru_driver_name));\n+\tstrncpy(ualg->cru_module_name, module_name(alg->cra_module),\n+\t\tsizeof(ualg->cru_module_name));\n+\n+\tualg->cru_type = 0;\n+\tualg->cru_mask = 0;\n \tualg->cru_flags = alg->cra_flags;\n \tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n \n@@ -122,8 +123,7 @@ static int crypto_report_one(struct crypto_alg *alg,\n \tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n \t\tstruct crypto_report_larval rl;\n \n-\t\tsnprintf(rl.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""larval\"");\n-\n+\t\tstrncpy(rl.type, \""larval\"", sizeof(rl.type));\n \t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n \t\t\t    sizeof(struct crypto_report_larval), &rl))\n \t\t\tgoto nla_put_failure;""}<_**next**_>{""sha"": ""7140fe70c7af04b2f544839b734de9aa5c461533"", ""filename"": ""crypto/pcompress.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/pcompress.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/pcompress.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/pcompress.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -53,8 +53,7 @@ static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_comp rpcomp;\n \n-\tsnprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""pcomp\"");\n-\n+\tstrncpy(rpcomp.type, \""pcomp\"", sizeof(rpcomp.type));\n \tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n \t\t    sizeof(struct crypto_report_comp), &rpcomp))\n \t\tgoto nla_put_failure;""}<_**next**_>{""sha"": ""e0a25c2456de4f7f92fa4ac1cc4daf9c48b5b209"", ""filename"": ""crypto/rng.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/rng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/rng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rng.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -65,7 +65,7 @@ static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_rng rrng;\n \n-\tsnprintf(rrng.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""rng\"");\n+\tstrncpy(rrng.type, \""rng\"", sizeof(rrng.type));\n \n \trrng.seedsize = alg->cra_rng.seedsize;\n ""}<_**next**_>{""sha"": ""929058a68561264c389719e26a3d22704bbbe18e"", ""filename"": ""crypto/shash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/shash.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/shash.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/shash.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -530,7 +530,8 @@ static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_hash rhash;\n \tstruct shash_alg *salg = __crypto_shash_alg(alg);\n \n-\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""shash\"");\n+\tstrncpy(rhash.type, \""shash\"", sizeof(rhash.type));\n+\n \trhash.blocksize = alg->cra_blocksize;\n \trhash.digestsize = salg->digestsize;\n ""}","static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_hash rhash;
 
	strncpy(rhash.type, ""ahash"", sizeof(rhash.type));
 
 	rhash.blocksize = alg->cra_blocksize;
 	rhash.digestsize = __crypto_hash_alg_common(alg)->digestsize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_HASH,
		    sizeof(struct crypto_report_hash), &rhash))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
","static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_hash rhash;
 
	snprintf(rhash.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""ahash"");
 
 	rhash.blocksize = alg->cra_blocksize;
 	rhash.digestsize = __crypto_hash_alg_common(alg)->digestsize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_HASH,
		    sizeof(struct crypto_report_hash), &rhash))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
",C,"	strncpy(rhash.type, ""ahash"", sizeof(rhash.type));
","	snprintf(rhash.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""ahash"");
",,"@@ -404,7 +404,7 @@ static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_hash rhash;
 
-	snprintf(rhash.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""ahash"");
+	strncpy(rhash.type, ""ahash"", sizeof(rhash.type));
 
 	rhash.blocksize = alg->cra_blocksize;
 	rhash.digestsize = __crypto_hash_alg_common(alg)->digestsize;",linux,9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,7eb9c5df92361c55daab4d8d4e8468eb774e297b,1,"static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_hash rhash;
 
//flaw_line_below:
	snprintf(rhash.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""ahash"");
//fix_flaw_line_below:
//	strncpy(rhash.type, ""ahash"", sizeof(rhash.type));
 
 	rhash.blocksize = alg->cra_blocksize;
 	rhash.digestsize = __crypto_hash_alg_common(alg)->digestsize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_HASH,
		    sizeof(struct crypto_report_hash), &rhash))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
"
1502,179238,,Local,Not required,,CVE-2013-2548,https://www.cvedetails.com/cve/CVE-2013-2548/,CWE-310,Low,Partial,,,2013-03-15,2.1,"The crypto_report_one function in crypto/crypto_user.c in the report API in the crypto user configuration API in the Linux kernel through 3.8.2 uses an incorrect length value during a copy operation, which allows local users to obtain sensitive information from kernel memory by leveraging the CAP_NET_ADMIN capability.",2014-01-03,+Info ,3,https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,"crypto: user - fix info leaks in report API

Three errors resulting in kernel memory disclosure:

1/ The structures used for the netlink based crypto algorithm report API
are located on the stack. As snprintf() does not fill the remainder of
the buffer with null bytes, those stack bytes will be disclosed to users
of the API. Switch to strncpy() to fix this.

2/ crypto_report_one() does not initialize all field of struct
crypto_user_alg. Fix this to fix the heap info leak.

3/ For the module name we should copy only as many bytes as
module_name() returns -- not as much as the destination buffer could
hold. But the current code does not and therefore copies random data
from behind the end of the module name, as the module name is always
shorter than CRYPTO_MAX_ALG_NAME.

Also switch to use strncpy() to copy the algorithm's name and
driver_name. They are strings, after all.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Cc: Steffen Klassert <steffen.klassert@secunet.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",3,crypto/blkcipher.c,"{""sha"": ""7d4a8d28277e181386981dcef2d73ec377aefe9a"", ""filename"": ""crypto/ablkcipher.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ablkcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ablkcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ablkcipher.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -388,9 +388,9 @@ static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""ablkcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_ablkcipher.geniv ?: \""<default>\"");\n+\tstrncpy(rblkcipher.type, \""ablkcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \""<default>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n@@ -469,9 +469,9 @@ static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""givcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_ablkcipher.geniv ?: \""<built-in>\"");\n+\tstrncpy(rblkcipher.type, \""givcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \""<built-in>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;""}<_**next**_>{""sha"": ""547491e35c63733f15ccb4697cf83109128125aa"", ""filename"": ""crypto/aead.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/aead.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/aead.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/aead.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -117,9 +117,8 @@ static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n-\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""aead\"");\n-\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t aead->geniv ?: \""<built-in>\"");\n+\tstrncpy(raead.type, \""aead\"", sizeof(raead.type));\n+\tstrncpy(raead.geniv, aead->geniv ?: \""<built-in>\"", sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;\n@@ -203,8 +202,8 @@ static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n-\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""nivaead\"");\n-\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"", aead->geniv);\n+\tstrncpy(raead.type, \""nivaead\"", sizeof(raead.type));\n+\tstrncpy(raead.geniv, aead->geniv, sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;""}<_**next**_>{""sha"": ""793a27f2493e5287c1275df40feaca7b7b14c87e"", ""filename"": ""crypto/ahash.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ahash.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ahash.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ahash.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -404,7 +404,7 @@ static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_hash rhash;\n \n-\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""ahash\"");\n+\tstrncpy(rhash.type, \""ahash\"", sizeof(rhash.type));\n \n \trhash.blocksize = alg->cra_blocksize;\n \trhash.digestsize = __crypto_hash_alg_common(alg)->digestsize;""}<_**next**_>{""sha"": ""a79e7e9ab86e890d7eed95f3038b4424323a70f5"", ""filename"": ""crypto/blkcipher.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/blkcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/blkcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/blkcipher.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -499,9 +499,9 @@ static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""blkcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_blkcipher.geniv ?: \""<default>\"");\n+\tstrncpy(rblkcipher.type, \""blkcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_blkcipher.geniv ?: \""<default>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;""}<_**next**_>{""sha"": ""f6d9baf77f0a41b76b0fc39aebf26365a1284bca"", ""filename"": ""crypto/crypto_user.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 11, ""changes"": 22, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/crypto_user.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/crypto_user.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crypto_user.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -75,7 +75,7 @@ static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_cipher rcipher;\n \n-\tsnprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""cipher\"");\n+\tstrncpy(rcipher.type, \""cipher\"", sizeof(rcipher.type));\n \n \trcipher.blocksize = alg->cra_blocksize;\n \trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n@@ -94,8 +94,7 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_comp rcomp;\n \n-\tsnprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""compression\"");\n-\n+\tstrncpy(rcomp.type, \""compression\"", sizeof(rcomp.type));\n \tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n \t\t    sizeof(struct crypto_report_comp), &rcomp))\n \t\tgoto nla_put_failure;\n@@ -108,12 +107,14 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n static int crypto_report_one(struct crypto_alg *alg,\n \t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n {\n-\tmemcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));\n-\tmemcpy(&ualg->cru_driver_name, &alg->cra_driver_name,\n-\t       sizeof(ualg->cru_driver_name));\n-\tmemcpy(&ualg->cru_module_name, module_name(alg->cra_module),\n-\t       CRYPTO_MAX_ALG_NAME);\n-\n+\tstrncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n+\tstrncpy(ualg->cru_driver_name, alg->cra_driver_name,\n+\t\tsizeof(ualg->cru_driver_name));\n+\tstrncpy(ualg->cru_module_name, module_name(alg->cra_module),\n+\t\tsizeof(ualg->cru_module_name));\n+\n+\tualg->cru_type = 0;\n+\tualg->cru_mask = 0;\n \tualg->cru_flags = alg->cra_flags;\n \tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n \n@@ -122,8 +123,7 @@ static int crypto_report_one(struct crypto_alg *alg,\n \tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n \t\tstruct crypto_report_larval rl;\n \n-\t\tsnprintf(rl.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""larval\"");\n-\n+\t\tstrncpy(rl.type, \""larval\"", sizeof(rl.type));\n \t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n \t\t\t    sizeof(struct crypto_report_larval), &rl))\n \t\t\tgoto nla_put_failure;""}<_**next**_>{""sha"": ""7140fe70c7af04b2f544839b734de9aa5c461533"", ""filename"": ""crypto/pcompress.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/pcompress.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/pcompress.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/pcompress.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -53,8 +53,7 @@ static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_comp rpcomp;\n \n-\tsnprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""pcomp\"");\n-\n+\tstrncpy(rpcomp.type, \""pcomp\"", sizeof(rpcomp.type));\n \tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n \t\t    sizeof(struct crypto_report_comp), &rpcomp))\n \t\tgoto nla_put_failure;""}<_**next**_>{""sha"": ""e0a25c2456de4f7f92fa4ac1cc4daf9c48b5b209"", ""filename"": ""crypto/rng.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/rng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/rng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rng.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -65,7 +65,7 @@ static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_rng rrng;\n \n-\tsnprintf(rrng.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""rng\"");\n+\tstrncpy(rrng.type, \""rng\"", sizeof(rrng.type));\n \n \trrng.seedsize = alg->cra_rng.seedsize;\n ""}<_**next**_>{""sha"": ""929058a68561264c389719e26a3d22704bbbe18e"", ""filename"": ""crypto/shash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/shash.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/shash.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/shash.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -530,7 +530,8 @@ static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_hash rhash;\n \tstruct shash_alg *salg = __crypto_shash_alg(alg);\n \n-\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""shash\"");\n+\tstrncpy(rhash.type, \""shash\"", sizeof(rhash.type));\n+\n \trhash.blocksize = alg->cra_blocksize;\n \trhash.digestsize = salg->digestsize;\n ""}","static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_blkcipher rblkcipher;
 
	strncpy(rblkcipher.type, ""blkcipher"", sizeof(rblkcipher.type));
	strncpy(rblkcipher.geniv, alg->cra_blkcipher.geniv ?: ""<default>"",
		sizeof(rblkcipher.geniv));
 
 	rblkcipher.blocksize = alg->cra_blocksize;
 	rblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;
	rblkcipher.max_keysize = alg->cra_blkcipher.max_keysize;
	rblkcipher.ivsize = alg->cra_blkcipher.ivsize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,
		    sizeof(struct crypto_report_blkcipher), &rblkcipher))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
","static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_blkcipher rblkcipher;
 
	snprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""blkcipher"");
	snprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, ""%s"",
		 alg->cra_blkcipher.geniv ?: ""<default>"");
 
 	rblkcipher.blocksize = alg->cra_blocksize;
 	rblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;
	rblkcipher.max_keysize = alg->cra_blkcipher.max_keysize;
	rblkcipher.ivsize = alg->cra_blkcipher.ivsize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,
		    sizeof(struct crypto_report_blkcipher), &rblkcipher))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
",C,"	strncpy(rblkcipher.type, ""blkcipher"", sizeof(rblkcipher.type));
	strncpy(rblkcipher.geniv, alg->cra_blkcipher.geniv ?: ""<default>"",
		sizeof(rblkcipher.geniv));
","	snprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""blkcipher"");
	snprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, ""%s"",
		 alg->cra_blkcipher.geniv ?: ""<default>"");
",,"@@ -499,9 +499,9 @@ static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_blkcipher rblkcipher;
 
-	snprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""blkcipher"");
-	snprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, ""%s"",
-		 alg->cra_blkcipher.geniv ?: ""<default>"");
+	strncpy(rblkcipher.type, ""blkcipher"", sizeof(rblkcipher.type));
+	strncpy(rblkcipher.geniv, alg->cra_blkcipher.geniv ?: ""<default>"",
+		sizeof(rblkcipher.geniv));
 
 	rblkcipher.blocksize = alg->cra_blocksize;
 	rblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;",linux,9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,7eb9c5df92361c55daab4d8d4e8468eb774e297b,1,"static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_blkcipher rblkcipher;
 
//flaw_line_below:
	snprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""blkcipher"");
//flaw_line_below:
	snprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, ""%s"",
//flaw_line_below:
		 alg->cra_blkcipher.geniv ?: ""<default>"");
//fix_flaw_line_below:
//	strncpy(rblkcipher.type, ""blkcipher"", sizeof(rblkcipher.type));
//fix_flaw_line_below:
//	strncpy(rblkcipher.geniv, alg->cra_blkcipher.geniv ?: ""<default>"",
//fix_flaw_line_below:
//		sizeof(rblkcipher.geniv));
 
 	rblkcipher.blocksize = alg->cra_blocksize;
 	rblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;
	rblkcipher.max_keysize = alg->cra_blkcipher.max_keysize;
	rblkcipher.ivsize = alg->cra_blkcipher.ivsize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,
		    sizeof(struct crypto_report_blkcipher), &rblkcipher))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
"
1503,179239,,Local,Not required,,CVE-2013-2548,https://www.cvedetails.com/cve/CVE-2013-2548/,CWE-310,Low,Partial,,,2013-03-15,2.1,"The crypto_report_one function in crypto/crypto_user.c in the report API in the crypto user configuration API in the Linux kernel through 3.8.2 uses an incorrect length value during a copy operation, which allows local users to obtain sensitive information from kernel memory by leveraging the CAP_NET_ADMIN capability.",2014-01-03,+Info ,1,https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,"crypto: user - fix info leaks in report API

Three errors resulting in kernel memory disclosure:

1/ The structures used for the netlink based crypto algorithm report API
are located on the stack. As snprintf() does not fill the remainder of
the buffer with null bytes, those stack bytes will be disclosed to users
of the API. Switch to strncpy() to fix this.

2/ crypto_report_one() does not initialize all field of struct
crypto_user_alg. Fix this to fix the heap info leak.

3/ For the module name we should copy only as many bytes as
module_name() returns -- not as much as the destination buffer could
hold. But the current code does not and therefore copies random data
from behind the end of the module name, as the module name is always
shorter than CRYPTO_MAX_ALG_NAME.

Also switch to use strncpy() to copy the algorithm's name and
driver_name. They are strings, after all.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Cc: Steffen Klassert <steffen.klassert@secunet.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",1,crypto/crypto_user.c,"{""sha"": ""7d4a8d28277e181386981dcef2d73ec377aefe9a"", ""filename"": ""crypto/ablkcipher.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ablkcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ablkcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ablkcipher.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -388,9 +388,9 @@ static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""ablkcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_ablkcipher.geniv ?: \""<default>\"");\n+\tstrncpy(rblkcipher.type, \""ablkcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \""<default>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n@@ -469,9 +469,9 @@ static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""givcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_ablkcipher.geniv ?: \""<built-in>\"");\n+\tstrncpy(rblkcipher.type, \""givcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \""<built-in>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;""}<_**next**_>{""sha"": ""547491e35c63733f15ccb4697cf83109128125aa"", ""filename"": ""crypto/aead.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/aead.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/aead.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/aead.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -117,9 +117,8 @@ static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n-\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""aead\"");\n-\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t aead->geniv ?: \""<built-in>\"");\n+\tstrncpy(raead.type, \""aead\"", sizeof(raead.type));\n+\tstrncpy(raead.geniv, aead->geniv ?: \""<built-in>\"", sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;\n@@ -203,8 +202,8 @@ static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n-\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""nivaead\"");\n-\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"", aead->geniv);\n+\tstrncpy(raead.type, \""nivaead\"", sizeof(raead.type));\n+\tstrncpy(raead.geniv, aead->geniv, sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;""}<_**next**_>{""sha"": ""793a27f2493e5287c1275df40feaca7b7b14c87e"", ""filename"": ""crypto/ahash.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ahash.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ahash.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ahash.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -404,7 +404,7 @@ static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_hash rhash;\n \n-\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""ahash\"");\n+\tstrncpy(rhash.type, \""ahash\"", sizeof(rhash.type));\n \n \trhash.blocksize = alg->cra_blocksize;\n \trhash.digestsize = __crypto_hash_alg_common(alg)->digestsize;""}<_**next**_>{""sha"": ""a79e7e9ab86e890d7eed95f3038b4424323a70f5"", ""filename"": ""crypto/blkcipher.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/blkcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/blkcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/blkcipher.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -499,9 +499,9 @@ static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""blkcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_blkcipher.geniv ?: \""<default>\"");\n+\tstrncpy(rblkcipher.type, \""blkcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_blkcipher.geniv ?: \""<default>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;""}<_**next**_>{""sha"": ""f6d9baf77f0a41b76b0fc39aebf26365a1284bca"", ""filename"": ""crypto/crypto_user.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 11, ""changes"": 22, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/crypto_user.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/crypto_user.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crypto_user.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -75,7 +75,7 @@ static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_cipher rcipher;\n \n-\tsnprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""cipher\"");\n+\tstrncpy(rcipher.type, \""cipher\"", sizeof(rcipher.type));\n \n \trcipher.blocksize = alg->cra_blocksize;\n \trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n@@ -94,8 +94,7 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_comp rcomp;\n \n-\tsnprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""compression\"");\n-\n+\tstrncpy(rcomp.type, \""compression\"", sizeof(rcomp.type));\n \tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n \t\t    sizeof(struct crypto_report_comp), &rcomp))\n \t\tgoto nla_put_failure;\n@@ -108,12 +107,14 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n static int crypto_report_one(struct crypto_alg *alg,\n \t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n {\n-\tmemcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));\n-\tmemcpy(&ualg->cru_driver_name, &alg->cra_driver_name,\n-\t       sizeof(ualg->cru_driver_name));\n-\tmemcpy(&ualg->cru_module_name, module_name(alg->cra_module),\n-\t       CRYPTO_MAX_ALG_NAME);\n-\n+\tstrncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n+\tstrncpy(ualg->cru_driver_name, alg->cra_driver_name,\n+\t\tsizeof(ualg->cru_driver_name));\n+\tstrncpy(ualg->cru_module_name, module_name(alg->cra_module),\n+\t\tsizeof(ualg->cru_module_name));\n+\n+\tualg->cru_type = 0;\n+\tualg->cru_mask = 0;\n \tualg->cru_flags = alg->cra_flags;\n \tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n \n@@ -122,8 +123,7 @@ static int crypto_report_one(struct crypto_alg *alg,\n \tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n \t\tstruct crypto_report_larval rl;\n \n-\t\tsnprintf(rl.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""larval\"");\n-\n+\t\tstrncpy(rl.type, \""larval\"", sizeof(rl.type));\n \t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n \t\t\t    sizeof(struct crypto_report_larval), &rl))\n \t\t\tgoto nla_put_failure;""}<_**next**_>{""sha"": ""7140fe70c7af04b2f544839b734de9aa5c461533"", ""filename"": ""crypto/pcompress.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/pcompress.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/pcompress.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/pcompress.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -53,8 +53,7 @@ static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_comp rpcomp;\n \n-\tsnprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""pcomp\"");\n-\n+\tstrncpy(rpcomp.type, \""pcomp\"", sizeof(rpcomp.type));\n \tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n \t\t    sizeof(struct crypto_report_comp), &rpcomp))\n \t\tgoto nla_put_failure;""}<_**next**_>{""sha"": ""e0a25c2456de4f7f92fa4ac1cc4daf9c48b5b209"", ""filename"": ""crypto/rng.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/rng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/rng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rng.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -65,7 +65,7 @@ static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_rng rrng;\n \n-\tsnprintf(rrng.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""rng\"");\n+\tstrncpy(rrng.type, \""rng\"", sizeof(rrng.type));\n \n \trrng.seedsize = alg->cra_rng.seedsize;\n ""}<_**next**_>{""sha"": ""929058a68561264c389719e26a3d22704bbbe18e"", ""filename"": ""crypto/shash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/shash.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/shash.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/shash.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -530,7 +530,8 @@ static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_hash rhash;\n \tstruct shash_alg *salg = __crypto_shash_alg(alg);\n \n-\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""shash\"");\n+\tstrncpy(rhash.type, \""shash\"", sizeof(rhash.type));\n+\n \trhash.blocksize = alg->cra_blocksize;\n \trhash.digestsize = salg->digestsize;\n ""}","static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_cipher rcipher;
 
	strncpy(rcipher.type, ""cipher"", sizeof(rcipher.type));
 
 	rcipher.blocksize = alg->cra_blocksize;
 	rcipher.min_keysize = alg->cra_cipher.cia_min_keysize;
	rcipher.max_keysize = alg->cra_cipher.cia_max_keysize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,
		    sizeof(struct crypto_report_cipher), &rcipher))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
","static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_cipher rcipher;
 
	snprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""cipher"");
 
 	rcipher.blocksize = alg->cra_blocksize;
 	rcipher.min_keysize = alg->cra_cipher.cia_min_keysize;
	rcipher.max_keysize = alg->cra_cipher.cia_max_keysize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,
		    sizeof(struct crypto_report_cipher), &rcipher))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
",C,"	strncpy(rcipher.type, ""cipher"", sizeof(rcipher.type));
","	snprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""cipher"");
",,"@@ -75,7 +75,7 @@ static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_cipher rcipher;
 
-	snprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""cipher"");
+	strncpy(rcipher.type, ""cipher"", sizeof(rcipher.type));
 
 	rcipher.blocksize = alg->cra_blocksize;
 	rcipher.min_keysize = alg->cra_cipher.cia_min_keysize;
@@ -94,8 +94,7 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_comp rcomp;
 
-	snprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""compression"");
-
+	strncpy(rcomp.type, ""compression"", sizeof(rcomp.type));
 	if (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,
 		    sizeof(struct crypto_report_comp), &rcomp))
 		goto nla_put_failure;
@@ -108,12 +107,14 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)
 static int crypto_report_one(struct crypto_alg *alg,
 			     struct crypto_user_alg *ualg, struct sk_buff *skb)
 {
-	memcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));
-	memcpy(&ualg->cru_driver_name, &alg->cra_driver_name,
-	       sizeof(ualg->cru_driver_name));
-	memcpy(&ualg->cru_module_name, module_name(alg->cra_module),
-	       CRYPTO_MAX_ALG_NAME);
-
+	strncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));
+	strncpy(ualg->cru_driver_name, alg->cra_driver_name,
+		sizeof(ualg->cru_driver_name));
+	strncpy(ualg->cru_module_name, module_name(alg->cra_module),
+		sizeof(ualg->cru_module_name));
+
+	ualg->cru_type = 0;
+	ualg->cru_mask = 0;
 	ualg->cru_flags = alg->cra_flags;
 	ualg->cru_refcnt = atomic_read(&alg->cra_refcnt);
 
@@ -122,8 +123,7 @@ static int crypto_report_one(struct crypto_alg *alg,
 	if (alg->cra_flags & CRYPTO_ALG_LARVAL) {
 		struct crypto_report_larval rl;
 
-		snprintf(rl.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""larval"");
-
+		strncpy(rl.type, ""larval"", sizeof(rl.type));
 		if (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,
 			    sizeof(struct crypto_report_larval), &rl))
 			goto nla_put_failure;",linux,9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,7eb9c5df92361c55daab4d8d4e8468eb774e297b,1,"static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_cipher rcipher;
 
//flaw_line_below:
	snprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""cipher"");
//fix_flaw_line_below:
//	strncpy(rcipher.type, ""cipher"", sizeof(rcipher.type));
 
 	rcipher.blocksize = alg->cra_blocksize;
 	rcipher.min_keysize = alg->cra_cipher.cia_min_keysize;
	rcipher.max_keysize = alg->cra_cipher.cia_max_keysize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,
		    sizeof(struct crypto_report_cipher), &rcipher))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
"
1504,179240,,Local,Not required,,CVE-2013-2548,https://www.cvedetails.com/cve/CVE-2013-2548/,CWE-310,Low,Partial,,,2013-03-15,2.1,"The crypto_report_one function in crypto/crypto_user.c in the report API in the crypto user configuration API in the Linux kernel through 3.8.2 uses an incorrect length value during a copy operation, which allows local users to obtain sensitive information from kernel memory by leveraging the CAP_NET_ADMIN capability.",2014-01-03,+Info ,1,https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,"crypto: user - fix info leaks in report API

Three errors resulting in kernel memory disclosure:

1/ The structures used for the netlink based crypto algorithm report API
are located on the stack. As snprintf() does not fill the remainder of
the buffer with null bytes, those stack bytes will be disclosed to users
of the API. Switch to strncpy() to fix this.

2/ crypto_report_one() does not initialize all field of struct
crypto_user_alg. Fix this to fix the heap info leak.

3/ For the module name we should copy only as many bytes as
module_name() returns -- not as much as the destination buffer could
hold. But the current code does not and therefore copies random data
from behind the end of the module name, as the module name is always
shorter than CRYPTO_MAX_ALG_NAME.

Also switch to use strncpy() to copy the algorithm's name and
driver_name. They are strings, after all.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Cc: Steffen Klassert <steffen.klassert@secunet.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",1,crypto/crypto_user.c,"{""sha"": ""7d4a8d28277e181386981dcef2d73ec377aefe9a"", ""filename"": ""crypto/ablkcipher.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ablkcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ablkcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ablkcipher.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -388,9 +388,9 @@ static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""ablkcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_ablkcipher.geniv ?: \""<default>\"");\n+\tstrncpy(rblkcipher.type, \""ablkcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \""<default>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n@@ -469,9 +469,9 @@ static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""givcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_ablkcipher.geniv ?: \""<built-in>\"");\n+\tstrncpy(rblkcipher.type, \""givcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \""<built-in>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;""}<_**next**_>{""sha"": ""547491e35c63733f15ccb4697cf83109128125aa"", ""filename"": ""crypto/aead.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/aead.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/aead.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/aead.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -117,9 +117,8 @@ static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n-\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""aead\"");\n-\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t aead->geniv ?: \""<built-in>\"");\n+\tstrncpy(raead.type, \""aead\"", sizeof(raead.type));\n+\tstrncpy(raead.geniv, aead->geniv ?: \""<built-in>\"", sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;\n@@ -203,8 +202,8 @@ static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n-\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""nivaead\"");\n-\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"", aead->geniv);\n+\tstrncpy(raead.type, \""nivaead\"", sizeof(raead.type));\n+\tstrncpy(raead.geniv, aead->geniv, sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;""}<_**next**_>{""sha"": ""793a27f2493e5287c1275df40feaca7b7b14c87e"", ""filename"": ""crypto/ahash.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ahash.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ahash.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ahash.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -404,7 +404,7 @@ static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_hash rhash;\n \n-\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""ahash\"");\n+\tstrncpy(rhash.type, \""ahash\"", sizeof(rhash.type));\n \n \trhash.blocksize = alg->cra_blocksize;\n \trhash.digestsize = __crypto_hash_alg_common(alg)->digestsize;""}<_**next**_>{""sha"": ""a79e7e9ab86e890d7eed95f3038b4424323a70f5"", ""filename"": ""crypto/blkcipher.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/blkcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/blkcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/blkcipher.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -499,9 +499,9 @@ static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""blkcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_blkcipher.geniv ?: \""<default>\"");\n+\tstrncpy(rblkcipher.type, \""blkcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_blkcipher.geniv ?: \""<default>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;""}<_**next**_>{""sha"": ""f6d9baf77f0a41b76b0fc39aebf26365a1284bca"", ""filename"": ""crypto/crypto_user.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 11, ""changes"": 22, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/crypto_user.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/crypto_user.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crypto_user.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -75,7 +75,7 @@ static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_cipher rcipher;\n \n-\tsnprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""cipher\"");\n+\tstrncpy(rcipher.type, \""cipher\"", sizeof(rcipher.type));\n \n \trcipher.blocksize = alg->cra_blocksize;\n \trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n@@ -94,8 +94,7 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_comp rcomp;\n \n-\tsnprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""compression\"");\n-\n+\tstrncpy(rcomp.type, \""compression\"", sizeof(rcomp.type));\n \tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n \t\t    sizeof(struct crypto_report_comp), &rcomp))\n \t\tgoto nla_put_failure;\n@@ -108,12 +107,14 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n static int crypto_report_one(struct crypto_alg *alg,\n \t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n {\n-\tmemcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));\n-\tmemcpy(&ualg->cru_driver_name, &alg->cra_driver_name,\n-\t       sizeof(ualg->cru_driver_name));\n-\tmemcpy(&ualg->cru_module_name, module_name(alg->cra_module),\n-\t       CRYPTO_MAX_ALG_NAME);\n-\n+\tstrncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n+\tstrncpy(ualg->cru_driver_name, alg->cra_driver_name,\n+\t\tsizeof(ualg->cru_driver_name));\n+\tstrncpy(ualg->cru_module_name, module_name(alg->cra_module),\n+\t\tsizeof(ualg->cru_module_name));\n+\n+\tualg->cru_type = 0;\n+\tualg->cru_mask = 0;\n \tualg->cru_flags = alg->cra_flags;\n \tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n \n@@ -122,8 +123,7 @@ static int crypto_report_one(struct crypto_alg *alg,\n \tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n \t\tstruct crypto_report_larval rl;\n \n-\t\tsnprintf(rl.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""larval\"");\n-\n+\t\tstrncpy(rl.type, \""larval\"", sizeof(rl.type));\n \t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n \t\t\t    sizeof(struct crypto_report_larval), &rl))\n \t\t\tgoto nla_put_failure;""}<_**next**_>{""sha"": ""7140fe70c7af04b2f544839b734de9aa5c461533"", ""filename"": ""crypto/pcompress.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/pcompress.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/pcompress.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/pcompress.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -53,8 +53,7 @@ static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_comp rpcomp;\n \n-\tsnprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""pcomp\"");\n-\n+\tstrncpy(rpcomp.type, \""pcomp\"", sizeof(rpcomp.type));\n \tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n \t\t    sizeof(struct crypto_report_comp), &rpcomp))\n \t\tgoto nla_put_failure;""}<_**next**_>{""sha"": ""e0a25c2456de4f7f92fa4ac1cc4daf9c48b5b209"", ""filename"": ""crypto/rng.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/rng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/rng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rng.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -65,7 +65,7 @@ static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_rng rrng;\n \n-\tsnprintf(rrng.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""rng\"");\n+\tstrncpy(rrng.type, \""rng\"", sizeof(rrng.type));\n \n \trrng.seedsize = alg->cra_rng.seedsize;\n ""}<_**next**_>{""sha"": ""929058a68561264c389719e26a3d22704bbbe18e"", ""filename"": ""crypto/shash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/shash.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/shash.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/shash.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -530,7 +530,8 @@ static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_hash rhash;\n \tstruct shash_alg *salg = __crypto_shash_alg(alg);\n \n-\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""shash\"");\n+\tstrncpy(rhash.type, \""shash\"", sizeof(rhash.type));\n+\n \trhash.blocksize = alg->cra_blocksize;\n \trhash.digestsize = salg->digestsize;\n ""}","static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_comp rcomp;
 
	strncpy(rcomp.type, ""compression"", sizeof(rcomp.type));
 	if (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,
 		    sizeof(struct crypto_report_comp), &rcomp))
 		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
","static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_comp rcomp;
 
	snprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""compression"");
 	if (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,
 		    sizeof(struct crypto_report_comp), &rcomp))
 		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
",C,"	strncpy(rcomp.type, ""compression"", sizeof(rcomp.type));
","	snprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""compression"");
",,"@@ -75,7 +75,7 @@ static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_cipher rcipher;
 
-	snprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""cipher"");
+	strncpy(rcipher.type, ""cipher"", sizeof(rcipher.type));
 
 	rcipher.blocksize = alg->cra_blocksize;
 	rcipher.min_keysize = alg->cra_cipher.cia_min_keysize;
@@ -94,8 +94,7 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_comp rcomp;
 
-	snprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""compression"");
-
+	strncpy(rcomp.type, ""compression"", sizeof(rcomp.type));
 	if (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,
 		    sizeof(struct crypto_report_comp), &rcomp))
 		goto nla_put_failure;
@@ -108,12 +107,14 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)
 static int crypto_report_one(struct crypto_alg *alg,
 			     struct crypto_user_alg *ualg, struct sk_buff *skb)
 {
-	memcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));
-	memcpy(&ualg->cru_driver_name, &alg->cra_driver_name,
-	       sizeof(ualg->cru_driver_name));
-	memcpy(&ualg->cru_module_name, module_name(alg->cra_module),
-	       CRYPTO_MAX_ALG_NAME);
-
+	strncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));
+	strncpy(ualg->cru_driver_name, alg->cra_driver_name,
+		sizeof(ualg->cru_driver_name));
+	strncpy(ualg->cru_module_name, module_name(alg->cra_module),
+		sizeof(ualg->cru_module_name));
+
+	ualg->cru_type = 0;
+	ualg->cru_mask = 0;
 	ualg->cru_flags = alg->cra_flags;
 	ualg->cru_refcnt = atomic_read(&alg->cra_refcnt);
 
@@ -122,8 +123,7 @@ static int crypto_report_one(struct crypto_alg *alg,
 	if (alg->cra_flags & CRYPTO_ALG_LARVAL) {
 		struct crypto_report_larval rl;
 
-		snprintf(rl.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""larval"");
-
+		strncpy(rl.type, ""larval"", sizeof(rl.type));
 		if (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,
 			    sizeof(struct crypto_report_larval), &rl))
 			goto nla_put_failure;",linux,9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,7eb9c5df92361c55daab4d8d4e8468eb774e297b,1,"static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_comp rcomp;
 
//flaw_line_below:
	snprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""compression"");
//flaw_line_below:

//fix_flaw_line_below:
//	strncpy(rcomp.type, ""compression"", sizeof(rcomp.type));
 	if (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,
 		    sizeof(struct crypto_report_comp), &rcomp))
 		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
"
1505,179241,,Local,Not required,,CVE-2013-2548,https://www.cvedetails.com/cve/CVE-2013-2548/,CWE-310,Low,Partial,,,2013-03-15,2.1,"The crypto_report_one function in crypto/crypto_user.c in the report API in the crypto user configuration API in the Linux kernel through 3.8.2 uses an incorrect length value during a copy operation, which allows local users to obtain sensitive information from kernel memory by leveraging the CAP_NET_ADMIN capability.",2014-01-03,+Info ,9,https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,"crypto: user - fix info leaks in report API

Three errors resulting in kernel memory disclosure:

1/ The structures used for the netlink based crypto algorithm report API
are located on the stack. As snprintf() does not fill the remainder of
the buffer with null bytes, those stack bytes will be disclosed to users
of the API. Switch to strncpy() to fix this.

2/ crypto_report_one() does not initialize all field of struct
crypto_user_alg. Fix this to fix the heap info leak.

3/ For the module name we should copy only as many bytes as
module_name() returns -- not as much as the destination buffer could
hold. But the current code does not and therefore copies random data
from behind the end of the module name, as the module name is always
shorter than CRYPTO_MAX_ALG_NAME.

Also switch to use strncpy() to copy the algorithm's name and
driver_name. They are strings, after all.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Cc: Steffen Klassert <steffen.klassert@secunet.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",6,crypto/crypto_user.c,"{""sha"": ""7d4a8d28277e181386981dcef2d73ec377aefe9a"", ""filename"": ""crypto/ablkcipher.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ablkcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ablkcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ablkcipher.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -388,9 +388,9 @@ static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""ablkcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_ablkcipher.geniv ?: \""<default>\"");\n+\tstrncpy(rblkcipher.type, \""ablkcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \""<default>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n@@ -469,9 +469,9 @@ static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""givcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_ablkcipher.geniv ?: \""<built-in>\"");\n+\tstrncpy(rblkcipher.type, \""givcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \""<built-in>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;""}<_**next**_>{""sha"": ""547491e35c63733f15ccb4697cf83109128125aa"", ""filename"": ""crypto/aead.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/aead.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/aead.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/aead.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -117,9 +117,8 @@ static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n-\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""aead\"");\n-\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t aead->geniv ?: \""<built-in>\"");\n+\tstrncpy(raead.type, \""aead\"", sizeof(raead.type));\n+\tstrncpy(raead.geniv, aead->geniv ?: \""<built-in>\"", sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;\n@@ -203,8 +202,8 @@ static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n-\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""nivaead\"");\n-\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"", aead->geniv);\n+\tstrncpy(raead.type, \""nivaead\"", sizeof(raead.type));\n+\tstrncpy(raead.geniv, aead->geniv, sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;""}<_**next**_>{""sha"": ""793a27f2493e5287c1275df40feaca7b7b14c87e"", ""filename"": ""crypto/ahash.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ahash.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ahash.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ahash.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -404,7 +404,7 @@ static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_hash rhash;\n \n-\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""ahash\"");\n+\tstrncpy(rhash.type, \""ahash\"", sizeof(rhash.type));\n \n \trhash.blocksize = alg->cra_blocksize;\n \trhash.digestsize = __crypto_hash_alg_common(alg)->digestsize;""}<_**next**_>{""sha"": ""a79e7e9ab86e890d7eed95f3038b4424323a70f5"", ""filename"": ""crypto/blkcipher.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/blkcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/blkcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/blkcipher.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -499,9 +499,9 @@ static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""blkcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_blkcipher.geniv ?: \""<default>\"");\n+\tstrncpy(rblkcipher.type, \""blkcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_blkcipher.geniv ?: \""<default>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;""}<_**next**_>{""sha"": ""f6d9baf77f0a41b76b0fc39aebf26365a1284bca"", ""filename"": ""crypto/crypto_user.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 11, ""changes"": 22, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/crypto_user.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/crypto_user.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crypto_user.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -75,7 +75,7 @@ static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_cipher rcipher;\n \n-\tsnprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""cipher\"");\n+\tstrncpy(rcipher.type, \""cipher\"", sizeof(rcipher.type));\n \n \trcipher.blocksize = alg->cra_blocksize;\n \trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n@@ -94,8 +94,7 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_comp rcomp;\n \n-\tsnprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""compression\"");\n-\n+\tstrncpy(rcomp.type, \""compression\"", sizeof(rcomp.type));\n \tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n \t\t    sizeof(struct crypto_report_comp), &rcomp))\n \t\tgoto nla_put_failure;\n@@ -108,12 +107,14 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n static int crypto_report_one(struct crypto_alg *alg,\n \t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n {\n-\tmemcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));\n-\tmemcpy(&ualg->cru_driver_name, &alg->cra_driver_name,\n-\t       sizeof(ualg->cru_driver_name));\n-\tmemcpy(&ualg->cru_module_name, module_name(alg->cra_module),\n-\t       CRYPTO_MAX_ALG_NAME);\n-\n+\tstrncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n+\tstrncpy(ualg->cru_driver_name, alg->cra_driver_name,\n+\t\tsizeof(ualg->cru_driver_name));\n+\tstrncpy(ualg->cru_module_name, module_name(alg->cra_module),\n+\t\tsizeof(ualg->cru_module_name));\n+\n+\tualg->cru_type = 0;\n+\tualg->cru_mask = 0;\n \tualg->cru_flags = alg->cra_flags;\n \tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n \n@@ -122,8 +123,7 @@ static int crypto_report_one(struct crypto_alg *alg,\n \tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n \t\tstruct crypto_report_larval rl;\n \n-\t\tsnprintf(rl.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""larval\"");\n-\n+\t\tstrncpy(rl.type, \""larval\"", sizeof(rl.type));\n \t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n \t\t\t    sizeof(struct crypto_report_larval), &rl))\n \t\t\tgoto nla_put_failure;""}<_**next**_>{""sha"": ""7140fe70c7af04b2f544839b734de9aa5c461533"", ""filename"": ""crypto/pcompress.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/pcompress.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/pcompress.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/pcompress.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -53,8 +53,7 @@ static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_comp rpcomp;\n \n-\tsnprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""pcomp\"");\n-\n+\tstrncpy(rpcomp.type, \""pcomp\"", sizeof(rpcomp.type));\n \tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n \t\t    sizeof(struct crypto_report_comp), &rpcomp))\n \t\tgoto nla_put_failure;""}<_**next**_>{""sha"": ""e0a25c2456de4f7f92fa4ac1cc4daf9c48b5b209"", ""filename"": ""crypto/rng.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/rng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/rng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rng.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -65,7 +65,7 @@ static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_rng rrng;\n \n-\tsnprintf(rrng.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""rng\"");\n+\tstrncpy(rrng.type, \""rng\"", sizeof(rrng.type));\n \n \trrng.seedsize = alg->cra_rng.seedsize;\n ""}<_**next**_>{""sha"": ""929058a68561264c389719e26a3d22704bbbe18e"", ""filename"": ""crypto/shash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/shash.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/shash.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/shash.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -530,7 +530,8 @@ static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_hash rhash;\n \tstruct shash_alg *salg = __crypto_shash_alg(alg);\n \n-\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""shash\"");\n+\tstrncpy(rhash.type, \""shash\"", sizeof(rhash.type));\n+\n \trhash.blocksize = alg->cra_blocksize;\n \trhash.digestsize = salg->digestsize;\n ""}"," static int crypto_report_one(struct crypto_alg *alg,
 			     struct crypto_user_alg *ualg, struct sk_buff *skb)
 {
	strncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));
	strncpy(ualg->cru_driver_name, alg->cra_driver_name,
		sizeof(ualg->cru_driver_name));
	strncpy(ualg->cru_module_name, module_name(alg->cra_module),
		sizeof(ualg->cru_module_name));

	ualg->cru_type = 0;
	ualg->cru_mask = 0;
 	ualg->cru_flags = alg->cra_flags;
 	ualg->cru_refcnt = atomic_read(&alg->cra_refcnt);
 
	if (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))
		goto nla_put_failure;
 	if (alg->cra_flags & CRYPTO_ALG_LARVAL) {
 		struct crypto_report_larval rl;
 
		strncpy(rl.type, ""larval"", sizeof(rl.type));
 		if (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,
 			    sizeof(struct crypto_report_larval), &rl))
 			goto nla_put_failure;
		goto out;
	}

	if (alg->cra_type && alg->cra_type->report) {
		if (alg->cra_type->report(skb, alg))
			goto nla_put_failure;

		goto out;
	}

	switch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {
	case CRYPTO_ALG_TYPE_CIPHER:
		if (crypto_report_cipher(skb, alg))
			goto nla_put_failure;

		break;
	case CRYPTO_ALG_TYPE_COMPRESS:
		if (crypto_report_comp(skb, alg))
			goto nla_put_failure;

		break;
	}

out:
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
"," static int crypto_report_one(struct crypto_alg *alg,
 			     struct crypto_user_alg *ualg, struct sk_buff *skb)
 {
	memcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));
	memcpy(&ualg->cru_driver_name, &alg->cra_driver_name,
	       sizeof(ualg->cru_driver_name));
	memcpy(&ualg->cru_module_name, module_name(alg->cra_module),
	       CRYPTO_MAX_ALG_NAME);
 	ualg->cru_flags = alg->cra_flags;
 	ualg->cru_refcnt = atomic_read(&alg->cra_refcnt);
 
	if (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))
		goto nla_put_failure;
 	if (alg->cra_flags & CRYPTO_ALG_LARVAL) {
 		struct crypto_report_larval rl;
 
		snprintf(rl.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""larval"");
 		if (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,
 			    sizeof(struct crypto_report_larval), &rl))
 			goto nla_put_failure;
		goto out;
	}

	if (alg->cra_type && alg->cra_type->report) {
		if (alg->cra_type->report(skb, alg))
			goto nla_put_failure;

		goto out;
	}

	switch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {
	case CRYPTO_ALG_TYPE_CIPHER:
		if (crypto_report_cipher(skb, alg))
			goto nla_put_failure;

		break;
	case CRYPTO_ALG_TYPE_COMPRESS:
		if (crypto_report_comp(skb, alg))
			goto nla_put_failure;

		break;
	}

out:
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
",C,"	strncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));
	strncpy(ualg->cru_driver_name, alg->cra_driver_name,
		sizeof(ualg->cru_driver_name));
	strncpy(ualg->cru_module_name, module_name(alg->cra_module),
		sizeof(ualg->cru_module_name));

	ualg->cru_type = 0;
	ualg->cru_mask = 0;
		strncpy(rl.type, ""larval"", sizeof(rl.type));
","	memcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));
	memcpy(&ualg->cru_driver_name, &alg->cra_driver_name,
	       sizeof(ualg->cru_driver_name));
	memcpy(&ualg->cru_module_name, module_name(alg->cra_module),
	       CRYPTO_MAX_ALG_NAME);
		snprintf(rl.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""larval"");
",,"@@ -75,7 +75,7 @@ static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_cipher rcipher;
 
-	snprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""cipher"");
+	strncpy(rcipher.type, ""cipher"", sizeof(rcipher.type));
 
 	rcipher.blocksize = alg->cra_blocksize;
 	rcipher.min_keysize = alg->cra_cipher.cia_min_keysize;
@@ -94,8 +94,7 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_comp rcomp;
 
-	snprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""compression"");
-
+	strncpy(rcomp.type, ""compression"", sizeof(rcomp.type));
 	if (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,
 		    sizeof(struct crypto_report_comp), &rcomp))
 		goto nla_put_failure;
@@ -108,12 +107,14 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)
 static int crypto_report_one(struct crypto_alg *alg,
 			     struct crypto_user_alg *ualg, struct sk_buff *skb)
 {
-	memcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));
-	memcpy(&ualg->cru_driver_name, &alg->cra_driver_name,
-	       sizeof(ualg->cru_driver_name));
-	memcpy(&ualg->cru_module_name, module_name(alg->cra_module),
-	       CRYPTO_MAX_ALG_NAME);
-
+	strncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));
+	strncpy(ualg->cru_driver_name, alg->cra_driver_name,
+		sizeof(ualg->cru_driver_name));
+	strncpy(ualg->cru_module_name, module_name(alg->cra_module),
+		sizeof(ualg->cru_module_name));
+
+	ualg->cru_type = 0;
+	ualg->cru_mask = 0;
 	ualg->cru_flags = alg->cra_flags;
 	ualg->cru_refcnt = atomic_read(&alg->cra_refcnt);
 
@@ -122,8 +123,7 @@ static int crypto_report_one(struct crypto_alg *alg,
 	if (alg->cra_flags & CRYPTO_ALG_LARVAL) {
 		struct crypto_report_larval rl;
 
-		snprintf(rl.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""larval"");
-
+		strncpy(rl.type, ""larval"", sizeof(rl.type));
 		if (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,
 			    sizeof(struct crypto_report_larval), &rl))
 			goto nla_put_failure;",linux,9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,7eb9c5df92361c55daab4d8d4e8468eb774e297b,1," static int crypto_report_one(struct crypto_alg *alg,
 			     struct crypto_user_alg *ualg, struct sk_buff *skb)
 {
//flaw_line_below:
	memcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));
//flaw_line_below:
	memcpy(&ualg->cru_driver_name, &alg->cra_driver_name,
//flaw_line_below:
	       sizeof(ualg->cru_driver_name));
//flaw_line_below:
	memcpy(&ualg->cru_module_name, module_name(alg->cra_module),
//flaw_line_below:
	       CRYPTO_MAX_ALG_NAME);
//flaw_line_below:

//fix_flaw_line_below:
//	strncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));
//fix_flaw_line_below:
//	strncpy(ualg->cru_driver_name, alg->cra_driver_name,
//fix_flaw_line_below:
//		sizeof(ualg->cru_driver_name));
//fix_flaw_line_below:
//	strncpy(ualg->cru_module_name, module_name(alg->cra_module),
//fix_flaw_line_below:
//		sizeof(ualg->cru_module_name));
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	ualg->cru_type = 0;
//fix_flaw_line_below:
//	ualg->cru_mask = 0;
 	ualg->cru_flags = alg->cra_flags;
 	ualg->cru_refcnt = atomic_read(&alg->cra_refcnt);
 
	if (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))
		goto nla_put_failure;
 	if (alg->cra_flags & CRYPTO_ALG_LARVAL) {
 		struct crypto_report_larval rl;
 
//flaw_line_below:
		snprintf(rl.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""larval"");
//flaw_line_below:

//fix_flaw_line_below:
//		strncpy(rl.type, ""larval"", sizeof(rl.type));
 		if (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,
 			    sizeof(struct crypto_report_larval), &rl))
 			goto nla_put_failure;
		goto out;
	}

	if (alg->cra_type && alg->cra_type->report) {
		if (alg->cra_type->report(skb, alg))
			goto nla_put_failure;

		goto out;
	}

	switch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {
	case CRYPTO_ALG_TYPE_CIPHER:
		if (crypto_report_cipher(skb, alg))
			goto nla_put_failure;

		break;
	case CRYPTO_ALG_TYPE_COMPRESS:
		if (crypto_report_comp(skb, alg))
			goto nla_put_failure;

		break;
	}

out:
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
"
1506,179242,,Local,Not required,,CVE-2013-2548,https://www.cvedetails.com/cve/CVE-2013-2548/,CWE-310,Low,Partial,,,2013-03-15,2.1,"The crypto_report_one function in crypto/crypto_user.c in the report API in the crypto user configuration API in the Linux kernel through 3.8.2 uses an incorrect length value during a copy operation, which allows local users to obtain sensitive information from kernel memory by leveraging the CAP_NET_ADMIN capability.",2014-01-03,+Info ,1,https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,"crypto: user - fix info leaks in report API

Three errors resulting in kernel memory disclosure:

1/ The structures used for the netlink based crypto algorithm report API
are located on the stack. As snprintf() does not fill the remainder of
the buffer with null bytes, those stack bytes will be disclosed to users
of the API. Switch to strncpy() to fix this.

2/ crypto_report_one() does not initialize all field of struct
crypto_user_alg. Fix this to fix the heap info leak.

3/ For the module name we should copy only as many bytes as
module_name() returns -- not as much as the destination buffer could
hold. But the current code does not and therefore copies random data
from behind the end of the module name, as the module name is always
shorter than CRYPTO_MAX_ALG_NAME.

Also switch to use strncpy() to copy the algorithm's name and
driver_name. They are strings, after all.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Cc: Steffen Klassert <steffen.klassert@secunet.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",1,crypto/pcompress.c,"{""sha"": ""7d4a8d28277e181386981dcef2d73ec377aefe9a"", ""filename"": ""crypto/ablkcipher.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ablkcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ablkcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ablkcipher.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -388,9 +388,9 @@ static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""ablkcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_ablkcipher.geniv ?: \""<default>\"");\n+\tstrncpy(rblkcipher.type, \""ablkcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \""<default>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n@@ -469,9 +469,9 @@ static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""givcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_ablkcipher.geniv ?: \""<built-in>\"");\n+\tstrncpy(rblkcipher.type, \""givcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \""<built-in>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;""}<_**next**_>{""sha"": ""547491e35c63733f15ccb4697cf83109128125aa"", ""filename"": ""crypto/aead.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/aead.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/aead.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/aead.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -117,9 +117,8 @@ static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n-\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""aead\"");\n-\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t aead->geniv ?: \""<built-in>\"");\n+\tstrncpy(raead.type, \""aead\"", sizeof(raead.type));\n+\tstrncpy(raead.geniv, aead->geniv ?: \""<built-in>\"", sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;\n@@ -203,8 +202,8 @@ static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n-\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""nivaead\"");\n-\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"", aead->geniv);\n+\tstrncpy(raead.type, \""nivaead\"", sizeof(raead.type));\n+\tstrncpy(raead.geniv, aead->geniv, sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;""}<_**next**_>{""sha"": ""793a27f2493e5287c1275df40feaca7b7b14c87e"", ""filename"": ""crypto/ahash.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ahash.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ahash.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ahash.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -404,7 +404,7 @@ static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_hash rhash;\n \n-\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""ahash\"");\n+\tstrncpy(rhash.type, \""ahash\"", sizeof(rhash.type));\n \n \trhash.blocksize = alg->cra_blocksize;\n \trhash.digestsize = __crypto_hash_alg_common(alg)->digestsize;""}<_**next**_>{""sha"": ""a79e7e9ab86e890d7eed95f3038b4424323a70f5"", ""filename"": ""crypto/blkcipher.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/blkcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/blkcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/blkcipher.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -499,9 +499,9 @@ static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""blkcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_blkcipher.geniv ?: \""<default>\"");\n+\tstrncpy(rblkcipher.type, \""blkcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_blkcipher.geniv ?: \""<default>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;""}<_**next**_>{""sha"": ""f6d9baf77f0a41b76b0fc39aebf26365a1284bca"", ""filename"": ""crypto/crypto_user.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 11, ""changes"": 22, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/crypto_user.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/crypto_user.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crypto_user.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -75,7 +75,7 @@ static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_cipher rcipher;\n \n-\tsnprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""cipher\"");\n+\tstrncpy(rcipher.type, \""cipher\"", sizeof(rcipher.type));\n \n \trcipher.blocksize = alg->cra_blocksize;\n \trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n@@ -94,8 +94,7 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_comp rcomp;\n \n-\tsnprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""compression\"");\n-\n+\tstrncpy(rcomp.type, \""compression\"", sizeof(rcomp.type));\n \tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n \t\t    sizeof(struct crypto_report_comp), &rcomp))\n \t\tgoto nla_put_failure;\n@@ -108,12 +107,14 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n static int crypto_report_one(struct crypto_alg *alg,\n \t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n {\n-\tmemcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));\n-\tmemcpy(&ualg->cru_driver_name, &alg->cra_driver_name,\n-\t       sizeof(ualg->cru_driver_name));\n-\tmemcpy(&ualg->cru_module_name, module_name(alg->cra_module),\n-\t       CRYPTO_MAX_ALG_NAME);\n-\n+\tstrncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n+\tstrncpy(ualg->cru_driver_name, alg->cra_driver_name,\n+\t\tsizeof(ualg->cru_driver_name));\n+\tstrncpy(ualg->cru_module_name, module_name(alg->cra_module),\n+\t\tsizeof(ualg->cru_module_name));\n+\n+\tualg->cru_type = 0;\n+\tualg->cru_mask = 0;\n \tualg->cru_flags = alg->cra_flags;\n \tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n \n@@ -122,8 +123,7 @@ static int crypto_report_one(struct crypto_alg *alg,\n \tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n \t\tstruct crypto_report_larval rl;\n \n-\t\tsnprintf(rl.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""larval\"");\n-\n+\t\tstrncpy(rl.type, \""larval\"", sizeof(rl.type));\n \t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n \t\t\t    sizeof(struct crypto_report_larval), &rl))\n \t\t\tgoto nla_put_failure;""}<_**next**_>{""sha"": ""7140fe70c7af04b2f544839b734de9aa5c461533"", ""filename"": ""crypto/pcompress.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/pcompress.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/pcompress.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/pcompress.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -53,8 +53,7 @@ static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_comp rpcomp;\n \n-\tsnprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""pcomp\"");\n-\n+\tstrncpy(rpcomp.type, \""pcomp\"", sizeof(rpcomp.type));\n \tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n \t\t    sizeof(struct crypto_report_comp), &rpcomp))\n \t\tgoto nla_put_failure;""}<_**next**_>{""sha"": ""e0a25c2456de4f7f92fa4ac1cc4daf9c48b5b209"", ""filename"": ""crypto/rng.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/rng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/rng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rng.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -65,7 +65,7 @@ static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_rng rrng;\n \n-\tsnprintf(rrng.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""rng\"");\n+\tstrncpy(rrng.type, \""rng\"", sizeof(rrng.type));\n \n \trrng.seedsize = alg->cra_rng.seedsize;\n ""}<_**next**_>{""sha"": ""929058a68561264c389719e26a3d22704bbbe18e"", ""filename"": ""crypto/shash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/shash.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/shash.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/shash.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -530,7 +530,8 @@ static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_hash rhash;\n \tstruct shash_alg *salg = __crypto_shash_alg(alg);\n \n-\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""shash\"");\n+\tstrncpy(rhash.type, \""shash\"", sizeof(rhash.type));\n+\n \trhash.blocksize = alg->cra_blocksize;\n \trhash.digestsize = salg->digestsize;\n ""}","static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_comp rpcomp;
 
	strncpy(rpcomp.type, ""pcomp"", sizeof(rpcomp.type));
 	if (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,
 		    sizeof(struct crypto_report_comp), &rpcomp))
 		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
","static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_comp rpcomp;
 
	snprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""pcomp"");
 	if (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,
 		    sizeof(struct crypto_report_comp), &rpcomp))
 		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
",C,"	strncpy(rpcomp.type, ""pcomp"", sizeof(rpcomp.type));
","	snprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""pcomp"");
",,"@@ -53,8 +53,7 @@ static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_comp rpcomp;
 
-	snprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""pcomp"");
-
+	strncpy(rpcomp.type, ""pcomp"", sizeof(rpcomp.type));
 	if (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,
 		    sizeof(struct crypto_report_comp), &rpcomp))
 		goto nla_put_failure;",linux,9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,7eb9c5df92361c55daab4d8d4e8468eb774e297b,1,"static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_comp rpcomp;
 
//flaw_line_below:
	snprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""pcomp"");
//flaw_line_below:

//fix_flaw_line_below:
//	strncpy(rpcomp.type, ""pcomp"", sizeof(rpcomp.type));
 	if (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,
 		    sizeof(struct crypto_report_comp), &rpcomp))
 		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
"
1507,179243,,Local,Not required,,CVE-2013-2548,https://www.cvedetails.com/cve/CVE-2013-2548/,CWE-310,Low,Partial,,,2013-03-15,2.1,"The crypto_report_one function in crypto/crypto_user.c in the report API in the crypto user configuration API in the Linux kernel through 3.8.2 uses an incorrect length value during a copy operation, which allows local users to obtain sensitive information from kernel memory by leveraging the CAP_NET_ADMIN capability.",2014-01-03,+Info ,1,https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,"crypto: user - fix info leaks in report API

Three errors resulting in kernel memory disclosure:

1/ The structures used for the netlink based crypto algorithm report API
are located on the stack. As snprintf() does not fill the remainder of
the buffer with null bytes, those stack bytes will be disclosed to users
of the API. Switch to strncpy() to fix this.

2/ crypto_report_one() does not initialize all field of struct
crypto_user_alg. Fix this to fix the heap info leak.

3/ For the module name we should copy only as many bytes as
module_name() returns -- not as much as the destination buffer could
hold. But the current code does not and therefore copies random data
from behind the end of the module name, as the module name is always
shorter than CRYPTO_MAX_ALG_NAME.

Also switch to use strncpy() to copy the algorithm's name and
driver_name. They are strings, after all.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Cc: Steffen Klassert <steffen.klassert@secunet.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",1,crypto/rng.c,"{""sha"": ""7d4a8d28277e181386981dcef2d73ec377aefe9a"", ""filename"": ""crypto/ablkcipher.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ablkcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ablkcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ablkcipher.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -388,9 +388,9 @@ static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""ablkcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_ablkcipher.geniv ?: \""<default>\"");\n+\tstrncpy(rblkcipher.type, \""ablkcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \""<default>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n@@ -469,9 +469,9 @@ static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""givcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_ablkcipher.geniv ?: \""<built-in>\"");\n+\tstrncpy(rblkcipher.type, \""givcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \""<built-in>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;""}<_**next**_>{""sha"": ""547491e35c63733f15ccb4697cf83109128125aa"", ""filename"": ""crypto/aead.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/aead.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/aead.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/aead.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -117,9 +117,8 @@ static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n-\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""aead\"");\n-\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t aead->geniv ?: \""<built-in>\"");\n+\tstrncpy(raead.type, \""aead\"", sizeof(raead.type));\n+\tstrncpy(raead.geniv, aead->geniv ?: \""<built-in>\"", sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;\n@@ -203,8 +202,8 @@ static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n-\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""nivaead\"");\n-\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"", aead->geniv);\n+\tstrncpy(raead.type, \""nivaead\"", sizeof(raead.type));\n+\tstrncpy(raead.geniv, aead->geniv, sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;""}<_**next**_>{""sha"": ""793a27f2493e5287c1275df40feaca7b7b14c87e"", ""filename"": ""crypto/ahash.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ahash.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ahash.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ahash.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -404,7 +404,7 @@ static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_hash rhash;\n \n-\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""ahash\"");\n+\tstrncpy(rhash.type, \""ahash\"", sizeof(rhash.type));\n \n \trhash.blocksize = alg->cra_blocksize;\n \trhash.digestsize = __crypto_hash_alg_common(alg)->digestsize;""}<_**next**_>{""sha"": ""a79e7e9ab86e890d7eed95f3038b4424323a70f5"", ""filename"": ""crypto/blkcipher.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/blkcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/blkcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/blkcipher.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -499,9 +499,9 @@ static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""blkcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_blkcipher.geniv ?: \""<default>\"");\n+\tstrncpy(rblkcipher.type, \""blkcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_blkcipher.geniv ?: \""<default>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;""}<_**next**_>{""sha"": ""f6d9baf77f0a41b76b0fc39aebf26365a1284bca"", ""filename"": ""crypto/crypto_user.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 11, ""changes"": 22, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/crypto_user.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/crypto_user.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crypto_user.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -75,7 +75,7 @@ static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_cipher rcipher;\n \n-\tsnprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""cipher\"");\n+\tstrncpy(rcipher.type, \""cipher\"", sizeof(rcipher.type));\n \n \trcipher.blocksize = alg->cra_blocksize;\n \trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n@@ -94,8 +94,7 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_comp rcomp;\n \n-\tsnprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""compression\"");\n-\n+\tstrncpy(rcomp.type, \""compression\"", sizeof(rcomp.type));\n \tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n \t\t    sizeof(struct crypto_report_comp), &rcomp))\n \t\tgoto nla_put_failure;\n@@ -108,12 +107,14 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n static int crypto_report_one(struct crypto_alg *alg,\n \t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n {\n-\tmemcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));\n-\tmemcpy(&ualg->cru_driver_name, &alg->cra_driver_name,\n-\t       sizeof(ualg->cru_driver_name));\n-\tmemcpy(&ualg->cru_module_name, module_name(alg->cra_module),\n-\t       CRYPTO_MAX_ALG_NAME);\n-\n+\tstrncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n+\tstrncpy(ualg->cru_driver_name, alg->cra_driver_name,\n+\t\tsizeof(ualg->cru_driver_name));\n+\tstrncpy(ualg->cru_module_name, module_name(alg->cra_module),\n+\t\tsizeof(ualg->cru_module_name));\n+\n+\tualg->cru_type = 0;\n+\tualg->cru_mask = 0;\n \tualg->cru_flags = alg->cra_flags;\n \tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n \n@@ -122,8 +123,7 @@ static int crypto_report_one(struct crypto_alg *alg,\n \tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n \t\tstruct crypto_report_larval rl;\n \n-\t\tsnprintf(rl.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""larval\"");\n-\n+\t\tstrncpy(rl.type, \""larval\"", sizeof(rl.type));\n \t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n \t\t\t    sizeof(struct crypto_report_larval), &rl))\n \t\t\tgoto nla_put_failure;""}<_**next**_>{""sha"": ""7140fe70c7af04b2f544839b734de9aa5c461533"", ""filename"": ""crypto/pcompress.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/pcompress.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/pcompress.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/pcompress.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -53,8 +53,7 @@ static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_comp rpcomp;\n \n-\tsnprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""pcomp\"");\n-\n+\tstrncpy(rpcomp.type, \""pcomp\"", sizeof(rpcomp.type));\n \tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n \t\t    sizeof(struct crypto_report_comp), &rpcomp))\n \t\tgoto nla_put_failure;""}<_**next**_>{""sha"": ""e0a25c2456de4f7f92fa4ac1cc4daf9c48b5b209"", ""filename"": ""crypto/rng.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/rng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/rng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rng.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -65,7 +65,7 @@ static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_rng rrng;\n \n-\tsnprintf(rrng.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""rng\"");\n+\tstrncpy(rrng.type, \""rng\"", sizeof(rrng.type));\n \n \trrng.seedsize = alg->cra_rng.seedsize;\n ""}<_**next**_>{""sha"": ""929058a68561264c389719e26a3d22704bbbe18e"", ""filename"": ""crypto/shash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/shash.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/shash.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/shash.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -530,7 +530,8 @@ static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_hash rhash;\n \tstruct shash_alg *salg = __crypto_shash_alg(alg);\n \n-\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""shash\"");\n+\tstrncpy(rhash.type, \""shash\"", sizeof(rhash.type));\n+\n \trhash.blocksize = alg->cra_blocksize;\n \trhash.digestsize = salg->digestsize;\n ""}","static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_rng rrng;
 
	strncpy(rrng.type, ""rng"", sizeof(rrng.type));
 
 	rrng.seedsize = alg->cra_rng.seedsize;
 
	if (nla_put(skb, CRYPTOCFGA_REPORT_RNG,
		    sizeof(struct crypto_report_rng), &rrng))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
","static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_rng rrng;
 
	snprintf(rrng.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""rng"");
 
 	rrng.seedsize = alg->cra_rng.seedsize;
 
	if (nla_put(skb, CRYPTOCFGA_REPORT_RNG,
		    sizeof(struct crypto_report_rng), &rrng))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
",C,"	strncpy(rrng.type, ""rng"", sizeof(rrng.type));
","	snprintf(rrng.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""rng"");
",,"@@ -65,7 +65,7 @@ static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_rng rrng;
 
-	snprintf(rrng.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""rng"");
+	strncpy(rrng.type, ""rng"", sizeof(rrng.type));
 
 	rrng.seedsize = alg->cra_rng.seedsize;
 ",linux,9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,7eb9c5df92361c55daab4d8d4e8468eb774e297b,1,"static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_rng rrng;
 
//flaw_line_below:
	snprintf(rrng.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""rng"");
//fix_flaw_line_below:
//	strncpy(rrng.type, ""rng"", sizeof(rrng.type));
 
 	rrng.seedsize = alg->cra_rng.seedsize;
 
	if (nla_put(skb, CRYPTOCFGA_REPORT_RNG,
		    sizeof(struct crypto_report_rng), &rrng))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
"
1508,179244,,Local,Not required,,CVE-2013-2548,https://www.cvedetails.com/cve/CVE-2013-2548/,CWE-310,Low,Partial,,,2013-03-15,2.1,"The crypto_report_one function in crypto/crypto_user.c in the report API in the crypto user configuration API in the Linux kernel through 3.8.2 uses an incorrect length value during a copy operation, which allows local users to obtain sensitive information from kernel memory by leveraging the CAP_NET_ADMIN capability.",2014-01-03,+Info ,2,https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,"crypto: user - fix info leaks in report API

Three errors resulting in kernel memory disclosure:

1/ The structures used for the netlink based crypto algorithm report API
are located on the stack. As snprintf() does not fill the remainder of
the buffer with null bytes, those stack bytes will be disclosed to users
of the API. Switch to strncpy() to fix this.

2/ crypto_report_one() does not initialize all field of struct
crypto_user_alg. Fix this to fix the heap info leak.

3/ For the module name we should copy only as many bytes as
module_name() returns -- not as much as the destination buffer could
hold. But the current code does not and therefore copies random data
from behind the end of the module name, as the module name is always
shorter than CRYPTO_MAX_ALG_NAME.

Also switch to use strncpy() to copy the algorithm's name and
driver_name. They are strings, after all.

Signed-off-by: Mathias Krause <minipli@googlemail.com>
Cc: Steffen Klassert <steffen.klassert@secunet.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",1,crypto/shash.c,"{""sha"": ""7d4a8d28277e181386981dcef2d73ec377aefe9a"", ""filename"": ""crypto/ablkcipher.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ablkcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ablkcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ablkcipher.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -388,9 +388,9 @@ static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""ablkcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_ablkcipher.geniv ?: \""<default>\"");\n+\tstrncpy(rblkcipher.type, \""ablkcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \""<default>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n@@ -469,9 +469,9 @@ static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""givcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_ablkcipher.geniv ?: \""<built-in>\"");\n+\tstrncpy(rblkcipher.type, \""givcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \""<built-in>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;""}<_**next**_>{""sha"": ""547491e35c63733f15ccb4697cf83109128125aa"", ""filename"": ""crypto/aead.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/aead.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/aead.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/aead.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -117,9 +117,8 @@ static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n-\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""aead\"");\n-\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t aead->geniv ?: \""<built-in>\"");\n+\tstrncpy(raead.type, \""aead\"", sizeof(raead.type));\n+\tstrncpy(raead.geniv, aead->geniv ?: \""<built-in>\"", sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;\n@@ -203,8 +202,8 @@ static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n-\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""nivaead\"");\n-\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"", aead->geniv);\n+\tstrncpy(raead.type, \""nivaead\"", sizeof(raead.type));\n+\tstrncpy(raead.geniv, aead->geniv, sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;""}<_**next**_>{""sha"": ""793a27f2493e5287c1275df40feaca7b7b14c87e"", ""filename"": ""crypto/ahash.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ahash.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/ahash.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ahash.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -404,7 +404,7 @@ static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_hash rhash;\n \n-\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""ahash\"");\n+\tstrncpy(rhash.type, \""ahash\"", sizeof(rhash.type));\n \n \trhash.blocksize = alg->cra_blocksize;\n \trhash.digestsize = __crypto_hash_alg_common(alg)->digestsize;""}<_**next**_>{""sha"": ""a79e7e9ab86e890d7eed95f3038b4424323a70f5"", ""filename"": ""crypto/blkcipher.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/blkcipher.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/blkcipher.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/blkcipher.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -499,9 +499,9 @@ static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_blkcipher rblkcipher;\n \n-\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""blkcipher\"");\n-\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \""%s\"",\n-\t\t alg->cra_blkcipher.geniv ?: \""<default>\"");\n+\tstrncpy(rblkcipher.type, \""blkcipher\"", sizeof(rblkcipher.type));\n+\tstrncpy(rblkcipher.geniv, alg->cra_blkcipher.geniv ?: \""<default>\"",\n+\t\tsizeof(rblkcipher.geniv));\n \n \trblkcipher.blocksize = alg->cra_blocksize;\n \trblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;""}<_**next**_>{""sha"": ""f6d9baf77f0a41b76b0fc39aebf26365a1284bca"", ""filename"": ""crypto/crypto_user.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 11, ""changes"": 22, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/crypto_user.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/crypto_user.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crypto_user.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -75,7 +75,7 @@ static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_cipher rcipher;\n \n-\tsnprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""cipher\"");\n+\tstrncpy(rcipher.type, \""cipher\"", sizeof(rcipher.type));\n \n \trcipher.blocksize = alg->cra_blocksize;\n \trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n@@ -94,8 +94,7 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_comp rcomp;\n \n-\tsnprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""compression\"");\n-\n+\tstrncpy(rcomp.type, \""compression\"", sizeof(rcomp.type));\n \tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n \t\t    sizeof(struct crypto_report_comp), &rcomp))\n \t\tgoto nla_put_failure;\n@@ -108,12 +107,14 @@ static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n static int crypto_report_one(struct crypto_alg *alg,\n \t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n {\n-\tmemcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));\n-\tmemcpy(&ualg->cru_driver_name, &alg->cra_driver_name,\n-\t       sizeof(ualg->cru_driver_name));\n-\tmemcpy(&ualg->cru_module_name, module_name(alg->cra_module),\n-\t       CRYPTO_MAX_ALG_NAME);\n-\n+\tstrncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n+\tstrncpy(ualg->cru_driver_name, alg->cra_driver_name,\n+\t\tsizeof(ualg->cru_driver_name));\n+\tstrncpy(ualg->cru_module_name, module_name(alg->cra_module),\n+\t\tsizeof(ualg->cru_module_name));\n+\n+\tualg->cru_type = 0;\n+\tualg->cru_mask = 0;\n \tualg->cru_flags = alg->cra_flags;\n \tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n \n@@ -122,8 +123,7 @@ static int crypto_report_one(struct crypto_alg *alg,\n \tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n \t\tstruct crypto_report_larval rl;\n \n-\t\tsnprintf(rl.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""larval\"");\n-\n+\t\tstrncpy(rl.type, \""larval\"", sizeof(rl.type));\n \t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n \t\t\t    sizeof(struct crypto_report_larval), &rl))\n \t\t\tgoto nla_put_failure;""}<_**next**_>{""sha"": ""7140fe70c7af04b2f544839b734de9aa5c461533"", ""filename"": ""crypto/pcompress.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/pcompress.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/pcompress.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/pcompress.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -53,8 +53,7 @@ static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_comp rpcomp;\n \n-\tsnprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""pcomp\"");\n-\n+\tstrncpy(rpcomp.type, \""pcomp\"", sizeof(rpcomp.type));\n \tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n \t\t    sizeof(struct crypto_report_comp), &rpcomp))\n \t\tgoto nla_put_failure;""}<_**next**_>{""sha"": ""e0a25c2456de4f7f92fa4ac1cc4daf9c48b5b209"", ""filename"": ""crypto/rng.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/rng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/rng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rng.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -65,7 +65,7 @@ static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_rng rrng;\n \n-\tsnprintf(rrng.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""rng\"");\n+\tstrncpy(rrng.type, \""rng\"", sizeof(rrng.type));\n \n \trrng.seedsize = alg->cra_rng.seedsize;\n ""}<_**next**_>{""sha"": ""929058a68561264c389719e26a3d22704bbbe18e"", ""filename"": ""crypto/shash.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/shash.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6/crypto/shash.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/shash.c?ref=9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6"", ""patch"": ""@@ -530,7 +530,8 @@ static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)\n \tstruct crypto_report_hash rhash;\n \tstruct shash_alg *salg = __crypto_shash_alg(alg);\n \n-\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \""%s\"", \""shash\"");\n+\tstrncpy(rhash.type, \""shash\"", sizeof(rhash.type));\n+\n \trhash.blocksize = alg->cra_blocksize;\n \trhash.digestsize = salg->digestsize;\n ""}","static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)
{
 	struct crypto_report_hash rhash;
 	struct shash_alg *salg = __crypto_shash_alg(alg);
 
	strncpy(rhash.type, ""shash"", sizeof(rhash.type));

 	rhash.blocksize = alg->cra_blocksize;
 	rhash.digestsize = salg->digestsize;
 
	if (nla_put(skb, CRYPTOCFGA_REPORT_HASH,
		    sizeof(struct crypto_report_hash), &rhash))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
","static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)
{
 	struct crypto_report_hash rhash;
 	struct shash_alg *salg = __crypto_shash_alg(alg);
 
	snprintf(rhash.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""shash"");
 	rhash.blocksize = alg->cra_blocksize;
 	rhash.digestsize = salg->digestsize;
 
	if (nla_put(skb, CRYPTOCFGA_REPORT_HASH,
		    sizeof(struct crypto_report_hash), &rhash))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
",C,"	strncpy(rhash.type, ""shash"", sizeof(rhash.type));

","	snprintf(rhash.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""shash"");
",,"@@ -530,7 +530,8 @@ static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)
 	struct crypto_report_hash rhash;
 	struct shash_alg *salg = __crypto_shash_alg(alg);
 
-	snprintf(rhash.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""shash"");
+	strncpy(rhash.type, ""shash"", sizeof(rhash.type));
+
 	rhash.blocksize = alg->cra_blocksize;
 	rhash.digestsize = salg->digestsize;
 ",linux,9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6,7eb9c5df92361c55daab4d8d4e8468eb774e297b,1,"static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)
{
 	struct crypto_report_hash rhash;
 	struct shash_alg *salg = __crypto_shash_alg(alg);
 
//flaw_line_below:
	snprintf(rhash.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""shash"");
//fix_flaw_line_below:
//	strncpy(rhash.type, ""shash"", sizeof(rhash.type));
//fix_flaw_line_below:
//
 	rhash.blocksize = alg->cra_blocksize;
 	rhash.digestsize = salg->digestsize;
 
	if (nla_put(skb, CRYPTOCFGA_REPORT_HASH,
		    sizeof(struct crypto_report_hash), &rhash))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
"
1629,179365,,Local,Not required,Complete,CVE-2012-5375,https://www.cvedetails.com/cve/CVE-2012-5375/,CWE-310,High,,,,2013-02-18,4.0,"The CRC32C feature in the Btrfs implementation in the Linux kernel before 3.8-rc1 allows local users to cause a denial of service (prevention of file creation) by leveraging the ability to write to a directory important to the victim, and creating a file with a crafted name that is associated with a specific CRC32C hash value.",2014-01-03,DoS ,1,https://github.com/torvalds/linux/commit/9c52057c698fb96f8f07e7a4bcf4801a092bda89,9c52057c698fb96f8f07e7a4bcf4801a092bda89,"Btrfs: fix hash overflow handling

The handling for directory crc hash overflows was fairly obscure,
split_leaf returns EOVERFLOW when we try to extend the item and that is
supposed to bubble up to userland.  For a while it did so, but along the
way we added better handling of errors and forced the FS readonly if we
hit IO errors during the directory insertion.

Along the way, we started testing only for EEXIST and the EOVERFLOW case
was dropped.  The end result is that we may force the FS readonly if we
catch a directory hash bucket overflow.

This fixes a few problem spots.  First I add tests for EOVERFLOW in the
places where we can safely just return the error up the chain.

btrfs_rename is harder though, because it tries to insert the new
directory item only after it has already unlinked anything the rename
was going to overwrite.  Rather than adding very complex logic, I added
a helper to test for the hash overflow case early while it is still safe
to bail out.

Snapshot and subvolume creation had a similar problem, so they are using
the new helper now too.

Signed-off-by: Chris Mason <chris.mason@fusionio.com>
Reported-by: Pascal Junod <pascal@junod.info>",1,fs/btrfs/inode.c,"{""sha"": ""547b7b05727f917dfc2bad6516f5c5b30ea12c68"", ""filename"": ""fs/btrfs/ctree.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/ctree.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/ctree.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/ctree.h?ref=9c52057c698fb96f8f07e7a4bcf4801a092bda89"", ""patch"": ""@@ -3283,6 +3283,8 @@ void btrfs_update_root_times(struct btrfs_trans_handle *trans,\n \t\t\t     struct btrfs_root *root);\n \n /* dir-item.c */\n+int btrfs_check_dir_item_collision(struct btrfs_root *root, u64 dir,\n+\t\t\t  const char *name, int name_len);\n int btrfs_insert_dir_item(struct btrfs_trans_handle *trans,\n \t\t\t  struct btrfs_root *root, const char *name,\n \t\t\t  int name_len, struct inode *dir,""}<_**next**_>{""sha"": ""502c2158167c8fb95578f8166a9802a34e762def"", ""filename"": ""fs/btrfs/dir-item.c"", ""status"": ""modified"", ""additions"": 59, ""deletions"": 0, ""changes"": 59, ""blob_url"": ""https://github.com/torvalds/linux/blob/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/dir-item.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/dir-item.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/dir-item.c?ref=9c52057c698fb96f8f07e7a4bcf4801a092bda89"", ""patch"": ""@@ -213,6 +213,65 @@ struct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n \treturn btrfs_match_dir_item_name(root, path, name, name_len);\n }\n \n+int btrfs_check_dir_item_collision(struct btrfs_root *root, u64 dir,\n+\t\t\t\t   const char *name, int name_len)\n+{\n+\tint ret;\n+\tstruct btrfs_key key;\n+\tstruct btrfs_dir_item *di;\n+\tint data_size;\n+\tstruct extent_buffer *leaf;\n+\tint slot;\n+\tstruct btrfs_path *path;\n+\n+\n+\tpath = btrfs_alloc_path();\n+\tif (!path)\n+\t\treturn -ENOMEM;\n+\n+\tkey.objectid = dir;\n+\tbtrfs_set_key_type(&key, BTRFS_DIR_ITEM_KEY);\n+\tkey.offset = btrfs_name_hash(name, name_len);\n+\n+\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n+\n+\t/* return back any errors */\n+\tif (ret < 0)\n+\t\tgoto out;\n+\n+\t/* nothing found, we're safe */\n+\tif (ret > 0) {\n+\t\tret = 0;\n+\t\tgoto out;\n+\t}\n+\n+\t/* we found an item, look for our name in the item */\n+\tdi = btrfs_match_dir_item_name(root, path, name, name_len);\n+\tif (di) {\n+\t\t/* our exact name was found */\n+\t\tret = -EEXIST;\n+\t\tgoto out;\n+\t}\n+\n+\t/*\n+\t * see if there is room in the item to insert this\n+\t * name\n+\t */\n+\tdata_size = sizeof(*di) + name_len + sizeof(struct btrfs_item);\n+\tleaf = path->nodes[0];\n+\tslot = path->slots[0];\n+\tif (data_size + btrfs_item_size_nr(leaf, slot) +\n+\t    sizeof(struct btrfs_item) > BTRFS_LEAF_DATA_SIZE(root)) {\n+\t\tret = -EOVERFLOW;\n+\t} else {\n+\t\t/* plenty of insertion room */\n+\t\tret = 0;\n+\t}\n+out:\n+\tbtrfs_free_path(path);\n+\treturn ret;\n+}\n+\n /*\n  * lookup a directory item based on index.  'dir' is the objectid\n  * we're searching in, and 'mod' tells us if you plan on deleting the""}<_**next**_>{""sha"": ""e95b1f90a1f6676b73514877db83fc72986df66a"", ""filename"": ""fs/btrfs/inode.c"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 1, ""changes"": 24, ""blob_url"": ""https://github.com/torvalds/linux/blob/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/inode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/inode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/inode.c?ref=9c52057c698fb96f8f07e7a4bcf4801a092bda89"", ""patch"": ""@@ -4885,7 +4885,7 @@ int btrfs_add_link(struct btrfs_trans_handle *trans,\n \tret = btrfs_insert_dir_item(trans, root, name, name_len,\n \t\t\t\t    parent_inode, &key,\n \t\t\t\t    btrfs_inode_type(inode), index);\n-\tif (ret == -EEXIST)\n+\tif (ret == -EEXIST || ret == -EOVERFLOW)\n \t\tgoto fail_dir_item;\n \telse if (ret) {\n \t\tbtrfs_abort_transaction(trans, root, ret);\n@@ -7336,6 +7336,28 @@ static int btrfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n \tif (S_ISDIR(old_inode->i_mode) && new_inode &&\n \t    new_inode->i_size > BTRFS_EMPTY_DIR_SIZE)\n \t\treturn -ENOTEMPTY;\n+\n+\n+\t/* check for collisions, even if the  name isn't there */\n+\tret = btrfs_check_dir_item_collision(root, new_dir->i_ino,\n+\t\t\t     new_dentry->d_name.name,\n+\t\t\t     new_dentry->d_name.len);\n+\n+\tif (ret) {\n+\t\tif (ret == -EEXIST) {\n+\t\t\t/* we shouldn't get\n+\t\t\t * eexist without a new_inode */\n+\t\t\tif (!new_inode) {\n+\t\t\t\tWARN_ON(1);\n+\t\t\t\treturn ret;\n+\t\t\t}\n+\t\t} else {\n+\t\t\t/* maybe -EOVERFLOW */\n+\t\t\treturn ret;\n+\t\t}\n+\t}\n+\tret = 0;\n+\n \t/*\n \t * we're using rename to replace one file with another.\n \t * and the replacement file is large.  Start IO on it now so""}<_**next**_>{""sha"": ""d4608ab72b791682803da6761e52335cb367f31e"", ""filename"": ""fs/btrfs/ioctl.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 0, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/ioctl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/ioctl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/ioctl.c?ref=9c52057c698fb96f8f07e7a4bcf4801a092bda89"", ""patch"": ""@@ -710,6 +710,16 @@ static noinline int btrfs_mksubvol(struct path *parent,\n \tif (error)\n \t\tgoto out_dput;\n \n+\t/*\n+\t * even if this name doesn't exist, we may get hash collisions.\n+\t * check for them now when we can safely fail\n+\t */\n+\terror = btrfs_check_dir_item_collision(BTRFS_I(dir)->root,\n+\t\t\t\t\t       dir->i_ino, name,\n+\t\t\t\t\t       namelen);\n+\tif (error)\n+\t\tgoto out_dput;\n+\n \tdown_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\n \n \tif (btrfs_root_refs(&BTRFS_I(dir)->root->root_item) == 0)""}<_**next**_>{""sha"": ""87fac9a21ea56578625536ac1229678e854ec5f7"", ""filename"": ""fs/btrfs/transaction.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/transaction.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/transaction.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/transaction.c?ref=9c52057c698fb96f8f07e7a4bcf4801a092bda89"", ""patch"": ""@@ -1190,7 +1190,7 @@ static noinline int create_pending_snapshot(struct btrfs_trans_handle *trans,\n \t\t\t\t    parent_inode, &key,\n \t\t\t\t    BTRFS_FT_DIR, index);\n \t/* We have check then name at the beginning, so it is impossible. */\n-\tBUG_ON(ret == -EEXIST);\n+\tBUG_ON(ret == -EEXIST || ret == -EOVERFLOW);\n \tif (ret) {\n \t\tbtrfs_abort_transaction(trans, root, ret);\n \t\tgoto fail;""}","int btrfs_add_link(struct btrfs_trans_handle *trans,
		   struct inode *parent_inode, struct inode *inode,
		   const char *name, int name_len, int add_backref, u64 index)
{
	int ret = 0;
	struct btrfs_key key;
	struct btrfs_root *root = BTRFS_I(parent_inode)->root;
	u64 ino = btrfs_ino(inode);
	u64 parent_ino = btrfs_ino(parent_inode);

	if (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {
		memcpy(&key, &BTRFS_I(inode)->root->root_key, sizeof(key));
	} else {
		key.objectid = ino;
		btrfs_set_key_type(&key, BTRFS_INODE_ITEM_KEY);
		key.offset = 0;
	}

	if (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {
		ret = btrfs_add_root_ref(trans, root->fs_info->tree_root,
					 key.objectid, root->root_key.objectid,
					 parent_ino, index, name, name_len);
	} else if (add_backref) {
		ret = btrfs_insert_inode_ref(trans, root, name, name_len, ino,
					     parent_ino, index);
	}

	/* Nothing to clean up yet */
	if (ret)
		return ret;

 	ret = btrfs_insert_dir_item(trans, root, name, name_len,
 				    parent_inode, &key,
 				    btrfs_inode_type(inode), index);
	if (ret == -EEXIST || ret == -EOVERFLOW)
 		goto fail_dir_item;
 	else if (ret) {
 		btrfs_abort_transaction(trans, root, ret);
		return ret;
	}

	btrfs_i_size_write(parent_inode, parent_inode->i_size +
			   name_len * 2);
	inode_inc_iversion(parent_inode);
	parent_inode->i_mtime = parent_inode->i_ctime = CURRENT_TIME;
	ret = btrfs_update_inode(trans, root, parent_inode);
	if (ret)
		btrfs_abort_transaction(trans, root, ret);
	return ret;

fail_dir_item:
	if (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {
		u64 local_index;
		int err;
		err = btrfs_del_root_ref(trans, root->fs_info->tree_root,
				 key.objectid, root->root_key.objectid,
				 parent_ino, &local_index, name, name_len);

	} else if (add_backref) {
		u64 local_index;
		int err;

		err = btrfs_del_inode_ref(trans, root, name, name_len,
					  ino, parent_ino, &local_index);
	}
	return ret;
}
","int btrfs_add_link(struct btrfs_trans_handle *trans,
		   struct inode *parent_inode, struct inode *inode,
		   const char *name, int name_len, int add_backref, u64 index)
{
	int ret = 0;
	struct btrfs_key key;
	struct btrfs_root *root = BTRFS_I(parent_inode)->root;
	u64 ino = btrfs_ino(inode);
	u64 parent_ino = btrfs_ino(parent_inode);

	if (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {
		memcpy(&key, &BTRFS_I(inode)->root->root_key, sizeof(key));
	} else {
		key.objectid = ino;
		btrfs_set_key_type(&key, BTRFS_INODE_ITEM_KEY);
		key.offset = 0;
	}

	if (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {
		ret = btrfs_add_root_ref(trans, root->fs_info->tree_root,
					 key.objectid, root->root_key.objectid,
					 parent_ino, index, name, name_len);
	} else if (add_backref) {
		ret = btrfs_insert_inode_ref(trans, root, name, name_len, ino,
					     parent_ino, index);
	}

	/* Nothing to clean up yet */
	if (ret)
		return ret;

 	ret = btrfs_insert_dir_item(trans, root, name, name_len,
 				    parent_inode, &key,
 				    btrfs_inode_type(inode), index);
	if (ret == -EEXIST)
 		goto fail_dir_item;
 	else if (ret) {
 		btrfs_abort_transaction(trans, root, ret);
		return ret;
	}

	btrfs_i_size_write(parent_inode, parent_inode->i_size +
			   name_len * 2);
	inode_inc_iversion(parent_inode);
	parent_inode->i_mtime = parent_inode->i_ctime = CURRENT_TIME;
	ret = btrfs_update_inode(trans, root, parent_inode);
	if (ret)
		btrfs_abort_transaction(trans, root, ret);
	return ret;

fail_dir_item:
	if (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {
		u64 local_index;
		int err;
		err = btrfs_del_root_ref(trans, root->fs_info->tree_root,
				 key.objectid, root->root_key.objectid,
				 parent_ino, &local_index, name, name_len);

	} else if (add_backref) {
		u64 local_index;
		int err;

		err = btrfs_del_inode_ref(trans, root, name, name_len,
					  ino, parent_ino, &local_index);
	}
	return ret;
}
",C,"	if (ret == -EEXIST || ret == -EOVERFLOW)
","	if (ret == -EEXIST)
",,"@@ -4885,7 +4885,7 @@ int btrfs_add_link(struct btrfs_trans_handle *trans,
 	ret = btrfs_insert_dir_item(trans, root, name, name_len,
 				    parent_inode, &key,
 				    btrfs_inode_type(inode), index);
-	if (ret == -EEXIST)
+	if (ret == -EEXIST || ret == -EOVERFLOW)
 		goto fail_dir_item;
 	else if (ret) {
 		btrfs_abort_transaction(trans, root, ret);
@@ -7336,6 +7336,28 @@ static int btrfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 	if (S_ISDIR(old_inode->i_mode) && new_inode &&
 	    new_inode->i_size > BTRFS_EMPTY_DIR_SIZE)
 		return -ENOTEMPTY;
+
+
+	/* check for collisions, even if the  name isn't there */
+	ret = btrfs_check_dir_item_collision(root, new_dir->i_ino,
+			     new_dentry->d_name.name,
+			     new_dentry->d_name.len);
+
+	if (ret) {
+		if (ret == -EEXIST) {
+			/* we shouldn't get
+			 * eexist without a new_inode */
+			if (!new_inode) {
+				WARN_ON(1);
+				return ret;
+			}
+		} else {
+			/* maybe -EOVERFLOW */
+			return ret;
+		}
+	}
+	ret = 0;
+
 	/*
 	 * we're using rename to replace one file with another.
 	 * and the replacement file is large.  Start IO on it now so",linux,9c52057c698fb96f8f07e7a4bcf4801a092bda89,c64c2bd890df3b9a66c52c33df110777058c011e,1,"int btrfs_add_link(struct btrfs_trans_handle *trans,
		   struct inode *parent_inode, struct inode *inode,
		   const char *name, int name_len, int add_backref, u64 index)
{
	int ret = 0;
	struct btrfs_key key;
	struct btrfs_root *root = BTRFS_I(parent_inode)->root;
	u64 ino = btrfs_ino(inode);
	u64 parent_ino = btrfs_ino(parent_inode);

	if (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {
		memcpy(&key, &BTRFS_I(inode)->root->root_key, sizeof(key));
	} else {
		key.objectid = ino;
		btrfs_set_key_type(&key, BTRFS_INODE_ITEM_KEY);
		key.offset = 0;
	}

	if (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {
		ret = btrfs_add_root_ref(trans, root->fs_info->tree_root,
					 key.objectid, root->root_key.objectid,
					 parent_ino, index, name, name_len);
	} else if (add_backref) {
		ret = btrfs_insert_inode_ref(trans, root, name, name_len, ino,
					     parent_ino, index);
	}

	/* Nothing to clean up yet */
	if (ret)
		return ret;

 	ret = btrfs_insert_dir_item(trans, root, name, name_len,
 				    parent_inode, &key,
 				    btrfs_inode_type(inode), index);
//flaw_line_below:
	if (ret == -EEXIST)
//fix_flaw_line_below:
//	if (ret == -EEXIST || ret == -EOVERFLOW)
 		goto fail_dir_item;
 	else if (ret) {
 		btrfs_abort_transaction(trans, root, ret);
		return ret;
	}

	btrfs_i_size_write(parent_inode, parent_inode->i_size +
			   name_len * 2);
	inode_inc_iversion(parent_inode);
	parent_inode->i_mtime = parent_inode->i_ctime = CURRENT_TIME;
	ret = btrfs_update_inode(trans, root, parent_inode);
	if (ret)
		btrfs_abort_transaction(trans, root, ret);
	return ret;

fail_dir_item:
	if (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {
		u64 local_index;
		int err;
		err = btrfs_del_root_ref(trans, root->fs_info->tree_root,
				 key.objectid, root->root_key.objectid,
				 parent_ino, &local_index, name, name_len);

	} else if (add_backref) {
		u64 local_index;
		int err;

		err = btrfs_del_inode_ref(trans, root, name, name_len,
					  ino, parent_ino, &local_index);
	}
	return ret;
}
"
1630,179366,,Local,Not required,Complete,CVE-2012-5375,https://www.cvedetails.com/cve/CVE-2012-5375/,CWE-310,High,,,,2013-02-18,4.0,"The CRC32C feature in the Btrfs implementation in the Linux kernel before 3.8-rc1 allows local users to cause a denial of service (prevention of file creation) by leveraging the ability to write to a directory important to the victim, and creating a file with a crafted name that is associated with a specific CRC32C hash value.",2014-01-03,DoS ,22,https://github.com/torvalds/linux/commit/9c52057c698fb96f8f07e7a4bcf4801a092bda89,9c52057c698fb96f8f07e7a4bcf4801a092bda89,"Btrfs: fix hash overflow handling

The handling for directory crc hash overflows was fairly obscure,
split_leaf returns EOVERFLOW when we try to extend the item and that is
supposed to bubble up to userland.  For a while it did so, but along the
way we added better handling of errors and forced the FS readonly if we
hit IO errors during the directory insertion.

Along the way, we started testing only for EEXIST and the EOVERFLOW case
was dropped.  The end result is that we may force the FS readonly if we
catch a directory hash bucket overflow.

This fixes a few problem spots.  First I add tests for EOVERFLOW in the
places where we can safely just return the error up the chain.

btrfs_rename is harder though, because it tries to insert the new
directory item only after it has already unlinked anything the rename
was going to overwrite.  Rather than adding very complex logic, I added
a helper to test for the hash overflow case early while it is still safe
to bail out.

Snapshot and subvolume creation had a similar problem, so they are using
the new helper now too.

Signed-off-by: Chris Mason <chris.mason@fusionio.com>
Reported-by: Pascal Junod <pascal@junod.info>",0,fs/btrfs/inode.c,"{""sha"": ""547b7b05727f917dfc2bad6516f5c5b30ea12c68"", ""filename"": ""fs/btrfs/ctree.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/ctree.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/ctree.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/ctree.h?ref=9c52057c698fb96f8f07e7a4bcf4801a092bda89"", ""patch"": ""@@ -3283,6 +3283,8 @@ void btrfs_update_root_times(struct btrfs_trans_handle *trans,\n \t\t\t     struct btrfs_root *root);\n \n /* dir-item.c */\n+int btrfs_check_dir_item_collision(struct btrfs_root *root, u64 dir,\n+\t\t\t  const char *name, int name_len);\n int btrfs_insert_dir_item(struct btrfs_trans_handle *trans,\n \t\t\t  struct btrfs_root *root, const char *name,\n \t\t\t  int name_len, struct inode *dir,""}<_**next**_>{""sha"": ""502c2158167c8fb95578f8166a9802a34e762def"", ""filename"": ""fs/btrfs/dir-item.c"", ""status"": ""modified"", ""additions"": 59, ""deletions"": 0, ""changes"": 59, ""blob_url"": ""https://github.com/torvalds/linux/blob/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/dir-item.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/dir-item.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/dir-item.c?ref=9c52057c698fb96f8f07e7a4bcf4801a092bda89"", ""patch"": ""@@ -213,6 +213,65 @@ struct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n \treturn btrfs_match_dir_item_name(root, path, name, name_len);\n }\n \n+int btrfs_check_dir_item_collision(struct btrfs_root *root, u64 dir,\n+\t\t\t\t   const char *name, int name_len)\n+{\n+\tint ret;\n+\tstruct btrfs_key key;\n+\tstruct btrfs_dir_item *di;\n+\tint data_size;\n+\tstruct extent_buffer *leaf;\n+\tint slot;\n+\tstruct btrfs_path *path;\n+\n+\n+\tpath = btrfs_alloc_path();\n+\tif (!path)\n+\t\treturn -ENOMEM;\n+\n+\tkey.objectid = dir;\n+\tbtrfs_set_key_type(&key, BTRFS_DIR_ITEM_KEY);\n+\tkey.offset = btrfs_name_hash(name, name_len);\n+\n+\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n+\n+\t/* return back any errors */\n+\tif (ret < 0)\n+\t\tgoto out;\n+\n+\t/* nothing found, we're safe */\n+\tif (ret > 0) {\n+\t\tret = 0;\n+\t\tgoto out;\n+\t}\n+\n+\t/* we found an item, look for our name in the item */\n+\tdi = btrfs_match_dir_item_name(root, path, name, name_len);\n+\tif (di) {\n+\t\t/* our exact name was found */\n+\t\tret = -EEXIST;\n+\t\tgoto out;\n+\t}\n+\n+\t/*\n+\t * see if there is room in the item to insert this\n+\t * name\n+\t */\n+\tdata_size = sizeof(*di) + name_len + sizeof(struct btrfs_item);\n+\tleaf = path->nodes[0];\n+\tslot = path->slots[0];\n+\tif (data_size + btrfs_item_size_nr(leaf, slot) +\n+\t    sizeof(struct btrfs_item) > BTRFS_LEAF_DATA_SIZE(root)) {\n+\t\tret = -EOVERFLOW;\n+\t} else {\n+\t\t/* plenty of insertion room */\n+\t\tret = 0;\n+\t}\n+out:\n+\tbtrfs_free_path(path);\n+\treturn ret;\n+}\n+\n /*\n  * lookup a directory item based on index.  'dir' is the objectid\n  * we're searching in, and 'mod' tells us if you plan on deleting the""}<_**next**_>{""sha"": ""e95b1f90a1f6676b73514877db83fc72986df66a"", ""filename"": ""fs/btrfs/inode.c"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 1, ""changes"": 24, ""blob_url"": ""https://github.com/torvalds/linux/blob/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/inode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/inode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/inode.c?ref=9c52057c698fb96f8f07e7a4bcf4801a092bda89"", ""patch"": ""@@ -4885,7 +4885,7 @@ int btrfs_add_link(struct btrfs_trans_handle *trans,\n \tret = btrfs_insert_dir_item(trans, root, name, name_len,\n \t\t\t\t    parent_inode, &key,\n \t\t\t\t    btrfs_inode_type(inode), index);\n-\tif (ret == -EEXIST)\n+\tif (ret == -EEXIST || ret == -EOVERFLOW)\n \t\tgoto fail_dir_item;\n \telse if (ret) {\n \t\tbtrfs_abort_transaction(trans, root, ret);\n@@ -7336,6 +7336,28 @@ static int btrfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n \tif (S_ISDIR(old_inode->i_mode) && new_inode &&\n \t    new_inode->i_size > BTRFS_EMPTY_DIR_SIZE)\n \t\treturn -ENOTEMPTY;\n+\n+\n+\t/* check for collisions, even if the  name isn't there */\n+\tret = btrfs_check_dir_item_collision(root, new_dir->i_ino,\n+\t\t\t     new_dentry->d_name.name,\n+\t\t\t     new_dentry->d_name.len);\n+\n+\tif (ret) {\n+\t\tif (ret == -EEXIST) {\n+\t\t\t/* we shouldn't get\n+\t\t\t * eexist without a new_inode */\n+\t\t\tif (!new_inode) {\n+\t\t\t\tWARN_ON(1);\n+\t\t\t\treturn ret;\n+\t\t\t}\n+\t\t} else {\n+\t\t\t/* maybe -EOVERFLOW */\n+\t\t\treturn ret;\n+\t\t}\n+\t}\n+\tret = 0;\n+\n \t/*\n \t * we're using rename to replace one file with another.\n \t * and the replacement file is large.  Start IO on it now so""}<_**next**_>{""sha"": ""d4608ab72b791682803da6761e52335cb367f31e"", ""filename"": ""fs/btrfs/ioctl.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 0, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/ioctl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/ioctl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/ioctl.c?ref=9c52057c698fb96f8f07e7a4bcf4801a092bda89"", ""patch"": ""@@ -710,6 +710,16 @@ static noinline int btrfs_mksubvol(struct path *parent,\n \tif (error)\n \t\tgoto out_dput;\n \n+\t/*\n+\t * even if this name doesn't exist, we may get hash collisions.\n+\t * check for them now when we can safely fail\n+\t */\n+\terror = btrfs_check_dir_item_collision(BTRFS_I(dir)->root,\n+\t\t\t\t\t       dir->i_ino, name,\n+\t\t\t\t\t       namelen);\n+\tif (error)\n+\t\tgoto out_dput;\n+\n \tdown_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\n \n \tif (btrfs_root_refs(&BTRFS_I(dir)->root->root_item) == 0)""}<_**next**_>{""sha"": ""87fac9a21ea56578625536ac1229678e854ec5f7"", ""filename"": ""fs/btrfs/transaction.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/transaction.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/transaction.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/transaction.c?ref=9c52057c698fb96f8f07e7a4bcf4801a092bda89"", ""patch"": ""@@ -1190,7 +1190,7 @@ static noinline int create_pending_snapshot(struct btrfs_trans_handle *trans,\n \t\t\t\t    parent_inode, &key,\n \t\t\t\t    BTRFS_FT_DIR, index);\n \t/* We have check then name at the beginning, so it is impossible. */\n-\tBUG_ON(ret == -EEXIST);\n+\tBUG_ON(ret == -EEXIST || ret == -EOVERFLOW);\n \tif (ret) {\n \t\tbtrfs_abort_transaction(trans, root, ret);\n \t\tgoto fail;""}","static int btrfs_rename(struct inode *old_dir, struct dentry *old_dentry,
			   struct inode *new_dir, struct dentry *new_dentry)
{
	struct btrfs_trans_handle *trans;
	struct btrfs_root *root = BTRFS_I(old_dir)->root;
	struct btrfs_root *dest = BTRFS_I(new_dir)->root;
	struct inode *new_inode = new_dentry->d_inode;
	struct inode *old_inode = old_dentry->d_inode;
	struct timespec ctime = CURRENT_TIME;
	u64 index = 0;
	u64 root_objectid;
	int ret;
	u64 old_ino = btrfs_ino(old_inode);

	if (btrfs_ino(new_dir) == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID)
		return -EPERM;

	/* we only allow rename subvolume link between subvolumes */
	if (old_ino != BTRFS_FIRST_FREE_OBJECTID && root != dest)
		return -EXDEV;

	if (old_ino == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID ||
	    (new_inode && btrfs_ino(new_inode) == BTRFS_FIRST_FREE_OBJECTID))
		return -ENOTEMPTY;

 	if (S_ISDIR(old_inode->i_mode) && new_inode &&
 	    new_inode->i_size > BTRFS_EMPTY_DIR_SIZE)
 		return -ENOTEMPTY;


	/* check for collisions, even if the  name isn't there */
	ret = btrfs_check_dir_item_collision(root, new_dir->i_ino,
			     new_dentry->d_name.name,
			     new_dentry->d_name.len);

	if (ret) {
		if (ret == -EEXIST) {
			/* we shouldn't get
			 * eexist without a new_inode */
			if (!new_inode) {
				WARN_ON(1);
				return ret;
			}
		} else {
			/* maybe -EOVERFLOW */
			return ret;
		}
	}
	ret = 0;

 	/*
 	 * we're using rename to replace one file with another.
 	 * and the replacement file is large.  Start IO on it now so
	 * we don't add too much work to the end of the transaction
	 */
	if (new_inode && S_ISREG(old_inode->i_mode) && new_inode->i_size &&
	    old_inode->i_size > BTRFS_ORDERED_OPERATIONS_FLUSH_LIMIT)
		filemap_flush(old_inode->i_mapping);

	/* close the racy window with snapshot create/destroy ioctl */
	if (old_ino == BTRFS_FIRST_FREE_OBJECTID)
		down_read(&root->fs_info->subvol_sem);
	/*
	 * We want to reserve the absolute worst case amount of items.  So if
	 * both inodes are subvols and we need to unlink them then that would
	 * require 4 item modifications, but if they are both normal inodes it
	 * would require 5 item modifications, so we'll assume their normal
	 * inodes.  So 5 * 2 is 10, plus 1 for the new link, so 11 total items
	 * should cover the worst case number of items we'll modify.
	 */
	trans = btrfs_start_transaction(root, 20);
	if (IS_ERR(trans)) {
                ret = PTR_ERR(trans);
                goto out_notrans;
        }

	if (dest != root)
		btrfs_record_root_in_trans(trans, dest);

	ret = btrfs_set_inode_index(new_dir, &index);
	if (ret)
		goto out_fail;

	if (unlikely(old_ino == BTRFS_FIRST_FREE_OBJECTID)) {
		/* force full log commit if subvolume involved. */
		root->fs_info->last_trans_log_full_commit = trans->transid;
	} else {
		ret = btrfs_insert_inode_ref(trans, dest,
					     new_dentry->d_name.name,
					     new_dentry->d_name.len,
					     old_ino,
					     btrfs_ino(new_dir), index);
		if (ret)
			goto out_fail;
		/*
		 * this is an ugly little race, but the rename is required
		 * to make sure that if we crash, the inode is either at the
		 * old name or the new one.  pinning the log transaction lets
		 * us make sure we don't allow a log commit to come in after
		 * we unlink the name but before we add the new name back in.
		 */
		btrfs_pin_log_trans(root);
	}
	/*
	 * make sure the inode gets flushed if it is replacing
	 * something.
	 */
	if (new_inode && new_inode->i_size && S_ISREG(old_inode->i_mode))
		btrfs_add_ordered_operation(trans, root, old_inode);

	inode_inc_iversion(old_dir);
	inode_inc_iversion(new_dir);
	inode_inc_iversion(old_inode);
	old_dir->i_ctime = old_dir->i_mtime = ctime;
	new_dir->i_ctime = new_dir->i_mtime = ctime;
	old_inode->i_ctime = ctime;

	if (old_dentry->d_parent != new_dentry->d_parent)
		btrfs_record_unlink_dir(trans, old_dir, old_inode, 1);

	if (unlikely(old_ino == BTRFS_FIRST_FREE_OBJECTID)) {
		root_objectid = BTRFS_I(old_inode)->root->root_key.objectid;
		ret = btrfs_unlink_subvol(trans, root, old_dir, root_objectid,
					old_dentry->d_name.name,
					old_dentry->d_name.len);
	} else {
		ret = __btrfs_unlink_inode(trans, root, old_dir,
					old_dentry->d_inode,
					old_dentry->d_name.name,
					old_dentry->d_name.len);
		if (!ret)
			ret = btrfs_update_inode(trans, root, old_inode);
	}
	if (ret) {
		btrfs_abort_transaction(trans, root, ret);
		goto out_fail;
	}

	if (new_inode) {
		inode_inc_iversion(new_inode);
		new_inode->i_ctime = CURRENT_TIME;
		if (unlikely(btrfs_ino(new_inode) ==
			     BTRFS_EMPTY_SUBVOL_DIR_OBJECTID)) {
			root_objectid = BTRFS_I(new_inode)->location.objectid;
			ret = btrfs_unlink_subvol(trans, dest, new_dir,
						root_objectid,
						new_dentry->d_name.name,
						new_dentry->d_name.len);
			BUG_ON(new_inode->i_nlink == 0);
		} else {
			ret = btrfs_unlink_inode(trans, dest, new_dir,
						 new_dentry->d_inode,
						 new_dentry->d_name.name,
						 new_dentry->d_name.len);
		}
		if (!ret && new_inode->i_nlink == 0) {
			ret = btrfs_orphan_add(trans, new_dentry->d_inode);
			BUG_ON(ret);
		}
		if (ret) {
			btrfs_abort_transaction(trans, root, ret);
			goto out_fail;
		}
	}

	fixup_inode_flags(new_dir, old_inode);

	ret = btrfs_add_link(trans, new_dir, old_inode,
			     new_dentry->d_name.name,
			     new_dentry->d_name.len, 0, index);
	if (ret) {
		btrfs_abort_transaction(trans, root, ret);
		goto out_fail;
	}

	if (old_ino != BTRFS_FIRST_FREE_OBJECTID) {
		struct dentry *parent = new_dentry->d_parent;
		btrfs_log_new_name(trans, old_inode, old_dir, parent);
		btrfs_end_log_trans(root);
	}
out_fail:
	btrfs_end_transaction(trans, root);
out_notrans:
	if (old_ino == BTRFS_FIRST_FREE_OBJECTID)
		up_read(&root->fs_info->subvol_sem);

	return ret;
}
","static int btrfs_rename(struct inode *old_dir, struct dentry *old_dentry,
			   struct inode *new_dir, struct dentry *new_dentry)
{
	struct btrfs_trans_handle *trans;
	struct btrfs_root *root = BTRFS_I(old_dir)->root;
	struct btrfs_root *dest = BTRFS_I(new_dir)->root;
	struct inode *new_inode = new_dentry->d_inode;
	struct inode *old_inode = old_dentry->d_inode;
	struct timespec ctime = CURRENT_TIME;
	u64 index = 0;
	u64 root_objectid;
	int ret;
	u64 old_ino = btrfs_ino(old_inode);

	if (btrfs_ino(new_dir) == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID)
		return -EPERM;

	/* we only allow rename subvolume link between subvolumes */
	if (old_ino != BTRFS_FIRST_FREE_OBJECTID && root != dest)
		return -EXDEV;

	if (old_ino == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID ||
	    (new_inode && btrfs_ino(new_inode) == BTRFS_FIRST_FREE_OBJECTID))
		return -ENOTEMPTY;

 	if (S_ISDIR(old_inode->i_mode) && new_inode &&
 	    new_inode->i_size > BTRFS_EMPTY_DIR_SIZE)
 		return -ENOTEMPTY;
 	/*
 	 * we're using rename to replace one file with another.
 	 * and the replacement file is large.  Start IO on it now so
	 * we don't add too much work to the end of the transaction
	 */
	if (new_inode && S_ISREG(old_inode->i_mode) && new_inode->i_size &&
	    old_inode->i_size > BTRFS_ORDERED_OPERATIONS_FLUSH_LIMIT)
		filemap_flush(old_inode->i_mapping);

	/* close the racy window with snapshot create/destroy ioctl */
	if (old_ino == BTRFS_FIRST_FREE_OBJECTID)
		down_read(&root->fs_info->subvol_sem);
	/*
	 * We want to reserve the absolute worst case amount of items.  So if
	 * both inodes are subvols and we need to unlink them then that would
	 * require 4 item modifications, but if they are both normal inodes it
	 * would require 5 item modifications, so we'll assume their normal
	 * inodes.  So 5 * 2 is 10, plus 1 for the new link, so 11 total items
	 * should cover the worst case number of items we'll modify.
	 */
	trans = btrfs_start_transaction(root, 20);
	if (IS_ERR(trans)) {
                ret = PTR_ERR(trans);
                goto out_notrans;
        }

	if (dest != root)
		btrfs_record_root_in_trans(trans, dest);

	ret = btrfs_set_inode_index(new_dir, &index);
	if (ret)
		goto out_fail;

	if (unlikely(old_ino == BTRFS_FIRST_FREE_OBJECTID)) {
		/* force full log commit if subvolume involved. */
		root->fs_info->last_trans_log_full_commit = trans->transid;
	} else {
		ret = btrfs_insert_inode_ref(trans, dest,
					     new_dentry->d_name.name,
					     new_dentry->d_name.len,
					     old_ino,
					     btrfs_ino(new_dir), index);
		if (ret)
			goto out_fail;
		/*
		 * this is an ugly little race, but the rename is required
		 * to make sure that if we crash, the inode is either at the
		 * old name or the new one.  pinning the log transaction lets
		 * us make sure we don't allow a log commit to come in after
		 * we unlink the name but before we add the new name back in.
		 */
		btrfs_pin_log_trans(root);
	}
	/*
	 * make sure the inode gets flushed if it is replacing
	 * something.
	 */
	if (new_inode && new_inode->i_size && S_ISREG(old_inode->i_mode))
		btrfs_add_ordered_operation(trans, root, old_inode);

	inode_inc_iversion(old_dir);
	inode_inc_iversion(new_dir);
	inode_inc_iversion(old_inode);
	old_dir->i_ctime = old_dir->i_mtime = ctime;
	new_dir->i_ctime = new_dir->i_mtime = ctime;
	old_inode->i_ctime = ctime;

	if (old_dentry->d_parent != new_dentry->d_parent)
		btrfs_record_unlink_dir(trans, old_dir, old_inode, 1);

	if (unlikely(old_ino == BTRFS_FIRST_FREE_OBJECTID)) {
		root_objectid = BTRFS_I(old_inode)->root->root_key.objectid;
		ret = btrfs_unlink_subvol(trans, root, old_dir, root_objectid,
					old_dentry->d_name.name,
					old_dentry->d_name.len);
	} else {
		ret = __btrfs_unlink_inode(trans, root, old_dir,
					old_dentry->d_inode,
					old_dentry->d_name.name,
					old_dentry->d_name.len);
		if (!ret)
			ret = btrfs_update_inode(trans, root, old_inode);
	}
	if (ret) {
		btrfs_abort_transaction(trans, root, ret);
		goto out_fail;
	}

	if (new_inode) {
		inode_inc_iversion(new_inode);
		new_inode->i_ctime = CURRENT_TIME;
		if (unlikely(btrfs_ino(new_inode) ==
			     BTRFS_EMPTY_SUBVOL_DIR_OBJECTID)) {
			root_objectid = BTRFS_I(new_inode)->location.objectid;
			ret = btrfs_unlink_subvol(trans, dest, new_dir,
						root_objectid,
						new_dentry->d_name.name,
						new_dentry->d_name.len);
			BUG_ON(new_inode->i_nlink == 0);
		} else {
			ret = btrfs_unlink_inode(trans, dest, new_dir,
						 new_dentry->d_inode,
						 new_dentry->d_name.name,
						 new_dentry->d_name.len);
		}
		if (!ret && new_inode->i_nlink == 0) {
			ret = btrfs_orphan_add(trans, new_dentry->d_inode);
			BUG_ON(ret);
		}
		if (ret) {
			btrfs_abort_transaction(trans, root, ret);
			goto out_fail;
		}
	}

	fixup_inode_flags(new_dir, old_inode);

	ret = btrfs_add_link(trans, new_dir, old_inode,
			     new_dentry->d_name.name,
			     new_dentry->d_name.len, 0, index);
	if (ret) {
		btrfs_abort_transaction(trans, root, ret);
		goto out_fail;
	}

	if (old_ino != BTRFS_FIRST_FREE_OBJECTID) {
		struct dentry *parent = new_dentry->d_parent;
		btrfs_log_new_name(trans, old_inode, old_dir, parent);
		btrfs_end_log_trans(root);
	}
out_fail:
	btrfs_end_transaction(trans, root);
out_notrans:
	if (old_ino == BTRFS_FIRST_FREE_OBJECTID)
		up_read(&root->fs_info->subvol_sem);

	return ret;
}
",C,"

	/* check for collisions, even if the  name isn't there */
	ret = btrfs_check_dir_item_collision(root, new_dir->i_ino,
			     new_dentry->d_name.name,
			     new_dentry->d_name.len);

	if (ret) {
		if (ret == -EEXIST) {
			/* we shouldn't get
			 * eexist without a new_inode */
			if (!new_inode) {
				WARN_ON(1);
				return ret;
			}
		} else {
			/* maybe -EOVERFLOW */
			return ret;
		}
	}
	ret = 0;

",,,"@@ -4885,7 +4885,7 @@ int btrfs_add_link(struct btrfs_trans_handle *trans,
 	ret = btrfs_insert_dir_item(trans, root, name, name_len,
 				    parent_inode, &key,
 				    btrfs_inode_type(inode), index);
-	if (ret == -EEXIST)
+	if (ret == -EEXIST || ret == -EOVERFLOW)
 		goto fail_dir_item;
 	else if (ret) {
 		btrfs_abort_transaction(trans, root, ret);
@@ -7336,6 +7336,28 @@ static int btrfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 	if (S_ISDIR(old_inode->i_mode) && new_inode &&
 	    new_inode->i_size > BTRFS_EMPTY_DIR_SIZE)
 		return -ENOTEMPTY;
+
+
+	/* check for collisions, even if the  name isn't there */
+	ret = btrfs_check_dir_item_collision(root, new_dir->i_ino,
+			     new_dentry->d_name.name,
+			     new_dentry->d_name.len);
+
+	if (ret) {
+		if (ret == -EEXIST) {
+			/* we shouldn't get
+			 * eexist without a new_inode */
+			if (!new_inode) {
+				WARN_ON(1);
+				return ret;
+			}
+		} else {
+			/* maybe -EOVERFLOW */
+			return ret;
+		}
+	}
+	ret = 0;
+
 	/*
 	 * we're using rename to replace one file with another.
 	 * and the replacement file is large.  Start IO on it now so",linux,9c52057c698fb96f8f07e7a4bcf4801a092bda89,c64c2bd890df3b9a66c52c33df110777058c011e,1,"static int btrfs_rename(struct inode *old_dir, struct dentry *old_dentry,
			   struct inode *new_dir, struct dentry *new_dentry)
{
	struct btrfs_trans_handle *trans;
	struct btrfs_root *root = BTRFS_I(old_dir)->root;
	struct btrfs_root *dest = BTRFS_I(new_dir)->root;
	struct inode *new_inode = new_dentry->d_inode;
	struct inode *old_inode = old_dentry->d_inode;
	struct timespec ctime = CURRENT_TIME;
	u64 index = 0;
	u64 root_objectid;
	int ret;
	u64 old_ino = btrfs_ino(old_inode);

	if (btrfs_ino(new_dir) == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID)
		return -EPERM;

	/* we only allow rename subvolume link between subvolumes */
	if (old_ino != BTRFS_FIRST_FREE_OBJECTID && root != dest)
		return -EXDEV;

	if (old_ino == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID ||
	    (new_inode && btrfs_ino(new_inode) == BTRFS_FIRST_FREE_OBJECTID))
		return -ENOTEMPTY;

 	if (S_ISDIR(old_inode->i_mode) && new_inode &&
 	    new_inode->i_size > BTRFS_EMPTY_DIR_SIZE)
 		return -ENOTEMPTY;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	/* check for collisions, even if the  name isn't there */
//fix_flaw_line_below:
//	ret = btrfs_check_dir_item_collision(root, new_dir->i_ino,
//fix_flaw_line_below:
//			     new_dentry->d_name.name,
//fix_flaw_line_below:
//			     new_dentry->d_name.len);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (ret) {
//fix_flaw_line_below:
//		if (ret == -EEXIST) {
//fix_flaw_line_below:
//			/* we shouldn't get
//fix_flaw_line_below:
//			 * eexist without a new_inode */
//fix_flaw_line_below:
//			if (!new_inode) {
//fix_flaw_line_below:
//				WARN_ON(1);
//fix_flaw_line_below:
//				return ret;
//fix_flaw_line_below:
//			}
//fix_flaw_line_below:
//		} else {
//fix_flaw_line_below:
//			/* maybe -EOVERFLOW */
//fix_flaw_line_below:
//			return ret;
//fix_flaw_line_below:
//		}
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//	ret = 0;
//fix_flaw_line_below:
//
 	/*
 	 * we're using rename to replace one file with another.
 	 * and the replacement file is large.  Start IO on it now so
	 * we don't add too much work to the end of the transaction
	 */
	if (new_inode && S_ISREG(old_inode->i_mode) && new_inode->i_size &&
	    old_inode->i_size > BTRFS_ORDERED_OPERATIONS_FLUSH_LIMIT)
		filemap_flush(old_inode->i_mapping);

	/* close the racy window with snapshot create/destroy ioctl */
	if (old_ino == BTRFS_FIRST_FREE_OBJECTID)
		down_read(&root->fs_info->subvol_sem);
	/*
	 * We want to reserve the absolute worst case amount of items.  So if
	 * both inodes are subvols and we need to unlink them then that would
	 * require 4 item modifications, but if they are both normal inodes it
	 * would require 5 item modifications, so we'll assume their normal
	 * inodes.  So 5 * 2 is 10, plus 1 for the new link, so 11 total items
	 * should cover the worst case number of items we'll modify.
	 */
	trans = btrfs_start_transaction(root, 20);
	if (IS_ERR(trans)) {
                ret = PTR_ERR(trans);
                goto out_notrans;
        }

	if (dest != root)
		btrfs_record_root_in_trans(trans, dest);

	ret = btrfs_set_inode_index(new_dir, &index);
	if (ret)
		goto out_fail;

	if (unlikely(old_ino == BTRFS_FIRST_FREE_OBJECTID)) {
		/* force full log commit if subvolume involved. */
		root->fs_info->last_trans_log_full_commit = trans->transid;
	} else {
		ret = btrfs_insert_inode_ref(trans, dest,
					     new_dentry->d_name.name,
					     new_dentry->d_name.len,
					     old_ino,
					     btrfs_ino(new_dir), index);
		if (ret)
			goto out_fail;
		/*
		 * this is an ugly little race, but the rename is required
		 * to make sure that if we crash, the inode is either at the
		 * old name or the new one.  pinning the log transaction lets
		 * us make sure we don't allow a log commit to come in after
		 * we unlink the name but before we add the new name back in.
		 */
		btrfs_pin_log_trans(root);
	}
	/*
	 * make sure the inode gets flushed if it is replacing
	 * something.
	 */
	if (new_inode && new_inode->i_size && S_ISREG(old_inode->i_mode))
		btrfs_add_ordered_operation(trans, root, old_inode);

	inode_inc_iversion(old_dir);
	inode_inc_iversion(new_dir);
	inode_inc_iversion(old_inode);
	old_dir->i_ctime = old_dir->i_mtime = ctime;
	new_dir->i_ctime = new_dir->i_mtime = ctime;
	old_inode->i_ctime = ctime;

	if (old_dentry->d_parent != new_dentry->d_parent)
		btrfs_record_unlink_dir(trans, old_dir, old_inode, 1);

	if (unlikely(old_ino == BTRFS_FIRST_FREE_OBJECTID)) {
		root_objectid = BTRFS_I(old_inode)->root->root_key.objectid;
		ret = btrfs_unlink_subvol(trans, root, old_dir, root_objectid,
					old_dentry->d_name.name,
					old_dentry->d_name.len);
	} else {
		ret = __btrfs_unlink_inode(trans, root, old_dir,
					old_dentry->d_inode,
					old_dentry->d_name.name,
					old_dentry->d_name.len);
		if (!ret)
			ret = btrfs_update_inode(trans, root, old_inode);
	}
	if (ret) {
		btrfs_abort_transaction(trans, root, ret);
		goto out_fail;
	}

	if (new_inode) {
		inode_inc_iversion(new_inode);
		new_inode->i_ctime = CURRENT_TIME;
		if (unlikely(btrfs_ino(new_inode) ==
			     BTRFS_EMPTY_SUBVOL_DIR_OBJECTID)) {
			root_objectid = BTRFS_I(new_inode)->location.objectid;
			ret = btrfs_unlink_subvol(trans, dest, new_dir,
						root_objectid,
						new_dentry->d_name.name,
						new_dentry->d_name.len);
			BUG_ON(new_inode->i_nlink == 0);
		} else {
			ret = btrfs_unlink_inode(trans, dest, new_dir,
						 new_dentry->d_inode,
						 new_dentry->d_name.name,
						 new_dentry->d_name.len);
		}
		if (!ret && new_inode->i_nlink == 0) {
			ret = btrfs_orphan_add(trans, new_dentry->d_inode);
			BUG_ON(ret);
		}
		if (ret) {
			btrfs_abort_transaction(trans, root, ret);
			goto out_fail;
		}
	}

	fixup_inode_flags(new_dir, old_inode);

	ret = btrfs_add_link(trans, new_dir, old_inode,
			     new_dentry->d_name.name,
			     new_dentry->d_name.len, 0, index);
	if (ret) {
		btrfs_abort_transaction(trans, root, ret);
		goto out_fail;
	}

	if (old_ino != BTRFS_FIRST_FREE_OBJECTID) {
		struct dentry *parent = new_dentry->d_parent;
		btrfs_log_new_name(trans, old_inode, old_dir, parent);
		btrfs_end_log_trans(root);
	}
out_fail:
	btrfs_end_transaction(trans, root);
out_notrans:
	if (old_ino == BTRFS_FIRST_FREE_OBJECTID)
		up_read(&root->fs_info->subvol_sem);

	return ret;
}
"
1631,179367,,Local,Not required,Complete,CVE-2012-5375,https://www.cvedetails.com/cve/CVE-2012-5375/,CWE-310,High,,,,2013-02-18,4.0,"The CRC32C feature in the Btrfs implementation in the Linux kernel before 3.8-rc1 allows local users to cause a denial of service (prevention of file creation) by leveraging the ability to write to a directory important to the victim, and creating a file with a crafted name that is associated with a specific CRC32C hash value.",2014-01-03,DoS ,10,https://github.com/torvalds/linux/commit/9c52057c698fb96f8f07e7a4bcf4801a092bda89,9c52057c698fb96f8f07e7a4bcf4801a092bda89,"Btrfs: fix hash overflow handling

The handling for directory crc hash overflows was fairly obscure,
split_leaf returns EOVERFLOW when we try to extend the item and that is
supposed to bubble up to userland.  For a while it did so, but along the
way we added better handling of errors and forced the FS readonly if we
hit IO errors during the directory insertion.

Along the way, we started testing only for EEXIST and the EOVERFLOW case
was dropped.  The end result is that we may force the FS readonly if we
catch a directory hash bucket overflow.

This fixes a few problem spots.  First I add tests for EOVERFLOW in the
places where we can safely just return the error up the chain.

btrfs_rename is harder though, because it tries to insert the new
directory item only after it has already unlinked anything the rename
was going to overwrite.  Rather than adding very complex logic, I added
a helper to test for the hash overflow case early while it is still safe
to bail out.

Snapshot and subvolume creation had a similar problem, so they are using
the new helper now too.

Signed-off-by: Chris Mason <chris.mason@fusionio.com>
Reported-by: Pascal Junod <pascal@junod.info>",0,fs/btrfs/ioctl.c,"{""sha"": ""547b7b05727f917dfc2bad6516f5c5b30ea12c68"", ""filename"": ""fs/btrfs/ctree.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/ctree.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/ctree.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/ctree.h?ref=9c52057c698fb96f8f07e7a4bcf4801a092bda89"", ""patch"": ""@@ -3283,6 +3283,8 @@ void btrfs_update_root_times(struct btrfs_trans_handle *trans,\n \t\t\t     struct btrfs_root *root);\n \n /* dir-item.c */\n+int btrfs_check_dir_item_collision(struct btrfs_root *root, u64 dir,\n+\t\t\t  const char *name, int name_len);\n int btrfs_insert_dir_item(struct btrfs_trans_handle *trans,\n \t\t\t  struct btrfs_root *root, const char *name,\n \t\t\t  int name_len, struct inode *dir,""}<_**next**_>{""sha"": ""502c2158167c8fb95578f8166a9802a34e762def"", ""filename"": ""fs/btrfs/dir-item.c"", ""status"": ""modified"", ""additions"": 59, ""deletions"": 0, ""changes"": 59, ""blob_url"": ""https://github.com/torvalds/linux/blob/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/dir-item.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/dir-item.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/dir-item.c?ref=9c52057c698fb96f8f07e7a4bcf4801a092bda89"", ""patch"": ""@@ -213,6 +213,65 @@ struct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n \treturn btrfs_match_dir_item_name(root, path, name, name_len);\n }\n \n+int btrfs_check_dir_item_collision(struct btrfs_root *root, u64 dir,\n+\t\t\t\t   const char *name, int name_len)\n+{\n+\tint ret;\n+\tstruct btrfs_key key;\n+\tstruct btrfs_dir_item *di;\n+\tint data_size;\n+\tstruct extent_buffer *leaf;\n+\tint slot;\n+\tstruct btrfs_path *path;\n+\n+\n+\tpath = btrfs_alloc_path();\n+\tif (!path)\n+\t\treturn -ENOMEM;\n+\n+\tkey.objectid = dir;\n+\tbtrfs_set_key_type(&key, BTRFS_DIR_ITEM_KEY);\n+\tkey.offset = btrfs_name_hash(name, name_len);\n+\n+\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n+\n+\t/* return back any errors */\n+\tif (ret < 0)\n+\t\tgoto out;\n+\n+\t/* nothing found, we're safe */\n+\tif (ret > 0) {\n+\t\tret = 0;\n+\t\tgoto out;\n+\t}\n+\n+\t/* we found an item, look for our name in the item */\n+\tdi = btrfs_match_dir_item_name(root, path, name, name_len);\n+\tif (di) {\n+\t\t/* our exact name was found */\n+\t\tret = -EEXIST;\n+\t\tgoto out;\n+\t}\n+\n+\t/*\n+\t * see if there is room in the item to insert this\n+\t * name\n+\t */\n+\tdata_size = sizeof(*di) + name_len + sizeof(struct btrfs_item);\n+\tleaf = path->nodes[0];\n+\tslot = path->slots[0];\n+\tif (data_size + btrfs_item_size_nr(leaf, slot) +\n+\t    sizeof(struct btrfs_item) > BTRFS_LEAF_DATA_SIZE(root)) {\n+\t\tret = -EOVERFLOW;\n+\t} else {\n+\t\t/* plenty of insertion room */\n+\t\tret = 0;\n+\t}\n+out:\n+\tbtrfs_free_path(path);\n+\treturn ret;\n+}\n+\n /*\n  * lookup a directory item based on index.  'dir' is the objectid\n  * we're searching in, and 'mod' tells us if you plan on deleting the""}<_**next**_>{""sha"": ""e95b1f90a1f6676b73514877db83fc72986df66a"", ""filename"": ""fs/btrfs/inode.c"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 1, ""changes"": 24, ""blob_url"": ""https://github.com/torvalds/linux/blob/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/inode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/inode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/inode.c?ref=9c52057c698fb96f8f07e7a4bcf4801a092bda89"", ""patch"": ""@@ -4885,7 +4885,7 @@ int btrfs_add_link(struct btrfs_trans_handle *trans,\n \tret = btrfs_insert_dir_item(trans, root, name, name_len,\n \t\t\t\t    parent_inode, &key,\n \t\t\t\t    btrfs_inode_type(inode), index);\n-\tif (ret == -EEXIST)\n+\tif (ret == -EEXIST || ret == -EOVERFLOW)\n \t\tgoto fail_dir_item;\n \telse if (ret) {\n \t\tbtrfs_abort_transaction(trans, root, ret);\n@@ -7336,6 +7336,28 @@ static int btrfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n \tif (S_ISDIR(old_inode->i_mode) && new_inode &&\n \t    new_inode->i_size > BTRFS_EMPTY_DIR_SIZE)\n \t\treturn -ENOTEMPTY;\n+\n+\n+\t/* check for collisions, even if the  name isn't there */\n+\tret = btrfs_check_dir_item_collision(root, new_dir->i_ino,\n+\t\t\t     new_dentry->d_name.name,\n+\t\t\t     new_dentry->d_name.len);\n+\n+\tif (ret) {\n+\t\tif (ret == -EEXIST) {\n+\t\t\t/* we shouldn't get\n+\t\t\t * eexist without a new_inode */\n+\t\t\tif (!new_inode) {\n+\t\t\t\tWARN_ON(1);\n+\t\t\t\treturn ret;\n+\t\t\t}\n+\t\t} else {\n+\t\t\t/* maybe -EOVERFLOW */\n+\t\t\treturn ret;\n+\t\t}\n+\t}\n+\tret = 0;\n+\n \t/*\n \t * we're using rename to replace one file with another.\n \t * and the replacement file is large.  Start IO on it now so""}<_**next**_>{""sha"": ""d4608ab72b791682803da6761e52335cb367f31e"", ""filename"": ""fs/btrfs/ioctl.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 0, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/ioctl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/ioctl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/ioctl.c?ref=9c52057c698fb96f8f07e7a4bcf4801a092bda89"", ""patch"": ""@@ -710,6 +710,16 @@ static noinline int btrfs_mksubvol(struct path *parent,\n \tif (error)\n \t\tgoto out_dput;\n \n+\t/*\n+\t * even if this name doesn't exist, we may get hash collisions.\n+\t * check for them now when we can safely fail\n+\t */\n+\terror = btrfs_check_dir_item_collision(BTRFS_I(dir)->root,\n+\t\t\t\t\t       dir->i_ino, name,\n+\t\t\t\t\t       namelen);\n+\tif (error)\n+\t\tgoto out_dput;\n+\n \tdown_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\n \n \tif (btrfs_root_refs(&BTRFS_I(dir)->root->root_item) == 0)""}<_**next**_>{""sha"": ""87fac9a21ea56578625536ac1229678e854ec5f7"", ""filename"": ""fs/btrfs/transaction.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/transaction.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/transaction.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/transaction.c?ref=9c52057c698fb96f8f07e7a4bcf4801a092bda89"", ""patch"": ""@@ -1190,7 +1190,7 @@ static noinline int create_pending_snapshot(struct btrfs_trans_handle *trans,\n \t\t\t\t    parent_inode, &key,\n \t\t\t\t    BTRFS_FT_DIR, index);\n \t/* We have check then name at the beginning, so it is impossible. */\n-\tBUG_ON(ret == -EEXIST);\n+\tBUG_ON(ret == -EEXIST || ret == -EOVERFLOW);\n \tif (ret) {\n \t\tbtrfs_abort_transaction(trans, root, ret);\n \t\tgoto fail;""}","static noinline int btrfs_mksubvol(struct path *parent,
				   char *name, int namelen,
				   struct btrfs_root *snap_src,
				   u64 *async_transid, bool readonly,
				   struct btrfs_qgroup_inherit **inherit)
{
	struct inode *dir  = parent->dentry->d_inode;
	struct dentry *dentry;
	int error;

	mutex_lock_nested(&dir->i_mutex, I_MUTEX_PARENT);

	dentry = lookup_one_len(name, parent->dentry, namelen);
	error = PTR_ERR(dentry);
	if (IS_ERR(dentry))
		goto out_unlock;

	error = -EEXIST;
	if (dentry->d_inode)
		goto out_dput;

	error = btrfs_may_create(dir, dentry);
 	if (error)
 		goto out_dput;
 
	/*
	 * even if this name doesn't exist, we may get hash collisions.
	 * check for them now when we can safely fail
	 */
	error = btrfs_check_dir_item_collision(BTRFS_I(dir)->root,
					       dir->i_ino, name,
					       namelen);
	if (error)
		goto out_dput;

 	down_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);
 
 	if (btrfs_root_refs(&BTRFS_I(dir)->root->root_item) == 0)
		goto out_up_read;

	if (snap_src) {
		error = create_snapshot(snap_src, dentry, name, namelen,
					async_transid, readonly, inherit);
	} else {
		error = create_subvol(BTRFS_I(dir)->root, dentry,
				      name, namelen, async_transid, inherit);
	}
	if (!error)
		fsnotify_mkdir(dir, dentry);
out_up_read:
	up_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);
out_dput:
	dput(dentry);
out_unlock:
	mutex_unlock(&dir->i_mutex);
	return error;
}
","static noinline int btrfs_mksubvol(struct path *parent,
				   char *name, int namelen,
				   struct btrfs_root *snap_src,
				   u64 *async_transid, bool readonly,
				   struct btrfs_qgroup_inherit **inherit)
{
	struct inode *dir  = parent->dentry->d_inode;
	struct dentry *dentry;
	int error;

	mutex_lock_nested(&dir->i_mutex, I_MUTEX_PARENT);

	dentry = lookup_one_len(name, parent->dentry, namelen);
	error = PTR_ERR(dentry);
	if (IS_ERR(dentry))
		goto out_unlock;

	error = -EEXIST;
	if (dentry->d_inode)
		goto out_dput;

	error = btrfs_may_create(dir, dentry);
 	if (error)
 		goto out_dput;
 
 	down_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);
 
 	if (btrfs_root_refs(&BTRFS_I(dir)->root->root_item) == 0)
		goto out_up_read;

	if (snap_src) {
		error = create_snapshot(snap_src, dentry, name, namelen,
					async_transid, readonly, inherit);
	} else {
		error = create_subvol(BTRFS_I(dir)->root, dentry,
				      name, namelen, async_transid, inherit);
	}
	if (!error)
		fsnotify_mkdir(dir, dentry);
out_up_read:
	up_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);
out_dput:
	dput(dentry);
out_unlock:
	mutex_unlock(&dir->i_mutex);
	return error;
}
",C,"	/*
	 * even if this name doesn't exist, we may get hash collisions.
	 * check for them now when we can safely fail
	 */
	error = btrfs_check_dir_item_collision(BTRFS_I(dir)->root,
					       dir->i_ino, name,
					       namelen);
	if (error)
		goto out_dput;

",,,"@@ -710,6 +710,16 @@ static noinline int btrfs_mksubvol(struct path *parent,
 	if (error)
 		goto out_dput;
 
+	/*
+	 * even if this name doesn't exist, we may get hash collisions.
+	 * check for them now when we can safely fail
+	 */
+	error = btrfs_check_dir_item_collision(BTRFS_I(dir)->root,
+					       dir->i_ino, name,
+					       namelen);
+	if (error)
+		goto out_dput;
+
 	down_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);
 
 	if (btrfs_root_refs(&BTRFS_I(dir)->root->root_item) == 0)",linux,9c52057c698fb96f8f07e7a4bcf4801a092bda89,c64c2bd890df3b9a66c52c33df110777058c011e,1,"static noinline int btrfs_mksubvol(struct path *parent,
				   char *name, int namelen,
				   struct btrfs_root *snap_src,
				   u64 *async_transid, bool readonly,
				   struct btrfs_qgroup_inherit **inherit)
{
	struct inode *dir  = parent->dentry->d_inode;
	struct dentry *dentry;
	int error;

	mutex_lock_nested(&dir->i_mutex, I_MUTEX_PARENT);

	dentry = lookup_one_len(name, parent->dentry, namelen);
	error = PTR_ERR(dentry);
	if (IS_ERR(dentry))
		goto out_unlock;

	error = -EEXIST;
	if (dentry->d_inode)
		goto out_dput;

	error = btrfs_may_create(dir, dentry);
 	if (error)
 		goto out_dput;
 
//fix_flaw_line_below:
//	/*
//fix_flaw_line_below:
//	 * even if this name doesn't exist, we may get hash collisions.
//fix_flaw_line_below:
//	 * check for them now when we can safely fail
//fix_flaw_line_below:
//	 */
//fix_flaw_line_below:
//	error = btrfs_check_dir_item_collision(BTRFS_I(dir)->root,
//fix_flaw_line_below:
//					       dir->i_ino, name,
//fix_flaw_line_below:
//					       namelen);
//fix_flaw_line_below:
//	if (error)
//fix_flaw_line_below:
//		goto out_dput;
//fix_flaw_line_below:
//
 	down_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);
 
 	if (btrfs_root_refs(&BTRFS_I(dir)->root->root_item) == 0)
		goto out_up_read;

	if (snap_src) {
		error = create_snapshot(snap_src, dentry, name, namelen,
					async_transid, readonly, inherit);
	} else {
		error = create_subvol(BTRFS_I(dir)->root, dentry,
				      name, namelen, async_transid, inherit);
	}
	if (!error)
		fsnotify_mkdir(dir, dentry);
out_up_read:
	up_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);
out_dput:
	dput(dentry);
out_unlock:
	mutex_unlock(&dir->i_mutex);
	return error;
}
"
1632,179368,,Local,Not required,Complete,CVE-2012-5375,https://www.cvedetails.com/cve/CVE-2012-5375/,CWE-310,High,,,,2013-02-18,4.0,"The CRC32C feature in the Btrfs implementation in the Linux kernel before 3.8-rc1 allows local users to cause a denial of service (prevention of file creation) by leveraging the ability to write to a directory important to the victim, and creating a file with a crafted name that is associated with a specific CRC32C hash value.",2014-01-03,DoS ,1,https://github.com/torvalds/linux/commit/9c52057c698fb96f8f07e7a4bcf4801a092bda89,9c52057c698fb96f8f07e7a4bcf4801a092bda89,"Btrfs: fix hash overflow handling

The handling for directory crc hash overflows was fairly obscure,
split_leaf returns EOVERFLOW when we try to extend the item and that is
supposed to bubble up to userland.  For a while it did so, but along the
way we added better handling of errors and forced the FS readonly if we
hit IO errors during the directory insertion.

Along the way, we started testing only for EEXIST and the EOVERFLOW case
was dropped.  The end result is that we may force the FS readonly if we
catch a directory hash bucket overflow.

This fixes a few problem spots.  First I add tests for EOVERFLOW in the
places where we can safely just return the error up the chain.

btrfs_rename is harder though, because it tries to insert the new
directory item only after it has already unlinked anything the rename
was going to overwrite.  Rather than adding very complex logic, I added
a helper to test for the hash overflow case early while it is still safe
to bail out.

Snapshot and subvolume creation had a similar problem, so they are using
the new helper now too.

Signed-off-by: Chris Mason <chris.mason@fusionio.com>
Reported-by: Pascal Junod <pascal@junod.info>",1,fs/btrfs/transaction.c,"{""sha"": ""547b7b05727f917dfc2bad6516f5c5b30ea12c68"", ""filename"": ""fs/btrfs/ctree.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/ctree.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/ctree.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/ctree.h?ref=9c52057c698fb96f8f07e7a4bcf4801a092bda89"", ""patch"": ""@@ -3283,6 +3283,8 @@ void btrfs_update_root_times(struct btrfs_trans_handle *trans,\n \t\t\t     struct btrfs_root *root);\n \n /* dir-item.c */\n+int btrfs_check_dir_item_collision(struct btrfs_root *root, u64 dir,\n+\t\t\t  const char *name, int name_len);\n int btrfs_insert_dir_item(struct btrfs_trans_handle *trans,\n \t\t\t  struct btrfs_root *root, const char *name,\n \t\t\t  int name_len, struct inode *dir,""}<_**next**_>{""sha"": ""502c2158167c8fb95578f8166a9802a34e762def"", ""filename"": ""fs/btrfs/dir-item.c"", ""status"": ""modified"", ""additions"": 59, ""deletions"": 0, ""changes"": 59, ""blob_url"": ""https://github.com/torvalds/linux/blob/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/dir-item.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/dir-item.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/dir-item.c?ref=9c52057c698fb96f8f07e7a4bcf4801a092bda89"", ""patch"": ""@@ -213,6 +213,65 @@ struct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n \treturn btrfs_match_dir_item_name(root, path, name, name_len);\n }\n \n+int btrfs_check_dir_item_collision(struct btrfs_root *root, u64 dir,\n+\t\t\t\t   const char *name, int name_len)\n+{\n+\tint ret;\n+\tstruct btrfs_key key;\n+\tstruct btrfs_dir_item *di;\n+\tint data_size;\n+\tstruct extent_buffer *leaf;\n+\tint slot;\n+\tstruct btrfs_path *path;\n+\n+\n+\tpath = btrfs_alloc_path();\n+\tif (!path)\n+\t\treturn -ENOMEM;\n+\n+\tkey.objectid = dir;\n+\tbtrfs_set_key_type(&key, BTRFS_DIR_ITEM_KEY);\n+\tkey.offset = btrfs_name_hash(name, name_len);\n+\n+\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n+\n+\t/* return back any errors */\n+\tif (ret < 0)\n+\t\tgoto out;\n+\n+\t/* nothing found, we're safe */\n+\tif (ret > 0) {\n+\t\tret = 0;\n+\t\tgoto out;\n+\t}\n+\n+\t/* we found an item, look for our name in the item */\n+\tdi = btrfs_match_dir_item_name(root, path, name, name_len);\n+\tif (di) {\n+\t\t/* our exact name was found */\n+\t\tret = -EEXIST;\n+\t\tgoto out;\n+\t}\n+\n+\t/*\n+\t * see if there is room in the item to insert this\n+\t * name\n+\t */\n+\tdata_size = sizeof(*di) + name_len + sizeof(struct btrfs_item);\n+\tleaf = path->nodes[0];\n+\tslot = path->slots[0];\n+\tif (data_size + btrfs_item_size_nr(leaf, slot) +\n+\t    sizeof(struct btrfs_item) > BTRFS_LEAF_DATA_SIZE(root)) {\n+\t\tret = -EOVERFLOW;\n+\t} else {\n+\t\t/* plenty of insertion room */\n+\t\tret = 0;\n+\t}\n+out:\n+\tbtrfs_free_path(path);\n+\treturn ret;\n+}\n+\n /*\n  * lookup a directory item based on index.  'dir' is the objectid\n  * we're searching in, and 'mod' tells us if you plan on deleting the""}<_**next**_>{""sha"": ""e95b1f90a1f6676b73514877db83fc72986df66a"", ""filename"": ""fs/btrfs/inode.c"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 1, ""changes"": 24, ""blob_url"": ""https://github.com/torvalds/linux/blob/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/inode.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/inode.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/inode.c?ref=9c52057c698fb96f8f07e7a4bcf4801a092bda89"", ""patch"": ""@@ -4885,7 +4885,7 @@ int btrfs_add_link(struct btrfs_trans_handle *trans,\n \tret = btrfs_insert_dir_item(trans, root, name, name_len,\n \t\t\t\t    parent_inode, &key,\n \t\t\t\t    btrfs_inode_type(inode), index);\n-\tif (ret == -EEXIST)\n+\tif (ret == -EEXIST || ret == -EOVERFLOW)\n \t\tgoto fail_dir_item;\n \telse if (ret) {\n \t\tbtrfs_abort_transaction(trans, root, ret);\n@@ -7336,6 +7336,28 @@ static int btrfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n \tif (S_ISDIR(old_inode->i_mode) && new_inode &&\n \t    new_inode->i_size > BTRFS_EMPTY_DIR_SIZE)\n \t\treturn -ENOTEMPTY;\n+\n+\n+\t/* check for collisions, even if the  name isn't there */\n+\tret = btrfs_check_dir_item_collision(root, new_dir->i_ino,\n+\t\t\t     new_dentry->d_name.name,\n+\t\t\t     new_dentry->d_name.len);\n+\n+\tif (ret) {\n+\t\tif (ret == -EEXIST) {\n+\t\t\t/* we shouldn't get\n+\t\t\t * eexist without a new_inode */\n+\t\t\tif (!new_inode) {\n+\t\t\t\tWARN_ON(1);\n+\t\t\t\treturn ret;\n+\t\t\t}\n+\t\t} else {\n+\t\t\t/* maybe -EOVERFLOW */\n+\t\t\treturn ret;\n+\t\t}\n+\t}\n+\tret = 0;\n+\n \t/*\n \t * we're using rename to replace one file with another.\n \t * and the replacement file is large.  Start IO on it now so""}<_**next**_>{""sha"": ""d4608ab72b791682803da6761e52335cb367f31e"", ""filename"": ""fs/btrfs/ioctl.c"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 0, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/ioctl.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/ioctl.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/ioctl.c?ref=9c52057c698fb96f8f07e7a4bcf4801a092bda89"", ""patch"": ""@@ -710,6 +710,16 @@ static noinline int btrfs_mksubvol(struct path *parent,\n \tif (error)\n \t\tgoto out_dput;\n \n+\t/*\n+\t * even if this name doesn't exist, we may get hash collisions.\n+\t * check for them now when we can safely fail\n+\t */\n+\terror = btrfs_check_dir_item_collision(BTRFS_I(dir)->root,\n+\t\t\t\t\t       dir->i_ino, name,\n+\t\t\t\t\t       namelen);\n+\tif (error)\n+\t\tgoto out_dput;\n+\n \tdown_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\n \n \tif (btrfs_root_refs(&BTRFS_I(dir)->root->root_item) == 0)""}<_**next**_>{""sha"": ""87fac9a21ea56578625536ac1229678e854ec5f7"", ""filename"": ""fs/btrfs/transaction.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/transaction.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9c52057c698fb96f8f07e7a4bcf4801a092bda89/fs/btrfs/transaction.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/transaction.c?ref=9c52057c698fb96f8f07e7a4bcf4801a092bda89"", ""patch"": ""@@ -1190,7 +1190,7 @@ static noinline int create_pending_snapshot(struct btrfs_trans_handle *trans,\n \t\t\t\t    parent_inode, &key,\n \t\t\t\t    BTRFS_FT_DIR, index);\n \t/* We have check then name at the beginning, so it is impossible. */\n-\tBUG_ON(ret == -EEXIST);\n+\tBUG_ON(ret == -EEXIST || ret == -EOVERFLOW);\n \tif (ret) {\n \t\tbtrfs_abort_transaction(trans, root, ret);\n \t\tgoto fail;""}","static noinline int create_pending_snapshot(struct btrfs_trans_handle *trans,
				   struct btrfs_fs_info *fs_info,
				   struct btrfs_pending_snapshot *pending)
{
	struct btrfs_key key;
	struct btrfs_root_item *new_root_item;
	struct btrfs_root *tree_root = fs_info->tree_root;
	struct btrfs_root *root = pending->root;
	struct btrfs_root *parent_root;
	struct btrfs_block_rsv *rsv;
	struct inode *parent_inode;
	struct btrfs_path *path;
	struct btrfs_dir_item *dir_item;
	struct dentry *parent;
	struct dentry *dentry;
	struct extent_buffer *tmp;
	struct extent_buffer *old;
	struct timespec cur_time = CURRENT_TIME;
	int ret;
	u64 to_reserve = 0;
	u64 index = 0;
	u64 objectid;
	u64 root_flags;
	uuid_le new_uuid;

	path = btrfs_alloc_path();
	if (!path) {
		ret = pending->error = -ENOMEM;
		goto path_alloc_fail;
	}

	new_root_item = kmalloc(sizeof(*new_root_item), GFP_NOFS);
	if (!new_root_item) {
		ret = pending->error = -ENOMEM;
		goto root_item_alloc_fail;
	}

	ret = btrfs_find_free_objectid(tree_root, &objectid);
	if (ret) {
		pending->error = ret;
		goto no_free_objectid;
	}

	btrfs_reloc_pre_snapshot(trans, pending, &to_reserve);

	if (to_reserve > 0) {
		ret = btrfs_block_rsv_add(root, &pending->block_rsv,
					  to_reserve,
					  BTRFS_RESERVE_NO_FLUSH);
		if (ret) {
			pending->error = ret;
			goto no_free_objectid;
		}
	}

	ret = btrfs_qgroup_inherit(trans, fs_info, root->root_key.objectid,
				   objectid, pending->inherit);
	if (ret) {
		pending->error = ret;
		goto no_free_objectid;
	}

	key.objectid = objectid;
	key.offset = (u64)-1;
	key.type = BTRFS_ROOT_ITEM_KEY;

	rsv = trans->block_rsv;
	trans->block_rsv = &pending->block_rsv;

	dentry = pending->dentry;
	parent = dget_parent(dentry);
	parent_inode = parent->d_inode;
	parent_root = BTRFS_I(parent_inode)->root;
	record_root_in_trans(trans, parent_root);

	/*
	 * insert the directory item
	 */
	ret = btrfs_set_inode_index(parent_inode, &index);
	BUG_ON(ret); /* -ENOMEM */

	/* check if there is a file/dir which has the same name. */
	dir_item = btrfs_lookup_dir_item(NULL, parent_root, path,
					 btrfs_ino(parent_inode),
					 dentry->d_name.name,
					 dentry->d_name.len, 0);
	if (dir_item != NULL && !IS_ERR(dir_item)) {
		pending->error = -EEXIST;
		goto fail;
	} else if (IS_ERR(dir_item)) {
		ret = PTR_ERR(dir_item);
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}
	btrfs_release_path(path);

	/*
	 * pull in the delayed directory update
	 * and the delayed inode item
	 * otherwise we corrupt the FS during
	 * snapshot
	 */
	ret = btrfs_run_delayed_items(trans, root);
	if (ret) {	/* Transaction aborted */
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}

	record_root_in_trans(trans, root);
	btrfs_set_root_last_snapshot(&root->root_item, trans->transid);
	memcpy(new_root_item, &root->root_item, sizeof(*new_root_item));
	btrfs_check_and_init_root_item(new_root_item);

	root_flags = btrfs_root_flags(new_root_item);
	if (pending->readonly)
		root_flags |= BTRFS_ROOT_SUBVOL_RDONLY;
	else
		root_flags &= ~BTRFS_ROOT_SUBVOL_RDONLY;
	btrfs_set_root_flags(new_root_item, root_flags);

	btrfs_set_root_generation_v2(new_root_item,
			trans->transid);
	uuid_le_gen(&new_uuid);
	memcpy(new_root_item->uuid, new_uuid.b, BTRFS_UUID_SIZE);
	memcpy(new_root_item->parent_uuid, root->root_item.uuid,
			BTRFS_UUID_SIZE);
	new_root_item->otime.sec = cpu_to_le64(cur_time.tv_sec);
	new_root_item->otime.nsec = cpu_to_le32(cur_time.tv_nsec);
	btrfs_set_root_otransid(new_root_item, trans->transid);
	memset(&new_root_item->stime, 0, sizeof(new_root_item->stime));
	memset(&new_root_item->rtime, 0, sizeof(new_root_item->rtime));
	btrfs_set_root_stransid(new_root_item, 0);
	btrfs_set_root_rtransid(new_root_item, 0);

	old = btrfs_lock_root_node(root);
	ret = btrfs_cow_block(trans, root, old, NULL, 0, &old);
	if (ret) {
		btrfs_tree_unlock(old);
		free_extent_buffer(old);
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}

	btrfs_set_lock_blocking(old);

	ret = btrfs_copy_root(trans, root, old, &tmp, objectid);
	/* clean up in any case */
	btrfs_tree_unlock(old);
	free_extent_buffer(old);
	if (ret) {
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}

	/* see comments in should_cow_block() */
	root->force_cow = 1;
	smp_wmb();

	btrfs_set_root_node(new_root_item, tmp);
	/* record when the snapshot was created in key.offset */
	key.offset = trans->transid;
	ret = btrfs_insert_root(trans, tree_root, &key, new_root_item);
	btrfs_tree_unlock(tmp);
	free_extent_buffer(tmp);
	if (ret) {
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}

	/*
	 * insert root back/forward references
	 */
	ret = btrfs_add_root_ref(trans, tree_root, objectid,
				 parent_root->root_key.objectid,
				 btrfs_ino(parent_inode), index,
				 dentry->d_name.name, dentry->d_name.len);
	if (ret) {
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}

	key.offset = (u64)-1;
	pending->snap = btrfs_read_fs_root_no_name(root->fs_info, &key);
	if (IS_ERR(pending->snap)) {
		ret = PTR_ERR(pending->snap);
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}

	ret = btrfs_reloc_post_snapshot(trans, pending);
	if (ret) {
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}

	ret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);
	if (ret) {
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}

	ret = btrfs_insert_dir_item(trans, parent_root,
				    dentry->d_name.name, dentry->d_name.len,
 				    parent_inode, &key,
 				    BTRFS_FT_DIR, index);
 	/* We have check then name at the beginning, so it is impossible. */
	BUG_ON(ret == -EEXIST || ret == -EOVERFLOW);
 	if (ret) {
 		btrfs_abort_transaction(trans, root, ret);
 		goto fail;
	}

	btrfs_i_size_write(parent_inode, parent_inode->i_size +
					 dentry->d_name.len * 2);
	parent_inode->i_mtime = parent_inode->i_ctime = CURRENT_TIME;
	ret = btrfs_update_inode_fallback(trans, parent_root, parent_inode);
	if (ret)
		btrfs_abort_transaction(trans, root, ret);
fail:
	dput(parent);
	trans->block_rsv = rsv;
no_free_objectid:
	kfree(new_root_item);
root_item_alloc_fail:
	btrfs_free_path(path);
path_alloc_fail:
	btrfs_block_rsv_release(root, &pending->block_rsv, (u64)-1);
	return ret;
}
","static noinline int create_pending_snapshot(struct btrfs_trans_handle *trans,
				   struct btrfs_fs_info *fs_info,
				   struct btrfs_pending_snapshot *pending)
{
	struct btrfs_key key;
	struct btrfs_root_item *new_root_item;
	struct btrfs_root *tree_root = fs_info->tree_root;
	struct btrfs_root *root = pending->root;
	struct btrfs_root *parent_root;
	struct btrfs_block_rsv *rsv;
	struct inode *parent_inode;
	struct btrfs_path *path;
	struct btrfs_dir_item *dir_item;
	struct dentry *parent;
	struct dentry *dentry;
	struct extent_buffer *tmp;
	struct extent_buffer *old;
	struct timespec cur_time = CURRENT_TIME;
	int ret;
	u64 to_reserve = 0;
	u64 index = 0;
	u64 objectid;
	u64 root_flags;
	uuid_le new_uuid;

	path = btrfs_alloc_path();
	if (!path) {
		ret = pending->error = -ENOMEM;
		goto path_alloc_fail;
	}

	new_root_item = kmalloc(sizeof(*new_root_item), GFP_NOFS);
	if (!new_root_item) {
		ret = pending->error = -ENOMEM;
		goto root_item_alloc_fail;
	}

	ret = btrfs_find_free_objectid(tree_root, &objectid);
	if (ret) {
		pending->error = ret;
		goto no_free_objectid;
	}

	btrfs_reloc_pre_snapshot(trans, pending, &to_reserve);

	if (to_reserve > 0) {
		ret = btrfs_block_rsv_add(root, &pending->block_rsv,
					  to_reserve,
					  BTRFS_RESERVE_NO_FLUSH);
		if (ret) {
			pending->error = ret;
			goto no_free_objectid;
		}
	}

	ret = btrfs_qgroup_inherit(trans, fs_info, root->root_key.objectid,
				   objectid, pending->inherit);
	if (ret) {
		pending->error = ret;
		goto no_free_objectid;
	}

	key.objectid = objectid;
	key.offset = (u64)-1;
	key.type = BTRFS_ROOT_ITEM_KEY;

	rsv = trans->block_rsv;
	trans->block_rsv = &pending->block_rsv;

	dentry = pending->dentry;
	parent = dget_parent(dentry);
	parent_inode = parent->d_inode;
	parent_root = BTRFS_I(parent_inode)->root;
	record_root_in_trans(trans, parent_root);

	/*
	 * insert the directory item
	 */
	ret = btrfs_set_inode_index(parent_inode, &index);
	BUG_ON(ret); /* -ENOMEM */

	/* check if there is a file/dir which has the same name. */
	dir_item = btrfs_lookup_dir_item(NULL, parent_root, path,
					 btrfs_ino(parent_inode),
					 dentry->d_name.name,
					 dentry->d_name.len, 0);
	if (dir_item != NULL && !IS_ERR(dir_item)) {
		pending->error = -EEXIST;
		goto fail;
	} else if (IS_ERR(dir_item)) {
		ret = PTR_ERR(dir_item);
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}
	btrfs_release_path(path);

	/*
	 * pull in the delayed directory update
	 * and the delayed inode item
	 * otherwise we corrupt the FS during
	 * snapshot
	 */
	ret = btrfs_run_delayed_items(trans, root);
	if (ret) {	/* Transaction aborted */
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}

	record_root_in_trans(trans, root);
	btrfs_set_root_last_snapshot(&root->root_item, trans->transid);
	memcpy(new_root_item, &root->root_item, sizeof(*new_root_item));
	btrfs_check_and_init_root_item(new_root_item);

	root_flags = btrfs_root_flags(new_root_item);
	if (pending->readonly)
		root_flags |= BTRFS_ROOT_SUBVOL_RDONLY;
	else
		root_flags &= ~BTRFS_ROOT_SUBVOL_RDONLY;
	btrfs_set_root_flags(new_root_item, root_flags);

	btrfs_set_root_generation_v2(new_root_item,
			trans->transid);
	uuid_le_gen(&new_uuid);
	memcpy(new_root_item->uuid, new_uuid.b, BTRFS_UUID_SIZE);
	memcpy(new_root_item->parent_uuid, root->root_item.uuid,
			BTRFS_UUID_SIZE);
	new_root_item->otime.sec = cpu_to_le64(cur_time.tv_sec);
	new_root_item->otime.nsec = cpu_to_le32(cur_time.tv_nsec);
	btrfs_set_root_otransid(new_root_item, trans->transid);
	memset(&new_root_item->stime, 0, sizeof(new_root_item->stime));
	memset(&new_root_item->rtime, 0, sizeof(new_root_item->rtime));
	btrfs_set_root_stransid(new_root_item, 0);
	btrfs_set_root_rtransid(new_root_item, 0);

	old = btrfs_lock_root_node(root);
	ret = btrfs_cow_block(trans, root, old, NULL, 0, &old);
	if (ret) {
		btrfs_tree_unlock(old);
		free_extent_buffer(old);
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}

	btrfs_set_lock_blocking(old);

	ret = btrfs_copy_root(trans, root, old, &tmp, objectid);
	/* clean up in any case */
	btrfs_tree_unlock(old);
	free_extent_buffer(old);
	if (ret) {
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}

	/* see comments in should_cow_block() */
	root->force_cow = 1;
	smp_wmb();

	btrfs_set_root_node(new_root_item, tmp);
	/* record when the snapshot was created in key.offset */
	key.offset = trans->transid;
	ret = btrfs_insert_root(trans, tree_root, &key, new_root_item);
	btrfs_tree_unlock(tmp);
	free_extent_buffer(tmp);
	if (ret) {
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}

	/*
	 * insert root back/forward references
	 */
	ret = btrfs_add_root_ref(trans, tree_root, objectid,
				 parent_root->root_key.objectid,
				 btrfs_ino(parent_inode), index,
				 dentry->d_name.name, dentry->d_name.len);
	if (ret) {
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}

	key.offset = (u64)-1;
	pending->snap = btrfs_read_fs_root_no_name(root->fs_info, &key);
	if (IS_ERR(pending->snap)) {
		ret = PTR_ERR(pending->snap);
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}

	ret = btrfs_reloc_post_snapshot(trans, pending);
	if (ret) {
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}

	ret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);
	if (ret) {
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}

	ret = btrfs_insert_dir_item(trans, parent_root,
				    dentry->d_name.name, dentry->d_name.len,
 				    parent_inode, &key,
 				    BTRFS_FT_DIR, index);
 	/* We have check then name at the beginning, so it is impossible. */
	BUG_ON(ret == -EEXIST);
 	if (ret) {
 		btrfs_abort_transaction(trans, root, ret);
 		goto fail;
	}

	btrfs_i_size_write(parent_inode, parent_inode->i_size +
					 dentry->d_name.len * 2);
	parent_inode->i_mtime = parent_inode->i_ctime = CURRENT_TIME;
	ret = btrfs_update_inode_fallback(trans, parent_root, parent_inode);
	if (ret)
		btrfs_abort_transaction(trans, root, ret);
fail:
	dput(parent);
	trans->block_rsv = rsv;
no_free_objectid:
	kfree(new_root_item);
root_item_alloc_fail:
	btrfs_free_path(path);
path_alloc_fail:
	btrfs_block_rsv_release(root, &pending->block_rsv, (u64)-1);
	return ret;
}
",C,"	BUG_ON(ret == -EEXIST || ret == -EOVERFLOW);
","	BUG_ON(ret == -EEXIST);
",,"@@ -1190,7 +1190,7 @@ static noinline int create_pending_snapshot(struct btrfs_trans_handle *trans,
 				    parent_inode, &key,
 				    BTRFS_FT_DIR, index);
 	/* We have check then name at the beginning, so it is impossible. */
-	BUG_ON(ret == -EEXIST);
+	BUG_ON(ret == -EEXIST || ret == -EOVERFLOW);
 	if (ret) {
 		btrfs_abort_transaction(trans, root, ret);
 		goto fail;",linux,9c52057c698fb96f8f07e7a4bcf4801a092bda89,c64c2bd890df3b9a66c52c33df110777058c011e,1,"static noinline int create_pending_snapshot(struct btrfs_trans_handle *trans,
				   struct btrfs_fs_info *fs_info,
				   struct btrfs_pending_snapshot *pending)
{
	struct btrfs_key key;
	struct btrfs_root_item *new_root_item;
	struct btrfs_root *tree_root = fs_info->tree_root;
	struct btrfs_root *root = pending->root;
	struct btrfs_root *parent_root;
	struct btrfs_block_rsv *rsv;
	struct inode *parent_inode;
	struct btrfs_path *path;
	struct btrfs_dir_item *dir_item;
	struct dentry *parent;
	struct dentry *dentry;
	struct extent_buffer *tmp;
	struct extent_buffer *old;
	struct timespec cur_time = CURRENT_TIME;
	int ret;
	u64 to_reserve = 0;
	u64 index = 0;
	u64 objectid;
	u64 root_flags;
	uuid_le new_uuid;

	path = btrfs_alloc_path();
	if (!path) {
		ret = pending->error = -ENOMEM;
		goto path_alloc_fail;
	}

	new_root_item = kmalloc(sizeof(*new_root_item), GFP_NOFS);
	if (!new_root_item) {
		ret = pending->error = -ENOMEM;
		goto root_item_alloc_fail;
	}

	ret = btrfs_find_free_objectid(tree_root, &objectid);
	if (ret) {
		pending->error = ret;
		goto no_free_objectid;
	}

	btrfs_reloc_pre_snapshot(trans, pending, &to_reserve);

	if (to_reserve > 0) {
		ret = btrfs_block_rsv_add(root, &pending->block_rsv,
					  to_reserve,
					  BTRFS_RESERVE_NO_FLUSH);
		if (ret) {
			pending->error = ret;
			goto no_free_objectid;
		}
	}

	ret = btrfs_qgroup_inherit(trans, fs_info, root->root_key.objectid,
				   objectid, pending->inherit);
	if (ret) {
		pending->error = ret;
		goto no_free_objectid;
	}

	key.objectid = objectid;
	key.offset = (u64)-1;
	key.type = BTRFS_ROOT_ITEM_KEY;

	rsv = trans->block_rsv;
	trans->block_rsv = &pending->block_rsv;

	dentry = pending->dentry;
	parent = dget_parent(dentry);
	parent_inode = parent->d_inode;
	parent_root = BTRFS_I(parent_inode)->root;
	record_root_in_trans(trans, parent_root);

	/*
	 * insert the directory item
	 */
	ret = btrfs_set_inode_index(parent_inode, &index);
	BUG_ON(ret); /* -ENOMEM */

	/* check if there is a file/dir which has the same name. */
	dir_item = btrfs_lookup_dir_item(NULL, parent_root, path,
					 btrfs_ino(parent_inode),
					 dentry->d_name.name,
					 dentry->d_name.len, 0);
	if (dir_item != NULL && !IS_ERR(dir_item)) {
		pending->error = -EEXIST;
		goto fail;
	} else if (IS_ERR(dir_item)) {
		ret = PTR_ERR(dir_item);
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}
	btrfs_release_path(path);

	/*
	 * pull in the delayed directory update
	 * and the delayed inode item
	 * otherwise we corrupt the FS during
	 * snapshot
	 */
	ret = btrfs_run_delayed_items(trans, root);
	if (ret) {	/* Transaction aborted */
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}

	record_root_in_trans(trans, root);
	btrfs_set_root_last_snapshot(&root->root_item, trans->transid);
	memcpy(new_root_item, &root->root_item, sizeof(*new_root_item));
	btrfs_check_and_init_root_item(new_root_item);

	root_flags = btrfs_root_flags(new_root_item);
	if (pending->readonly)
		root_flags |= BTRFS_ROOT_SUBVOL_RDONLY;
	else
		root_flags &= ~BTRFS_ROOT_SUBVOL_RDONLY;
	btrfs_set_root_flags(new_root_item, root_flags);

	btrfs_set_root_generation_v2(new_root_item,
			trans->transid);
	uuid_le_gen(&new_uuid);
	memcpy(new_root_item->uuid, new_uuid.b, BTRFS_UUID_SIZE);
	memcpy(new_root_item->parent_uuid, root->root_item.uuid,
			BTRFS_UUID_SIZE);
	new_root_item->otime.sec = cpu_to_le64(cur_time.tv_sec);
	new_root_item->otime.nsec = cpu_to_le32(cur_time.tv_nsec);
	btrfs_set_root_otransid(new_root_item, trans->transid);
	memset(&new_root_item->stime, 0, sizeof(new_root_item->stime));
	memset(&new_root_item->rtime, 0, sizeof(new_root_item->rtime));
	btrfs_set_root_stransid(new_root_item, 0);
	btrfs_set_root_rtransid(new_root_item, 0);

	old = btrfs_lock_root_node(root);
	ret = btrfs_cow_block(trans, root, old, NULL, 0, &old);
	if (ret) {
		btrfs_tree_unlock(old);
		free_extent_buffer(old);
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}

	btrfs_set_lock_blocking(old);

	ret = btrfs_copy_root(trans, root, old, &tmp, objectid);
	/* clean up in any case */
	btrfs_tree_unlock(old);
	free_extent_buffer(old);
	if (ret) {
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}

	/* see comments in should_cow_block() */
	root->force_cow = 1;
	smp_wmb();

	btrfs_set_root_node(new_root_item, tmp);
	/* record when the snapshot was created in key.offset */
	key.offset = trans->transid;
	ret = btrfs_insert_root(trans, tree_root, &key, new_root_item);
	btrfs_tree_unlock(tmp);
	free_extent_buffer(tmp);
	if (ret) {
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}

	/*
	 * insert root back/forward references
	 */
	ret = btrfs_add_root_ref(trans, tree_root, objectid,
				 parent_root->root_key.objectid,
				 btrfs_ino(parent_inode), index,
				 dentry->d_name.name, dentry->d_name.len);
	if (ret) {
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}

	key.offset = (u64)-1;
	pending->snap = btrfs_read_fs_root_no_name(root->fs_info, &key);
	if (IS_ERR(pending->snap)) {
		ret = PTR_ERR(pending->snap);
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}

	ret = btrfs_reloc_post_snapshot(trans, pending);
	if (ret) {
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}

	ret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);
	if (ret) {
		btrfs_abort_transaction(trans, root, ret);
		goto fail;
	}

	ret = btrfs_insert_dir_item(trans, parent_root,
				    dentry->d_name.name, dentry->d_name.len,
 				    parent_inode, &key,
 				    BTRFS_FT_DIR, index);
 	/* We have check then name at the beginning, so it is impossible. */
//flaw_line_below:
	BUG_ON(ret == -EEXIST);
//fix_flaw_line_below:
//	BUG_ON(ret == -EEXIST || ret == -EOVERFLOW);
 	if (ret) {
 		btrfs_abort_transaction(trans, root, ret);
 		goto fail;
	}

	btrfs_i_size_write(parent_inode, parent_inode->i_size +
					 dentry->d_name.len * 2);
	parent_inode->i_mtime = parent_inode->i_ctime = CURRENT_TIME;
	ret = btrfs_update_inode_fallback(trans, parent_root, parent_inode);
	if (ret)
		btrfs_abort_transaction(trans, root, ret);
fail:
	dput(parent);
	trans->block_rsv = rsv;
no_free_objectid:
	kfree(new_root_item);
root_item_alloc_fail:
	btrfs_free_path(path);
path_alloc_fail:
	btrfs_block_rsv_release(root, &pending->block_rsv, (u64)-1);
	return ret;
}
"
1962,179698,,Remote,Not required,Partial,CVE-2013-6401,https://www.cvedetails.com/cve/CVE-2013-6401/,CWE-310,Low,,,,2014-03-20,5.0,"Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document.",2014-05-23,DoS ,3,https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4,8f80c2d83808150724d31793e6ade92749b1faa4,"CVE-2013-6401: Change hash function, randomize hashes

Thanks to Florian Weimer and Eric Sesterhenn for reporting, reviewing
and testing.",11,src/hashtable.c,"{""sha"": ""1043c9ae4c0bc0c1f6a5913783973383832ff14b"", ""filename"": ""CMakeLists.txt"", ""status"": ""modified"", ""additions"": 39, ""deletions"": 10, ""changes"": 49, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/CMakeLists.txt"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/CMakeLists.txt"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/CMakeLists.txt?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -52,6 +52,8 @@ project (jansson C)\n \n # Options\n OPTION (BUILD_SHARED_LIBS \""Build shared libraries.\"" OFF)\n+OPTION (USE_URANDOM \""Use /dev/urandom to seed the hash function.\"" ON)\n+OPTION (USE_WINDOWS_CRYPTOAPI \""Use CryptGenRandom to seed the hash function.\"" ON)\n \n if (MSVC)\n    # This option must match the settings used in your program, in particular if you\n@@ -85,12 +87,12 @@ set (JANSSON_SOVERSION 4)\n # for CheckFunctionKeywords\n set(CMAKE_MODULE_PATH \""${CMAKE_CURRENT_SOURCE_DIR}/cmake\"")\n \n+INCLUDE (CheckCSourceCompiles)\n include (CheckFunctionExists)\n include (CheckFunctionKeywords)\n include (CheckIncludeFiles)\n include (CheckTypeSize)\n \n-\n if (MSVC)\n    # Turn off Microsofts \""security\"" warnings.\n    add_definitions( \""/W3 /D_CRT_SECURE_NO_WARNINGS /wd4005 /wd4996 /nologo\"" )\n@@ -106,14 +108,25 @@ if (CMAKE_COMPILER_IS_GNUCC OR CMAKE_COMPILER_IS_GNUCXX)\n    set(CMAKE_C_FLAGS \""-fPIC\"")\n endif()\n \n-   \n+check_include_files (endian.h HAVE_ENDIAN_H)\n+check_include_files (fcntl.h HAVE_FCNTL_H)\n+check_include_files (sched.h HAVE_SCHED_H)\n+check_include_files (unistd.h HAVE_UNISTD_H)\n+check_include_files (sys/param.h HAVE_SYS_PARAM_H)\n+check_include_files (sys/stat.h HAVE_SYS_STAT_H)\n+check_include_files (sys/time.h HAVE_SYS_TIME_H)\n+check_include_files (sys/time.h HAVE_SYS_TYPES_H)\n+\n+check_function_exists (close HAVE_CLOSE)\n+check_function_exists (getpid HAVE_GETPID)\n+check_function_exists (gettimeofday HAVE_GETTIMEOFDAY)\n+check_function_exists (open HAVE_OPEN)\n+check_function_exists (read HAVE_READ)\n+check_function_exists (sched_yield HAVE_SCHED_YIELD)\n \n # Check for the int-type includes\n-check_include_files (sys/types.h HAVE_SYS_TYPES_H)\n-check_include_files (inttypes.h HAVE_INTTYPES_H)\n check_include_files (stdint.h HAVE_STDINT_H)\n \n-\n # Check our 64 bit integer sizes\n check_type_size (__int64 __INT64)\n check_type_size (int64_t INT64_T)\n@@ -124,17 +137,32 @@ check_type_size (int32_t INT32_T)\n check_type_size (__int32 __INT32)\n check_type_size (\""long\"" LONG_INT)\n check_type_size (\""int\"" INT)\n-\n if (HAVE_INT32_T)\n    set (JSON_INT32 int32_t)\n elseif (HAVE___INT32)\n    set (JSON_INT32 __int32)\n-elseif (HAVE_LONG AND (${LONG_INT} EQUAL 4))\n+elseif (HAVE_LONG_INT AND (${LONG_INT} EQUAL 4))\n    set (JSON_INT32 long)\n elseif (HAVE_INT AND (${INT} EQUAL 4))\n    set (JSON_INT32 int)\n else ()\n-   message (FATAL_ERROR \""Could not detect a valid 32 bit integer type\"")\n+   message (FATAL_ERROR \""Could not detect a valid 32-bit integer type\"")\n+endif ()\n+\n+check_type_size (uint32_t UINT32_T)\n+check_type_size (__uint32 __UINT32)\n+check_type_size (\""unsigned long\"" UNSIGNED_LONG_INT)\n+check_type_size (\""unsigned int\"" UNSIGNED_INT)\n+if (HAVE_UINT32_T)\n+   set (JSON_UINT32 uint32_t)\n+elseif (HAVE___UINT32)\n+   set (JSON_UINT32 __uint32)\n+elseif (HAVE_UNSIGNED_LONG_INT AND (${UNSIGNED_LONG_INT} EQUAL 4))\n+   set (JSON_UINT32 \""unsigned long\"")\n+elseif (HAVE_UNSIGNED_INT AND (${UNSIGNED_INT} EQUAL 4))\n+   set (JSON_UINT32 \""unsigned int\"")\n+else ()\n+   message (FATAL_ERROR \""Could not detect a valid unsigned 32-bit integer type\"")\n endif ()\n \n # Check for ssize_t and SSIZE_T existance.\n@@ -206,11 +234,9 @@ else ()\n    set (JSON_HAVE_LOCALECONV 0)\n endif ()\n \n-\n # check if we have setlocale\n check_function_exists (setlocale HAVE_SETLOCALE)\n \n-\n # Check what the inline keyword is.\n # Note that the original JSON_INLINE was always set to just 'inline', so this goes further.\n check_function_keywords(\""inline\"")\n@@ -238,6 +264,9 @@ elseif (HAVE__SNPRINTF)\n    set (JSON_SNPRINTF _snprintf)\n endif ()\n \n+check_c_source_compiles (\""int main() { unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1); return 0; } \"" HAVE_SYNC_BUILTINS)\n+check_c_source_compiles (\""int main() { char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE); return 0; }\"" HAVE_ATOMIC_BUILTINS)\n+\n # Create pkg-conf file.\n # (We use the same files as ./configure does, so we\n #  have to defined the same variables used there).""}<_**next**_>{""sha"": ""b27b9a3a849e94686aa648c1ec4d1bd4c8e35445"", ""filename"": ""cmake/config.h.cmake"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 21, ""changes"": 46, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/cmake/config.h.cmake"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/cmake/config.h.cmake"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/cmake/config.h.cmake?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,35 +1,36 @@\n-/* Reduced down to the defines that are actually used in the code */\n-\n-/* Define to 1 if you have the <inttypes.h> (and friends) header file. */\n-#cmakedefine HAVE_INTTYPES_H 1\n-#cmakedefine HAVE_STDINT_H 1\n+#cmakedefine HAVE_ENDIAN_H 1\n+#cmakedefine HAVE_FCNTL_H 1\n+#cmakedefine HAVE_SCHED_H 1\n+#cmakedefine HAVE_UNISTD_H 1\n+#cmakedefine HAVE_SYS_PARAM_H 1\n+#cmakedefine HAVE_SYS_STAT_H 1\n+#cmakedefine HAVE_SYS_TIME_H 1\n #cmakedefine HAVE_SYS_TYPES_H 1\n+#cmakedefine HAVE_STDINT_H 1\n \n-/* We must include this here, as in (eg) utf.h it will want to use\n-   the integer type, which in MSVC2010 will be in stdint.h\n-   (there is no inttypes.h in MSVC2010) */\n-#if defined(HAVE_STDINT_H)\n-#  include <stdint.h>\n-#elif defined(HAVE_INTTYPES_H)\n-#  include <inttypes.h>\n-#elif defined(HAVE_SYS_TYPES_H)\n-#  include <sys/types.h>\n-#endif\n+#cmakedefine HAVE_CLOSE 1\n+#cmakedefine HAVE_GETPID 1\n+#cmakedefine HAVE_GETTIMEOFDAY 1\n+#cmakedefine HAVE_OPEN 1\n+#cmakedefine HAVE_READ 1\n+#cmakedefine HAVE_SCHED_YIELD 1\n \n-/* Define to 1 if you have the <locale.h> header file. */\n-#cmakedefine HAVE_LOCALE_H 1\n+#cmakedefine HAVE_SYNC_BUILTINS 1\n+#cmakedefine HAVE_ATOMIC_BUILTINS 1\n \n-/* Define to 1 if you have the 'setlocale' function. */\n+#cmakedefine HAVE_LOCALE_H 1\n #cmakedefine HAVE_SETLOCALE 1\n \n-/* Define to the type of a signed integer type of width exactly 32 bits if\n-   such a type exists and the standard includes do not define it. */\n #cmakedefine HAVE_INT32_T 1\n-\n #ifndef HAVE_INT32_T\n #  define int32_t @JSON_INT32@\n #endif\n \n+#cmakedefine HAVE_UINT32_T 1\n+#ifndef HAVE_UINT32_T\n+#  define uint32_t @JSON_UINT32@\n+#endif\n+\n #cmakedefine HAVE_SSIZE_T 1\n \n #ifndef HAVE_SSIZE_T\n@@ -43,3 +44,6 @@\n #endif\n \n #cmakedefine HAVE_VSNPRINTF\n+\n+#cmakedefine USE_URANDOM 1\n+#cmakedefine USE_WINDOWS_CRYPTOAPI 1""}<_**next**_>{""sha"": ""113cb85e17a15f2fac83b528fe1880bc99481ccb"", ""filename"": ""configure.ac"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 2, ""changes"": 50, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/configure.ac"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/configure.ac"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/configure.ac?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -14,10 +14,11 @@ AM_CONDITIONAL([GCC], [test x$GCC = xyes])\n # Checks for libraries.\n \n # Checks for header files.\n-AC_CHECK_HEADERS([locale.h])\n+AC_CHECK_HEADERS([endian.h fcntl.h locale.h sched.h unistd.h sys/param.h sys/stat.h sys/time.h sys/types.h])\n \n # Checks for typedefs, structures, and compiler characteristics.\n AC_TYPE_INT32_T\n+AC_TYPE_UINT32_T\n AC_TYPE_LONG_LONG_INT\n \n AC_C_INLINE\n@@ -29,7 +30,31 @@ esac\n AC_SUBST([json_inline])\n \n # Checks for library functions.\n-AC_CHECK_FUNCS([strtoll localeconv])\n+AC_CHECK_FUNCS([close getpid gettimeofday localeconv open read sched_yield strtoll])\n+\n+AC_MSG_CHECKING([for gcc __sync builtins])\n+have_sync_builtins=no\n+AC_TRY_LINK(\n+  [], [unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1);],\n+  [have_sync_builtins=yes],\n+)\n+if test \""x$have_sync_builtins\"" = \""xyes\""; then\n+  AC_DEFINE([HAVE_SYNC_BUILTINS], [1],\n+    [Define to 1 if gcc's __sync builtins are available])\n+fi\n+AC_MSG_RESULT([$have_sync_builtins])\n+\n+AC_MSG_CHECKING([for gcc __atomic builtins])\n+have_atomic_builtins=no\n+AC_TRY_LINK(\n+  [], [char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE);],\n+  [have_atomic_builtins=yes],\n+)\n+if test \""x$have_atomic_builtins\"" = \""xyes\""; then\n+  AC_DEFINE([HAVE_ATOMIC_BUILTINS], [1],\n+    [Define to 1 if gcc's __atomic builtins are available])\n+fi\n+AC_MSG_RESULT([$have_atomic_builtins])\n \n case \""$ac_cv_type_long_long_int$ac_cv_func_strtoll\"" in\n      yesyes) json_have_long_long=1;;\n@@ -43,6 +68,27 @@ case \""$ac_cv_header_locale_h$ac_cv_func_localeconv\"" in\n esac\n AC_SUBST([json_have_localeconv])\n \n+# Features\n+AC_ARG_ENABLE([urandom],\n+  [AS_HELP_STRING([--disable-urandom],\n+    [Don't use /dev/urandom to seed the hash function])],\n+  [use_urandom=$enableval], [use_urandom=yes])\n+\n+if test \""x$use_urandom\"" = xyes; then\n+AC_DEFINE([USE_URANDOM], [1],\n+  [Define to 1 if /dev/urandom should be used for seeding the hash function])\n+fi\n+\n+AC_ARG_ENABLE([windows-cryptoapi],\n+  [AS_HELP_STRING([--disable-windows-cryptoapi],\n+    [Don't use CryptGenRandom to seed the hash function])],\n+  [use_windows_cryptoapi=$enableval], [use_windows_cryptoapi=yes])\n+\n+if test \""x$use_windows_cryptoapi\"" = xyes; then\n+AC_DEFINE([USE_WINDOWS_CRYPTOAPI], [1],\n+  [Define to 1 if CryptGenRandom should be used for seeding the hash function])\n+fi\n+\n AC_CONFIG_FILES([\n         jansson.pc\n         Makefile""}<_**next**_>{""sha"": ""b4af562e84b5ed9dba1107af7d1768dcdb0b9a95"", ""filename"": ""src/Makefile.am"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/Makefile.am"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/Makefile.am?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -8,6 +8,7 @@ libjansson_la_SOURCES = \\\n \terror.c \\\n \thashtable.c \\\n \thashtable.h \\\n+\thashtable_seed.c \\\n \tjansson_private.h \\\n \tload.c \\\n \tmemory.c \\""}<_**next**_>{""sha"": ""abd4bf11fe7a393fcf3d533b952aa8b5efa4ea30"", ""filename"": ""src/hashtable.c"", ""status"": ""modified"", ""additions"": 26, ""deletions"": 41, ""changes"": 67, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -5,8 +5,17 @@\n  * it under the terms of the MIT license. See LICENSE for details.\n  */\n \n+#if HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stdlib.h>\n #include <string.h>\n+\n+#if HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include <jansson_config.h>   /* for JSON_INLINE */\n #include \""jansson_private.h\""  /* for container_of() */\n #include \""hashtable.h\""\n@@ -15,24 +24,13 @@ typedef struct hashtable_list list_t;\n typedef struct hashtable_pair pair_t;\n typedef struct hashtable_bucket bucket_t;\n \n-#define list_to_pair(list_)  container_of(list_, pair_t, list)\n-\n-/* From http://www.cse.yorku.ca/~oz/hash.html */\n-static size_t hash_str(const void *ptr)\n-{\n-    const char *str = (const char *)ptr;\n-\n-    size_t hash = 5381;\n-    size_t c;\n+extern volatile uint32_t hashtable_seed;\n \n-    while((c = (size_t)*str))\n-    {\n-        hash = ((hash << 5) + hash) + c;\n-        str++;\n-    }\n+/* Implementation of the hash function */\n+#include \""lookup3.h\""\n \n-    return hash;\n-}\n+#define list_to_pair(list_)  container_of(list_, pair_t, list)\n+#define hash_str(key)        ((size_t)hashlittle((key), strlen(key), hashtable_seed))\n \n static JSON_INLINE void list_init(list_t *list)\n {\n@@ -74,19 +72,6 @@ static void insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket,\n     }\n }\n \n-static const size_t primes[] = {\n-    5, 13, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,\n-    49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,\n-    12582917, 25165843, 50331653, 100663319, 201326611, 402653189,\n-    805306457, 1610612741\n-};\n-\n-static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)\n-{\n-    return primes[hashtable->num_buckets];\n-}\n-\n-\n static pair_t *hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket,\n                                    const char *key, size_t hash)\n {\n@@ -120,7 +105,7 @@ static int hashtable_do_del(hashtable_t *hashtable,\n     bucket_t *bucket;\n     size_t index;\n \n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n@@ -167,14 +152,14 @@ static int hashtable_do_rehash(hashtable_t *hashtable)\n \n     jsonp_free(hashtable->buckets);\n \n-    hashtable->num_buckets++;\n-    new_size = num_buckets(hashtable);\n+    hashtable->order++;\n+    new_size = hashsize(hashtable->order);\n \n     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -199,14 +184,14 @@ int hashtable_init(hashtable_t *hashtable)\n     size_t i;\n \n     hashtable->size = 0;\n-    hashtable->num_buckets = 0;  /* index to primes[] */\n-    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));\n+    hashtable->order = 3;\n+    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n     list_init(&hashtable->list);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -230,12 +215,12 @@ int hashtable_set(hashtable_t *hashtable,\n     size_t hash, index;\n \n     /* rehash if the load ratio exceeds 1 */\n-    if(hashtable->size >= num_buckets(hashtable))\n+    if(hashtable->size >= hashsize(hashtable->order))\n         if(hashtable_do_rehash(hashtable))\n             return -1;\n \n     hash = hash_str(key);\n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n \n@@ -273,7 +258,7 @@ void *hashtable_get(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)\n@@ -294,7 +279,7 @@ void hashtable_clear(hashtable_t *hashtable)\n \n     hashtable_do_clear(hashtable);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -316,7 +301,7 @@ void *hashtable_iter_at(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)""}<_**next**_>{""sha"": ""469c6ecd869c4698f650fa81983bb3ee03d47fab"", ""filename"": ""src/hashtable.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -32,14 +32,15 @@ struct hashtable_bucket {\n typedef struct hashtable {\n     size_t size;\n     struct hashtable_bucket *buckets;\n-    size_t num_buckets;  /* index to primes[] */\n+    size_t order;  /* hashtable has pow(2, order) buckets */\n     struct hashtable_list list;\n } hashtable_t;\n \n \n #define hashtable_key_to_iter(key_) \\\n     (&(container_of(key_, struct hashtable_pair, key)->list))\n \n+\n /**\n  * hashtable_init - Initialize a hashtable object\n  *""}<_**next**_>{""sha"": ""a07d145d10df35b933c1441dcbf42d3316b78ca5"", ""filename"": ""src/hashtable_seed.c"", ""status"": ""added"", ""additions"": 278, ""deletions"": 0, ""changes"": 278, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable_seed.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable_seed.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable_seed.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,278 @@\n+/* Generate sizeof(uint32_t) bytes of as random data as possible to seed\n+   the hash function.\n+*/\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#include <stdio.h>\n+#include <time.h>\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n+#ifdef HAVE_FCNTL_H\n+#include <fcntl.h>\n+#endif\n+\n+#ifdef HAVE_SCHED_H\n+#include <sched.h>\n+#endif\n+\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+\n+#ifdef HAVE_SYS_STAT_H\n+#include <sys/stat.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TIME_H\n+#include <sys/time.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TYPES_H\n+#include <sys/types.h>\n+#endif\n+\n+#if defined(_WIN32)\n+/* For _getpid() */\n+#include <process.h>\n+#endif\n+\n+#include \""jansson.h\""\n+\n+\n+static uint32_t buf_to_uint32(char *data) {\n+    size_t i;\n+    uint32_t result = 0;\n+\n+    for (i = 0; i < sizeof(uint32_t); i++)\n+        result = (result << 8) | (unsigned char)data[i];\n+\n+    return result;\n+}\n+\n+\n+\n+/* /dev/urandom */\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+static int seed_from_urandom(uint32_t *seed) {\n+    /* Use unbuffered I/O if we have open(), close() and read(). Otherwise\n+       fall back to fopen() */\n+\n+    char data[sizeof(uint32_t)];\n+    int ok;\n+\n+#if defined(HAVE_OPEN) && defined(HAVE_CLOSE) && defined(HAVE_READ)\n+    int urandom;\n+    urandom = open(\""/dev/urandom\"", O_RDONLY);\n+    if (urandom == -1)\n+        return 1;\n+\n+    ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);\n+    close(urandom);\n+#else\n+    FILE *urandom;\n+\n+    urandom = fopen(\""/dev/urandom\"", \""rb\"");\n+    if (!urandom)\n+        return 1;\n+\n+    ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);\n+    fclose(urandom);\n+#endif\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32(data);\n+    return 0;\n+}\n+#endif\n+\n+/* Windows Crypto API */\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+#include <windows.h>\n+#include <wincrypt.h>\n+\n+typedef BOOL (WINAPI *CRYPTACQUIRECONTEXTA)(HCRYPTPROV *phProv, LPCSTR pszContainer, LPCSTR pszProvider, DWORD dwProvType, DWORD dwFlags);\n+typedef BOOL (WINAPI *CRYPTGENRANDOM)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);\n+typedef BOOL (WINAPI *CRYPTRELEASECONTEXT)(HCRYPTPROV hProv, DWORD dwFlags);\n+\n+static int seed_from_windows_cryptoapi(uint32_t *seed)\n+{\n+    HINSTANCE hAdvAPI32 = NULL;\n+    CRYPTACQUIRECONTEXTA pCryptAcquireContext = NULL;\n+    CRYPTGENRANDOM pCryptGenRandom = NULL;\n+    CRYPTRELEASECONTEXT pCryptReleaseContext = NULL;\n+    HCRYPTPROV hCryptProv = 0;\n+    BYTE data[sizeof(uint32_t)];\n+    int ok;\n+\n+    hAdvAPI32 = GetModuleHandle(\""advapi32.dll\"");\n+    if(hAdvAPI32 == NULL)\n+        return 1;\n+\n+    pCryptAcquireContext = (CRYPTACQUIRECONTEXTA)GetProcAddress(hAdvAPI32, \""CryptAcquireContextA\"");\n+    if (!pCryptAcquireContext)\n+        return 1;\n+\n+    pCryptGenRandom = (CRYPTGENRANDOM)GetProcAddress(hAdvAPI32, \""CryptGenRandom\"");\n+    if (!pCryptGenRandom)\n+        return 1;\n+\n+    pCryptReleaseContext = (CRYPTRELEASECONTEXT)GetProcAddress(hAdvAPI32, \""CryptReleaseContext\"");\n+    if (!pCryptReleaseContext)\n+        return 1;\n+\n+    if (!pCryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))\n+        return 1;\n+\n+    ok = CryptGenRandom(hCryptProv, sizeof(uint32_t), data);\n+    pCryptReleaseContext(hCryptProv, 0);\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32((char *)data);\n+    return 0;\n+}\n+#endif\n+\n+/* gettimeofday() and getpid() */\n+static int seed_from_timestamp_and_pid(uint32_t *seed) {\n+#ifdef HAVE_GETTIMEOFDAY\n+    /* XOR of seconds and microseconds */\n+    struct timeval tv;\n+    gettimeofday(&tv, NULL);\n+    *seed = (uint32_t)tv.tv_sec ^ (uint32_t)tv.tv_usec;\n+#else\n+    /* Seconds only */\n+    *seed = (uint32_t)time(NULL);\n+#endif\n+\n+    /* XOR with PID for more randomness */\n+#if defined(_WIN32)\n+    *seed ^= (uint32_t)_getpid();\n+#elif defined(HAVE_GETPID)\n+    *seed ^= (uint32_t)getpid();\n+#endif\n+\n+    return 0;\n+}\n+\n+static uint32_t generate_seed() {\n+    uint32_t seed;\n+    int done = 0;\n+\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+    if (!done && seed_from_urandom(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+    if (!done && seed_from_windows_cryptoapi(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+    if (!done) {\n+        /* Fall back to timestamp and PID if no better randomness is\n+           available */\n+        seed_from_timestamp_and_pid(&seed);\n+    }\n+\n+    /* Make sure the seed is never zero */\n+    if (seed == 0)\n+        seed = 1;\n+\n+    return seed;\n+}\n+\n+\n+volatile uint32_t hashtable_seed = 0;\n+\n+#if defined(HAVE_ATOMIC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+static volatile char seed_initialized = 0;\n+\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (__atomic_test_and_set(&seed_initialized, __ATOMIC_RELAXED) == 0) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            __atomic_store_n(&hashtable_seed, new_seed, __ATOMIC_ACQ_REL);\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            } while(__atomic_load_n(&hashtable_seed, __ATOMIC_ACQUIRE) == 0);\n+        }\n+    }\n+}\n+#elif defined(HAVE_SYNC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0) {\n+            /* Explicit synchronization fences are not supported by the\n+               __sync builtins, so every thread getting here has to\n+               generate the seed value.\n+            */\n+            new_seed = generate_seed();\n+        }\n+\n+        do {\n+            if (__sync_bool_compare_and_swap(&hashtable_seed, 0, new_seed)) {\n+                /* We were the first to seed */\n+                break;\n+            } else {\n+                /* Wait for another thread to do the seeding */\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            }\n+        } while(hashtable_seed == 0);\n+    }\n+}\n+#elif defined(_WIN32)\n+static long seed_initialized = 0;\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (InterlockedIncrement(&seed_initialized) == 1) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            hashtable_seed = new_seed;\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+                SwitchToThread();\n+            } while (hashtable_seed == 0);\n+        }\n+    }\n+}\n+#else\n+/* Fall back to a thread-unsafe version */\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0)\n+            new_seed = generate_seed();\n+\n+        hashtable_seed = new_seed;\n+    }\n+}\n+#endif""}<_**next**_>{""sha"": ""19096d4201e6b13f8c56765116865c71f67e9696"", ""filename"": ""src/jansson.def"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.def"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.def"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/jansson.def?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -41,6 +41,7 @@ EXPORTS\n     json_object_iter_value\n     json_object_iter_set_new\n     json_object_key_to_iter\n+    json_object_seed\n     json_dumps\n     json_dumpf\n     json_dump_file""}<_**next**_>{""sha"": ""ea230852a629e55457fba2d00e3edd8a4ad4fcec"", ""filename"": ""src/jansson.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/jansson.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -126,6 +126,7 @@ typedef struct {\n \n /* getters, setters, manipulation */\n \n+void json_object_seed(size_t seed);\n size_t json_object_size(const json_t *object);\n json_t *json_object_get(const json_t *object, const char *key);\n int json_object_set_new(json_t *object, const char *key, json_t *value);""}<_**next**_>{""sha"": ""dc76138c940516e9590784825d28d040fd1a8b25"", ""filename"": ""src/lookup3.h"", ""status"": ""added"", ""additions"": 366, ""deletions"": 0, ""changes"": 366, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/lookup3.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/lookup3.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/lookup3.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,366 @@\n+/*\n+-------------------------------------------------------------------------------\n+lookup3.c, by Bob Jenkins, May 2006, Public Domain.\n+\n+These are functions for producing 32-bit hashes for hash table lookup.\n+hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final() \n+are externally useful functions.  Routines to test the hash are included \n+if SELF_TEST is defined.  You can use this free for any purpose.  It's in\n+the public domain.  It has no warranty.\n+\n+You probably want to use hashlittle().  hashlittle() and hashbig()\n+hash byte arrays.  hashlittle() is is faster than hashbig() on\n+little-endian machines.  Intel and AMD are little-endian machines.\n+On second thought, you probably want hashlittle2(), which is identical to\n+hashlittle() except it returns two 32-bit hashes for the price of one.  \n+You could implement hashbig2() if you wanted but I haven't bothered here.\n+\n+If you want to find a hash of, say, exactly 7 integers, do\n+  a = i1;  b = i2;  c = i3;\n+  mix(a,b,c);\n+  a += i4; b += i5; c += i6;\n+  mix(a,b,c);\n+  a += i7;\n+  final(a,b,c);\n+then use c as the hash value.  If you have a variable length array of\n+4-byte integers to hash, use hashword().  If you have a byte array (like\n+a character string), use hashlittle().  If you have several byte arrays, or\n+a mix of things, see the comments above hashlittle().  \n+\n+Why is this so big?  I read 12 bytes at a time into 3 4-byte integers, \n+then mix those integers.  This is fast (you can do a lot more thorough\n+mixing with 12*3 instructions on 3 integers than you can with 3 instructions\n+on 1 byte), but shoehorning those bytes into integers efficiently is messy.\n+-------------------------------------------------------------------------------\n+*/\n+\n+#include <stdlib.h>\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>     /* defines uint32_t etc */\n+#endif\n+\n+#ifdef HAVE_SYS_PARAM_H\n+#include <sys/param.h>  /* attempt to define endianness */\n+#endif\n+\n+#ifdef HAVE_ENDIAN_H\n+# include <endian.h>    /* attempt to define endianness */\n+#endif\n+\n+/*\n+ * My best guess at if you are big-endian or little-endian.  This may\n+ * need adjustment.\n+ */\n+#if (defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && \\\n+     __BYTE_ORDER == __LITTLE_ENDIAN) || \\\n+    (defined(i386) || defined(__i386__) || defined(__i486__) || \\\n+     defined(__i586__) || defined(__i686__) || defined(vax) || defined(MIPSEL))\n+# define HASH_LITTLE_ENDIAN 1\n+# define HASH_BIG_ENDIAN 0\n+#elif (defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && \\\n+       __BYTE_ORDER == __BIG_ENDIAN) || \\\n+      (defined(sparc) || defined(POWERPC) || defined(mc68000) || defined(sel))\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 1\n+#else\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 0\n+#endif\n+\n+#define hashsize(n) ((uint32_t)1<<(n))\n+#define hashmask(n) (hashsize(n)-1)\n+#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n+\n+/*\n+-------------------------------------------------------------------------------\n+mix -- mix 3 32-bit values reversibly.\n+\n+This is reversible, so any information in (a,b,c) before mix() is\n+still in (a,b,c) after mix().\n+\n+If four pairs of (a,b,c) inputs are run through mix(), or through\n+mix() in reverse, there are at least 32 bits of the output that\n+are sometimes the same for one pair and different for another pair.\n+This was tested for:\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+Some k values for my \""a-=c; a^=rot(c,k); c+=b;\"" arrangement that\n+satisfy this are\n+    4  6  8 16 19  4\n+    9 15  3 18 27 15\n+   14  9  3  7 17  3\n+Well, \""9 15 3 18 27 15\"" didn't quite get 32 bits diffing\n+for \""differ\"" defined as + with a one-bit base and a two-bit delta.  I\n+used http://burtleburtle.net/bob/hash/avalanche.html to choose \n+the operations, constants, and arrangements of the variables.\n+\n+This does not achieve avalanche.  There are input bits of (a,b,c)\n+that fail to affect some output bits of (a,b,c), especially of a.  The\n+most thoroughly mixed value is c, but it doesn't really even achieve\n+avalanche in c.\n+\n+This allows some parallelism.  Read-after-writes are good at doubling\n+the number of bits affected, so the goal of mixing pulls in the opposite\n+direction as the goal of parallelism.  I did what I could.  Rotates\n+seem to cost as much as shifts on every machine I could lay my hands\n+on, and rotates are much kinder to the top and bottom bits, so I used\n+rotates.\n+-------------------------------------------------------------------------------\n+*/\n+#define mix(a,b,c) \\\n+{ \\\n+  a -= c;  a ^= rot(c, 4);  c += b; \\\n+  b -= a;  b ^= rot(a, 6);  a += c; \\\n+  c -= b;  c ^= rot(b, 8);  b += a; \\\n+  a -= c;  a ^= rot(c,16);  c += b; \\\n+  b -= a;  b ^= rot(a,19);  a += c; \\\n+  c -= b;  c ^= rot(b, 4);  b += a; \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+final -- final mixing of 3 32-bit values (a,b,c) into c\n+\n+Pairs of (a,b,c) values differing in only a few bits will usually\n+produce values of c that look totally different.  This was tested for\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+These constants passed:\n+ 14 11 25 16 4 14 24\n+ 12 14 25 16 4 14 24\n+and these came close:\n+  4  8 15 26 3 22 24\n+ 10  8 15 26 3 22 24\n+ 11  8 15 26 3 22 24\n+-------------------------------------------------------------------------------\n+*/\n+#define final(a,b,c) \\\n+{ \\\n+  c ^= b; c -= rot(b,14); \\\n+  a ^= c; a -= rot(c,11); \\\n+  b ^= a; b -= rot(a,25); \\\n+  c ^= b; c -= rot(b,16); \\\n+  a ^= c; a -= rot(c,4);  \\\n+  b ^= a; b -= rot(a,14); \\\n+  c ^= b; c -= rot(b,24); \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+hashlittle() -- hash a variable-length key into a 32-bit value\n+  k       : the key (the unaligned variable-length array of bytes)\n+  length  : the length of the key, counting by bytes\n+  initval : can be any 4-byte value\n+Returns a 32-bit value.  Every bit of the key affects every bit of\n+the return value.  Two keys differing by one or two bits will have\n+totally different hash values.\n+\n+The best hash table sizes are powers of 2.  There is no need to do\n+mod a prime (mod is sooo slow!).  If you need less than 32 bits,\n+use a bitmask.  For example, if you need only 10 bits, do\n+  h = (h & hashmask(10));\n+In which case, the hash table should have hashsize(10) elements.\n+\n+If you are hashing n strings (uint8_t **)k, do it like this:\n+  for (i=0, h=0; i<n; ++i) h = hashlittle( k[i], len[i], h);\n+\n+By Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this\n+code any way you wish, private, educational, or commercial.  It's free.\n+\n+Use for hash table lookup, or anything where one collision in 2^^32 is\n+acceptable.  Do NOT use for cryptographic purposes.\n+-------------------------------------------------------------------------------\n+*/\n+\n+static uint32_t hashlittle(const void *key, size_t length, uint32_t initval)\n+{\n+  uint32_t a,b,c;                                          /* internal state */\n+  union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */\n+\n+  /* Set up the internal state */\n+  a = b = c = 0xdeadbeef + ((uint32_t)length) + initval;\n+\n+  u.ptr = key;\n+  if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0)) {\n+    const uint32_t *k = (const uint32_t *)key;         /* read 32-bit chunks */\n+\n+#ifdef VALGRIND\n+    const uint8_t  *k8;\n+#endif\n+\n+    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      b += k[1];\n+      c += k[2];\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 3;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    /* \n+     * \""k[2]&0xffffff\"" actually reads beyond the end of the string, but\n+     * then masks off the part it's not allowed to read.  Because the\n+     * string is aligned, the masked-off tail is in the same word as the\n+     * rest of the string.  Every machine with memory protection I've seen\n+     * does it on word boundaries, so is OK with this.  But VALGRIND will\n+     * still catch it and complain.  The masking trick does make the hash\n+     * noticably faster for short strings (like English words).\n+     */\n+#ifndef VALGRIND\n+\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n+    case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n+    case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n+    case 6 : b+=k[1]&0xffff; a+=k[0]; break;\n+    case 5 : b+=k[1]&0xff; a+=k[0]; break;\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=k[0]&0xffffff; break;\n+    case 2 : a+=k[0]&0xffff; break;\n+    case 1 : a+=k[0]&0xff; break;\n+    case 0 : return c;              /* zero length strings require no mixing */\n+    }\n+\n+#else /* make valgrind happy */\n+\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=((uint32_t)k8[10])<<16;  /* fall through */\n+    case 10: c+=((uint32_t)k8[9])<<8;    /* fall through */\n+    case 9 : c+=k8[8];                   /* fall through */\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;   /* fall through */\n+    case 6 : b+=((uint32_t)k8[5])<<8;    /* fall through */\n+    case 5 : b+=k8[4];                   /* fall through */\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;   /* fall through */\n+    case 2 : a+=((uint32_t)k8[1])<<8;    /* fall through */\n+    case 1 : a+=k8[0]; break;\n+    case 0 : return c;\n+    }\n+\n+#endif /* !valgrind */\n+\n+  } else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0)) {\n+    const uint16_t *k = (const uint16_t *)key;         /* read 16-bit chunks */\n+    const uint8_t  *k8;\n+\n+    /*--------------- all but last block: aligned reads and different mixing */\n+    while (length > 12)\n+    {\n+      a += k[0] + (((uint32_t)k[1])<<16);\n+      b += k[2] + (((uint32_t)k[3])<<16);\n+      c += k[4] + (((uint32_t)k[5])<<16);\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 6;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[4]+(((uint32_t)k[5])<<16);\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 11: c+=((uint32_t)k8[10])<<16;     /* fall through */\n+    case 10: c+=k[4];\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 9 : c+=k8[8];                      /* fall through */\n+    case 8 : b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;      /* fall through */\n+    case 6 : b+=k[2];\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 5 : b+=k8[4];                      /* fall through */\n+    case 4 : a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;      /* fall through */\n+    case 2 : a+=k[0];\n+             break;\n+    case 1 : a+=k8[0];\n+             break;\n+    case 0 : return c;                     /* zero length requires no mixing */\n+    }\n+\n+  } else {                        /* need to read the key one byte at a time */\n+    const uint8_t *k = (const uint8_t *)key;\n+\n+    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      a += ((uint32_t)k[1])<<8;\n+      a += ((uint32_t)k[2])<<16;\n+      a += ((uint32_t)k[3])<<24;\n+      b += k[4];\n+      b += ((uint32_t)k[5])<<8;\n+      b += ((uint32_t)k[6])<<16;\n+      b += ((uint32_t)k[7])<<24;\n+      c += k[8];\n+      c += ((uint32_t)k[9])<<8;\n+      c += ((uint32_t)k[10])<<16;\n+      c += ((uint32_t)k[11])<<24;\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 12;\n+    }\n+\n+    /*-------------------------------- last block: affect all 32 bits of (c) */\n+    switch(length)                   /* all the case statements fall through */\n+    {\n+    case 12: c+=((uint32_t)k[11])<<24;\n+    case 11: c+=((uint32_t)k[10])<<16;\n+    case 10: c+=((uint32_t)k[9])<<8;\n+    case 9 : c+=k[8];\n+    case 8 : b+=((uint32_t)k[7])<<24;\n+    case 7 : b+=((uint32_t)k[6])<<16;\n+    case 6 : b+=((uint32_t)k[5])<<8;\n+    case 5 : b+=k[4];\n+    case 4 : a+=((uint32_t)k[3])<<24;\n+    case 3 : a+=((uint32_t)k[2])<<16;\n+    case 2 : a+=((uint32_t)k[1])<<8;\n+    case 1 : a+=k[0];\n+             break;\n+    case 0 : return c;\n+    }\n+  }\n+\n+  final(a,b,c);\n+  return c;\n+}""}<_**next**_>{""sha"": ""b4f109143031b2481a0d32a332c88cc1cc96c688"", ""filename"": ""src/utf.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 16, ""changes"": 20, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/utf.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/utf.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/utf.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -10,23 +10,11 @@\n \n #ifdef HAVE_CONFIG_H\n #include <config.h>\n+#endif\n \n-#ifdef HAVE_INTTYPES_H\n-/* inttypes.h includes stdint.h in a standard environment, so there's\n-no need to include stdint.h separately. If inttypes.h doesn't define\n-int32_t, it's defined in config.h. */\n-#include <inttypes.h>\n-#endif /* HAVE_INTTYPES_H */\n-\n-#else /* !HAVE_CONFIG_H */\n-#ifdef _WIN32\n-typedef int int32_t;\n-#else /* !_WIN32 */\n-/* Assume a standard environment */\n-#include <inttypes.h>\n-#endif /* _WIN32 */\n-\n-#endif /* HAVE_CONFIG_H */\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n \n int utf8_encode(int codepoint, char *buffer, int *size);\n ""}<_**next**_>{""sha"": ""1b02d90aa885f1ede146bb2077d05c8bb9096565"", ""filename"": ""src/value.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/value.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/value.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/value.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -9,11 +9,19 @@\n #define _GNU_SOURCE\n #endif\n \n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stddef.h>\n #include <stdlib.h>\n #include <string.h>\n #include <math.h>\n \n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include \""jansson.h\""\n #include \""hashtable.h\""\n #include \""jansson_private.h\""\n@@ -36,11 +44,19 @@ static JSON_INLINE void json_init(json_t *json, json_type type)\n \n /*** object ***/\n \n+extern volatile uint32_t hashtable_seed;\n+\n json_t *json_object(void)\n {\n     json_object_t *object = jsonp_malloc(sizeof(json_object_t));\n     if(!object)\n         return NULL;\n+\n+    if (!hashtable_seed) {\n+        /* Autoseed */\n+        json_object_seed(0);\n+    }\n+\n     json_init(&object->json, JSON_OBJECT);\n \n     if(hashtable_init(&object->hashtable))""}<_**next**_>{""sha"": ""e2c54bd12bd7c22de7cc3533f010b26cc1c330b0"", ""filename"": ""test/bin/json_process.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 1, ""changes"": 16, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/bin/json_process.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/bin/json_process.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/bin/json_process.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -37,6 +37,8 @@ struct config {\n     int sort_keys;\n     int strip;\n     int use_env;\n+    int have_hashseed;\n+    int hashseed;\n } conf;\n \n #define l_isspace(c) ((c) == ' ' || (c) == '\\n' || (c) == '\\r' || (c) == '\\t')\n@@ -108,6 +110,12 @@ static void read_conf(FILE *conffile)\n             conf.sort_keys = atoi(val);\n         if (!strcmp(line, \""STRIP\""))\n             conf.strip = atoi(val);\n+        if (!strcmp(line, \""HASHSEED\"")) {\n+            conf.have_hashseed = 1;\n+            conf.hashseed = atoi(val);\n+        } else {\n+            conf.have_hashseed = 0;\n+        }\n     }\n \n     free(buffer);\n@@ -188,6 +196,9 @@ int use_conf(char *test_path)\n     if (conf.sort_keys)\n         flags |= JSON_SORT_KEYS;\n \n+    if (conf.have_hashseed)\n+        json_object_seed(conf.hashseed);\n+\n     if (conf.strip) {\n         /* Load to memory, strip leading and trailing whitespace */\n         buffer = loadfile(infile);\n@@ -265,7 +276,10 @@ int use_env()\n         flags |= JSON_PRESERVE_ORDER;\n \n     if(getenv_int(\""JSON_SORT_KEYS\""))\n-         flags |= JSON_SORT_KEYS;\n+        flags |= JSON_SORT_KEYS;\n+\n+    if(getenv(\""HASHSEED\""))\n+        json_object_seed(getenv_int(\""HASHSEED\""));\n \n     if(getenv_int(\""STRIP\"")) {\n         /* Load to memory, strip leading and trailing whitespace */""}<_**next**_>{""sha"": ""84b17466fd0a753b8cbd714d0236ed9072cdd536"", ""filename"": ""test/suites/api/test_memory_funcs.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_memory_funcs.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_memory_funcs.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/api/test_memory_funcs.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -24,13 +24,13 @@ static void create_and_free_complex_object()\n \n static void *my_malloc(size_t size)\n {\n-    malloc_called += 1;\n+    malloc_called = 1;\n     return malloc(size);\n }\n \n static void my_free(void *ptr)\n {\n-    free_called += 1;\n+    free_called = 1;\n     free(ptr);\n }\n \n@@ -39,7 +39,7 @@ static void test_simple()\n     json_set_alloc_funcs(my_malloc, my_free);\n     create_and_free_complex_object();\n \n-    if(malloc_called != 20 || free_called != 20)\n+    if(malloc_called != 1 || free_called != 1)\n         fail(\""Custom allocation failed\"");\n }\n ""}<_**next**_>{""sha"": ""92e5208224b75ab45d93672446279d598052a83e"", ""filename"": ""test/suites/api/test_object.c"", ""status"": ""modified"", ""additions"": 40, ""deletions"": 24, ""changes"": 64, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_object.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_object.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/api/test_object.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -249,7 +249,11 @@ static void test_set_nocheck()\n \n static void test_iterators()\n {\n+    int i;\n     json_t *object, *foo, *bar, *baz;\n+    const char *iter_keys[3];\n+    int have_key[3] = { 0, 0, 0 };\n+    json_t *iter_values[3];\n     void *iter;\n \n     if(json_object_iter(NULL))\n@@ -276,30 +280,50 @@ static void test_iterators()\n     iter = json_object_iter(object);\n     if(!iter)\n         fail(\""unable to get iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""a\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != foo)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[0] = json_object_iter_key(iter);\n+    iter_values[0] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""b\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != bar)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[1] = json_object_iter_key(iter);\n+    iter_values[1] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[2] = json_object_iter_key(iter);\n+    iter_values[2] = json_object_iter_value(iter);\n \n     if(json_object_iter_next(object, iter) != NULL)\n         fail(\""able to iterate over the end\"");\n \n+    /* Check that keys have correct values */\n+    for (i = 0; i < 3; i++) {\n+        if (strcmp(iter_keys[i], \""a\"") == 0) {\n+            if (iter_values[i] != foo)\n+                fail(\""wrong value for iter key a\"");\n+            else\n+                have_key[0] = 1;\n+        } else if (strcmp(iter_keys[i], \""b\"") == 0) {\n+            if (iter_values[i] != bar)\n+                fail(\""wrong value for iter key b\"");\n+            else\n+                have_key[1] = 1;\n+        } else if (strcmp(iter_keys[i], \""c\"") == 0) {\n+            if (iter_values[i] != baz)\n+                fail(\""wrong value for iter key c\"");\n+            else\n+                have_key[2] = 1;\n+        }\n+    }\n+\n+    /* Check that we got all keys */\n+    for(i = 0; i < 3; i++) {\n+        if(!have_key[i])\n+            fail(\""a key wasn't iterated over\"");\n+    }\n+\n     if(json_object_iter_at(object, \""foo\""))\n         fail(\""json_object_iter_at() succeeds for non-existent key\"");\n \n@@ -312,22 +336,14 @@ static void test_iterators()\n     if(json_object_iter_value(iter) != bar)\n         fail(\""iterating failed: wrong value\"");\n \n-    iter = json_object_iter_next(object, iter);\n-    if(!iter)\n-        fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\""iterating failed: wrong value\"");\n-\n-    if(json_object_iter_set(object, iter, bar))\n+    if(json_object_iter_set(object, iter, baz))\n         fail(\""unable to set value at iterator\"");\n \n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n+    if(strcmp(json_object_iter_key(iter), \""b\""))\n         fail(\""json_object_iter_key() fails after json_object_iter_set()\"");\n-    if(json_object_iter_value(iter) != bar)\n+    if(json_object_iter_value(iter) != baz)\n         fail(\""json_object_iter_value() fails after json_object_iter_set()\"");\n-    if(json_object_get(object, \""c\"") != bar)\n+    if(json_object_get(object, \""b\"") != baz)\n         fail(\""json_object_get() fails after json_object_iter_set()\"");\n \n     json_decref(object);""}<_**next**_>{""sha"": ""93cb33ddafeb9eef6ce7ad4709ce1bcbdf25b200"", ""filename"": ""test/suites/encoding-flags/compact-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/compact-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/compact-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/compact-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,2 +1,3 @@\n JSON_COMPACT=1\n-export JSON_COMPACT\n+HASHSEED=1\n+export JSON_COMPACT HASHSEED""}<_**next**_>{""sha"": ""c73acc1792963be8a5f41ff11f6e858506ada51d"", ""filename"": ""test/suites/encoding-flags/indent-compact-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-compact-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-compact-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/indent-compact-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,3 +1,4 @@\n JSON_INDENT=4\n JSON_COMPACT=1\n-export JSON_INDENT JSON_COMPACT\n+HASHSEED=1\n+export JSON_INDENT JSON_COMPACT HASHSEED""}<_**next**_>{""sha"": ""961558ca23ceca2ce6e4d07697f4018d8475f317"", ""filename"": ""test/suites/encoding-flags/indent-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/indent-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,2 +1,3 @@\n JSON_INDENT=4\n-export JSON_INDENT\n+HASHSEED=1\n+export JSON_INDENT HASHSEED""}<_**next**_>{""sha"": ""9120b03514ec614695c2d17841ba228b102c9db6"", ""filename"": ""test/suites/encoding-flags/object/env"", ""status"": ""added"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,2 @@\n+HASHSEED=1\n+export HASHSEED""}","static size_t hash_str(const void *ptr)
extern volatile uint32_t hashtable_seed;
 
/* Implementation of the hash function */
#include ""lookup3.h""
 
","static size_t hash_str(const void *ptr)
{
    const char *str = (const char *)ptr;
    size_t hash = 5381;
    size_t c;
 
    while((c = (size_t)*str))
    {
        hash = ((hash << 5) + hash) + c;
        str++;
    }
 
    return hash;
}
",C,"extern volatile uint32_t hashtable_seed;
/* Implementation of the hash function */
#include ""lookup3.h""
","{
    const char *str = (const char *)ptr;
    size_t hash = 5381;
    size_t c;
    while((c = (size_t)*str))
    {
        hash = ((hash << 5) + hash) + c;
        str++;
    }
    return hash;
}
",,"@@ -5,8 +5,17 @@
  * it under the terms of the MIT license. See LICENSE for details.
  */
 
+#if HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include <stdlib.h>
 #include <string.h>
+
+#if HAVE_STDINT_H
+#include <stdint.h>
+#endif
+
 #include <jansson_config.h>   /* for JSON_INLINE */
 #include ""jansson_private.h""  /* for container_of() */
 #include ""hashtable.h""
@@ -15,24 +24,13 @@ typedef struct hashtable_list list_t;
 typedef struct hashtable_pair pair_t;
 typedef struct hashtable_bucket bucket_t;
 
-#define list_to_pair(list_)  container_of(list_, pair_t, list)
-
-/* From http://www.cse.yorku.ca/~oz/hash.html */
-static size_t hash_str(const void *ptr)
-{
-    const char *str = (const char *)ptr;
-
-    size_t hash = 5381;
-    size_t c;
+extern volatile uint32_t hashtable_seed;
 
-    while((c = (size_t)*str))
-    {
-        hash = ((hash << 5) + hash) + c;
-        str++;
-    }
+/* Implementation of the hash function */
+#include ""lookup3.h""
 
-    return hash;
-}
+#define list_to_pair(list_)  container_of(list_, pair_t, list)
+#define hash_str(key)        ((size_t)hashlittle((key), strlen(key), hashtable_seed))
 
 static JSON_INLINE void list_init(list_t *list)
 {
@@ -74,19 +72,6 @@ static void insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket,
     }
 }
 
-static const size_t primes[] = {
-    5, 13, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,
-    49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,
-    12582917, 25165843, 50331653, 100663319, 201326611, 402653189,
-    805306457, 1610612741
-};
-
-static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)
-{
-    return primes[hashtable->num_buckets];
-}
-
-
 static pair_t *hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket,
                                    const char *key, size_t hash)
 {
@@ -120,7 +105,7 @@ static int hashtable_do_del(hashtable_t *hashtable,
     bucket_t *bucket;
     size_t index;
 
-    index = hash % num_buckets(hashtable);
+    index = hash & hashmask(hashtable->order);
     bucket = &hashtable->buckets[index];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
@@ -167,14 +152,14 @@ static int hashtable_do_rehash(hashtable_t *hashtable)
 
     jsonp_free(hashtable->buckets);
 
-    hashtable->num_buckets++;
-    new_size = num_buckets(hashtable);
+    hashtable->order++;
+    new_size = hashsize(hashtable->order);
 
     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));
     if(!hashtable->buckets)
         return -1;
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -199,14 +184,14 @@ int hashtable_init(hashtable_t *hashtable)
     size_t i;
 
     hashtable->size = 0;
-    hashtable->num_buckets = 0;  /* index to primes[] */
-    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));
+    hashtable->order = 3;
+    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));
     if(!hashtable->buckets)
         return -1;
 
     list_init(&hashtable->list);
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -230,12 +215,12 @@ int hashtable_set(hashtable_t *hashtable,
     size_t hash, index;
 
     /* rehash if the load ratio exceeds 1 */
-    if(hashtable->size >= num_buckets(hashtable))
+    if(hashtable->size >= hashsize(hashtable->order))
         if(hashtable_do_rehash(hashtable))
             return -1;
 
     hash = hash_str(key);
-    index = hash % num_buckets(hashtable);
+    index = hash & hashmask(hashtable->order);
     bucket = &hashtable->buckets[index];
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
 
@@ -273,7 +258,7 @@ void *hashtable_get(hashtable_t *hashtable, const char *key)
     bucket_t *bucket;
 
     hash = hash_str(key);
-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)
@@ -294,7 +279,7 @@ void hashtable_clear(hashtable_t *hashtable)
 
     hashtable_do_clear(hashtable);
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -316,7 +301,7 @@ void *hashtable_iter_at(hashtable_t *hashtable, const char *key)
     bucket_t *bucket;
 
     hash = hash_str(key);
-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)",jansson,8f80c2d83808150724d31793e6ade92749b1faa4,b9c588de3deb4efdd7b9ec44aa79335dba11fd6b,1,"static size_t hash_str(const void *ptr)
//flaw_line_below:
{
//flaw_line_below:
    const char *str = (const char *)ptr;
//flaw_line_below:

//flaw_line_below:
    size_t hash = 5381;
//flaw_line_below:
    size_t c;
//fix_flaw_line_below:
//extern volatile uint32_t hashtable_seed;
 
//flaw_line_below:
    while((c = (size_t)*str))
//flaw_line_below:
    {
//flaw_line_below:
        hash = ((hash << 5) + hash) + c;
//flaw_line_below:
        str++;
//flaw_line_below:
    }
//fix_flaw_line_below:
///* Implementation of the hash function */
//fix_flaw_line_below:
//#include ""lookup3.h""
 
//flaw_line_below:
    return hash;
//flaw_line_below:
}
"
1963,179699,,Remote,Not required,Partial,CVE-2013-6401,https://www.cvedetails.com/cve/CVE-2013-6401/,CWE-310,Low,,,,2014-03-20,5.0,"Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document.",2014-05-23,DoS ,1,https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4,8f80c2d83808150724d31793e6ade92749b1faa4,"CVE-2013-6401: Change hash function, randomize hashes

Thanks to Florian Weimer and Eric Sesterhenn for reporting, reviewing
and testing.",1,src/hashtable.c,"{""sha"": ""1043c9ae4c0bc0c1f6a5913783973383832ff14b"", ""filename"": ""CMakeLists.txt"", ""status"": ""modified"", ""additions"": 39, ""deletions"": 10, ""changes"": 49, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/CMakeLists.txt"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/CMakeLists.txt"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/CMakeLists.txt?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -52,6 +52,8 @@ project (jansson C)\n \n # Options\n OPTION (BUILD_SHARED_LIBS \""Build shared libraries.\"" OFF)\n+OPTION (USE_URANDOM \""Use /dev/urandom to seed the hash function.\"" ON)\n+OPTION (USE_WINDOWS_CRYPTOAPI \""Use CryptGenRandom to seed the hash function.\"" ON)\n \n if (MSVC)\n    # This option must match the settings used in your program, in particular if you\n@@ -85,12 +87,12 @@ set (JANSSON_SOVERSION 4)\n # for CheckFunctionKeywords\n set(CMAKE_MODULE_PATH \""${CMAKE_CURRENT_SOURCE_DIR}/cmake\"")\n \n+INCLUDE (CheckCSourceCompiles)\n include (CheckFunctionExists)\n include (CheckFunctionKeywords)\n include (CheckIncludeFiles)\n include (CheckTypeSize)\n \n-\n if (MSVC)\n    # Turn off Microsofts \""security\"" warnings.\n    add_definitions( \""/W3 /D_CRT_SECURE_NO_WARNINGS /wd4005 /wd4996 /nologo\"" )\n@@ -106,14 +108,25 @@ if (CMAKE_COMPILER_IS_GNUCC OR CMAKE_COMPILER_IS_GNUCXX)\n    set(CMAKE_C_FLAGS \""-fPIC\"")\n endif()\n \n-   \n+check_include_files (endian.h HAVE_ENDIAN_H)\n+check_include_files (fcntl.h HAVE_FCNTL_H)\n+check_include_files (sched.h HAVE_SCHED_H)\n+check_include_files (unistd.h HAVE_UNISTD_H)\n+check_include_files (sys/param.h HAVE_SYS_PARAM_H)\n+check_include_files (sys/stat.h HAVE_SYS_STAT_H)\n+check_include_files (sys/time.h HAVE_SYS_TIME_H)\n+check_include_files (sys/time.h HAVE_SYS_TYPES_H)\n+\n+check_function_exists (close HAVE_CLOSE)\n+check_function_exists (getpid HAVE_GETPID)\n+check_function_exists (gettimeofday HAVE_GETTIMEOFDAY)\n+check_function_exists (open HAVE_OPEN)\n+check_function_exists (read HAVE_READ)\n+check_function_exists (sched_yield HAVE_SCHED_YIELD)\n \n # Check for the int-type includes\n-check_include_files (sys/types.h HAVE_SYS_TYPES_H)\n-check_include_files (inttypes.h HAVE_INTTYPES_H)\n check_include_files (stdint.h HAVE_STDINT_H)\n \n-\n # Check our 64 bit integer sizes\n check_type_size (__int64 __INT64)\n check_type_size (int64_t INT64_T)\n@@ -124,17 +137,32 @@ check_type_size (int32_t INT32_T)\n check_type_size (__int32 __INT32)\n check_type_size (\""long\"" LONG_INT)\n check_type_size (\""int\"" INT)\n-\n if (HAVE_INT32_T)\n    set (JSON_INT32 int32_t)\n elseif (HAVE___INT32)\n    set (JSON_INT32 __int32)\n-elseif (HAVE_LONG AND (${LONG_INT} EQUAL 4))\n+elseif (HAVE_LONG_INT AND (${LONG_INT} EQUAL 4))\n    set (JSON_INT32 long)\n elseif (HAVE_INT AND (${INT} EQUAL 4))\n    set (JSON_INT32 int)\n else ()\n-   message (FATAL_ERROR \""Could not detect a valid 32 bit integer type\"")\n+   message (FATAL_ERROR \""Could not detect a valid 32-bit integer type\"")\n+endif ()\n+\n+check_type_size (uint32_t UINT32_T)\n+check_type_size (__uint32 __UINT32)\n+check_type_size (\""unsigned long\"" UNSIGNED_LONG_INT)\n+check_type_size (\""unsigned int\"" UNSIGNED_INT)\n+if (HAVE_UINT32_T)\n+   set (JSON_UINT32 uint32_t)\n+elseif (HAVE___UINT32)\n+   set (JSON_UINT32 __uint32)\n+elseif (HAVE_UNSIGNED_LONG_INT AND (${UNSIGNED_LONG_INT} EQUAL 4))\n+   set (JSON_UINT32 \""unsigned long\"")\n+elseif (HAVE_UNSIGNED_INT AND (${UNSIGNED_INT} EQUAL 4))\n+   set (JSON_UINT32 \""unsigned int\"")\n+else ()\n+   message (FATAL_ERROR \""Could not detect a valid unsigned 32-bit integer type\"")\n endif ()\n \n # Check for ssize_t and SSIZE_T existance.\n@@ -206,11 +234,9 @@ else ()\n    set (JSON_HAVE_LOCALECONV 0)\n endif ()\n \n-\n # check if we have setlocale\n check_function_exists (setlocale HAVE_SETLOCALE)\n \n-\n # Check what the inline keyword is.\n # Note that the original JSON_INLINE was always set to just 'inline', so this goes further.\n check_function_keywords(\""inline\"")\n@@ -238,6 +264,9 @@ elseif (HAVE__SNPRINTF)\n    set (JSON_SNPRINTF _snprintf)\n endif ()\n \n+check_c_source_compiles (\""int main() { unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1); return 0; } \"" HAVE_SYNC_BUILTINS)\n+check_c_source_compiles (\""int main() { char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE); return 0; }\"" HAVE_ATOMIC_BUILTINS)\n+\n # Create pkg-conf file.\n # (We use the same files as ./configure does, so we\n #  have to defined the same variables used there).""}<_**next**_>{""sha"": ""b27b9a3a849e94686aa648c1ec4d1bd4c8e35445"", ""filename"": ""cmake/config.h.cmake"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 21, ""changes"": 46, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/cmake/config.h.cmake"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/cmake/config.h.cmake"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/cmake/config.h.cmake?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,35 +1,36 @@\n-/* Reduced down to the defines that are actually used in the code */\n-\n-/* Define to 1 if you have the <inttypes.h> (and friends) header file. */\n-#cmakedefine HAVE_INTTYPES_H 1\n-#cmakedefine HAVE_STDINT_H 1\n+#cmakedefine HAVE_ENDIAN_H 1\n+#cmakedefine HAVE_FCNTL_H 1\n+#cmakedefine HAVE_SCHED_H 1\n+#cmakedefine HAVE_UNISTD_H 1\n+#cmakedefine HAVE_SYS_PARAM_H 1\n+#cmakedefine HAVE_SYS_STAT_H 1\n+#cmakedefine HAVE_SYS_TIME_H 1\n #cmakedefine HAVE_SYS_TYPES_H 1\n+#cmakedefine HAVE_STDINT_H 1\n \n-/* We must include this here, as in (eg) utf.h it will want to use\n-   the integer type, which in MSVC2010 will be in stdint.h\n-   (there is no inttypes.h in MSVC2010) */\n-#if defined(HAVE_STDINT_H)\n-#  include <stdint.h>\n-#elif defined(HAVE_INTTYPES_H)\n-#  include <inttypes.h>\n-#elif defined(HAVE_SYS_TYPES_H)\n-#  include <sys/types.h>\n-#endif\n+#cmakedefine HAVE_CLOSE 1\n+#cmakedefine HAVE_GETPID 1\n+#cmakedefine HAVE_GETTIMEOFDAY 1\n+#cmakedefine HAVE_OPEN 1\n+#cmakedefine HAVE_READ 1\n+#cmakedefine HAVE_SCHED_YIELD 1\n \n-/* Define to 1 if you have the <locale.h> header file. */\n-#cmakedefine HAVE_LOCALE_H 1\n+#cmakedefine HAVE_SYNC_BUILTINS 1\n+#cmakedefine HAVE_ATOMIC_BUILTINS 1\n \n-/* Define to 1 if you have the 'setlocale' function. */\n+#cmakedefine HAVE_LOCALE_H 1\n #cmakedefine HAVE_SETLOCALE 1\n \n-/* Define to the type of a signed integer type of width exactly 32 bits if\n-   such a type exists and the standard includes do not define it. */\n #cmakedefine HAVE_INT32_T 1\n-\n #ifndef HAVE_INT32_T\n #  define int32_t @JSON_INT32@\n #endif\n \n+#cmakedefine HAVE_UINT32_T 1\n+#ifndef HAVE_UINT32_T\n+#  define uint32_t @JSON_UINT32@\n+#endif\n+\n #cmakedefine HAVE_SSIZE_T 1\n \n #ifndef HAVE_SSIZE_T\n@@ -43,3 +44,6 @@\n #endif\n \n #cmakedefine HAVE_VSNPRINTF\n+\n+#cmakedefine USE_URANDOM 1\n+#cmakedefine USE_WINDOWS_CRYPTOAPI 1""}<_**next**_>{""sha"": ""113cb85e17a15f2fac83b528fe1880bc99481ccb"", ""filename"": ""configure.ac"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 2, ""changes"": 50, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/configure.ac"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/configure.ac"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/configure.ac?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -14,10 +14,11 @@ AM_CONDITIONAL([GCC], [test x$GCC = xyes])\n # Checks for libraries.\n \n # Checks for header files.\n-AC_CHECK_HEADERS([locale.h])\n+AC_CHECK_HEADERS([endian.h fcntl.h locale.h sched.h unistd.h sys/param.h sys/stat.h sys/time.h sys/types.h])\n \n # Checks for typedefs, structures, and compiler characteristics.\n AC_TYPE_INT32_T\n+AC_TYPE_UINT32_T\n AC_TYPE_LONG_LONG_INT\n \n AC_C_INLINE\n@@ -29,7 +30,31 @@ esac\n AC_SUBST([json_inline])\n \n # Checks for library functions.\n-AC_CHECK_FUNCS([strtoll localeconv])\n+AC_CHECK_FUNCS([close getpid gettimeofday localeconv open read sched_yield strtoll])\n+\n+AC_MSG_CHECKING([for gcc __sync builtins])\n+have_sync_builtins=no\n+AC_TRY_LINK(\n+  [], [unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1);],\n+  [have_sync_builtins=yes],\n+)\n+if test \""x$have_sync_builtins\"" = \""xyes\""; then\n+  AC_DEFINE([HAVE_SYNC_BUILTINS], [1],\n+    [Define to 1 if gcc's __sync builtins are available])\n+fi\n+AC_MSG_RESULT([$have_sync_builtins])\n+\n+AC_MSG_CHECKING([for gcc __atomic builtins])\n+have_atomic_builtins=no\n+AC_TRY_LINK(\n+  [], [char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE);],\n+  [have_atomic_builtins=yes],\n+)\n+if test \""x$have_atomic_builtins\"" = \""xyes\""; then\n+  AC_DEFINE([HAVE_ATOMIC_BUILTINS], [1],\n+    [Define to 1 if gcc's __atomic builtins are available])\n+fi\n+AC_MSG_RESULT([$have_atomic_builtins])\n \n case \""$ac_cv_type_long_long_int$ac_cv_func_strtoll\"" in\n      yesyes) json_have_long_long=1;;\n@@ -43,6 +68,27 @@ case \""$ac_cv_header_locale_h$ac_cv_func_localeconv\"" in\n esac\n AC_SUBST([json_have_localeconv])\n \n+# Features\n+AC_ARG_ENABLE([urandom],\n+  [AS_HELP_STRING([--disable-urandom],\n+    [Don't use /dev/urandom to seed the hash function])],\n+  [use_urandom=$enableval], [use_urandom=yes])\n+\n+if test \""x$use_urandom\"" = xyes; then\n+AC_DEFINE([USE_URANDOM], [1],\n+  [Define to 1 if /dev/urandom should be used for seeding the hash function])\n+fi\n+\n+AC_ARG_ENABLE([windows-cryptoapi],\n+  [AS_HELP_STRING([--disable-windows-cryptoapi],\n+    [Don't use CryptGenRandom to seed the hash function])],\n+  [use_windows_cryptoapi=$enableval], [use_windows_cryptoapi=yes])\n+\n+if test \""x$use_windows_cryptoapi\"" = xyes; then\n+AC_DEFINE([USE_WINDOWS_CRYPTOAPI], [1],\n+  [Define to 1 if CryptGenRandom should be used for seeding the hash function])\n+fi\n+\n AC_CONFIG_FILES([\n         jansson.pc\n         Makefile""}<_**next**_>{""sha"": ""b4af562e84b5ed9dba1107af7d1768dcdb0b9a95"", ""filename"": ""src/Makefile.am"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/Makefile.am"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/Makefile.am?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -8,6 +8,7 @@ libjansson_la_SOURCES = \\\n \terror.c \\\n \thashtable.c \\\n \thashtable.h \\\n+\thashtable_seed.c \\\n \tjansson_private.h \\\n \tload.c \\\n \tmemory.c \\""}<_**next**_>{""sha"": ""abd4bf11fe7a393fcf3d533b952aa8b5efa4ea30"", ""filename"": ""src/hashtable.c"", ""status"": ""modified"", ""additions"": 26, ""deletions"": 41, ""changes"": 67, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -5,8 +5,17 @@\n  * it under the terms of the MIT license. See LICENSE for details.\n  */\n \n+#if HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stdlib.h>\n #include <string.h>\n+\n+#if HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include <jansson_config.h>   /* for JSON_INLINE */\n #include \""jansson_private.h\""  /* for container_of() */\n #include \""hashtable.h\""\n@@ -15,24 +24,13 @@ typedef struct hashtable_list list_t;\n typedef struct hashtable_pair pair_t;\n typedef struct hashtable_bucket bucket_t;\n \n-#define list_to_pair(list_)  container_of(list_, pair_t, list)\n-\n-/* From http://www.cse.yorku.ca/~oz/hash.html */\n-static size_t hash_str(const void *ptr)\n-{\n-    const char *str = (const char *)ptr;\n-\n-    size_t hash = 5381;\n-    size_t c;\n+extern volatile uint32_t hashtable_seed;\n \n-    while((c = (size_t)*str))\n-    {\n-        hash = ((hash << 5) + hash) + c;\n-        str++;\n-    }\n+/* Implementation of the hash function */\n+#include \""lookup3.h\""\n \n-    return hash;\n-}\n+#define list_to_pair(list_)  container_of(list_, pair_t, list)\n+#define hash_str(key)        ((size_t)hashlittle((key), strlen(key), hashtable_seed))\n \n static JSON_INLINE void list_init(list_t *list)\n {\n@@ -74,19 +72,6 @@ static void insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket,\n     }\n }\n \n-static const size_t primes[] = {\n-    5, 13, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,\n-    49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,\n-    12582917, 25165843, 50331653, 100663319, 201326611, 402653189,\n-    805306457, 1610612741\n-};\n-\n-static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)\n-{\n-    return primes[hashtable->num_buckets];\n-}\n-\n-\n static pair_t *hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket,\n                                    const char *key, size_t hash)\n {\n@@ -120,7 +105,7 @@ static int hashtable_do_del(hashtable_t *hashtable,\n     bucket_t *bucket;\n     size_t index;\n \n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n@@ -167,14 +152,14 @@ static int hashtable_do_rehash(hashtable_t *hashtable)\n \n     jsonp_free(hashtable->buckets);\n \n-    hashtable->num_buckets++;\n-    new_size = num_buckets(hashtable);\n+    hashtable->order++;\n+    new_size = hashsize(hashtable->order);\n \n     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -199,14 +184,14 @@ int hashtable_init(hashtable_t *hashtable)\n     size_t i;\n \n     hashtable->size = 0;\n-    hashtable->num_buckets = 0;  /* index to primes[] */\n-    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));\n+    hashtable->order = 3;\n+    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n     list_init(&hashtable->list);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -230,12 +215,12 @@ int hashtable_set(hashtable_t *hashtable,\n     size_t hash, index;\n \n     /* rehash if the load ratio exceeds 1 */\n-    if(hashtable->size >= num_buckets(hashtable))\n+    if(hashtable->size >= hashsize(hashtable->order))\n         if(hashtable_do_rehash(hashtable))\n             return -1;\n \n     hash = hash_str(key);\n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n \n@@ -273,7 +258,7 @@ void *hashtable_get(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)\n@@ -294,7 +279,7 @@ void hashtable_clear(hashtable_t *hashtable)\n \n     hashtable_do_clear(hashtable);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -316,7 +301,7 @@ void *hashtable_iter_at(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)""}<_**next**_>{""sha"": ""469c6ecd869c4698f650fa81983bb3ee03d47fab"", ""filename"": ""src/hashtable.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -32,14 +32,15 @@ struct hashtable_bucket {\n typedef struct hashtable {\n     size_t size;\n     struct hashtable_bucket *buckets;\n-    size_t num_buckets;  /* index to primes[] */\n+    size_t order;  /* hashtable has pow(2, order) buckets */\n     struct hashtable_list list;\n } hashtable_t;\n \n \n #define hashtable_key_to_iter(key_) \\\n     (&(container_of(key_, struct hashtable_pair, key)->list))\n \n+\n /**\n  * hashtable_init - Initialize a hashtable object\n  *""}<_**next**_>{""sha"": ""a07d145d10df35b933c1441dcbf42d3316b78ca5"", ""filename"": ""src/hashtable_seed.c"", ""status"": ""added"", ""additions"": 278, ""deletions"": 0, ""changes"": 278, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable_seed.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable_seed.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable_seed.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,278 @@\n+/* Generate sizeof(uint32_t) bytes of as random data as possible to seed\n+   the hash function.\n+*/\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#include <stdio.h>\n+#include <time.h>\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n+#ifdef HAVE_FCNTL_H\n+#include <fcntl.h>\n+#endif\n+\n+#ifdef HAVE_SCHED_H\n+#include <sched.h>\n+#endif\n+\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+\n+#ifdef HAVE_SYS_STAT_H\n+#include <sys/stat.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TIME_H\n+#include <sys/time.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TYPES_H\n+#include <sys/types.h>\n+#endif\n+\n+#if defined(_WIN32)\n+/* For _getpid() */\n+#include <process.h>\n+#endif\n+\n+#include \""jansson.h\""\n+\n+\n+static uint32_t buf_to_uint32(char *data) {\n+    size_t i;\n+    uint32_t result = 0;\n+\n+    for (i = 0; i < sizeof(uint32_t); i++)\n+        result = (result << 8) | (unsigned char)data[i];\n+\n+    return result;\n+}\n+\n+\n+\n+/* /dev/urandom */\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+static int seed_from_urandom(uint32_t *seed) {\n+    /* Use unbuffered I/O if we have open(), close() and read(). Otherwise\n+       fall back to fopen() */\n+\n+    char data[sizeof(uint32_t)];\n+    int ok;\n+\n+#if defined(HAVE_OPEN) && defined(HAVE_CLOSE) && defined(HAVE_READ)\n+    int urandom;\n+    urandom = open(\""/dev/urandom\"", O_RDONLY);\n+    if (urandom == -1)\n+        return 1;\n+\n+    ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);\n+    close(urandom);\n+#else\n+    FILE *urandom;\n+\n+    urandom = fopen(\""/dev/urandom\"", \""rb\"");\n+    if (!urandom)\n+        return 1;\n+\n+    ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);\n+    fclose(urandom);\n+#endif\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32(data);\n+    return 0;\n+}\n+#endif\n+\n+/* Windows Crypto API */\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+#include <windows.h>\n+#include <wincrypt.h>\n+\n+typedef BOOL (WINAPI *CRYPTACQUIRECONTEXTA)(HCRYPTPROV *phProv, LPCSTR pszContainer, LPCSTR pszProvider, DWORD dwProvType, DWORD dwFlags);\n+typedef BOOL (WINAPI *CRYPTGENRANDOM)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);\n+typedef BOOL (WINAPI *CRYPTRELEASECONTEXT)(HCRYPTPROV hProv, DWORD dwFlags);\n+\n+static int seed_from_windows_cryptoapi(uint32_t *seed)\n+{\n+    HINSTANCE hAdvAPI32 = NULL;\n+    CRYPTACQUIRECONTEXTA pCryptAcquireContext = NULL;\n+    CRYPTGENRANDOM pCryptGenRandom = NULL;\n+    CRYPTRELEASECONTEXT pCryptReleaseContext = NULL;\n+    HCRYPTPROV hCryptProv = 0;\n+    BYTE data[sizeof(uint32_t)];\n+    int ok;\n+\n+    hAdvAPI32 = GetModuleHandle(\""advapi32.dll\"");\n+    if(hAdvAPI32 == NULL)\n+        return 1;\n+\n+    pCryptAcquireContext = (CRYPTACQUIRECONTEXTA)GetProcAddress(hAdvAPI32, \""CryptAcquireContextA\"");\n+    if (!pCryptAcquireContext)\n+        return 1;\n+\n+    pCryptGenRandom = (CRYPTGENRANDOM)GetProcAddress(hAdvAPI32, \""CryptGenRandom\"");\n+    if (!pCryptGenRandom)\n+        return 1;\n+\n+    pCryptReleaseContext = (CRYPTRELEASECONTEXT)GetProcAddress(hAdvAPI32, \""CryptReleaseContext\"");\n+    if (!pCryptReleaseContext)\n+        return 1;\n+\n+    if (!pCryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))\n+        return 1;\n+\n+    ok = CryptGenRandom(hCryptProv, sizeof(uint32_t), data);\n+    pCryptReleaseContext(hCryptProv, 0);\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32((char *)data);\n+    return 0;\n+}\n+#endif\n+\n+/* gettimeofday() and getpid() */\n+static int seed_from_timestamp_and_pid(uint32_t *seed) {\n+#ifdef HAVE_GETTIMEOFDAY\n+    /* XOR of seconds and microseconds */\n+    struct timeval tv;\n+    gettimeofday(&tv, NULL);\n+    *seed = (uint32_t)tv.tv_sec ^ (uint32_t)tv.tv_usec;\n+#else\n+    /* Seconds only */\n+    *seed = (uint32_t)time(NULL);\n+#endif\n+\n+    /* XOR with PID for more randomness */\n+#if defined(_WIN32)\n+    *seed ^= (uint32_t)_getpid();\n+#elif defined(HAVE_GETPID)\n+    *seed ^= (uint32_t)getpid();\n+#endif\n+\n+    return 0;\n+}\n+\n+static uint32_t generate_seed() {\n+    uint32_t seed;\n+    int done = 0;\n+\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+    if (!done && seed_from_urandom(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+    if (!done && seed_from_windows_cryptoapi(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+    if (!done) {\n+        /* Fall back to timestamp and PID if no better randomness is\n+           available */\n+        seed_from_timestamp_and_pid(&seed);\n+    }\n+\n+    /* Make sure the seed is never zero */\n+    if (seed == 0)\n+        seed = 1;\n+\n+    return seed;\n+}\n+\n+\n+volatile uint32_t hashtable_seed = 0;\n+\n+#if defined(HAVE_ATOMIC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+static volatile char seed_initialized = 0;\n+\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (__atomic_test_and_set(&seed_initialized, __ATOMIC_RELAXED) == 0) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            __atomic_store_n(&hashtable_seed, new_seed, __ATOMIC_ACQ_REL);\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            } while(__atomic_load_n(&hashtable_seed, __ATOMIC_ACQUIRE) == 0);\n+        }\n+    }\n+}\n+#elif defined(HAVE_SYNC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0) {\n+            /* Explicit synchronization fences are not supported by the\n+               __sync builtins, so every thread getting here has to\n+               generate the seed value.\n+            */\n+            new_seed = generate_seed();\n+        }\n+\n+        do {\n+            if (__sync_bool_compare_and_swap(&hashtable_seed, 0, new_seed)) {\n+                /* We were the first to seed */\n+                break;\n+            } else {\n+                /* Wait for another thread to do the seeding */\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            }\n+        } while(hashtable_seed == 0);\n+    }\n+}\n+#elif defined(_WIN32)\n+static long seed_initialized = 0;\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (InterlockedIncrement(&seed_initialized) == 1) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            hashtable_seed = new_seed;\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+                SwitchToThread();\n+            } while (hashtable_seed == 0);\n+        }\n+    }\n+}\n+#else\n+/* Fall back to a thread-unsafe version */\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0)\n+            new_seed = generate_seed();\n+\n+        hashtable_seed = new_seed;\n+    }\n+}\n+#endif""}<_**next**_>{""sha"": ""19096d4201e6b13f8c56765116865c71f67e9696"", ""filename"": ""src/jansson.def"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.def"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.def"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/jansson.def?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -41,6 +41,7 @@ EXPORTS\n     json_object_iter_value\n     json_object_iter_set_new\n     json_object_key_to_iter\n+    json_object_seed\n     json_dumps\n     json_dumpf\n     json_dump_file""}<_**next**_>{""sha"": ""ea230852a629e55457fba2d00e3edd8a4ad4fcec"", ""filename"": ""src/jansson.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/jansson.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -126,6 +126,7 @@ typedef struct {\n \n /* getters, setters, manipulation */\n \n+void json_object_seed(size_t seed);\n size_t json_object_size(const json_t *object);\n json_t *json_object_get(const json_t *object, const char *key);\n int json_object_set_new(json_t *object, const char *key, json_t *value);""}<_**next**_>{""sha"": ""dc76138c940516e9590784825d28d040fd1a8b25"", ""filename"": ""src/lookup3.h"", ""status"": ""added"", ""additions"": 366, ""deletions"": 0, ""changes"": 366, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/lookup3.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/lookup3.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/lookup3.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,366 @@\n+/*\n+-------------------------------------------------------------------------------\n+lookup3.c, by Bob Jenkins, May 2006, Public Domain.\n+\n+These are functions for producing 32-bit hashes for hash table lookup.\n+hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final() \n+are externally useful functions.  Routines to test the hash are included \n+if SELF_TEST is defined.  You can use this free for any purpose.  It's in\n+the public domain.  It has no warranty.\n+\n+You probably want to use hashlittle().  hashlittle() and hashbig()\n+hash byte arrays.  hashlittle() is is faster than hashbig() on\n+little-endian machines.  Intel and AMD are little-endian machines.\n+On second thought, you probably want hashlittle2(), which is identical to\n+hashlittle() except it returns two 32-bit hashes for the price of one.  \n+You could implement hashbig2() if you wanted but I haven't bothered here.\n+\n+If you want to find a hash of, say, exactly 7 integers, do\n+  a = i1;  b = i2;  c = i3;\n+  mix(a,b,c);\n+  a += i4; b += i5; c += i6;\n+  mix(a,b,c);\n+  a += i7;\n+  final(a,b,c);\n+then use c as the hash value.  If you have a variable length array of\n+4-byte integers to hash, use hashword().  If you have a byte array (like\n+a character string), use hashlittle().  If you have several byte arrays, or\n+a mix of things, see the comments above hashlittle().  \n+\n+Why is this so big?  I read 12 bytes at a time into 3 4-byte integers, \n+then mix those integers.  This is fast (you can do a lot more thorough\n+mixing with 12*3 instructions on 3 integers than you can with 3 instructions\n+on 1 byte), but shoehorning those bytes into integers efficiently is messy.\n+-------------------------------------------------------------------------------\n+*/\n+\n+#include <stdlib.h>\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>     /* defines uint32_t etc */\n+#endif\n+\n+#ifdef HAVE_SYS_PARAM_H\n+#include <sys/param.h>  /* attempt to define endianness */\n+#endif\n+\n+#ifdef HAVE_ENDIAN_H\n+# include <endian.h>    /* attempt to define endianness */\n+#endif\n+\n+/*\n+ * My best guess at if you are big-endian or little-endian.  This may\n+ * need adjustment.\n+ */\n+#if (defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && \\\n+     __BYTE_ORDER == __LITTLE_ENDIAN) || \\\n+    (defined(i386) || defined(__i386__) || defined(__i486__) || \\\n+     defined(__i586__) || defined(__i686__) || defined(vax) || defined(MIPSEL))\n+# define HASH_LITTLE_ENDIAN 1\n+# define HASH_BIG_ENDIAN 0\n+#elif (defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && \\\n+       __BYTE_ORDER == __BIG_ENDIAN) || \\\n+      (defined(sparc) || defined(POWERPC) || defined(mc68000) || defined(sel))\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 1\n+#else\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 0\n+#endif\n+\n+#define hashsize(n) ((uint32_t)1<<(n))\n+#define hashmask(n) (hashsize(n)-1)\n+#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n+\n+/*\n+-------------------------------------------------------------------------------\n+mix -- mix 3 32-bit values reversibly.\n+\n+This is reversible, so any information in (a,b,c) before mix() is\n+still in (a,b,c) after mix().\n+\n+If four pairs of (a,b,c) inputs are run through mix(), or through\n+mix() in reverse, there are at least 32 bits of the output that\n+are sometimes the same for one pair and different for another pair.\n+This was tested for:\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+Some k values for my \""a-=c; a^=rot(c,k); c+=b;\"" arrangement that\n+satisfy this are\n+    4  6  8 16 19  4\n+    9 15  3 18 27 15\n+   14  9  3  7 17  3\n+Well, \""9 15 3 18 27 15\"" didn't quite get 32 bits diffing\n+for \""differ\"" defined as + with a one-bit base and a two-bit delta.  I\n+used http://burtleburtle.net/bob/hash/avalanche.html to choose \n+the operations, constants, and arrangements of the variables.\n+\n+This does not achieve avalanche.  There are input bits of (a,b,c)\n+that fail to affect some output bits of (a,b,c), especially of a.  The\n+most thoroughly mixed value is c, but it doesn't really even achieve\n+avalanche in c.\n+\n+This allows some parallelism.  Read-after-writes are good at doubling\n+the number of bits affected, so the goal of mixing pulls in the opposite\n+direction as the goal of parallelism.  I did what I could.  Rotates\n+seem to cost as much as shifts on every machine I could lay my hands\n+on, and rotates are much kinder to the top and bottom bits, so I used\n+rotates.\n+-------------------------------------------------------------------------------\n+*/\n+#define mix(a,b,c) \\\n+{ \\\n+  a -= c;  a ^= rot(c, 4);  c += b; \\\n+  b -= a;  b ^= rot(a, 6);  a += c; \\\n+  c -= b;  c ^= rot(b, 8);  b += a; \\\n+  a -= c;  a ^= rot(c,16);  c += b; \\\n+  b -= a;  b ^= rot(a,19);  a += c; \\\n+  c -= b;  c ^= rot(b, 4);  b += a; \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+final -- final mixing of 3 32-bit values (a,b,c) into c\n+\n+Pairs of (a,b,c) values differing in only a few bits will usually\n+produce values of c that look totally different.  This was tested for\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+These constants passed:\n+ 14 11 25 16 4 14 24\n+ 12 14 25 16 4 14 24\n+and these came close:\n+  4  8 15 26 3 22 24\n+ 10  8 15 26 3 22 24\n+ 11  8 15 26 3 22 24\n+-------------------------------------------------------------------------------\n+*/\n+#define final(a,b,c) \\\n+{ \\\n+  c ^= b; c -= rot(b,14); \\\n+  a ^= c; a -= rot(c,11); \\\n+  b ^= a; b -= rot(a,25); \\\n+  c ^= b; c -= rot(b,16); \\\n+  a ^= c; a -= rot(c,4);  \\\n+  b ^= a; b -= rot(a,14); \\\n+  c ^= b; c -= rot(b,24); \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+hashlittle() -- hash a variable-length key into a 32-bit value\n+  k       : the key (the unaligned variable-length array of bytes)\n+  length  : the length of the key, counting by bytes\n+  initval : can be any 4-byte value\n+Returns a 32-bit value.  Every bit of the key affects every bit of\n+the return value.  Two keys differing by one or two bits will have\n+totally different hash values.\n+\n+The best hash table sizes are powers of 2.  There is no need to do\n+mod a prime (mod is sooo slow!).  If you need less than 32 bits,\n+use a bitmask.  For example, if you need only 10 bits, do\n+  h = (h & hashmask(10));\n+In which case, the hash table should have hashsize(10) elements.\n+\n+If you are hashing n strings (uint8_t **)k, do it like this:\n+  for (i=0, h=0; i<n; ++i) h = hashlittle( k[i], len[i], h);\n+\n+By Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this\n+code any way you wish, private, educational, or commercial.  It's free.\n+\n+Use for hash table lookup, or anything where one collision in 2^^32 is\n+acceptable.  Do NOT use for cryptographic purposes.\n+-------------------------------------------------------------------------------\n+*/\n+\n+static uint32_t hashlittle(const void *key, size_t length, uint32_t initval)\n+{\n+  uint32_t a,b,c;                                          /* internal state */\n+  union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */\n+\n+  /* Set up the internal state */\n+  a = b = c = 0xdeadbeef + ((uint32_t)length) + initval;\n+\n+  u.ptr = key;\n+  if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0)) {\n+    const uint32_t *k = (const uint32_t *)key;         /* read 32-bit chunks */\n+\n+#ifdef VALGRIND\n+    const uint8_t  *k8;\n+#endif\n+\n+    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      b += k[1];\n+      c += k[2];\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 3;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    /* \n+     * \""k[2]&0xffffff\"" actually reads beyond the end of the string, but\n+     * then masks off the part it's not allowed to read.  Because the\n+     * string is aligned, the masked-off tail is in the same word as the\n+     * rest of the string.  Every machine with memory protection I've seen\n+     * does it on word boundaries, so is OK with this.  But VALGRIND will\n+     * still catch it and complain.  The masking trick does make the hash\n+     * noticably faster for short strings (like English words).\n+     */\n+#ifndef VALGRIND\n+\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n+    case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n+    case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n+    case 6 : b+=k[1]&0xffff; a+=k[0]; break;\n+    case 5 : b+=k[1]&0xff; a+=k[0]; break;\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=k[0]&0xffffff; break;\n+    case 2 : a+=k[0]&0xffff; break;\n+    case 1 : a+=k[0]&0xff; break;\n+    case 0 : return c;              /* zero length strings require no mixing */\n+    }\n+\n+#else /* make valgrind happy */\n+\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=((uint32_t)k8[10])<<16;  /* fall through */\n+    case 10: c+=((uint32_t)k8[9])<<8;    /* fall through */\n+    case 9 : c+=k8[8];                   /* fall through */\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;   /* fall through */\n+    case 6 : b+=((uint32_t)k8[5])<<8;    /* fall through */\n+    case 5 : b+=k8[4];                   /* fall through */\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;   /* fall through */\n+    case 2 : a+=((uint32_t)k8[1])<<8;    /* fall through */\n+    case 1 : a+=k8[0]; break;\n+    case 0 : return c;\n+    }\n+\n+#endif /* !valgrind */\n+\n+  } else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0)) {\n+    const uint16_t *k = (const uint16_t *)key;         /* read 16-bit chunks */\n+    const uint8_t  *k8;\n+\n+    /*--------------- all but last block: aligned reads and different mixing */\n+    while (length > 12)\n+    {\n+      a += k[0] + (((uint32_t)k[1])<<16);\n+      b += k[2] + (((uint32_t)k[3])<<16);\n+      c += k[4] + (((uint32_t)k[5])<<16);\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 6;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[4]+(((uint32_t)k[5])<<16);\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 11: c+=((uint32_t)k8[10])<<16;     /* fall through */\n+    case 10: c+=k[4];\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 9 : c+=k8[8];                      /* fall through */\n+    case 8 : b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;      /* fall through */\n+    case 6 : b+=k[2];\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 5 : b+=k8[4];                      /* fall through */\n+    case 4 : a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;      /* fall through */\n+    case 2 : a+=k[0];\n+             break;\n+    case 1 : a+=k8[0];\n+             break;\n+    case 0 : return c;                     /* zero length requires no mixing */\n+    }\n+\n+  } else {                        /* need to read the key one byte at a time */\n+    const uint8_t *k = (const uint8_t *)key;\n+\n+    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      a += ((uint32_t)k[1])<<8;\n+      a += ((uint32_t)k[2])<<16;\n+      a += ((uint32_t)k[3])<<24;\n+      b += k[4];\n+      b += ((uint32_t)k[5])<<8;\n+      b += ((uint32_t)k[6])<<16;\n+      b += ((uint32_t)k[7])<<24;\n+      c += k[8];\n+      c += ((uint32_t)k[9])<<8;\n+      c += ((uint32_t)k[10])<<16;\n+      c += ((uint32_t)k[11])<<24;\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 12;\n+    }\n+\n+    /*-------------------------------- last block: affect all 32 bits of (c) */\n+    switch(length)                   /* all the case statements fall through */\n+    {\n+    case 12: c+=((uint32_t)k[11])<<24;\n+    case 11: c+=((uint32_t)k[10])<<16;\n+    case 10: c+=((uint32_t)k[9])<<8;\n+    case 9 : c+=k[8];\n+    case 8 : b+=((uint32_t)k[7])<<24;\n+    case 7 : b+=((uint32_t)k[6])<<16;\n+    case 6 : b+=((uint32_t)k[5])<<8;\n+    case 5 : b+=k[4];\n+    case 4 : a+=((uint32_t)k[3])<<24;\n+    case 3 : a+=((uint32_t)k[2])<<16;\n+    case 2 : a+=((uint32_t)k[1])<<8;\n+    case 1 : a+=k[0];\n+             break;\n+    case 0 : return c;\n+    }\n+  }\n+\n+  final(a,b,c);\n+  return c;\n+}""}<_**next**_>{""sha"": ""b4f109143031b2481a0d32a332c88cc1cc96c688"", ""filename"": ""src/utf.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 16, ""changes"": 20, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/utf.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/utf.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/utf.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -10,23 +10,11 @@\n \n #ifdef HAVE_CONFIG_H\n #include <config.h>\n+#endif\n \n-#ifdef HAVE_INTTYPES_H\n-/* inttypes.h includes stdint.h in a standard environment, so there's\n-no need to include stdint.h separately. If inttypes.h doesn't define\n-int32_t, it's defined in config.h. */\n-#include <inttypes.h>\n-#endif /* HAVE_INTTYPES_H */\n-\n-#else /* !HAVE_CONFIG_H */\n-#ifdef _WIN32\n-typedef int int32_t;\n-#else /* !_WIN32 */\n-/* Assume a standard environment */\n-#include <inttypes.h>\n-#endif /* _WIN32 */\n-\n-#endif /* HAVE_CONFIG_H */\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n \n int utf8_encode(int codepoint, char *buffer, int *size);\n ""}<_**next**_>{""sha"": ""1b02d90aa885f1ede146bb2077d05c8bb9096565"", ""filename"": ""src/value.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/value.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/value.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/value.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -9,11 +9,19 @@\n #define _GNU_SOURCE\n #endif\n \n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stddef.h>\n #include <stdlib.h>\n #include <string.h>\n #include <math.h>\n \n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include \""jansson.h\""\n #include \""hashtable.h\""\n #include \""jansson_private.h\""\n@@ -36,11 +44,19 @@ static JSON_INLINE void json_init(json_t *json, json_type type)\n \n /*** object ***/\n \n+extern volatile uint32_t hashtable_seed;\n+\n json_t *json_object(void)\n {\n     json_object_t *object = jsonp_malloc(sizeof(json_object_t));\n     if(!object)\n         return NULL;\n+\n+    if (!hashtable_seed) {\n+        /* Autoseed */\n+        json_object_seed(0);\n+    }\n+\n     json_init(&object->json, JSON_OBJECT);\n \n     if(hashtable_init(&object->hashtable))""}<_**next**_>{""sha"": ""e2c54bd12bd7c22de7cc3533f010b26cc1c330b0"", ""filename"": ""test/bin/json_process.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 1, ""changes"": 16, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/bin/json_process.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/bin/json_process.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/bin/json_process.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -37,6 +37,8 @@ struct config {\n     int sort_keys;\n     int strip;\n     int use_env;\n+    int have_hashseed;\n+    int hashseed;\n } conf;\n \n #define l_isspace(c) ((c) == ' ' || (c) == '\\n' || (c) == '\\r' || (c) == '\\t')\n@@ -108,6 +110,12 @@ static void read_conf(FILE *conffile)\n             conf.sort_keys = atoi(val);\n         if (!strcmp(line, \""STRIP\""))\n             conf.strip = atoi(val);\n+        if (!strcmp(line, \""HASHSEED\"")) {\n+            conf.have_hashseed = 1;\n+            conf.hashseed = atoi(val);\n+        } else {\n+            conf.have_hashseed = 0;\n+        }\n     }\n \n     free(buffer);\n@@ -188,6 +196,9 @@ int use_conf(char *test_path)\n     if (conf.sort_keys)\n         flags |= JSON_SORT_KEYS;\n \n+    if (conf.have_hashseed)\n+        json_object_seed(conf.hashseed);\n+\n     if (conf.strip) {\n         /* Load to memory, strip leading and trailing whitespace */\n         buffer = loadfile(infile);\n@@ -265,7 +276,10 @@ int use_env()\n         flags |= JSON_PRESERVE_ORDER;\n \n     if(getenv_int(\""JSON_SORT_KEYS\""))\n-         flags |= JSON_SORT_KEYS;\n+        flags |= JSON_SORT_KEYS;\n+\n+    if(getenv(\""HASHSEED\""))\n+        json_object_seed(getenv_int(\""HASHSEED\""));\n \n     if(getenv_int(\""STRIP\"")) {\n         /* Load to memory, strip leading and trailing whitespace */""}<_**next**_>{""sha"": ""84b17466fd0a753b8cbd714d0236ed9072cdd536"", ""filename"": ""test/suites/api/test_memory_funcs.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_memory_funcs.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_memory_funcs.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/api/test_memory_funcs.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -24,13 +24,13 @@ static void create_and_free_complex_object()\n \n static void *my_malloc(size_t size)\n {\n-    malloc_called += 1;\n+    malloc_called = 1;\n     return malloc(size);\n }\n \n static void my_free(void *ptr)\n {\n-    free_called += 1;\n+    free_called = 1;\n     free(ptr);\n }\n \n@@ -39,7 +39,7 @@ static void test_simple()\n     json_set_alloc_funcs(my_malloc, my_free);\n     create_and_free_complex_object();\n \n-    if(malloc_called != 20 || free_called != 20)\n+    if(malloc_called != 1 || free_called != 1)\n         fail(\""Custom allocation failed\"");\n }\n ""}<_**next**_>{""sha"": ""92e5208224b75ab45d93672446279d598052a83e"", ""filename"": ""test/suites/api/test_object.c"", ""status"": ""modified"", ""additions"": 40, ""deletions"": 24, ""changes"": 64, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_object.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_object.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/api/test_object.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -249,7 +249,11 @@ static void test_set_nocheck()\n \n static void test_iterators()\n {\n+    int i;\n     json_t *object, *foo, *bar, *baz;\n+    const char *iter_keys[3];\n+    int have_key[3] = { 0, 0, 0 };\n+    json_t *iter_values[3];\n     void *iter;\n \n     if(json_object_iter(NULL))\n@@ -276,30 +280,50 @@ static void test_iterators()\n     iter = json_object_iter(object);\n     if(!iter)\n         fail(\""unable to get iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""a\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != foo)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[0] = json_object_iter_key(iter);\n+    iter_values[0] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""b\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != bar)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[1] = json_object_iter_key(iter);\n+    iter_values[1] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[2] = json_object_iter_key(iter);\n+    iter_values[2] = json_object_iter_value(iter);\n \n     if(json_object_iter_next(object, iter) != NULL)\n         fail(\""able to iterate over the end\"");\n \n+    /* Check that keys have correct values */\n+    for (i = 0; i < 3; i++) {\n+        if (strcmp(iter_keys[i], \""a\"") == 0) {\n+            if (iter_values[i] != foo)\n+                fail(\""wrong value for iter key a\"");\n+            else\n+                have_key[0] = 1;\n+        } else if (strcmp(iter_keys[i], \""b\"") == 0) {\n+            if (iter_values[i] != bar)\n+                fail(\""wrong value for iter key b\"");\n+            else\n+                have_key[1] = 1;\n+        } else if (strcmp(iter_keys[i], \""c\"") == 0) {\n+            if (iter_values[i] != baz)\n+                fail(\""wrong value for iter key c\"");\n+            else\n+                have_key[2] = 1;\n+        }\n+    }\n+\n+    /* Check that we got all keys */\n+    for(i = 0; i < 3; i++) {\n+        if(!have_key[i])\n+            fail(\""a key wasn't iterated over\"");\n+    }\n+\n     if(json_object_iter_at(object, \""foo\""))\n         fail(\""json_object_iter_at() succeeds for non-existent key\"");\n \n@@ -312,22 +336,14 @@ static void test_iterators()\n     if(json_object_iter_value(iter) != bar)\n         fail(\""iterating failed: wrong value\"");\n \n-    iter = json_object_iter_next(object, iter);\n-    if(!iter)\n-        fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\""iterating failed: wrong value\"");\n-\n-    if(json_object_iter_set(object, iter, bar))\n+    if(json_object_iter_set(object, iter, baz))\n         fail(\""unable to set value at iterator\"");\n \n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n+    if(strcmp(json_object_iter_key(iter), \""b\""))\n         fail(\""json_object_iter_key() fails after json_object_iter_set()\"");\n-    if(json_object_iter_value(iter) != bar)\n+    if(json_object_iter_value(iter) != baz)\n         fail(\""json_object_iter_value() fails after json_object_iter_set()\"");\n-    if(json_object_get(object, \""c\"") != bar)\n+    if(json_object_get(object, \""b\"") != baz)\n         fail(\""json_object_get() fails after json_object_iter_set()\"");\n \n     json_decref(object);""}<_**next**_>{""sha"": ""93cb33ddafeb9eef6ce7ad4709ce1bcbdf25b200"", ""filename"": ""test/suites/encoding-flags/compact-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/compact-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/compact-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/compact-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,2 +1,3 @@\n JSON_COMPACT=1\n-export JSON_COMPACT\n+HASHSEED=1\n+export JSON_COMPACT HASHSEED""}<_**next**_>{""sha"": ""c73acc1792963be8a5f41ff11f6e858506ada51d"", ""filename"": ""test/suites/encoding-flags/indent-compact-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-compact-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-compact-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/indent-compact-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,3 +1,4 @@\n JSON_INDENT=4\n JSON_COMPACT=1\n-export JSON_INDENT JSON_COMPACT\n+HASHSEED=1\n+export JSON_INDENT JSON_COMPACT HASHSEED""}<_**next**_>{""sha"": ""961558ca23ceca2ce6e4d07697f4018d8475f317"", ""filename"": ""test/suites/encoding-flags/indent-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/indent-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,2 +1,3 @@\n JSON_INDENT=4\n-export JSON_INDENT\n+HASHSEED=1\n+export JSON_INDENT HASHSEED""}<_**next**_>{""sha"": ""9120b03514ec614695c2d17841ba228b102c9db6"", ""filename"": ""test/suites/encoding-flags/object/env"", ""status"": ""added"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,2 @@\n+HASHSEED=1\n+export HASHSEED""}","void hashtable_clear(hashtable_t *hashtable)
{
    size_t i;
 
     hashtable_do_clear(hashtable);
 
    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
    }

    list_init(&hashtable->list);
    hashtable->size = 0;
}
","void hashtable_clear(hashtable_t *hashtable)
{
    size_t i;
 
     hashtable_do_clear(hashtable);
 
    for(i = 0; i < num_buckets(hashtable); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
    }

    list_init(&hashtable->list);
    hashtable->size = 0;
}
",C,"    for(i = 0; i < hashsize(hashtable->order); i++)
","    for(i = 0; i < num_buckets(hashtable); i++)
",,"@@ -5,8 +5,17 @@
  * it under the terms of the MIT license. See LICENSE for details.
  */
 
+#if HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include <stdlib.h>
 #include <string.h>
+
+#if HAVE_STDINT_H
+#include <stdint.h>
+#endif
+
 #include <jansson_config.h>   /* for JSON_INLINE */
 #include ""jansson_private.h""  /* for container_of() */
 #include ""hashtable.h""
@@ -15,24 +24,13 @@ typedef struct hashtable_list list_t;
 typedef struct hashtable_pair pair_t;
 typedef struct hashtable_bucket bucket_t;
 
-#define list_to_pair(list_)  container_of(list_, pair_t, list)
-
-/* From http://www.cse.yorku.ca/~oz/hash.html */
-static size_t hash_str(const void *ptr)
-{
-    const char *str = (const char *)ptr;
-
-    size_t hash = 5381;
-    size_t c;
+extern volatile uint32_t hashtable_seed;
 
-    while((c = (size_t)*str))
-    {
-        hash = ((hash << 5) + hash) + c;
-        str++;
-    }
+/* Implementation of the hash function */
+#include ""lookup3.h""
 
-    return hash;
-}
+#define list_to_pair(list_)  container_of(list_, pair_t, list)
+#define hash_str(key)        ((size_t)hashlittle((key), strlen(key), hashtable_seed))
 
 static JSON_INLINE void list_init(list_t *list)
 {
@@ -74,19 +72,6 @@ static void insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket,
     }
 }
 
-static const size_t primes[] = {
-    5, 13, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,
-    49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,
-    12582917, 25165843, 50331653, 100663319, 201326611, 402653189,
-    805306457, 1610612741
-};
-
-static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)
-{
-    return primes[hashtable->num_buckets];
-}
-
-
 static pair_t *hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket,
                                    const char *key, size_t hash)
 {
@@ -120,7 +105,7 @@ static int hashtable_do_del(hashtable_t *hashtable,
     bucket_t *bucket;
     size_t index;
 
-    index = hash % num_buckets(hashtable);
+    index = hash & hashmask(hashtable->order);
     bucket = &hashtable->buckets[index];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
@@ -167,14 +152,14 @@ static int hashtable_do_rehash(hashtable_t *hashtable)
 
     jsonp_free(hashtable->buckets);
 
-    hashtable->num_buckets++;
-    new_size = num_buckets(hashtable);
+    hashtable->order++;
+    new_size = hashsize(hashtable->order);
 
     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));
     if(!hashtable->buckets)
         return -1;
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -199,14 +184,14 @@ int hashtable_init(hashtable_t *hashtable)
     size_t i;
 
     hashtable->size = 0;
-    hashtable->num_buckets = 0;  /* index to primes[] */
-    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));
+    hashtable->order = 3;
+    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));
     if(!hashtable->buckets)
         return -1;
 
     list_init(&hashtable->list);
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -230,12 +215,12 @@ int hashtable_set(hashtable_t *hashtable,
     size_t hash, index;
 
     /* rehash if the load ratio exceeds 1 */
-    if(hashtable->size >= num_buckets(hashtable))
+    if(hashtable->size >= hashsize(hashtable->order))
         if(hashtable_do_rehash(hashtable))
             return -1;
 
     hash = hash_str(key);
-    index = hash % num_buckets(hashtable);
+    index = hash & hashmask(hashtable->order);
     bucket = &hashtable->buckets[index];
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
 
@@ -273,7 +258,7 @@ void *hashtable_get(hashtable_t *hashtable, const char *key)
     bucket_t *bucket;
 
     hash = hash_str(key);
-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)
@@ -294,7 +279,7 @@ void hashtable_clear(hashtable_t *hashtable)
 
     hashtable_do_clear(hashtable);
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -316,7 +301,7 @@ void *hashtable_iter_at(hashtable_t *hashtable, const char *key)
     bucket_t *bucket;
 
     hash = hash_str(key);
-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)",jansson,8f80c2d83808150724d31793e6ade92749b1faa4,b9c588de3deb4efdd7b9ec44aa79335dba11fd6b,1,"void hashtable_clear(hashtable_t *hashtable)
{
    size_t i;
 
     hashtable_do_clear(hashtable);
 
//flaw_line_below:
    for(i = 0; i < num_buckets(hashtable); i++)
//fix_flaw_line_below:
//    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
    }

    list_init(&hashtable->list);
    hashtable->size = 0;
}
"
1964,179700,,Remote,Not required,Partial,CVE-2013-6401,https://www.cvedetails.com/cve/CVE-2013-6401/,CWE-310,Low,,,,2014-03-20,5.0,"Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document.",2014-05-23,DoS ,1,https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4,8f80c2d83808150724d31793e6ade92749b1faa4,"CVE-2013-6401: Change hash function, randomize hashes

Thanks to Florian Weimer and Eric Sesterhenn for reporting, reviewing
and testing.",1,src/hashtable.c,"{""sha"": ""1043c9ae4c0bc0c1f6a5913783973383832ff14b"", ""filename"": ""CMakeLists.txt"", ""status"": ""modified"", ""additions"": 39, ""deletions"": 10, ""changes"": 49, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/CMakeLists.txt"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/CMakeLists.txt"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/CMakeLists.txt?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -52,6 +52,8 @@ project (jansson C)\n \n # Options\n OPTION (BUILD_SHARED_LIBS \""Build shared libraries.\"" OFF)\n+OPTION (USE_URANDOM \""Use /dev/urandom to seed the hash function.\"" ON)\n+OPTION (USE_WINDOWS_CRYPTOAPI \""Use CryptGenRandom to seed the hash function.\"" ON)\n \n if (MSVC)\n    # This option must match the settings used in your program, in particular if you\n@@ -85,12 +87,12 @@ set (JANSSON_SOVERSION 4)\n # for CheckFunctionKeywords\n set(CMAKE_MODULE_PATH \""${CMAKE_CURRENT_SOURCE_DIR}/cmake\"")\n \n+INCLUDE (CheckCSourceCompiles)\n include (CheckFunctionExists)\n include (CheckFunctionKeywords)\n include (CheckIncludeFiles)\n include (CheckTypeSize)\n \n-\n if (MSVC)\n    # Turn off Microsofts \""security\"" warnings.\n    add_definitions( \""/W3 /D_CRT_SECURE_NO_WARNINGS /wd4005 /wd4996 /nologo\"" )\n@@ -106,14 +108,25 @@ if (CMAKE_COMPILER_IS_GNUCC OR CMAKE_COMPILER_IS_GNUCXX)\n    set(CMAKE_C_FLAGS \""-fPIC\"")\n endif()\n \n-   \n+check_include_files (endian.h HAVE_ENDIAN_H)\n+check_include_files (fcntl.h HAVE_FCNTL_H)\n+check_include_files (sched.h HAVE_SCHED_H)\n+check_include_files (unistd.h HAVE_UNISTD_H)\n+check_include_files (sys/param.h HAVE_SYS_PARAM_H)\n+check_include_files (sys/stat.h HAVE_SYS_STAT_H)\n+check_include_files (sys/time.h HAVE_SYS_TIME_H)\n+check_include_files (sys/time.h HAVE_SYS_TYPES_H)\n+\n+check_function_exists (close HAVE_CLOSE)\n+check_function_exists (getpid HAVE_GETPID)\n+check_function_exists (gettimeofday HAVE_GETTIMEOFDAY)\n+check_function_exists (open HAVE_OPEN)\n+check_function_exists (read HAVE_READ)\n+check_function_exists (sched_yield HAVE_SCHED_YIELD)\n \n # Check for the int-type includes\n-check_include_files (sys/types.h HAVE_SYS_TYPES_H)\n-check_include_files (inttypes.h HAVE_INTTYPES_H)\n check_include_files (stdint.h HAVE_STDINT_H)\n \n-\n # Check our 64 bit integer sizes\n check_type_size (__int64 __INT64)\n check_type_size (int64_t INT64_T)\n@@ -124,17 +137,32 @@ check_type_size (int32_t INT32_T)\n check_type_size (__int32 __INT32)\n check_type_size (\""long\"" LONG_INT)\n check_type_size (\""int\"" INT)\n-\n if (HAVE_INT32_T)\n    set (JSON_INT32 int32_t)\n elseif (HAVE___INT32)\n    set (JSON_INT32 __int32)\n-elseif (HAVE_LONG AND (${LONG_INT} EQUAL 4))\n+elseif (HAVE_LONG_INT AND (${LONG_INT} EQUAL 4))\n    set (JSON_INT32 long)\n elseif (HAVE_INT AND (${INT} EQUAL 4))\n    set (JSON_INT32 int)\n else ()\n-   message (FATAL_ERROR \""Could not detect a valid 32 bit integer type\"")\n+   message (FATAL_ERROR \""Could not detect a valid 32-bit integer type\"")\n+endif ()\n+\n+check_type_size (uint32_t UINT32_T)\n+check_type_size (__uint32 __UINT32)\n+check_type_size (\""unsigned long\"" UNSIGNED_LONG_INT)\n+check_type_size (\""unsigned int\"" UNSIGNED_INT)\n+if (HAVE_UINT32_T)\n+   set (JSON_UINT32 uint32_t)\n+elseif (HAVE___UINT32)\n+   set (JSON_UINT32 __uint32)\n+elseif (HAVE_UNSIGNED_LONG_INT AND (${UNSIGNED_LONG_INT} EQUAL 4))\n+   set (JSON_UINT32 \""unsigned long\"")\n+elseif (HAVE_UNSIGNED_INT AND (${UNSIGNED_INT} EQUAL 4))\n+   set (JSON_UINT32 \""unsigned int\"")\n+else ()\n+   message (FATAL_ERROR \""Could not detect a valid unsigned 32-bit integer type\"")\n endif ()\n \n # Check for ssize_t and SSIZE_T existance.\n@@ -206,11 +234,9 @@ else ()\n    set (JSON_HAVE_LOCALECONV 0)\n endif ()\n \n-\n # check if we have setlocale\n check_function_exists (setlocale HAVE_SETLOCALE)\n \n-\n # Check what the inline keyword is.\n # Note that the original JSON_INLINE was always set to just 'inline', so this goes further.\n check_function_keywords(\""inline\"")\n@@ -238,6 +264,9 @@ elseif (HAVE__SNPRINTF)\n    set (JSON_SNPRINTF _snprintf)\n endif ()\n \n+check_c_source_compiles (\""int main() { unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1); return 0; } \"" HAVE_SYNC_BUILTINS)\n+check_c_source_compiles (\""int main() { char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE); return 0; }\"" HAVE_ATOMIC_BUILTINS)\n+\n # Create pkg-conf file.\n # (We use the same files as ./configure does, so we\n #  have to defined the same variables used there).""}<_**next**_>{""sha"": ""b27b9a3a849e94686aa648c1ec4d1bd4c8e35445"", ""filename"": ""cmake/config.h.cmake"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 21, ""changes"": 46, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/cmake/config.h.cmake"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/cmake/config.h.cmake"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/cmake/config.h.cmake?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,35 +1,36 @@\n-/* Reduced down to the defines that are actually used in the code */\n-\n-/* Define to 1 if you have the <inttypes.h> (and friends) header file. */\n-#cmakedefine HAVE_INTTYPES_H 1\n-#cmakedefine HAVE_STDINT_H 1\n+#cmakedefine HAVE_ENDIAN_H 1\n+#cmakedefine HAVE_FCNTL_H 1\n+#cmakedefine HAVE_SCHED_H 1\n+#cmakedefine HAVE_UNISTD_H 1\n+#cmakedefine HAVE_SYS_PARAM_H 1\n+#cmakedefine HAVE_SYS_STAT_H 1\n+#cmakedefine HAVE_SYS_TIME_H 1\n #cmakedefine HAVE_SYS_TYPES_H 1\n+#cmakedefine HAVE_STDINT_H 1\n \n-/* We must include this here, as in (eg) utf.h it will want to use\n-   the integer type, which in MSVC2010 will be in stdint.h\n-   (there is no inttypes.h in MSVC2010) */\n-#if defined(HAVE_STDINT_H)\n-#  include <stdint.h>\n-#elif defined(HAVE_INTTYPES_H)\n-#  include <inttypes.h>\n-#elif defined(HAVE_SYS_TYPES_H)\n-#  include <sys/types.h>\n-#endif\n+#cmakedefine HAVE_CLOSE 1\n+#cmakedefine HAVE_GETPID 1\n+#cmakedefine HAVE_GETTIMEOFDAY 1\n+#cmakedefine HAVE_OPEN 1\n+#cmakedefine HAVE_READ 1\n+#cmakedefine HAVE_SCHED_YIELD 1\n \n-/* Define to 1 if you have the <locale.h> header file. */\n-#cmakedefine HAVE_LOCALE_H 1\n+#cmakedefine HAVE_SYNC_BUILTINS 1\n+#cmakedefine HAVE_ATOMIC_BUILTINS 1\n \n-/* Define to 1 if you have the 'setlocale' function. */\n+#cmakedefine HAVE_LOCALE_H 1\n #cmakedefine HAVE_SETLOCALE 1\n \n-/* Define to the type of a signed integer type of width exactly 32 bits if\n-   such a type exists and the standard includes do not define it. */\n #cmakedefine HAVE_INT32_T 1\n-\n #ifndef HAVE_INT32_T\n #  define int32_t @JSON_INT32@\n #endif\n \n+#cmakedefine HAVE_UINT32_T 1\n+#ifndef HAVE_UINT32_T\n+#  define uint32_t @JSON_UINT32@\n+#endif\n+\n #cmakedefine HAVE_SSIZE_T 1\n \n #ifndef HAVE_SSIZE_T\n@@ -43,3 +44,6 @@\n #endif\n \n #cmakedefine HAVE_VSNPRINTF\n+\n+#cmakedefine USE_URANDOM 1\n+#cmakedefine USE_WINDOWS_CRYPTOAPI 1""}<_**next**_>{""sha"": ""113cb85e17a15f2fac83b528fe1880bc99481ccb"", ""filename"": ""configure.ac"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 2, ""changes"": 50, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/configure.ac"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/configure.ac"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/configure.ac?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -14,10 +14,11 @@ AM_CONDITIONAL([GCC], [test x$GCC = xyes])\n # Checks for libraries.\n \n # Checks for header files.\n-AC_CHECK_HEADERS([locale.h])\n+AC_CHECK_HEADERS([endian.h fcntl.h locale.h sched.h unistd.h sys/param.h sys/stat.h sys/time.h sys/types.h])\n \n # Checks for typedefs, structures, and compiler characteristics.\n AC_TYPE_INT32_T\n+AC_TYPE_UINT32_T\n AC_TYPE_LONG_LONG_INT\n \n AC_C_INLINE\n@@ -29,7 +30,31 @@ esac\n AC_SUBST([json_inline])\n \n # Checks for library functions.\n-AC_CHECK_FUNCS([strtoll localeconv])\n+AC_CHECK_FUNCS([close getpid gettimeofday localeconv open read sched_yield strtoll])\n+\n+AC_MSG_CHECKING([for gcc __sync builtins])\n+have_sync_builtins=no\n+AC_TRY_LINK(\n+  [], [unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1);],\n+  [have_sync_builtins=yes],\n+)\n+if test \""x$have_sync_builtins\"" = \""xyes\""; then\n+  AC_DEFINE([HAVE_SYNC_BUILTINS], [1],\n+    [Define to 1 if gcc's __sync builtins are available])\n+fi\n+AC_MSG_RESULT([$have_sync_builtins])\n+\n+AC_MSG_CHECKING([for gcc __atomic builtins])\n+have_atomic_builtins=no\n+AC_TRY_LINK(\n+  [], [char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE);],\n+  [have_atomic_builtins=yes],\n+)\n+if test \""x$have_atomic_builtins\"" = \""xyes\""; then\n+  AC_DEFINE([HAVE_ATOMIC_BUILTINS], [1],\n+    [Define to 1 if gcc's __atomic builtins are available])\n+fi\n+AC_MSG_RESULT([$have_atomic_builtins])\n \n case \""$ac_cv_type_long_long_int$ac_cv_func_strtoll\"" in\n      yesyes) json_have_long_long=1;;\n@@ -43,6 +68,27 @@ case \""$ac_cv_header_locale_h$ac_cv_func_localeconv\"" in\n esac\n AC_SUBST([json_have_localeconv])\n \n+# Features\n+AC_ARG_ENABLE([urandom],\n+  [AS_HELP_STRING([--disable-urandom],\n+    [Don't use /dev/urandom to seed the hash function])],\n+  [use_urandom=$enableval], [use_urandom=yes])\n+\n+if test \""x$use_urandom\"" = xyes; then\n+AC_DEFINE([USE_URANDOM], [1],\n+  [Define to 1 if /dev/urandom should be used for seeding the hash function])\n+fi\n+\n+AC_ARG_ENABLE([windows-cryptoapi],\n+  [AS_HELP_STRING([--disable-windows-cryptoapi],\n+    [Don't use CryptGenRandom to seed the hash function])],\n+  [use_windows_cryptoapi=$enableval], [use_windows_cryptoapi=yes])\n+\n+if test \""x$use_windows_cryptoapi\"" = xyes; then\n+AC_DEFINE([USE_WINDOWS_CRYPTOAPI], [1],\n+  [Define to 1 if CryptGenRandom should be used for seeding the hash function])\n+fi\n+\n AC_CONFIG_FILES([\n         jansson.pc\n         Makefile""}<_**next**_>{""sha"": ""b4af562e84b5ed9dba1107af7d1768dcdb0b9a95"", ""filename"": ""src/Makefile.am"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/Makefile.am"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/Makefile.am?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -8,6 +8,7 @@ libjansson_la_SOURCES = \\\n \terror.c \\\n \thashtable.c \\\n \thashtable.h \\\n+\thashtable_seed.c \\\n \tjansson_private.h \\\n \tload.c \\\n \tmemory.c \\""}<_**next**_>{""sha"": ""abd4bf11fe7a393fcf3d533b952aa8b5efa4ea30"", ""filename"": ""src/hashtable.c"", ""status"": ""modified"", ""additions"": 26, ""deletions"": 41, ""changes"": 67, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -5,8 +5,17 @@\n  * it under the terms of the MIT license. See LICENSE for details.\n  */\n \n+#if HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stdlib.h>\n #include <string.h>\n+\n+#if HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include <jansson_config.h>   /* for JSON_INLINE */\n #include \""jansson_private.h\""  /* for container_of() */\n #include \""hashtable.h\""\n@@ -15,24 +24,13 @@ typedef struct hashtable_list list_t;\n typedef struct hashtable_pair pair_t;\n typedef struct hashtable_bucket bucket_t;\n \n-#define list_to_pair(list_)  container_of(list_, pair_t, list)\n-\n-/* From http://www.cse.yorku.ca/~oz/hash.html */\n-static size_t hash_str(const void *ptr)\n-{\n-    const char *str = (const char *)ptr;\n-\n-    size_t hash = 5381;\n-    size_t c;\n+extern volatile uint32_t hashtable_seed;\n \n-    while((c = (size_t)*str))\n-    {\n-        hash = ((hash << 5) + hash) + c;\n-        str++;\n-    }\n+/* Implementation of the hash function */\n+#include \""lookup3.h\""\n \n-    return hash;\n-}\n+#define list_to_pair(list_)  container_of(list_, pair_t, list)\n+#define hash_str(key)        ((size_t)hashlittle((key), strlen(key), hashtable_seed))\n \n static JSON_INLINE void list_init(list_t *list)\n {\n@@ -74,19 +72,6 @@ static void insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket,\n     }\n }\n \n-static const size_t primes[] = {\n-    5, 13, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,\n-    49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,\n-    12582917, 25165843, 50331653, 100663319, 201326611, 402653189,\n-    805306457, 1610612741\n-};\n-\n-static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)\n-{\n-    return primes[hashtable->num_buckets];\n-}\n-\n-\n static pair_t *hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket,\n                                    const char *key, size_t hash)\n {\n@@ -120,7 +105,7 @@ static int hashtable_do_del(hashtable_t *hashtable,\n     bucket_t *bucket;\n     size_t index;\n \n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n@@ -167,14 +152,14 @@ static int hashtable_do_rehash(hashtable_t *hashtable)\n \n     jsonp_free(hashtable->buckets);\n \n-    hashtable->num_buckets++;\n-    new_size = num_buckets(hashtable);\n+    hashtable->order++;\n+    new_size = hashsize(hashtable->order);\n \n     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -199,14 +184,14 @@ int hashtable_init(hashtable_t *hashtable)\n     size_t i;\n \n     hashtable->size = 0;\n-    hashtable->num_buckets = 0;  /* index to primes[] */\n-    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));\n+    hashtable->order = 3;\n+    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n     list_init(&hashtable->list);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -230,12 +215,12 @@ int hashtable_set(hashtable_t *hashtable,\n     size_t hash, index;\n \n     /* rehash if the load ratio exceeds 1 */\n-    if(hashtable->size >= num_buckets(hashtable))\n+    if(hashtable->size >= hashsize(hashtable->order))\n         if(hashtable_do_rehash(hashtable))\n             return -1;\n \n     hash = hash_str(key);\n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n \n@@ -273,7 +258,7 @@ void *hashtable_get(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)\n@@ -294,7 +279,7 @@ void hashtable_clear(hashtable_t *hashtable)\n \n     hashtable_do_clear(hashtable);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -316,7 +301,7 @@ void *hashtable_iter_at(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)""}<_**next**_>{""sha"": ""469c6ecd869c4698f650fa81983bb3ee03d47fab"", ""filename"": ""src/hashtable.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -32,14 +32,15 @@ struct hashtable_bucket {\n typedef struct hashtable {\n     size_t size;\n     struct hashtable_bucket *buckets;\n-    size_t num_buckets;  /* index to primes[] */\n+    size_t order;  /* hashtable has pow(2, order) buckets */\n     struct hashtable_list list;\n } hashtable_t;\n \n \n #define hashtable_key_to_iter(key_) \\\n     (&(container_of(key_, struct hashtable_pair, key)->list))\n \n+\n /**\n  * hashtable_init - Initialize a hashtable object\n  *""}<_**next**_>{""sha"": ""a07d145d10df35b933c1441dcbf42d3316b78ca5"", ""filename"": ""src/hashtable_seed.c"", ""status"": ""added"", ""additions"": 278, ""deletions"": 0, ""changes"": 278, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable_seed.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable_seed.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable_seed.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,278 @@\n+/* Generate sizeof(uint32_t) bytes of as random data as possible to seed\n+   the hash function.\n+*/\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#include <stdio.h>\n+#include <time.h>\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n+#ifdef HAVE_FCNTL_H\n+#include <fcntl.h>\n+#endif\n+\n+#ifdef HAVE_SCHED_H\n+#include <sched.h>\n+#endif\n+\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+\n+#ifdef HAVE_SYS_STAT_H\n+#include <sys/stat.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TIME_H\n+#include <sys/time.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TYPES_H\n+#include <sys/types.h>\n+#endif\n+\n+#if defined(_WIN32)\n+/* For _getpid() */\n+#include <process.h>\n+#endif\n+\n+#include \""jansson.h\""\n+\n+\n+static uint32_t buf_to_uint32(char *data) {\n+    size_t i;\n+    uint32_t result = 0;\n+\n+    for (i = 0; i < sizeof(uint32_t); i++)\n+        result = (result << 8) | (unsigned char)data[i];\n+\n+    return result;\n+}\n+\n+\n+\n+/* /dev/urandom */\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+static int seed_from_urandom(uint32_t *seed) {\n+    /* Use unbuffered I/O if we have open(), close() and read(). Otherwise\n+       fall back to fopen() */\n+\n+    char data[sizeof(uint32_t)];\n+    int ok;\n+\n+#if defined(HAVE_OPEN) && defined(HAVE_CLOSE) && defined(HAVE_READ)\n+    int urandom;\n+    urandom = open(\""/dev/urandom\"", O_RDONLY);\n+    if (urandom == -1)\n+        return 1;\n+\n+    ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);\n+    close(urandom);\n+#else\n+    FILE *urandom;\n+\n+    urandom = fopen(\""/dev/urandom\"", \""rb\"");\n+    if (!urandom)\n+        return 1;\n+\n+    ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);\n+    fclose(urandom);\n+#endif\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32(data);\n+    return 0;\n+}\n+#endif\n+\n+/* Windows Crypto API */\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+#include <windows.h>\n+#include <wincrypt.h>\n+\n+typedef BOOL (WINAPI *CRYPTACQUIRECONTEXTA)(HCRYPTPROV *phProv, LPCSTR pszContainer, LPCSTR pszProvider, DWORD dwProvType, DWORD dwFlags);\n+typedef BOOL (WINAPI *CRYPTGENRANDOM)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);\n+typedef BOOL (WINAPI *CRYPTRELEASECONTEXT)(HCRYPTPROV hProv, DWORD dwFlags);\n+\n+static int seed_from_windows_cryptoapi(uint32_t *seed)\n+{\n+    HINSTANCE hAdvAPI32 = NULL;\n+    CRYPTACQUIRECONTEXTA pCryptAcquireContext = NULL;\n+    CRYPTGENRANDOM pCryptGenRandom = NULL;\n+    CRYPTRELEASECONTEXT pCryptReleaseContext = NULL;\n+    HCRYPTPROV hCryptProv = 0;\n+    BYTE data[sizeof(uint32_t)];\n+    int ok;\n+\n+    hAdvAPI32 = GetModuleHandle(\""advapi32.dll\"");\n+    if(hAdvAPI32 == NULL)\n+        return 1;\n+\n+    pCryptAcquireContext = (CRYPTACQUIRECONTEXTA)GetProcAddress(hAdvAPI32, \""CryptAcquireContextA\"");\n+    if (!pCryptAcquireContext)\n+        return 1;\n+\n+    pCryptGenRandom = (CRYPTGENRANDOM)GetProcAddress(hAdvAPI32, \""CryptGenRandom\"");\n+    if (!pCryptGenRandom)\n+        return 1;\n+\n+    pCryptReleaseContext = (CRYPTRELEASECONTEXT)GetProcAddress(hAdvAPI32, \""CryptReleaseContext\"");\n+    if (!pCryptReleaseContext)\n+        return 1;\n+\n+    if (!pCryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))\n+        return 1;\n+\n+    ok = CryptGenRandom(hCryptProv, sizeof(uint32_t), data);\n+    pCryptReleaseContext(hCryptProv, 0);\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32((char *)data);\n+    return 0;\n+}\n+#endif\n+\n+/* gettimeofday() and getpid() */\n+static int seed_from_timestamp_and_pid(uint32_t *seed) {\n+#ifdef HAVE_GETTIMEOFDAY\n+    /* XOR of seconds and microseconds */\n+    struct timeval tv;\n+    gettimeofday(&tv, NULL);\n+    *seed = (uint32_t)tv.tv_sec ^ (uint32_t)tv.tv_usec;\n+#else\n+    /* Seconds only */\n+    *seed = (uint32_t)time(NULL);\n+#endif\n+\n+    /* XOR with PID for more randomness */\n+#if defined(_WIN32)\n+    *seed ^= (uint32_t)_getpid();\n+#elif defined(HAVE_GETPID)\n+    *seed ^= (uint32_t)getpid();\n+#endif\n+\n+    return 0;\n+}\n+\n+static uint32_t generate_seed() {\n+    uint32_t seed;\n+    int done = 0;\n+\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+    if (!done && seed_from_urandom(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+    if (!done && seed_from_windows_cryptoapi(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+    if (!done) {\n+        /* Fall back to timestamp and PID if no better randomness is\n+           available */\n+        seed_from_timestamp_and_pid(&seed);\n+    }\n+\n+    /* Make sure the seed is never zero */\n+    if (seed == 0)\n+        seed = 1;\n+\n+    return seed;\n+}\n+\n+\n+volatile uint32_t hashtable_seed = 0;\n+\n+#if defined(HAVE_ATOMIC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+static volatile char seed_initialized = 0;\n+\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (__atomic_test_and_set(&seed_initialized, __ATOMIC_RELAXED) == 0) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            __atomic_store_n(&hashtable_seed, new_seed, __ATOMIC_ACQ_REL);\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            } while(__atomic_load_n(&hashtable_seed, __ATOMIC_ACQUIRE) == 0);\n+        }\n+    }\n+}\n+#elif defined(HAVE_SYNC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0) {\n+            /* Explicit synchronization fences are not supported by the\n+               __sync builtins, so every thread getting here has to\n+               generate the seed value.\n+            */\n+            new_seed = generate_seed();\n+        }\n+\n+        do {\n+            if (__sync_bool_compare_and_swap(&hashtable_seed, 0, new_seed)) {\n+                /* We were the first to seed */\n+                break;\n+            } else {\n+                /* Wait for another thread to do the seeding */\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            }\n+        } while(hashtable_seed == 0);\n+    }\n+}\n+#elif defined(_WIN32)\n+static long seed_initialized = 0;\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (InterlockedIncrement(&seed_initialized) == 1) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            hashtable_seed = new_seed;\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+                SwitchToThread();\n+            } while (hashtable_seed == 0);\n+        }\n+    }\n+}\n+#else\n+/* Fall back to a thread-unsafe version */\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0)\n+            new_seed = generate_seed();\n+\n+        hashtable_seed = new_seed;\n+    }\n+}\n+#endif""}<_**next**_>{""sha"": ""19096d4201e6b13f8c56765116865c71f67e9696"", ""filename"": ""src/jansson.def"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.def"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.def"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/jansson.def?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -41,6 +41,7 @@ EXPORTS\n     json_object_iter_value\n     json_object_iter_set_new\n     json_object_key_to_iter\n+    json_object_seed\n     json_dumps\n     json_dumpf\n     json_dump_file""}<_**next**_>{""sha"": ""ea230852a629e55457fba2d00e3edd8a4ad4fcec"", ""filename"": ""src/jansson.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/jansson.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -126,6 +126,7 @@ typedef struct {\n \n /* getters, setters, manipulation */\n \n+void json_object_seed(size_t seed);\n size_t json_object_size(const json_t *object);\n json_t *json_object_get(const json_t *object, const char *key);\n int json_object_set_new(json_t *object, const char *key, json_t *value);""}<_**next**_>{""sha"": ""dc76138c940516e9590784825d28d040fd1a8b25"", ""filename"": ""src/lookup3.h"", ""status"": ""added"", ""additions"": 366, ""deletions"": 0, ""changes"": 366, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/lookup3.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/lookup3.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/lookup3.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,366 @@\n+/*\n+-------------------------------------------------------------------------------\n+lookup3.c, by Bob Jenkins, May 2006, Public Domain.\n+\n+These are functions for producing 32-bit hashes for hash table lookup.\n+hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final() \n+are externally useful functions.  Routines to test the hash are included \n+if SELF_TEST is defined.  You can use this free for any purpose.  It's in\n+the public domain.  It has no warranty.\n+\n+You probably want to use hashlittle().  hashlittle() and hashbig()\n+hash byte arrays.  hashlittle() is is faster than hashbig() on\n+little-endian machines.  Intel and AMD are little-endian machines.\n+On second thought, you probably want hashlittle2(), which is identical to\n+hashlittle() except it returns two 32-bit hashes for the price of one.  \n+You could implement hashbig2() if you wanted but I haven't bothered here.\n+\n+If you want to find a hash of, say, exactly 7 integers, do\n+  a = i1;  b = i2;  c = i3;\n+  mix(a,b,c);\n+  a += i4; b += i5; c += i6;\n+  mix(a,b,c);\n+  a += i7;\n+  final(a,b,c);\n+then use c as the hash value.  If you have a variable length array of\n+4-byte integers to hash, use hashword().  If you have a byte array (like\n+a character string), use hashlittle().  If you have several byte arrays, or\n+a mix of things, see the comments above hashlittle().  \n+\n+Why is this so big?  I read 12 bytes at a time into 3 4-byte integers, \n+then mix those integers.  This is fast (you can do a lot more thorough\n+mixing with 12*3 instructions on 3 integers than you can with 3 instructions\n+on 1 byte), but shoehorning those bytes into integers efficiently is messy.\n+-------------------------------------------------------------------------------\n+*/\n+\n+#include <stdlib.h>\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>     /* defines uint32_t etc */\n+#endif\n+\n+#ifdef HAVE_SYS_PARAM_H\n+#include <sys/param.h>  /* attempt to define endianness */\n+#endif\n+\n+#ifdef HAVE_ENDIAN_H\n+# include <endian.h>    /* attempt to define endianness */\n+#endif\n+\n+/*\n+ * My best guess at if you are big-endian or little-endian.  This may\n+ * need adjustment.\n+ */\n+#if (defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && \\\n+     __BYTE_ORDER == __LITTLE_ENDIAN) || \\\n+    (defined(i386) || defined(__i386__) || defined(__i486__) || \\\n+     defined(__i586__) || defined(__i686__) || defined(vax) || defined(MIPSEL))\n+# define HASH_LITTLE_ENDIAN 1\n+# define HASH_BIG_ENDIAN 0\n+#elif (defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && \\\n+       __BYTE_ORDER == __BIG_ENDIAN) || \\\n+      (defined(sparc) || defined(POWERPC) || defined(mc68000) || defined(sel))\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 1\n+#else\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 0\n+#endif\n+\n+#define hashsize(n) ((uint32_t)1<<(n))\n+#define hashmask(n) (hashsize(n)-1)\n+#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n+\n+/*\n+-------------------------------------------------------------------------------\n+mix -- mix 3 32-bit values reversibly.\n+\n+This is reversible, so any information in (a,b,c) before mix() is\n+still in (a,b,c) after mix().\n+\n+If four pairs of (a,b,c) inputs are run through mix(), or through\n+mix() in reverse, there are at least 32 bits of the output that\n+are sometimes the same for one pair and different for another pair.\n+This was tested for:\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+Some k values for my \""a-=c; a^=rot(c,k); c+=b;\"" arrangement that\n+satisfy this are\n+    4  6  8 16 19  4\n+    9 15  3 18 27 15\n+   14  9  3  7 17  3\n+Well, \""9 15 3 18 27 15\"" didn't quite get 32 bits diffing\n+for \""differ\"" defined as + with a one-bit base and a two-bit delta.  I\n+used http://burtleburtle.net/bob/hash/avalanche.html to choose \n+the operations, constants, and arrangements of the variables.\n+\n+This does not achieve avalanche.  There are input bits of (a,b,c)\n+that fail to affect some output bits of (a,b,c), especially of a.  The\n+most thoroughly mixed value is c, but it doesn't really even achieve\n+avalanche in c.\n+\n+This allows some parallelism.  Read-after-writes are good at doubling\n+the number of bits affected, so the goal of mixing pulls in the opposite\n+direction as the goal of parallelism.  I did what I could.  Rotates\n+seem to cost as much as shifts on every machine I could lay my hands\n+on, and rotates are much kinder to the top and bottom bits, so I used\n+rotates.\n+-------------------------------------------------------------------------------\n+*/\n+#define mix(a,b,c) \\\n+{ \\\n+  a -= c;  a ^= rot(c, 4);  c += b; \\\n+  b -= a;  b ^= rot(a, 6);  a += c; \\\n+  c -= b;  c ^= rot(b, 8);  b += a; \\\n+  a -= c;  a ^= rot(c,16);  c += b; \\\n+  b -= a;  b ^= rot(a,19);  a += c; \\\n+  c -= b;  c ^= rot(b, 4);  b += a; \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+final -- final mixing of 3 32-bit values (a,b,c) into c\n+\n+Pairs of (a,b,c) values differing in only a few bits will usually\n+produce values of c that look totally different.  This was tested for\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+These constants passed:\n+ 14 11 25 16 4 14 24\n+ 12 14 25 16 4 14 24\n+and these came close:\n+  4  8 15 26 3 22 24\n+ 10  8 15 26 3 22 24\n+ 11  8 15 26 3 22 24\n+-------------------------------------------------------------------------------\n+*/\n+#define final(a,b,c) \\\n+{ \\\n+  c ^= b; c -= rot(b,14); \\\n+  a ^= c; a -= rot(c,11); \\\n+  b ^= a; b -= rot(a,25); \\\n+  c ^= b; c -= rot(b,16); \\\n+  a ^= c; a -= rot(c,4);  \\\n+  b ^= a; b -= rot(a,14); \\\n+  c ^= b; c -= rot(b,24); \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+hashlittle() -- hash a variable-length key into a 32-bit value\n+  k       : the key (the unaligned variable-length array of bytes)\n+  length  : the length of the key, counting by bytes\n+  initval : can be any 4-byte value\n+Returns a 32-bit value.  Every bit of the key affects every bit of\n+the return value.  Two keys differing by one or two bits will have\n+totally different hash values.\n+\n+The best hash table sizes are powers of 2.  There is no need to do\n+mod a prime (mod is sooo slow!).  If you need less than 32 bits,\n+use a bitmask.  For example, if you need only 10 bits, do\n+  h = (h & hashmask(10));\n+In which case, the hash table should have hashsize(10) elements.\n+\n+If you are hashing n strings (uint8_t **)k, do it like this:\n+  for (i=0, h=0; i<n; ++i) h = hashlittle( k[i], len[i], h);\n+\n+By Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this\n+code any way you wish, private, educational, or commercial.  It's free.\n+\n+Use for hash table lookup, or anything where one collision in 2^^32 is\n+acceptable.  Do NOT use for cryptographic purposes.\n+-------------------------------------------------------------------------------\n+*/\n+\n+static uint32_t hashlittle(const void *key, size_t length, uint32_t initval)\n+{\n+  uint32_t a,b,c;                                          /* internal state */\n+  union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */\n+\n+  /* Set up the internal state */\n+  a = b = c = 0xdeadbeef + ((uint32_t)length) + initval;\n+\n+  u.ptr = key;\n+  if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0)) {\n+    const uint32_t *k = (const uint32_t *)key;         /* read 32-bit chunks */\n+\n+#ifdef VALGRIND\n+    const uint8_t  *k8;\n+#endif\n+\n+    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      b += k[1];\n+      c += k[2];\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 3;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    /* \n+     * \""k[2]&0xffffff\"" actually reads beyond the end of the string, but\n+     * then masks off the part it's not allowed to read.  Because the\n+     * string is aligned, the masked-off tail is in the same word as the\n+     * rest of the string.  Every machine with memory protection I've seen\n+     * does it on word boundaries, so is OK with this.  But VALGRIND will\n+     * still catch it and complain.  The masking trick does make the hash\n+     * noticably faster for short strings (like English words).\n+     */\n+#ifndef VALGRIND\n+\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n+    case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n+    case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n+    case 6 : b+=k[1]&0xffff; a+=k[0]; break;\n+    case 5 : b+=k[1]&0xff; a+=k[0]; break;\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=k[0]&0xffffff; break;\n+    case 2 : a+=k[0]&0xffff; break;\n+    case 1 : a+=k[0]&0xff; break;\n+    case 0 : return c;              /* zero length strings require no mixing */\n+    }\n+\n+#else /* make valgrind happy */\n+\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=((uint32_t)k8[10])<<16;  /* fall through */\n+    case 10: c+=((uint32_t)k8[9])<<8;    /* fall through */\n+    case 9 : c+=k8[8];                   /* fall through */\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;   /* fall through */\n+    case 6 : b+=((uint32_t)k8[5])<<8;    /* fall through */\n+    case 5 : b+=k8[4];                   /* fall through */\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;   /* fall through */\n+    case 2 : a+=((uint32_t)k8[1])<<8;    /* fall through */\n+    case 1 : a+=k8[0]; break;\n+    case 0 : return c;\n+    }\n+\n+#endif /* !valgrind */\n+\n+  } else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0)) {\n+    const uint16_t *k = (const uint16_t *)key;         /* read 16-bit chunks */\n+    const uint8_t  *k8;\n+\n+    /*--------------- all but last block: aligned reads and different mixing */\n+    while (length > 12)\n+    {\n+      a += k[0] + (((uint32_t)k[1])<<16);\n+      b += k[2] + (((uint32_t)k[3])<<16);\n+      c += k[4] + (((uint32_t)k[5])<<16);\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 6;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[4]+(((uint32_t)k[5])<<16);\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 11: c+=((uint32_t)k8[10])<<16;     /* fall through */\n+    case 10: c+=k[4];\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 9 : c+=k8[8];                      /* fall through */\n+    case 8 : b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;      /* fall through */\n+    case 6 : b+=k[2];\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 5 : b+=k8[4];                      /* fall through */\n+    case 4 : a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;      /* fall through */\n+    case 2 : a+=k[0];\n+             break;\n+    case 1 : a+=k8[0];\n+             break;\n+    case 0 : return c;                     /* zero length requires no mixing */\n+    }\n+\n+  } else {                        /* need to read the key one byte at a time */\n+    const uint8_t *k = (const uint8_t *)key;\n+\n+    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      a += ((uint32_t)k[1])<<8;\n+      a += ((uint32_t)k[2])<<16;\n+      a += ((uint32_t)k[3])<<24;\n+      b += k[4];\n+      b += ((uint32_t)k[5])<<8;\n+      b += ((uint32_t)k[6])<<16;\n+      b += ((uint32_t)k[7])<<24;\n+      c += k[8];\n+      c += ((uint32_t)k[9])<<8;\n+      c += ((uint32_t)k[10])<<16;\n+      c += ((uint32_t)k[11])<<24;\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 12;\n+    }\n+\n+    /*-------------------------------- last block: affect all 32 bits of (c) */\n+    switch(length)                   /* all the case statements fall through */\n+    {\n+    case 12: c+=((uint32_t)k[11])<<24;\n+    case 11: c+=((uint32_t)k[10])<<16;\n+    case 10: c+=((uint32_t)k[9])<<8;\n+    case 9 : c+=k[8];\n+    case 8 : b+=((uint32_t)k[7])<<24;\n+    case 7 : b+=((uint32_t)k[6])<<16;\n+    case 6 : b+=((uint32_t)k[5])<<8;\n+    case 5 : b+=k[4];\n+    case 4 : a+=((uint32_t)k[3])<<24;\n+    case 3 : a+=((uint32_t)k[2])<<16;\n+    case 2 : a+=((uint32_t)k[1])<<8;\n+    case 1 : a+=k[0];\n+             break;\n+    case 0 : return c;\n+    }\n+  }\n+\n+  final(a,b,c);\n+  return c;\n+}""}<_**next**_>{""sha"": ""b4f109143031b2481a0d32a332c88cc1cc96c688"", ""filename"": ""src/utf.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 16, ""changes"": 20, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/utf.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/utf.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/utf.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -10,23 +10,11 @@\n \n #ifdef HAVE_CONFIG_H\n #include <config.h>\n+#endif\n \n-#ifdef HAVE_INTTYPES_H\n-/* inttypes.h includes stdint.h in a standard environment, so there's\n-no need to include stdint.h separately. If inttypes.h doesn't define\n-int32_t, it's defined in config.h. */\n-#include <inttypes.h>\n-#endif /* HAVE_INTTYPES_H */\n-\n-#else /* !HAVE_CONFIG_H */\n-#ifdef _WIN32\n-typedef int int32_t;\n-#else /* !_WIN32 */\n-/* Assume a standard environment */\n-#include <inttypes.h>\n-#endif /* _WIN32 */\n-\n-#endif /* HAVE_CONFIG_H */\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n \n int utf8_encode(int codepoint, char *buffer, int *size);\n ""}<_**next**_>{""sha"": ""1b02d90aa885f1ede146bb2077d05c8bb9096565"", ""filename"": ""src/value.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/value.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/value.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/value.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -9,11 +9,19 @@\n #define _GNU_SOURCE\n #endif\n \n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stddef.h>\n #include <stdlib.h>\n #include <string.h>\n #include <math.h>\n \n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include \""jansson.h\""\n #include \""hashtable.h\""\n #include \""jansson_private.h\""\n@@ -36,11 +44,19 @@ static JSON_INLINE void json_init(json_t *json, json_type type)\n \n /*** object ***/\n \n+extern volatile uint32_t hashtable_seed;\n+\n json_t *json_object(void)\n {\n     json_object_t *object = jsonp_malloc(sizeof(json_object_t));\n     if(!object)\n         return NULL;\n+\n+    if (!hashtable_seed) {\n+        /* Autoseed */\n+        json_object_seed(0);\n+    }\n+\n     json_init(&object->json, JSON_OBJECT);\n \n     if(hashtable_init(&object->hashtable))""}<_**next**_>{""sha"": ""e2c54bd12bd7c22de7cc3533f010b26cc1c330b0"", ""filename"": ""test/bin/json_process.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 1, ""changes"": 16, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/bin/json_process.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/bin/json_process.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/bin/json_process.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -37,6 +37,8 @@ struct config {\n     int sort_keys;\n     int strip;\n     int use_env;\n+    int have_hashseed;\n+    int hashseed;\n } conf;\n \n #define l_isspace(c) ((c) == ' ' || (c) == '\\n' || (c) == '\\r' || (c) == '\\t')\n@@ -108,6 +110,12 @@ static void read_conf(FILE *conffile)\n             conf.sort_keys = atoi(val);\n         if (!strcmp(line, \""STRIP\""))\n             conf.strip = atoi(val);\n+        if (!strcmp(line, \""HASHSEED\"")) {\n+            conf.have_hashseed = 1;\n+            conf.hashseed = atoi(val);\n+        } else {\n+            conf.have_hashseed = 0;\n+        }\n     }\n \n     free(buffer);\n@@ -188,6 +196,9 @@ int use_conf(char *test_path)\n     if (conf.sort_keys)\n         flags |= JSON_SORT_KEYS;\n \n+    if (conf.have_hashseed)\n+        json_object_seed(conf.hashseed);\n+\n     if (conf.strip) {\n         /* Load to memory, strip leading and trailing whitespace */\n         buffer = loadfile(infile);\n@@ -265,7 +276,10 @@ int use_env()\n         flags |= JSON_PRESERVE_ORDER;\n \n     if(getenv_int(\""JSON_SORT_KEYS\""))\n-         flags |= JSON_SORT_KEYS;\n+        flags |= JSON_SORT_KEYS;\n+\n+    if(getenv(\""HASHSEED\""))\n+        json_object_seed(getenv_int(\""HASHSEED\""));\n \n     if(getenv_int(\""STRIP\"")) {\n         /* Load to memory, strip leading and trailing whitespace */""}<_**next**_>{""sha"": ""84b17466fd0a753b8cbd714d0236ed9072cdd536"", ""filename"": ""test/suites/api/test_memory_funcs.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_memory_funcs.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_memory_funcs.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/api/test_memory_funcs.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -24,13 +24,13 @@ static void create_and_free_complex_object()\n \n static void *my_malloc(size_t size)\n {\n-    malloc_called += 1;\n+    malloc_called = 1;\n     return malloc(size);\n }\n \n static void my_free(void *ptr)\n {\n-    free_called += 1;\n+    free_called = 1;\n     free(ptr);\n }\n \n@@ -39,7 +39,7 @@ static void test_simple()\n     json_set_alloc_funcs(my_malloc, my_free);\n     create_and_free_complex_object();\n \n-    if(malloc_called != 20 || free_called != 20)\n+    if(malloc_called != 1 || free_called != 1)\n         fail(\""Custom allocation failed\"");\n }\n ""}<_**next**_>{""sha"": ""92e5208224b75ab45d93672446279d598052a83e"", ""filename"": ""test/suites/api/test_object.c"", ""status"": ""modified"", ""additions"": 40, ""deletions"": 24, ""changes"": 64, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_object.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_object.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/api/test_object.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -249,7 +249,11 @@ static void test_set_nocheck()\n \n static void test_iterators()\n {\n+    int i;\n     json_t *object, *foo, *bar, *baz;\n+    const char *iter_keys[3];\n+    int have_key[3] = { 0, 0, 0 };\n+    json_t *iter_values[3];\n     void *iter;\n \n     if(json_object_iter(NULL))\n@@ -276,30 +280,50 @@ static void test_iterators()\n     iter = json_object_iter(object);\n     if(!iter)\n         fail(\""unable to get iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""a\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != foo)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[0] = json_object_iter_key(iter);\n+    iter_values[0] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""b\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != bar)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[1] = json_object_iter_key(iter);\n+    iter_values[1] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[2] = json_object_iter_key(iter);\n+    iter_values[2] = json_object_iter_value(iter);\n \n     if(json_object_iter_next(object, iter) != NULL)\n         fail(\""able to iterate over the end\"");\n \n+    /* Check that keys have correct values */\n+    for (i = 0; i < 3; i++) {\n+        if (strcmp(iter_keys[i], \""a\"") == 0) {\n+            if (iter_values[i] != foo)\n+                fail(\""wrong value for iter key a\"");\n+            else\n+                have_key[0] = 1;\n+        } else if (strcmp(iter_keys[i], \""b\"") == 0) {\n+            if (iter_values[i] != bar)\n+                fail(\""wrong value for iter key b\"");\n+            else\n+                have_key[1] = 1;\n+        } else if (strcmp(iter_keys[i], \""c\"") == 0) {\n+            if (iter_values[i] != baz)\n+                fail(\""wrong value for iter key c\"");\n+            else\n+                have_key[2] = 1;\n+        }\n+    }\n+\n+    /* Check that we got all keys */\n+    for(i = 0; i < 3; i++) {\n+        if(!have_key[i])\n+            fail(\""a key wasn't iterated over\"");\n+    }\n+\n     if(json_object_iter_at(object, \""foo\""))\n         fail(\""json_object_iter_at() succeeds for non-existent key\"");\n \n@@ -312,22 +336,14 @@ static void test_iterators()\n     if(json_object_iter_value(iter) != bar)\n         fail(\""iterating failed: wrong value\"");\n \n-    iter = json_object_iter_next(object, iter);\n-    if(!iter)\n-        fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\""iterating failed: wrong value\"");\n-\n-    if(json_object_iter_set(object, iter, bar))\n+    if(json_object_iter_set(object, iter, baz))\n         fail(\""unable to set value at iterator\"");\n \n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n+    if(strcmp(json_object_iter_key(iter), \""b\""))\n         fail(\""json_object_iter_key() fails after json_object_iter_set()\"");\n-    if(json_object_iter_value(iter) != bar)\n+    if(json_object_iter_value(iter) != baz)\n         fail(\""json_object_iter_value() fails after json_object_iter_set()\"");\n-    if(json_object_get(object, \""c\"") != bar)\n+    if(json_object_get(object, \""b\"") != baz)\n         fail(\""json_object_get() fails after json_object_iter_set()\"");\n \n     json_decref(object);""}<_**next**_>{""sha"": ""93cb33ddafeb9eef6ce7ad4709ce1bcbdf25b200"", ""filename"": ""test/suites/encoding-flags/compact-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/compact-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/compact-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/compact-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,2 +1,3 @@\n JSON_COMPACT=1\n-export JSON_COMPACT\n+HASHSEED=1\n+export JSON_COMPACT HASHSEED""}<_**next**_>{""sha"": ""c73acc1792963be8a5f41ff11f6e858506ada51d"", ""filename"": ""test/suites/encoding-flags/indent-compact-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-compact-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-compact-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/indent-compact-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,3 +1,4 @@\n JSON_INDENT=4\n JSON_COMPACT=1\n-export JSON_INDENT JSON_COMPACT\n+HASHSEED=1\n+export JSON_INDENT JSON_COMPACT HASHSEED""}<_**next**_>{""sha"": ""961558ca23ceca2ce6e4d07697f4018d8475f317"", ""filename"": ""test/suites/encoding-flags/indent-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/indent-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,2 +1,3 @@\n JSON_INDENT=4\n-export JSON_INDENT\n+HASHSEED=1\n+export JSON_INDENT HASHSEED""}<_**next**_>{""sha"": ""9120b03514ec614695c2d17841ba228b102c9db6"", ""filename"": ""test/suites/encoding-flags/object/env"", ""status"": ""added"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,2 @@\n+HASHSEED=1\n+export HASHSEED""}","static int hashtable_do_del(hashtable_t *hashtable,
                            const char *key, size_t hash)
{
    pair_t *pair;
     bucket_t *bucket;
     size_t index;
 
    index = hash & hashmask(hashtable->order);
     bucket = &hashtable->buckets[index];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
    if(!pair)
        return -1;

    if(&pair->list == bucket->first && &pair->list == bucket->last)
        bucket->first = bucket->last = &hashtable->list;

    else if(&pair->list == bucket->first)
        bucket->first = pair->list.next;

    else if(&pair->list == bucket->last)
        bucket->last = pair->list.prev;

    list_remove(&pair->list);
    json_decref(pair->value);

    jsonp_free(pair);
    hashtable->size--;

    return 0;
}
","static int hashtable_do_del(hashtable_t *hashtable,
                            const char *key, size_t hash)
{
    pair_t *pair;
     bucket_t *bucket;
     size_t index;
 
    index = hash % num_buckets(hashtable);
     bucket = &hashtable->buckets[index];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
    if(!pair)
        return -1;

    if(&pair->list == bucket->first && &pair->list == bucket->last)
        bucket->first = bucket->last = &hashtable->list;

    else if(&pair->list == bucket->first)
        bucket->first = pair->list.next;

    else if(&pair->list == bucket->last)
        bucket->last = pair->list.prev;

    list_remove(&pair->list);
    json_decref(pair->value);

    jsonp_free(pair);
    hashtable->size--;

    return 0;
}
",C,"    index = hash & hashmask(hashtable->order);
","    index = hash % num_buckets(hashtable);
",,"@@ -5,8 +5,17 @@
  * it under the terms of the MIT license. See LICENSE for details.
  */
 
+#if HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include <stdlib.h>
 #include <string.h>
+
+#if HAVE_STDINT_H
+#include <stdint.h>
+#endif
+
 #include <jansson_config.h>   /* for JSON_INLINE */
 #include ""jansson_private.h""  /* for container_of() */
 #include ""hashtable.h""
@@ -15,24 +24,13 @@ typedef struct hashtable_list list_t;
 typedef struct hashtable_pair pair_t;
 typedef struct hashtable_bucket bucket_t;
 
-#define list_to_pair(list_)  container_of(list_, pair_t, list)
-
-/* From http://www.cse.yorku.ca/~oz/hash.html */
-static size_t hash_str(const void *ptr)
-{
-    const char *str = (const char *)ptr;
-
-    size_t hash = 5381;
-    size_t c;
+extern volatile uint32_t hashtable_seed;
 
-    while((c = (size_t)*str))
-    {
-        hash = ((hash << 5) + hash) + c;
-        str++;
-    }
+/* Implementation of the hash function */
+#include ""lookup3.h""
 
-    return hash;
-}
+#define list_to_pair(list_)  container_of(list_, pair_t, list)
+#define hash_str(key)        ((size_t)hashlittle((key), strlen(key), hashtable_seed))
 
 static JSON_INLINE void list_init(list_t *list)
 {
@@ -74,19 +72,6 @@ static void insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket,
     }
 }
 
-static const size_t primes[] = {
-    5, 13, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,
-    49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,
-    12582917, 25165843, 50331653, 100663319, 201326611, 402653189,
-    805306457, 1610612741
-};
-
-static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)
-{
-    return primes[hashtable->num_buckets];
-}
-
-
 static pair_t *hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket,
                                    const char *key, size_t hash)
 {
@@ -120,7 +105,7 @@ static int hashtable_do_del(hashtable_t *hashtable,
     bucket_t *bucket;
     size_t index;
 
-    index = hash % num_buckets(hashtable);
+    index = hash & hashmask(hashtable->order);
     bucket = &hashtable->buckets[index];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
@@ -167,14 +152,14 @@ static int hashtable_do_rehash(hashtable_t *hashtable)
 
     jsonp_free(hashtable->buckets);
 
-    hashtable->num_buckets++;
-    new_size = num_buckets(hashtable);
+    hashtable->order++;
+    new_size = hashsize(hashtable->order);
 
     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));
     if(!hashtable->buckets)
         return -1;
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -199,14 +184,14 @@ int hashtable_init(hashtable_t *hashtable)
     size_t i;
 
     hashtable->size = 0;
-    hashtable->num_buckets = 0;  /* index to primes[] */
-    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));
+    hashtable->order = 3;
+    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));
     if(!hashtable->buckets)
         return -1;
 
     list_init(&hashtable->list);
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -230,12 +215,12 @@ int hashtable_set(hashtable_t *hashtable,
     size_t hash, index;
 
     /* rehash if the load ratio exceeds 1 */
-    if(hashtable->size >= num_buckets(hashtable))
+    if(hashtable->size >= hashsize(hashtable->order))
         if(hashtable_do_rehash(hashtable))
             return -1;
 
     hash = hash_str(key);
-    index = hash % num_buckets(hashtable);
+    index = hash & hashmask(hashtable->order);
     bucket = &hashtable->buckets[index];
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
 
@@ -273,7 +258,7 @@ void *hashtable_get(hashtable_t *hashtable, const char *key)
     bucket_t *bucket;
 
     hash = hash_str(key);
-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)
@@ -294,7 +279,7 @@ void hashtable_clear(hashtable_t *hashtable)
 
     hashtable_do_clear(hashtable);
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -316,7 +301,7 @@ void *hashtable_iter_at(hashtable_t *hashtable, const char *key)
     bucket_t *bucket;
 
     hash = hash_str(key);
-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)",jansson,8f80c2d83808150724d31793e6ade92749b1faa4,b9c588de3deb4efdd7b9ec44aa79335dba11fd6b,1,"static int hashtable_do_del(hashtable_t *hashtable,
                            const char *key, size_t hash)
{
    pair_t *pair;
     bucket_t *bucket;
     size_t index;
 
//flaw_line_below:
    index = hash % num_buckets(hashtable);
//fix_flaw_line_below:
//    index = hash & hashmask(hashtable->order);
     bucket = &hashtable->buckets[index];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
    if(!pair)
        return -1;

    if(&pair->list == bucket->first && &pair->list == bucket->last)
        bucket->first = bucket->last = &hashtable->list;

    else if(&pair->list == bucket->first)
        bucket->first = pair->list.next;

    else if(&pair->list == bucket->last)
        bucket->last = pair->list.prev;

    list_remove(&pair->list);
    json_decref(pair->value);

    jsonp_free(pair);
    hashtable->size--;

    return 0;
}
"
1965,179701,,Remote,Not required,Partial,CVE-2013-6401,https://www.cvedetails.com/cve/CVE-2013-6401/,CWE-310,Low,,,,2014-03-20,5.0,"Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document.",2014-05-23,DoS ,3,https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4,8f80c2d83808150724d31793e6ade92749b1faa4,"CVE-2013-6401: Change hash function, randomize hashes

Thanks to Florian Weimer and Eric Sesterhenn for reporting, reviewing
and testing.",3,src/hashtable.c,"{""sha"": ""1043c9ae4c0bc0c1f6a5913783973383832ff14b"", ""filename"": ""CMakeLists.txt"", ""status"": ""modified"", ""additions"": 39, ""deletions"": 10, ""changes"": 49, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/CMakeLists.txt"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/CMakeLists.txt"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/CMakeLists.txt?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -52,6 +52,8 @@ project (jansson C)\n \n # Options\n OPTION (BUILD_SHARED_LIBS \""Build shared libraries.\"" OFF)\n+OPTION (USE_URANDOM \""Use /dev/urandom to seed the hash function.\"" ON)\n+OPTION (USE_WINDOWS_CRYPTOAPI \""Use CryptGenRandom to seed the hash function.\"" ON)\n \n if (MSVC)\n    # This option must match the settings used in your program, in particular if you\n@@ -85,12 +87,12 @@ set (JANSSON_SOVERSION 4)\n # for CheckFunctionKeywords\n set(CMAKE_MODULE_PATH \""${CMAKE_CURRENT_SOURCE_DIR}/cmake\"")\n \n+INCLUDE (CheckCSourceCompiles)\n include (CheckFunctionExists)\n include (CheckFunctionKeywords)\n include (CheckIncludeFiles)\n include (CheckTypeSize)\n \n-\n if (MSVC)\n    # Turn off Microsofts \""security\"" warnings.\n    add_definitions( \""/W3 /D_CRT_SECURE_NO_WARNINGS /wd4005 /wd4996 /nologo\"" )\n@@ -106,14 +108,25 @@ if (CMAKE_COMPILER_IS_GNUCC OR CMAKE_COMPILER_IS_GNUCXX)\n    set(CMAKE_C_FLAGS \""-fPIC\"")\n endif()\n \n-   \n+check_include_files (endian.h HAVE_ENDIAN_H)\n+check_include_files (fcntl.h HAVE_FCNTL_H)\n+check_include_files (sched.h HAVE_SCHED_H)\n+check_include_files (unistd.h HAVE_UNISTD_H)\n+check_include_files (sys/param.h HAVE_SYS_PARAM_H)\n+check_include_files (sys/stat.h HAVE_SYS_STAT_H)\n+check_include_files (sys/time.h HAVE_SYS_TIME_H)\n+check_include_files (sys/time.h HAVE_SYS_TYPES_H)\n+\n+check_function_exists (close HAVE_CLOSE)\n+check_function_exists (getpid HAVE_GETPID)\n+check_function_exists (gettimeofday HAVE_GETTIMEOFDAY)\n+check_function_exists (open HAVE_OPEN)\n+check_function_exists (read HAVE_READ)\n+check_function_exists (sched_yield HAVE_SCHED_YIELD)\n \n # Check for the int-type includes\n-check_include_files (sys/types.h HAVE_SYS_TYPES_H)\n-check_include_files (inttypes.h HAVE_INTTYPES_H)\n check_include_files (stdint.h HAVE_STDINT_H)\n \n-\n # Check our 64 bit integer sizes\n check_type_size (__int64 __INT64)\n check_type_size (int64_t INT64_T)\n@@ -124,17 +137,32 @@ check_type_size (int32_t INT32_T)\n check_type_size (__int32 __INT32)\n check_type_size (\""long\"" LONG_INT)\n check_type_size (\""int\"" INT)\n-\n if (HAVE_INT32_T)\n    set (JSON_INT32 int32_t)\n elseif (HAVE___INT32)\n    set (JSON_INT32 __int32)\n-elseif (HAVE_LONG AND (${LONG_INT} EQUAL 4))\n+elseif (HAVE_LONG_INT AND (${LONG_INT} EQUAL 4))\n    set (JSON_INT32 long)\n elseif (HAVE_INT AND (${INT} EQUAL 4))\n    set (JSON_INT32 int)\n else ()\n-   message (FATAL_ERROR \""Could not detect a valid 32 bit integer type\"")\n+   message (FATAL_ERROR \""Could not detect a valid 32-bit integer type\"")\n+endif ()\n+\n+check_type_size (uint32_t UINT32_T)\n+check_type_size (__uint32 __UINT32)\n+check_type_size (\""unsigned long\"" UNSIGNED_LONG_INT)\n+check_type_size (\""unsigned int\"" UNSIGNED_INT)\n+if (HAVE_UINT32_T)\n+   set (JSON_UINT32 uint32_t)\n+elseif (HAVE___UINT32)\n+   set (JSON_UINT32 __uint32)\n+elseif (HAVE_UNSIGNED_LONG_INT AND (${UNSIGNED_LONG_INT} EQUAL 4))\n+   set (JSON_UINT32 \""unsigned long\"")\n+elseif (HAVE_UNSIGNED_INT AND (${UNSIGNED_INT} EQUAL 4))\n+   set (JSON_UINT32 \""unsigned int\"")\n+else ()\n+   message (FATAL_ERROR \""Could not detect a valid unsigned 32-bit integer type\"")\n endif ()\n \n # Check for ssize_t and SSIZE_T existance.\n@@ -206,11 +234,9 @@ else ()\n    set (JSON_HAVE_LOCALECONV 0)\n endif ()\n \n-\n # check if we have setlocale\n check_function_exists (setlocale HAVE_SETLOCALE)\n \n-\n # Check what the inline keyword is.\n # Note that the original JSON_INLINE was always set to just 'inline', so this goes further.\n check_function_keywords(\""inline\"")\n@@ -238,6 +264,9 @@ elseif (HAVE__SNPRINTF)\n    set (JSON_SNPRINTF _snprintf)\n endif ()\n \n+check_c_source_compiles (\""int main() { unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1); return 0; } \"" HAVE_SYNC_BUILTINS)\n+check_c_source_compiles (\""int main() { char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE); return 0; }\"" HAVE_ATOMIC_BUILTINS)\n+\n # Create pkg-conf file.\n # (We use the same files as ./configure does, so we\n #  have to defined the same variables used there).""}<_**next**_>{""sha"": ""b27b9a3a849e94686aa648c1ec4d1bd4c8e35445"", ""filename"": ""cmake/config.h.cmake"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 21, ""changes"": 46, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/cmake/config.h.cmake"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/cmake/config.h.cmake"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/cmake/config.h.cmake?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,35 +1,36 @@\n-/* Reduced down to the defines that are actually used in the code */\n-\n-/* Define to 1 if you have the <inttypes.h> (and friends) header file. */\n-#cmakedefine HAVE_INTTYPES_H 1\n-#cmakedefine HAVE_STDINT_H 1\n+#cmakedefine HAVE_ENDIAN_H 1\n+#cmakedefine HAVE_FCNTL_H 1\n+#cmakedefine HAVE_SCHED_H 1\n+#cmakedefine HAVE_UNISTD_H 1\n+#cmakedefine HAVE_SYS_PARAM_H 1\n+#cmakedefine HAVE_SYS_STAT_H 1\n+#cmakedefine HAVE_SYS_TIME_H 1\n #cmakedefine HAVE_SYS_TYPES_H 1\n+#cmakedefine HAVE_STDINT_H 1\n \n-/* We must include this here, as in (eg) utf.h it will want to use\n-   the integer type, which in MSVC2010 will be in stdint.h\n-   (there is no inttypes.h in MSVC2010) */\n-#if defined(HAVE_STDINT_H)\n-#  include <stdint.h>\n-#elif defined(HAVE_INTTYPES_H)\n-#  include <inttypes.h>\n-#elif defined(HAVE_SYS_TYPES_H)\n-#  include <sys/types.h>\n-#endif\n+#cmakedefine HAVE_CLOSE 1\n+#cmakedefine HAVE_GETPID 1\n+#cmakedefine HAVE_GETTIMEOFDAY 1\n+#cmakedefine HAVE_OPEN 1\n+#cmakedefine HAVE_READ 1\n+#cmakedefine HAVE_SCHED_YIELD 1\n \n-/* Define to 1 if you have the <locale.h> header file. */\n-#cmakedefine HAVE_LOCALE_H 1\n+#cmakedefine HAVE_SYNC_BUILTINS 1\n+#cmakedefine HAVE_ATOMIC_BUILTINS 1\n \n-/* Define to 1 if you have the 'setlocale' function. */\n+#cmakedefine HAVE_LOCALE_H 1\n #cmakedefine HAVE_SETLOCALE 1\n \n-/* Define to the type of a signed integer type of width exactly 32 bits if\n-   such a type exists and the standard includes do not define it. */\n #cmakedefine HAVE_INT32_T 1\n-\n #ifndef HAVE_INT32_T\n #  define int32_t @JSON_INT32@\n #endif\n \n+#cmakedefine HAVE_UINT32_T 1\n+#ifndef HAVE_UINT32_T\n+#  define uint32_t @JSON_UINT32@\n+#endif\n+\n #cmakedefine HAVE_SSIZE_T 1\n \n #ifndef HAVE_SSIZE_T\n@@ -43,3 +44,6 @@\n #endif\n \n #cmakedefine HAVE_VSNPRINTF\n+\n+#cmakedefine USE_URANDOM 1\n+#cmakedefine USE_WINDOWS_CRYPTOAPI 1""}<_**next**_>{""sha"": ""113cb85e17a15f2fac83b528fe1880bc99481ccb"", ""filename"": ""configure.ac"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 2, ""changes"": 50, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/configure.ac"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/configure.ac"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/configure.ac?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -14,10 +14,11 @@ AM_CONDITIONAL([GCC], [test x$GCC = xyes])\n # Checks for libraries.\n \n # Checks for header files.\n-AC_CHECK_HEADERS([locale.h])\n+AC_CHECK_HEADERS([endian.h fcntl.h locale.h sched.h unistd.h sys/param.h sys/stat.h sys/time.h sys/types.h])\n \n # Checks for typedefs, structures, and compiler characteristics.\n AC_TYPE_INT32_T\n+AC_TYPE_UINT32_T\n AC_TYPE_LONG_LONG_INT\n \n AC_C_INLINE\n@@ -29,7 +30,31 @@ esac\n AC_SUBST([json_inline])\n \n # Checks for library functions.\n-AC_CHECK_FUNCS([strtoll localeconv])\n+AC_CHECK_FUNCS([close getpid gettimeofday localeconv open read sched_yield strtoll])\n+\n+AC_MSG_CHECKING([for gcc __sync builtins])\n+have_sync_builtins=no\n+AC_TRY_LINK(\n+  [], [unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1);],\n+  [have_sync_builtins=yes],\n+)\n+if test \""x$have_sync_builtins\"" = \""xyes\""; then\n+  AC_DEFINE([HAVE_SYNC_BUILTINS], [1],\n+    [Define to 1 if gcc's __sync builtins are available])\n+fi\n+AC_MSG_RESULT([$have_sync_builtins])\n+\n+AC_MSG_CHECKING([for gcc __atomic builtins])\n+have_atomic_builtins=no\n+AC_TRY_LINK(\n+  [], [char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE);],\n+  [have_atomic_builtins=yes],\n+)\n+if test \""x$have_atomic_builtins\"" = \""xyes\""; then\n+  AC_DEFINE([HAVE_ATOMIC_BUILTINS], [1],\n+    [Define to 1 if gcc's __atomic builtins are available])\n+fi\n+AC_MSG_RESULT([$have_atomic_builtins])\n \n case \""$ac_cv_type_long_long_int$ac_cv_func_strtoll\"" in\n      yesyes) json_have_long_long=1;;\n@@ -43,6 +68,27 @@ case \""$ac_cv_header_locale_h$ac_cv_func_localeconv\"" in\n esac\n AC_SUBST([json_have_localeconv])\n \n+# Features\n+AC_ARG_ENABLE([urandom],\n+  [AS_HELP_STRING([--disable-urandom],\n+    [Don't use /dev/urandom to seed the hash function])],\n+  [use_urandom=$enableval], [use_urandom=yes])\n+\n+if test \""x$use_urandom\"" = xyes; then\n+AC_DEFINE([USE_URANDOM], [1],\n+  [Define to 1 if /dev/urandom should be used for seeding the hash function])\n+fi\n+\n+AC_ARG_ENABLE([windows-cryptoapi],\n+  [AS_HELP_STRING([--disable-windows-cryptoapi],\n+    [Don't use CryptGenRandom to seed the hash function])],\n+  [use_windows_cryptoapi=$enableval], [use_windows_cryptoapi=yes])\n+\n+if test \""x$use_windows_cryptoapi\"" = xyes; then\n+AC_DEFINE([USE_WINDOWS_CRYPTOAPI], [1],\n+  [Define to 1 if CryptGenRandom should be used for seeding the hash function])\n+fi\n+\n AC_CONFIG_FILES([\n         jansson.pc\n         Makefile""}<_**next**_>{""sha"": ""b4af562e84b5ed9dba1107af7d1768dcdb0b9a95"", ""filename"": ""src/Makefile.am"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/Makefile.am"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/Makefile.am?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -8,6 +8,7 @@ libjansson_la_SOURCES = \\\n \terror.c \\\n \thashtable.c \\\n \thashtable.h \\\n+\thashtable_seed.c \\\n \tjansson_private.h \\\n \tload.c \\\n \tmemory.c \\""}<_**next**_>{""sha"": ""abd4bf11fe7a393fcf3d533b952aa8b5efa4ea30"", ""filename"": ""src/hashtable.c"", ""status"": ""modified"", ""additions"": 26, ""deletions"": 41, ""changes"": 67, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -5,8 +5,17 @@\n  * it under the terms of the MIT license. See LICENSE for details.\n  */\n \n+#if HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stdlib.h>\n #include <string.h>\n+\n+#if HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include <jansson_config.h>   /* for JSON_INLINE */\n #include \""jansson_private.h\""  /* for container_of() */\n #include \""hashtable.h\""\n@@ -15,24 +24,13 @@ typedef struct hashtable_list list_t;\n typedef struct hashtable_pair pair_t;\n typedef struct hashtable_bucket bucket_t;\n \n-#define list_to_pair(list_)  container_of(list_, pair_t, list)\n-\n-/* From http://www.cse.yorku.ca/~oz/hash.html */\n-static size_t hash_str(const void *ptr)\n-{\n-    const char *str = (const char *)ptr;\n-\n-    size_t hash = 5381;\n-    size_t c;\n+extern volatile uint32_t hashtable_seed;\n \n-    while((c = (size_t)*str))\n-    {\n-        hash = ((hash << 5) + hash) + c;\n-        str++;\n-    }\n+/* Implementation of the hash function */\n+#include \""lookup3.h\""\n \n-    return hash;\n-}\n+#define list_to_pair(list_)  container_of(list_, pair_t, list)\n+#define hash_str(key)        ((size_t)hashlittle((key), strlen(key), hashtable_seed))\n \n static JSON_INLINE void list_init(list_t *list)\n {\n@@ -74,19 +72,6 @@ static void insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket,\n     }\n }\n \n-static const size_t primes[] = {\n-    5, 13, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,\n-    49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,\n-    12582917, 25165843, 50331653, 100663319, 201326611, 402653189,\n-    805306457, 1610612741\n-};\n-\n-static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)\n-{\n-    return primes[hashtable->num_buckets];\n-}\n-\n-\n static pair_t *hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket,\n                                    const char *key, size_t hash)\n {\n@@ -120,7 +105,7 @@ static int hashtable_do_del(hashtable_t *hashtable,\n     bucket_t *bucket;\n     size_t index;\n \n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n@@ -167,14 +152,14 @@ static int hashtable_do_rehash(hashtable_t *hashtable)\n \n     jsonp_free(hashtable->buckets);\n \n-    hashtable->num_buckets++;\n-    new_size = num_buckets(hashtable);\n+    hashtable->order++;\n+    new_size = hashsize(hashtable->order);\n \n     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -199,14 +184,14 @@ int hashtable_init(hashtable_t *hashtable)\n     size_t i;\n \n     hashtable->size = 0;\n-    hashtable->num_buckets = 0;  /* index to primes[] */\n-    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));\n+    hashtable->order = 3;\n+    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n     list_init(&hashtable->list);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -230,12 +215,12 @@ int hashtable_set(hashtable_t *hashtable,\n     size_t hash, index;\n \n     /* rehash if the load ratio exceeds 1 */\n-    if(hashtable->size >= num_buckets(hashtable))\n+    if(hashtable->size >= hashsize(hashtable->order))\n         if(hashtable_do_rehash(hashtable))\n             return -1;\n \n     hash = hash_str(key);\n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n \n@@ -273,7 +258,7 @@ void *hashtable_get(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)\n@@ -294,7 +279,7 @@ void hashtable_clear(hashtable_t *hashtable)\n \n     hashtable_do_clear(hashtable);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -316,7 +301,7 @@ void *hashtable_iter_at(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)""}<_**next**_>{""sha"": ""469c6ecd869c4698f650fa81983bb3ee03d47fab"", ""filename"": ""src/hashtable.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -32,14 +32,15 @@ struct hashtable_bucket {\n typedef struct hashtable {\n     size_t size;\n     struct hashtable_bucket *buckets;\n-    size_t num_buckets;  /* index to primes[] */\n+    size_t order;  /* hashtable has pow(2, order) buckets */\n     struct hashtable_list list;\n } hashtable_t;\n \n \n #define hashtable_key_to_iter(key_) \\\n     (&(container_of(key_, struct hashtable_pair, key)->list))\n \n+\n /**\n  * hashtable_init - Initialize a hashtable object\n  *""}<_**next**_>{""sha"": ""a07d145d10df35b933c1441dcbf42d3316b78ca5"", ""filename"": ""src/hashtable_seed.c"", ""status"": ""added"", ""additions"": 278, ""deletions"": 0, ""changes"": 278, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable_seed.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable_seed.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable_seed.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,278 @@\n+/* Generate sizeof(uint32_t) bytes of as random data as possible to seed\n+   the hash function.\n+*/\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#include <stdio.h>\n+#include <time.h>\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n+#ifdef HAVE_FCNTL_H\n+#include <fcntl.h>\n+#endif\n+\n+#ifdef HAVE_SCHED_H\n+#include <sched.h>\n+#endif\n+\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+\n+#ifdef HAVE_SYS_STAT_H\n+#include <sys/stat.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TIME_H\n+#include <sys/time.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TYPES_H\n+#include <sys/types.h>\n+#endif\n+\n+#if defined(_WIN32)\n+/* For _getpid() */\n+#include <process.h>\n+#endif\n+\n+#include \""jansson.h\""\n+\n+\n+static uint32_t buf_to_uint32(char *data) {\n+    size_t i;\n+    uint32_t result = 0;\n+\n+    for (i = 0; i < sizeof(uint32_t); i++)\n+        result = (result << 8) | (unsigned char)data[i];\n+\n+    return result;\n+}\n+\n+\n+\n+/* /dev/urandom */\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+static int seed_from_urandom(uint32_t *seed) {\n+    /* Use unbuffered I/O if we have open(), close() and read(). Otherwise\n+       fall back to fopen() */\n+\n+    char data[sizeof(uint32_t)];\n+    int ok;\n+\n+#if defined(HAVE_OPEN) && defined(HAVE_CLOSE) && defined(HAVE_READ)\n+    int urandom;\n+    urandom = open(\""/dev/urandom\"", O_RDONLY);\n+    if (urandom == -1)\n+        return 1;\n+\n+    ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);\n+    close(urandom);\n+#else\n+    FILE *urandom;\n+\n+    urandom = fopen(\""/dev/urandom\"", \""rb\"");\n+    if (!urandom)\n+        return 1;\n+\n+    ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);\n+    fclose(urandom);\n+#endif\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32(data);\n+    return 0;\n+}\n+#endif\n+\n+/* Windows Crypto API */\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+#include <windows.h>\n+#include <wincrypt.h>\n+\n+typedef BOOL (WINAPI *CRYPTACQUIRECONTEXTA)(HCRYPTPROV *phProv, LPCSTR pszContainer, LPCSTR pszProvider, DWORD dwProvType, DWORD dwFlags);\n+typedef BOOL (WINAPI *CRYPTGENRANDOM)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);\n+typedef BOOL (WINAPI *CRYPTRELEASECONTEXT)(HCRYPTPROV hProv, DWORD dwFlags);\n+\n+static int seed_from_windows_cryptoapi(uint32_t *seed)\n+{\n+    HINSTANCE hAdvAPI32 = NULL;\n+    CRYPTACQUIRECONTEXTA pCryptAcquireContext = NULL;\n+    CRYPTGENRANDOM pCryptGenRandom = NULL;\n+    CRYPTRELEASECONTEXT pCryptReleaseContext = NULL;\n+    HCRYPTPROV hCryptProv = 0;\n+    BYTE data[sizeof(uint32_t)];\n+    int ok;\n+\n+    hAdvAPI32 = GetModuleHandle(\""advapi32.dll\"");\n+    if(hAdvAPI32 == NULL)\n+        return 1;\n+\n+    pCryptAcquireContext = (CRYPTACQUIRECONTEXTA)GetProcAddress(hAdvAPI32, \""CryptAcquireContextA\"");\n+    if (!pCryptAcquireContext)\n+        return 1;\n+\n+    pCryptGenRandom = (CRYPTGENRANDOM)GetProcAddress(hAdvAPI32, \""CryptGenRandom\"");\n+    if (!pCryptGenRandom)\n+        return 1;\n+\n+    pCryptReleaseContext = (CRYPTRELEASECONTEXT)GetProcAddress(hAdvAPI32, \""CryptReleaseContext\"");\n+    if (!pCryptReleaseContext)\n+        return 1;\n+\n+    if (!pCryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))\n+        return 1;\n+\n+    ok = CryptGenRandom(hCryptProv, sizeof(uint32_t), data);\n+    pCryptReleaseContext(hCryptProv, 0);\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32((char *)data);\n+    return 0;\n+}\n+#endif\n+\n+/* gettimeofday() and getpid() */\n+static int seed_from_timestamp_and_pid(uint32_t *seed) {\n+#ifdef HAVE_GETTIMEOFDAY\n+    /* XOR of seconds and microseconds */\n+    struct timeval tv;\n+    gettimeofday(&tv, NULL);\n+    *seed = (uint32_t)tv.tv_sec ^ (uint32_t)tv.tv_usec;\n+#else\n+    /* Seconds only */\n+    *seed = (uint32_t)time(NULL);\n+#endif\n+\n+    /* XOR with PID for more randomness */\n+#if defined(_WIN32)\n+    *seed ^= (uint32_t)_getpid();\n+#elif defined(HAVE_GETPID)\n+    *seed ^= (uint32_t)getpid();\n+#endif\n+\n+    return 0;\n+}\n+\n+static uint32_t generate_seed() {\n+    uint32_t seed;\n+    int done = 0;\n+\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+    if (!done && seed_from_urandom(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+    if (!done && seed_from_windows_cryptoapi(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+    if (!done) {\n+        /* Fall back to timestamp and PID if no better randomness is\n+           available */\n+        seed_from_timestamp_and_pid(&seed);\n+    }\n+\n+    /* Make sure the seed is never zero */\n+    if (seed == 0)\n+        seed = 1;\n+\n+    return seed;\n+}\n+\n+\n+volatile uint32_t hashtable_seed = 0;\n+\n+#if defined(HAVE_ATOMIC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+static volatile char seed_initialized = 0;\n+\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (__atomic_test_and_set(&seed_initialized, __ATOMIC_RELAXED) == 0) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            __atomic_store_n(&hashtable_seed, new_seed, __ATOMIC_ACQ_REL);\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            } while(__atomic_load_n(&hashtable_seed, __ATOMIC_ACQUIRE) == 0);\n+        }\n+    }\n+}\n+#elif defined(HAVE_SYNC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0) {\n+            /* Explicit synchronization fences are not supported by the\n+               __sync builtins, so every thread getting here has to\n+               generate the seed value.\n+            */\n+            new_seed = generate_seed();\n+        }\n+\n+        do {\n+            if (__sync_bool_compare_and_swap(&hashtable_seed, 0, new_seed)) {\n+                /* We were the first to seed */\n+                break;\n+            } else {\n+                /* Wait for another thread to do the seeding */\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            }\n+        } while(hashtable_seed == 0);\n+    }\n+}\n+#elif defined(_WIN32)\n+static long seed_initialized = 0;\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (InterlockedIncrement(&seed_initialized) == 1) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            hashtable_seed = new_seed;\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+                SwitchToThread();\n+            } while (hashtable_seed == 0);\n+        }\n+    }\n+}\n+#else\n+/* Fall back to a thread-unsafe version */\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0)\n+            new_seed = generate_seed();\n+\n+        hashtable_seed = new_seed;\n+    }\n+}\n+#endif""}<_**next**_>{""sha"": ""19096d4201e6b13f8c56765116865c71f67e9696"", ""filename"": ""src/jansson.def"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.def"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.def"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/jansson.def?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -41,6 +41,7 @@ EXPORTS\n     json_object_iter_value\n     json_object_iter_set_new\n     json_object_key_to_iter\n+    json_object_seed\n     json_dumps\n     json_dumpf\n     json_dump_file""}<_**next**_>{""sha"": ""ea230852a629e55457fba2d00e3edd8a4ad4fcec"", ""filename"": ""src/jansson.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/jansson.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -126,6 +126,7 @@ typedef struct {\n \n /* getters, setters, manipulation */\n \n+void json_object_seed(size_t seed);\n size_t json_object_size(const json_t *object);\n json_t *json_object_get(const json_t *object, const char *key);\n int json_object_set_new(json_t *object, const char *key, json_t *value);""}<_**next**_>{""sha"": ""dc76138c940516e9590784825d28d040fd1a8b25"", ""filename"": ""src/lookup3.h"", ""status"": ""added"", ""additions"": 366, ""deletions"": 0, ""changes"": 366, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/lookup3.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/lookup3.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/lookup3.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,366 @@\n+/*\n+-------------------------------------------------------------------------------\n+lookup3.c, by Bob Jenkins, May 2006, Public Domain.\n+\n+These are functions for producing 32-bit hashes for hash table lookup.\n+hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final() \n+are externally useful functions.  Routines to test the hash are included \n+if SELF_TEST is defined.  You can use this free for any purpose.  It's in\n+the public domain.  It has no warranty.\n+\n+You probably want to use hashlittle().  hashlittle() and hashbig()\n+hash byte arrays.  hashlittle() is is faster than hashbig() on\n+little-endian machines.  Intel and AMD are little-endian machines.\n+On second thought, you probably want hashlittle2(), which is identical to\n+hashlittle() except it returns two 32-bit hashes for the price of one.  \n+You could implement hashbig2() if you wanted but I haven't bothered here.\n+\n+If you want to find a hash of, say, exactly 7 integers, do\n+  a = i1;  b = i2;  c = i3;\n+  mix(a,b,c);\n+  a += i4; b += i5; c += i6;\n+  mix(a,b,c);\n+  a += i7;\n+  final(a,b,c);\n+then use c as the hash value.  If you have a variable length array of\n+4-byte integers to hash, use hashword().  If you have a byte array (like\n+a character string), use hashlittle().  If you have several byte arrays, or\n+a mix of things, see the comments above hashlittle().  \n+\n+Why is this so big?  I read 12 bytes at a time into 3 4-byte integers, \n+then mix those integers.  This is fast (you can do a lot more thorough\n+mixing with 12*3 instructions on 3 integers than you can with 3 instructions\n+on 1 byte), but shoehorning those bytes into integers efficiently is messy.\n+-------------------------------------------------------------------------------\n+*/\n+\n+#include <stdlib.h>\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>     /* defines uint32_t etc */\n+#endif\n+\n+#ifdef HAVE_SYS_PARAM_H\n+#include <sys/param.h>  /* attempt to define endianness */\n+#endif\n+\n+#ifdef HAVE_ENDIAN_H\n+# include <endian.h>    /* attempt to define endianness */\n+#endif\n+\n+/*\n+ * My best guess at if you are big-endian or little-endian.  This may\n+ * need adjustment.\n+ */\n+#if (defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && \\\n+     __BYTE_ORDER == __LITTLE_ENDIAN) || \\\n+    (defined(i386) || defined(__i386__) || defined(__i486__) || \\\n+     defined(__i586__) || defined(__i686__) || defined(vax) || defined(MIPSEL))\n+# define HASH_LITTLE_ENDIAN 1\n+# define HASH_BIG_ENDIAN 0\n+#elif (defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && \\\n+       __BYTE_ORDER == __BIG_ENDIAN) || \\\n+      (defined(sparc) || defined(POWERPC) || defined(mc68000) || defined(sel))\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 1\n+#else\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 0\n+#endif\n+\n+#define hashsize(n) ((uint32_t)1<<(n))\n+#define hashmask(n) (hashsize(n)-1)\n+#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n+\n+/*\n+-------------------------------------------------------------------------------\n+mix -- mix 3 32-bit values reversibly.\n+\n+This is reversible, so any information in (a,b,c) before mix() is\n+still in (a,b,c) after mix().\n+\n+If four pairs of (a,b,c) inputs are run through mix(), or through\n+mix() in reverse, there are at least 32 bits of the output that\n+are sometimes the same for one pair and different for another pair.\n+This was tested for:\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+Some k values for my \""a-=c; a^=rot(c,k); c+=b;\"" arrangement that\n+satisfy this are\n+    4  6  8 16 19  4\n+    9 15  3 18 27 15\n+   14  9  3  7 17  3\n+Well, \""9 15 3 18 27 15\"" didn't quite get 32 bits diffing\n+for \""differ\"" defined as + with a one-bit base and a two-bit delta.  I\n+used http://burtleburtle.net/bob/hash/avalanche.html to choose \n+the operations, constants, and arrangements of the variables.\n+\n+This does not achieve avalanche.  There are input bits of (a,b,c)\n+that fail to affect some output bits of (a,b,c), especially of a.  The\n+most thoroughly mixed value is c, but it doesn't really even achieve\n+avalanche in c.\n+\n+This allows some parallelism.  Read-after-writes are good at doubling\n+the number of bits affected, so the goal of mixing pulls in the opposite\n+direction as the goal of parallelism.  I did what I could.  Rotates\n+seem to cost as much as shifts on every machine I could lay my hands\n+on, and rotates are much kinder to the top and bottom bits, so I used\n+rotates.\n+-------------------------------------------------------------------------------\n+*/\n+#define mix(a,b,c) \\\n+{ \\\n+  a -= c;  a ^= rot(c, 4);  c += b; \\\n+  b -= a;  b ^= rot(a, 6);  a += c; \\\n+  c -= b;  c ^= rot(b, 8);  b += a; \\\n+  a -= c;  a ^= rot(c,16);  c += b; \\\n+  b -= a;  b ^= rot(a,19);  a += c; \\\n+  c -= b;  c ^= rot(b, 4);  b += a; \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+final -- final mixing of 3 32-bit values (a,b,c) into c\n+\n+Pairs of (a,b,c) values differing in only a few bits will usually\n+produce values of c that look totally different.  This was tested for\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+These constants passed:\n+ 14 11 25 16 4 14 24\n+ 12 14 25 16 4 14 24\n+and these came close:\n+  4  8 15 26 3 22 24\n+ 10  8 15 26 3 22 24\n+ 11  8 15 26 3 22 24\n+-------------------------------------------------------------------------------\n+*/\n+#define final(a,b,c) \\\n+{ \\\n+  c ^= b; c -= rot(b,14); \\\n+  a ^= c; a -= rot(c,11); \\\n+  b ^= a; b -= rot(a,25); \\\n+  c ^= b; c -= rot(b,16); \\\n+  a ^= c; a -= rot(c,4);  \\\n+  b ^= a; b -= rot(a,14); \\\n+  c ^= b; c -= rot(b,24); \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+hashlittle() -- hash a variable-length key into a 32-bit value\n+  k       : the key (the unaligned variable-length array of bytes)\n+  length  : the length of the key, counting by bytes\n+  initval : can be any 4-byte value\n+Returns a 32-bit value.  Every bit of the key affects every bit of\n+the return value.  Two keys differing by one or two bits will have\n+totally different hash values.\n+\n+The best hash table sizes are powers of 2.  There is no need to do\n+mod a prime (mod is sooo slow!).  If you need less than 32 bits,\n+use a bitmask.  For example, if you need only 10 bits, do\n+  h = (h & hashmask(10));\n+In which case, the hash table should have hashsize(10) elements.\n+\n+If you are hashing n strings (uint8_t **)k, do it like this:\n+  for (i=0, h=0; i<n; ++i) h = hashlittle( k[i], len[i], h);\n+\n+By Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this\n+code any way you wish, private, educational, or commercial.  It's free.\n+\n+Use for hash table lookup, or anything where one collision in 2^^32 is\n+acceptable.  Do NOT use for cryptographic purposes.\n+-------------------------------------------------------------------------------\n+*/\n+\n+static uint32_t hashlittle(const void *key, size_t length, uint32_t initval)\n+{\n+  uint32_t a,b,c;                                          /* internal state */\n+  union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */\n+\n+  /* Set up the internal state */\n+  a = b = c = 0xdeadbeef + ((uint32_t)length) + initval;\n+\n+  u.ptr = key;\n+  if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0)) {\n+    const uint32_t *k = (const uint32_t *)key;         /* read 32-bit chunks */\n+\n+#ifdef VALGRIND\n+    const uint8_t  *k8;\n+#endif\n+\n+    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      b += k[1];\n+      c += k[2];\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 3;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    /* \n+     * \""k[2]&0xffffff\"" actually reads beyond the end of the string, but\n+     * then masks off the part it's not allowed to read.  Because the\n+     * string is aligned, the masked-off tail is in the same word as the\n+     * rest of the string.  Every machine with memory protection I've seen\n+     * does it on word boundaries, so is OK with this.  But VALGRIND will\n+     * still catch it and complain.  The masking trick does make the hash\n+     * noticably faster for short strings (like English words).\n+     */\n+#ifndef VALGRIND\n+\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n+    case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n+    case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n+    case 6 : b+=k[1]&0xffff; a+=k[0]; break;\n+    case 5 : b+=k[1]&0xff; a+=k[0]; break;\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=k[0]&0xffffff; break;\n+    case 2 : a+=k[0]&0xffff; break;\n+    case 1 : a+=k[0]&0xff; break;\n+    case 0 : return c;              /* zero length strings require no mixing */\n+    }\n+\n+#else /* make valgrind happy */\n+\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=((uint32_t)k8[10])<<16;  /* fall through */\n+    case 10: c+=((uint32_t)k8[9])<<8;    /* fall through */\n+    case 9 : c+=k8[8];                   /* fall through */\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;   /* fall through */\n+    case 6 : b+=((uint32_t)k8[5])<<8;    /* fall through */\n+    case 5 : b+=k8[4];                   /* fall through */\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;   /* fall through */\n+    case 2 : a+=((uint32_t)k8[1])<<8;    /* fall through */\n+    case 1 : a+=k8[0]; break;\n+    case 0 : return c;\n+    }\n+\n+#endif /* !valgrind */\n+\n+  } else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0)) {\n+    const uint16_t *k = (const uint16_t *)key;         /* read 16-bit chunks */\n+    const uint8_t  *k8;\n+\n+    /*--------------- all but last block: aligned reads and different mixing */\n+    while (length > 12)\n+    {\n+      a += k[0] + (((uint32_t)k[1])<<16);\n+      b += k[2] + (((uint32_t)k[3])<<16);\n+      c += k[4] + (((uint32_t)k[5])<<16);\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 6;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[4]+(((uint32_t)k[5])<<16);\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 11: c+=((uint32_t)k8[10])<<16;     /* fall through */\n+    case 10: c+=k[4];\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 9 : c+=k8[8];                      /* fall through */\n+    case 8 : b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;      /* fall through */\n+    case 6 : b+=k[2];\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 5 : b+=k8[4];                      /* fall through */\n+    case 4 : a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;      /* fall through */\n+    case 2 : a+=k[0];\n+             break;\n+    case 1 : a+=k8[0];\n+             break;\n+    case 0 : return c;                     /* zero length requires no mixing */\n+    }\n+\n+  } else {                        /* need to read the key one byte at a time */\n+    const uint8_t *k = (const uint8_t *)key;\n+\n+    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      a += ((uint32_t)k[1])<<8;\n+      a += ((uint32_t)k[2])<<16;\n+      a += ((uint32_t)k[3])<<24;\n+      b += k[4];\n+      b += ((uint32_t)k[5])<<8;\n+      b += ((uint32_t)k[6])<<16;\n+      b += ((uint32_t)k[7])<<24;\n+      c += k[8];\n+      c += ((uint32_t)k[9])<<8;\n+      c += ((uint32_t)k[10])<<16;\n+      c += ((uint32_t)k[11])<<24;\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 12;\n+    }\n+\n+    /*-------------------------------- last block: affect all 32 bits of (c) */\n+    switch(length)                   /* all the case statements fall through */\n+    {\n+    case 12: c+=((uint32_t)k[11])<<24;\n+    case 11: c+=((uint32_t)k[10])<<16;\n+    case 10: c+=((uint32_t)k[9])<<8;\n+    case 9 : c+=k[8];\n+    case 8 : b+=((uint32_t)k[7])<<24;\n+    case 7 : b+=((uint32_t)k[6])<<16;\n+    case 6 : b+=((uint32_t)k[5])<<8;\n+    case 5 : b+=k[4];\n+    case 4 : a+=((uint32_t)k[3])<<24;\n+    case 3 : a+=((uint32_t)k[2])<<16;\n+    case 2 : a+=((uint32_t)k[1])<<8;\n+    case 1 : a+=k[0];\n+             break;\n+    case 0 : return c;\n+    }\n+  }\n+\n+  final(a,b,c);\n+  return c;\n+}""}<_**next**_>{""sha"": ""b4f109143031b2481a0d32a332c88cc1cc96c688"", ""filename"": ""src/utf.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 16, ""changes"": 20, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/utf.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/utf.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/utf.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -10,23 +10,11 @@\n \n #ifdef HAVE_CONFIG_H\n #include <config.h>\n+#endif\n \n-#ifdef HAVE_INTTYPES_H\n-/* inttypes.h includes stdint.h in a standard environment, so there's\n-no need to include stdint.h separately. If inttypes.h doesn't define\n-int32_t, it's defined in config.h. */\n-#include <inttypes.h>\n-#endif /* HAVE_INTTYPES_H */\n-\n-#else /* !HAVE_CONFIG_H */\n-#ifdef _WIN32\n-typedef int int32_t;\n-#else /* !_WIN32 */\n-/* Assume a standard environment */\n-#include <inttypes.h>\n-#endif /* _WIN32 */\n-\n-#endif /* HAVE_CONFIG_H */\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n \n int utf8_encode(int codepoint, char *buffer, int *size);\n ""}<_**next**_>{""sha"": ""1b02d90aa885f1ede146bb2077d05c8bb9096565"", ""filename"": ""src/value.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/value.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/value.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/value.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -9,11 +9,19 @@\n #define _GNU_SOURCE\n #endif\n \n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stddef.h>\n #include <stdlib.h>\n #include <string.h>\n #include <math.h>\n \n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include \""jansson.h\""\n #include \""hashtable.h\""\n #include \""jansson_private.h\""\n@@ -36,11 +44,19 @@ static JSON_INLINE void json_init(json_t *json, json_type type)\n \n /*** object ***/\n \n+extern volatile uint32_t hashtable_seed;\n+\n json_t *json_object(void)\n {\n     json_object_t *object = jsonp_malloc(sizeof(json_object_t));\n     if(!object)\n         return NULL;\n+\n+    if (!hashtable_seed) {\n+        /* Autoseed */\n+        json_object_seed(0);\n+    }\n+\n     json_init(&object->json, JSON_OBJECT);\n \n     if(hashtable_init(&object->hashtable))""}<_**next**_>{""sha"": ""e2c54bd12bd7c22de7cc3533f010b26cc1c330b0"", ""filename"": ""test/bin/json_process.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 1, ""changes"": 16, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/bin/json_process.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/bin/json_process.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/bin/json_process.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -37,6 +37,8 @@ struct config {\n     int sort_keys;\n     int strip;\n     int use_env;\n+    int have_hashseed;\n+    int hashseed;\n } conf;\n \n #define l_isspace(c) ((c) == ' ' || (c) == '\\n' || (c) == '\\r' || (c) == '\\t')\n@@ -108,6 +110,12 @@ static void read_conf(FILE *conffile)\n             conf.sort_keys = atoi(val);\n         if (!strcmp(line, \""STRIP\""))\n             conf.strip = atoi(val);\n+        if (!strcmp(line, \""HASHSEED\"")) {\n+            conf.have_hashseed = 1;\n+            conf.hashseed = atoi(val);\n+        } else {\n+            conf.have_hashseed = 0;\n+        }\n     }\n \n     free(buffer);\n@@ -188,6 +196,9 @@ int use_conf(char *test_path)\n     if (conf.sort_keys)\n         flags |= JSON_SORT_KEYS;\n \n+    if (conf.have_hashseed)\n+        json_object_seed(conf.hashseed);\n+\n     if (conf.strip) {\n         /* Load to memory, strip leading and trailing whitespace */\n         buffer = loadfile(infile);\n@@ -265,7 +276,10 @@ int use_env()\n         flags |= JSON_PRESERVE_ORDER;\n \n     if(getenv_int(\""JSON_SORT_KEYS\""))\n-         flags |= JSON_SORT_KEYS;\n+        flags |= JSON_SORT_KEYS;\n+\n+    if(getenv(\""HASHSEED\""))\n+        json_object_seed(getenv_int(\""HASHSEED\""));\n \n     if(getenv_int(\""STRIP\"")) {\n         /* Load to memory, strip leading and trailing whitespace */""}<_**next**_>{""sha"": ""84b17466fd0a753b8cbd714d0236ed9072cdd536"", ""filename"": ""test/suites/api/test_memory_funcs.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_memory_funcs.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_memory_funcs.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/api/test_memory_funcs.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -24,13 +24,13 @@ static void create_and_free_complex_object()\n \n static void *my_malloc(size_t size)\n {\n-    malloc_called += 1;\n+    malloc_called = 1;\n     return malloc(size);\n }\n \n static void my_free(void *ptr)\n {\n-    free_called += 1;\n+    free_called = 1;\n     free(ptr);\n }\n \n@@ -39,7 +39,7 @@ static void test_simple()\n     json_set_alloc_funcs(my_malloc, my_free);\n     create_and_free_complex_object();\n \n-    if(malloc_called != 20 || free_called != 20)\n+    if(malloc_called != 1 || free_called != 1)\n         fail(\""Custom allocation failed\"");\n }\n ""}<_**next**_>{""sha"": ""92e5208224b75ab45d93672446279d598052a83e"", ""filename"": ""test/suites/api/test_object.c"", ""status"": ""modified"", ""additions"": 40, ""deletions"": 24, ""changes"": 64, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_object.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_object.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/api/test_object.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -249,7 +249,11 @@ static void test_set_nocheck()\n \n static void test_iterators()\n {\n+    int i;\n     json_t *object, *foo, *bar, *baz;\n+    const char *iter_keys[3];\n+    int have_key[3] = { 0, 0, 0 };\n+    json_t *iter_values[3];\n     void *iter;\n \n     if(json_object_iter(NULL))\n@@ -276,30 +280,50 @@ static void test_iterators()\n     iter = json_object_iter(object);\n     if(!iter)\n         fail(\""unable to get iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""a\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != foo)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[0] = json_object_iter_key(iter);\n+    iter_values[0] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""b\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != bar)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[1] = json_object_iter_key(iter);\n+    iter_values[1] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[2] = json_object_iter_key(iter);\n+    iter_values[2] = json_object_iter_value(iter);\n \n     if(json_object_iter_next(object, iter) != NULL)\n         fail(\""able to iterate over the end\"");\n \n+    /* Check that keys have correct values */\n+    for (i = 0; i < 3; i++) {\n+        if (strcmp(iter_keys[i], \""a\"") == 0) {\n+            if (iter_values[i] != foo)\n+                fail(\""wrong value for iter key a\"");\n+            else\n+                have_key[0] = 1;\n+        } else if (strcmp(iter_keys[i], \""b\"") == 0) {\n+            if (iter_values[i] != bar)\n+                fail(\""wrong value for iter key b\"");\n+            else\n+                have_key[1] = 1;\n+        } else if (strcmp(iter_keys[i], \""c\"") == 0) {\n+            if (iter_values[i] != baz)\n+                fail(\""wrong value for iter key c\"");\n+            else\n+                have_key[2] = 1;\n+        }\n+    }\n+\n+    /* Check that we got all keys */\n+    for(i = 0; i < 3; i++) {\n+        if(!have_key[i])\n+            fail(\""a key wasn't iterated over\"");\n+    }\n+\n     if(json_object_iter_at(object, \""foo\""))\n         fail(\""json_object_iter_at() succeeds for non-existent key\"");\n \n@@ -312,22 +336,14 @@ static void test_iterators()\n     if(json_object_iter_value(iter) != bar)\n         fail(\""iterating failed: wrong value\"");\n \n-    iter = json_object_iter_next(object, iter);\n-    if(!iter)\n-        fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\""iterating failed: wrong value\"");\n-\n-    if(json_object_iter_set(object, iter, bar))\n+    if(json_object_iter_set(object, iter, baz))\n         fail(\""unable to set value at iterator\"");\n \n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n+    if(strcmp(json_object_iter_key(iter), \""b\""))\n         fail(\""json_object_iter_key() fails after json_object_iter_set()\"");\n-    if(json_object_iter_value(iter) != bar)\n+    if(json_object_iter_value(iter) != baz)\n         fail(\""json_object_iter_value() fails after json_object_iter_set()\"");\n-    if(json_object_get(object, \""c\"") != bar)\n+    if(json_object_get(object, \""b\"") != baz)\n         fail(\""json_object_get() fails after json_object_iter_set()\"");\n \n     json_decref(object);""}<_**next**_>{""sha"": ""93cb33ddafeb9eef6ce7ad4709ce1bcbdf25b200"", ""filename"": ""test/suites/encoding-flags/compact-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/compact-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/compact-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/compact-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,2 +1,3 @@\n JSON_COMPACT=1\n-export JSON_COMPACT\n+HASHSEED=1\n+export JSON_COMPACT HASHSEED""}<_**next**_>{""sha"": ""c73acc1792963be8a5f41ff11f6e858506ada51d"", ""filename"": ""test/suites/encoding-flags/indent-compact-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-compact-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-compact-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/indent-compact-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,3 +1,4 @@\n JSON_INDENT=4\n JSON_COMPACT=1\n-export JSON_INDENT JSON_COMPACT\n+HASHSEED=1\n+export JSON_INDENT JSON_COMPACT HASHSEED""}<_**next**_>{""sha"": ""961558ca23ceca2ce6e4d07697f4018d8475f317"", ""filename"": ""test/suites/encoding-flags/indent-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/indent-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,2 +1,3 @@\n JSON_INDENT=4\n-export JSON_INDENT\n+HASHSEED=1\n+export JSON_INDENT HASHSEED""}<_**next**_>{""sha"": ""9120b03514ec614695c2d17841ba228b102c9db6"", ""filename"": ""test/suites/encoding-flags/object/env"", ""status"": ""added"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,2 @@\n+HASHSEED=1\n+export HASHSEED""}","static int hashtable_do_rehash(hashtable_t *hashtable)
{
    list_t *list, *next;
    pair_t *pair;
    size_t i, index, new_size;
 
     jsonp_free(hashtable->buckets);
 
    hashtable->order++;
    new_size = hashsize(hashtable->order);
 
     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));
     if(!hashtable->buckets)
         return -1;
 
    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
    }

    list = hashtable->list.next;
    list_init(&hashtable->list);

    for(; list != &hashtable->list; list = next) {
        next = list->next;
        pair = list_to_pair(list);
        index = pair->hash % new_size;
        insert_to_bucket(hashtable, &hashtable->buckets[index], &pair->list);
    }

    return 0;
}
","static int hashtable_do_rehash(hashtable_t *hashtable)
{
    list_t *list, *next;
    pair_t *pair;
    size_t i, index, new_size;
 
     jsonp_free(hashtable->buckets);
 
    hashtable->num_buckets++;
    new_size = num_buckets(hashtable);
 
     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));
     if(!hashtable->buckets)
         return -1;
 
    for(i = 0; i < num_buckets(hashtable); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
    }

    list = hashtable->list.next;
    list_init(&hashtable->list);

    for(; list != &hashtable->list; list = next) {
        next = list->next;
        pair = list_to_pair(list);
        index = pair->hash % new_size;
        insert_to_bucket(hashtable, &hashtable->buckets[index], &pair->list);
    }

    return 0;
}
",C,"    hashtable->order++;
    new_size = hashsize(hashtable->order);
    for(i = 0; i < hashsize(hashtable->order); i++)
","    hashtable->num_buckets++;
    new_size = num_buckets(hashtable);
    for(i = 0; i < num_buckets(hashtable); i++)
",,"@@ -5,8 +5,17 @@
  * it under the terms of the MIT license. See LICENSE for details.
  */
 
+#if HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include <stdlib.h>
 #include <string.h>
+
+#if HAVE_STDINT_H
+#include <stdint.h>
+#endif
+
 #include <jansson_config.h>   /* for JSON_INLINE */
 #include ""jansson_private.h""  /* for container_of() */
 #include ""hashtable.h""
@@ -15,24 +24,13 @@ typedef struct hashtable_list list_t;
 typedef struct hashtable_pair pair_t;
 typedef struct hashtable_bucket bucket_t;
 
-#define list_to_pair(list_)  container_of(list_, pair_t, list)
-
-/* From http://www.cse.yorku.ca/~oz/hash.html */
-static size_t hash_str(const void *ptr)
-{
-    const char *str = (const char *)ptr;
-
-    size_t hash = 5381;
-    size_t c;
+extern volatile uint32_t hashtable_seed;
 
-    while((c = (size_t)*str))
-    {
-        hash = ((hash << 5) + hash) + c;
-        str++;
-    }
+/* Implementation of the hash function */
+#include ""lookup3.h""
 
-    return hash;
-}
+#define list_to_pair(list_)  container_of(list_, pair_t, list)
+#define hash_str(key)        ((size_t)hashlittle((key), strlen(key), hashtable_seed))
 
 static JSON_INLINE void list_init(list_t *list)
 {
@@ -74,19 +72,6 @@ static void insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket,
     }
 }
 
-static const size_t primes[] = {
-    5, 13, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,
-    49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,
-    12582917, 25165843, 50331653, 100663319, 201326611, 402653189,
-    805306457, 1610612741
-};
-
-static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)
-{
-    return primes[hashtable->num_buckets];
-}
-
-
 static pair_t *hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket,
                                    const char *key, size_t hash)
 {
@@ -120,7 +105,7 @@ static int hashtable_do_del(hashtable_t *hashtable,
     bucket_t *bucket;
     size_t index;
 
-    index = hash % num_buckets(hashtable);
+    index = hash & hashmask(hashtable->order);
     bucket = &hashtable->buckets[index];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
@@ -167,14 +152,14 @@ static int hashtable_do_rehash(hashtable_t *hashtable)
 
     jsonp_free(hashtable->buckets);
 
-    hashtable->num_buckets++;
-    new_size = num_buckets(hashtable);
+    hashtable->order++;
+    new_size = hashsize(hashtable->order);
 
     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));
     if(!hashtable->buckets)
         return -1;
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -199,14 +184,14 @@ int hashtable_init(hashtable_t *hashtable)
     size_t i;
 
     hashtable->size = 0;
-    hashtable->num_buckets = 0;  /* index to primes[] */
-    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));
+    hashtable->order = 3;
+    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));
     if(!hashtable->buckets)
         return -1;
 
     list_init(&hashtable->list);
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -230,12 +215,12 @@ int hashtable_set(hashtable_t *hashtable,
     size_t hash, index;
 
     /* rehash if the load ratio exceeds 1 */
-    if(hashtable->size >= num_buckets(hashtable))
+    if(hashtable->size >= hashsize(hashtable->order))
         if(hashtable_do_rehash(hashtable))
             return -1;
 
     hash = hash_str(key);
-    index = hash % num_buckets(hashtable);
+    index = hash & hashmask(hashtable->order);
     bucket = &hashtable->buckets[index];
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
 
@@ -273,7 +258,7 @@ void *hashtable_get(hashtable_t *hashtable, const char *key)
     bucket_t *bucket;
 
     hash = hash_str(key);
-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)
@@ -294,7 +279,7 @@ void hashtable_clear(hashtable_t *hashtable)
 
     hashtable_do_clear(hashtable);
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -316,7 +301,7 @@ void *hashtable_iter_at(hashtable_t *hashtable, const char *key)
     bucket_t *bucket;
 
     hash = hash_str(key);
-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)",jansson,8f80c2d83808150724d31793e6ade92749b1faa4,b9c588de3deb4efdd7b9ec44aa79335dba11fd6b,1,"static int hashtable_do_rehash(hashtable_t *hashtable)
{
    list_t *list, *next;
    pair_t *pair;
    size_t i, index, new_size;
 
     jsonp_free(hashtable->buckets);
 
//flaw_line_below:
    hashtable->num_buckets++;
//flaw_line_below:
    new_size = num_buckets(hashtable);
//fix_flaw_line_below:
//    hashtable->order++;
//fix_flaw_line_below:
//    new_size = hashsize(hashtable->order);
 
     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));
     if(!hashtable->buckets)
         return -1;
 
//flaw_line_below:
    for(i = 0; i < num_buckets(hashtable); i++)
//fix_flaw_line_below:
//    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
    }

    list = hashtable->list.next;
    list_init(&hashtable->list);

    for(; list != &hashtable->list; list = next) {
        next = list->next;
        pair = list_to_pair(list);
        index = pair->hash % new_size;
        insert_to_bucket(hashtable, &hashtable->buckets[index], &pair->list);
    }

    return 0;
}
"
1966,179702,,Remote,Not required,Partial,CVE-2013-6401,https://www.cvedetails.com/cve/CVE-2013-6401/,CWE-310,Low,,,,2014-03-20,5.0,"Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document.",2014-05-23,DoS ,1,https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4,8f80c2d83808150724d31793e6ade92749b1faa4,"CVE-2013-6401: Change hash function, randomize hashes

Thanks to Florian Weimer and Eric Sesterhenn for reporting, reviewing
and testing.",1,src/hashtable.c,"{""sha"": ""1043c9ae4c0bc0c1f6a5913783973383832ff14b"", ""filename"": ""CMakeLists.txt"", ""status"": ""modified"", ""additions"": 39, ""deletions"": 10, ""changes"": 49, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/CMakeLists.txt"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/CMakeLists.txt"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/CMakeLists.txt?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -52,6 +52,8 @@ project (jansson C)\n \n # Options\n OPTION (BUILD_SHARED_LIBS \""Build shared libraries.\"" OFF)\n+OPTION (USE_URANDOM \""Use /dev/urandom to seed the hash function.\"" ON)\n+OPTION (USE_WINDOWS_CRYPTOAPI \""Use CryptGenRandom to seed the hash function.\"" ON)\n \n if (MSVC)\n    # This option must match the settings used in your program, in particular if you\n@@ -85,12 +87,12 @@ set (JANSSON_SOVERSION 4)\n # for CheckFunctionKeywords\n set(CMAKE_MODULE_PATH \""${CMAKE_CURRENT_SOURCE_DIR}/cmake\"")\n \n+INCLUDE (CheckCSourceCompiles)\n include (CheckFunctionExists)\n include (CheckFunctionKeywords)\n include (CheckIncludeFiles)\n include (CheckTypeSize)\n \n-\n if (MSVC)\n    # Turn off Microsofts \""security\"" warnings.\n    add_definitions( \""/W3 /D_CRT_SECURE_NO_WARNINGS /wd4005 /wd4996 /nologo\"" )\n@@ -106,14 +108,25 @@ if (CMAKE_COMPILER_IS_GNUCC OR CMAKE_COMPILER_IS_GNUCXX)\n    set(CMAKE_C_FLAGS \""-fPIC\"")\n endif()\n \n-   \n+check_include_files (endian.h HAVE_ENDIAN_H)\n+check_include_files (fcntl.h HAVE_FCNTL_H)\n+check_include_files (sched.h HAVE_SCHED_H)\n+check_include_files (unistd.h HAVE_UNISTD_H)\n+check_include_files (sys/param.h HAVE_SYS_PARAM_H)\n+check_include_files (sys/stat.h HAVE_SYS_STAT_H)\n+check_include_files (sys/time.h HAVE_SYS_TIME_H)\n+check_include_files (sys/time.h HAVE_SYS_TYPES_H)\n+\n+check_function_exists (close HAVE_CLOSE)\n+check_function_exists (getpid HAVE_GETPID)\n+check_function_exists (gettimeofday HAVE_GETTIMEOFDAY)\n+check_function_exists (open HAVE_OPEN)\n+check_function_exists (read HAVE_READ)\n+check_function_exists (sched_yield HAVE_SCHED_YIELD)\n \n # Check for the int-type includes\n-check_include_files (sys/types.h HAVE_SYS_TYPES_H)\n-check_include_files (inttypes.h HAVE_INTTYPES_H)\n check_include_files (stdint.h HAVE_STDINT_H)\n \n-\n # Check our 64 bit integer sizes\n check_type_size (__int64 __INT64)\n check_type_size (int64_t INT64_T)\n@@ -124,17 +137,32 @@ check_type_size (int32_t INT32_T)\n check_type_size (__int32 __INT32)\n check_type_size (\""long\"" LONG_INT)\n check_type_size (\""int\"" INT)\n-\n if (HAVE_INT32_T)\n    set (JSON_INT32 int32_t)\n elseif (HAVE___INT32)\n    set (JSON_INT32 __int32)\n-elseif (HAVE_LONG AND (${LONG_INT} EQUAL 4))\n+elseif (HAVE_LONG_INT AND (${LONG_INT} EQUAL 4))\n    set (JSON_INT32 long)\n elseif (HAVE_INT AND (${INT} EQUAL 4))\n    set (JSON_INT32 int)\n else ()\n-   message (FATAL_ERROR \""Could not detect a valid 32 bit integer type\"")\n+   message (FATAL_ERROR \""Could not detect a valid 32-bit integer type\"")\n+endif ()\n+\n+check_type_size (uint32_t UINT32_T)\n+check_type_size (__uint32 __UINT32)\n+check_type_size (\""unsigned long\"" UNSIGNED_LONG_INT)\n+check_type_size (\""unsigned int\"" UNSIGNED_INT)\n+if (HAVE_UINT32_T)\n+   set (JSON_UINT32 uint32_t)\n+elseif (HAVE___UINT32)\n+   set (JSON_UINT32 __uint32)\n+elseif (HAVE_UNSIGNED_LONG_INT AND (${UNSIGNED_LONG_INT} EQUAL 4))\n+   set (JSON_UINT32 \""unsigned long\"")\n+elseif (HAVE_UNSIGNED_INT AND (${UNSIGNED_INT} EQUAL 4))\n+   set (JSON_UINT32 \""unsigned int\"")\n+else ()\n+   message (FATAL_ERROR \""Could not detect a valid unsigned 32-bit integer type\"")\n endif ()\n \n # Check for ssize_t and SSIZE_T existance.\n@@ -206,11 +234,9 @@ else ()\n    set (JSON_HAVE_LOCALECONV 0)\n endif ()\n \n-\n # check if we have setlocale\n check_function_exists (setlocale HAVE_SETLOCALE)\n \n-\n # Check what the inline keyword is.\n # Note that the original JSON_INLINE was always set to just 'inline', so this goes further.\n check_function_keywords(\""inline\"")\n@@ -238,6 +264,9 @@ elseif (HAVE__SNPRINTF)\n    set (JSON_SNPRINTF _snprintf)\n endif ()\n \n+check_c_source_compiles (\""int main() { unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1); return 0; } \"" HAVE_SYNC_BUILTINS)\n+check_c_source_compiles (\""int main() { char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE); return 0; }\"" HAVE_ATOMIC_BUILTINS)\n+\n # Create pkg-conf file.\n # (We use the same files as ./configure does, so we\n #  have to defined the same variables used there).""}<_**next**_>{""sha"": ""b27b9a3a849e94686aa648c1ec4d1bd4c8e35445"", ""filename"": ""cmake/config.h.cmake"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 21, ""changes"": 46, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/cmake/config.h.cmake"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/cmake/config.h.cmake"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/cmake/config.h.cmake?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,35 +1,36 @@\n-/* Reduced down to the defines that are actually used in the code */\n-\n-/* Define to 1 if you have the <inttypes.h> (and friends) header file. */\n-#cmakedefine HAVE_INTTYPES_H 1\n-#cmakedefine HAVE_STDINT_H 1\n+#cmakedefine HAVE_ENDIAN_H 1\n+#cmakedefine HAVE_FCNTL_H 1\n+#cmakedefine HAVE_SCHED_H 1\n+#cmakedefine HAVE_UNISTD_H 1\n+#cmakedefine HAVE_SYS_PARAM_H 1\n+#cmakedefine HAVE_SYS_STAT_H 1\n+#cmakedefine HAVE_SYS_TIME_H 1\n #cmakedefine HAVE_SYS_TYPES_H 1\n+#cmakedefine HAVE_STDINT_H 1\n \n-/* We must include this here, as in (eg) utf.h it will want to use\n-   the integer type, which in MSVC2010 will be in stdint.h\n-   (there is no inttypes.h in MSVC2010) */\n-#if defined(HAVE_STDINT_H)\n-#  include <stdint.h>\n-#elif defined(HAVE_INTTYPES_H)\n-#  include <inttypes.h>\n-#elif defined(HAVE_SYS_TYPES_H)\n-#  include <sys/types.h>\n-#endif\n+#cmakedefine HAVE_CLOSE 1\n+#cmakedefine HAVE_GETPID 1\n+#cmakedefine HAVE_GETTIMEOFDAY 1\n+#cmakedefine HAVE_OPEN 1\n+#cmakedefine HAVE_READ 1\n+#cmakedefine HAVE_SCHED_YIELD 1\n \n-/* Define to 1 if you have the <locale.h> header file. */\n-#cmakedefine HAVE_LOCALE_H 1\n+#cmakedefine HAVE_SYNC_BUILTINS 1\n+#cmakedefine HAVE_ATOMIC_BUILTINS 1\n \n-/* Define to 1 if you have the 'setlocale' function. */\n+#cmakedefine HAVE_LOCALE_H 1\n #cmakedefine HAVE_SETLOCALE 1\n \n-/* Define to the type of a signed integer type of width exactly 32 bits if\n-   such a type exists and the standard includes do not define it. */\n #cmakedefine HAVE_INT32_T 1\n-\n #ifndef HAVE_INT32_T\n #  define int32_t @JSON_INT32@\n #endif\n \n+#cmakedefine HAVE_UINT32_T 1\n+#ifndef HAVE_UINT32_T\n+#  define uint32_t @JSON_UINT32@\n+#endif\n+\n #cmakedefine HAVE_SSIZE_T 1\n \n #ifndef HAVE_SSIZE_T\n@@ -43,3 +44,6 @@\n #endif\n \n #cmakedefine HAVE_VSNPRINTF\n+\n+#cmakedefine USE_URANDOM 1\n+#cmakedefine USE_WINDOWS_CRYPTOAPI 1""}<_**next**_>{""sha"": ""113cb85e17a15f2fac83b528fe1880bc99481ccb"", ""filename"": ""configure.ac"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 2, ""changes"": 50, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/configure.ac"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/configure.ac"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/configure.ac?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -14,10 +14,11 @@ AM_CONDITIONAL([GCC], [test x$GCC = xyes])\n # Checks for libraries.\n \n # Checks for header files.\n-AC_CHECK_HEADERS([locale.h])\n+AC_CHECK_HEADERS([endian.h fcntl.h locale.h sched.h unistd.h sys/param.h sys/stat.h sys/time.h sys/types.h])\n \n # Checks for typedefs, structures, and compiler characteristics.\n AC_TYPE_INT32_T\n+AC_TYPE_UINT32_T\n AC_TYPE_LONG_LONG_INT\n \n AC_C_INLINE\n@@ -29,7 +30,31 @@ esac\n AC_SUBST([json_inline])\n \n # Checks for library functions.\n-AC_CHECK_FUNCS([strtoll localeconv])\n+AC_CHECK_FUNCS([close getpid gettimeofday localeconv open read sched_yield strtoll])\n+\n+AC_MSG_CHECKING([for gcc __sync builtins])\n+have_sync_builtins=no\n+AC_TRY_LINK(\n+  [], [unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1);],\n+  [have_sync_builtins=yes],\n+)\n+if test \""x$have_sync_builtins\"" = \""xyes\""; then\n+  AC_DEFINE([HAVE_SYNC_BUILTINS], [1],\n+    [Define to 1 if gcc's __sync builtins are available])\n+fi\n+AC_MSG_RESULT([$have_sync_builtins])\n+\n+AC_MSG_CHECKING([for gcc __atomic builtins])\n+have_atomic_builtins=no\n+AC_TRY_LINK(\n+  [], [char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE);],\n+  [have_atomic_builtins=yes],\n+)\n+if test \""x$have_atomic_builtins\"" = \""xyes\""; then\n+  AC_DEFINE([HAVE_ATOMIC_BUILTINS], [1],\n+    [Define to 1 if gcc's __atomic builtins are available])\n+fi\n+AC_MSG_RESULT([$have_atomic_builtins])\n \n case \""$ac_cv_type_long_long_int$ac_cv_func_strtoll\"" in\n      yesyes) json_have_long_long=1;;\n@@ -43,6 +68,27 @@ case \""$ac_cv_header_locale_h$ac_cv_func_localeconv\"" in\n esac\n AC_SUBST([json_have_localeconv])\n \n+# Features\n+AC_ARG_ENABLE([urandom],\n+  [AS_HELP_STRING([--disable-urandom],\n+    [Don't use /dev/urandom to seed the hash function])],\n+  [use_urandom=$enableval], [use_urandom=yes])\n+\n+if test \""x$use_urandom\"" = xyes; then\n+AC_DEFINE([USE_URANDOM], [1],\n+  [Define to 1 if /dev/urandom should be used for seeding the hash function])\n+fi\n+\n+AC_ARG_ENABLE([windows-cryptoapi],\n+  [AS_HELP_STRING([--disable-windows-cryptoapi],\n+    [Don't use CryptGenRandom to seed the hash function])],\n+  [use_windows_cryptoapi=$enableval], [use_windows_cryptoapi=yes])\n+\n+if test \""x$use_windows_cryptoapi\"" = xyes; then\n+AC_DEFINE([USE_WINDOWS_CRYPTOAPI], [1],\n+  [Define to 1 if CryptGenRandom should be used for seeding the hash function])\n+fi\n+\n AC_CONFIG_FILES([\n         jansson.pc\n         Makefile""}<_**next**_>{""sha"": ""b4af562e84b5ed9dba1107af7d1768dcdb0b9a95"", ""filename"": ""src/Makefile.am"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/Makefile.am"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/Makefile.am?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -8,6 +8,7 @@ libjansson_la_SOURCES = \\\n \terror.c \\\n \thashtable.c \\\n \thashtable.h \\\n+\thashtable_seed.c \\\n \tjansson_private.h \\\n \tload.c \\\n \tmemory.c \\""}<_**next**_>{""sha"": ""abd4bf11fe7a393fcf3d533b952aa8b5efa4ea30"", ""filename"": ""src/hashtable.c"", ""status"": ""modified"", ""additions"": 26, ""deletions"": 41, ""changes"": 67, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -5,8 +5,17 @@\n  * it under the terms of the MIT license. See LICENSE for details.\n  */\n \n+#if HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stdlib.h>\n #include <string.h>\n+\n+#if HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include <jansson_config.h>   /* for JSON_INLINE */\n #include \""jansson_private.h\""  /* for container_of() */\n #include \""hashtable.h\""\n@@ -15,24 +24,13 @@ typedef struct hashtable_list list_t;\n typedef struct hashtable_pair pair_t;\n typedef struct hashtable_bucket bucket_t;\n \n-#define list_to_pair(list_)  container_of(list_, pair_t, list)\n-\n-/* From http://www.cse.yorku.ca/~oz/hash.html */\n-static size_t hash_str(const void *ptr)\n-{\n-    const char *str = (const char *)ptr;\n-\n-    size_t hash = 5381;\n-    size_t c;\n+extern volatile uint32_t hashtable_seed;\n \n-    while((c = (size_t)*str))\n-    {\n-        hash = ((hash << 5) + hash) + c;\n-        str++;\n-    }\n+/* Implementation of the hash function */\n+#include \""lookup3.h\""\n \n-    return hash;\n-}\n+#define list_to_pair(list_)  container_of(list_, pair_t, list)\n+#define hash_str(key)        ((size_t)hashlittle((key), strlen(key), hashtable_seed))\n \n static JSON_INLINE void list_init(list_t *list)\n {\n@@ -74,19 +72,6 @@ static void insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket,\n     }\n }\n \n-static const size_t primes[] = {\n-    5, 13, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,\n-    49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,\n-    12582917, 25165843, 50331653, 100663319, 201326611, 402653189,\n-    805306457, 1610612741\n-};\n-\n-static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)\n-{\n-    return primes[hashtable->num_buckets];\n-}\n-\n-\n static pair_t *hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket,\n                                    const char *key, size_t hash)\n {\n@@ -120,7 +105,7 @@ static int hashtable_do_del(hashtable_t *hashtable,\n     bucket_t *bucket;\n     size_t index;\n \n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n@@ -167,14 +152,14 @@ static int hashtable_do_rehash(hashtable_t *hashtable)\n \n     jsonp_free(hashtable->buckets);\n \n-    hashtable->num_buckets++;\n-    new_size = num_buckets(hashtable);\n+    hashtable->order++;\n+    new_size = hashsize(hashtable->order);\n \n     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -199,14 +184,14 @@ int hashtable_init(hashtable_t *hashtable)\n     size_t i;\n \n     hashtable->size = 0;\n-    hashtable->num_buckets = 0;  /* index to primes[] */\n-    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));\n+    hashtable->order = 3;\n+    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n     list_init(&hashtable->list);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -230,12 +215,12 @@ int hashtable_set(hashtable_t *hashtable,\n     size_t hash, index;\n \n     /* rehash if the load ratio exceeds 1 */\n-    if(hashtable->size >= num_buckets(hashtable))\n+    if(hashtable->size >= hashsize(hashtable->order))\n         if(hashtable_do_rehash(hashtable))\n             return -1;\n \n     hash = hash_str(key);\n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n \n@@ -273,7 +258,7 @@ void *hashtable_get(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)\n@@ -294,7 +279,7 @@ void hashtable_clear(hashtable_t *hashtable)\n \n     hashtable_do_clear(hashtable);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -316,7 +301,7 @@ void *hashtable_iter_at(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)""}<_**next**_>{""sha"": ""469c6ecd869c4698f650fa81983bb3ee03d47fab"", ""filename"": ""src/hashtable.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -32,14 +32,15 @@ struct hashtable_bucket {\n typedef struct hashtable {\n     size_t size;\n     struct hashtable_bucket *buckets;\n-    size_t num_buckets;  /* index to primes[] */\n+    size_t order;  /* hashtable has pow(2, order) buckets */\n     struct hashtable_list list;\n } hashtable_t;\n \n \n #define hashtable_key_to_iter(key_) \\\n     (&(container_of(key_, struct hashtable_pair, key)->list))\n \n+\n /**\n  * hashtable_init - Initialize a hashtable object\n  *""}<_**next**_>{""sha"": ""a07d145d10df35b933c1441dcbf42d3316b78ca5"", ""filename"": ""src/hashtable_seed.c"", ""status"": ""added"", ""additions"": 278, ""deletions"": 0, ""changes"": 278, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable_seed.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable_seed.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable_seed.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,278 @@\n+/* Generate sizeof(uint32_t) bytes of as random data as possible to seed\n+   the hash function.\n+*/\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#include <stdio.h>\n+#include <time.h>\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n+#ifdef HAVE_FCNTL_H\n+#include <fcntl.h>\n+#endif\n+\n+#ifdef HAVE_SCHED_H\n+#include <sched.h>\n+#endif\n+\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+\n+#ifdef HAVE_SYS_STAT_H\n+#include <sys/stat.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TIME_H\n+#include <sys/time.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TYPES_H\n+#include <sys/types.h>\n+#endif\n+\n+#if defined(_WIN32)\n+/* For _getpid() */\n+#include <process.h>\n+#endif\n+\n+#include \""jansson.h\""\n+\n+\n+static uint32_t buf_to_uint32(char *data) {\n+    size_t i;\n+    uint32_t result = 0;\n+\n+    for (i = 0; i < sizeof(uint32_t); i++)\n+        result = (result << 8) | (unsigned char)data[i];\n+\n+    return result;\n+}\n+\n+\n+\n+/* /dev/urandom */\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+static int seed_from_urandom(uint32_t *seed) {\n+    /* Use unbuffered I/O if we have open(), close() and read(). Otherwise\n+       fall back to fopen() */\n+\n+    char data[sizeof(uint32_t)];\n+    int ok;\n+\n+#if defined(HAVE_OPEN) && defined(HAVE_CLOSE) && defined(HAVE_READ)\n+    int urandom;\n+    urandom = open(\""/dev/urandom\"", O_RDONLY);\n+    if (urandom == -1)\n+        return 1;\n+\n+    ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);\n+    close(urandom);\n+#else\n+    FILE *urandom;\n+\n+    urandom = fopen(\""/dev/urandom\"", \""rb\"");\n+    if (!urandom)\n+        return 1;\n+\n+    ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);\n+    fclose(urandom);\n+#endif\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32(data);\n+    return 0;\n+}\n+#endif\n+\n+/* Windows Crypto API */\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+#include <windows.h>\n+#include <wincrypt.h>\n+\n+typedef BOOL (WINAPI *CRYPTACQUIRECONTEXTA)(HCRYPTPROV *phProv, LPCSTR pszContainer, LPCSTR pszProvider, DWORD dwProvType, DWORD dwFlags);\n+typedef BOOL (WINAPI *CRYPTGENRANDOM)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);\n+typedef BOOL (WINAPI *CRYPTRELEASECONTEXT)(HCRYPTPROV hProv, DWORD dwFlags);\n+\n+static int seed_from_windows_cryptoapi(uint32_t *seed)\n+{\n+    HINSTANCE hAdvAPI32 = NULL;\n+    CRYPTACQUIRECONTEXTA pCryptAcquireContext = NULL;\n+    CRYPTGENRANDOM pCryptGenRandom = NULL;\n+    CRYPTRELEASECONTEXT pCryptReleaseContext = NULL;\n+    HCRYPTPROV hCryptProv = 0;\n+    BYTE data[sizeof(uint32_t)];\n+    int ok;\n+\n+    hAdvAPI32 = GetModuleHandle(\""advapi32.dll\"");\n+    if(hAdvAPI32 == NULL)\n+        return 1;\n+\n+    pCryptAcquireContext = (CRYPTACQUIRECONTEXTA)GetProcAddress(hAdvAPI32, \""CryptAcquireContextA\"");\n+    if (!pCryptAcquireContext)\n+        return 1;\n+\n+    pCryptGenRandom = (CRYPTGENRANDOM)GetProcAddress(hAdvAPI32, \""CryptGenRandom\"");\n+    if (!pCryptGenRandom)\n+        return 1;\n+\n+    pCryptReleaseContext = (CRYPTRELEASECONTEXT)GetProcAddress(hAdvAPI32, \""CryptReleaseContext\"");\n+    if (!pCryptReleaseContext)\n+        return 1;\n+\n+    if (!pCryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))\n+        return 1;\n+\n+    ok = CryptGenRandom(hCryptProv, sizeof(uint32_t), data);\n+    pCryptReleaseContext(hCryptProv, 0);\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32((char *)data);\n+    return 0;\n+}\n+#endif\n+\n+/* gettimeofday() and getpid() */\n+static int seed_from_timestamp_and_pid(uint32_t *seed) {\n+#ifdef HAVE_GETTIMEOFDAY\n+    /* XOR of seconds and microseconds */\n+    struct timeval tv;\n+    gettimeofday(&tv, NULL);\n+    *seed = (uint32_t)tv.tv_sec ^ (uint32_t)tv.tv_usec;\n+#else\n+    /* Seconds only */\n+    *seed = (uint32_t)time(NULL);\n+#endif\n+\n+    /* XOR with PID for more randomness */\n+#if defined(_WIN32)\n+    *seed ^= (uint32_t)_getpid();\n+#elif defined(HAVE_GETPID)\n+    *seed ^= (uint32_t)getpid();\n+#endif\n+\n+    return 0;\n+}\n+\n+static uint32_t generate_seed() {\n+    uint32_t seed;\n+    int done = 0;\n+\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+    if (!done && seed_from_urandom(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+    if (!done && seed_from_windows_cryptoapi(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+    if (!done) {\n+        /* Fall back to timestamp and PID if no better randomness is\n+           available */\n+        seed_from_timestamp_and_pid(&seed);\n+    }\n+\n+    /* Make sure the seed is never zero */\n+    if (seed == 0)\n+        seed = 1;\n+\n+    return seed;\n+}\n+\n+\n+volatile uint32_t hashtable_seed = 0;\n+\n+#if defined(HAVE_ATOMIC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+static volatile char seed_initialized = 0;\n+\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (__atomic_test_and_set(&seed_initialized, __ATOMIC_RELAXED) == 0) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            __atomic_store_n(&hashtable_seed, new_seed, __ATOMIC_ACQ_REL);\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            } while(__atomic_load_n(&hashtable_seed, __ATOMIC_ACQUIRE) == 0);\n+        }\n+    }\n+}\n+#elif defined(HAVE_SYNC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0) {\n+            /* Explicit synchronization fences are not supported by the\n+               __sync builtins, so every thread getting here has to\n+               generate the seed value.\n+            */\n+            new_seed = generate_seed();\n+        }\n+\n+        do {\n+            if (__sync_bool_compare_and_swap(&hashtable_seed, 0, new_seed)) {\n+                /* We were the first to seed */\n+                break;\n+            } else {\n+                /* Wait for another thread to do the seeding */\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            }\n+        } while(hashtable_seed == 0);\n+    }\n+}\n+#elif defined(_WIN32)\n+static long seed_initialized = 0;\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (InterlockedIncrement(&seed_initialized) == 1) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            hashtable_seed = new_seed;\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+                SwitchToThread();\n+            } while (hashtable_seed == 0);\n+        }\n+    }\n+}\n+#else\n+/* Fall back to a thread-unsafe version */\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0)\n+            new_seed = generate_seed();\n+\n+        hashtable_seed = new_seed;\n+    }\n+}\n+#endif""}<_**next**_>{""sha"": ""19096d4201e6b13f8c56765116865c71f67e9696"", ""filename"": ""src/jansson.def"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.def"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.def"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/jansson.def?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -41,6 +41,7 @@ EXPORTS\n     json_object_iter_value\n     json_object_iter_set_new\n     json_object_key_to_iter\n+    json_object_seed\n     json_dumps\n     json_dumpf\n     json_dump_file""}<_**next**_>{""sha"": ""ea230852a629e55457fba2d00e3edd8a4ad4fcec"", ""filename"": ""src/jansson.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/jansson.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -126,6 +126,7 @@ typedef struct {\n \n /* getters, setters, manipulation */\n \n+void json_object_seed(size_t seed);\n size_t json_object_size(const json_t *object);\n json_t *json_object_get(const json_t *object, const char *key);\n int json_object_set_new(json_t *object, const char *key, json_t *value);""}<_**next**_>{""sha"": ""dc76138c940516e9590784825d28d040fd1a8b25"", ""filename"": ""src/lookup3.h"", ""status"": ""added"", ""additions"": 366, ""deletions"": 0, ""changes"": 366, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/lookup3.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/lookup3.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/lookup3.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,366 @@\n+/*\n+-------------------------------------------------------------------------------\n+lookup3.c, by Bob Jenkins, May 2006, Public Domain.\n+\n+These are functions for producing 32-bit hashes for hash table lookup.\n+hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final() \n+are externally useful functions.  Routines to test the hash are included \n+if SELF_TEST is defined.  You can use this free for any purpose.  It's in\n+the public domain.  It has no warranty.\n+\n+You probably want to use hashlittle().  hashlittle() and hashbig()\n+hash byte arrays.  hashlittle() is is faster than hashbig() on\n+little-endian machines.  Intel and AMD are little-endian machines.\n+On second thought, you probably want hashlittle2(), which is identical to\n+hashlittle() except it returns two 32-bit hashes for the price of one.  \n+You could implement hashbig2() if you wanted but I haven't bothered here.\n+\n+If you want to find a hash of, say, exactly 7 integers, do\n+  a = i1;  b = i2;  c = i3;\n+  mix(a,b,c);\n+  a += i4; b += i5; c += i6;\n+  mix(a,b,c);\n+  a += i7;\n+  final(a,b,c);\n+then use c as the hash value.  If you have a variable length array of\n+4-byte integers to hash, use hashword().  If you have a byte array (like\n+a character string), use hashlittle().  If you have several byte arrays, or\n+a mix of things, see the comments above hashlittle().  \n+\n+Why is this so big?  I read 12 bytes at a time into 3 4-byte integers, \n+then mix those integers.  This is fast (you can do a lot more thorough\n+mixing with 12*3 instructions on 3 integers than you can with 3 instructions\n+on 1 byte), but shoehorning those bytes into integers efficiently is messy.\n+-------------------------------------------------------------------------------\n+*/\n+\n+#include <stdlib.h>\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>     /* defines uint32_t etc */\n+#endif\n+\n+#ifdef HAVE_SYS_PARAM_H\n+#include <sys/param.h>  /* attempt to define endianness */\n+#endif\n+\n+#ifdef HAVE_ENDIAN_H\n+# include <endian.h>    /* attempt to define endianness */\n+#endif\n+\n+/*\n+ * My best guess at if you are big-endian or little-endian.  This may\n+ * need adjustment.\n+ */\n+#if (defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && \\\n+     __BYTE_ORDER == __LITTLE_ENDIAN) || \\\n+    (defined(i386) || defined(__i386__) || defined(__i486__) || \\\n+     defined(__i586__) || defined(__i686__) || defined(vax) || defined(MIPSEL))\n+# define HASH_LITTLE_ENDIAN 1\n+# define HASH_BIG_ENDIAN 0\n+#elif (defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && \\\n+       __BYTE_ORDER == __BIG_ENDIAN) || \\\n+      (defined(sparc) || defined(POWERPC) || defined(mc68000) || defined(sel))\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 1\n+#else\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 0\n+#endif\n+\n+#define hashsize(n) ((uint32_t)1<<(n))\n+#define hashmask(n) (hashsize(n)-1)\n+#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n+\n+/*\n+-------------------------------------------------------------------------------\n+mix -- mix 3 32-bit values reversibly.\n+\n+This is reversible, so any information in (a,b,c) before mix() is\n+still in (a,b,c) after mix().\n+\n+If four pairs of (a,b,c) inputs are run through mix(), or through\n+mix() in reverse, there are at least 32 bits of the output that\n+are sometimes the same for one pair and different for another pair.\n+This was tested for:\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+Some k values for my \""a-=c; a^=rot(c,k); c+=b;\"" arrangement that\n+satisfy this are\n+    4  6  8 16 19  4\n+    9 15  3 18 27 15\n+   14  9  3  7 17  3\n+Well, \""9 15 3 18 27 15\"" didn't quite get 32 bits diffing\n+for \""differ\"" defined as + with a one-bit base and a two-bit delta.  I\n+used http://burtleburtle.net/bob/hash/avalanche.html to choose \n+the operations, constants, and arrangements of the variables.\n+\n+This does not achieve avalanche.  There are input bits of (a,b,c)\n+that fail to affect some output bits of (a,b,c), especially of a.  The\n+most thoroughly mixed value is c, but it doesn't really even achieve\n+avalanche in c.\n+\n+This allows some parallelism.  Read-after-writes are good at doubling\n+the number of bits affected, so the goal of mixing pulls in the opposite\n+direction as the goal of parallelism.  I did what I could.  Rotates\n+seem to cost as much as shifts on every machine I could lay my hands\n+on, and rotates are much kinder to the top and bottom bits, so I used\n+rotates.\n+-------------------------------------------------------------------------------\n+*/\n+#define mix(a,b,c) \\\n+{ \\\n+  a -= c;  a ^= rot(c, 4);  c += b; \\\n+  b -= a;  b ^= rot(a, 6);  a += c; \\\n+  c -= b;  c ^= rot(b, 8);  b += a; \\\n+  a -= c;  a ^= rot(c,16);  c += b; \\\n+  b -= a;  b ^= rot(a,19);  a += c; \\\n+  c -= b;  c ^= rot(b, 4);  b += a; \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+final -- final mixing of 3 32-bit values (a,b,c) into c\n+\n+Pairs of (a,b,c) values differing in only a few bits will usually\n+produce values of c that look totally different.  This was tested for\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+These constants passed:\n+ 14 11 25 16 4 14 24\n+ 12 14 25 16 4 14 24\n+and these came close:\n+  4  8 15 26 3 22 24\n+ 10  8 15 26 3 22 24\n+ 11  8 15 26 3 22 24\n+-------------------------------------------------------------------------------\n+*/\n+#define final(a,b,c) \\\n+{ \\\n+  c ^= b; c -= rot(b,14); \\\n+  a ^= c; a -= rot(c,11); \\\n+  b ^= a; b -= rot(a,25); \\\n+  c ^= b; c -= rot(b,16); \\\n+  a ^= c; a -= rot(c,4);  \\\n+  b ^= a; b -= rot(a,14); \\\n+  c ^= b; c -= rot(b,24); \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+hashlittle() -- hash a variable-length key into a 32-bit value\n+  k       : the key (the unaligned variable-length array of bytes)\n+  length  : the length of the key, counting by bytes\n+  initval : can be any 4-byte value\n+Returns a 32-bit value.  Every bit of the key affects every bit of\n+the return value.  Two keys differing by one or two bits will have\n+totally different hash values.\n+\n+The best hash table sizes are powers of 2.  There is no need to do\n+mod a prime (mod is sooo slow!).  If you need less than 32 bits,\n+use a bitmask.  For example, if you need only 10 bits, do\n+  h = (h & hashmask(10));\n+In which case, the hash table should have hashsize(10) elements.\n+\n+If you are hashing n strings (uint8_t **)k, do it like this:\n+  for (i=0, h=0; i<n; ++i) h = hashlittle( k[i], len[i], h);\n+\n+By Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this\n+code any way you wish, private, educational, or commercial.  It's free.\n+\n+Use for hash table lookup, or anything where one collision in 2^^32 is\n+acceptable.  Do NOT use for cryptographic purposes.\n+-------------------------------------------------------------------------------\n+*/\n+\n+static uint32_t hashlittle(const void *key, size_t length, uint32_t initval)\n+{\n+  uint32_t a,b,c;                                          /* internal state */\n+  union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */\n+\n+  /* Set up the internal state */\n+  a = b = c = 0xdeadbeef + ((uint32_t)length) + initval;\n+\n+  u.ptr = key;\n+  if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0)) {\n+    const uint32_t *k = (const uint32_t *)key;         /* read 32-bit chunks */\n+\n+#ifdef VALGRIND\n+    const uint8_t  *k8;\n+#endif\n+\n+    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      b += k[1];\n+      c += k[2];\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 3;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    /* \n+     * \""k[2]&0xffffff\"" actually reads beyond the end of the string, but\n+     * then masks off the part it's not allowed to read.  Because the\n+     * string is aligned, the masked-off tail is in the same word as the\n+     * rest of the string.  Every machine with memory protection I've seen\n+     * does it on word boundaries, so is OK with this.  But VALGRIND will\n+     * still catch it and complain.  The masking trick does make the hash\n+     * noticably faster for short strings (like English words).\n+     */\n+#ifndef VALGRIND\n+\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n+    case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n+    case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n+    case 6 : b+=k[1]&0xffff; a+=k[0]; break;\n+    case 5 : b+=k[1]&0xff; a+=k[0]; break;\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=k[0]&0xffffff; break;\n+    case 2 : a+=k[0]&0xffff; break;\n+    case 1 : a+=k[0]&0xff; break;\n+    case 0 : return c;              /* zero length strings require no mixing */\n+    }\n+\n+#else /* make valgrind happy */\n+\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=((uint32_t)k8[10])<<16;  /* fall through */\n+    case 10: c+=((uint32_t)k8[9])<<8;    /* fall through */\n+    case 9 : c+=k8[8];                   /* fall through */\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;   /* fall through */\n+    case 6 : b+=((uint32_t)k8[5])<<8;    /* fall through */\n+    case 5 : b+=k8[4];                   /* fall through */\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;   /* fall through */\n+    case 2 : a+=((uint32_t)k8[1])<<8;    /* fall through */\n+    case 1 : a+=k8[0]; break;\n+    case 0 : return c;\n+    }\n+\n+#endif /* !valgrind */\n+\n+  } else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0)) {\n+    const uint16_t *k = (const uint16_t *)key;         /* read 16-bit chunks */\n+    const uint8_t  *k8;\n+\n+    /*--------------- all but last block: aligned reads and different mixing */\n+    while (length > 12)\n+    {\n+      a += k[0] + (((uint32_t)k[1])<<16);\n+      b += k[2] + (((uint32_t)k[3])<<16);\n+      c += k[4] + (((uint32_t)k[5])<<16);\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 6;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[4]+(((uint32_t)k[5])<<16);\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 11: c+=((uint32_t)k8[10])<<16;     /* fall through */\n+    case 10: c+=k[4];\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 9 : c+=k8[8];                      /* fall through */\n+    case 8 : b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;      /* fall through */\n+    case 6 : b+=k[2];\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 5 : b+=k8[4];                      /* fall through */\n+    case 4 : a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;      /* fall through */\n+    case 2 : a+=k[0];\n+             break;\n+    case 1 : a+=k8[0];\n+             break;\n+    case 0 : return c;                     /* zero length requires no mixing */\n+    }\n+\n+  } else {                        /* need to read the key one byte at a time */\n+    const uint8_t *k = (const uint8_t *)key;\n+\n+    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      a += ((uint32_t)k[1])<<8;\n+      a += ((uint32_t)k[2])<<16;\n+      a += ((uint32_t)k[3])<<24;\n+      b += k[4];\n+      b += ((uint32_t)k[5])<<8;\n+      b += ((uint32_t)k[6])<<16;\n+      b += ((uint32_t)k[7])<<24;\n+      c += k[8];\n+      c += ((uint32_t)k[9])<<8;\n+      c += ((uint32_t)k[10])<<16;\n+      c += ((uint32_t)k[11])<<24;\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 12;\n+    }\n+\n+    /*-------------------------------- last block: affect all 32 bits of (c) */\n+    switch(length)                   /* all the case statements fall through */\n+    {\n+    case 12: c+=((uint32_t)k[11])<<24;\n+    case 11: c+=((uint32_t)k[10])<<16;\n+    case 10: c+=((uint32_t)k[9])<<8;\n+    case 9 : c+=k[8];\n+    case 8 : b+=((uint32_t)k[7])<<24;\n+    case 7 : b+=((uint32_t)k[6])<<16;\n+    case 6 : b+=((uint32_t)k[5])<<8;\n+    case 5 : b+=k[4];\n+    case 4 : a+=((uint32_t)k[3])<<24;\n+    case 3 : a+=((uint32_t)k[2])<<16;\n+    case 2 : a+=((uint32_t)k[1])<<8;\n+    case 1 : a+=k[0];\n+             break;\n+    case 0 : return c;\n+    }\n+  }\n+\n+  final(a,b,c);\n+  return c;\n+}""}<_**next**_>{""sha"": ""b4f109143031b2481a0d32a332c88cc1cc96c688"", ""filename"": ""src/utf.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 16, ""changes"": 20, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/utf.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/utf.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/utf.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -10,23 +10,11 @@\n \n #ifdef HAVE_CONFIG_H\n #include <config.h>\n+#endif\n \n-#ifdef HAVE_INTTYPES_H\n-/* inttypes.h includes stdint.h in a standard environment, so there's\n-no need to include stdint.h separately. If inttypes.h doesn't define\n-int32_t, it's defined in config.h. */\n-#include <inttypes.h>\n-#endif /* HAVE_INTTYPES_H */\n-\n-#else /* !HAVE_CONFIG_H */\n-#ifdef _WIN32\n-typedef int int32_t;\n-#else /* !_WIN32 */\n-/* Assume a standard environment */\n-#include <inttypes.h>\n-#endif /* _WIN32 */\n-\n-#endif /* HAVE_CONFIG_H */\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n \n int utf8_encode(int codepoint, char *buffer, int *size);\n ""}<_**next**_>{""sha"": ""1b02d90aa885f1ede146bb2077d05c8bb9096565"", ""filename"": ""src/value.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/value.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/value.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/value.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -9,11 +9,19 @@\n #define _GNU_SOURCE\n #endif\n \n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stddef.h>\n #include <stdlib.h>\n #include <string.h>\n #include <math.h>\n \n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include \""jansson.h\""\n #include \""hashtable.h\""\n #include \""jansson_private.h\""\n@@ -36,11 +44,19 @@ static JSON_INLINE void json_init(json_t *json, json_type type)\n \n /*** object ***/\n \n+extern volatile uint32_t hashtable_seed;\n+\n json_t *json_object(void)\n {\n     json_object_t *object = jsonp_malloc(sizeof(json_object_t));\n     if(!object)\n         return NULL;\n+\n+    if (!hashtable_seed) {\n+        /* Autoseed */\n+        json_object_seed(0);\n+    }\n+\n     json_init(&object->json, JSON_OBJECT);\n \n     if(hashtable_init(&object->hashtable))""}<_**next**_>{""sha"": ""e2c54bd12bd7c22de7cc3533f010b26cc1c330b0"", ""filename"": ""test/bin/json_process.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 1, ""changes"": 16, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/bin/json_process.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/bin/json_process.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/bin/json_process.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -37,6 +37,8 @@ struct config {\n     int sort_keys;\n     int strip;\n     int use_env;\n+    int have_hashseed;\n+    int hashseed;\n } conf;\n \n #define l_isspace(c) ((c) == ' ' || (c) == '\\n' || (c) == '\\r' || (c) == '\\t')\n@@ -108,6 +110,12 @@ static void read_conf(FILE *conffile)\n             conf.sort_keys = atoi(val);\n         if (!strcmp(line, \""STRIP\""))\n             conf.strip = atoi(val);\n+        if (!strcmp(line, \""HASHSEED\"")) {\n+            conf.have_hashseed = 1;\n+            conf.hashseed = atoi(val);\n+        } else {\n+            conf.have_hashseed = 0;\n+        }\n     }\n \n     free(buffer);\n@@ -188,6 +196,9 @@ int use_conf(char *test_path)\n     if (conf.sort_keys)\n         flags |= JSON_SORT_KEYS;\n \n+    if (conf.have_hashseed)\n+        json_object_seed(conf.hashseed);\n+\n     if (conf.strip) {\n         /* Load to memory, strip leading and trailing whitespace */\n         buffer = loadfile(infile);\n@@ -265,7 +276,10 @@ int use_env()\n         flags |= JSON_PRESERVE_ORDER;\n \n     if(getenv_int(\""JSON_SORT_KEYS\""))\n-         flags |= JSON_SORT_KEYS;\n+        flags |= JSON_SORT_KEYS;\n+\n+    if(getenv(\""HASHSEED\""))\n+        json_object_seed(getenv_int(\""HASHSEED\""));\n \n     if(getenv_int(\""STRIP\"")) {\n         /* Load to memory, strip leading and trailing whitespace */""}<_**next**_>{""sha"": ""84b17466fd0a753b8cbd714d0236ed9072cdd536"", ""filename"": ""test/suites/api/test_memory_funcs.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_memory_funcs.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_memory_funcs.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/api/test_memory_funcs.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -24,13 +24,13 @@ static void create_and_free_complex_object()\n \n static void *my_malloc(size_t size)\n {\n-    malloc_called += 1;\n+    malloc_called = 1;\n     return malloc(size);\n }\n \n static void my_free(void *ptr)\n {\n-    free_called += 1;\n+    free_called = 1;\n     free(ptr);\n }\n \n@@ -39,7 +39,7 @@ static void test_simple()\n     json_set_alloc_funcs(my_malloc, my_free);\n     create_and_free_complex_object();\n \n-    if(malloc_called != 20 || free_called != 20)\n+    if(malloc_called != 1 || free_called != 1)\n         fail(\""Custom allocation failed\"");\n }\n ""}<_**next**_>{""sha"": ""92e5208224b75ab45d93672446279d598052a83e"", ""filename"": ""test/suites/api/test_object.c"", ""status"": ""modified"", ""additions"": 40, ""deletions"": 24, ""changes"": 64, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_object.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_object.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/api/test_object.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -249,7 +249,11 @@ static void test_set_nocheck()\n \n static void test_iterators()\n {\n+    int i;\n     json_t *object, *foo, *bar, *baz;\n+    const char *iter_keys[3];\n+    int have_key[3] = { 0, 0, 0 };\n+    json_t *iter_values[3];\n     void *iter;\n \n     if(json_object_iter(NULL))\n@@ -276,30 +280,50 @@ static void test_iterators()\n     iter = json_object_iter(object);\n     if(!iter)\n         fail(\""unable to get iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""a\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != foo)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[0] = json_object_iter_key(iter);\n+    iter_values[0] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""b\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != bar)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[1] = json_object_iter_key(iter);\n+    iter_values[1] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[2] = json_object_iter_key(iter);\n+    iter_values[2] = json_object_iter_value(iter);\n \n     if(json_object_iter_next(object, iter) != NULL)\n         fail(\""able to iterate over the end\"");\n \n+    /* Check that keys have correct values */\n+    for (i = 0; i < 3; i++) {\n+        if (strcmp(iter_keys[i], \""a\"") == 0) {\n+            if (iter_values[i] != foo)\n+                fail(\""wrong value for iter key a\"");\n+            else\n+                have_key[0] = 1;\n+        } else if (strcmp(iter_keys[i], \""b\"") == 0) {\n+            if (iter_values[i] != bar)\n+                fail(\""wrong value for iter key b\"");\n+            else\n+                have_key[1] = 1;\n+        } else if (strcmp(iter_keys[i], \""c\"") == 0) {\n+            if (iter_values[i] != baz)\n+                fail(\""wrong value for iter key c\"");\n+            else\n+                have_key[2] = 1;\n+        }\n+    }\n+\n+    /* Check that we got all keys */\n+    for(i = 0; i < 3; i++) {\n+        if(!have_key[i])\n+            fail(\""a key wasn't iterated over\"");\n+    }\n+\n     if(json_object_iter_at(object, \""foo\""))\n         fail(\""json_object_iter_at() succeeds for non-existent key\"");\n \n@@ -312,22 +336,14 @@ static void test_iterators()\n     if(json_object_iter_value(iter) != bar)\n         fail(\""iterating failed: wrong value\"");\n \n-    iter = json_object_iter_next(object, iter);\n-    if(!iter)\n-        fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\""iterating failed: wrong value\"");\n-\n-    if(json_object_iter_set(object, iter, bar))\n+    if(json_object_iter_set(object, iter, baz))\n         fail(\""unable to set value at iterator\"");\n \n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n+    if(strcmp(json_object_iter_key(iter), \""b\""))\n         fail(\""json_object_iter_key() fails after json_object_iter_set()\"");\n-    if(json_object_iter_value(iter) != bar)\n+    if(json_object_iter_value(iter) != baz)\n         fail(\""json_object_iter_value() fails after json_object_iter_set()\"");\n-    if(json_object_get(object, \""c\"") != bar)\n+    if(json_object_get(object, \""b\"") != baz)\n         fail(\""json_object_get() fails after json_object_iter_set()\"");\n \n     json_decref(object);""}<_**next**_>{""sha"": ""93cb33ddafeb9eef6ce7ad4709ce1bcbdf25b200"", ""filename"": ""test/suites/encoding-flags/compact-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/compact-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/compact-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/compact-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,2 +1,3 @@\n JSON_COMPACT=1\n-export JSON_COMPACT\n+HASHSEED=1\n+export JSON_COMPACT HASHSEED""}<_**next**_>{""sha"": ""c73acc1792963be8a5f41ff11f6e858506ada51d"", ""filename"": ""test/suites/encoding-flags/indent-compact-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-compact-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-compact-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/indent-compact-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,3 +1,4 @@\n JSON_INDENT=4\n JSON_COMPACT=1\n-export JSON_INDENT JSON_COMPACT\n+HASHSEED=1\n+export JSON_INDENT JSON_COMPACT HASHSEED""}<_**next**_>{""sha"": ""961558ca23ceca2ce6e4d07697f4018d8475f317"", ""filename"": ""test/suites/encoding-flags/indent-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/indent-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,2 +1,3 @@\n JSON_INDENT=4\n-export JSON_INDENT\n+HASHSEED=1\n+export JSON_INDENT HASHSEED""}<_**next**_>{""sha"": ""9120b03514ec614695c2d17841ba228b102c9db6"", ""filename"": ""test/suites/encoding-flags/object/env"", ""status"": ""added"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,2 @@\n+HASHSEED=1\n+export HASHSEED""}","void *hashtable_get(hashtable_t *hashtable, const char *key)
{
    pair_t *pair;
    size_t hash;
     bucket_t *bucket;
 
     hash = hash_str(key);
    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)
        return NULL;

    return pair->value;
}
","void *hashtable_get(hashtable_t *hashtable, const char *key)
{
    pair_t *pair;
    size_t hash;
     bucket_t *bucket;
 
     hash = hash_str(key);
    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)
        return NULL;

    return pair->value;
}
",C,"    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];
","    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
",,"@@ -5,8 +5,17 @@
  * it under the terms of the MIT license. See LICENSE for details.
  */
 
+#if HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include <stdlib.h>
 #include <string.h>
+
+#if HAVE_STDINT_H
+#include <stdint.h>
+#endif
+
 #include <jansson_config.h>   /* for JSON_INLINE */
 #include ""jansson_private.h""  /* for container_of() */
 #include ""hashtable.h""
@@ -15,24 +24,13 @@ typedef struct hashtable_list list_t;
 typedef struct hashtable_pair pair_t;
 typedef struct hashtable_bucket bucket_t;
 
-#define list_to_pair(list_)  container_of(list_, pair_t, list)
-
-/* From http://www.cse.yorku.ca/~oz/hash.html */
-static size_t hash_str(const void *ptr)
-{
-    const char *str = (const char *)ptr;
-
-    size_t hash = 5381;
-    size_t c;
+extern volatile uint32_t hashtable_seed;
 
-    while((c = (size_t)*str))
-    {
-        hash = ((hash << 5) + hash) + c;
-        str++;
-    }
+/* Implementation of the hash function */
+#include ""lookup3.h""
 
-    return hash;
-}
+#define list_to_pair(list_)  container_of(list_, pair_t, list)
+#define hash_str(key)        ((size_t)hashlittle((key), strlen(key), hashtable_seed))
 
 static JSON_INLINE void list_init(list_t *list)
 {
@@ -74,19 +72,6 @@ static void insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket,
     }
 }
 
-static const size_t primes[] = {
-    5, 13, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,
-    49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,
-    12582917, 25165843, 50331653, 100663319, 201326611, 402653189,
-    805306457, 1610612741
-};
-
-static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)
-{
-    return primes[hashtable->num_buckets];
-}
-
-
 static pair_t *hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket,
                                    const char *key, size_t hash)
 {
@@ -120,7 +105,7 @@ static int hashtable_do_del(hashtable_t *hashtable,
     bucket_t *bucket;
     size_t index;
 
-    index = hash % num_buckets(hashtable);
+    index = hash & hashmask(hashtable->order);
     bucket = &hashtable->buckets[index];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
@@ -167,14 +152,14 @@ static int hashtable_do_rehash(hashtable_t *hashtable)
 
     jsonp_free(hashtable->buckets);
 
-    hashtable->num_buckets++;
-    new_size = num_buckets(hashtable);
+    hashtable->order++;
+    new_size = hashsize(hashtable->order);
 
     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));
     if(!hashtable->buckets)
         return -1;
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -199,14 +184,14 @@ int hashtable_init(hashtable_t *hashtable)
     size_t i;
 
     hashtable->size = 0;
-    hashtable->num_buckets = 0;  /* index to primes[] */
-    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));
+    hashtable->order = 3;
+    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));
     if(!hashtable->buckets)
         return -1;
 
     list_init(&hashtable->list);
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -230,12 +215,12 @@ int hashtable_set(hashtable_t *hashtable,
     size_t hash, index;
 
     /* rehash if the load ratio exceeds 1 */
-    if(hashtable->size >= num_buckets(hashtable))
+    if(hashtable->size >= hashsize(hashtable->order))
         if(hashtable_do_rehash(hashtable))
             return -1;
 
     hash = hash_str(key);
-    index = hash % num_buckets(hashtable);
+    index = hash & hashmask(hashtable->order);
     bucket = &hashtable->buckets[index];
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
 
@@ -273,7 +258,7 @@ void *hashtable_get(hashtable_t *hashtable, const char *key)
     bucket_t *bucket;
 
     hash = hash_str(key);
-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)
@@ -294,7 +279,7 @@ void hashtable_clear(hashtable_t *hashtable)
 
     hashtable_do_clear(hashtable);
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -316,7 +301,7 @@ void *hashtable_iter_at(hashtable_t *hashtable, const char *key)
     bucket_t *bucket;
 
     hash = hash_str(key);
-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)",jansson,8f80c2d83808150724d31793e6ade92749b1faa4,b9c588de3deb4efdd7b9ec44aa79335dba11fd6b,1,"void *hashtable_get(hashtable_t *hashtable, const char *key)
{
    pair_t *pair;
    size_t hash;
     bucket_t *bucket;
 
     hash = hash_str(key);
//flaw_line_below:
    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
//fix_flaw_line_below:
//    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)
        return NULL;

    return pair->value;
}
"
1967,179703,,Remote,Not required,Partial,CVE-2013-6401,https://www.cvedetails.com/cve/CVE-2013-6401/,CWE-310,Low,,,,2014-03-20,5.0,"Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document.",2014-05-23,DoS ,3,https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4,8f80c2d83808150724d31793e6ade92749b1faa4,"CVE-2013-6401: Change hash function, randomize hashes

Thanks to Florian Weimer and Eric Sesterhenn for reporting, reviewing
and testing.",3,src/hashtable.c,"{""sha"": ""1043c9ae4c0bc0c1f6a5913783973383832ff14b"", ""filename"": ""CMakeLists.txt"", ""status"": ""modified"", ""additions"": 39, ""deletions"": 10, ""changes"": 49, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/CMakeLists.txt"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/CMakeLists.txt"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/CMakeLists.txt?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -52,6 +52,8 @@ project (jansson C)\n \n # Options\n OPTION (BUILD_SHARED_LIBS \""Build shared libraries.\"" OFF)\n+OPTION (USE_URANDOM \""Use /dev/urandom to seed the hash function.\"" ON)\n+OPTION (USE_WINDOWS_CRYPTOAPI \""Use CryptGenRandom to seed the hash function.\"" ON)\n \n if (MSVC)\n    # This option must match the settings used in your program, in particular if you\n@@ -85,12 +87,12 @@ set (JANSSON_SOVERSION 4)\n # for CheckFunctionKeywords\n set(CMAKE_MODULE_PATH \""${CMAKE_CURRENT_SOURCE_DIR}/cmake\"")\n \n+INCLUDE (CheckCSourceCompiles)\n include (CheckFunctionExists)\n include (CheckFunctionKeywords)\n include (CheckIncludeFiles)\n include (CheckTypeSize)\n \n-\n if (MSVC)\n    # Turn off Microsofts \""security\"" warnings.\n    add_definitions( \""/W3 /D_CRT_SECURE_NO_WARNINGS /wd4005 /wd4996 /nologo\"" )\n@@ -106,14 +108,25 @@ if (CMAKE_COMPILER_IS_GNUCC OR CMAKE_COMPILER_IS_GNUCXX)\n    set(CMAKE_C_FLAGS \""-fPIC\"")\n endif()\n \n-   \n+check_include_files (endian.h HAVE_ENDIAN_H)\n+check_include_files (fcntl.h HAVE_FCNTL_H)\n+check_include_files (sched.h HAVE_SCHED_H)\n+check_include_files (unistd.h HAVE_UNISTD_H)\n+check_include_files (sys/param.h HAVE_SYS_PARAM_H)\n+check_include_files (sys/stat.h HAVE_SYS_STAT_H)\n+check_include_files (sys/time.h HAVE_SYS_TIME_H)\n+check_include_files (sys/time.h HAVE_SYS_TYPES_H)\n+\n+check_function_exists (close HAVE_CLOSE)\n+check_function_exists (getpid HAVE_GETPID)\n+check_function_exists (gettimeofday HAVE_GETTIMEOFDAY)\n+check_function_exists (open HAVE_OPEN)\n+check_function_exists (read HAVE_READ)\n+check_function_exists (sched_yield HAVE_SCHED_YIELD)\n \n # Check for the int-type includes\n-check_include_files (sys/types.h HAVE_SYS_TYPES_H)\n-check_include_files (inttypes.h HAVE_INTTYPES_H)\n check_include_files (stdint.h HAVE_STDINT_H)\n \n-\n # Check our 64 bit integer sizes\n check_type_size (__int64 __INT64)\n check_type_size (int64_t INT64_T)\n@@ -124,17 +137,32 @@ check_type_size (int32_t INT32_T)\n check_type_size (__int32 __INT32)\n check_type_size (\""long\"" LONG_INT)\n check_type_size (\""int\"" INT)\n-\n if (HAVE_INT32_T)\n    set (JSON_INT32 int32_t)\n elseif (HAVE___INT32)\n    set (JSON_INT32 __int32)\n-elseif (HAVE_LONG AND (${LONG_INT} EQUAL 4))\n+elseif (HAVE_LONG_INT AND (${LONG_INT} EQUAL 4))\n    set (JSON_INT32 long)\n elseif (HAVE_INT AND (${INT} EQUAL 4))\n    set (JSON_INT32 int)\n else ()\n-   message (FATAL_ERROR \""Could not detect a valid 32 bit integer type\"")\n+   message (FATAL_ERROR \""Could not detect a valid 32-bit integer type\"")\n+endif ()\n+\n+check_type_size (uint32_t UINT32_T)\n+check_type_size (__uint32 __UINT32)\n+check_type_size (\""unsigned long\"" UNSIGNED_LONG_INT)\n+check_type_size (\""unsigned int\"" UNSIGNED_INT)\n+if (HAVE_UINT32_T)\n+   set (JSON_UINT32 uint32_t)\n+elseif (HAVE___UINT32)\n+   set (JSON_UINT32 __uint32)\n+elseif (HAVE_UNSIGNED_LONG_INT AND (${UNSIGNED_LONG_INT} EQUAL 4))\n+   set (JSON_UINT32 \""unsigned long\"")\n+elseif (HAVE_UNSIGNED_INT AND (${UNSIGNED_INT} EQUAL 4))\n+   set (JSON_UINT32 \""unsigned int\"")\n+else ()\n+   message (FATAL_ERROR \""Could not detect a valid unsigned 32-bit integer type\"")\n endif ()\n \n # Check for ssize_t and SSIZE_T existance.\n@@ -206,11 +234,9 @@ else ()\n    set (JSON_HAVE_LOCALECONV 0)\n endif ()\n \n-\n # check if we have setlocale\n check_function_exists (setlocale HAVE_SETLOCALE)\n \n-\n # Check what the inline keyword is.\n # Note that the original JSON_INLINE was always set to just 'inline', so this goes further.\n check_function_keywords(\""inline\"")\n@@ -238,6 +264,9 @@ elseif (HAVE__SNPRINTF)\n    set (JSON_SNPRINTF _snprintf)\n endif ()\n \n+check_c_source_compiles (\""int main() { unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1); return 0; } \"" HAVE_SYNC_BUILTINS)\n+check_c_source_compiles (\""int main() { char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE); return 0; }\"" HAVE_ATOMIC_BUILTINS)\n+\n # Create pkg-conf file.\n # (We use the same files as ./configure does, so we\n #  have to defined the same variables used there).""}<_**next**_>{""sha"": ""b27b9a3a849e94686aa648c1ec4d1bd4c8e35445"", ""filename"": ""cmake/config.h.cmake"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 21, ""changes"": 46, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/cmake/config.h.cmake"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/cmake/config.h.cmake"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/cmake/config.h.cmake?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,35 +1,36 @@\n-/* Reduced down to the defines that are actually used in the code */\n-\n-/* Define to 1 if you have the <inttypes.h> (and friends) header file. */\n-#cmakedefine HAVE_INTTYPES_H 1\n-#cmakedefine HAVE_STDINT_H 1\n+#cmakedefine HAVE_ENDIAN_H 1\n+#cmakedefine HAVE_FCNTL_H 1\n+#cmakedefine HAVE_SCHED_H 1\n+#cmakedefine HAVE_UNISTD_H 1\n+#cmakedefine HAVE_SYS_PARAM_H 1\n+#cmakedefine HAVE_SYS_STAT_H 1\n+#cmakedefine HAVE_SYS_TIME_H 1\n #cmakedefine HAVE_SYS_TYPES_H 1\n+#cmakedefine HAVE_STDINT_H 1\n \n-/* We must include this here, as in (eg) utf.h it will want to use\n-   the integer type, which in MSVC2010 will be in stdint.h\n-   (there is no inttypes.h in MSVC2010) */\n-#if defined(HAVE_STDINT_H)\n-#  include <stdint.h>\n-#elif defined(HAVE_INTTYPES_H)\n-#  include <inttypes.h>\n-#elif defined(HAVE_SYS_TYPES_H)\n-#  include <sys/types.h>\n-#endif\n+#cmakedefine HAVE_CLOSE 1\n+#cmakedefine HAVE_GETPID 1\n+#cmakedefine HAVE_GETTIMEOFDAY 1\n+#cmakedefine HAVE_OPEN 1\n+#cmakedefine HAVE_READ 1\n+#cmakedefine HAVE_SCHED_YIELD 1\n \n-/* Define to 1 if you have the <locale.h> header file. */\n-#cmakedefine HAVE_LOCALE_H 1\n+#cmakedefine HAVE_SYNC_BUILTINS 1\n+#cmakedefine HAVE_ATOMIC_BUILTINS 1\n \n-/* Define to 1 if you have the 'setlocale' function. */\n+#cmakedefine HAVE_LOCALE_H 1\n #cmakedefine HAVE_SETLOCALE 1\n \n-/* Define to the type of a signed integer type of width exactly 32 bits if\n-   such a type exists and the standard includes do not define it. */\n #cmakedefine HAVE_INT32_T 1\n-\n #ifndef HAVE_INT32_T\n #  define int32_t @JSON_INT32@\n #endif\n \n+#cmakedefine HAVE_UINT32_T 1\n+#ifndef HAVE_UINT32_T\n+#  define uint32_t @JSON_UINT32@\n+#endif\n+\n #cmakedefine HAVE_SSIZE_T 1\n \n #ifndef HAVE_SSIZE_T\n@@ -43,3 +44,6 @@\n #endif\n \n #cmakedefine HAVE_VSNPRINTF\n+\n+#cmakedefine USE_URANDOM 1\n+#cmakedefine USE_WINDOWS_CRYPTOAPI 1""}<_**next**_>{""sha"": ""113cb85e17a15f2fac83b528fe1880bc99481ccb"", ""filename"": ""configure.ac"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 2, ""changes"": 50, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/configure.ac"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/configure.ac"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/configure.ac?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -14,10 +14,11 @@ AM_CONDITIONAL([GCC], [test x$GCC = xyes])\n # Checks for libraries.\n \n # Checks for header files.\n-AC_CHECK_HEADERS([locale.h])\n+AC_CHECK_HEADERS([endian.h fcntl.h locale.h sched.h unistd.h sys/param.h sys/stat.h sys/time.h sys/types.h])\n \n # Checks for typedefs, structures, and compiler characteristics.\n AC_TYPE_INT32_T\n+AC_TYPE_UINT32_T\n AC_TYPE_LONG_LONG_INT\n \n AC_C_INLINE\n@@ -29,7 +30,31 @@ esac\n AC_SUBST([json_inline])\n \n # Checks for library functions.\n-AC_CHECK_FUNCS([strtoll localeconv])\n+AC_CHECK_FUNCS([close getpid gettimeofday localeconv open read sched_yield strtoll])\n+\n+AC_MSG_CHECKING([for gcc __sync builtins])\n+have_sync_builtins=no\n+AC_TRY_LINK(\n+  [], [unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1);],\n+  [have_sync_builtins=yes],\n+)\n+if test \""x$have_sync_builtins\"" = \""xyes\""; then\n+  AC_DEFINE([HAVE_SYNC_BUILTINS], [1],\n+    [Define to 1 if gcc's __sync builtins are available])\n+fi\n+AC_MSG_RESULT([$have_sync_builtins])\n+\n+AC_MSG_CHECKING([for gcc __atomic builtins])\n+have_atomic_builtins=no\n+AC_TRY_LINK(\n+  [], [char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE);],\n+  [have_atomic_builtins=yes],\n+)\n+if test \""x$have_atomic_builtins\"" = \""xyes\""; then\n+  AC_DEFINE([HAVE_ATOMIC_BUILTINS], [1],\n+    [Define to 1 if gcc's __atomic builtins are available])\n+fi\n+AC_MSG_RESULT([$have_atomic_builtins])\n \n case \""$ac_cv_type_long_long_int$ac_cv_func_strtoll\"" in\n      yesyes) json_have_long_long=1;;\n@@ -43,6 +68,27 @@ case \""$ac_cv_header_locale_h$ac_cv_func_localeconv\"" in\n esac\n AC_SUBST([json_have_localeconv])\n \n+# Features\n+AC_ARG_ENABLE([urandom],\n+  [AS_HELP_STRING([--disable-urandom],\n+    [Don't use /dev/urandom to seed the hash function])],\n+  [use_urandom=$enableval], [use_urandom=yes])\n+\n+if test \""x$use_urandom\"" = xyes; then\n+AC_DEFINE([USE_URANDOM], [1],\n+  [Define to 1 if /dev/urandom should be used for seeding the hash function])\n+fi\n+\n+AC_ARG_ENABLE([windows-cryptoapi],\n+  [AS_HELP_STRING([--disable-windows-cryptoapi],\n+    [Don't use CryptGenRandom to seed the hash function])],\n+  [use_windows_cryptoapi=$enableval], [use_windows_cryptoapi=yes])\n+\n+if test \""x$use_windows_cryptoapi\"" = xyes; then\n+AC_DEFINE([USE_WINDOWS_CRYPTOAPI], [1],\n+  [Define to 1 if CryptGenRandom should be used for seeding the hash function])\n+fi\n+\n AC_CONFIG_FILES([\n         jansson.pc\n         Makefile""}<_**next**_>{""sha"": ""b4af562e84b5ed9dba1107af7d1768dcdb0b9a95"", ""filename"": ""src/Makefile.am"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/Makefile.am"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/Makefile.am?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -8,6 +8,7 @@ libjansson_la_SOURCES = \\\n \terror.c \\\n \thashtable.c \\\n \thashtable.h \\\n+\thashtable_seed.c \\\n \tjansson_private.h \\\n \tload.c \\\n \tmemory.c \\""}<_**next**_>{""sha"": ""abd4bf11fe7a393fcf3d533b952aa8b5efa4ea30"", ""filename"": ""src/hashtable.c"", ""status"": ""modified"", ""additions"": 26, ""deletions"": 41, ""changes"": 67, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -5,8 +5,17 @@\n  * it under the terms of the MIT license. See LICENSE for details.\n  */\n \n+#if HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stdlib.h>\n #include <string.h>\n+\n+#if HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include <jansson_config.h>   /* for JSON_INLINE */\n #include \""jansson_private.h\""  /* for container_of() */\n #include \""hashtable.h\""\n@@ -15,24 +24,13 @@ typedef struct hashtable_list list_t;\n typedef struct hashtable_pair pair_t;\n typedef struct hashtable_bucket bucket_t;\n \n-#define list_to_pair(list_)  container_of(list_, pair_t, list)\n-\n-/* From http://www.cse.yorku.ca/~oz/hash.html */\n-static size_t hash_str(const void *ptr)\n-{\n-    const char *str = (const char *)ptr;\n-\n-    size_t hash = 5381;\n-    size_t c;\n+extern volatile uint32_t hashtable_seed;\n \n-    while((c = (size_t)*str))\n-    {\n-        hash = ((hash << 5) + hash) + c;\n-        str++;\n-    }\n+/* Implementation of the hash function */\n+#include \""lookup3.h\""\n \n-    return hash;\n-}\n+#define list_to_pair(list_)  container_of(list_, pair_t, list)\n+#define hash_str(key)        ((size_t)hashlittle((key), strlen(key), hashtable_seed))\n \n static JSON_INLINE void list_init(list_t *list)\n {\n@@ -74,19 +72,6 @@ static void insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket,\n     }\n }\n \n-static const size_t primes[] = {\n-    5, 13, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,\n-    49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,\n-    12582917, 25165843, 50331653, 100663319, 201326611, 402653189,\n-    805306457, 1610612741\n-};\n-\n-static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)\n-{\n-    return primes[hashtable->num_buckets];\n-}\n-\n-\n static pair_t *hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket,\n                                    const char *key, size_t hash)\n {\n@@ -120,7 +105,7 @@ static int hashtable_do_del(hashtable_t *hashtable,\n     bucket_t *bucket;\n     size_t index;\n \n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n@@ -167,14 +152,14 @@ static int hashtable_do_rehash(hashtable_t *hashtable)\n \n     jsonp_free(hashtable->buckets);\n \n-    hashtable->num_buckets++;\n-    new_size = num_buckets(hashtable);\n+    hashtable->order++;\n+    new_size = hashsize(hashtable->order);\n \n     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -199,14 +184,14 @@ int hashtable_init(hashtable_t *hashtable)\n     size_t i;\n \n     hashtable->size = 0;\n-    hashtable->num_buckets = 0;  /* index to primes[] */\n-    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));\n+    hashtable->order = 3;\n+    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n     list_init(&hashtable->list);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -230,12 +215,12 @@ int hashtable_set(hashtable_t *hashtable,\n     size_t hash, index;\n \n     /* rehash if the load ratio exceeds 1 */\n-    if(hashtable->size >= num_buckets(hashtable))\n+    if(hashtable->size >= hashsize(hashtable->order))\n         if(hashtable_do_rehash(hashtable))\n             return -1;\n \n     hash = hash_str(key);\n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n \n@@ -273,7 +258,7 @@ void *hashtable_get(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)\n@@ -294,7 +279,7 @@ void hashtable_clear(hashtable_t *hashtable)\n \n     hashtable_do_clear(hashtable);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -316,7 +301,7 @@ void *hashtable_iter_at(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)""}<_**next**_>{""sha"": ""469c6ecd869c4698f650fa81983bb3ee03d47fab"", ""filename"": ""src/hashtable.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -32,14 +32,15 @@ struct hashtable_bucket {\n typedef struct hashtable {\n     size_t size;\n     struct hashtable_bucket *buckets;\n-    size_t num_buckets;  /* index to primes[] */\n+    size_t order;  /* hashtable has pow(2, order) buckets */\n     struct hashtable_list list;\n } hashtable_t;\n \n \n #define hashtable_key_to_iter(key_) \\\n     (&(container_of(key_, struct hashtable_pair, key)->list))\n \n+\n /**\n  * hashtable_init - Initialize a hashtable object\n  *""}<_**next**_>{""sha"": ""a07d145d10df35b933c1441dcbf42d3316b78ca5"", ""filename"": ""src/hashtable_seed.c"", ""status"": ""added"", ""additions"": 278, ""deletions"": 0, ""changes"": 278, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable_seed.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable_seed.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable_seed.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,278 @@\n+/* Generate sizeof(uint32_t) bytes of as random data as possible to seed\n+   the hash function.\n+*/\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#include <stdio.h>\n+#include <time.h>\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n+#ifdef HAVE_FCNTL_H\n+#include <fcntl.h>\n+#endif\n+\n+#ifdef HAVE_SCHED_H\n+#include <sched.h>\n+#endif\n+\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+\n+#ifdef HAVE_SYS_STAT_H\n+#include <sys/stat.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TIME_H\n+#include <sys/time.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TYPES_H\n+#include <sys/types.h>\n+#endif\n+\n+#if defined(_WIN32)\n+/* For _getpid() */\n+#include <process.h>\n+#endif\n+\n+#include \""jansson.h\""\n+\n+\n+static uint32_t buf_to_uint32(char *data) {\n+    size_t i;\n+    uint32_t result = 0;\n+\n+    for (i = 0; i < sizeof(uint32_t); i++)\n+        result = (result << 8) | (unsigned char)data[i];\n+\n+    return result;\n+}\n+\n+\n+\n+/* /dev/urandom */\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+static int seed_from_urandom(uint32_t *seed) {\n+    /* Use unbuffered I/O if we have open(), close() and read(). Otherwise\n+       fall back to fopen() */\n+\n+    char data[sizeof(uint32_t)];\n+    int ok;\n+\n+#if defined(HAVE_OPEN) && defined(HAVE_CLOSE) && defined(HAVE_READ)\n+    int urandom;\n+    urandom = open(\""/dev/urandom\"", O_RDONLY);\n+    if (urandom == -1)\n+        return 1;\n+\n+    ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);\n+    close(urandom);\n+#else\n+    FILE *urandom;\n+\n+    urandom = fopen(\""/dev/urandom\"", \""rb\"");\n+    if (!urandom)\n+        return 1;\n+\n+    ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);\n+    fclose(urandom);\n+#endif\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32(data);\n+    return 0;\n+}\n+#endif\n+\n+/* Windows Crypto API */\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+#include <windows.h>\n+#include <wincrypt.h>\n+\n+typedef BOOL (WINAPI *CRYPTACQUIRECONTEXTA)(HCRYPTPROV *phProv, LPCSTR pszContainer, LPCSTR pszProvider, DWORD dwProvType, DWORD dwFlags);\n+typedef BOOL (WINAPI *CRYPTGENRANDOM)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);\n+typedef BOOL (WINAPI *CRYPTRELEASECONTEXT)(HCRYPTPROV hProv, DWORD dwFlags);\n+\n+static int seed_from_windows_cryptoapi(uint32_t *seed)\n+{\n+    HINSTANCE hAdvAPI32 = NULL;\n+    CRYPTACQUIRECONTEXTA pCryptAcquireContext = NULL;\n+    CRYPTGENRANDOM pCryptGenRandom = NULL;\n+    CRYPTRELEASECONTEXT pCryptReleaseContext = NULL;\n+    HCRYPTPROV hCryptProv = 0;\n+    BYTE data[sizeof(uint32_t)];\n+    int ok;\n+\n+    hAdvAPI32 = GetModuleHandle(\""advapi32.dll\"");\n+    if(hAdvAPI32 == NULL)\n+        return 1;\n+\n+    pCryptAcquireContext = (CRYPTACQUIRECONTEXTA)GetProcAddress(hAdvAPI32, \""CryptAcquireContextA\"");\n+    if (!pCryptAcquireContext)\n+        return 1;\n+\n+    pCryptGenRandom = (CRYPTGENRANDOM)GetProcAddress(hAdvAPI32, \""CryptGenRandom\"");\n+    if (!pCryptGenRandom)\n+        return 1;\n+\n+    pCryptReleaseContext = (CRYPTRELEASECONTEXT)GetProcAddress(hAdvAPI32, \""CryptReleaseContext\"");\n+    if (!pCryptReleaseContext)\n+        return 1;\n+\n+    if (!pCryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))\n+        return 1;\n+\n+    ok = CryptGenRandom(hCryptProv, sizeof(uint32_t), data);\n+    pCryptReleaseContext(hCryptProv, 0);\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32((char *)data);\n+    return 0;\n+}\n+#endif\n+\n+/* gettimeofday() and getpid() */\n+static int seed_from_timestamp_and_pid(uint32_t *seed) {\n+#ifdef HAVE_GETTIMEOFDAY\n+    /* XOR of seconds and microseconds */\n+    struct timeval tv;\n+    gettimeofday(&tv, NULL);\n+    *seed = (uint32_t)tv.tv_sec ^ (uint32_t)tv.tv_usec;\n+#else\n+    /* Seconds only */\n+    *seed = (uint32_t)time(NULL);\n+#endif\n+\n+    /* XOR with PID for more randomness */\n+#if defined(_WIN32)\n+    *seed ^= (uint32_t)_getpid();\n+#elif defined(HAVE_GETPID)\n+    *seed ^= (uint32_t)getpid();\n+#endif\n+\n+    return 0;\n+}\n+\n+static uint32_t generate_seed() {\n+    uint32_t seed;\n+    int done = 0;\n+\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+    if (!done && seed_from_urandom(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+    if (!done && seed_from_windows_cryptoapi(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+    if (!done) {\n+        /* Fall back to timestamp and PID if no better randomness is\n+           available */\n+        seed_from_timestamp_and_pid(&seed);\n+    }\n+\n+    /* Make sure the seed is never zero */\n+    if (seed == 0)\n+        seed = 1;\n+\n+    return seed;\n+}\n+\n+\n+volatile uint32_t hashtable_seed = 0;\n+\n+#if defined(HAVE_ATOMIC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+static volatile char seed_initialized = 0;\n+\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (__atomic_test_and_set(&seed_initialized, __ATOMIC_RELAXED) == 0) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            __atomic_store_n(&hashtable_seed, new_seed, __ATOMIC_ACQ_REL);\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            } while(__atomic_load_n(&hashtable_seed, __ATOMIC_ACQUIRE) == 0);\n+        }\n+    }\n+}\n+#elif defined(HAVE_SYNC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0) {\n+            /* Explicit synchronization fences are not supported by the\n+               __sync builtins, so every thread getting here has to\n+               generate the seed value.\n+            */\n+            new_seed = generate_seed();\n+        }\n+\n+        do {\n+            if (__sync_bool_compare_and_swap(&hashtable_seed, 0, new_seed)) {\n+                /* We were the first to seed */\n+                break;\n+            } else {\n+                /* Wait for another thread to do the seeding */\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            }\n+        } while(hashtable_seed == 0);\n+    }\n+}\n+#elif defined(_WIN32)\n+static long seed_initialized = 0;\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (InterlockedIncrement(&seed_initialized) == 1) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            hashtable_seed = new_seed;\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+                SwitchToThread();\n+            } while (hashtable_seed == 0);\n+        }\n+    }\n+}\n+#else\n+/* Fall back to a thread-unsafe version */\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0)\n+            new_seed = generate_seed();\n+\n+        hashtable_seed = new_seed;\n+    }\n+}\n+#endif""}<_**next**_>{""sha"": ""19096d4201e6b13f8c56765116865c71f67e9696"", ""filename"": ""src/jansson.def"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.def"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.def"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/jansson.def?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -41,6 +41,7 @@ EXPORTS\n     json_object_iter_value\n     json_object_iter_set_new\n     json_object_key_to_iter\n+    json_object_seed\n     json_dumps\n     json_dumpf\n     json_dump_file""}<_**next**_>{""sha"": ""ea230852a629e55457fba2d00e3edd8a4ad4fcec"", ""filename"": ""src/jansson.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/jansson.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -126,6 +126,7 @@ typedef struct {\n \n /* getters, setters, manipulation */\n \n+void json_object_seed(size_t seed);\n size_t json_object_size(const json_t *object);\n json_t *json_object_get(const json_t *object, const char *key);\n int json_object_set_new(json_t *object, const char *key, json_t *value);""}<_**next**_>{""sha"": ""dc76138c940516e9590784825d28d040fd1a8b25"", ""filename"": ""src/lookup3.h"", ""status"": ""added"", ""additions"": 366, ""deletions"": 0, ""changes"": 366, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/lookup3.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/lookup3.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/lookup3.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,366 @@\n+/*\n+-------------------------------------------------------------------------------\n+lookup3.c, by Bob Jenkins, May 2006, Public Domain.\n+\n+These are functions for producing 32-bit hashes for hash table lookup.\n+hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final() \n+are externally useful functions.  Routines to test the hash are included \n+if SELF_TEST is defined.  You can use this free for any purpose.  It's in\n+the public domain.  It has no warranty.\n+\n+You probably want to use hashlittle().  hashlittle() and hashbig()\n+hash byte arrays.  hashlittle() is is faster than hashbig() on\n+little-endian machines.  Intel and AMD are little-endian machines.\n+On second thought, you probably want hashlittle2(), which is identical to\n+hashlittle() except it returns two 32-bit hashes for the price of one.  \n+You could implement hashbig2() if you wanted but I haven't bothered here.\n+\n+If you want to find a hash of, say, exactly 7 integers, do\n+  a = i1;  b = i2;  c = i3;\n+  mix(a,b,c);\n+  a += i4; b += i5; c += i6;\n+  mix(a,b,c);\n+  a += i7;\n+  final(a,b,c);\n+then use c as the hash value.  If you have a variable length array of\n+4-byte integers to hash, use hashword().  If you have a byte array (like\n+a character string), use hashlittle().  If you have several byte arrays, or\n+a mix of things, see the comments above hashlittle().  \n+\n+Why is this so big?  I read 12 bytes at a time into 3 4-byte integers, \n+then mix those integers.  This is fast (you can do a lot more thorough\n+mixing with 12*3 instructions on 3 integers than you can with 3 instructions\n+on 1 byte), but shoehorning those bytes into integers efficiently is messy.\n+-------------------------------------------------------------------------------\n+*/\n+\n+#include <stdlib.h>\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>     /* defines uint32_t etc */\n+#endif\n+\n+#ifdef HAVE_SYS_PARAM_H\n+#include <sys/param.h>  /* attempt to define endianness */\n+#endif\n+\n+#ifdef HAVE_ENDIAN_H\n+# include <endian.h>    /* attempt to define endianness */\n+#endif\n+\n+/*\n+ * My best guess at if you are big-endian or little-endian.  This may\n+ * need adjustment.\n+ */\n+#if (defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && \\\n+     __BYTE_ORDER == __LITTLE_ENDIAN) || \\\n+    (defined(i386) || defined(__i386__) || defined(__i486__) || \\\n+     defined(__i586__) || defined(__i686__) || defined(vax) || defined(MIPSEL))\n+# define HASH_LITTLE_ENDIAN 1\n+# define HASH_BIG_ENDIAN 0\n+#elif (defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && \\\n+       __BYTE_ORDER == __BIG_ENDIAN) || \\\n+      (defined(sparc) || defined(POWERPC) || defined(mc68000) || defined(sel))\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 1\n+#else\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 0\n+#endif\n+\n+#define hashsize(n) ((uint32_t)1<<(n))\n+#define hashmask(n) (hashsize(n)-1)\n+#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n+\n+/*\n+-------------------------------------------------------------------------------\n+mix -- mix 3 32-bit values reversibly.\n+\n+This is reversible, so any information in (a,b,c) before mix() is\n+still in (a,b,c) after mix().\n+\n+If four pairs of (a,b,c) inputs are run through mix(), or through\n+mix() in reverse, there are at least 32 bits of the output that\n+are sometimes the same for one pair and different for another pair.\n+This was tested for:\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+Some k values for my \""a-=c; a^=rot(c,k); c+=b;\"" arrangement that\n+satisfy this are\n+    4  6  8 16 19  4\n+    9 15  3 18 27 15\n+   14  9  3  7 17  3\n+Well, \""9 15 3 18 27 15\"" didn't quite get 32 bits diffing\n+for \""differ\"" defined as + with a one-bit base and a two-bit delta.  I\n+used http://burtleburtle.net/bob/hash/avalanche.html to choose \n+the operations, constants, and arrangements of the variables.\n+\n+This does not achieve avalanche.  There are input bits of (a,b,c)\n+that fail to affect some output bits of (a,b,c), especially of a.  The\n+most thoroughly mixed value is c, but it doesn't really even achieve\n+avalanche in c.\n+\n+This allows some parallelism.  Read-after-writes are good at doubling\n+the number of bits affected, so the goal of mixing pulls in the opposite\n+direction as the goal of parallelism.  I did what I could.  Rotates\n+seem to cost as much as shifts on every machine I could lay my hands\n+on, and rotates are much kinder to the top and bottom bits, so I used\n+rotates.\n+-------------------------------------------------------------------------------\n+*/\n+#define mix(a,b,c) \\\n+{ \\\n+  a -= c;  a ^= rot(c, 4);  c += b; \\\n+  b -= a;  b ^= rot(a, 6);  a += c; \\\n+  c -= b;  c ^= rot(b, 8);  b += a; \\\n+  a -= c;  a ^= rot(c,16);  c += b; \\\n+  b -= a;  b ^= rot(a,19);  a += c; \\\n+  c -= b;  c ^= rot(b, 4);  b += a; \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+final -- final mixing of 3 32-bit values (a,b,c) into c\n+\n+Pairs of (a,b,c) values differing in only a few bits will usually\n+produce values of c that look totally different.  This was tested for\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+These constants passed:\n+ 14 11 25 16 4 14 24\n+ 12 14 25 16 4 14 24\n+and these came close:\n+  4  8 15 26 3 22 24\n+ 10  8 15 26 3 22 24\n+ 11  8 15 26 3 22 24\n+-------------------------------------------------------------------------------\n+*/\n+#define final(a,b,c) \\\n+{ \\\n+  c ^= b; c -= rot(b,14); \\\n+  a ^= c; a -= rot(c,11); \\\n+  b ^= a; b -= rot(a,25); \\\n+  c ^= b; c -= rot(b,16); \\\n+  a ^= c; a -= rot(c,4);  \\\n+  b ^= a; b -= rot(a,14); \\\n+  c ^= b; c -= rot(b,24); \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+hashlittle() -- hash a variable-length key into a 32-bit value\n+  k       : the key (the unaligned variable-length array of bytes)\n+  length  : the length of the key, counting by bytes\n+  initval : can be any 4-byte value\n+Returns a 32-bit value.  Every bit of the key affects every bit of\n+the return value.  Two keys differing by one or two bits will have\n+totally different hash values.\n+\n+The best hash table sizes are powers of 2.  There is no need to do\n+mod a prime (mod is sooo slow!).  If you need less than 32 bits,\n+use a bitmask.  For example, if you need only 10 bits, do\n+  h = (h & hashmask(10));\n+In which case, the hash table should have hashsize(10) elements.\n+\n+If you are hashing n strings (uint8_t **)k, do it like this:\n+  for (i=0, h=0; i<n; ++i) h = hashlittle( k[i], len[i], h);\n+\n+By Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this\n+code any way you wish, private, educational, or commercial.  It's free.\n+\n+Use for hash table lookup, or anything where one collision in 2^^32 is\n+acceptable.  Do NOT use for cryptographic purposes.\n+-------------------------------------------------------------------------------\n+*/\n+\n+static uint32_t hashlittle(const void *key, size_t length, uint32_t initval)\n+{\n+  uint32_t a,b,c;                                          /* internal state */\n+  union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */\n+\n+  /* Set up the internal state */\n+  a = b = c = 0xdeadbeef + ((uint32_t)length) + initval;\n+\n+  u.ptr = key;\n+  if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0)) {\n+    const uint32_t *k = (const uint32_t *)key;         /* read 32-bit chunks */\n+\n+#ifdef VALGRIND\n+    const uint8_t  *k8;\n+#endif\n+\n+    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      b += k[1];\n+      c += k[2];\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 3;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    /* \n+     * \""k[2]&0xffffff\"" actually reads beyond the end of the string, but\n+     * then masks off the part it's not allowed to read.  Because the\n+     * string is aligned, the masked-off tail is in the same word as the\n+     * rest of the string.  Every machine with memory protection I've seen\n+     * does it on word boundaries, so is OK with this.  But VALGRIND will\n+     * still catch it and complain.  The masking trick does make the hash\n+     * noticably faster for short strings (like English words).\n+     */\n+#ifndef VALGRIND\n+\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n+    case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n+    case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n+    case 6 : b+=k[1]&0xffff; a+=k[0]; break;\n+    case 5 : b+=k[1]&0xff; a+=k[0]; break;\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=k[0]&0xffffff; break;\n+    case 2 : a+=k[0]&0xffff; break;\n+    case 1 : a+=k[0]&0xff; break;\n+    case 0 : return c;              /* zero length strings require no mixing */\n+    }\n+\n+#else /* make valgrind happy */\n+\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=((uint32_t)k8[10])<<16;  /* fall through */\n+    case 10: c+=((uint32_t)k8[9])<<8;    /* fall through */\n+    case 9 : c+=k8[8];                   /* fall through */\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;   /* fall through */\n+    case 6 : b+=((uint32_t)k8[5])<<8;    /* fall through */\n+    case 5 : b+=k8[4];                   /* fall through */\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;   /* fall through */\n+    case 2 : a+=((uint32_t)k8[1])<<8;    /* fall through */\n+    case 1 : a+=k8[0]; break;\n+    case 0 : return c;\n+    }\n+\n+#endif /* !valgrind */\n+\n+  } else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0)) {\n+    const uint16_t *k = (const uint16_t *)key;         /* read 16-bit chunks */\n+    const uint8_t  *k8;\n+\n+    /*--------------- all but last block: aligned reads and different mixing */\n+    while (length > 12)\n+    {\n+      a += k[0] + (((uint32_t)k[1])<<16);\n+      b += k[2] + (((uint32_t)k[3])<<16);\n+      c += k[4] + (((uint32_t)k[5])<<16);\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 6;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[4]+(((uint32_t)k[5])<<16);\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 11: c+=((uint32_t)k8[10])<<16;     /* fall through */\n+    case 10: c+=k[4];\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 9 : c+=k8[8];                      /* fall through */\n+    case 8 : b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;      /* fall through */\n+    case 6 : b+=k[2];\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 5 : b+=k8[4];                      /* fall through */\n+    case 4 : a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;      /* fall through */\n+    case 2 : a+=k[0];\n+             break;\n+    case 1 : a+=k8[0];\n+             break;\n+    case 0 : return c;                     /* zero length requires no mixing */\n+    }\n+\n+  } else {                        /* need to read the key one byte at a time */\n+    const uint8_t *k = (const uint8_t *)key;\n+\n+    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      a += ((uint32_t)k[1])<<8;\n+      a += ((uint32_t)k[2])<<16;\n+      a += ((uint32_t)k[3])<<24;\n+      b += k[4];\n+      b += ((uint32_t)k[5])<<8;\n+      b += ((uint32_t)k[6])<<16;\n+      b += ((uint32_t)k[7])<<24;\n+      c += k[8];\n+      c += ((uint32_t)k[9])<<8;\n+      c += ((uint32_t)k[10])<<16;\n+      c += ((uint32_t)k[11])<<24;\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 12;\n+    }\n+\n+    /*-------------------------------- last block: affect all 32 bits of (c) */\n+    switch(length)                   /* all the case statements fall through */\n+    {\n+    case 12: c+=((uint32_t)k[11])<<24;\n+    case 11: c+=((uint32_t)k[10])<<16;\n+    case 10: c+=((uint32_t)k[9])<<8;\n+    case 9 : c+=k[8];\n+    case 8 : b+=((uint32_t)k[7])<<24;\n+    case 7 : b+=((uint32_t)k[6])<<16;\n+    case 6 : b+=((uint32_t)k[5])<<8;\n+    case 5 : b+=k[4];\n+    case 4 : a+=((uint32_t)k[3])<<24;\n+    case 3 : a+=((uint32_t)k[2])<<16;\n+    case 2 : a+=((uint32_t)k[1])<<8;\n+    case 1 : a+=k[0];\n+             break;\n+    case 0 : return c;\n+    }\n+  }\n+\n+  final(a,b,c);\n+  return c;\n+}""}<_**next**_>{""sha"": ""b4f109143031b2481a0d32a332c88cc1cc96c688"", ""filename"": ""src/utf.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 16, ""changes"": 20, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/utf.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/utf.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/utf.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -10,23 +10,11 @@\n \n #ifdef HAVE_CONFIG_H\n #include <config.h>\n+#endif\n \n-#ifdef HAVE_INTTYPES_H\n-/* inttypes.h includes stdint.h in a standard environment, so there's\n-no need to include stdint.h separately. If inttypes.h doesn't define\n-int32_t, it's defined in config.h. */\n-#include <inttypes.h>\n-#endif /* HAVE_INTTYPES_H */\n-\n-#else /* !HAVE_CONFIG_H */\n-#ifdef _WIN32\n-typedef int int32_t;\n-#else /* !_WIN32 */\n-/* Assume a standard environment */\n-#include <inttypes.h>\n-#endif /* _WIN32 */\n-\n-#endif /* HAVE_CONFIG_H */\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n \n int utf8_encode(int codepoint, char *buffer, int *size);\n ""}<_**next**_>{""sha"": ""1b02d90aa885f1ede146bb2077d05c8bb9096565"", ""filename"": ""src/value.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/value.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/value.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/value.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -9,11 +9,19 @@\n #define _GNU_SOURCE\n #endif\n \n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stddef.h>\n #include <stdlib.h>\n #include <string.h>\n #include <math.h>\n \n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include \""jansson.h\""\n #include \""hashtable.h\""\n #include \""jansson_private.h\""\n@@ -36,11 +44,19 @@ static JSON_INLINE void json_init(json_t *json, json_type type)\n \n /*** object ***/\n \n+extern volatile uint32_t hashtable_seed;\n+\n json_t *json_object(void)\n {\n     json_object_t *object = jsonp_malloc(sizeof(json_object_t));\n     if(!object)\n         return NULL;\n+\n+    if (!hashtable_seed) {\n+        /* Autoseed */\n+        json_object_seed(0);\n+    }\n+\n     json_init(&object->json, JSON_OBJECT);\n \n     if(hashtable_init(&object->hashtable))""}<_**next**_>{""sha"": ""e2c54bd12bd7c22de7cc3533f010b26cc1c330b0"", ""filename"": ""test/bin/json_process.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 1, ""changes"": 16, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/bin/json_process.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/bin/json_process.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/bin/json_process.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -37,6 +37,8 @@ struct config {\n     int sort_keys;\n     int strip;\n     int use_env;\n+    int have_hashseed;\n+    int hashseed;\n } conf;\n \n #define l_isspace(c) ((c) == ' ' || (c) == '\\n' || (c) == '\\r' || (c) == '\\t')\n@@ -108,6 +110,12 @@ static void read_conf(FILE *conffile)\n             conf.sort_keys = atoi(val);\n         if (!strcmp(line, \""STRIP\""))\n             conf.strip = atoi(val);\n+        if (!strcmp(line, \""HASHSEED\"")) {\n+            conf.have_hashseed = 1;\n+            conf.hashseed = atoi(val);\n+        } else {\n+            conf.have_hashseed = 0;\n+        }\n     }\n \n     free(buffer);\n@@ -188,6 +196,9 @@ int use_conf(char *test_path)\n     if (conf.sort_keys)\n         flags |= JSON_SORT_KEYS;\n \n+    if (conf.have_hashseed)\n+        json_object_seed(conf.hashseed);\n+\n     if (conf.strip) {\n         /* Load to memory, strip leading and trailing whitespace */\n         buffer = loadfile(infile);\n@@ -265,7 +276,10 @@ int use_env()\n         flags |= JSON_PRESERVE_ORDER;\n \n     if(getenv_int(\""JSON_SORT_KEYS\""))\n-         flags |= JSON_SORT_KEYS;\n+        flags |= JSON_SORT_KEYS;\n+\n+    if(getenv(\""HASHSEED\""))\n+        json_object_seed(getenv_int(\""HASHSEED\""));\n \n     if(getenv_int(\""STRIP\"")) {\n         /* Load to memory, strip leading and trailing whitespace */""}<_**next**_>{""sha"": ""84b17466fd0a753b8cbd714d0236ed9072cdd536"", ""filename"": ""test/suites/api/test_memory_funcs.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_memory_funcs.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_memory_funcs.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/api/test_memory_funcs.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -24,13 +24,13 @@ static void create_and_free_complex_object()\n \n static void *my_malloc(size_t size)\n {\n-    malloc_called += 1;\n+    malloc_called = 1;\n     return malloc(size);\n }\n \n static void my_free(void *ptr)\n {\n-    free_called += 1;\n+    free_called = 1;\n     free(ptr);\n }\n \n@@ -39,7 +39,7 @@ static void test_simple()\n     json_set_alloc_funcs(my_malloc, my_free);\n     create_and_free_complex_object();\n \n-    if(malloc_called != 20 || free_called != 20)\n+    if(malloc_called != 1 || free_called != 1)\n         fail(\""Custom allocation failed\"");\n }\n ""}<_**next**_>{""sha"": ""92e5208224b75ab45d93672446279d598052a83e"", ""filename"": ""test/suites/api/test_object.c"", ""status"": ""modified"", ""additions"": 40, ""deletions"": 24, ""changes"": 64, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_object.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_object.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/api/test_object.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -249,7 +249,11 @@ static void test_set_nocheck()\n \n static void test_iterators()\n {\n+    int i;\n     json_t *object, *foo, *bar, *baz;\n+    const char *iter_keys[3];\n+    int have_key[3] = { 0, 0, 0 };\n+    json_t *iter_values[3];\n     void *iter;\n \n     if(json_object_iter(NULL))\n@@ -276,30 +280,50 @@ static void test_iterators()\n     iter = json_object_iter(object);\n     if(!iter)\n         fail(\""unable to get iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""a\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != foo)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[0] = json_object_iter_key(iter);\n+    iter_values[0] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""b\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != bar)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[1] = json_object_iter_key(iter);\n+    iter_values[1] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[2] = json_object_iter_key(iter);\n+    iter_values[2] = json_object_iter_value(iter);\n \n     if(json_object_iter_next(object, iter) != NULL)\n         fail(\""able to iterate over the end\"");\n \n+    /* Check that keys have correct values */\n+    for (i = 0; i < 3; i++) {\n+        if (strcmp(iter_keys[i], \""a\"") == 0) {\n+            if (iter_values[i] != foo)\n+                fail(\""wrong value for iter key a\"");\n+            else\n+                have_key[0] = 1;\n+        } else if (strcmp(iter_keys[i], \""b\"") == 0) {\n+            if (iter_values[i] != bar)\n+                fail(\""wrong value for iter key b\"");\n+            else\n+                have_key[1] = 1;\n+        } else if (strcmp(iter_keys[i], \""c\"") == 0) {\n+            if (iter_values[i] != baz)\n+                fail(\""wrong value for iter key c\"");\n+            else\n+                have_key[2] = 1;\n+        }\n+    }\n+\n+    /* Check that we got all keys */\n+    for(i = 0; i < 3; i++) {\n+        if(!have_key[i])\n+            fail(\""a key wasn't iterated over\"");\n+    }\n+\n     if(json_object_iter_at(object, \""foo\""))\n         fail(\""json_object_iter_at() succeeds for non-existent key\"");\n \n@@ -312,22 +336,14 @@ static void test_iterators()\n     if(json_object_iter_value(iter) != bar)\n         fail(\""iterating failed: wrong value\"");\n \n-    iter = json_object_iter_next(object, iter);\n-    if(!iter)\n-        fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\""iterating failed: wrong value\"");\n-\n-    if(json_object_iter_set(object, iter, bar))\n+    if(json_object_iter_set(object, iter, baz))\n         fail(\""unable to set value at iterator\"");\n \n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n+    if(strcmp(json_object_iter_key(iter), \""b\""))\n         fail(\""json_object_iter_key() fails after json_object_iter_set()\"");\n-    if(json_object_iter_value(iter) != bar)\n+    if(json_object_iter_value(iter) != baz)\n         fail(\""json_object_iter_value() fails after json_object_iter_set()\"");\n-    if(json_object_get(object, \""c\"") != bar)\n+    if(json_object_get(object, \""b\"") != baz)\n         fail(\""json_object_get() fails after json_object_iter_set()\"");\n \n     json_decref(object);""}<_**next**_>{""sha"": ""93cb33ddafeb9eef6ce7ad4709ce1bcbdf25b200"", ""filename"": ""test/suites/encoding-flags/compact-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/compact-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/compact-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/compact-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,2 +1,3 @@\n JSON_COMPACT=1\n-export JSON_COMPACT\n+HASHSEED=1\n+export JSON_COMPACT HASHSEED""}<_**next**_>{""sha"": ""c73acc1792963be8a5f41ff11f6e858506ada51d"", ""filename"": ""test/suites/encoding-flags/indent-compact-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-compact-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-compact-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/indent-compact-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,3 +1,4 @@\n JSON_INDENT=4\n JSON_COMPACT=1\n-export JSON_INDENT JSON_COMPACT\n+HASHSEED=1\n+export JSON_INDENT JSON_COMPACT HASHSEED""}<_**next**_>{""sha"": ""961558ca23ceca2ce6e4d07697f4018d8475f317"", ""filename"": ""test/suites/encoding-flags/indent-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/indent-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,2 +1,3 @@\n JSON_INDENT=4\n-export JSON_INDENT\n+HASHSEED=1\n+export JSON_INDENT HASHSEED""}<_**next**_>{""sha"": ""9120b03514ec614695c2d17841ba228b102c9db6"", ""filename"": ""test/suites/encoding-flags/object/env"", ""status"": ""added"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,2 @@\n+HASHSEED=1\n+export HASHSEED""}","int hashtable_init(hashtable_t *hashtable)
{
     size_t i;
 
     hashtable->size = 0;
    hashtable->order = 3;
    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));
     if(!hashtable->buckets)
         return -1;
 
     list_init(&hashtable->list);
 
    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
    }

    return 0;
}
","int hashtable_init(hashtable_t *hashtable)
{
     size_t i;
 
     hashtable->size = 0;
    hashtable->num_buckets = 0;  /* index to primes[] */
    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));
     if(!hashtable->buckets)
         return -1;
 
     list_init(&hashtable->list);
 
    for(i = 0; i < num_buckets(hashtable); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
    }

    return 0;
}
",C,"    hashtable->order = 3;
    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));
    for(i = 0; i < hashsize(hashtable->order); i++)
","    hashtable->num_buckets = 0;  /* index to primes[] */
    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));
    for(i = 0; i < num_buckets(hashtable); i++)
",,"@@ -5,8 +5,17 @@
  * it under the terms of the MIT license. See LICENSE for details.
  */
 
+#if HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include <stdlib.h>
 #include <string.h>
+
+#if HAVE_STDINT_H
+#include <stdint.h>
+#endif
+
 #include <jansson_config.h>   /* for JSON_INLINE */
 #include ""jansson_private.h""  /* for container_of() */
 #include ""hashtable.h""
@@ -15,24 +24,13 @@ typedef struct hashtable_list list_t;
 typedef struct hashtable_pair pair_t;
 typedef struct hashtable_bucket bucket_t;
 
-#define list_to_pair(list_)  container_of(list_, pair_t, list)
-
-/* From http://www.cse.yorku.ca/~oz/hash.html */
-static size_t hash_str(const void *ptr)
-{
-    const char *str = (const char *)ptr;
-
-    size_t hash = 5381;
-    size_t c;
+extern volatile uint32_t hashtable_seed;
 
-    while((c = (size_t)*str))
-    {
-        hash = ((hash << 5) + hash) + c;
-        str++;
-    }
+/* Implementation of the hash function */
+#include ""lookup3.h""
 
-    return hash;
-}
+#define list_to_pair(list_)  container_of(list_, pair_t, list)
+#define hash_str(key)        ((size_t)hashlittle((key), strlen(key), hashtable_seed))
 
 static JSON_INLINE void list_init(list_t *list)
 {
@@ -74,19 +72,6 @@ static void insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket,
     }
 }
 
-static const size_t primes[] = {
-    5, 13, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,
-    49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,
-    12582917, 25165843, 50331653, 100663319, 201326611, 402653189,
-    805306457, 1610612741
-};
-
-static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)
-{
-    return primes[hashtable->num_buckets];
-}
-
-
 static pair_t *hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket,
                                    const char *key, size_t hash)
 {
@@ -120,7 +105,7 @@ static int hashtable_do_del(hashtable_t *hashtable,
     bucket_t *bucket;
     size_t index;
 
-    index = hash % num_buckets(hashtable);
+    index = hash & hashmask(hashtable->order);
     bucket = &hashtable->buckets[index];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
@@ -167,14 +152,14 @@ static int hashtable_do_rehash(hashtable_t *hashtable)
 
     jsonp_free(hashtable->buckets);
 
-    hashtable->num_buckets++;
-    new_size = num_buckets(hashtable);
+    hashtable->order++;
+    new_size = hashsize(hashtable->order);
 
     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));
     if(!hashtable->buckets)
         return -1;
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -199,14 +184,14 @@ int hashtable_init(hashtable_t *hashtable)
     size_t i;
 
     hashtable->size = 0;
-    hashtable->num_buckets = 0;  /* index to primes[] */
-    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));
+    hashtable->order = 3;
+    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));
     if(!hashtable->buckets)
         return -1;
 
     list_init(&hashtable->list);
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -230,12 +215,12 @@ int hashtable_set(hashtable_t *hashtable,
     size_t hash, index;
 
     /* rehash if the load ratio exceeds 1 */
-    if(hashtable->size >= num_buckets(hashtable))
+    if(hashtable->size >= hashsize(hashtable->order))
         if(hashtable_do_rehash(hashtable))
             return -1;
 
     hash = hash_str(key);
-    index = hash % num_buckets(hashtable);
+    index = hash & hashmask(hashtable->order);
     bucket = &hashtable->buckets[index];
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
 
@@ -273,7 +258,7 @@ void *hashtable_get(hashtable_t *hashtable, const char *key)
     bucket_t *bucket;
 
     hash = hash_str(key);
-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)
@@ -294,7 +279,7 @@ void hashtable_clear(hashtable_t *hashtable)
 
     hashtable_do_clear(hashtable);
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -316,7 +301,7 @@ void *hashtable_iter_at(hashtable_t *hashtable, const char *key)
     bucket_t *bucket;
 
     hash = hash_str(key);
-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)",jansson,8f80c2d83808150724d31793e6ade92749b1faa4,b9c588de3deb4efdd7b9ec44aa79335dba11fd6b,1,"int hashtable_init(hashtable_t *hashtable)
{
     size_t i;
 
     hashtable->size = 0;
//flaw_line_below:
    hashtable->num_buckets = 0;  /* index to primes[] */
//flaw_line_below:
    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));
//fix_flaw_line_below:
//    hashtable->order = 3;
//fix_flaw_line_below:
//    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));
     if(!hashtable->buckets)
         return -1;
 
     list_init(&hashtable->list);
 
//flaw_line_below:
    for(i = 0; i < num_buckets(hashtable); i++)
//fix_flaw_line_below:
//    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
    }

    return 0;
}
"
1968,179704,,Remote,Not required,Partial,CVE-2013-6401,https://www.cvedetails.com/cve/CVE-2013-6401/,CWE-310,Low,,,,2014-03-20,5.0,"Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document.",2014-05-23,DoS ,1,https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4,8f80c2d83808150724d31793e6ade92749b1faa4,"CVE-2013-6401: Change hash function, randomize hashes

Thanks to Florian Weimer and Eric Sesterhenn for reporting, reviewing
and testing.",1,src/hashtable.c,"{""sha"": ""1043c9ae4c0bc0c1f6a5913783973383832ff14b"", ""filename"": ""CMakeLists.txt"", ""status"": ""modified"", ""additions"": 39, ""deletions"": 10, ""changes"": 49, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/CMakeLists.txt"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/CMakeLists.txt"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/CMakeLists.txt?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -52,6 +52,8 @@ project (jansson C)\n \n # Options\n OPTION (BUILD_SHARED_LIBS \""Build shared libraries.\"" OFF)\n+OPTION (USE_URANDOM \""Use /dev/urandom to seed the hash function.\"" ON)\n+OPTION (USE_WINDOWS_CRYPTOAPI \""Use CryptGenRandom to seed the hash function.\"" ON)\n \n if (MSVC)\n    # This option must match the settings used in your program, in particular if you\n@@ -85,12 +87,12 @@ set (JANSSON_SOVERSION 4)\n # for CheckFunctionKeywords\n set(CMAKE_MODULE_PATH \""${CMAKE_CURRENT_SOURCE_DIR}/cmake\"")\n \n+INCLUDE (CheckCSourceCompiles)\n include (CheckFunctionExists)\n include (CheckFunctionKeywords)\n include (CheckIncludeFiles)\n include (CheckTypeSize)\n \n-\n if (MSVC)\n    # Turn off Microsofts \""security\"" warnings.\n    add_definitions( \""/W3 /D_CRT_SECURE_NO_WARNINGS /wd4005 /wd4996 /nologo\"" )\n@@ -106,14 +108,25 @@ if (CMAKE_COMPILER_IS_GNUCC OR CMAKE_COMPILER_IS_GNUCXX)\n    set(CMAKE_C_FLAGS \""-fPIC\"")\n endif()\n \n-   \n+check_include_files (endian.h HAVE_ENDIAN_H)\n+check_include_files (fcntl.h HAVE_FCNTL_H)\n+check_include_files (sched.h HAVE_SCHED_H)\n+check_include_files (unistd.h HAVE_UNISTD_H)\n+check_include_files (sys/param.h HAVE_SYS_PARAM_H)\n+check_include_files (sys/stat.h HAVE_SYS_STAT_H)\n+check_include_files (sys/time.h HAVE_SYS_TIME_H)\n+check_include_files (sys/time.h HAVE_SYS_TYPES_H)\n+\n+check_function_exists (close HAVE_CLOSE)\n+check_function_exists (getpid HAVE_GETPID)\n+check_function_exists (gettimeofday HAVE_GETTIMEOFDAY)\n+check_function_exists (open HAVE_OPEN)\n+check_function_exists (read HAVE_READ)\n+check_function_exists (sched_yield HAVE_SCHED_YIELD)\n \n # Check for the int-type includes\n-check_include_files (sys/types.h HAVE_SYS_TYPES_H)\n-check_include_files (inttypes.h HAVE_INTTYPES_H)\n check_include_files (stdint.h HAVE_STDINT_H)\n \n-\n # Check our 64 bit integer sizes\n check_type_size (__int64 __INT64)\n check_type_size (int64_t INT64_T)\n@@ -124,17 +137,32 @@ check_type_size (int32_t INT32_T)\n check_type_size (__int32 __INT32)\n check_type_size (\""long\"" LONG_INT)\n check_type_size (\""int\"" INT)\n-\n if (HAVE_INT32_T)\n    set (JSON_INT32 int32_t)\n elseif (HAVE___INT32)\n    set (JSON_INT32 __int32)\n-elseif (HAVE_LONG AND (${LONG_INT} EQUAL 4))\n+elseif (HAVE_LONG_INT AND (${LONG_INT} EQUAL 4))\n    set (JSON_INT32 long)\n elseif (HAVE_INT AND (${INT} EQUAL 4))\n    set (JSON_INT32 int)\n else ()\n-   message (FATAL_ERROR \""Could not detect a valid 32 bit integer type\"")\n+   message (FATAL_ERROR \""Could not detect a valid 32-bit integer type\"")\n+endif ()\n+\n+check_type_size (uint32_t UINT32_T)\n+check_type_size (__uint32 __UINT32)\n+check_type_size (\""unsigned long\"" UNSIGNED_LONG_INT)\n+check_type_size (\""unsigned int\"" UNSIGNED_INT)\n+if (HAVE_UINT32_T)\n+   set (JSON_UINT32 uint32_t)\n+elseif (HAVE___UINT32)\n+   set (JSON_UINT32 __uint32)\n+elseif (HAVE_UNSIGNED_LONG_INT AND (${UNSIGNED_LONG_INT} EQUAL 4))\n+   set (JSON_UINT32 \""unsigned long\"")\n+elseif (HAVE_UNSIGNED_INT AND (${UNSIGNED_INT} EQUAL 4))\n+   set (JSON_UINT32 \""unsigned int\"")\n+else ()\n+   message (FATAL_ERROR \""Could not detect a valid unsigned 32-bit integer type\"")\n endif ()\n \n # Check for ssize_t and SSIZE_T existance.\n@@ -206,11 +234,9 @@ else ()\n    set (JSON_HAVE_LOCALECONV 0)\n endif ()\n \n-\n # check if we have setlocale\n check_function_exists (setlocale HAVE_SETLOCALE)\n \n-\n # Check what the inline keyword is.\n # Note that the original JSON_INLINE was always set to just 'inline', so this goes further.\n check_function_keywords(\""inline\"")\n@@ -238,6 +264,9 @@ elseif (HAVE__SNPRINTF)\n    set (JSON_SNPRINTF _snprintf)\n endif ()\n \n+check_c_source_compiles (\""int main() { unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1); return 0; } \"" HAVE_SYNC_BUILTINS)\n+check_c_source_compiles (\""int main() { char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE); return 0; }\"" HAVE_ATOMIC_BUILTINS)\n+\n # Create pkg-conf file.\n # (We use the same files as ./configure does, so we\n #  have to defined the same variables used there).""}<_**next**_>{""sha"": ""b27b9a3a849e94686aa648c1ec4d1bd4c8e35445"", ""filename"": ""cmake/config.h.cmake"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 21, ""changes"": 46, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/cmake/config.h.cmake"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/cmake/config.h.cmake"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/cmake/config.h.cmake?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,35 +1,36 @@\n-/* Reduced down to the defines that are actually used in the code */\n-\n-/* Define to 1 if you have the <inttypes.h> (and friends) header file. */\n-#cmakedefine HAVE_INTTYPES_H 1\n-#cmakedefine HAVE_STDINT_H 1\n+#cmakedefine HAVE_ENDIAN_H 1\n+#cmakedefine HAVE_FCNTL_H 1\n+#cmakedefine HAVE_SCHED_H 1\n+#cmakedefine HAVE_UNISTD_H 1\n+#cmakedefine HAVE_SYS_PARAM_H 1\n+#cmakedefine HAVE_SYS_STAT_H 1\n+#cmakedefine HAVE_SYS_TIME_H 1\n #cmakedefine HAVE_SYS_TYPES_H 1\n+#cmakedefine HAVE_STDINT_H 1\n \n-/* We must include this here, as in (eg) utf.h it will want to use\n-   the integer type, which in MSVC2010 will be in stdint.h\n-   (there is no inttypes.h in MSVC2010) */\n-#if defined(HAVE_STDINT_H)\n-#  include <stdint.h>\n-#elif defined(HAVE_INTTYPES_H)\n-#  include <inttypes.h>\n-#elif defined(HAVE_SYS_TYPES_H)\n-#  include <sys/types.h>\n-#endif\n+#cmakedefine HAVE_CLOSE 1\n+#cmakedefine HAVE_GETPID 1\n+#cmakedefine HAVE_GETTIMEOFDAY 1\n+#cmakedefine HAVE_OPEN 1\n+#cmakedefine HAVE_READ 1\n+#cmakedefine HAVE_SCHED_YIELD 1\n \n-/* Define to 1 if you have the <locale.h> header file. */\n-#cmakedefine HAVE_LOCALE_H 1\n+#cmakedefine HAVE_SYNC_BUILTINS 1\n+#cmakedefine HAVE_ATOMIC_BUILTINS 1\n \n-/* Define to 1 if you have the 'setlocale' function. */\n+#cmakedefine HAVE_LOCALE_H 1\n #cmakedefine HAVE_SETLOCALE 1\n \n-/* Define to the type of a signed integer type of width exactly 32 bits if\n-   such a type exists and the standard includes do not define it. */\n #cmakedefine HAVE_INT32_T 1\n-\n #ifndef HAVE_INT32_T\n #  define int32_t @JSON_INT32@\n #endif\n \n+#cmakedefine HAVE_UINT32_T 1\n+#ifndef HAVE_UINT32_T\n+#  define uint32_t @JSON_UINT32@\n+#endif\n+\n #cmakedefine HAVE_SSIZE_T 1\n \n #ifndef HAVE_SSIZE_T\n@@ -43,3 +44,6 @@\n #endif\n \n #cmakedefine HAVE_VSNPRINTF\n+\n+#cmakedefine USE_URANDOM 1\n+#cmakedefine USE_WINDOWS_CRYPTOAPI 1""}<_**next**_>{""sha"": ""113cb85e17a15f2fac83b528fe1880bc99481ccb"", ""filename"": ""configure.ac"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 2, ""changes"": 50, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/configure.ac"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/configure.ac"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/configure.ac?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -14,10 +14,11 @@ AM_CONDITIONAL([GCC], [test x$GCC = xyes])\n # Checks for libraries.\n \n # Checks for header files.\n-AC_CHECK_HEADERS([locale.h])\n+AC_CHECK_HEADERS([endian.h fcntl.h locale.h sched.h unistd.h sys/param.h sys/stat.h sys/time.h sys/types.h])\n \n # Checks for typedefs, structures, and compiler characteristics.\n AC_TYPE_INT32_T\n+AC_TYPE_UINT32_T\n AC_TYPE_LONG_LONG_INT\n \n AC_C_INLINE\n@@ -29,7 +30,31 @@ esac\n AC_SUBST([json_inline])\n \n # Checks for library functions.\n-AC_CHECK_FUNCS([strtoll localeconv])\n+AC_CHECK_FUNCS([close getpid gettimeofday localeconv open read sched_yield strtoll])\n+\n+AC_MSG_CHECKING([for gcc __sync builtins])\n+have_sync_builtins=no\n+AC_TRY_LINK(\n+  [], [unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1);],\n+  [have_sync_builtins=yes],\n+)\n+if test \""x$have_sync_builtins\"" = \""xyes\""; then\n+  AC_DEFINE([HAVE_SYNC_BUILTINS], [1],\n+    [Define to 1 if gcc's __sync builtins are available])\n+fi\n+AC_MSG_RESULT([$have_sync_builtins])\n+\n+AC_MSG_CHECKING([for gcc __atomic builtins])\n+have_atomic_builtins=no\n+AC_TRY_LINK(\n+  [], [char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE);],\n+  [have_atomic_builtins=yes],\n+)\n+if test \""x$have_atomic_builtins\"" = \""xyes\""; then\n+  AC_DEFINE([HAVE_ATOMIC_BUILTINS], [1],\n+    [Define to 1 if gcc's __atomic builtins are available])\n+fi\n+AC_MSG_RESULT([$have_atomic_builtins])\n \n case \""$ac_cv_type_long_long_int$ac_cv_func_strtoll\"" in\n      yesyes) json_have_long_long=1;;\n@@ -43,6 +68,27 @@ case \""$ac_cv_header_locale_h$ac_cv_func_localeconv\"" in\n esac\n AC_SUBST([json_have_localeconv])\n \n+# Features\n+AC_ARG_ENABLE([urandom],\n+  [AS_HELP_STRING([--disable-urandom],\n+    [Don't use /dev/urandom to seed the hash function])],\n+  [use_urandom=$enableval], [use_urandom=yes])\n+\n+if test \""x$use_urandom\"" = xyes; then\n+AC_DEFINE([USE_URANDOM], [1],\n+  [Define to 1 if /dev/urandom should be used for seeding the hash function])\n+fi\n+\n+AC_ARG_ENABLE([windows-cryptoapi],\n+  [AS_HELP_STRING([--disable-windows-cryptoapi],\n+    [Don't use CryptGenRandom to seed the hash function])],\n+  [use_windows_cryptoapi=$enableval], [use_windows_cryptoapi=yes])\n+\n+if test \""x$use_windows_cryptoapi\"" = xyes; then\n+AC_DEFINE([USE_WINDOWS_CRYPTOAPI], [1],\n+  [Define to 1 if CryptGenRandom should be used for seeding the hash function])\n+fi\n+\n AC_CONFIG_FILES([\n         jansson.pc\n         Makefile""}<_**next**_>{""sha"": ""b4af562e84b5ed9dba1107af7d1768dcdb0b9a95"", ""filename"": ""src/Makefile.am"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/Makefile.am"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/Makefile.am?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -8,6 +8,7 @@ libjansson_la_SOURCES = \\\n \terror.c \\\n \thashtable.c \\\n \thashtable.h \\\n+\thashtable_seed.c \\\n \tjansson_private.h \\\n \tload.c \\\n \tmemory.c \\""}<_**next**_>{""sha"": ""abd4bf11fe7a393fcf3d533b952aa8b5efa4ea30"", ""filename"": ""src/hashtable.c"", ""status"": ""modified"", ""additions"": 26, ""deletions"": 41, ""changes"": 67, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -5,8 +5,17 @@\n  * it under the terms of the MIT license. See LICENSE for details.\n  */\n \n+#if HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stdlib.h>\n #include <string.h>\n+\n+#if HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include <jansson_config.h>   /* for JSON_INLINE */\n #include \""jansson_private.h\""  /* for container_of() */\n #include \""hashtable.h\""\n@@ -15,24 +24,13 @@ typedef struct hashtable_list list_t;\n typedef struct hashtable_pair pair_t;\n typedef struct hashtable_bucket bucket_t;\n \n-#define list_to_pair(list_)  container_of(list_, pair_t, list)\n-\n-/* From http://www.cse.yorku.ca/~oz/hash.html */\n-static size_t hash_str(const void *ptr)\n-{\n-    const char *str = (const char *)ptr;\n-\n-    size_t hash = 5381;\n-    size_t c;\n+extern volatile uint32_t hashtable_seed;\n \n-    while((c = (size_t)*str))\n-    {\n-        hash = ((hash << 5) + hash) + c;\n-        str++;\n-    }\n+/* Implementation of the hash function */\n+#include \""lookup3.h\""\n \n-    return hash;\n-}\n+#define list_to_pair(list_)  container_of(list_, pair_t, list)\n+#define hash_str(key)        ((size_t)hashlittle((key), strlen(key), hashtable_seed))\n \n static JSON_INLINE void list_init(list_t *list)\n {\n@@ -74,19 +72,6 @@ static void insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket,\n     }\n }\n \n-static const size_t primes[] = {\n-    5, 13, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,\n-    49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,\n-    12582917, 25165843, 50331653, 100663319, 201326611, 402653189,\n-    805306457, 1610612741\n-};\n-\n-static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)\n-{\n-    return primes[hashtable->num_buckets];\n-}\n-\n-\n static pair_t *hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket,\n                                    const char *key, size_t hash)\n {\n@@ -120,7 +105,7 @@ static int hashtable_do_del(hashtable_t *hashtable,\n     bucket_t *bucket;\n     size_t index;\n \n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n@@ -167,14 +152,14 @@ static int hashtable_do_rehash(hashtable_t *hashtable)\n \n     jsonp_free(hashtable->buckets);\n \n-    hashtable->num_buckets++;\n-    new_size = num_buckets(hashtable);\n+    hashtable->order++;\n+    new_size = hashsize(hashtable->order);\n \n     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -199,14 +184,14 @@ int hashtable_init(hashtable_t *hashtable)\n     size_t i;\n \n     hashtable->size = 0;\n-    hashtable->num_buckets = 0;  /* index to primes[] */\n-    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));\n+    hashtable->order = 3;\n+    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n     list_init(&hashtable->list);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -230,12 +215,12 @@ int hashtable_set(hashtable_t *hashtable,\n     size_t hash, index;\n \n     /* rehash if the load ratio exceeds 1 */\n-    if(hashtable->size >= num_buckets(hashtable))\n+    if(hashtable->size >= hashsize(hashtable->order))\n         if(hashtable_do_rehash(hashtable))\n             return -1;\n \n     hash = hash_str(key);\n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n \n@@ -273,7 +258,7 @@ void *hashtable_get(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)\n@@ -294,7 +279,7 @@ void hashtable_clear(hashtable_t *hashtable)\n \n     hashtable_do_clear(hashtable);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -316,7 +301,7 @@ void *hashtable_iter_at(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)""}<_**next**_>{""sha"": ""469c6ecd869c4698f650fa81983bb3ee03d47fab"", ""filename"": ""src/hashtable.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -32,14 +32,15 @@ struct hashtable_bucket {\n typedef struct hashtable {\n     size_t size;\n     struct hashtable_bucket *buckets;\n-    size_t num_buckets;  /* index to primes[] */\n+    size_t order;  /* hashtable has pow(2, order) buckets */\n     struct hashtable_list list;\n } hashtable_t;\n \n \n #define hashtable_key_to_iter(key_) \\\n     (&(container_of(key_, struct hashtable_pair, key)->list))\n \n+\n /**\n  * hashtable_init - Initialize a hashtable object\n  *""}<_**next**_>{""sha"": ""a07d145d10df35b933c1441dcbf42d3316b78ca5"", ""filename"": ""src/hashtable_seed.c"", ""status"": ""added"", ""additions"": 278, ""deletions"": 0, ""changes"": 278, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable_seed.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable_seed.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable_seed.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,278 @@\n+/* Generate sizeof(uint32_t) bytes of as random data as possible to seed\n+   the hash function.\n+*/\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#include <stdio.h>\n+#include <time.h>\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n+#ifdef HAVE_FCNTL_H\n+#include <fcntl.h>\n+#endif\n+\n+#ifdef HAVE_SCHED_H\n+#include <sched.h>\n+#endif\n+\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+\n+#ifdef HAVE_SYS_STAT_H\n+#include <sys/stat.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TIME_H\n+#include <sys/time.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TYPES_H\n+#include <sys/types.h>\n+#endif\n+\n+#if defined(_WIN32)\n+/* For _getpid() */\n+#include <process.h>\n+#endif\n+\n+#include \""jansson.h\""\n+\n+\n+static uint32_t buf_to_uint32(char *data) {\n+    size_t i;\n+    uint32_t result = 0;\n+\n+    for (i = 0; i < sizeof(uint32_t); i++)\n+        result = (result << 8) | (unsigned char)data[i];\n+\n+    return result;\n+}\n+\n+\n+\n+/* /dev/urandom */\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+static int seed_from_urandom(uint32_t *seed) {\n+    /* Use unbuffered I/O if we have open(), close() and read(). Otherwise\n+       fall back to fopen() */\n+\n+    char data[sizeof(uint32_t)];\n+    int ok;\n+\n+#if defined(HAVE_OPEN) && defined(HAVE_CLOSE) && defined(HAVE_READ)\n+    int urandom;\n+    urandom = open(\""/dev/urandom\"", O_RDONLY);\n+    if (urandom == -1)\n+        return 1;\n+\n+    ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);\n+    close(urandom);\n+#else\n+    FILE *urandom;\n+\n+    urandom = fopen(\""/dev/urandom\"", \""rb\"");\n+    if (!urandom)\n+        return 1;\n+\n+    ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);\n+    fclose(urandom);\n+#endif\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32(data);\n+    return 0;\n+}\n+#endif\n+\n+/* Windows Crypto API */\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+#include <windows.h>\n+#include <wincrypt.h>\n+\n+typedef BOOL (WINAPI *CRYPTACQUIRECONTEXTA)(HCRYPTPROV *phProv, LPCSTR pszContainer, LPCSTR pszProvider, DWORD dwProvType, DWORD dwFlags);\n+typedef BOOL (WINAPI *CRYPTGENRANDOM)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);\n+typedef BOOL (WINAPI *CRYPTRELEASECONTEXT)(HCRYPTPROV hProv, DWORD dwFlags);\n+\n+static int seed_from_windows_cryptoapi(uint32_t *seed)\n+{\n+    HINSTANCE hAdvAPI32 = NULL;\n+    CRYPTACQUIRECONTEXTA pCryptAcquireContext = NULL;\n+    CRYPTGENRANDOM pCryptGenRandom = NULL;\n+    CRYPTRELEASECONTEXT pCryptReleaseContext = NULL;\n+    HCRYPTPROV hCryptProv = 0;\n+    BYTE data[sizeof(uint32_t)];\n+    int ok;\n+\n+    hAdvAPI32 = GetModuleHandle(\""advapi32.dll\"");\n+    if(hAdvAPI32 == NULL)\n+        return 1;\n+\n+    pCryptAcquireContext = (CRYPTACQUIRECONTEXTA)GetProcAddress(hAdvAPI32, \""CryptAcquireContextA\"");\n+    if (!pCryptAcquireContext)\n+        return 1;\n+\n+    pCryptGenRandom = (CRYPTGENRANDOM)GetProcAddress(hAdvAPI32, \""CryptGenRandom\"");\n+    if (!pCryptGenRandom)\n+        return 1;\n+\n+    pCryptReleaseContext = (CRYPTRELEASECONTEXT)GetProcAddress(hAdvAPI32, \""CryptReleaseContext\"");\n+    if (!pCryptReleaseContext)\n+        return 1;\n+\n+    if (!pCryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))\n+        return 1;\n+\n+    ok = CryptGenRandom(hCryptProv, sizeof(uint32_t), data);\n+    pCryptReleaseContext(hCryptProv, 0);\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32((char *)data);\n+    return 0;\n+}\n+#endif\n+\n+/* gettimeofday() and getpid() */\n+static int seed_from_timestamp_and_pid(uint32_t *seed) {\n+#ifdef HAVE_GETTIMEOFDAY\n+    /* XOR of seconds and microseconds */\n+    struct timeval tv;\n+    gettimeofday(&tv, NULL);\n+    *seed = (uint32_t)tv.tv_sec ^ (uint32_t)tv.tv_usec;\n+#else\n+    /* Seconds only */\n+    *seed = (uint32_t)time(NULL);\n+#endif\n+\n+    /* XOR with PID for more randomness */\n+#if defined(_WIN32)\n+    *seed ^= (uint32_t)_getpid();\n+#elif defined(HAVE_GETPID)\n+    *seed ^= (uint32_t)getpid();\n+#endif\n+\n+    return 0;\n+}\n+\n+static uint32_t generate_seed() {\n+    uint32_t seed;\n+    int done = 0;\n+\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+    if (!done && seed_from_urandom(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+    if (!done && seed_from_windows_cryptoapi(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+    if (!done) {\n+        /* Fall back to timestamp and PID if no better randomness is\n+           available */\n+        seed_from_timestamp_and_pid(&seed);\n+    }\n+\n+    /* Make sure the seed is never zero */\n+    if (seed == 0)\n+        seed = 1;\n+\n+    return seed;\n+}\n+\n+\n+volatile uint32_t hashtable_seed = 0;\n+\n+#if defined(HAVE_ATOMIC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+static volatile char seed_initialized = 0;\n+\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (__atomic_test_and_set(&seed_initialized, __ATOMIC_RELAXED) == 0) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            __atomic_store_n(&hashtable_seed, new_seed, __ATOMIC_ACQ_REL);\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            } while(__atomic_load_n(&hashtable_seed, __ATOMIC_ACQUIRE) == 0);\n+        }\n+    }\n+}\n+#elif defined(HAVE_SYNC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0) {\n+            /* Explicit synchronization fences are not supported by the\n+               __sync builtins, so every thread getting here has to\n+               generate the seed value.\n+            */\n+            new_seed = generate_seed();\n+        }\n+\n+        do {\n+            if (__sync_bool_compare_and_swap(&hashtable_seed, 0, new_seed)) {\n+                /* We were the first to seed */\n+                break;\n+            } else {\n+                /* Wait for another thread to do the seeding */\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            }\n+        } while(hashtable_seed == 0);\n+    }\n+}\n+#elif defined(_WIN32)\n+static long seed_initialized = 0;\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (InterlockedIncrement(&seed_initialized) == 1) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            hashtable_seed = new_seed;\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+                SwitchToThread();\n+            } while (hashtable_seed == 0);\n+        }\n+    }\n+}\n+#else\n+/* Fall back to a thread-unsafe version */\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0)\n+            new_seed = generate_seed();\n+\n+        hashtable_seed = new_seed;\n+    }\n+}\n+#endif""}<_**next**_>{""sha"": ""19096d4201e6b13f8c56765116865c71f67e9696"", ""filename"": ""src/jansson.def"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.def"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.def"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/jansson.def?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -41,6 +41,7 @@ EXPORTS\n     json_object_iter_value\n     json_object_iter_set_new\n     json_object_key_to_iter\n+    json_object_seed\n     json_dumps\n     json_dumpf\n     json_dump_file""}<_**next**_>{""sha"": ""ea230852a629e55457fba2d00e3edd8a4ad4fcec"", ""filename"": ""src/jansson.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/jansson.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -126,6 +126,7 @@ typedef struct {\n \n /* getters, setters, manipulation */\n \n+void json_object_seed(size_t seed);\n size_t json_object_size(const json_t *object);\n json_t *json_object_get(const json_t *object, const char *key);\n int json_object_set_new(json_t *object, const char *key, json_t *value);""}<_**next**_>{""sha"": ""dc76138c940516e9590784825d28d040fd1a8b25"", ""filename"": ""src/lookup3.h"", ""status"": ""added"", ""additions"": 366, ""deletions"": 0, ""changes"": 366, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/lookup3.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/lookup3.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/lookup3.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,366 @@\n+/*\n+-------------------------------------------------------------------------------\n+lookup3.c, by Bob Jenkins, May 2006, Public Domain.\n+\n+These are functions for producing 32-bit hashes for hash table lookup.\n+hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final() \n+are externally useful functions.  Routines to test the hash are included \n+if SELF_TEST is defined.  You can use this free for any purpose.  It's in\n+the public domain.  It has no warranty.\n+\n+You probably want to use hashlittle().  hashlittle() and hashbig()\n+hash byte arrays.  hashlittle() is is faster than hashbig() on\n+little-endian machines.  Intel and AMD are little-endian machines.\n+On second thought, you probably want hashlittle2(), which is identical to\n+hashlittle() except it returns two 32-bit hashes for the price of one.  \n+You could implement hashbig2() if you wanted but I haven't bothered here.\n+\n+If you want to find a hash of, say, exactly 7 integers, do\n+  a = i1;  b = i2;  c = i3;\n+  mix(a,b,c);\n+  a += i4; b += i5; c += i6;\n+  mix(a,b,c);\n+  a += i7;\n+  final(a,b,c);\n+then use c as the hash value.  If you have a variable length array of\n+4-byte integers to hash, use hashword().  If you have a byte array (like\n+a character string), use hashlittle().  If you have several byte arrays, or\n+a mix of things, see the comments above hashlittle().  \n+\n+Why is this so big?  I read 12 bytes at a time into 3 4-byte integers, \n+then mix those integers.  This is fast (you can do a lot more thorough\n+mixing with 12*3 instructions on 3 integers than you can with 3 instructions\n+on 1 byte), but shoehorning those bytes into integers efficiently is messy.\n+-------------------------------------------------------------------------------\n+*/\n+\n+#include <stdlib.h>\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>     /* defines uint32_t etc */\n+#endif\n+\n+#ifdef HAVE_SYS_PARAM_H\n+#include <sys/param.h>  /* attempt to define endianness */\n+#endif\n+\n+#ifdef HAVE_ENDIAN_H\n+# include <endian.h>    /* attempt to define endianness */\n+#endif\n+\n+/*\n+ * My best guess at if you are big-endian or little-endian.  This may\n+ * need adjustment.\n+ */\n+#if (defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && \\\n+     __BYTE_ORDER == __LITTLE_ENDIAN) || \\\n+    (defined(i386) || defined(__i386__) || defined(__i486__) || \\\n+     defined(__i586__) || defined(__i686__) || defined(vax) || defined(MIPSEL))\n+# define HASH_LITTLE_ENDIAN 1\n+# define HASH_BIG_ENDIAN 0\n+#elif (defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && \\\n+       __BYTE_ORDER == __BIG_ENDIAN) || \\\n+      (defined(sparc) || defined(POWERPC) || defined(mc68000) || defined(sel))\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 1\n+#else\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 0\n+#endif\n+\n+#define hashsize(n) ((uint32_t)1<<(n))\n+#define hashmask(n) (hashsize(n)-1)\n+#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n+\n+/*\n+-------------------------------------------------------------------------------\n+mix -- mix 3 32-bit values reversibly.\n+\n+This is reversible, so any information in (a,b,c) before mix() is\n+still in (a,b,c) after mix().\n+\n+If four pairs of (a,b,c) inputs are run through mix(), or through\n+mix() in reverse, there are at least 32 bits of the output that\n+are sometimes the same for one pair and different for another pair.\n+This was tested for:\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+Some k values for my \""a-=c; a^=rot(c,k); c+=b;\"" arrangement that\n+satisfy this are\n+    4  6  8 16 19  4\n+    9 15  3 18 27 15\n+   14  9  3  7 17  3\n+Well, \""9 15 3 18 27 15\"" didn't quite get 32 bits diffing\n+for \""differ\"" defined as + with a one-bit base and a two-bit delta.  I\n+used http://burtleburtle.net/bob/hash/avalanche.html to choose \n+the operations, constants, and arrangements of the variables.\n+\n+This does not achieve avalanche.  There are input bits of (a,b,c)\n+that fail to affect some output bits of (a,b,c), especially of a.  The\n+most thoroughly mixed value is c, but it doesn't really even achieve\n+avalanche in c.\n+\n+This allows some parallelism.  Read-after-writes are good at doubling\n+the number of bits affected, so the goal of mixing pulls in the opposite\n+direction as the goal of parallelism.  I did what I could.  Rotates\n+seem to cost as much as shifts on every machine I could lay my hands\n+on, and rotates are much kinder to the top and bottom bits, so I used\n+rotates.\n+-------------------------------------------------------------------------------\n+*/\n+#define mix(a,b,c) \\\n+{ \\\n+  a -= c;  a ^= rot(c, 4);  c += b; \\\n+  b -= a;  b ^= rot(a, 6);  a += c; \\\n+  c -= b;  c ^= rot(b, 8);  b += a; \\\n+  a -= c;  a ^= rot(c,16);  c += b; \\\n+  b -= a;  b ^= rot(a,19);  a += c; \\\n+  c -= b;  c ^= rot(b, 4);  b += a; \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+final -- final mixing of 3 32-bit values (a,b,c) into c\n+\n+Pairs of (a,b,c) values differing in only a few bits will usually\n+produce values of c that look totally different.  This was tested for\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+These constants passed:\n+ 14 11 25 16 4 14 24\n+ 12 14 25 16 4 14 24\n+and these came close:\n+  4  8 15 26 3 22 24\n+ 10  8 15 26 3 22 24\n+ 11  8 15 26 3 22 24\n+-------------------------------------------------------------------------------\n+*/\n+#define final(a,b,c) \\\n+{ \\\n+  c ^= b; c -= rot(b,14); \\\n+  a ^= c; a -= rot(c,11); \\\n+  b ^= a; b -= rot(a,25); \\\n+  c ^= b; c -= rot(b,16); \\\n+  a ^= c; a -= rot(c,4);  \\\n+  b ^= a; b -= rot(a,14); \\\n+  c ^= b; c -= rot(b,24); \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+hashlittle() -- hash a variable-length key into a 32-bit value\n+  k       : the key (the unaligned variable-length array of bytes)\n+  length  : the length of the key, counting by bytes\n+  initval : can be any 4-byte value\n+Returns a 32-bit value.  Every bit of the key affects every bit of\n+the return value.  Two keys differing by one or two bits will have\n+totally different hash values.\n+\n+The best hash table sizes are powers of 2.  There is no need to do\n+mod a prime (mod is sooo slow!).  If you need less than 32 bits,\n+use a bitmask.  For example, if you need only 10 bits, do\n+  h = (h & hashmask(10));\n+In which case, the hash table should have hashsize(10) elements.\n+\n+If you are hashing n strings (uint8_t **)k, do it like this:\n+  for (i=0, h=0; i<n; ++i) h = hashlittle( k[i], len[i], h);\n+\n+By Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this\n+code any way you wish, private, educational, or commercial.  It's free.\n+\n+Use for hash table lookup, or anything where one collision in 2^^32 is\n+acceptable.  Do NOT use for cryptographic purposes.\n+-------------------------------------------------------------------------------\n+*/\n+\n+static uint32_t hashlittle(const void *key, size_t length, uint32_t initval)\n+{\n+  uint32_t a,b,c;                                          /* internal state */\n+  union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */\n+\n+  /* Set up the internal state */\n+  a = b = c = 0xdeadbeef + ((uint32_t)length) + initval;\n+\n+  u.ptr = key;\n+  if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0)) {\n+    const uint32_t *k = (const uint32_t *)key;         /* read 32-bit chunks */\n+\n+#ifdef VALGRIND\n+    const uint8_t  *k8;\n+#endif\n+\n+    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      b += k[1];\n+      c += k[2];\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 3;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    /* \n+     * \""k[2]&0xffffff\"" actually reads beyond the end of the string, but\n+     * then masks off the part it's not allowed to read.  Because the\n+     * string is aligned, the masked-off tail is in the same word as the\n+     * rest of the string.  Every machine with memory protection I've seen\n+     * does it on word boundaries, so is OK with this.  But VALGRIND will\n+     * still catch it and complain.  The masking trick does make the hash\n+     * noticably faster for short strings (like English words).\n+     */\n+#ifndef VALGRIND\n+\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n+    case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n+    case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n+    case 6 : b+=k[1]&0xffff; a+=k[0]; break;\n+    case 5 : b+=k[1]&0xff; a+=k[0]; break;\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=k[0]&0xffffff; break;\n+    case 2 : a+=k[0]&0xffff; break;\n+    case 1 : a+=k[0]&0xff; break;\n+    case 0 : return c;              /* zero length strings require no mixing */\n+    }\n+\n+#else /* make valgrind happy */\n+\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=((uint32_t)k8[10])<<16;  /* fall through */\n+    case 10: c+=((uint32_t)k8[9])<<8;    /* fall through */\n+    case 9 : c+=k8[8];                   /* fall through */\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;   /* fall through */\n+    case 6 : b+=((uint32_t)k8[5])<<8;    /* fall through */\n+    case 5 : b+=k8[4];                   /* fall through */\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;   /* fall through */\n+    case 2 : a+=((uint32_t)k8[1])<<8;    /* fall through */\n+    case 1 : a+=k8[0]; break;\n+    case 0 : return c;\n+    }\n+\n+#endif /* !valgrind */\n+\n+  } else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0)) {\n+    const uint16_t *k = (const uint16_t *)key;         /* read 16-bit chunks */\n+    const uint8_t  *k8;\n+\n+    /*--------------- all but last block: aligned reads and different mixing */\n+    while (length > 12)\n+    {\n+      a += k[0] + (((uint32_t)k[1])<<16);\n+      b += k[2] + (((uint32_t)k[3])<<16);\n+      c += k[4] + (((uint32_t)k[5])<<16);\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 6;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[4]+(((uint32_t)k[5])<<16);\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 11: c+=((uint32_t)k8[10])<<16;     /* fall through */\n+    case 10: c+=k[4];\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 9 : c+=k8[8];                      /* fall through */\n+    case 8 : b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;      /* fall through */\n+    case 6 : b+=k[2];\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 5 : b+=k8[4];                      /* fall through */\n+    case 4 : a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;      /* fall through */\n+    case 2 : a+=k[0];\n+             break;\n+    case 1 : a+=k8[0];\n+             break;\n+    case 0 : return c;                     /* zero length requires no mixing */\n+    }\n+\n+  } else {                        /* need to read the key one byte at a time */\n+    const uint8_t *k = (const uint8_t *)key;\n+\n+    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      a += ((uint32_t)k[1])<<8;\n+      a += ((uint32_t)k[2])<<16;\n+      a += ((uint32_t)k[3])<<24;\n+      b += k[4];\n+      b += ((uint32_t)k[5])<<8;\n+      b += ((uint32_t)k[6])<<16;\n+      b += ((uint32_t)k[7])<<24;\n+      c += k[8];\n+      c += ((uint32_t)k[9])<<8;\n+      c += ((uint32_t)k[10])<<16;\n+      c += ((uint32_t)k[11])<<24;\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 12;\n+    }\n+\n+    /*-------------------------------- last block: affect all 32 bits of (c) */\n+    switch(length)                   /* all the case statements fall through */\n+    {\n+    case 12: c+=((uint32_t)k[11])<<24;\n+    case 11: c+=((uint32_t)k[10])<<16;\n+    case 10: c+=((uint32_t)k[9])<<8;\n+    case 9 : c+=k[8];\n+    case 8 : b+=((uint32_t)k[7])<<24;\n+    case 7 : b+=((uint32_t)k[6])<<16;\n+    case 6 : b+=((uint32_t)k[5])<<8;\n+    case 5 : b+=k[4];\n+    case 4 : a+=((uint32_t)k[3])<<24;\n+    case 3 : a+=((uint32_t)k[2])<<16;\n+    case 2 : a+=((uint32_t)k[1])<<8;\n+    case 1 : a+=k[0];\n+             break;\n+    case 0 : return c;\n+    }\n+  }\n+\n+  final(a,b,c);\n+  return c;\n+}""}<_**next**_>{""sha"": ""b4f109143031b2481a0d32a332c88cc1cc96c688"", ""filename"": ""src/utf.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 16, ""changes"": 20, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/utf.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/utf.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/utf.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -10,23 +10,11 @@\n \n #ifdef HAVE_CONFIG_H\n #include <config.h>\n+#endif\n \n-#ifdef HAVE_INTTYPES_H\n-/* inttypes.h includes stdint.h in a standard environment, so there's\n-no need to include stdint.h separately. If inttypes.h doesn't define\n-int32_t, it's defined in config.h. */\n-#include <inttypes.h>\n-#endif /* HAVE_INTTYPES_H */\n-\n-#else /* !HAVE_CONFIG_H */\n-#ifdef _WIN32\n-typedef int int32_t;\n-#else /* !_WIN32 */\n-/* Assume a standard environment */\n-#include <inttypes.h>\n-#endif /* _WIN32 */\n-\n-#endif /* HAVE_CONFIG_H */\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n \n int utf8_encode(int codepoint, char *buffer, int *size);\n ""}<_**next**_>{""sha"": ""1b02d90aa885f1ede146bb2077d05c8bb9096565"", ""filename"": ""src/value.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/value.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/value.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/value.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -9,11 +9,19 @@\n #define _GNU_SOURCE\n #endif\n \n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stddef.h>\n #include <stdlib.h>\n #include <string.h>\n #include <math.h>\n \n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include \""jansson.h\""\n #include \""hashtable.h\""\n #include \""jansson_private.h\""\n@@ -36,11 +44,19 @@ static JSON_INLINE void json_init(json_t *json, json_type type)\n \n /*** object ***/\n \n+extern volatile uint32_t hashtable_seed;\n+\n json_t *json_object(void)\n {\n     json_object_t *object = jsonp_malloc(sizeof(json_object_t));\n     if(!object)\n         return NULL;\n+\n+    if (!hashtable_seed) {\n+        /* Autoseed */\n+        json_object_seed(0);\n+    }\n+\n     json_init(&object->json, JSON_OBJECT);\n \n     if(hashtable_init(&object->hashtable))""}<_**next**_>{""sha"": ""e2c54bd12bd7c22de7cc3533f010b26cc1c330b0"", ""filename"": ""test/bin/json_process.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 1, ""changes"": 16, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/bin/json_process.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/bin/json_process.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/bin/json_process.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -37,6 +37,8 @@ struct config {\n     int sort_keys;\n     int strip;\n     int use_env;\n+    int have_hashseed;\n+    int hashseed;\n } conf;\n \n #define l_isspace(c) ((c) == ' ' || (c) == '\\n' || (c) == '\\r' || (c) == '\\t')\n@@ -108,6 +110,12 @@ static void read_conf(FILE *conffile)\n             conf.sort_keys = atoi(val);\n         if (!strcmp(line, \""STRIP\""))\n             conf.strip = atoi(val);\n+        if (!strcmp(line, \""HASHSEED\"")) {\n+            conf.have_hashseed = 1;\n+            conf.hashseed = atoi(val);\n+        } else {\n+            conf.have_hashseed = 0;\n+        }\n     }\n \n     free(buffer);\n@@ -188,6 +196,9 @@ int use_conf(char *test_path)\n     if (conf.sort_keys)\n         flags |= JSON_SORT_KEYS;\n \n+    if (conf.have_hashseed)\n+        json_object_seed(conf.hashseed);\n+\n     if (conf.strip) {\n         /* Load to memory, strip leading and trailing whitespace */\n         buffer = loadfile(infile);\n@@ -265,7 +276,10 @@ int use_env()\n         flags |= JSON_PRESERVE_ORDER;\n \n     if(getenv_int(\""JSON_SORT_KEYS\""))\n-         flags |= JSON_SORT_KEYS;\n+        flags |= JSON_SORT_KEYS;\n+\n+    if(getenv(\""HASHSEED\""))\n+        json_object_seed(getenv_int(\""HASHSEED\""));\n \n     if(getenv_int(\""STRIP\"")) {\n         /* Load to memory, strip leading and trailing whitespace */""}<_**next**_>{""sha"": ""84b17466fd0a753b8cbd714d0236ed9072cdd536"", ""filename"": ""test/suites/api/test_memory_funcs.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_memory_funcs.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_memory_funcs.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/api/test_memory_funcs.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -24,13 +24,13 @@ static void create_and_free_complex_object()\n \n static void *my_malloc(size_t size)\n {\n-    malloc_called += 1;\n+    malloc_called = 1;\n     return malloc(size);\n }\n \n static void my_free(void *ptr)\n {\n-    free_called += 1;\n+    free_called = 1;\n     free(ptr);\n }\n \n@@ -39,7 +39,7 @@ static void test_simple()\n     json_set_alloc_funcs(my_malloc, my_free);\n     create_and_free_complex_object();\n \n-    if(malloc_called != 20 || free_called != 20)\n+    if(malloc_called != 1 || free_called != 1)\n         fail(\""Custom allocation failed\"");\n }\n ""}<_**next**_>{""sha"": ""92e5208224b75ab45d93672446279d598052a83e"", ""filename"": ""test/suites/api/test_object.c"", ""status"": ""modified"", ""additions"": 40, ""deletions"": 24, ""changes"": 64, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_object.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_object.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/api/test_object.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -249,7 +249,11 @@ static void test_set_nocheck()\n \n static void test_iterators()\n {\n+    int i;\n     json_t *object, *foo, *bar, *baz;\n+    const char *iter_keys[3];\n+    int have_key[3] = { 0, 0, 0 };\n+    json_t *iter_values[3];\n     void *iter;\n \n     if(json_object_iter(NULL))\n@@ -276,30 +280,50 @@ static void test_iterators()\n     iter = json_object_iter(object);\n     if(!iter)\n         fail(\""unable to get iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""a\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != foo)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[0] = json_object_iter_key(iter);\n+    iter_values[0] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""b\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != bar)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[1] = json_object_iter_key(iter);\n+    iter_values[1] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[2] = json_object_iter_key(iter);\n+    iter_values[2] = json_object_iter_value(iter);\n \n     if(json_object_iter_next(object, iter) != NULL)\n         fail(\""able to iterate over the end\"");\n \n+    /* Check that keys have correct values */\n+    for (i = 0; i < 3; i++) {\n+        if (strcmp(iter_keys[i], \""a\"") == 0) {\n+            if (iter_values[i] != foo)\n+                fail(\""wrong value for iter key a\"");\n+            else\n+                have_key[0] = 1;\n+        } else if (strcmp(iter_keys[i], \""b\"") == 0) {\n+            if (iter_values[i] != bar)\n+                fail(\""wrong value for iter key b\"");\n+            else\n+                have_key[1] = 1;\n+        } else if (strcmp(iter_keys[i], \""c\"") == 0) {\n+            if (iter_values[i] != baz)\n+                fail(\""wrong value for iter key c\"");\n+            else\n+                have_key[2] = 1;\n+        }\n+    }\n+\n+    /* Check that we got all keys */\n+    for(i = 0; i < 3; i++) {\n+        if(!have_key[i])\n+            fail(\""a key wasn't iterated over\"");\n+    }\n+\n     if(json_object_iter_at(object, \""foo\""))\n         fail(\""json_object_iter_at() succeeds for non-existent key\"");\n \n@@ -312,22 +336,14 @@ static void test_iterators()\n     if(json_object_iter_value(iter) != bar)\n         fail(\""iterating failed: wrong value\"");\n \n-    iter = json_object_iter_next(object, iter);\n-    if(!iter)\n-        fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\""iterating failed: wrong value\"");\n-\n-    if(json_object_iter_set(object, iter, bar))\n+    if(json_object_iter_set(object, iter, baz))\n         fail(\""unable to set value at iterator\"");\n \n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n+    if(strcmp(json_object_iter_key(iter), \""b\""))\n         fail(\""json_object_iter_key() fails after json_object_iter_set()\"");\n-    if(json_object_iter_value(iter) != bar)\n+    if(json_object_iter_value(iter) != baz)\n         fail(\""json_object_iter_value() fails after json_object_iter_set()\"");\n-    if(json_object_get(object, \""c\"") != bar)\n+    if(json_object_get(object, \""b\"") != baz)\n         fail(\""json_object_get() fails after json_object_iter_set()\"");\n \n     json_decref(object);""}<_**next**_>{""sha"": ""93cb33ddafeb9eef6ce7ad4709ce1bcbdf25b200"", ""filename"": ""test/suites/encoding-flags/compact-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/compact-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/compact-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/compact-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,2 +1,3 @@\n JSON_COMPACT=1\n-export JSON_COMPACT\n+HASHSEED=1\n+export JSON_COMPACT HASHSEED""}<_**next**_>{""sha"": ""c73acc1792963be8a5f41ff11f6e858506ada51d"", ""filename"": ""test/suites/encoding-flags/indent-compact-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-compact-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-compact-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/indent-compact-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,3 +1,4 @@\n JSON_INDENT=4\n JSON_COMPACT=1\n-export JSON_INDENT JSON_COMPACT\n+HASHSEED=1\n+export JSON_INDENT JSON_COMPACT HASHSEED""}<_**next**_>{""sha"": ""961558ca23ceca2ce6e4d07697f4018d8475f317"", ""filename"": ""test/suites/encoding-flags/indent-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/indent-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,2 +1,3 @@\n JSON_INDENT=4\n-export JSON_INDENT\n+HASHSEED=1\n+export JSON_INDENT HASHSEED""}<_**next**_>{""sha"": ""9120b03514ec614695c2d17841ba228b102c9db6"", ""filename"": ""test/suites/encoding-flags/object/env"", ""status"": ""added"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,2 @@\n+HASHSEED=1\n+export HASHSEED""}","void *hashtable_iter_at(hashtable_t *hashtable, const char *key)
{
    pair_t *pair;
    size_t hash;
     bucket_t *bucket;
 
     hash = hash_str(key);
    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)
        return NULL;

    return &pair->list;
}
","void *hashtable_iter_at(hashtable_t *hashtable, const char *key)
{
    pair_t *pair;
    size_t hash;
     bucket_t *bucket;
 
     hash = hash_str(key);
    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)
        return NULL;

    return &pair->list;
}
",C,"    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];
","    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
",,"@@ -5,8 +5,17 @@
  * it under the terms of the MIT license. See LICENSE for details.
  */
 
+#if HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include <stdlib.h>
 #include <string.h>
+
+#if HAVE_STDINT_H
+#include <stdint.h>
+#endif
+
 #include <jansson_config.h>   /* for JSON_INLINE */
 #include ""jansson_private.h""  /* for container_of() */
 #include ""hashtable.h""
@@ -15,24 +24,13 @@ typedef struct hashtable_list list_t;
 typedef struct hashtable_pair pair_t;
 typedef struct hashtable_bucket bucket_t;
 
-#define list_to_pair(list_)  container_of(list_, pair_t, list)
-
-/* From http://www.cse.yorku.ca/~oz/hash.html */
-static size_t hash_str(const void *ptr)
-{
-    const char *str = (const char *)ptr;
-
-    size_t hash = 5381;
-    size_t c;
+extern volatile uint32_t hashtable_seed;
 
-    while((c = (size_t)*str))
-    {
-        hash = ((hash << 5) + hash) + c;
-        str++;
-    }
+/* Implementation of the hash function */
+#include ""lookup3.h""
 
-    return hash;
-}
+#define list_to_pair(list_)  container_of(list_, pair_t, list)
+#define hash_str(key)        ((size_t)hashlittle((key), strlen(key), hashtable_seed))
 
 static JSON_INLINE void list_init(list_t *list)
 {
@@ -74,19 +72,6 @@ static void insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket,
     }
 }
 
-static const size_t primes[] = {
-    5, 13, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,
-    49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,
-    12582917, 25165843, 50331653, 100663319, 201326611, 402653189,
-    805306457, 1610612741
-};
-
-static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)
-{
-    return primes[hashtable->num_buckets];
-}
-
-
 static pair_t *hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket,
                                    const char *key, size_t hash)
 {
@@ -120,7 +105,7 @@ static int hashtable_do_del(hashtable_t *hashtable,
     bucket_t *bucket;
     size_t index;
 
-    index = hash % num_buckets(hashtable);
+    index = hash & hashmask(hashtable->order);
     bucket = &hashtable->buckets[index];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
@@ -167,14 +152,14 @@ static int hashtable_do_rehash(hashtable_t *hashtable)
 
     jsonp_free(hashtable->buckets);
 
-    hashtable->num_buckets++;
-    new_size = num_buckets(hashtable);
+    hashtable->order++;
+    new_size = hashsize(hashtable->order);
 
     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));
     if(!hashtable->buckets)
         return -1;
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -199,14 +184,14 @@ int hashtable_init(hashtable_t *hashtable)
     size_t i;
 
     hashtable->size = 0;
-    hashtable->num_buckets = 0;  /* index to primes[] */
-    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));
+    hashtable->order = 3;
+    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));
     if(!hashtable->buckets)
         return -1;
 
     list_init(&hashtable->list);
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -230,12 +215,12 @@ int hashtable_set(hashtable_t *hashtable,
     size_t hash, index;
 
     /* rehash if the load ratio exceeds 1 */
-    if(hashtable->size >= num_buckets(hashtable))
+    if(hashtable->size >= hashsize(hashtable->order))
         if(hashtable_do_rehash(hashtable))
             return -1;
 
     hash = hash_str(key);
-    index = hash % num_buckets(hashtable);
+    index = hash & hashmask(hashtable->order);
     bucket = &hashtable->buckets[index];
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
 
@@ -273,7 +258,7 @@ void *hashtable_get(hashtable_t *hashtable, const char *key)
     bucket_t *bucket;
 
     hash = hash_str(key);
-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)
@@ -294,7 +279,7 @@ void hashtable_clear(hashtable_t *hashtable)
 
     hashtable_do_clear(hashtable);
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -316,7 +301,7 @@ void *hashtable_iter_at(hashtable_t *hashtable, const char *key)
     bucket_t *bucket;
 
     hash = hash_str(key);
-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)",jansson,8f80c2d83808150724d31793e6ade92749b1faa4,b9c588de3deb4efdd7b9ec44aa79335dba11fd6b,1,"void *hashtable_iter_at(hashtable_t *hashtable, const char *key)
{
    pair_t *pair;
    size_t hash;
     bucket_t *bucket;
 
     hash = hash_str(key);
//flaw_line_below:
    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
//fix_flaw_line_below:
//    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)
        return NULL;

    return &pair->list;
}
"
1969,179705,,Remote,Not required,Partial,CVE-2013-6401,https://www.cvedetails.com/cve/CVE-2013-6401/,CWE-310,Low,,,,2014-03-20,5.0,"Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document.",2014-05-23,DoS ,2,https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4,8f80c2d83808150724d31793e6ade92749b1faa4,"CVE-2013-6401: Change hash function, randomize hashes

Thanks to Florian Weimer and Eric Sesterhenn for reporting, reviewing
and testing.",2,src/hashtable.c,"{""sha"": ""1043c9ae4c0bc0c1f6a5913783973383832ff14b"", ""filename"": ""CMakeLists.txt"", ""status"": ""modified"", ""additions"": 39, ""deletions"": 10, ""changes"": 49, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/CMakeLists.txt"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/CMakeLists.txt"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/CMakeLists.txt?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -52,6 +52,8 @@ project (jansson C)\n \n # Options\n OPTION (BUILD_SHARED_LIBS \""Build shared libraries.\"" OFF)\n+OPTION (USE_URANDOM \""Use /dev/urandom to seed the hash function.\"" ON)\n+OPTION (USE_WINDOWS_CRYPTOAPI \""Use CryptGenRandom to seed the hash function.\"" ON)\n \n if (MSVC)\n    # This option must match the settings used in your program, in particular if you\n@@ -85,12 +87,12 @@ set (JANSSON_SOVERSION 4)\n # for CheckFunctionKeywords\n set(CMAKE_MODULE_PATH \""${CMAKE_CURRENT_SOURCE_DIR}/cmake\"")\n \n+INCLUDE (CheckCSourceCompiles)\n include (CheckFunctionExists)\n include (CheckFunctionKeywords)\n include (CheckIncludeFiles)\n include (CheckTypeSize)\n \n-\n if (MSVC)\n    # Turn off Microsofts \""security\"" warnings.\n    add_definitions( \""/W3 /D_CRT_SECURE_NO_WARNINGS /wd4005 /wd4996 /nologo\"" )\n@@ -106,14 +108,25 @@ if (CMAKE_COMPILER_IS_GNUCC OR CMAKE_COMPILER_IS_GNUCXX)\n    set(CMAKE_C_FLAGS \""-fPIC\"")\n endif()\n \n-   \n+check_include_files (endian.h HAVE_ENDIAN_H)\n+check_include_files (fcntl.h HAVE_FCNTL_H)\n+check_include_files (sched.h HAVE_SCHED_H)\n+check_include_files (unistd.h HAVE_UNISTD_H)\n+check_include_files (sys/param.h HAVE_SYS_PARAM_H)\n+check_include_files (sys/stat.h HAVE_SYS_STAT_H)\n+check_include_files (sys/time.h HAVE_SYS_TIME_H)\n+check_include_files (sys/time.h HAVE_SYS_TYPES_H)\n+\n+check_function_exists (close HAVE_CLOSE)\n+check_function_exists (getpid HAVE_GETPID)\n+check_function_exists (gettimeofday HAVE_GETTIMEOFDAY)\n+check_function_exists (open HAVE_OPEN)\n+check_function_exists (read HAVE_READ)\n+check_function_exists (sched_yield HAVE_SCHED_YIELD)\n \n # Check for the int-type includes\n-check_include_files (sys/types.h HAVE_SYS_TYPES_H)\n-check_include_files (inttypes.h HAVE_INTTYPES_H)\n check_include_files (stdint.h HAVE_STDINT_H)\n \n-\n # Check our 64 bit integer sizes\n check_type_size (__int64 __INT64)\n check_type_size (int64_t INT64_T)\n@@ -124,17 +137,32 @@ check_type_size (int32_t INT32_T)\n check_type_size (__int32 __INT32)\n check_type_size (\""long\"" LONG_INT)\n check_type_size (\""int\"" INT)\n-\n if (HAVE_INT32_T)\n    set (JSON_INT32 int32_t)\n elseif (HAVE___INT32)\n    set (JSON_INT32 __int32)\n-elseif (HAVE_LONG AND (${LONG_INT} EQUAL 4))\n+elseif (HAVE_LONG_INT AND (${LONG_INT} EQUAL 4))\n    set (JSON_INT32 long)\n elseif (HAVE_INT AND (${INT} EQUAL 4))\n    set (JSON_INT32 int)\n else ()\n-   message (FATAL_ERROR \""Could not detect a valid 32 bit integer type\"")\n+   message (FATAL_ERROR \""Could not detect a valid 32-bit integer type\"")\n+endif ()\n+\n+check_type_size (uint32_t UINT32_T)\n+check_type_size (__uint32 __UINT32)\n+check_type_size (\""unsigned long\"" UNSIGNED_LONG_INT)\n+check_type_size (\""unsigned int\"" UNSIGNED_INT)\n+if (HAVE_UINT32_T)\n+   set (JSON_UINT32 uint32_t)\n+elseif (HAVE___UINT32)\n+   set (JSON_UINT32 __uint32)\n+elseif (HAVE_UNSIGNED_LONG_INT AND (${UNSIGNED_LONG_INT} EQUAL 4))\n+   set (JSON_UINT32 \""unsigned long\"")\n+elseif (HAVE_UNSIGNED_INT AND (${UNSIGNED_INT} EQUAL 4))\n+   set (JSON_UINT32 \""unsigned int\"")\n+else ()\n+   message (FATAL_ERROR \""Could not detect a valid unsigned 32-bit integer type\"")\n endif ()\n \n # Check for ssize_t and SSIZE_T existance.\n@@ -206,11 +234,9 @@ else ()\n    set (JSON_HAVE_LOCALECONV 0)\n endif ()\n \n-\n # check if we have setlocale\n check_function_exists (setlocale HAVE_SETLOCALE)\n \n-\n # Check what the inline keyword is.\n # Note that the original JSON_INLINE was always set to just 'inline', so this goes further.\n check_function_keywords(\""inline\"")\n@@ -238,6 +264,9 @@ elseif (HAVE__SNPRINTF)\n    set (JSON_SNPRINTF _snprintf)\n endif ()\n \n+check_c_source_compiles (\""int main() { unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1); return 0; } \"" HAVE_SYNC_BUILTINS)\n+check_c_source_compiles (\""int main() { char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE); return 0; }\"" HAVE_ATOMIC_BUILTINS)\n+\n # Create pkg-conf file.\n # (We use the same files as ./configure does, so we\n #  have to defined the same variables used there).""}<_**next**_>{""sha"": ""b27b9a3a849e94686aa648c1ec4d1bd4c8e35445"", ""filename"": ""cmake/config.h.cmake"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 21, ""changes"": 46, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/cmake/config.h.cmake"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/cmake/config.h.cmake"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/cmake/config.h.cmake?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,35 +1,36 @@\n-/* Reduced down to the defines that are actually used in the code */\n-\n-/* Define to 1 if you have the <inttypes.h> (and friends) header file. */\n-#cmakedefine HAVE_INTTYPES_H 1\n-#cmakedefine HAVE_STDINT_H 1\n+#cmakedefine HAVE_ENDIAN_H 1\n+#cmakedefine HAVE_FCNTL_H 1\n+#cmakedefine HAVE_SCHED_H 1\n+#cmakedefine HAVE_UNISTD_H 1\n+#cmakedefine HAVE_SYS_PARAM_H 1\n+#cmakedefine HAVE_SYS_STAT_H 1\n+#cmakedefine HAVE_SYS_TIME_H 1\n #cmakedefine HAVE_SYS_TYPES_H 1\n+#cmakedefine HAVE_STDINT_H 1\n \n-/* We must include this here, as in (eg) utf.h it will want to use\n-   the integer type, which in MSVC2010 will be in stdint.h\n-   (there is no inttypes.h in MSVC2010) */\n-#if defined(HAVE_STDINT_H)\n-#  include <stdint.h>\n-#elif defined(HAVE_INTTYPES_H)\n-#  include <inttypes.h>\n-#elif defined(HAVE_SYS_TYPES_H)\n-#  include <sys/types.h>\n-#endif\n+#cmakedefine HAVE_CLOSE 1\n+#cmakedefine HAVE_GETPID 1\n+#cmakedefine HAVE_GETTIMEOFDAY 1\n+#cmakedefine HAVE_OPEN 1\n+#cmakedefine HAVE_READ 1\n+#cmakedefine HAVE_SCHED_YIELD 1\n \n-/* Define to 1 if you have the <locale.h> header file. */\n-#cmakedefine HAVE_LOCALE_H 1\n+#cmakedefine HAVE_SYNC_BUILTINS 1\n+#cmakedefine HAVE_ATOMIC_BUILTINS 1\n \n-/* Define to 1 if you have the 'setlocale' function. */\n+#cmakedefine HAVE_LOCALE_H 1\n #cmakedefine HAVE_SETLOCALE 1\n \n-/* Define to the type of a signed integer type of width exactly 32 bits if\n-   such a type exists and the standard includes do not define it. */\n #cmakedefine HAVE_INT32_T 1\n-\n #ifndef HAVE_INT32_T\n #  define int32_t @JSON_INT32@\n #endif\n \n+#cmakedefine HAVE_UINT32_T 1\n+#ifndef HAVE_UINT32_T\n+#  define uint32_t @JSON_UINT32@\n+#endif\n+\n #cmakedefine HAVE_SSIZE_T 1\n \n #ifndef HAVE_SSIZE_T\n@@ -43,3 +44,6 @@\n #endif\n \n #cmakedefine HAVE_VSNPRINTF\n+\n+#cmakedefine USE_URANDOM 1\n+#cmakedefine USE_WINDOWS_CRYPTOAPI 1""}<_**next**_>{""sha"": ""113cb85e17a15f2fac83b528fe1880bc99481ccb"", ""filename"": ""configure.ac"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 2, ""changes"": 50, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/configure.ac"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/configure.ac"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/configure.ac?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -14,10 +14,11 @@ AM_CONDITIONAL([GCC], [test x$GCC = xyes])\n # Checks for libraries.\n \n # Checks for header files.\n-AC_CHECK_HEADERS([locale.h])\n+AC_CHECK_HEADERS([endian.h fcntl.h locale.h sched.h unistd.h sys/param.h sys/stat.h sys/time.h sys/types.h])\n \n # Checks for typedefs, structures, and compiler characteristics.\n AC_TYPE_INT32_T\n+AC_TYPE_UINT32_T\n AC_TYPE_LONG_LONG_INT\n \n AC_C_INLINE\n@@ -29,7 +30,31 @@ esac\n AC_SUBST([json_inline])\n \n # Checks for library functions.\n-AC_CHECK_FUNCS([strtoll localeconv])\n+AC_CHECK_FUNCS([close getpid gettimeofday localeconv open read sched_yield strtoll])\n+\n+AC_MSG_CHECKING([for gcc __sync builtins])\n+have_sync_builtins=no\n+AC_TRY_LINK(\n+  [], [unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1);],\n+  [have_sync_builtins=yes],\n+)\n+if test \""x$have_sync_builtins\"" = \""xyes\""; then\n+  AC_DEFINE([HAVE_SYNC_BUILTINS], [1],\n+    [Define to 1 if gcc's __sync builtins are available])\n+fi\n+AC_MSG_RESULT([$have_sync_builtins])\n+\n+AC_MSG_CHECKING([for gcc __atomic builtins])\n+have_atomic_builtins=no\n+AC_TRY_LINK(\n+  [], [char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE);],\n+  [have_atomic_builtins=yes],\n+)\n+if test \""x$have_atomic_builtins\"" = \""xyes\""; then\n+  AC_DEFINE([HAVE_ATOMIC_BUILTINS], [1],\n+    [Define to 1 if gcc's __atomic builtins are available])\n+fi\n+AC_MSG_RESULT([$have_atomic_builtins])\n \n case \""$ac_cv_type_long_long_int$ac_cv_func_strtoll\"" in\n      yesyes) json_have_long_long=1;;\n@@ -43,6 +68,27 @@ case \""$ac_cv_header_locale_h$ac_cv_func_localeconv\"" in\n esac\n AC_SUBST([json_have_localeconv])\n \n+# Features\n+AC_ARG_ENABLE([urandom],\n+  [AS_HELP_STRING([--disable-urandom],\n+    [Don't use /dev/urandom to seed the hash function])],\n+  [use_urandom=$enableval], [use_urandom=yes])\n+\n+if test \""x$use_urandom\"" = xyes; then\n+AC_DEFINE([USE_URANDOM], [1],\n+  [Define to 1 if /dev/urandom should be used for seeding the hash function])\n+fi\n+\n+AC_ARG_ENABLE([windows-cryptoapi],\n+  [AS_HELP_STRING([--disable-windows-cryptoapi],\n+    [Don't use CryptGenRandom to seed the hash function])],\n+  [use_windows_cryptoapi=$enableval], [use_windows_cryptoapi=yes])\n+\n+if test \""x$use_windows_cryptoapi\"" = xyes; then\n+AC_DEFINE([USE_WINDOWS_CRYPTOAPI], [1],\n+  [Define to 1 if CryptGenRandom should be used for seeding the hash function])\n+fi\n+\n AC_CONFIG_FILES([\n         jansson.pc\n         Makefile""}<_**next**_>{""sha"": ""b4af562e84b5ed9dba1107af7d1768dcdb0b9a95"", ""filename"": ""src/Makefile.am"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/Makefile.am"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/Makefile.am?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -8,6 +8,7 @@ libjansson_la_SOURCES = \\\n \terror.c \\\n \thashtable.c \\\n \thashtable.h \\\n+\thashtable_seed.c \\\n \tjansson_private.h \\\n \tload.c \\\n \tmemory.c \\""}<_**next**_>{""sha"": ""abd4bf11fe7a393fcf3d533b952aa8b5efa4ea30"", ""filename"": ""src/hashtable.c"", ""status"": ""modified"", ""additions"": 26, ""deletions"": 41, ""changes"": 67, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -5,8 +5,17 @@\n  * it under the terms of the MIT license. See LICENSE for details.\n  */\n \n+#if HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stdlib.h>\n #include <string.h>\n+\n+#if HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include <jansson_config.h>   /* for JSON_INLINE */\n #include \""jansson_private.h\""  /* for container_of() */\n #include \""hashtable.h\""\n@@ -15,24 +24,13 @@ typedef struct hashtable_list list_t;\n typedef struct hashtable_pair pair_t;\n typedef struct hashtable_bucket bucket_t;\n \n-#define list_to_pair(list_)  container_of(list_, pair_t, list)\n-\n-/* From http://www.cse.yorku.ca/~oz/hash.html */\n-static size_t hash_str(const void *ptr)\n-{\n-    const char *str = (const char *)ptr;\n-\n-    size_t hash = 5381;\n-    size_t c;\n+extern volatile uint32_t hashtable_seed;\n \n-    while((c = (size_t)*str))\n-    {\n-        hash = ((hash << 5) + hash) + c;\n-        str++;\n-    }\n+/* Implementation of the hash function */\n+#include \""lookup3.h\""\n \n-    return hash;\n-}\n+#define list_to_pair(list_)  container_of(list_, pair_t, list)\n+#define hash_str(key)        ((size_t)hashlittle((key), strlen(key), hashtable_seed))\n \n static JSON_INLINE void list_init(list_t *list)\n {\n@@ -74,19 +72,6 @@ static void insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket,\n     }\n }\n \n-static const size_t primes[] = {\n-    5, 13, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,\n-    49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,\n-    12582917, 25165843, 50331653, 100663319, 201326611, 402653189,\n-    805306457, 1610612741\n-};\n-\n-static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)\n-{\n-    return primes[hashtable->num_buckets];\n-}\n-\n-\n static pair_t *hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket,\n                                    const char *key, size_t hash)\n {\n@@ -120,7 +105,7 @@ static int hashtable_do_del(hashtable_t *hashtable,\n     bucket_t *bucket;\n     size_t index;\n \n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n@@ -167,14 +152,14 @@ static int hashtable_do_rehash(hashtable_t *hashtable)\n \n     jsonp_free(hashtable->buckets);\n \n-    hashtable->num_buckets++;\n-    new_size = num_buckets(hashtable);\n+    hashtable->order++;\n+    new_size = hashsize(hashtable->order);\n \n     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -199,14 +184,14 @@ int hashtable_init(hashtable_t *hashtable)\n     size_t i;\n \n     hashtable->size = 0;\n-    hashtable->num_buckets = 0;  /* index to primes[] */\n-    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));\n+    hashtable->order = 3;\n+    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n     list_init(&hashtable->list);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -230,12 +215,12 @@ int hashtable_set(hashtable_t *hashtable,\n     size_t hash, index;\n \n     /* rehash if the load ratio exceeds 1 */\n-    if(hashtable->size >= num_buckets(hashtable))\n+    if(hashtable->size >= hashsize(hashtable->order))\n         if(hashtable_do_rehash(hashtable))\n             return -1;\n \n     hash = hash_str(key);\n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n \n@@ -273,7 +258,7 @@ void *hashtable_get(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)\n@@ -294,7 +279,7 @@ void hashtable_clear(hashtable_t *hashtable)\n \n     hashtable_do_clear(hashtable);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -316,7 +301,7 @@ void *hashtable_iter_at(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)""}<_**next**_>{""sha"": ""469c6ecd869c4698f650fa81983bb3ee03d47fab"", ""filename"": ""src/hashtable.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -32,14 +32,15 @@ struct hashtable_bucket {\n typedef struct hashtable {\n     size_t size;\n     struct hashtable_bucket *buckets;\n-    size_t num_buckets;  /* index to primes[] */\n+    size_t order;  /* hashtable has pow(2, order) buckets */\n     struct hashtable_list list;\n } hashtable_t;\n \n \n #define hashtable_key_to_iter(key_) \\\n     (&(container_of(key_, struct hashtable_pair, key)->list))\n \n+\n /**\n  * hashtable_init - Initialize a hashtable object\n  *""}<_**next**_>{""sha"": ""a07d145d10df35b933c1441dcbf42d3316b78ca5"", ""filename"": ""src/hashtable_seed.c"", ""status"": ""added"", ""additions"": 278, ""deletions"": 0, ""changes"": 278, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable_seed.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable_seed.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable_seed.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,278 @@\n+/* Generate sizeof(uint32_t) bytes of as random data as possible to seed\n+   the hash function.\n+*/\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#include <stdio.h>\n+#include <time.h>\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n+#ifdef HAVE_FCNTL_H\n+#include <fcntl.h>\n+#endif\n+\n+#ifdef HAVE_SCHED_H\n+#include <sched.h>\n+#endif\n+\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+\n+#ifdef HAVE_SYS_STAT_H\n+#include <sys/stat.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TIME_H\n+#include <sys/time.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TYPES_H\n+#include <sys/types.h>\n+#endif\n+\n+#if defined(_WIN32)\n+/* For _getpid() */\n+#include <process.h>\n+#endif\n+\n+#include \""jansson.h\""\n+\n+\n+static uint32_t buf_to_uint32(char *data) {\n+    size_t i;\n+    uint32_t result = 0;\n+\n+    for (i = 0; i < sizeof(uint32_t); i++)\n+        result = (result << 8) | (unsigned char)data[i];\n+\n+    return result;\n+}\n+\n+\n+\n+/* /dev/urandom */\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+static int seed_from_urandom(uint32_t *seed) {\n+    /* Use unbuffered I/O if we have open(), close() and read(). Otherwise\n+       fall back to fopen() */\n+\n+    char data[sizeof(uint32_t)];\n+    int ok;\n+\n+#if defined(HAVE_OPEN) && defined(HAVE_CLOSE) && defined(HAVE_READ)\n+    int urandom;\n+    urandom = open(\""/dev/urandom\"", O_RDONLY);\n+    if (urandom == -1)\n+        return 1;\n+\n+    ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);\n+    close(urandom);\n+#else\n+    FILE *urandom;\n+\n+    urandom = fopen(\""/dev/urandom\"", \""rb\"");\n+    if (!urandom)\n+        return 1;\n+\n+    ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);\n+    fclose(urandom);\n+#endif\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32(data);\n+    return 0;\n+}\n+#endif\n+\n+/* Windows Crypto API */\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+#include <windows.h>\n+#include <wincrypt.h>\n+\n+typedef BOOL (WINAPI *CRYPTACQUIRECONTEXTA)(HCRYPTPROV *phProv, LPCSTR pszContainer, LPCSTR pszProvider, DWORD dwProvType, DWORD dwFlags);\n+typedef BOOL (WINAPI *CRYPTGENRANDOM)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);\n+typedef BOOL (WINAPI *CRYPTRELEASECONTEXT)(HCRYPTPROV hProv, DWORD dwFlags);\n+\n+static int seed_from_windows_cryptoapi(uint32_t *seed)\n+{\n+    HINSTANCE hAdvAPI32 = NULL;\n+    CRYPTACQUIRECONTEXTA pCryptAcquireContext = NULL;\n+    CRYPTGENRANDOM pCryptGenRandom = NULL;\n+    CRYPTRELEASECONTEXT pCryptReleaseContext = NULL;\n+    HCRYPTPROV hCryptProv = 0;\n+    BYTE data[sizeof(uint32_t)];\n+    int ok;\n+\n+    hAdvAPI32 = GetModuleHandle(\""advapi32.dll\"");\n+    if(hAdvAPI32 == NULL)\n+        return 1;\n+\n+    pCryptAcquireContext = (CRYPTACQUIRECONTEXTA)GetProcAddress(hAdvAPI32, \""CryptAcquireContextA\"");\n+    if (!pCryptAcquireContext)\n+        return 1;\n+\n+    pCryptGenRandom = (CRYPTGENRANDOM)GetProcAddress(hAdvAPI32, \""CryptGenRandom\"");\n+    if (!pCryptGenRandom)\n+        return 1;\n+\n+    pCryptReleaseContext = (CRYPTRELEASECONTEXT)GetProcAddress(hAdvAPI32, \""CryptReleaseContext\"");\n+    if (!pCryptReleaseContext)\n+        return 1;\n+\n+    if (!pCryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))\n+        return 1;\n+\n+    ok = CryptGenRandom(hCryptProv, sizeof(uint32_t), data);\n+    pCryptReleaseContext(hCryptProv, 0);\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32((char *)data);\n+    return 0;\n+}\n+#endif\n+\n+/* gettimeofday() and getpid() */\n+static int seed_from_timestamp_and_pid(uint32_t *seed) {\n+#ifdef HAVE_GETTIMEOFDAY\n+    /* XOR of seconds and microseconds */\n+    struct timeval tv;\n+    gettimeofday(&tv, NULL);\n+    *seed = (uint32_t)tv.tv_sec ^ (uint32_t)tv.tv_usec;\n+#else\n+    /* Seconds only */\n+    *seed = (uint32_t)time(NULL);\n+#endif\n+\n+    /* XOR with PID for more randomness */\n+#if defined(_WIN32)\n+    *seed ^= (uint32_t)_getpid();\n+#elif defined(HAVE_GETPID)\n+    *seed ^= (uint32_t)getpid();\n+#endif\n+\n+    return 0;\n+}\n+\n+static uint32_t generate_seed() {\n+    uint32_t seed;\n+    int done = 0;\n+\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+    if (!done && seed_from_urandom(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+    if (!done && seed_from_windows_cryptoapi(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+    if (!done) {\n+        /* Fall back to timestamp and PID if no better randomness is\n+           available */\n+        seed_from_timestamp_and_pid(&seed);\n+    }\n+\n+    /* Make sure the seed is never zero */\n+    if (seed == 0)\n+        seed = 1;\n+\n+    return seed;\n+}\n+\n+\n+volatile uint32_t hashtable_seed = 0;\n+\n+#if defined(HAVE_ATOMIC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+static volatile char seed_initialized = 0;\n+\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (__atomic_test_and_set(&seed_initialized, __ATOMIC_RELAXED) == 0) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            __atomic_store_n(&hashtable_seed, new_seed, __ATOMIC_ACQ_REL);\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            } while(__atomic_load_n(&hashtable_seed, __ATOMIC_ACQUIRE) == 0);\n+        }\n+    }\n+}\n+#elif defined(HAVE_SYNC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0) {\n+            /* Explicit synchronization fences are not supported by the\n+               __sync builtins, so every thread getting here has to\n+               generate the seed value.\n+            */\n+            new_seed = generate_seed();\n+        }\n+\n+        do {\n+            if (__sync_bool_compare_and_swap(&hashtable_seed, 0, new_seed)) {\n+                /* We were the first to seed */\n+                break;\n+            } else {\n+                /* Wait for another thread to do the seeding */\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            }\n+        } while(hashtable_seed == 0);\n+    }\n+}\n+#elif defined(_WIN32)\n+static long seed_initialized = 0;\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (InterlockedIncrement(&seed_initialized) == 1) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            hashtable_seed = new_seed;\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+                SwitchToThread();\n+            } while (hashtable_seed == 0);\n+        }\n+    }\n+}\n+#else\n+/* Fall back to a thread-unsafe version */\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0)\n+            new_seed = generate_seed();\n+\n+        hashtable_seed = new_seed;\n+    }\n+}\n+#endif""}<_**next**_>{""sha"": ""19096d4201e6b13f8c56765116865c71f67e9696"", ""filename"": ""src/jansson.def"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.def"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.def"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/jansson.def?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -41,6 +41,7 @@ EXPORTS\n     json_object_iter_value\n     json_object_iter_set_new\n     json_object_key_to_iter\n+    json_object_seed\n     json_dumps\n     json_dumpf\n     json_dump_file""}<_**next**_>{""sha"": ""ea230852a629e55457fba2d00e3edd8a4ad4fcec"", ""filename"": ""src/jansson.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/jansson.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -126,6 +126,7 @@ typedef struct {\n \n /* getters, setters, manipulation */\n \n+void json_object_seed(size_t seed);\n size_t json_object_size(const json_t *object);\n json_t *json_object_get(const json_t *object, const char *key);\n int json_object_set_new(json_t *object, const char *key, json_t *value);""}<_**next**_>{""sha"": ""dc76138c940516e9590784825d28d040fd1a8b25"", ""filename"": ""src/lookup3.h"", ""status"": ""added"", ""additions"": 366, ""deletions"": 0, ""changes"": 366, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/lookup3.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/lookup3.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/lookup3.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,366 @@\n+/*\n+-------------------------------------------------------------------------------\n+lookup3.c, by Bob Jenkins, May 2006, Public Domain.\n+\n+These are functions for producing 32-bit hashes for hash table lookup.\n+hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final() \n+are externally useful functions.  Routines to test the hash are included \n+if SELF_TEST is defined.  You can use this free for any purpose.  It's in\n+the public domain.  It has no warranty.\n+\n+You probably want to use hashlittle().  hashlittle() and hashbig()\n+hash byte arrays.  hashlittle() is is faster than hashbig() on\n+little-endian machines.  Intel and AMD are little-endian machines.\n+On second thought, you probably want hashlittle2(), which is identical to\n+hashlittle() except it returns two 32-bit hashes for the price of one.  \n+You could implement hashbig2() if you wanted but I haven't bothered here.\n+\n+If you want to find a hash of, say, exactly 7 integers, do\n+  a = i1;  b = i2;  c = i3;\n+  mix(a,b,c);\n+  a += i4; b += i5; c += i6;\n+  mix(a,b,c);\n+  a += i7;\n+  final(a,b,c);\n+then use c as the hash value.  If you have a variable length array of\n+4-byte integers to hash, use hashword().  If you have a byte array (like\n+a character string), use hashlittle().  If you have several byte arrays, or\n+a mix of things, see the comments above hashlittle().  \n+\n+Why is this so big?  I read 12 bytes at a time into 3 4-byte integers, \n+then mix those integers.  This is fast (you can do a lot more thorough\n+mixing with 12*3 instructions on 3 integers than you can with 3 instructions\n+on 1 byte), but shoehorning those bytes into integers efficiently is messy.\n+-------------------------------------------------------------------------------\n+*/\n+\n+#include <stdlib.h>\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>     /* defines uint32_t etc */\n+#endif\n+\n+#ifdef HAVE_SYS_PARAM_H\n+#include <sys/param.h>  /* attempt to define endianness */\n+#endif\n+\n+#ifdef HAVE_ENDIAN_H\n+# include <endian.h>    /* attempt to define endianness */\n+#endif\n+\n+/*\n+ * My best guess at if you are big-endian or little-endian.  This may\n+ * need adjustment.\n+ */\n+#if (defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && \\\n+     __BYTE_ORDER == __LITTLE_ENDIAN) || \\\n+    (defined(i386) || defined(__i386__) || defined(__i486__) || \\\n+     defined(__i586__) || defined(__i686__) || defined(vax) || defined(MIPSEL))\n+# define HASH_LITTLE_ENDIAN 1\n+# define HASH_BIG_ENDIAN 0\n+#elif (defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && \\\n+       __BYTE_ORDER == __BIG_ENDIAN) || \\\n+      (defined(sparc) || defined(POWERPC) || defined(mc68000) || defined(sel))\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 1\n+#else\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 0\n+#endif\n+\n+#define hashsize(n) ((uint32_t)1<<(n))\n+#define hashmask(n) (hashsize(n)-1)\n+#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n+\n+/*\n+-------------------------------------------------------------------------------\n+mix -- mix 3 32-bit values reversibly.\n+\n+This is reversible, so any information in (a,b,c) before mix() is\n+still in (a,b,c) after mix().\n+\n+If four pairs of (a,b,c) inputs are run through mix(), or through\n+mix() in reverse, there are at least 32 bits of the output that\n+are sometimes the same for one pair and different for another pair.\n+This was tested for:\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+Some k values for my \""a-=c; a^=rot(c,k); c+=b;\"" arrangement that\n+satisfy this are\n+    4  6  8 16 19  4\n+    9 15  3 18 27 15\n+   14  9  3  7 17  3\n+Well, \""9 15 3 18 27 15\"" didn't quite get 32 bits diffing\n+for \""differ\"" defined as + with a one-bit base and a two-bit delta.  I\n+used http://burtleburtle.net/bob/hash/avalanche.html to choose \n+the operations, constants, and arrangements of the variables.\n+\n+This does not achieve avalanche.  There are input bits of (a,b,c)\n+that fail to affect some output bits of (a,b,c), especially of a.  The\n+most thoroughly mixed value is c, but it doesn't really even achieve\n+avalanche in c.\n+\n+This allows some parallelism.  Read-after-writes are good at doubling\n+the number of bits affected, so the goal of mixing pulls in the opposite\n+direction as the goal of parallelism.  I did what I could.  Rotates\n+seem to cost as much as shifts on every machine I could lay my hands\n+on, and rotates are much kinder to the top and bottom bits, so I used\n+rotates.\n+-------------------------------------------------------------------------------\n+*/\n+#define mix(a,b,c) \\\n+{ \\\n+  a -= c;  a ^= rot(c, 4);  c += b; \\\n+  b -= a;  b ^= rot(a, 6);  a += c; \\\n+  c -= b;  c ^= rot(b, 8);  b += a; \\\n+  a -= c;  a ^= rot(c,16);  c += b; \\\n+  b -= a;  b ^= rot(a,19);  a += c; \\\n+  c -= b;  c ^= rot(b, 4);  b += a; \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+final -- final mixing of 3 32-bit values (a,b,c) into c\n+\n+Pairs of (a,b,c) values differing in only a few bits will usually\n+produce values of c that look totally different.  This was tested for\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+These constants passed:\n+ 14 11 25 16 4 14 24\n+ 12 14 25 16 4 14 24\n+and these came close:\n+  4  8 15 26 3 22 24\n+ 10  8 15 26 3 22 24\n+ 11  8 15 26 3 22 24\n+-------------------------------------------------------------------------------\n+*/\n+#define final(a,b,c) \\\n+{ \\\n+  c ^= b; c -= rot(b,14); \\\n+  a ^= c; a -= rot(c,11); \\\n+  b ^= a; b -= rot(a,25); \\\n+  c ^= b; c -= rot(b,16); \\\n+  a ^= c; a -= rot(c,4);  \\\n+  b ^= a; b -= rot(a,14); \\\n+  c ^= b; c -= rot(b,24); \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+hashlittle() -- hash a variable-length key into a 32-bit value\n+  k       : the key (the unaligned variable-length array of bytes)\n+  length  : the length of the key, counting by bytes\n+  initval : can be any 4-byte value\n+Returns a 32-bit value.  Every bit of the key affects every bit of\n+the return value.  Two keys differing by one or two bits will have\n+totally different hash values.\n+\n+The best hash table sizes are powers of 2.  There is no need to do\n+mod a prime (mod is sooo slow!).  If you need less than 32 bits,\n+use a bitmask.  For example, if you need only 10 bits, do\n+  h = (h & hashmask(10));\n+In which case, the hash table should have hashsize(10) elements.\n+\n+If you are hashing n strings (uint8_t **)k, do it like this:\n+  for (i=0, h=0; i<n; ++i) h = hashlittle( k[i], len[i], h);\n+\n+By Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this\n+code any way you wish, private, educational, or commercial.  It's free.\n+\n+Use for hash table lookup, or anything where one collision in 2^^32 is\n+acceptable.  Do NOT use for cryptographic purposes.\n+-------------------------------------------------------------------------------\n+*/\n+\n+static uint32_t hashlittle(const void *key, size_t length, uint32_t initval)\n+{\n+  uint32_t a,b,c;                                          /* internal state */\n+  union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */\n+\n+  /* Set up the internal state */\n+  a = b = c = 0xdeadbeef + ((uint32_t)length) + initval;\n+\n+  u.ptr = key;\n+  if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0)) {\n+    const uint32_t *k = (const uint32_t *)key;         /* read 32-bit chunks */\n+\n+#ifdef VALGRIND\n+    const uint8_t  *k8;\n+#endif\n+\n+    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      b += k[1];\n+      c += k[2];\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 3;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    /* \n+     * \""k[2]&0xffffff\"" actually reads beyond the end of the string, but\n+     * then masks off the part it's not allowed to read.  Because the\n+     * string is aligned, the masked-off tail is in the same word as the\n+     * rest of the string.  Every machine with memory protection I've seen\n+     * does it on word boundaries, so is OK with this.  But VALGRIND will\n+     * still catch it and complain.  The masking trick does make the hash\n+     * noticably faster for short strings (like English words).\n+     */\n+#ifndef VALGRIND\n+\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n+    case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n+    case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n+    case 6 : b+=k[1]&0xffff; a+=k[0]; break;\n+    case 5 : b+=k[1]&0xff; a+=k[0]; break;\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=k[0]&0xffffff; break;\n+    case 2 : a+=k[0]&0xffff; break;\n+    case 1 : a+=k[0]&0xff; break;\n+    case 0 : return c;              /* zero length strings require no mixing */\n+    }\n+\n+#else /* make valgrind happy */\n+\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=((uint32_t)k8[10])<<16;  /* fall through */\n+    case 10: c+=((uint32_t)k8[9])<<8;    /* fall through */\n+    case 9 : c+=k8[8];                   /* fall through */\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;   /* fall through */\n+    case 6 : b+=((uint32_t)k8[5])<<8;    /* fall through */\n+    case 5 : b+=k8[4];                   /* fall through */\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;   /* fall through */\n+    case 2 : a+=((uint32_t)k8[1])<<8;    /* fall through */\n+    case 1 : a+=k8[0]; break;\n+    case 0 : return c;\n+    }\n+\n+#endif /* !valgrind */\n+\n+  } else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0)) {\n+    const uint16_t *k = (const uint16_t *)key;         /* read 16-bit chunks */\n+    const uint8_t  *k8;\n+\n+    /*--------------- all but last block: aligned reads and different mixing */\n+    while (length > 12)\n+    {\n+      a += k[0] + (((uint32_t)k[1])<<16);\n+      b += k[2] + (((uint32_t)k[3])<<16);\n+      c += k[4] + (((uint32_t)k[5])<<16);\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 6;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[4]+(((uint32_t)k[5])<<16);\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 11: c+=((uint32_t)k8[10])<<16;     /* fall through */\n+    case 10: c+=k[4];\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 9 : c+=k8[8];                      /* fall through */\n+    case 8 : b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;      /* fall through */\n+    case 6 : b+=k[2];\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 5 : b+=k8[4];                      /* fall through */\n+    case 4 : a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;      /* fall through */\n+    case 2 : a+=k[0];\n+             break;\n+    case 1 : a+=k8[0];\n+             break;\n+    case 0 : return c;                     /* zero length requires no mixing */\n+    }\n+\n+  } else {                        /* need to read the key one byte at a time */\n+    const uint8_t *k = (const uint8_t *)key;\n+\n+    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      a += ((uint32_t)k[1])<<8;\n+      a += ((uint32_t)k[2])<<16;\n+      a += ((uint32_t)k[3])<<24;\n+      b += k[4];\n+      b += ((uint32_t)k[5])<<8;\n+      b += ((uint32_t)k[6])<<16;\n+      b += ((uint32_t)k[7])<<24;\n+      c += k[8];\n+      c += ((uint32_t)k[9])<<8;\n+      c += ((uint32_t)k[10])<<16;\n+      c += ((uint32_t)k[11])<<24;\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 12;\n+    }\n+\n+    /*-------------------------------- last block: affect all 32 bits of (c) */\n+    switch(length)                   /* all the case statements fall through */\n+    {\n+    case 12: c+=((uint32_t)k[11])<<24;\n+    case 11: c+=((uint32_t)k[10])<<16;\n+    case 10: c+=((uint32_t)k[9])<<8;\n+    case 9 : c+=k[8];\n+    case 8 : b+=((uint32_t)k[7])<<24;\n+    case 7 : b+=((uint32_t)k[6])<<16;\n+    case 6 : b+=((uint32_t)k[5])<<8;\n+    case 5 : b+=k[4];\n+    case 4 : a+=((uint32_t)k[3])<<24;\n+    case 3 : a+=((uint32_t)k[2])<<16;\n+    case 2 : a+=((uint32_t)k[1])<<8;\n+    case 1 : a+=k[0];\n+             break;\n+    case 0 : return c;\n+    }\n+  }\n+\n+  final(a,b,c);\n+  return c;\n+}""}<_**next**_>{""sha"": ""b4f109143031b2481a0d32a332c88cc1cc96c688"", ""filename"": ""src/utf.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 16, ""changes"": 20, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/utf.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/utf.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/utf.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -10,23 +10,11 @@\n \n #ifdef HAVE_CONFIG_H\n #include <config.h>\n+#endif\n \n-#ifdef HAVE_INTTYPES_H\n-/* inttypes.h includes stdint.h in a standard environment, so there's\n-no need to include stdint.h separately. If inttypes.h doesn't define\n-int32_t, it's defined in config.h. */\n-#include <inttypes.h>\n-#endif /* HAVE_INTTYPES_H */\n-\n-#else /* !HAVE_CONFIG_H */\n-#ifdef _WIN32\n-typedef int int32_t;\n-#else /* !_WIN32 */\n-/* Assume a standard environment */\n-#include <inttypes.h>\n-#endif /* _WIN32 */\n-\n-#endif /* HAVE_CONFIG_H */\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n \n int utf8_encode(int codepoint, char *buffer, int *size);\n ""}<_**next**_>{""sha"": ""1b02d90aa885f1ede146bb2077d05c8bb9096565"", ""filename"": ""src/value.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/value.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/value.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/value.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -9,11 +9,19 @@\n #define _GNU_SOURCE\n #endif\n \n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stddef.h>\n #include <stdlib.h>\n #include <string.h>\n #include <math.h>\n \n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include \""jansson.h\""\n #include \""hashtable.h\""\n #include \""jansson_private.h\""\n@@ -36,11 +44,19 @@ static JSON_INLINE void json_init(json_t *json, json_type type)\n \n /*** object ***/\n \n+extern volatile uint32_t hashtable_seed;\n+\n json_t *json_object(void)\n {\n     json_object_t *object = jsonp_malloc(sizeof(json_object_t));\n     if(!object)\n         return NULL;\n+\n+    if (!hashtable_seed) {\n+        /* Autoseed */\n+        json_object_seed(0);\n+    }\n+\n     json_init(&object->json, JSON_OBJECT);\n \n     if(hashtable_init(&object->hashtable))""}<_**next**_>{""sha"": ""e2c54bd12bd7c22de7cc3533f010b26cc1c330b0"", ""filename"": ""test/bin/json_process.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 1, ""changes"": 16, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/bin/json_process.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/bin/json_process.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/bin/json_process.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -37,6 +37,8 @@ struct config {\n     int sort_keys;\n     int strip;\n     int use_env;\n+    int have_hashseed;\n+    int hashseed;\n } conf;\n \n #define l_isspace(c) ((c) == ' ' || (c) == '\\n' || (c) == '\\r' || (c) == '\\t')\n@@ -108,6 +110,12 @@ static void read_conf(FILE *conffile)\n             conf.sort_keys = atoi(val);\n         if (!strcmp(line, \""STRIP\""))\n             conf.strip = atoi(val);\n+        if (!strcmp(line, \""HASHSEED\"")) {\n+            conf.have_hashseed = 1;\n+            conf.hashseed = atoi(val);\n+        } else {\n+            conf.have_hashseed = 0;\n+        }\n     }\n \n     free(buffer);\n@@ -188,6 +196,9 @@ int use_conf(char *test_path)\n     if (conf.sort_keys)\n         flags |= JSON_SORT_KEYS;\n \n+    if (conf.have_hashseed)\n+        json_object_seed(conf.hashseed);\n+\n     if (conf.strip) {\n         /* Load to memory, strip leading and trailing whitespace */\n         buffer = loadfile(infile);\n@@ -265,7 +276,10 @@ int use_env()\n         flags |= JSON_PRESERVE_ORDER;\n \n     if(getenv_int(\""JSON_SORT_KEYS\""))\n-         flags |= JSON_SORT_KEYS;\n+        flags |= JSON_SORT_KEYS;\n+\n+    if(getenv(\""HASHSEED\""))\n+        json_object_seed(getenv_int(\""HASHSEED\""));\n \n     if(getenv_int(\""STRIP\"")) {\n         /* Load to memory, strip leading and trailing whitespace */""}<_**next**_>{""sha"": ""84b17466fd0a753b8cbd714d0236ed9072cdd536"", ""filename"": ""test/suites/api/test_memory_funcs.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_memory_funcs.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_memory_funcs.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/api/test_memory_funcs.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -24,13 +24,13 @@ static void create_and_free_complex_object()\n \n static void *my_malloc(size_t size)\n {\n-    malloc_called += 1;\n+    malloc_called = 1;\n     return malloc(size);\n }\n \n static void my_free(void *ptr)\n {\n-    free_called += 1;\n+    free_called = 1;\n     free(ptr);\n }\n \n@@ -39,7 +39,7 @@ static void test_simple()\n     json_set_alloc_funcs(my_malloc, my_free);\n     create_and_free_complex_object();\n \n-    if(malloc_called != 20 || free_called != 20)\n+    if(malloc_called != 1 || free_called != 1)\n         fail(\""Custom allocation failed\"");\n }\n ""}<_**next**_>{""sha"": ""92e5208224b75ab45d93672446279d598052a83e"", ""filename"": ""test/suites/api/test_object.c"", ""status"": ""modified"", ""additions"": 40, ""deletions"": 24, ""changes"": 64, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_object.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_object.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/api/test_object.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -249,7 +249,11 @@ static void test_set_nocheck()\n \n static void test_iterators()\n {\n+    int i;\n     json_t *object, *foo, *bar, *baz;\n+    const char *iter_keys[3];\n+    int have_key[3] = { 0, 0, 0 };\n+    json_t *iter_values[3];\n     void *iter;\n \n     if(json_object_iter(NULL))\n@@ -276,30 +280,50 @@ static void test_iterators()\n     iter = json_object_iter(object);\n     if(!iter)\n         fail(\""unable to get iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""a\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != foo)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[0] = json_object_iter_key(iter);\n+    iter_values[0] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""b\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != bar)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[1] = json_object_iter_key(iter);\n+    iter_values[1] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[2] = json_object_iter_key(iter);\n+    iter_values[2] = json_object_iter_value(iter);\n \n     if(json_object_iter_next(object, iter) != NULL)\n         fail(\""able to iterate over the end\"");\n \n+    /* Check that keys have correct values */\n+    for (i = 0; i < 3; i++) {\n+        if (strcmp(iter_keys[i], \""a\"") == 0) {\n+            if (iter_values[i] != foo)\n+                fail(\""wrong value for iter key a\"");\n+            else\n+                have_key[0] = 1;\n+        } else if (strcmp(iter_keys[i], \""b\"") == 0) {\n+            if (iter_values[i] != bar)\n+                fail(\""wrong value for iter key b\"");\n+            else\n+                have_key[1] = 1;\n+        } else if (strcmp(iter_keys[i], \""c\"") == 0) {\n+            if (iter_values[i] != baz)\n+                fail(\""wrong value for iter key c\"");\n+            else\n+                have_key[2] = 1;\n+        }\n+    }\n+\n+    /* Check that we got all keys */\n+    for(i = 0; i < 3; i++) {\n+        if(!have_key[i])\n+            fail(\""a key wasn't iterated over\"");\n+    }\n+\n     if(json_object_iter_at(object, \""foo\""))\n         fail(\""json_object_iter_at() succeeds for non-existent key\"");\n \n@@ -312,22 +336,14 @@ static void test_iterators()\n     if(json_object_iter_value(iter) != bar)\n         fail(\""iterating failed: wrong value\"");\n \n-    iter = json_object_iter_next(object, iter);\n-    if(!iter)\n-        fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\""iterating failed: wrong value\"");\n-\n-    if(json_object_iter_set(object, iter, bar))\n+    if(json_object_iter_set(object, iter, baz))\n         fail(\""unable to set value at iterator\"");\n \n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n+    if(strcmp(json_object_iter_key(iter), \""b\""))\n         fail(\""json_object_iter_key() fails after json_object_iter_set()\"");\n-    if(json_object_iter_value(iter) != bar)\n+    if(json_object_iter_value(iter) != baz)\n         fail(\""json_object_iter_value() fails after json_object_iter_set()\"");\n-    if(json_object_get(object, \""c\"") != bar)\n+    if(json_object_get(object, \""b\"") != baz)\n         fail(\""json_object_get() fails after json_object_iter_set()\"");\n \n     json_decref(object);""}<_**next**_>{""sha"": ""93cb33ddafeb9eef6ce7ad4709ce1bcbdf25b200"", ""filename"": ""test/suites/encoding-flags/compact-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/compact-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/compact-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/compact-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,2 +1,3 @@\n JSON_COMPACT=1\n-export JSON_COMPACT\n+HASHSEED=1\n+export JSON_COMPACT HASHSEED""}<_**next**_>{""sha"": ""c73acc1792963be8a5f41ff11f6e858506ada51d"", ""filename"": ""test/suites/encoding-flags/indent-compact-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-compact-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-compact-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/indent-compact-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,3 +1,4 @@\n JSON_INDENT=4\n JSON_COMPACT=1\n-export JSON_INDENT JSON_COMPACT\n+HASHSEED=1\n+export JSON_INDENT JSON_COMPACT HASHSEED""}<_**next**_>{""sha"": ""961558ca23ceca2ce6e4d07697f4018d8475f317"", ""filename"": ""test/suites/encoding-flags/indent-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/indent-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,2 +1,3 @@\n JSON_INDENT=4\n-export JSON_INDENT\n+HASHSEED=1\n+export JSON_INDENT HASHSEED""}<_**next**_>{""sha"": ""9120b03514ec614695c2d17841ba228b102c9db6"", ""filename"": ""test/suites/encoding-flags/object/env"", ""status"": ""added"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,2 @@\n+HASHSEED=1\n+export HASHSEED""}","int hashtable_set(hashtable_t *hashtable,
                  const char *key, size_t serial,
                  json_t *value)
{
    pair_t *pair;
    bucket_t *bucket;
     size_t hash, index;
 
     /* rehash if the load ratio exceeds 1 */
    if(hashtable->size >= hashsize(hashtable->order))
         if(hashtable_do_rehash(hashtable))
             return -1;
 
     hash = hash_str(key);
    index = hash & hashmask(hashtable->order);
     bucket = &hashtable->buckets[index];
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
 
    if(pair)
    {
        json_decref(pair->value);
        pair->value = value;
    }
    else
    {
        /* offsetof(...) returns the size of pair_t without the last,
           flexible member. This way, the correct amount is
           allocated. */
        pair = jsonp_malloc(offsetof(pair_t, key) + strlen(key) + 1);
        if(!pair)
            return -1;

        pair->hash = hash;
        pair->serial = serial;
        strcpy(pair->key, key);
        pair->value = value;
        list_init(&pair->list);

        insert_to_bucket(hashtable, bucket, &pair->list);

        hashtable->size++;
    }
    return 0;
}
","int hashtable_set(hashtable_t *hashtable,
                  const char *key, size_t serial,
                  json_t *value)
{
    pair_t *pair;
    bucket_t *bucket;
     size_t hash, index;
 
     /* rehash if the load ratio exceeds 1 */
    if(hashtable->size >= num_buckets(hashtable))
         if(hashtable_do_rehash(hashtable))
             return -1;
 
     hash = hash_str(key);
    index = hash % num_buckets(hashtable);
     bucket = &hashtable->buckets[index];
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
 
    if(pair)
    {
        json_decref(pair->value);
        pair->value = value;
    }
    else
    {
        /* offsetof(...) returns the size of pair_t without the last,
           flexible member. This way, the correct amount is
           allocated. */
        pair = jsonp_malloc(offsetof(pair_t, key) + strlen(key) + 1);
        if(!pair)
            return -1;

        pair->hash = hash;
        pair->serial = serial;
        strcpy(pair->key, key);
        pair->value = value;
        list_init(&pair->list);

        insert_to_bucket(hashtable, bucket, &pair->list);

        hashtable->size++;
    }
    return 0;
}
",C,"    if(hashtable->size >= hashsize(hashtable->order))
    index = hash & hashmask(hashtable->order);
","    if(hashtable->size >= num_buckets(hashtable))
    index = hash % num_buckets(hashtable);
",,"@@ -5,8 +5,17 @@
  * it under the terms of the MIT license. See LICENSE for details.
  */
 
+#if HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include <stdlib.h>
 #include <string.h>
+
+#if HAVE_STDINT_H
+#include <stdint.h>
+#endif
+
 #include <jansson_config.h>   /* for JSON_INLINE */
 #include ""jansson_private.h""  /* for container_of() */
 #include ""hashtable.h""
@@ -15,24 +24,13 @@ typedef struct hashtable_list list_t;
 typedef struct hashtable_pair pair_t;
 typedef struct hashtable_bucket bucket_t;
 
-#define list_to_pair(list_)  container_of(list_, pair_t, list)
-
-/* From http://www.cse.yorku.ca/~oz/hash.html */
-static size_t hash_str(const void *ptr)
-{
-    const char *str = (const char *)ptr;
-
-    size_t hash = 5381;
-    size_t c;
+extern volatile uint32_t hashtable_seed;
 
-    while((c = (size_t)*str))
-    {
-        hash = ((hash << 5) + hash) + c;
-        str++;
-    }
+/* Implementation of the hash function */
+#include ""lookup3.h""
 
-    return hash;
-}
+#define list_to_pair(list_)  container_of(list_, pair_t, list)
+#define hash_str(key)        ((size_t)hashlittle((key), strlen(key), hashtable_seed))
 
 static JSON_INLINE void list_init(list_t *list)
 {
@@ -74,19 +72,6 @@ static void insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket,
     }
 }
 
-static const size_t primes[] = {
-    5, 13, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,
-    49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,
-    12582917, 25165843, 50331653, 100663319, 201326611, 402653189,
-    805306457, 1610612741
-};
-
-static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)
-{
-    return primes[hashtable->num_buckets];
-}
-
-
 static pair_t *hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket,
                                    const char *key, size_t hash)
 {
@@ -120,7 +105,7 @@ static int hashtable_do_del(hashtable_t *hashtable,
     bucket_t *bucket;
     size_t index;
 
-    index = hash % num_buckets(hashtable);
+    index = hash & hashmask(hashtable->order);
     bucket = &hashtable->buckets[index];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
@@ -167,14 +152,14 @@ static int hashtable_do_rehash(hashtable_t *hashtable)
 
     jsonp_free(hashtable->buckets);
 
-    hashtable->num_buckets++;
-    new_size = num_buckets(hashtable);
+    hashtable->order++;
+    new_size = hashsize(hashtable->order);
 
     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));
     if(!hashtable->buckets)
         return -1;
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -199,14 +184,14 @@ int hashtable_init(hashtable_t *hashtable)
     size_t i;
 
     hashtable->size = 0;
-    hashtable->num_buckets = 0;  /* index to primes[] */
-    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));
+    hashtable->order = 3;
+    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));
     if(!hashtable->buckets)
         return -1;
 
     list_init(&hashtable->list);
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -230,12 +215,12 @@ int hashtable_set(hashtable_t *hashtable,
     size_t hash, index;
 
     /* rehash if the load ratio exceeds 1 */
-    if(hashtable->size >= num_buckets(hashtable))
+    if(hashtable->size >= hashsize(hashtable->order))
         if(hashtable_do_rehash(hashtable))
             return -1;
 
     hash = hash_str(key);
-    index = hash % num_buckets(hashtable);
+    index = hash & hashmask(hashtable->order);
     bucket = &hashtable->buckets[index];
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
 
@@ -273,7 +258,7 @@ void *hashtable_get(hashtable_t *hashtable, const char *key)
     bucket_t *bucket;
 
     hash = hash_str(key);
-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)
@@ -294,7 +279,7 @@ void hashtable_clear(hashtable_t *hashtable)
 
     hashtable_do_clear(hashtable);
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -316,7 +301,7 @@ void *hashtable_iter_at(hashtable_t *hashtable, const char *key)
     bucket_t *bucket;
 
     hash = hash_str(key);
-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)",jansson,8f80c2d83808150724d31793e6ade92749b1faa4,b9c588de3deb4efdd7b9ec44aa79335dba11fd6b,1,"int hashtable_set(hashtable_t *hashtable,
                  const char *key, size_t serial,
                  json_t *value)
{
    pair_t *pair;
    bucket_t *bucket;
     size_t hash, index;
 
     /* rehash if the load ratio exceeds 1 */
//flaw_line_below:
    if(hashtable->size >= num_buckets(hashtable))
//fix_flaw_line_below:
//    if(hashtable->size >= hashsize(hashtable->order))
         if(hashtable_do_rehash(hashtable))
             return -1;
 
     hash = hash_str(key);
//flaw_line_below:
    index = hash % num_buckets(hashtable);
//fix_flaw_line_below:
//    index = hash & hashmask(hashtable->order);
     bucket = &hashtable->buckets[index];
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
 
    if(pair)
    {
        json_decref(pair->value);
        pair->value = value;
    }
    else
    {
        /* offsetof(...) returns the size of pair_t without the last,
           flexible member. This way, the correct amount is
           allocated. */
        pair = jsonp_malloc(offsetof(pair_t, key) + strlen(key) + 1);
        if(!pair)
            return -1;

        pair->hash = hash;
        pair->serial = serial;
        strcpy(pair->key, key);
        pair->value = value;
        list_init(&pair->list);

        insert_to_bucket(hashtable, bucket, &pair->list);

        hashtable->size++;
    }
    return 0;
}
"
1970,179706,,Remote,Not required,Partial,CVE-2013-6401,https://www.cvedetails.com/cve/CVE-2013-6401/,CWE-310,Low,,,,2014-03-20,5.0,"Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document.",2014-05-23,DoS ,0,https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4,8f80c2d83808150724d31793e6ade92749b1faa4,"CVE-2013-6401: Change hash function, randomize hashes

Thanks to Florian Weimer and Eric Sesterhenn for reporting, reviewing
and testing.",3,src/hashtable.c,"{""sha"": ""1043c9ae4c0bc0c1f6a5913783973383832ff14b"", ""filename"": ""CMakeLists.txt"", ""status"": ""modified"", ""additions"": 39, ""deletions"": 10, ""changes"": 49, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/CMakeLists.txt"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/CMakeLists.txt"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/CMakeLists.txt?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -52,6 +52,8 @@ project (jansson C)\n \n # Options\n OPTION (BUILD_SHARED_LIBS \""Build shared libraries.\"" OFF)\n+OPTION (USE_URANDOM \""Use /dev/urandom to seed the hash function.\"" ON)\n+OPTION (USE_WINDOWS_CRYPTOAPI \""Use CryptGenRandom to seed the hash function.\"" ON)\n \n if (MSVC)\n    # This option must match the settings used in your program, in particular if you\n@@ -85,12 +87,12 @@ set (JANSSON_SOVERSION 4)\n # for CheckFunctionKeywords\n set(CMAKE_MODULE_PATH \""${CMAKE_CURRENT_SOURCE_DIR}/cmake\"")\n \n+INCLUDE (CheckCSourceCompiles)\n include (CheckFunctionExists)\n include (CheckFunctionKeywords)\n include (CheckIncludeFiles)\n include (CheckTypeSize)\n \n-\n if (MSVC)\n    # Turn off Microsofts \""security\"" warnings.\n    add_definitions( \""/W3 /D_CRT_SECURE_NO_WARNINGS /wd4005 /wd4996 /nologo\"" )\n@@ -106,14 +108,25 @@ if (CMAKE_COMPILER_IS_GNUCC OR CMAKE_COMPILER_IS_GNUCXX)\n    set(CMAKE_C_FLAGS \""-fPIC\"")\n endif()\n \n-   \n+check_include_files (endian.h HAVE_ENDIAN_H)\n+check_include_files (fcntl.h HAVE_FCNTL_H)\n+check_include_files (sched.h HAVE_SCHED_H)\n+check_include_files (unistd.h HAVE_UNISTD_H)\n+check_include_files (sys/param.h HAVE_SYS_PARAM_H)\n+check_include_files (sys/stat.h HAVE_SYS_STAT_H)\n+check_include_files (sys/time.h HAVE_SYS_TIME_H)\n+check_include_files (sys/time.h HAVE_SYS_TYPES_H)\n+\n+check_function_exists (close HAVE_CLOSE)\n+check_function_exists (getpid HAVE_GETPID)\n+check_function_exists (gettimeofday HAVE_GETTIMEOFDAY)\n+check_function_exists (open HAVE_OPEN)\n+check_function_exists (read HAVE_READ)\n+check_function_exists (sched_yield HAVE_SCHED_YIELD)\n \n # Check for the int-type includes\n-check_include_files (sys/types.h HAVE_SYS_TYPES_H)\n-check_include_files (inttypes.h HAVE_INTTYPES_H)\n check_include_files (stdint.h HAVE_STDINT_H)\n \n-\n # Check our 64 bit integer sizes\n check_type_size (__int64 __INT64)\n check_type_size (int64_t INT64_T)\n@@ -124,17 +137,32 @@ check_type_size (int32_t INT32_T)\n check_type_size (__int32 __INT32)\n check_type_size (\""long\"" LONG_INT)\n check_type_size (\""int\"" INT)\n-\n if (HAVE_INT32_T)\n    set (JSON_INT32 int32_t)\n elseif (HAVE___INT32)\n    set (JSON_INT32 __int32)\n-elseif (HAVE_LONG AND (${LONG_INT} EQUAL 4))\n+elseif (HAVE_LONG_INT AND (${LONG_INT} EQUAL 4))\n    set (JSON_INT32 long)\n elseif (HAVE_INT AND (${INT} EQUAL 4))\n    set (JSON_INT32 int)\n else ()\n-   message (FATAL_ERROR \""Could not detect a valid 32 bit integer type\"")\n+   message (FATAL_ERROR \""Could not detect a valid 32-bit integer type\"")\n+endif ()\n+\n+check_type_size (uint32_t UINT32_T)\n+check_type_size (__uint32 __UINT32)\n+check_type_size (\""unsigned long\"" UNSIGNED_LONG_INT)\n+check_type_size (\""unsigned int\"" UNSIGNED_INT)\n+if (HAVE_UINT32_T)\n+   set (JSON_UINT32 uint32_t)\n+elseif (HAVE___UINT32)\n+   set (JSON_UINT32 __uint32)\n+elseif (HAVE_UNSIGNED_LONG_INT AND (${UNSIGNED_LONG_INT} EQUAL 4))\n+   set (JSON_UINT32 \""unsigned long\"")\n+elseif (HAVE_UNSIGNED_INT AND (${UNSIGNED_INT} EQUAL 4))\n+   set (JSON_UINT32 \""unsigned int\"")\n+else ()\n+   message (FATAL_ERROR \""Could not detect a valid unsigned 32-bit integer type\"")\n endif ()\n \n # Check for ssize_t and SSIZE_T existance.\n@@ -206,11 +234,9 @@ else ()\n    set (JSON_HAVE_LOCALECONV 0)\n endif ()\n \n-\n # check if we have setlocale\n check_function_exists (setlocale HAVE_SETLOCALE)\n \n-\n # Check what the inline keyword is.\n # Note that the original JSON_INLINE was always set to just 'inline', so this goes further.\n check_function_keywords(\""inline\"")\n@@ -238,6 +264,9 @@ elseif (HAVE__SNPRINTF)\n    set (JSON_SNPRINTF _snprintf)\n endif ()\n \n+check_c_source_compiles (\""int main() { unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1); return 0; } \"" HAVE_SYNC_BUILTINS)\n+check_c_source_compiles (\""int main() { char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE); return 0; }\"" HAVE_ATOMIC_BUILTINS)\n+\n # Create pkg-conf file.\n # (We use the same files as ./configure does, so we\n #  have to defined the same variables used there).""}<_**next**_>{""sha"": ""b27b9a3a849e94686aa648c1ec4d1bd4c8e35445"", ""filename"": ""cmake/config.h.cmake"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 21, ""changes"": 46, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/cmake/config.h.cmake"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/cmake/config.h.cmake"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/cmake/config.h.cmake?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,35 +1,36 @@\n-/* Reduced down to the defines that are actually used in the code */\n-\n-/* Define to 1 if you have the <inttypes.h> (and friends) header file. */\n-#cmakedefine HAVE_INTTYPES_H 1\n-#cmakedefine HAVE_STDINT_H 1\n+#cmakedefine HAVE_ENDIAN_H 1\n+#cmakedefine HAVE_FCNTL_H 1\n+#cmakedefine HAVE_SCHED_H 1\n+#cmakedefine HAVE_UNISTD_H 1\n+#cmakedefine HAVE_SYS_PARAM_H 1\n+#cmakedefine HAVE_SYS_STAT_H 1\n+#cmakedefine HAVE_SYS_TIME_H 1\n #cmakedefine HAVE_SYS_TYPES_H 1\n+#cmakedefine HAVE_STDINT_H 1\n \n-/* We must include this here, as in (eg) utf.h it will want to use\n-   the integer type, which in MSVC2010 will be in stdint.h\n-   (there is no inttypes.h in MSVC2010) */\n-#if defined(HAVE_STDINT_H)\n-#  include <stdint.h>\n-#elif defined(HAVE_INTTYPES_H)\n-#  include <inttypes.h>\n-#elif defined(HAVE_SYS_TYPES_H)\n-#  include <sys/types.h>\n-#endif\n+#cmakedefine HAVE_CLOSE 1\n+#cmakedefine HAVE_GETPID 1\n+#cmakedefine HAVE_GETTIMEOFDAY 1\n+#cmakedefine HAVE_OPEN 1\n+#cmakedefine HAVE_READ 1\n+#cmakedefine HAVE_SCHED_YIELD 1\n \n-/* Define to 1 if you have the <locale.h> header file. */\n-#cmakedefine HAVE_LOCALE_H 1\n+#cmakedefine HAVE_SYNC_BUILTINS 1\n+#cmakedefine HAVE_ATOMIC_BUILTINS 1\n \n-/* Define to 1 if you have the 'setlocale' function. */\n+#cmakedefine HAVE_LOCALE_H 1\n #cmakedefine HAVE_SETLOCALE 1\n \n-/* Define to the type of a signed integer type of width exactly 32 bits if\n-   such a type exists and the standard includes do not define it. */\n #cmakedefine HAVE_INT32_T 1\n-\n #ifndef HAVE_INT32_T\n #  define int32_t @JSON_INT32@\n #endif\n \n+#cmakedefine HAVE_UINT32_T 1\n+#ifndef HAVE_UINT32_T\n+#  define uint32_t @JSON_UINT32@\n+#endif\n+\n #cmakedefine HAVE_SSIZE_T 1\n \n #ifndef HAVE_SSIZE_T\n@@ -43,3 +44,6 @@\n #endif\n \n #cmakedefine HAVE_VSNPRINTF\n+\n+#cmakedefine USE_URANDOM 1\n+#cmakedefine USE_WINDOWS_CRYPTOAPI 1""}<_**next**_>{""sha"": ""113cb85e17a15f2fac83b528fe1880bc99481ccb"", ""filename"": ""configure.ac"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 2, ""changes"": 50, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/configure.ac"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/configure.ac"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/configure.ac?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -14,10 +14,11 @@ AM_CONDITIONAL([GCC], [test x$GCC = xyes])\n # Checks for libraries.\n \n # Checks for header files.\n-AC_CHECK_HEADERS([locale.h])\n+AC_CHECK_HEADERS([endian.h fcntl.h locale.h sched.h unistd.h sys/param.h sys/stat.h sys/time.h sys/types.h])\n \n # Checks for typedefs, structures, and compiler characteristics.\n AC_TYPE_INT32_T\n+AC_TYPE_UINT32_T\n AC_TYPE_LONG_LONG_INT\n \n AC_C_INLINE\n@@ -29,7 +30,31 @@ esac\n AC_SUBST([json_inline])\n \n # Checks for library functions.\n-AC_CHECK_FUNCS([strtoll localeconv])\n+AC_CHECK_FUNCS([close getpid gettimeofday localeconv open read sched_yield strtoll])\n+\n+AC_MSG_CHECKING([for gcc __sync builtins])\n+have_sync_builtins=no\n+AC_TRY_LINK(\n+  [], [unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1);],\n+  [have_sync_builtins=yes],\n+)\n+if test \""x$have_sync_builtins\"" = \""xyes\""; then\n+  AC_DEFINE([HAVE_SYNC_BUILTINS], [1],\n+    [Define to 1 if gcc's __sync builtins are available])\n+fi\n+AC_MSG_RESULT([$have_sync_builtins])\n+\n+AC_MSG_CHECKING([for gcc __atomic builtins])\n+have_atomic_builtins=no\n+AC_TRY_LINK(\n+  [], [char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE);],\n+  [have_atomic_builtins=yes],\n+)\n+if test \""x$have_atomic_builtins\"" = \""xyes\""; then\n+  AC_DEFINE([HAVE_ATOMIC_BUILTINS], [1],\n+    [Define to 1 if gcc's __atomic builtins are available])\n+fi\n+AC_MSG_RESULT([$have_atomic_builtins])\n \n case \""$ac_cv_type_long_long_int$ac_cv_func_strtoll\"" in\n      yesyes) json_have_long_long=1;;\n@@ -43,6 +68,27 @@ case \""$ac_cv_header_locale_h$ac_cv_func_localeconv\"" in\n esac\n AC_SUBST([json_have_localeconv])\n \n+# Features\n+AC_ARG_ENABLE([urandom],\n+  [AS_HELP_STRING([--disable-urandom],\n+    [Don't use /dev/urandom to seed the hash function])],\n+  [use_urandom=$enableval], [use_urandom=yes])\n+\n+if test \""x$use_urandom\"" = xyes; then\n+AC_DEFINE([USE_URANDOM], [1],\n+  [Define to 1 if /dev/urandom should be used for seeding the hash function])\n+fi\n+\n+AC_ARG_ENABLE([windows-cryptoapi],\n+  [AS_HELP_STRING([--disable-windows-cryptoapi],\n+    [Don't use CryptGenRandom to seed the hash function])],\n+  [use_windows_cryptoapi=$enableval], [use_windows_cryptoapi=yes])\n+\n+if test \""x$use_windows_cryptoapi\"" = xyes; then\n+AC_DEFINE([USE_WINDOWS_CRYPTOAPI], [1],\n+  [Define to 1 if CryptGenRandom should be used for seeding the hash function])\n+fi\n+\n AC_CONFIG_FILES([\n         jansson.pc\n         Makefile""}<_**next**_>{""sha"": ""b4af562e84b5ed9dba1107af7d1768dcdb0b9a95"", ""filename"": ""src/Makefile.am"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/Makefile.am"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/Makefile.am?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -8,6 +8,7 @@ libjansson_la_SOURCES = \\\n \terror.c \\\n \thashtable.c \\\n \thashtable.h \\\n+\thashtable_seed.c \\\n \tjansson_private.h \\\n \tload.c \\\n \tmemory.c \\""}<_**next**_>{""sha"": ""abd4bf11fe7a393fcf3d533b952aa8b5efa4ea30"", ""filename"": ""src/hashtable.c"", ""status"": ""modified"", ""additions"": 26, ""deletions"": 41, ""changes"": 67, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -5,8 +5,17 @@\n  * it under the terms of the MIT license. See LICENSE for details.\n  */\n \n+#if HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stdlib.h>\n #include <string.h>\n+\n+#if HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include <jansson_config.h>   /* for JSON_INLINE */\n #include \""jansson_private.h\""  /* for container_of() */\n #include \""hashtable.h\""\n@@ -15,24 +24,13 @@ typedef struct hashtable_list list_t;\n typedef struct hashtable_pair pair_t;\n typedef struct hashtable_bucket bucket_t;\n \n-#define list_to_pair(list_)  container_of(list_, pair_t, list)\n-\n-/* From http://www.cse.yorku.ca/~oz/hash.html */\n-static size_t hash_str(const void *ptr)\n-{\n-    const char *str = (const char *)ptr;\n-\n-    size_t hash = 5381;\n-    size_t c;\n+extern volatile uint32_t hashtable_seed;\n \n-    while((c = (size_t)*str))\n-    {\n-        hash = ((hash << 5) + hash) + c;\n-        str++;\n-    }\n+/* Implementation of the hash function */\n+#include \""lookup3.h\""\n \n-    return hash;\n-}\n+#define list_to_pair(list_)  container_of(list_, pair_t, list)\n+#define hash_str(key)        ((size_t)hashlittle((key), strlen(key), hashtable_seed))\n \n static JSON_INLINE void list_init(list_t *list)\n {\n@@ -74,19 +72,6 @@ static void insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket,\n     }\n }\n \n-static const size_t primes[] = {\n-    5, 13, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,\n-    49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,\n-    12582917, 25165843, 50331653, 100663319, 201326611, 402653189,\n-    805306457, 1610612741\n-};\n-\n-static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)\n-{\n-    return primes[hashtable->num_buckets];\n-}\n-\n-\n static pair_t *hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket,\n                                    const char *key, size_t hash)\n {\n@@ -120,7 +105,7 @@ static int hashtable_do_del(hashtable_t *hashtable,\n     bucket_t *bucket;\n     size_t index;\n \n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n@@ -167,14 +152,14 @@ static int hashtable_do_rehash(hashtable_t *hashtable)\n \n     jsonp_free(hashtable->buckets);\n \n-    hashtable->num_buckets++;\n-    new_size = num_buckets(hashtable);\n+    hashtable->order++;\n+    new_size = hashsize(hashtable->order);\n \n     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -199,14 +184,14 @@ int hashtable_init(hashtable_t *hashtable)\n     size_t i;\n \n     hashtable->size = 0;\n-    hashtable->num_buckets = 0;  /* index to primes[] */\n-    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));\n+    hashtable->order = 3;\n+    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n     list_init(&hashtable->list);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -230,12 +215,12 @@ int hashtable_set(hashtable_t *hashtable,\n     size_t hash, index;\n \n     /* rehash if the load ratio exceeds 1 */\n-    if(hashtable->size >= num_buckets(hashtable))\n+    if(hashtable->size >= hashsize(hashtable->order))\n         if(hashtable_do_rehash(hashtable))\n             return -1;\n \n     hash = hash_str(key);\n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n \n@@ -273,7 +258,7 @@ void *hashtable_get(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)\n@@ -294,7 +279,7 @@ void hashtable_clear(hashtable_t *hashtable)\n \n     hashtable_do_clear(hashtable);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -316,7 +301,7 @@ void *hashtable_iter_at(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)""}<_**next**_>{""sha"": ""469c6ecd869c4698f650fa81983bb3ee03d47fab"", ""filename"": ""src/hashtable.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -32,14 +32,15 @@ struct hashtable_bucket {\n typedef struct hashtable {\n     size_t size;\n     struct hashtable_bucket *buckets;\n-    size_t num_buckets;  /* index to primes[] */\n+    size_t order;  /* hashtable has pow(2, order) buckets */\n     struct hashtable_list list;\n } hashtable_t;\n \n \n #define hashtable_key_to_iter(key_) \\\n     (&(container_of(key_, struct hashtable_pair, key)->list))\n \n+\n /**\n  * hashtable_init - Initialize a hashtable object\n  *""}<_**next**_>{""sha"": ""a07d145d10df35b933c1441dcbf42d3316b78ca5"", ""filename"": ""src/hashtable_seed.c"", ""status"": ""added"", ""additions"": 278, ""deletions"": 0, ""changes"": 278, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable_seed.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable_seed.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable_seed.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,278 @@\n+/* Generate sizeof(uint32_t) bytes of as random data as possible to seed\n+   the hash function.\n+*/\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#include <stdio.h>\n+#include <time.h>\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n+#ifdef HAVE_FCNTL_H\n+#include <fcntl.h>\n+#endif\n+\n+#ifdef HAVE_SCHED_H\n+#include <sched.h>\n+#endif\n+\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+\n+#ifdef HAVE_SYS_STAT_H\n+#include <sys/stat.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TIME_H\n+#include <sys/time.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TYPES_H\n+#include <sys/types.h>\n+#endif\n+\n+#if defined(_WIN32)\n+/* For _getpid() */\n+#include <process.h>\n+#endif\n+\n+#include \""jansson.h\""\n+\n+\n+static uint32_t buf_to_uint32(char *data) {\n+    size_t i;\n+    uint32_t result = 0;\n+\n+    for (i = 0; i < sizeof(uint32_t); i++)\n+        result = (result << 8) | (unsigned char)data[i];\n+\n+    return result;\n+}\n+\n+\n+\n+/* /dev/urandom */\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+static int seed_from_urandom(uint32_t *seed) {\n+    /* Use unbuffered I/O if we have open(), close() and read(). Otherwise\n+       fall back to fopen() */\n+\n+    char data[sizeof(uint32_t)];\n+    int ok;\n+\n+#if defined(HAVE_OPEN) && defined(HAVE_CLOSE) && defined(HAVE_READ)\n+    int urandom;\n+    urandom = open(\""/dev/urandom\"", O_RDONLY);\n+    if (urandom == -1)\n+        return 1;\n+\n+    ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);\n+    close(urandom);\n+#else\n+    FILE *urandom;\n+\n+    urandom = fopen(\""/dev/urandom\"", \""rb\"");\n+    if (!urandom)\n+        return 1;\n+\n+    ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);\n+    fclose(urandom);\n+#endif\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32(data);\n+    return 0;\n+}\n+#endif\n+\n+/* Windows Crypto API */\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+#include <windows.h>\n+#include <wincrypt.h>\n+\n+typedef BOOL (WINAPI *CRYPTACQUIRECONTEXTA)(HCRYPTPROV *phProv, LPCSTR pszContainer, LPCSTR pszProvider, DWORD dwProvType, DWORD dwFlags);\n+typedef BOOL (WINAPI *CRYPTGENRANDOM)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);\n+typedef BOOL (WINAPI *CRYPTRELEASECONTEXT)(HCRYPTPROV hProv, DWORD dwFlags);\n+\n+static int seed_from_windows_cryptoapi(uint32_t *seed)\n+{\n+    HINSTANCE hAdvAPI32 = NULL;\n+    CRYPTACQUIRECONTEXTA pCryptAcquireContext = NULL;\n+    CRYPTGENRANDOM pCryptGenRandom = NULL;\n+    CRYPTRELEASECONTEXT pCryptReleaseContext = NULL;\n+    HCRYPTPROV hCryptProv = 0;\n+    BYTE data[sizeof(uint32_t)];\n+    int ok;\n+\n+    hAdvAPI32 = GetModuleHandle(\""advapi32.dll\"");\n+    if(hAdvAPI32 == NULL)\n+        return 1;\n+\n+    pCryptAcquireContext = (CRYPTACQUIRECONTEXTA)GetProcAddress(hAdvAPI32, \""CryptAcquireContextA\"");\n+    if (!pCryptAcquireContext)\n+        return 1;\n+\n+    pCryptGenRandom = (CRYPTGENRANDOM)GetProcAddress(hAdvAPI32, \""CryptGenRandom\"");\n+    if (!pCryptGenRandom)\n+        return 1;\n+\n+    pCryptReleaseContext = (CRYPTRELEASECONTEXT)GetProcAddress(hAdvAPI32, \""CryptReleaseContext\"");\n+    if (!pCryptReleaseContext)\n+        return 1;\n+\n+    if (!pCryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))\n+        return 1;\n+\n+    ok = CryptGenRandom(hCryptProv, sizeof(uint32_t), data);\n+    pCryptReleaseContext(hCryptProv, 0);\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32((char *)data);\n+    return 0;\n+}\n+#endif\n+\n+/* gettimeofday() and getpid() */\n+static int seed_from_timestamp_and_pid(uint32_t *seed) {\n+#ifdef HAVE_GETTIMEOFDAY\n+    /* XOR of seconds and microseconds */\n+    struct timeval tv;\n+    gettimeofday(&tv, NULL);\n+    *seed = (uint32_t)tv.tv_sec ^ (uint32_t)tv.tv_usec;\n+#else\n+    /* Seconds only */\n+    *seed = (uint32_t)time(NULL);\n+#endif\n+\n+    /* XOR with PID for more randomness */\n+#if defined(_WIN32)\n+    *seed ^= (uint32_t)_getpid();\n+#elif defined(HAVE_GETPID)\n+    *seed ^= (uint32_t)getpid();\n+#endif\n+\n+    return 0;\n+}\n+\n+static uint32_t generate_seed() {\n+    uint32_t seed;\n+    int done = 0;\n+\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+    if (!done && seed_from_urandom(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+    if (!done && seed_from_windows_cryptoapi(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+    if (!done) {\n+        /* Fall back to timestamp and PID if no better randomness is\n+           available */\n+        seed_from_timestamp_and_pid(&seed);\n+    }\n+\n+    /* Make sure the seed is never zero */\n+    if (seed == 0)\n+        seed = 1;\n+\n+    return seed;\n+}\n+\n+\n+volatile uint32_t hashtable_seed = 0;\n+\n+#if defined(HAVE_ATOMIC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+static volatile char seed_initialized = 0;\n+\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (__atomic_test_and_set(&seed_initialized, __ATOMIC_RELAXED) == 0) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            __atomic_store_n(&hashtable_seed, new_seed, __ATOMIC_ACQ_REL);\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            } while(__atomic_load_n(&hashtable_seed, __ATOMIC_ACQUIRE) == 0);\n+        }\n+    }\n+}\n+#elif defined(HAVE_SYNC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0) {\n+            /* Explicit synchronization fences are not supported by the\n+               __sync builtins, so every thread getting here has to\n+               generate the seed value.\n+            */\n+            new_seed = generate_seed();\n+        }\n+\n+        do {\n+            if (__sync_bool_compare_and_swap(&hashtable_seed, 0, new_seed)) {\n+                /* We were the first to seed */\n+                break;\n+            } else {\n+                /* Wait for another thread to do the seeding */\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            }\n+        } while(hashtable_seed == 0);\n+    }\n+}\n+#elif defined(_WIN32)\n+static long seed_initialized = 0;\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (InterlockedIncrement(&seed_initialized) == 1) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            hashtable_seed = new_seed;\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+                SwitchToThread();\n+            } while (hashtable_seed == 0);\n+        }\n+    }\n+}\n+#else\n+/* Fall back to a thread-unsafe version */\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0)\n+            new_seed = generate_seed();\n+\n+        hashtable_seed = new_seed;\n+    }\n+}\n+#endif""}<_**next**_>{""sha"": ""19096d4201e6b13f8c56765116865c71f67e9696"", ""filename"": ""src/jansson.def"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.def"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.def"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/jansson.def?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -41,6 +41,7 @@ EXPORTS\n     json_object_iter_value\n     json_object_iter_set_new\n     json_object_key_to_iter\n+    json_object_seed\n     json_dumps\n     json_dumpf\n     json_dump_file""}<_**next**_>{""sha"": ""ea230852a629e55457fba2d00e3edd8a4ad4fcec"", ""filename"": ""src/jansson.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/jansson.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -126,6 +126,7 @@ typedef struct {\n \n /* getters, setters, manipulation */\n \n+void json_object_seed(size_t seed);\n size_t json_object_size(const json_t *object);\n json_t *json_object_get(const json_t *object, const char *key);\n int json_object_set_new(json_t *object, const char *key, json_t *value);""}<_**next**_>{""sha"": ""dc76138c940516e9590784825d28d040fd1a8b25"", ""filename"": ""src/lookup3.h"", ""status"": ""added"", ""additions"": 366, ""deletions"": 0, ""changes"": 366, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/lookup3.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/lookup3.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/lookup3.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,366 @@\n+/*\n+-------------------------------------------------------------------------------\n+lookup3.c, by Bob Jenkins, May 2006, Public Domain.\n+\n+These are functions for producing 32-bit hashes for hash table lookup.\n+hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final() \n+are externally useful functions.  Routines to test the hash are included \n+if SELF_TEST is defined.  You can use this free for any purpose.  It's in\n+the public domain.  It has no warranty.\n+\n+You probably want to use hashlittle().  hashlittle() and hashbig()\n+hash byte arrays.  hashlittle() is is faster than hashbig() on\n+little-endian machines.  Intel and AMD are little-endian machines.\n+On second thought, you probably want hashlittle2(), which is identical to\n+hashlittle() except it returns two 32-bit hashes for the price of one.  \n+You could implement hashbig2() if you wanted but I haven't bothered here.\n+\n+If you want to find a hash of, say, exactly 7 integers, do\n+  a = i1;  b = i2;  c = i3;\n+  mix(a,b,c);\n+  a += i4; b += i5; c += i6;\n+  mix(a,b,c);\n+  a += i7;\n+  final(a,b,c);\n+then use c as the hash value.  If you have a variable length array of\n+4-byte integers to hash, use hashword().  If you have a byte array (like\n+a character string), use hashlittle().  If you have several byte arrays, or\n+a mix of things, see the comments above hashlittle().  \n+\n+Why is this so big?  I read 12 bytes at a time into 3 4-byte integers, \n+then mix those integers.  This is fast (you can do a lot more thorough\n+mixing with 12*3 instructions on 3 integers than you can with 3 instructions\n+on 1 byte), but shoehorning those bytes into integers efficiently is messy.\n+-------------------------------------------------------------------------------\n+*/\n+\n+#include <stdlib.h>\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>     /* defines uint32_t etc */\n+#endif\n+\n+#ifdef HAVE_SYS_PARAM_H\n+#include <sys/param.h>  /* attempt to define endianness */\n+#endif\n+\n+#ifdef HAVE_ENDIAN_H\n+# include <endian.h>    /* attempt to define endianness */\n+#endif\n+\n+/*\n+ * My best guess at if you are big-endian or little-endian.  This may\n+ * need adjustment.\n+ */\n+#if (defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && \\\n+     __BYTE_ORDER == __LITTLE_ENDIAN) || \\\n+    (defined(i386) || defined(__i386__) || defined(__i486__) || \\\n+     defined(__i586__) || defined(__i686__) || defined(vax) || defined(MIPSEL))\n+# define HASH_LITTLE_ENDIAN 1\n+# define HASH_BIG_ENDIAN 0\n+#elif (defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && \\\n+       __BYTE_ORDER == __BIG_ENDIAN) || \\\n+      (defined(sparc) || defined(POWERPC) || defined(mc68000) || defined(sel))\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 1\n+#else\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 0\n+#endif\n+\n+#define hashsize(n) ((uint32_t)1<<(n))\n+#define hashmask(n) (hashsize(n)-1)\n+#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n+\n+/*\n+-------------------------------------------------------------------------------\n+mix -- mix 3 32-bit values reversibly.\n+\n+This is reversible, so any information in (a,b,c) before mix() is\n+still in (a,b,c) after mix().\n+\n+If four pairs of (a,b,c) inputs are run through mix(), or through\n+mix() in reverse, there are at least 32 bits of the output that\n+are sometimes the same for one pair and different for another pair.\n+This was tested for:\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+Some k values for my \""a-=c; a^=rot(c,k); c+=b;\"" arrangement that\n+satisfy this are\n+    4  6  8 16 19  4\n+    9 15  3 18 27 15\n+   14  9  3  7 17  3\n+Well, \""9 15 3 18 27 15\"" didn't quite get 32 bits diffing\n+for \""differ\"" defined as + with a one-bit base and a two-bit delta.  I\n+used http://burtleburtle.net/bob/hash/avalanche.html to choose \n+the operations, constants, and arrangements of the variables.\n+\n+This does not achieve avalanche.  There are input bits of (a,b,c)\n+that fail to affect some output bits of (a,b,c), especially of a.  The\n+most thoroughly mixed value is c, but it doesn't really even achieve\n+avalanche in c.\n+\n+This allows some parallelism.  Read-after-writes are good at doubling\n+the number of bits affected, so the goal of mixing pulls in the opposite\n+direction as the goal of parallelism.  I did what I could.  Rotates\n+seem to cost as much as shifts on every machine I could lay my hands\n+on, and rotates are much kinder to the top and bottom bits, so I used\n+rotates.\n+-------------------------------------------------------------------------------\n+*/\n+#define mix(a,b,c) \\\n+{ \\\n+  a -= c;  a ^= rot(c, 4);  c += b; \\\n+  b -= a;  b ^= rot(a, 6);  a += c; \\\n+  c -= b;  c ^= rot(b, 8);  b += a; \\\n+  a -= c;  a ^= rot(c,16);  c += b; \\\n+  b -= a;  b ^= rot(a,19);  a += c; \\\n+  c -= b;  c ^= rot(b, 4);  b += a; \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+final -- final mixing of 3 32-bit values (a,b,c) into c\n+\n+Pairs of (a,b,c) values differing in only a few bits will usually\n+produce values of c that look totally different.  This was tested for\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+These constants passed:\n+ 14 11 25 16 4 14 24\n+ 12 14 25 16 4 14 24\n+and these came close:\n+  4  8 15 26 3 22 24\n+ 10  8 15 26 3 22 24\n+ 11  8 15 26 3 22 24\n+-------------------------------------------------------------------------------\n+*/\n+#define final(a,b,c) \\\n+{ \\\n+  c ^= b; c -= rot(b,14); \\\n+  a ^= c; a -= rot(c,11); \\\n+  b ^= a; b -= rot(a,25); \\\n+  c ^= b; c -= rot(b,16); \\\n+  a ^= c; a -= rot(c,4);  \\\n+  b ^= a; b -= rot(a,14); \\\n+  c ^= b; c -= rot(b,24); \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+hashlittle() -- hash a variable-length key into a 32-bit value\n+  k       : the key (the unaligned variable-length array of bytes)\n+  length  : the length of the key, counting by bytes\n+  initval : can be any 4-byte value\n+Returns a 32-bit value.  Every bit of the key affects every bit of\n+the return value.  Two keys differing by one or two bits will have\n+totally different hash values.\n+\n+The best hash table sizes are powers of 2.  There is no need to do\n+mod a prime (mod is sooo slow!).  If you need less than 32 bits,\n+use a bitmask.  For example, if you need only 10 bits, do\n+  h = (h & hashmask(10));\n+In which case, the hash table should have hashsize(10) elements.\n+\n+If you are hashing n strings (uint8_t **)k, do it like this:\n+  for (i=0, h=0; i<n; ++i) h = hashlittle( k[i], len[i], h);\n+\n+By Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this\n+code any way you wish, private, educational, or commercial.  It's free.\n+\n+Use for hash table lookup, or anything where one collision in 2^^32 is\n+acceptable.  Do NOT use for cryptographic purposes.\n+-------------------------------------------------------------------------------\n+*/\n+\n+static uint32_t hashlittle(const void *key, size_t length, uint32_t initval)\n+{\n+  uint32_t a,b,c;                                          /* internal state */\n+  union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */\n+\n+  /* Set up the internal state */\n+  a = b = c = 0xdeadbeef + ((uint32_t)length) + initval;\n+\n+  u.ptr = key;\n+  if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0)) {\n+    const uint32_t *k = (const uint32_t *)key;         /* read 32-bit chunks */\n+\n+#ifdef VALGRIND\n+    const uint8_t  *k8;\n+#endif\n+\n+    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      b += k[1];\n+      c += k[2];\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 3;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    /* \n+     * \""k[2]&0xffffff\"" actually reads beyond the end of the string, but\n+     * then masks off the part it's not allowed to read.  Because the\n+     * string is aligned, the masked-off tail is in the same word as the\n+     * rest of the string.  Every machine with memory protection I've seen\n+     * does it on word boundaries, so is OK with this.  But VALGRIND will\n+     * still catch it and complain.  The masking trick does make the hash\n+     * noticably faster for short strings (like English words).\n+     */\n+#ifndef VALGRIND\n+\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n+    case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n+    case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n+    case 6 : b+=k[1]&0xffff; a+=k[0]; break;\n+    case 5 : b+=k[1]&0xff; a+=k[0]; break;\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=k[0]&0xffffff; break;\n+    case 2 : a+=k[0]&0xffff; break;\n+    case 1 : a+=k[0]&0xff; break;\n+    case 0 : return c;              /* zero length strings require no mixing */\n+    }\n+\n+#else /* make valgrind happy */\n+\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=((uint32_t)k8[10])<<16;  /* fall through */\n+    case 10: c+=((uint32_t)k8[9])<<8;    /* fall through */\n+    case 9 : c+=k8[8];                   /* fall through */\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;   /* fall through */\n+    case 6 : b+=((uint32_t)k8[5])<<8;    /* fall through */\n+    case 5 : b+=k8[4];                   /* fall through */\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;   /* fall through */\n+    case 2 : a+=((uint32_t)k8[1])<<8;    /* fall through */\n+    case 1 : a+=k8[0]; break;\n+    case 0 : return c;\n+    }\n+\n+#endif /* !valgrind */\n+\n+  } else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0)) {\n+    const uint16_t *k = (const uint16_t *)key;         /* read 16-bit chunks */\n+    const uint8_t  *k8;\n+\n+    /*--------------- all but last block: aligned reads and different mixing */\n+    while (length > 12)\n+    {\n+      a += k[0] + (((uint32_t)k[1])<<16);\n+      b += k[2] + (((uint32_t)k[3])<<16);\n+      c += k[4] + (((uint32_t)k[5])<<16);\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 6;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[4]+(((uint32_t)k[5])<<16);\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 11: c+=((uint32_t)k8[10])<<16;     /* fall through */\n+    case 10: c+=k[4];\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 9 : c+=k8[8];                      /* fall through */\n+    case 8 : b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;      /* fall through */\n+    case 6 : b+=k[2];\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 5 : b+=k8[4];                      /* fall through */\n+    case 4 : a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;      /* fall through */\n+    case 2 : a+=k[0];\n+             break;\n+    case 1 : a+=k8[0];\n+             break;\n+    case 0 : return c;                     /* zero length requires no mixing */\n+    }\n+\n+  } else {                        /* need to read the key one byte at a time */\n+    const uint8_t *k = (const uint8_t *)key;\n+\n+    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      a += ((uint32_t)k[1])<<8;\n+      a += ((uint32_t)k[2])<<16;\n+      a += ((uint32_t)k[3])<<24;\n+      b += k[4];\n+      b += ((uint32_t)k[5])<<8;\n+      b += ((uint32_t)k[6])<<16;\n+      b += ((uint32_t)k[7])<<24;\n+      c += k[8];\n+      c += ((uint32_t)k[9])<<8;\n+      c += ((uint32_t)k[10])<<16;\n+      c += ((uint32_t)k[11])<<24;\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 12;\n+    }\n+\n+    /*-------------------------------- last block: affect all 32 bits of (c) */\n+    switch(length)                   /* all the case statements fall through */\n+    {\n+    case 12: c+=((uint32_t)k[11])<<24;\n+    case 11: c+=((uint32_t)k[10])<<16;\n+    case 10: c+=((uint32_t)k[9])<<8;\n+    case 9 : c+=k[8];\n+    case 8 : b+=((uint32_t)k[7])<<24;\n+    case 7 : b+=((uint32_t)k[6])<<16;\n+    case 6 : b+=((uint32_t)k[5])<<8;\n+    case 5 : b+=k[4];\n+    case 4 : a+=((uint32_t)k[3])<<24;\n+    case 3 : a+=((uint32_t)k[2])<<16;\n+    case 2 : a+=((uint32_t)k[1])<<8;\n+    case 1 : a+=k[0];\n+             break;\n+    case 0 : return c;\n+    }\n+  }\n+\n+  final(a,b,c);\n+  return c;\n+}""}<_**next**_>{""sha"": ""b4f109143031b2481a0d32a332c88cc1cc96c688"", ""filename"": ""src/utf.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 16, ""changes"": 20, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/utf.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/utf.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/utf.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -10,23 +10,11 @@\n \n #ifdef HAVE_CONFIG_H\n #include <config.h>\n+#endif\n \n-#ifdef HAVE_INTTYPES_H\n-/* inttypes.h includes stdint.h in a standard environment, so there's\n-no need to include stdint.h separately. If inttypes.h doesn't define\n-int32_t, it's defined in config.h. */\n-#include <inttypes.h>\n-#endif /* HAVE_INTTYPES_H */\n-\n-#else /* !HAVE_CONFIG_H */\n-#ifdef _WIN32\n-typedef int int32_t;\n-#else /* !_WIN32 */\n-/* Assume a standard environment */\n-#include <inttypes.h>\n-#endif /* _WIN32 */\n-\n-#endif /* HAVE_CONFIG_H */\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n \n int utf8_encode(int codepoint, char *buffer, int *size);\n ""}<_**next**_>{""sha"": ""1b02d90aa885f1ede146bb2077d05c8bb9096565"", ""filename"": ""src/value.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/value.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/value.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/value.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -9,11 +9,19 @@\n #define _GNU_SOURCE\n #endif\n \n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stddef.h>\n #include <stdlib.h>\n #include <string.h>\n #include <math.h>\n \n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include \""jansson.h\""\n #include \""hashtable.h\""\n #include \""jansson_private.h\""\n@@ -36,11 +44,19 @@ static JSON_INLINE void json_init(json_t *json, json_type type)\n \n /*** object ***/\n \n+extern volatile uint32_t hashtable_seed;\n+\n json_t *json_object(void)\n {\n     json_object_t *object = jsonp_malloc(sizeof(json_object_t));\n     if(!object)\n         return NULL;\n+\n+    if (!hashtable_seed) {\n+        /* Autoseed */\n+        json_object_seed(0);\n+    }\n+\n     json_init(&object->json, JSON_OBJECT);\n \n     if(hashtable_init(&object->hashtable))""}<_**next**_>{""sha"": ""e2c54bd12bd7c22de7cc3533f010b26cc1c330b0"", ""filename"": ""test/bin/json_process.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 1, ""changes"": 16, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/bin/json_process.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/bin/json_process.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/bin/json_process.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -37,6 +37,8 @@ struct config {\n     int sort_keys;\n     int strip;\n     int use_env;\n+    int have_hashseed;\n+    int hashseed;\n } conf;\n \n #define l_isspace(c) ((c) == ' ' || (c) == '\\n' || (c) == '\\r' || (c) == '\\t')\n@@ -108,6 +110,12 @@ static void read_conf(FILE *conffile)\n             conf.sort_keys = atoi(val);\n         if (!strcmp(line, \""STRIP\""))\n             conf.strip = atoi(val);\n+        if (!strcmp(line, \""HASHSEED\"")) {\n+            conf.have_hashseed = 1;\n+            conf.hashseed = atoi(val);\n+        } else {\n+            conf.have_hashseed = 0;\n+        }\n     }\n \n     free(buffer);\n@@ -188,6 +196,9 @@ int use_conf(char *test_path)\n     if (conf.sort_keys)\n         flags |= JSON_SORT_KEYS;\n \n+    if (conf.have_hashseed)\n+        json_object_seed(conf.hashseed);\n+\n     if (conf.strip) {\n         /* Load to memory, strip leading and trailing whitespace */\n         buffer = loadfile(infile);\n@@ -265,7 +276,10 @@ int use_env()\n         flags |= JSON_PRESERVE_ORDER;\n \n     if(getenv_int(\""JSON_SORT_KEYS\""))\n-         flags |= JSON_SORT_KEYS;\n+        flags |= JSON_SORT_KEYS;\n+\n+    if(getenv(\""HASHSEED\""))\n+        json_object_seed(getenv_int(\""HASHSEED\""));\n \n     if(getenv_int(\""STRIP\"")) {\n         /* Load to memory, strip leading and trailing whitespace */""}<_**next**_>{""sha"": ""84b17466fd0a753b8cbd714d0236ed9072cdd536"", ""filename"": ""test/suites/api/test_memory_funcs.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_memory_funcs.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_memory_funcs.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/api/test_memory_funcs.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -24,13 +24,13 @@ static void create_and_free_complex_object()\n \n static void *my_malloc(size_t size)\n {\n-    malloc_called += 1;\n+    malloc_called = 1;\n     return malloc(size);\n }\n \n static void my_free(void *ptr)\n {\n-    free_called += 1;\n+    free_called = 1;\n     free(ptr);\n }\n \n@@ -39,7 +39,7 @@ static void test_simple()\n     json_set_alloc_funcs(my_malloc, my_free);\n     create_and_free_complex_object();\n \n-    if(malloc_called != 20 || free_called != 20)\n+    if(malloc_called != 1 || free_called != 1)\n         fail(\""Custom allocation failed\"");\n }\n ""}<_**next**_>{""sha"": ""92e5208224b75ab45d93672446279d598052a83e"", ""filename"": ""test/suites/api/test_object.c"", ""status"": ""modified"", ""additions"": 40, ""deletions"": 24, ""changes"": 64, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_object.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_object.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/api/test_object.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -249,7 +249,11 @@ static void test_set_nocheck()\n \n static void test_iterators()\n {\n+    int i;\n     json_t *object, *foo, *bar, *baz;\n+    const char *iter_keys[3];\n+    int have_key[3] = { 0, 0, 0 };\n+    json_t *iter_values[3];\n     void *iter;\n \n     if(json_object_iter(NULL))\n@@ -276,30 +280,50 @@ static void test_iterators()\n     iter = json_object_iter(object);\n     if(!iter)\n         fail(\""unable to get iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""a\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != foo)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[0] = json_object_iter_key(iter);\n+    iter_values[0] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""b\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != bar)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[1] = json_object_iter_key(iter);\n+    iter_values[1] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[2] = json_object_iter_key(iter);\n+    iter_values[2] = json_object_iter_value(iter);\n \n     if(json_object_iter_next(object, iter) != NULL)\n         fail(\""able to iterate over the end\"");\n \n+    /* Check that keys have correct values */\n+    for (i = 0; i < 3; i++) {\n+        if (strcmp(iter_keys[i], \""a\"") == 0) {\n+            if (iter_values[i] != foo)\n+                fail(\""wrong value for iter key a\"");\n+            else\n+                have_key[0] = 1;\n+        } else if (strcmp(iter_keys[i], \""b\"") == 0) {\n+            if (iter_values[i] != bar)\n+                fail(\""wrong value for iter key b\"");\n+            else\n+                have_key[1] = 1;\n+        } else if (strcmp(iter_keys[i], \""c\"") == 0) {\n+            if (iter_values[i] != baz)\n+                fail(\""wrong value for iter key c\"");\n+            else\n+                have_key[2] = 1;\n+        }\n+    }\n+\n+    /* Check that we got all keys */\n+    for(i = 0; i < 3; i++) {\n+        if(!have_key[i])\n+            fail(\""a key wasn't iterated over\"");\n+    }\n+\n     if(json_object_iter_at(object, \""foo\""))\n         fail(\""json_object_iter_at() succeeds for non-existent key\"");\n \n@@ -312,22 +336,14 @@ static void test_iterators()\n     if(json_object_iter_value(iter) != bar)\n         fail(\""iterating failed: wrong value\"");\n \n-    iter = json_object_iter_next(object, iter);\n-    if(!iter)\n-        fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\""iterating failed: wrong value\"");\n-\n-    if(json_object_iter_set(object, iter, bar))\n+    if(json_object_iter_set(object, iter, baz))\n         fail(\""unable to set value at iterator\"");\n \n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n+    if(strcmp(json_object_iter_key(iter), \""b\""))\n         fail(\""json_object_iter_key() fails after json_object_iter_set()\"");\n-    if(json_object_iter_value(iter) != bar)\n+    if(json_object_iter_value(iter) != baz)\n         fail(\""json_object_iter_value() fails after json_object_iter_set()\"");\n-    if(json_object_get(object, \""c\"") != bar)\n+    if(json_object_get(object, \""b\"") != baz)\n         fail(\""json_object_get() fails after json_object_iter_set()\"");\n \n     json_decref(object);""}<_**next**_>{""sha"": ""93cb33ddafeb9eef6ce7ad4709ce1bcbdf25b200"", ""filename"": ""test/suites/encoding-flags/compact-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/compact-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/compact-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/compact-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,2 +1,3 @@\n JSON_COMPACT=1\n-export JSON_COMPACT\n+HASHSEED=1\n+export JSON_COMPACT HASHSEED""}<_**next**_>{""sha"": ""c73acc1792963be8a5f41ff11f6e858506ada51d"", ""filename"": ""test/suites/encoding-flags/indent-compact-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-compact-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-compact-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/indent-compact-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,3 +1,4 @@\n JSON_INDENT=4\n JSON_COMPACT=1\n-export JSON_INDENT JSON_COMPACT\n+HASHSEED=1\n+export JSON_INDENT JSON_COMPACT HASHSEED""}<_**next**_>{""sha"": ""961558ca23ceca2ce6e4d07697f4018d8475f317"", ""filename"": ""test/suites/encoding-flags/indent-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/indent-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,2 +1,3 @@\n JSON_INDENT=4\n-export JSON_INDENT\n+HASHSEED=1\n+export JSON_INDENT HASHSEED""}<_**next**_>{""sha"": ""9120b03514ec614695c2d17841ba228b102c9db6"", ""filename"": ""test/suites/encoding-flags/object/env"", ""status"": ""added"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,2 @@\n+HASHSEED=1\n+export HASHSEED""}","static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)
","static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)
{
    return primes[hashtable->num_buckets];
}
",C,,"{
    return primes[hashtable->num_buckets];
}
",,"@@ -5,8 +5,17 @@
  * it under the terms of the MIT license. See LICENSE for details.
  */
 
+#if HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include <stdlib.h>
 #include <string.h>
+
+#if HAVE_STDINT_H
+#include <stdint.h>
+#endif
+
 #include <jansson_config.h>   /* for JSON_INLINE */
 #include ""jansson_private.h""  /* for container_of() */
 #include ""hashtable.h""
@@ -15,24 +24,13 @@ typedef struct hashtable_list list_t;
 typedef struct hashtable_pair pair_t;
 typedef struct hashtable_bucket bucket_t;
 
-#define list_to_pair(list_)  container_of(list_, pair_t, list)
-
-/* From http://www.cse.yorku.ca/~oz/hash.html */
-static size_t hash_str(const void *ptr)
-{
-    const char *str = (const char *)ptr;
-
-    size_t hash = 5381;
-    size_t c;
+extern volatile uint32_t hashtable_seed;
 
-    while((c = (size_t)*str))
-    {
-        hash = ((hash << 5) + hash) + c;
-        str++;
-    }
+/* Implementation of the hash function */
+#include ""lookup3.h""
 
-    return hash;
-}
+#define list_to_pair(list_)  container_of(list_, pair_t, list)
+#define hash_str(key)        ((size_t)hashlittle((key), strlen(key), hashtable_seed))
 
 static JSON_INLINE void list_init(list_t *list)
 {
@@ -74,19 +72,6 @@ static void insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket,
     }
 }
 
-static const size_t primes[] = {
-    5, 13, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,
-    49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,
-    12582917, 25165843, 50331653, 100663319, 201326611, 402653189,
-    805306457, 1610612741
-};
-
-static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)
-{
-    return primes[hashtable->num_buckets];
-}
-
-
 static pair_t *hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket,
                                    const char *key, size_t hash)
 {
@@ -120,7 +105,7 @@ static int hashtable_do_del(hashtable_t *hashtable,
     bucket_t *bucket;
     size_t index;
 
-    index = hash % num_buckets(hashtable);
+    index = hash & hashmask(hashtable->order);
     bucket = &hashtable->buckets[index];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
@@ -167,14 +152,14 @@ static int hashtable_do_rehash(hashtable_t *hashtable)
 
     jsonp_free(hashtable->buckets);
 
-    hashtable->num_buckets++;
-    new_size = num_buckets(hashtable);
+    hashtable->order++;
+    new_size = hashsize(hashtable->order);
 
     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));
     if(!hashtable->buckets)
         return -1;
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -199,14 +184,14 @@ int hashtable_init(hashtable_t *hashtable)
     size_t i;
 
     hashtable->size = 0;
-    hashtable->num_buckets = 0;  /* index to primes[] */
-    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));
+    hashtable->order = 3;
+    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));
     if(!hashtable->buckets)
         return -1;
 
     list_init(&hashtable->list);
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -230,12 +215,12 @@ int hashtable_set(hashtable_t *hashtable,
     size_t hash, index;
 
     /* rehash if the load ratio exceeds 1 */
-    if(hashtable->size >= num_buckets(hashtable))
+    if(hashtable->size >= hashsize(hashtable->order))
         if(hashtable_do_rehash(hashtable))
             return -1;
 
     hash = hash_str(key);
-    index = hash % num_buckets(hashtable);
+    index = hash & hashmask(hashtable->order);
     bucket = &hashtable->buckets[index];
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
 
@@ -273,7 +258,7 @@ void *hashtable_get(hashtable_t *hashtable, const char *key)
     bucket_t *bucket;
 
     hash = hash_str(key);
-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)
@@ -294,7 +279,7 @@ void hashtable_clear(hashtable_t *hashtable)
 
     hashtable_do_clear(hashtable);
 
-    for(i = 0; i < num_buckets(hashtable); i++)
+    for(i = 0; i < hashsize(hashtable->order); i++)
     {
         hashtable->buckets[i].first = hashtable->buckets[i].last =
             &hashtable->list;
@@ -316,7 +301,7 @@ void *hashtable_iter_at(hashtable_t *hashtable, const char *key)
     bucket_t *bucket;
 
     hash = hash_str(key);
-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];
+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)",jansson,8f80c2d83808150724d31793e6ade92749b1faa4,b9c588de3deb4efdd7b9ec44aa79335dba11fd6b,1,"static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)
//flaw_line_below:
{
//flaw_line_below:
    return primes[hashtable->num_buckets];
//flaw_line_below:
}
"
1971,179707,,Remote,Not required,Partial,CVE-2013-6401,https://www.cvedetails.com/cve/CVE-2013-6401/,CWE-310,Low,,,,2014-03-20,5.0,"Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document.",2014-05-23,DoS ,6,https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4,8f80c2d83808150724d31793e6ade92749b1faa4,"CVE-2013-6401: Change hash function, randomize hashes

Thanks to Florian Weimer and Eric Sesterhenn for reporting, reviewing
and testing.",0,src/value.c,"{""sha"": ""1043c9ae4c0bc0c1f6a5913783973383832ff14b"", ""filename"": ""CMakeLists.txt"", ""status"": ""modified"", ""additions"": 39, ""deletions"": 10, ""changes"": 49, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/CMakeLists.txt"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/CMakeLists.txt"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/CMakeLists.txt?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -52,6 +52,8 @@ project (jansson C)\n \n # Options\n OPTION (BUILD_SHARED_LIBS \""Build shared libraries.\"" OFF)\n+OPTION (USE_URANDOM \""Use /dev/urandom to seed the hash function.\"" ON)\n+OPTION (USE_WINDOWS_CRYPTOAPI \""Use CryptGenRandom to seed the hash function.\"" ON)\n \n if (MSVC)\n    # This option must match the settings used in your program, in particular if you\n@@ -85,12 +87,12 @@ set (JANSSON_SOVERSION 4)\n # for CheckFunctionKeywords\n set(CMAKE_MODULE_PATH \""${CMAKE_CURRENT_SOURCE_DIR}/cmake\"")\n \n+INCLUDE (CheckCSourceCompiles)\n include (CheckFunctionExists)\n include (CheckFunctionKeywords)\n include (CheckIncludeFiles)\n include (CheckTypeSize)\n \n-\n if (MSVC)\n    # Turn off Microsofts \""security\"" warnings.\n    add_definitions( \""/W3 /D_CRT_SECURE_NO_WARNINGS /wd4005 /wd4996 /nologo\"" )\n@@ -106,14 +108,25 @@ if (CMAKE_COMPILER_IS_GNUCC OR CMAKE_COMPILER_IS_GNUCXX)\n    set(CMAKE_C_FLAGS \""-fPIC\"")\n endif()\n \n-   \n+check_include_files (endian.h HAVE_ENDIAN_H)\n+check_include_files (fcntl.h HAVE_FCNTL_H)\n+check_include_files (sched.h HAVE_SCHED_H)\n+check_include_files (unistd.h HAVE_UNISTD_H)\n+check_include_files (sys/param.h HAVE_SYS_PARAM_H)\n+check_include_files (sys/stat.h HAVE_SYS_STAT_H)\n+check_include_files (sys/time.h HAVE_SYS_TIME_H)\n+check_include_files (sys/time.h HAVE_SYS_TYPES_H)\n+\n+check_function_exists (close HAVE_CLOSE)\n+check_function_exists (getpid HAVE_GETPID)\n+check_function_exists (gettimeofday HAVE_GETTIMEOFDAY)\n+check_function_exists (open HAVE_OPEN)\n+check_function_exists (read HAVE_READ)\n+check_function_exists (sched_yield HAVE_SCHED_YIELD)\n \n # Check for the int-type includes\n-check_include_files (sys/types.h HAVE_SYS_TYPES_H)\n-check_include_files (inttypes.h HAVE_INTTYPES_H)\n check_include_files (stdint.h HAVE_STDINT_H)\n \n-\n # Check our 64 bit integer sizes\n check_type_size (__int64 __INT64)\n check_type_size (int64_t INT64_T)\n@@ -124,17 +137,32 @@ check_type_size (int32_t INT32_T)\n check_type_size (__int32 __INT32)\n check_type_size (\""long\"" LONG_INT)\n check_type_size (\""int\"" INT)\n-\n if (HAVE_INT32_T)\n    set (JSON_INT32 int32_t)\n elseif (HAVE___INT32)\n    set (JSON_INT32 __int32)\n-elseif (HAVE_LONG AND (${LONG_INT} EQUAL 4))\n+elseif (HAVE_LONG_INT AND (${LONG_INT} EQUAL 4))\n    set (JSON_INT32 long)\n elseif (HAVE_INT AND (${INT} EQUAL 4))\n    set (JSON_INT32 int)\n else ()\n-   message (FATAL_ERROR \""Could not detect a valid 32 bit integer type\"")\n+   message (FATAL_ERROR \""Could not detect a valid 32-bit integer type\"")\n+endif ()\n+\n+check_type_size (uint32_t UINT32_T)\n+check_type_size (__uint32 __UINT32)\n+check_type_size (\""unsigned long\"" UNSIGNED_LONG_INT)\n+check_type_size (\""unsigned int\"" UNSIGNED_INT)\n+if (HAVE_UINT32_T)\n+   set (JSON_UINT32 uint32_t)\n+elseif (HAVE___UINT32)\n+   set (JSON_UINT32 __uint32)\n+elseif (HAVE_UNSIGNED_LONG_INT AND (${UNSIGNED_LONG_INT} EQUAL 4))\n+   set (JSON_UINT32 \""unsigned long\"")\n+elseif (HAVE_UNSIGNED_INT AND (${UNSIGNED_INT} EQUAL 4))\n+   set (JSON_UINT32 \""unsigned int\"")\n+else ()\n+   message (FATAL_ERROR \""Could not detect a valid unsigned 32-bit integer type\"")\n endif ()\n \n # Check for ssize_t and SSIZE_T existance.\n@@ -206,11 +234,9 @@ else ()\n    set (JSON_HAVE_LOCALECONV 0)\n endif ()\n \n-\n # check if we have setlocale\n check_function_exists (setlocale HAVE_SETLOCALE)\n \n-\n # Check what the inline keyword is.\n # Note that the original JSON_INLINE was always set to just 'inline', so this goes further.\n check_function_keywords(\""inline\"")\n@@ -238,6 +264,9 @@ elseif (HAVE__SNPRINTF)\n    set (JSON_SNPRINTF _snprintf)\n endif ()\n \n+check_c_source_compiles (\""int main() { unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1); return 0; } \"" HAVE_SYNC_BUILTINS)\n+check_c_source_compiles (\""int main() { char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE); return 0; }\"" HAVE_ATOMIC_BUILTINS)\n+\n # Create pkg-conf file.\n # (We use the same files as ./configure does, so we\n #  have to defined the same variables used there).""}<_**next**_>{""sha"": ""b27b9a3a849e94686aa648c1ec4d1bd4c8e35445"", ""filename"": ""cmake/config.h.cmake"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 21, ""changes"": 46, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/cmake/config.h.cmake"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/cmake/config.h.cmake"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/cmake/config.h.cmake?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,35 +1,36 @@\n-/* Reduced down to the defines that are actually used in the code */\n-\n-/* Define to 1 if you have the <inttypes.h> (and friends) header file. */\n-#cmakedefine HAVE_INTTYPES_H 1\n-#cmakedefine HAVE_STDINT_H 1\n+#cmakedefine HAVE_ENDIAN_H 1\n+#cmakedefine HAVE_FCNTL_H 1\n+#cmakedefine HAVE_SCHED_H 1\n+#cmakedefine HAVE_UNISTD_H 1\n+#cmakedefine HAVE_SYS_PARAM_H 1\n+#cmakedefine HAVE_SYS_STAT_H 1\n+#cmakedefine HAVE_SYS_TIME_H 1\n #cmakedefine HAVE_SYS_TYPES_H 1\n+#cmakedefine HAVE_STDINT_H 1\n \n-/* We must include this here, as in (eg) utf.h it will want to use\n-   the integer type, which in MSVC2010 will be in stdint.h\n-   (there is no inttypes.h in MSVC2010) */\n-#if defined(HAVE_STDINT_H)\n-#  include <stdint.h>\n-#elif defined(HAVE_INTTYPES_H)\n-#  include <inttypes.h>\n-#elif defined(HAVE_SYS_TYPES_H)\n-#  include <sys/types.h>\n-#endif\n+#cmakedefine HAVE_CLOSE 1\n+#cmakedefine HAVE_GETPID 1\n+#cmakedefine HAVE_GETTIMEOFDAY 1\n+#cmakedefine HAVE_OPEN 1\n+#cmakedefine HAVE_READ 1\n+#cmakedefine HAVE_SCHED_YIELD 1\n \n-/* Define to 1 if you have the <locale.h> header file. */\n-#cmakedefine HAVE_LOCALE_H 1\n+#cmakedefine HAVE_SYNC_BUILTINS 1\n+#cmakedefine HAVE_ATOMIC_BUILTINS 1\n \n-/* Define to 1 if you have the 'setlocale' function. */\n+#cmakedefine HAVE_LOCALE_H 1\n #cmakedefine HAVE_SETLOCALE 1\n \n-/* Define to the type of a signed integer type of width exactly 32 bits if\n-   such a type exists and the standard includes do not define it. */\n #cmakedefine HAVE_INT32_T 1\n-\n #ifndef HAVE_INT32_T\n #  define int32_t @JSON_INT32@\n #endif\n \n+#cmakedefine HAVE_UINT32_T 1\n+#ifndef HAVE_UINT32_T\n+#  define uint32_t @JSON_UINT32@\n+#endif\n+\n #cmakedefine HAVE_SSIZE_T 1\n \n #ifndef HAVE_SSIZE_T\n@@ -43,3 +44,6 @@\n #endif\n \n #cmakedefine HAVE_VSNPRINTF\n+\n+#cmakedefine USE_URANDOM 1\n+#cmakedefine USE_WINDOWS_CRYPTOAPI 1""}<_**next**_>{""sha"": ""113cb85e17a15f2fac83b528fe1880bc99481ccb"", ""filename"": ""configure.ac"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 2, ""changes"": 50, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/configure.ac"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/configure.ac"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/configure.ac?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -14,10 +14,11 @@ AM_CONDITIONAL([GCC], [test x$GCC = xyes])\n # Checks for libraries.\n \n # Checks for header files.\n-AC_CHECK_HEADERS([locale.h])\n+AC_CHECK_HEADERS([endian.h fcntl.h locale.h sched.h unistd.h sys/param.h sys/stat.h sys/time.h sys/types.h])\n \n # Checks for typedefs, structures, and compiler characteristics.\n AC_TYPE_INT32_T\n+AC_TYPE_UINT32_T\n AC_TYPE_LONG_LONG_INT\n \n AC_C_INLINE\n@@ -29,7 +30,31 @@ esac\n AC_SUBST([json_inline])\n \n # Checks for library functions.\n-AC_CHECK_FUNCS([strtoll localeconv])\n+AC_CHECK_FUNCS([close getpid gettimeofday localeconv open read sched_yield strtoll])\n+\n+AC_MSG_CHECKING([for gcc __sync builtins])\n+have_sync_builtins=no\n+AC_TRY_LINK(\n+  [], [unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1);],\n+  [have_sync_builtins=yes],\n+)\n+if test \""x$have_sync_builtins\"" = \""xyes\""; then\n+  AC_DEFINE([HAVE_SYNC_BUILTINS], [1],\n+    [Define to 1 if gcc's __sync builtins are available])\n+fi\n+AC_MSG_RESULT([$have_sync_builtins])\n+\n+AC_MSG_CHECKING([for gcc __atomic builtins])\n+have_atomic_builtins=no\n+AC_TRY_LINK(\n+  [], [char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE);],\n+  [have_atomic_builtins=yes],\n+)\n+if test \""x$have_atomic_builtins\"" = \""xyes\""; then\n+  AC_DEFINE([HAVE_ATOMIC_BUILTINS], [1],\n+    [Define to 1 if gcc's __atomic builtins are available])\n+fi\n+AC_MSG_RESULT([$have_atomic_builtins])\n \n case \""$ac_cv_type_long_long_int$ac_cv_func_strtoll\"" in\n      yesyes) json_have_long_long=1;;\n@@ -43,6 +68,27 @@ case \""$ac_cv_header_locale_h$ac_cv_func_localeconv\"" in\n esac\n AC_SUBST([json_have_localeconv])\n \n+# Features\n+AC_ARG_ENABLE([urandom],\n+  [AS_HELP_STRING([--disable-urandom],\n+    [Don't use /dev/urandom to seed the hash function])],\n+  [use_urandom=$enableval], [use_urandom=yes])\n+\n+if test \""x$use_urandom\"" = xyes; then\n+AC_DEFINE([USE_URANDOM], [1],\n+  [Define to 1 if /dev/urandom should be used for seeding the hash function])\n+fi\n+\n+AC_ARG_ENABLE([windows-cryptoapi],\n+  [AS_HELP_STRING([--disable-windows-cryptoapi],\n+    [Don't use CryptGenRandom to seed the hash function])],\n+  [use_windows_cryptoapi=$enableval], [use_windows_cryptoapi=yes])\n+\n+if test \""x$use_windows_cryptoapi\"" = xyes; then\n+AC_DEFINE([USE_WINDOWS_CRYPTOAPI], [1],\n+  [Define to 1 if CryptGenRandom should be used for seeding the hash function])\n+fi\n+\n AC_CONFIG_FILES([\n         jansson.pc\n         Makefile""}<_**next**_>{""sha"": ""b4af562e84b5ed9dba1107af7d1768dcdb0b9a95"", ""filename"": ""src/Makefile.am"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/Makefile.am"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/Makefile.am?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -8,6 +8,7 @@ libjansson_la_SOURCES = \\\n \terror.c \\\n \thashtable.c \\\n \thashtable.h \\\n+\thashtable_seed.c \\\n \tjansson_private.h \\\n \tload.c \\\n \tmemory.c \\""}<_**next**_>{""sha"": ""abd4bf11fe7a393fcf3d533b952aa8b5efa4ea30"", ""filename"": ""src/hashtable.c"", ""status"": ""modified"", ""additions"": 26, ""deletions"": 41, ""changes"": 67, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -5,8 +5,17 @@\n  * it under the terms of the MIT license. See LICENSE for details.\n  */\n \n+#if HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stdlib.h>\n #include <string.h>\n+\n+#if HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include <jansson_config.h>   /* for JSON_INLINE */\n #include \""jansson_private.h\""  /* for container_of() */\n #include \""hashtable.h\""\n@@ -15,24 +24,13 @@ typedef struct hashtable_list list_t;\n typedef struct hashtable_pair pair_t;\n typedef struct hashtable_bucket bucket_t;\n \n-#define list_to_pair(list_)  container_of(list_, pair_t, list)\n-\n-/* From http://www.cse.yorku.ca/~oz/hash.html */\n-static size_t hash_str(const void *ptr)\n-{\n-    const char *str = (const char *)ptr;\n-\n-    size_t hash = 5381;\n-    size_t c;\n+extern volatile uint32_t hashtable_seed;\n \n-    while((c = (size_t)*str))\n-    {\n-        hash = ((hash << 5) + hash) + c;\n-        str++;\n-    }\n+/* Implementation of the hash function */\n+#include \""lookup3.h\""\n \n-    return hash;\n-}\n+#define list_to_pair(list_)  container_of(list_, pair_t, list)\n+#define hash_str(key)        ((size_t)hashlittle((key), strlen(key), hashtable_seed))\n \n static JSON_INLINE void list_init(list_t *list)\n {\n@@ -74,19 +72,6 @@ static void insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket,\n     }\n }\n \n-static const size_t primes[] = {\n-    5, 13, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,\n-    49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,\n-    12582917, 25165843, 50331653, 100663319, 201326611, 402653189,\n-    805306457, 1610612741\n-};\n-\n-static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)\n-{\n-    return primes[hashtable->num_buckets];\n-}\n-\n-\n static pair_t *hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket,\n                                    const char *key, size_t hash)\n {\n@@ -120,7 +105,7 @@ static int hashtable_do_del(hashtable_t *hashtable,\n     bucket_t *bucket;\n     size_t index;\n \n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n@@ -167,14 +152,14 @@ static int hashtable_do_rehash(hashtable_t *hashtable)\n \n     jsonp_free(hashtable->buckets);\n \n-    hashtable->num_buckets++;\n-    new_size = num_buckets(hashtable);\n+    hashtable->order++;\n+    new_size = hashsize(hashtable->order);\n \n     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -199,14 +184,14 @@ int hashtable_init(hashtable_t *hashtable)\n     size_t i;\n \n     hashtable->size = 0;\n-    hashtable->num_buckets = 0;  /* index to primes[] */\n-    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));\n+    hashtable->order = 3;\n+    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n     list_init(&hashtable->list);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -230,12 +215,12 @@ int hashtable_set(hashtable_t *hashtable,\n     size_t hash, index;\n \n     /* rehash if the load ratio exceeds 1 */\n-    if(hashtable->size >= num_buckets(hashtable))\n+    if(hashtable->size >= hashsize(hashtable->order))\n         if(hashtable_do_rehash(hashtable))\n             return -1;\n \n     hash = hash_str(key);\n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n \n@@ -273,7 +258,7 @@ void *hashtable_get(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)\n@@ -294,7 +279,7 @@ void hashtable_clear(hashtable_t *hashtable)\n \n     hashtable_do_clear(hashtable);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -316,7 +301,7 @@ void *hashtable_iter_at(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)""}<_**next**_>{""sha"": ""469c6ecd869c4698f650fa81983bb3ee03d47fab"", ""filename"": ""src/hashtable.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -32,14 +32,15 @@ struct hashtable_bucket {\n typedef struct hashtable {\n     size_t size;\n     struct hashtable_bucket *buckets;\n-    size_t num_buckets;  /* index to primes[] */\n+    size_t order;  /* hashtable has pow(2, order) buckets */\n     struct hashtable_list list;\n } hashtable_t;\n \n \n #define hashtable_key_to_iter(key_) \\\n     (&(container_of(key_, struct hashtable_pair, key)->list))\n \n+\n /**\n  * hashtable_init - Initialize a hashtable object\n  *""}<_**next**_>{""sha"": ""a07d145d10df35b933c1441dcbf42d3316b78ca5"", ""filename"": ""src/hashtable_seed.c"", ""status"": ""added"", ""additions"": 278, ""deletions"": 0, ""changes"": 278, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable_seed.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable_seed.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable_seed.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,278 @@\n+/* Generate sizeof(uint32_t) bytes of as random data as possible to seed\n+   the hash function.\n+*/\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#include <stdio.h>\n+#include <time.h>\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n+#ifdef HAVE_FCNTL_H\n+#include <fcntl.h>\n+#endif\n+\n+#ifdef HAVE_SCHED_H\n+#include <sched.h>\n+#endif\n+\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+\n+#ifdef HAVE_SYS_STAT_H\n+#include <sys/stat.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TIME_H\n+#include <sys/time.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TYPES_H\n+#include <sys/types.h>\n+#endif\n+\n+#if defined(_WIN32)\n+/* For _getpid() */\n+#include <process.h>\n+#endif\n+\n+#include \""jansson.h\""\n+\n+\n+static uint32_t buf_to_uint32(char *data) {\n+    size_t i;\n+    uint32_t result = 0;\n+\n+    for (i = 0; i < sizeof(uint32_t); i++)\n+        result = (result << 8) | (unsigned char)data[i];\n+\n+    return result;\n+}\n+\n+\n+\n+/* /dev/urandom */\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+static int seed_from_urandom(uint32_t *seed) {\n+    /* Use unbuffered I/O if we have open(), close() and read(). Otherwise\n+       fall back to fopen() */\n+\n+    char data[sizeof(uint32_t)];\n+    int ok;\n+\n+#if defined(HAVE_OPEN) && defined(HAVE_CLOSE) && defined(HAVE_READ)\n+    int urandom;\n+    urandom = open(\""/dev/urandom\"", O_RDONLY);\n+    if (urandom == -1)\n+        return 1;\n+\n+    ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);\n+    close(urandom);\n+#else\n+    FILE *urandom;\n+\n+    urandom = fopen(\""/dev/urandom\"", \""rb\"");\n+    if (!urandom)\n+        return 1;\n+\n+    ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);\n+    fclose(urandom);\n+#endif\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32(data);\n+    return 0;\n+}\n+#endif\n+\n+/* Windows Crypto API */\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+#include <windows.h>\n+#include <wincrypt.h>\n+\n+typedef BOOL (WINAPI *CRYPTACQUIRECONTEXTA)(HCRYPTPROV *phProv, LPCSTR pszContainer, LPCSTR pszProvider, DWORD dwProvType, DWORD dwFlags);\n+typedef BOOL (WINAPI *CRYPTGENRANDOM)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);\n+typedef BOOL (WINAPI *CRYPTRELEASECONTEXT)(HCRYPTPROV hProv, DWORD dwFlags);\n+\n+static int seed_from_windows_cryptoapi(uint32_t *seed)\n+{\n+    HINSTANCE hAdvAPI32 = NULL;\n+    CRYPTACQUIRECONTEXTA pCryptAcquireContext = NULL;\n+    CRYPTGENRANDOM pCryptGenRandom = NULL;\n+    CRYPTRELEASECONTEXT pCryptReleaseContext = NULL;\n+    HCRYPTPROV hCryptProv = 0;\n+    BYTE data[sizeof(uint32_t)];\n+    int ok;\n+\n+    hAdvAPI32 = GetModuleHandle(\""advapi32.dll\"");\n+    if(hAdvAPI32 == NULL)\n+        return 1;\n+\n+    pCryptAcquireContext = (CRYPTACQUIRECONTEXTA)GetProcAddress(hAdvAPI32, \""CryptAcquireContextA\"");\n+    if (!pCryptAcquireContext)\n+        return 1;\n+\n+    pCryptGenRandom = (CRYPTGENRANDOM)GetProcAddress(hAdvAPI32, \""CryptGenRandom\"");\n+    if (!pCryptGenRandom)\n+        return 1;\n+\n+    pCryptReleaseContext = (CRYPTRELEASECONTEXT)GetProcAddress(hAdvAPI32, \""CryptReleaseContext\"");\n+    if (!pCryptReleaseContext)\n+        return 1;\n+\n+    if (!pCryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))\n+        return 1;\n+\n+    ok = CryptGenRandom(hCryptProv, sizeof(uint32_t), data);\n+    pCryptReleaseContext(hCryptProv, 0);\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32((char *)data);\n+    return 0;\n+}\n+#endif\n+\n+/* gettimeofday() and getpid() */\n+static int seed_from_timestamp_and_pid(uint32_t *seed) {\n+#ifdef HAVE_GETTIMEOFDAY\n+    /* XOR of seconds and microseconds */\n+    struct timeval tv;\n+    gettimeofday(&tv, NULL);\n+    *seed = (uint32_t)tv.tv_sec ^ (uint32_t)tv.tv_usec;\n+#else\n+    /* Seconds only */\n+    *seed = (uint32_t)time(NULL);\n+#endif\n+\n+    /* XOR with PID for more randomness */\n+#if defined(_WIN32)\n+    *seed ^= (uint32_t)_getpid();\n+#elif defined(HAVE_GETPID)\n+    *seed ^= (uint32_t)getpid();\n+#endif\n+\n+    return 0;\n+}\n+\n+static uint32_t generate_seed() {\n+    uint32_t seed;\n+    int done = 0;\n+\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+    if (!done && seed_from_urandom(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+    if (!done && seed_from_windows_cryptoapi(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+    if (!done) {\n+        /* Fall back to timestamp and PID if no better randomness is\n+           available */\n+        seed_from_timestamp_and_pid(&seed);\n+    }\n+\n+    /* Make sure the seed is never zero */\n+    if (seed == 0)\n+        seed = 1;\n+\n+    return seed;\n+}\n+\n+\n+volatile uint32_t hashtable_seed = 0;\n+\n+#if defined(HAVE_ATOMIC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+static volatile char seed_initialized = 0;\n+\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (__atomic_test_and_set(&seed_initialized, __ATOMIC_RELAXED) == 0) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            __atomic_store_n(&hashtable_seed, new_seed, __ATOMIC_ACQ_REL);\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            } while(__atomic_load_n(&hashtable_seed, __ATOMIC_ACQUIRE) == 0);\n+        }\n+    }\n+}\n+#elif defined(HAVE_SYNC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0) {\n+            /* Explicit synchronization fences are not supported by the\n+               __sync builtins, so every thread getting here has to\n+               generate the seed value.\n+            */\n+            new_seed = generate_seed();\n+        }\n+\n+        do {\n+            if (__sync_bool_compare_and_swap(&hashtable_seed, 0, new_seed)) {\n+                /* We were the first to seed */\n+                break;\n+            } else {\n+                /* Wait for another thread to do the seeding */\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            }\n+        } while(hashtable_seed == 0);\n+    }\n+}\n+#elif defined(_WIN32)\n+static long seed_initialized = 0;\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (InterlockedIncrement(&seed_initialized) == 1) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            hashtable_seed = new_seed;\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+                SwitchToThread();\n+            } while (hashtable_seed == 0);\n+        }\n+    }\n+}\n+#else\n+/* Fall back to a thread-unsafe version */\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0)\n+            new_seed = generate_seed();\n+\n+        hashtable_seed = new_seed;\n+    }\n+}\n+#endif""}<_**next**_>{""sha"": ""19096d4201e6b13f8c56765116865c71f67e9696"", ""filename"": ""src/jansson.def"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.def"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.def"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/jansson.def?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -41,6 +41,7 @@ EXPORTS\n     json_object_iter_value\n     json_object_iter_set_new\n     json_object_key_to_iter\n+    json_object_seed\n     json_dumps\n     json_dumpf\n     json_dump_file""}<_**next**_>{""sha"": ""ea230852a629e55457fba2d00e3edd8a4ad4fcec"", ""filename"": ""src/jansson.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/jansson.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -126,6 +126,7 @@ typedef struct {\n \n /* getters, setters, manipulation */\n \n+void json_object_seed(size_t seed);\n size_t json_object_size(const json_t *object);\n json_t *json_object_get(const json_t *object, const char *key);\n int json_object_set_new(json_t *object, const char *key, json_t *value);""}<_**next**_>{""sha"": ""dc76138c940516e9590784825d28d040fd1a8b25"", ""filename"": ""src/lookup3.h"", ""status"": ""added"", ""additions"": 366, ""deletions"": 0, ""changes"": 366, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/lookup3.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/lookup3.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/lookup3.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,366 @@\n+/*\n+-------------------------------------------------------------------------------\n+lookup3.c, by Bob Jenkins, May 2006, Public Domain.\n+\n+These are functions for producing 32-bit hashes for hash table lookup.\n+hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final() \n+are externally useful functions.  Routines to test the hash are included \n+if SELF_TEST is defined.  You can use this free for any purpose.  It's in\n+the public domain.  It has no warranty.\n+\n+You probably want to use hashlittle().  hashlittle() and hashbig()\n+hash byte arrays.  hashlittle() is is faster than hashbig() on\n+little-endian machines.  Intel and AMD are little-endian machines.\n+On second thought, you probably want hashlittle2(), which is identical to\n+hashlittle() except it returns two 32-bit hashes for the price of one.  \n+You could implement hashbig2() if you wanted but I haven't bothered here.\n+\n+If you want to find a hash of, say, exactly 7 integers, do\n+  a = i1;  b = i2;  c = i3;\n+  mix(a,b,c);\n+  a += i4; b += i5; c += i6;\n+  mix(a,b,c);\n+  a += i7;\n+  final(a,b,c);\n+then use c as the hash value.  If you have a variable length array of\n+4-byte integers to hash, use hashword().  If you have a byte array (like\n+a character string), use hashlittle().  If you have several byte arrays, or\n+a mix of things, see the comments above hashlittle().  \n+\n+Why is this so big?  I read 12 bytes at a time into 3 4-byte integers, \n+then mix those integers.  This is fast (you can do a lot more thorough\n+mixing with 12*3 instructions on 3 integers than you can with 3 instructions\n+on 1 byte), but shoehorning those bytes into integers efficiently is messy.\n+-------------------------------------------------------------------------------\n+*/\n+\n+#include <stdlib.h>\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>     /* defines uint32_t etc */\n+#endif\n+\n+#ifdef HAVE_SYS_PARAM_H\n+#include <sys/param.h>  /* attempt to define endianness */\n+#endif\n+\n+#ifdef HAVE_ENDIAN_H\n+# include <endian.h>    /* attempt to define endianness */\n+#endif\n+\n+/*\n+ * My best guess at if you are big-endian or little-endian.  This may\n+ * need adjustment.\n+ */\n+#if (defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && \\\n+     __BYTE_ORDER == __LITTLE_ENDIAN) || \\\n+    (defined(i386) || defined(__i386__) || defined(__i486__) || \\\n+     defined(__i586__) || defined(__i686__) || defined(vax) || defined(MIPSEL))\n+# define HASH_LITTLE_ENDIAN 1\n+# define HASH_BIG_ENDIAN 0\n+#elif (defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && \\\n+       __BYTE_ORDER == __BIG_ENDIAN) || \\\n+      (defined(sparc) || defined(POWERPC) || defined(mc68000) || defined(sel))\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 1\n+#else\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 0\n+#endif\n+\n+#define hashsize(n) ((uint32_t)1<<(n))\n+#define hashmask(n) (hashsize(n)-1)\n+#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n+\n+/*\n+-------------------------------------------------------------------------------\n+mix -- mix 3 32-bit values reversibly.\n+\n+This is reversible, so any information in (a,b,c) before mix() is\n+still in (a,b,c) after mix().\n+\n+If four pairs of (a,b,c) inputs are run through mix(), or through\n+mix() in reverse, there are at least 32 bits of the output that\n+are sometimes the same for one pair and different for another pair.\n+This was tested for:\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+Some k values for my \""a-=c; a^=rot(c,k); c+=b;\"" arrangement that\n+satisfy this are\n+    4  6  8 16 19  4\n+    9 15  3 18 27 15\n+   14  9  3  7 17  3\n+Well, \""9 15 3 18 27 15\"" didn't quite get 32 bits diffing\n+for \""differ\"" defined as + with a one-bit base and a two-bit delta.  I\n+used http://burtleburtle.net/bob/hash/avalanche.html to choose \n+the operations, constants, and arrangements of the variables.\n+\n+This does not achieve avalanche.  There are input bits of (a,b,c)\n+that fail to affect some output bits of (a,b,c), especially of a.  The\n+most thoroughly mixed value is c, but it doesn't really even achieve\n+avalanche in c.\n+\n+This allows some parallelism.  Read-after-writes are good at doubling\n+the number of bits affected, so the goal of mixing pulls in the opposite\n+direction as the goal of parallelism.  I did what I could.  Rotates\n+seem to cost as much as shifts on every machine I could lay my hands\n+on, and rotates are much kinder to the top and bottom bits, so I used\n+rotates.\n+-------------------------------------------------------------------------------\n+*/\n+#define mix(a,b,c) \\\n+{ \\\n+  a -= c;  a ^= rot(c, 4);  c += b; \\\n+  b -= a;  b ^= rot(a, 6);  a += c; \\\n+  c -= b;  c ^= rot(b, 8);  b += a; \\\n+  a -= c;  a ^= rot(c,16);  c += b; \\\n+  b -= a;  b ^= rot(a,19);  a += c; \\\n+  c -= b;  c ^= rot(b, 4);  b += a; \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+final -- final mixing of 3 32-bit values (a,b,c) into c\n+\n+Pairs of (a,b,c) values differing in only a few bits will usually\n+produce values of c that look totally different.  This was tested for\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+These constants passed:\n+ 14 11 25 16 4 14 24\n+ 12 14 25 16 4 14 24\n+and these came close:\n+  4  8 15 26 3 22 24\n+ 10  8 15 26 3 22 24\n+ 11  8 15 26 3 22 24\n+-------------------------------------------------------------------------------\n+*/\n+#define final(a,b,c) \\\n+{ \\\n+  c ^= b; c -= rot(b,14); \\\n+  a ^= c; a -= rot(c,11); \\\n+  b ^= a; b -= rot(a,25); \\\n+  c ^= b; c -= rot(b,16); \\\n+  a ^= c; a -= rot(c,4);  \\\n+  b ^= a; b -= rot(a,14); \\\n+  c ^= b; c -= rot(b,24); \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+hashlittle() -- hash a variable-length key into a 32-bit value\n+  k       : the key (the unaligned variable-length array of bytes)\n+  length  : the length of the key, counting by bytes\n+  initval : can be any 4-byte value\n+Returns a 32-bit value.  Every bit of the key affects every bit of\n+the return value.  Two keys differing by one or two bits will have\n+totally different hash values.\n+\n+The best hash table sizes are powers of 2.  There is no need to do\n+mod a prime (mod is sooo slow!).  If you need less than 32 bits,\n+use a bitmask.  For example, if you need only 10 bits, do\n+  h = (h & hashmask(10));\n+In which case, the hash table should have hashsize(10) elements.\n+\n+If you are hashing n strings (uint8_t **)k, do it like this:\n+  for (i=0, h=0; i<n; ++i) h = hashlittle( k[i], len[i], h);\n+\n+By Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this\n+code any way you wish, private, educational, or commercial.  It's free.\n+\n+Use for hash table lookup, or anything where one collision in 2^^32 is\n+acceptable.  Do NOT use for cryptographic purposes.\n+-------------------------------------------------------------------------------\n+*/\n+\n+static uint32_t hashlittle(const void *key, size_t length, uint32_t initval)\n+{\n+  uint32_t a,b,c;                                          /* internal state */\n+  union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */\n+\n+  /* Set up the internal state */\n+  a = b = c = 0xdeadbeef + ((uint32_t)length) + initval;\n+\n+  u.ptr = key;\n+  if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0)) {\n+    const uint32_t *k = (const uint32_t *)key;         /* read 32-bit chunks */\n+\n+#ifdef VALGRIND\n+    const uint8_t  *k8;\n+#endif\n+\n+    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      b += k[1];\n+      c += k[2];\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 3;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    /* \n+     * \""k[2]&0xffffff\"" actually reads beyond the end of the string, but\n+     * then masks off the part it's not allowed to read.  Because the\n+     * string is aligned, the masked-off tail is in the same word as the\n+     * rest of the string.  Every machine with memory protection I've seen\n+     * does it on word boundaries, so is OK with this.  But VALGRIND will\n+     * still catch it and complain.  The masking trick does make the hash\n+     * noticably faster for short strings (like English words).\n+     */\n+#ifndef VALGRIND\n+\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n+    case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n+    case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n+    case 6 : b+=k[1]&0xffff; a+=k[0]; break;\n+    case 5 : b+=k[1]&0xff; a+=k[0]; break;\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=k[0]&0xffffff; break;\n+    case 2 : a+=k[0]&0xffff; break;\n+    case 1 : a+=k[0]&0xff; break;\n+    case 0 : return c;              /* zero length strings require no mixing */\n+    }\n+\n+#else /* make valgrind happy */\n+\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=((uint32_t)k8[10])<<16;  /* fall through */\n+    case 10: c+=((uint32_t)k8[9])<<8;    /* fall through */\n+    case 9 : c+=k8[8];                   /* fall through */\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;   /* fall through */\n+    case 6 : b+=((uint32_t)k8[5])<<8;    /* fall through */\n+    case 5 : b+=k8[4];                   /* fall through */\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;   /* fall through */\n+    case 2 : a+=((uint32_t)k8[1])<<8;    /* fall through */\n+    case 1 : a+=k8[0]; break;\n+    case 0 : return c;\n+    }\n+\n+#endif /* !valgrind */\n+\n+  } else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0)) {\n+    const uint16_t *k = (const uint16_t *)key;         /* read 16-bit chunks */\n+    const uint8_t  *k8;\n+\n+    /*--------------- all but last block: aligned reads and different mixing */\n+    while (length > 12)\n+    {\n+      a += k[0] + (((uint32_t)k[1])<<16);\n+      b += k[2] + (((uint32_t)k[3])<<16);\n+      c += k[4] + (((uint32_t)k[5])<<16);\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 6;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[4]+(((uint32_t)k[5])<<16);\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 11: c+=((uint32_t)k8[10])<<16;     /* fall through */\n+    case 10: c+=k[4];\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 9 : c+=k8[8];                      /* fall through */\n+    case 8 : b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;      /* fall through */\n+    case 6 : b+=k[2];\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 5 : b+=k8[4];                      /* fall through */\n+    case 4 : a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;      /* fall through */\n+    case 2 : a+=k[0];\n+             break;\n+    case 1 : a+=k8[0];\n+             break;\n+    case 0 : return c;                     /* zero length requires no mixing */\n+    }\n+\n+  } else {                        /* need to read the key one byte at a time */\n+    const uint8_t *k = (const uint8_t *)key;\n+\n+    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      a += ((uint32_t)k[1])<<8;\n+      a += ((uint32_t)k[2])<<16;\n+      a += ((uint32_t)k[3])<<24;\n+      b += k[4];\n+      b += ((uint32_t)k[5])<<8;\n+      b += ((uint32_t)k[6])<<16;\n+      b += ((uint32_t)k[7])<<24;\n+      c += k[8];\n+      c += ((uint32_t)k[9])<<8;\n+      c += ((uint32_t)k[10])<<16;\n+      c += ((uint32_t)k[11])<<24;\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 12;\n+    }\n+\n+    /*-------------------------------- last block: affect all 32 bits of (c) */\n+    switch(length)                   /* all the case statements fall through */\n+    {\n+    case 12: c+=((uint32_t)k[11])<<24;\n+    case 11: c+=((uint32_t)k[10])<<16;\n+    case 10: c+=((uint32_t)k[9])<<8;\n+    case 9 : c+=k[8];\n+    case 8 : b+=((uint32_t)k[7])<<24;\n+    case 7 : b+=((uint32_t)k[6])<<16;\n+    case 6 : b+=((uint32_t)k[5])<<8;\n+    case 5 : b+=k[4];\n+    case 4 : a+=((uint32_t)k[3])<<24;\n+    case 3 : a+=((uint32_t)k[2])<<16;\n+    case 2 : a+=((uint32_t)k[1])<<8;\n+    case 1 : a+=k[0];\n+             break;\n+    case 0 : return c;\n+    }\n+  }\n+\n+  final(a,b,c);\n+  return c;\n+}""}<_**next**_>{""sha"": ""b4f109143031b2481a0d32a332c88cc1cc96c688"", ""filename"": ""src/utf.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 16, ""changes"": 20, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/utf.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/utf.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/utf.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -10,23 +10,11 @@\n \n #ifdef HAVE_CONFIG_H\n #include <config.h>\n+#endif\n \n-#ifdef HAVE_INTTYPES_H\n-/* inttypes.h includes stdint.h in a standard environment, so there's\n-no need to include stdint.h separately. If inttypes.h doesn't define\n-int32_t, it's defined in config.h. */\n-#include <inttypes.h>\n-#endif /* HAVE_INTTYPES_H */\n-\n-#else /* !HAVE_CONFIG_H */\n-#ifdef _WIN32\n-typedef int int32_t;\n-#else /* !_WIN32 */\n-/* Assume a standard environment */\n-#include <inttypes.h>\n-#endif /* _WIN32 */\n-\n-#endif /* HAVE_CONFIG_H */\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n \n int utf8_encode(int codepoint, char *buffer, int *size);\n ""}<_**next**_>{""sha"": ""1b02d90aa885f1ede146bb2077d05c8bb9096565"", ""filename"": ""src/value.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/value.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/value.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/value.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -9,11 +9,19 @@\n #define _GNU_SOURCE\n #endif\n \n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stddef.h>\n #include <stdlib.h>\n #include <string.h>\n #include <math.h>\n \n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include \""jansson.h\""\n #include \""hashtable.h\""\n #include \""jansson_private.h\""\n@@ -36,11 +44,19 @@ static JSON_INLINE void json_init(json_t *json, json_type type)\n \n /*** object ***/\n \n+extern volatile uint32_t hashtable_seed;\n+\n json_t *json_object(void)\n {\n     json_object_t *object = jsonp_malloc(sizeof(json_object_t));\n     if(!object)\n         return NULL;\n+\n+    if (!hashtable_seed) {\n+        /* Autoseed */\n+        json_object_seed(0);\n+    }\n+\n     json_init(&object->json, JSON_OBJECT);\n \n     if(hashtable_init(&object->hashtable))""}<_**next**_>{""sha"": ""e2c54bd12bd7c22de7cc3533f010b26cc1c330b0"", ""filename"": ""test/bin/json_process.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 1, ""changes"": 16, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/bin/json_process.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/bin/json_process.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/bin/json_process.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -37,6 +37,8 @@ struct config {\n     int sort_keys;\n     int strip;\n     int use_env;\n+    int have_hashseed;\n+    int hashseed;\n } conf;\n \n #define l_isspace(c) ((c) == ' ' || (c) == '\\n' || (c) == '\\r' || (c) == '\\t')\n@@ -108,6 +110,12 @@ static void read_conf(FILE *conffile)\n             conf.sort_keys = atoi(val);\n         if (!strcmp(line, \""STRIP\""))\n             conf.strip = atoi(val);\n+        if (!strcmp(line, \""HASHSEED\"")) {\n+            conf.have_hashseed = 1;\n+            conf.hashseed = atoi(val);\n+        } else {\n+            conf.have_hashseed = 0;\n+        }\n     }\n \n     free(buffer);\n@@ -188,6 +196,9 @@ int use_conf(char *test_path)\n     if (conf.sort_keys)\n         flags |= JSON_SORT_KEYS;\n \n+    if (conf.have_hashseed)\n+        json_object_seed(conf.hashseed);\n+\n     if (conf.strip) {\n         /* Load to memory, strip leading and trailing whitespace */\n         buffer = loadfile(infile);\n@@ -265,7 +276,10 @@ int use_env()\n         flags |= JSON_PRESERVE_ORDER;\n \n     if(getenv_int(\""JSON_SORT_KEYS\""))\n-         flags |= JSON_SORT_KEYS;\n+        flags |= JSON_SORT_KEYS;\n+\n+    if(getenv(\""HASHSEED\""))\n+        json_object_seed(getenv_int(\""HASHSEED\""));\n \n     if(getenv_int(\""STRIP\"")) {\n         /* Load to memory, strip leading and trailing whitespace */""}<_**next**_>{""sha"": ""84b17466fd0a753b8cbd714d0236ed9072cdd536"", ""filename"": ""test/suites/api/test_memory_funcs.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_memory_funcs.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_memory_funcs.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/api/test_memory_funcs.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -24,13 +24,13 @@ static void create_and_free_complex_object()\n \n static void *my_malloc(size_t size)\n {\n-    malloc_called += 1;\n+    malloc_called = 1;\n     return malloc(size);\n }\n \n static void my_free(void *ptr)\n {\n-    free_called += 1;\n+    free_called = 1;\n     free(ptr);\n }\n \n@@ -39,7 +39,7 @@ static void test_simple()\n     json_set_alloc_funcs(my_malloc, my_free);\n     create_and_free_complex_object();\n \n-    if(malloc_called != 20 || free_called != 20)\n+    if(malloc_called != 1 || free_called != 1)\n         fail(\""Custom allocation failed\"");\n }\n ""}<_**next**_>{""sha"": ""92e5208224b75ab45d93672446279d598052a83e"", ""filename"": ""test/suites/api/test_object.c"", ""status"": ""modified"", ""additions"": 40, ""deletions"": 24, ""changes"": 64, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_object.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_object.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/api/test_object.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -249,7 +249,11 @@ static void test_set_nocheck()\n \n static void test_iterators()\n {\n+    int i;\n     json_t *object, *foo, *bar, *baz;\n+    const char *iter_keys[3];\n+    int have_key[3] = { 0, 0, 0 };\n+    json_t *iter_values[3];\n     void *iter;\n \n     if(json_object_iter(NULL))\n@@ -276,30 +280,50 @@ static void test_iterators()\n     iter = json_object_iter(object);\n     if(!iter)\n         fail(\""unable to get iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""a\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != foo)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[0] = json_object_iter_key(iter);\n+    iter_values[0] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""b\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != bar)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[1] = json_object_iter_key(iter);\n+    iter_values[1] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[2] = json_object_iter_key(iter);\n+    iter_values[2] = json_object_iter_value(iter);\n \n     if(json_object_iter_next(object, iter) != NULL)\n         fail(\""able to iterate over the end\"");\n \n+    /* Check that keys have correct values */\n+    for (i = 0; i < 3; i++) {\n+        if (strcmp(iter_keys[i], \""a\"") == 0) {\n+            if (iter_values[i] != foo)\n+                fail(\""wrong value for iter key a\"");\n+            else\n+                have_key[0] = 1;\n+        } else if (strcmp(iter_keys[i], \""b\"") == 0) {\n+            if (iter_values[i] != bar)\n+                fail(\""wrong value for iter key b\"");\n+            else\n+                have_key[1] = 1;\n+        } else if (strcmp(iter_keys[i], \""c\"") == 0) {\n+            if (iter_values[i] != baz)\n+                fail(\""wrong value for iter key c\"");\n+            else\n+                have_key[2] = 1;\n+        }\n+    }\n+\n+    /* Check that we got all keys */\n+    for(i = 0; i < 3; i++) {\n+        if(!have_key[i])\n+            fail(\""a key wasn't iterated over\"");\n+    }\n+\n     if(json_object_iter_at(object, \""foo\""))\n         fail(\""json_object_iter_at() succeeds for non-existent key\"");\n \n@@ -312,22 +336,14 @@ static void test_iterators()\n     if(json_object_iter_value(iter) != bar)\n         fail(\""iterating failed: wrong value\"");\n \n-    iter = json_object_iter_next(object, iter);\n-    if(!iter)\n-        fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\""iterating failed: wrong value\"");\n-\n-    if(json_object_iter_set(object, iter, bar))\n+    if(json_object_iter_set(object, iter, baz))\n         fail(\""unable to set value at iterator\"");\n \n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n+    if(strcmp(json_object_iter_key(iter), \""b\""))\n         fail(\""json_object_iter_key() fails after json_object_iter_set()\"");\n-    if(json_object_iter_value(iter) != bar)\n+    if(json_object_iter_value(iter) != baz)\n         fail(\""json_object_iter_value() fails after json_object_iter_set()\"");\n-    if(json_object_get(object, \""c\"") != bar)\n+    if(json_object_get(object, \""b\"") != baz)\n         fail(\""json_object_get() fails after json_object_iter_set()\"");\n \n     json_decref(object);""}<_**next**_>{""sha"": ""93cb33ddafeb9eef6ce7ad4709ce1bcbdf25b200"", ""filename"": ""test/suites/encoding-flags/compact-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/compact-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/compact-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/compact-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,2 +1,3 @@\n JSON_COMPACT=1\n-export JSON_COMPACT\n+HASHSEED=1\n+export JSON_COMPACT HASHSEED""}<_**next**_>{""sha"": ""c73acc1792963be8a5f41ff11f6e858506ada51d"", ""filename"": ""test/suites/encoding-flags/indent-compact-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-compact-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-compact-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/indent-compact-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,3 +1,4 @@\n JSON_INDENT=4\n JSON_COMPACT=1\n-export JSON_INDENT JSON_COMPACT\n+HASHSEED=1\n+export JSON_INDENT JSON_COMPACT HASHSEED""}<_**next**_>{""sha"": ""961558ca23ceca2ce6e4d07697f4018d8475f317"", ""filename"": ""test/suites/encoding-flags/indent-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/indent-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,2 +1,3 @@\n JSON_INDENT=4\n-export JSON_INDENT\n+HASHSEED=1\n+export JSON_INDENT HASHSEED""}<_**next**_>{""sha"": ""9120b03514ec614695c2d17841ba228b102c9db6"", ""filename"": ""test/suites/encoding-flags/object/env"", ""status"": ""added"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,2 @@\n+HASHSEED=1\n+export HASHSEED""}"," json_t *json_object(void)
 {
     json_object_t *object = jsonp_malloc(sizeof(json_object_t));
     if(!object)
         return NULL;

    if (!hashtable_seed) {
        /* Autoseed */
        json_object_seed(0);
    }

     json_init(&object->json, JSON_OBJECT);
 
     if(hashtable_init(&object->hashtable))
    {
        jsonp_free(object);
        return NULL;
    }

    object->serial = 0;
    object->visited = 0;

    return &object->json;
}
"," json_t *json_object(void)
 {
     json_object_t *object = jsonp_malloc(sizeof(json_object_t));
     if(!object)
         return NULL;
     json_init(&object->json, JSON_OBJECT);
 
     if(hashtable_init(&object->hashtable))
    {
        jsonp_free(object);
        return NULL;
    }

    object->serial = 0;
    object->visited = 0;

    return &object->json;
}
",C,"
    if (!hashtable_seed) {
        /* Autoseed */
        json_object_seed(0);
    }

",,,"@@ -9,11 +9,19 @@
 #define _GNU_SOURCE
 #endif
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include <stddef.h>
 #include <stdlib.h>
 #include <string.h>
 #include <math.h>
 
+#ifdef HAVE_STDINT_H
+#include <stdint.h>
+#endif
+
 #include ""jansson.h""
 #include ""hashtable.h""
 #include ""jansson_private.h""
@@ -36,11 +44,19 @@ static JSON_INLINE void json_init(json_t *json, json_type type)
 
 /*** object ***/
 
+extern volatile uint32_t hashtable_seed;
+
 json_t *json_object(void)
 {
     json_object_t *object = jsonp_malloc(sizeof(json_object_t));
     if(!object)
         return NULL;
+
+    if (!hashtable_seed) {
+        /* Autoseed */
+        json_object_seed(0);
+    }
+
     json_init(&object->json, JSON_OBJECT);
 
     if(hashtable_init(&object->hashtable))",jansson,8f80c2d83808150724d31793e6ade92749b1faa4,b9c588de3deb4efdd7b9ec44aa79335dba11fd6b,1," json_t *json_object(void)
 {
     json_object_t *object = jsonp_malloc(sizeof(json_object_t));
     if(!object)
         return NULL;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if (!hashtable_seed) {
//fix_flaw_line_below:
//        /* Autoseed */
//fix_flaw_line_below:
//        json_object_seed(0);
//fix_flaw_line_below:
//    }
//fix_flaw_line_below:
//
     json_init(&object->json, JSON_OBJECT);
 
     if(hashtable_init(&object->hashtable))
    {
        jsonp_free(object);
        return NULL;
    }

    object->serial = 0;
    object->visited = 0;

    return &object->json;
}
"
1972,179708,,Remote,Not required,Partial,CVE-2013-6401,https://www.cvedetails.com/cve/CVE-2013-6401/,CWE-310,Low,,,,2014-03-20,5.0,"Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document.",2014-05-23,DoS ,6,https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4,8f80c2d83808150724d31793e6ade92749b1faa4,"CVE-2013-6401: Change hash function, randomize hashes

Thanks to Florian Weimer and Eric Sesterhenn for reporting, reviewing
and testing.",0,test/bin/json_process.c,"{""sha"": ""1043c9ae4c0bc0c1f6a5913783973383832ff14b"", ""filename"": ""CMakeLists.txt"", ""status"": ""modified"", ""additions"": 39, ""deletions"": 10, ""changes"": 49, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/CMakeLists.txt"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/CMakeLists.txt"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/CMakeLists.txt?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -52,6 +52,8 @@ project (jansson C)\n \n # Options\n OPTION (BUILD_SHARED_LIBS \""Build shared libraries.\"" OFF)\n+OPTION (USE_URANDOM \""Use /dev/urandom to seed the hash function.\"" ON)\n+OPTION (USE_WINDOWS_CRYPTOAPI \""Use CryptGenRandom to seed the hash function.\"" ON)\n \n if (MSVC)\n    # This option must match the settings used in your program, in particular if you\n@@ -85,12 +87,12 @@ set (JANSSON_SOVERSION 4)\n # for CheckFunctionKeywords\n set(CMAKE_MODULE_PATH \""${CMAKE_CURRENT_SOURCE_DIR}/cmake\"")\n \n+INCLUDE (CheckCSourceCompiles)\n include (CheckFunctionExists)\n include (CheckFunctionKeywords)\n include (CheckIncludeFiles)\n include (CheckTypeSize)\n \n-\n if (MSVC)\n    # Turn off Microsofts \""security\"" warnings.\n    add_definitions( \""/W3 /D_CRT_SECURE_NO_WARNINGS /wd4005 /wd4996 /nologo\"" )\n@@ -106,14 +108,25 @@ if (CMAKE_COMPILER_IS_GNUCC OR CMAKE_COMPILER_IS_GNUCXX)\n    set(CMAKE_C_FLAGS \""-fPIC\"")\n endif()\n \n-   \n+check_include_files (endian.h HAVE_ENDIAN_H)\n+check_include_files (fcntl.h HAVE_FCNTL_H)\n+check_include_files (sched.h HAVE_SCHED_H)\n+check_include_files (unistd.h HAVE_UNISTD_H)\n+check_include_files (sys/param.h HAVE_SYS_PARAM_H)\n+check_include_files (sys/stat.h HAVE_SYS_STAT_H)\n+check_include_files (sys/time.h HAVE_SYS_TIME_H)\n+check_include_files (sys/time.h HAVE_SYS_TYPES_H)\n+\n+check_function_exists (close HAVE_CLOSE)\n+check_function_exists (getpid HAVE_GETPID)\n+check_function_exists (gettimeofday HAVE_GETTIMEOFDAY)\n+check_function_exists (open HAVE_OPEN)\n+check_function_exists (read HAVE_READ)\n+check_function_exists (sched_yield HAVE_SCHED_YIELD)\n \n # Check for the int-type includes\n-check_include_files (sys/types.h HAVE_SYS_TYPES_H)\n-check_include_files (inttypes.h HAVE_INTTYPES_H)\n check_include_files (stdint.h HAVE_STDINT_H)\n \n-\n # Check our 64 bit integer sizes\n check_type_size (__int64 __INT64)\n check_type_size (int64_t INT64_T)\n@@ -124,17 +137,32 @@ check_type_size (int32_t INT32_T)\n check_type_size (__int32 __INT32)\n check_type_size (\""long\"" LONG_INT)\n check_type_size (\""int\"" INT)\n-\n if (HAVE_INT32_T)\n    set (JSON_INT32 int32_t)\n elseif (HAVE___INT32)\n    set (JSON_INT32 __int32)\n-elseif (HAVE_LONG AND (${LONG_INT} EQUAL 4))\n+elseif (HAVE_LONG_INT AND (${LONG_INT} EQUAL 4))\n    set (JSON_INT32 long)\n elseif (HAVE_INT AND (${INT} EQUAL 4))\n    set (JSON_INT32 int)\n else ()\n-   message (FATAL_ERROR \""Could not detect a valid 32 bit integer type\"")\n+   message (FATAL_ERROR \""Could not detect a valid 32-bit integer type\"")\n+endif ()\n+\n+check_type_size (uint32_t UINT32_T)\n+check_type_size (__uint32 __UINT32)\n+check_type_size (\""unsigned long\"" UNSIGNED_LONG_INT)\n+check_type_size (\""unsigned int\"" UNSIGNED_INT)\n+if (HAVE_UINT32_T)\n+   set (JSON_UINT32 uint32_t)\n+elseif (HAVE___UINT32)\n+   set (JSON_UINT32 __uint32)\n+elseif (HAVE_UNSIGNED_LONG_INT AND (${UNSIGNED_LONG_INT} EQUAL 4))\n+   set (JSON_UINT32 \""unsigned long\"")\n+elseif (HAVE_UNSIGNED_INT AND (${UNSIGNED_INT} EQUAL 4))\n+   set (JSON_UINT32 \""unsigned int\"")\n+else ()\n+   message (FATAL_ERROR \""Could not detect a valid unsigned 32-bit integer type\"")\n endif ()\n \n # Check for ssize_t and SSIZE_T existance.\n@@ -206,11 +234,9 @@ else ()\n    set (JSON_HAVE_LOCALECONV 0)\n endif ()\n \n-\n # check if we have setlocale\n check_function_exists (setlocale HAVE_SETLOCALE)\n \n-\n # Check what the inline keyword is.\n # Note that the original JSON_INLINE was always set to just 'inline', so this goes further.\n check_function_keywords(\""inline\"")\n@@ -238,6 +264,9 @@ elseif (HAVE__SNPRINTF)\n    set (JSON_SNPRINTF _snprintf)\n endif ()\n \n+check_c_source_compiles (\""int main() { unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1); return 0; } \"" HAVE_SYNC_BUILTINS)\n+check_c_source_compiles (\""int main() { char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE); return 0; }\"" HAVE_ATOMIC_BUILTINS)\n+\n # Create pkg-conf file.\n # (We use the same files as ./configure does, so we\n #  have to defined the same variables used there).""}<_**next**_>{""sha"": ""b27b9a3a849e94686aa648c1ec4d1bd4c8e35445"", ""filename"": ""cmake/config.h.cmake"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 21, ""changes"": 46, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/cmake/config.h.cmake"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/cmake/config.h.cmake"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/cmake/config.h.cmake?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,35 +1,36 @@\n-/* Reduced down to the defines that are actually used in the code */\n-\n-/* Define to 1 if you have the <inttypes.h> (and friends) header file. */\n-#cmakedefine HAVE_INTTYPES_H 1\n-#cmakedefine HAVE_STDINT_H 1\n+#cmakedefine HAVE_ENDIAN_H 1\n+#cmakedefine HAVE_FCNTL_H 1\n+#cmakedefine HAVE_SCHED_H 1\n+#cmakedefine HAVE_UNISTD_H 1\n+#cmakedefine HAVE_SYS_PARAM_H 1\n+#cmakedefine HAVE_SYS_STAT_H 1\n+#cmakedefine HAVE_SYS_TIME_H 1\n #cmakedefine HAVE_SYS_TYPES_H 1\n+#cmakedefine HAVE_STDINT_H 1\n \n-/* We must include this here, as in (eg) utf.h it will want to use\n-   the integer type, which in MSVC2010 will be in stdint.h\n-   (there is no inttypes.h in MSVC2010) */\n-#if defined(HAVE_STDINT_H)\n-#  include <stdint.h>\n-#elif defined(HAVE_INTTYPES_H)\n-#  include <inttypes.h>\n-#elif defined(HAVE_SYS_TYPES_H)\n-#  include <sys/types.h>\n-#endif\n+#cmakedefine HAVE_CLOSE 1\n+#cmakedefine HAVE_GETPID 1\n+#cmakedefine HAVE_GETTIMEOFDAY 1\n+#cmakedefine HAVE_OPEN 1\n+#cmakedefine HAVE_READ 1\n+#cmakedefine HAVE_SCHED_YIELD 1\n \n-/* Define to 1 if you have the <locale.h> header file. */\n-#cmakedefine HAVE_LOCALE_H 1\n+#cmakedefine HAVE_SYNC_BUILTINS 1\n+#cmakedefine HAVE_ATOMIC_BUILTINS 1\n \n-/* Define to 1 if you have the 'setlocale' function. */\n+#cmakedefine HAVE_LOCALE_H 1\n #cmakedefine HAVE_SETLOCALE 1\n \n-/* Define to the type of a signed integer type of width exactly 32 bits if\n-   such a type exists and the standard includes do not define it. */\n #cmakedefine HAVE_INT32_T 1\n-\n #ifndef HAVE_INT32_T\n #  define int32_t @JSON_INT32@\n #endif\n \n+#cmakedefine HAVE_UINT32_T 1\n+#ifndef HAVE_UINT32_T\n+#  define uint32_t @JSON_UINT32@\n+#endif\n+\n #cmakedefine HAVE_SSIZE_T 1\n \n #ifndef HAVE_SSIZE_T\n@@ -43,3 +44,6 @@\n #endif\n \n #cmakedefine HAVE_VSNPRINTF\n+\n+#cmakedefine USE_URANDOM 1\n+#cmakedefine USE_WINDOWS_CRYPTOAPI 1""}<_**next**_>{""sha"": ""113cb85e17a15f2fac83b528fe1880bc99481ccb"", ""filename"": ""configure.ac"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 2, ""changes"": 50, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/configure.ac"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/configure.ac"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/configure.ac?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -14,10 +14,11 @@ AM_CONDITIONAL([GCC], [test x$GCC = xyes])\n # Checks for libraries.\n \n # Checks for header files.\n-AC_CHECK_HEADERS([locale.h])\n+AC_CHECK_HEADERS([endian.h fcntl.h locale.h sched.h unistd.h sys/param.h sys/stat.h sys/time.h sys/types.h])\n \n # Checks for typedefs, structures, and compiler characteristics.\n AC_TYPE_INT32_T\n+AC_TYPE_UINT32_T\n AC_TYPE_LONG_LONG_INT\n \n AC_C_INLINE\n@@ -29,7 +30,31 @@ esac\n AC_SUBST([json_inline])\n \n # Checks for library functions.\n-AC_CHECK_FUNCS([strtoll localeconv])\n+AC_CHECK_FUNCS([close getpid gettimeofday localeconv open read sched_yield strtoll])\n+\n+AC_MSG_CHECKING([for gcc __sync builtins])\n+have_sync_builtins=no\n+AC_TRY_LINK(\n+  [], [unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1);],\n+  [have_sync_builtins=yes],\n+)\n+if test \""x$have_sync_builtins\"" = \""xyes\""; then\n+  AC_DEFINE([HAVE_SYNC_BUILTINS], [1],\n+    [Define to 1 if gcc's __sync builtins are available])\n+fi\n+AC_MSG_RESULT([$have_sync_builtins])\n+\n+AC_MSG_CHECKING([for gcc __atomic builtins])\n+have_atomic_builtins=no\n+AC_TRY_LINK(\n+  [], [char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE);],\n+  [have_atomic_builtins=yes],\n+)\n+if test \""x$have_atomic_builtins\"" = \""xyes\""; then\n+  AC_DEFINE([HAVE_ATOMIC_BUILTINS], [1],\n+    [Define to 1 if gcc's __atomic builtins are available])\n+fi\n+AC_MSG_RESULT([$have_atomic_builtins])\n \n case \""$ac_cv_type_long_long_int$ac_cv_func_strtoll\"" in\n      yesyes) json_have_long_long=1;;\n@@ -43,6 +68,27 @@ case \""$ac_cv_header_locale_h$ac_cv_func_localeconv\"" in\n esac\n AC_SUBST([json_have_localeconv])\n \n+# Features\n+AC_ARG_ENABLE([urandom],\n+  [AS_HELP_STRING([--disable-urandom],\n+    [Don't use /dev/urandom to seed the hash function])],\n+  [use_urandom=$enableval], [use_urandom=yes])\n+\n+if test \""x$use_urandom\"" = xyes; then\n+AC_DEFINE([USE_URANDOM], [1],\n+  [Define to 1 if /dev/urandom should be used for seeding the hash function])\n+fi\n+\n+AC_ARG_ENABLE([windows-cryptoapi],\n+  [AS_HELP_STRING([--disable-windows-cryptoapi],\n+    [Don't use CryptGenRandom to seed the hash function])],\n+  [use_windows_cryptoapi=$enableval], [use_windows_cryptoapi=yes])\n+\n+if test \""x$use_windows_cryptoapi\"" = xyes; then\n+AC_DEFINE([USE_WINDOWS_CRYPTOAPI], [1],\n+  [Define to 1 if CryptGenRandom should be used for seeding the hash function])\n+fi\n+\n AC_CONFIG_FILES([\n         jansson.pc\n         Makefile""}<_**next**_>{""sha"": ""b4af562e84b5ed9dba1107af7d1768dcdb0b9a95"", ""filename"": ""src/Makefile.am"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/Makefile.am"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/Makefile.am?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -8,6 +8,7 @@ libjansson_la_SOURCES = \\\n \terror.c \\\n \thashtable.c \\\n \thashtable.h \\\n+\thashtable_seed.c \\\n \tjansson_private.h \\\n \tload.c \\\n \tmemory.c \\""}<_**next**_>{""sha"": ""abd4bf11fe7a393fcf3d533b952aa8b5efa4ea30"", ""filename"": ""src/hashtable.c"", ""status"": ""modified"", ""additions"": 26, ""deletions"": 41, ""changes"": 67, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -5,8 +5,17 @@\n  * it under the terms of the MIT license. See LICENSE for details.\n  */\n \n+#if HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stdlib.h>\n #include <string.h>\n+\n+#if HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include <jansson_config.h>   /* for JSON_INLINE */\n #include \""jansson_private.h\""  /* for container_of() */\n #include \""hashtable.h\""\n@@ -15,24 +24,13 @@ typedef struct hashtable_list list_t;\n typedef struct hashtable_pair pair_t;\n typedef struct hashtable_bucket bucket_t;\n \n-#define list_to_pair(list_)  container_of(list_, pair_t, list)\n-\n-/* From http://www.cse.yorku.ca/~oz/hash.html */\n-static size_t hash_str(const void *ptr)\n-{\n-    const char *str = (const char *)ptr;\n-\n-    size_t hash = 5381;\n-    size_t c;\n+extern volatile uint32_t hashtable_seed;\n \n-    while((c = (size_t)*str))\n-    {\n-        hash = ((hash << 5) + hash) + c;\n-        str++;\n-    }\n+/* Implementation of the hash function */\n+#include \""lookup3.h\""\n \n-    return hash;\n-}\n+#define list_to_pair(list_)  container_of(list_, pair_t, list)\n+#define hash_str(key)        ((size_t)hashlittle((key), strlen(key), hashtable_seed))\n \n static JSON_INLINE void list_init(list_t *list)\n {\n@@ -74,19 +72,6 @@ static void insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket,\n     }\n }\n \n-static const size_t primes[] = {\n-    5, 13, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,\n-    49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,\n-    12582917, 25165843, 50331653, 100663319, 201326611, 402653189,\n-    805306457, 1610612741\n-};\n-\n-static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)\n-{\n-    return primes[hashtable->num_buckets];\n-}\n-\n-\n static pair_t *hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket,\n                                    const char *key, size_t hash)\n {\n@@ -120,7 +105,7 @@ static int hashtable_do_del(hashtable_t *hashtable,\n     bucket_t *bucket;\n     size_t index;\n \n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n@@ -167,14 +152,14 @@ static int hashtable_do_rehash(hashtable_t *hashtable)\n \n     jsonp_free(hashtable->buckets);\n \n-    hashtable->num_buckets++;\n-    new_size = num_buckets(hashtable);\n+    hashtable->order++;\n+    new_size = hashsize(hashtable->order);\n \n     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -199,14 +184,14 @@ int hashtable_init(hashtable_t *hashtable)\n     size_t i;\n \n     hashtable->size = 0;\n-    hashtable->num_buckets = 0;  /* index to primes[] */\n-    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));\n+    hashtable->order = 3;\n+    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n     list_init(&hashtable->list);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -230,12 +215,12 @@ int hashtable_set(hashtable_t *hashtable,\n     size_t hash, index;\n \n     /* rehash if the load ratio exceeds 1 */\n-    if(hashtable->size >= num_buckets(hashtable))\n+    if(hashtable->size >= hashsize(hashtable->order))\n         if(hashtable_do_rehash(hashtable))\n             return -1;\n \n     hash = hash_str(key);\n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n \n@@ -273,7 +258,7 @@ void *hashtable_get(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)\n@@ -294,7 +279,7 @@ void hashtable_clear(hashtable_t *hashtable)\n \n     hashtable_do_clear(hashtable);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -316,7 +301,7 @@ void *hashtable_iter_at(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)""}<_**next**_>{""sha"": ""469c6ecd869c4698f650fa81983bb3ee03d47fab"", ""filename"": ""src/hashtable.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -32,14 +32,15 @@ struct hashtable_bucket {\n typedef struct hashtable {\n     size_t size;\n     struct hashtable_bucket *buckets;\n-    size_t num_buckets;  /* index to primes[] */\n+    size_t order;  /* hashtable has pow(2, order) buckets */\n     struct hashtable_list list;\n } hashtable_t;\n \n \n #define hashtable_key_to_iter(key_) \\\n     (&(container_of(key_, struct hashtable_pair, key)->list))\n \n+\n /**\n  * hashtable_init - Initialize a hashtable object\n  *""}<_**next**_>{""sha"": ""a07d145d10df35b933c1441dcbf42d3316b78ca5"", ""filename"": ""src/hashtable_seed.c"", ""status"": ""added"", ""additions"": 278, ""deletions"": 0, ""changes"": 278, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable_seed.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable_seed.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable_seed.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,278 @@\n+/* Generate sizeof(uint32_t) bytes of as random data as possible to seed\n+   the hash function.\n+*/\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#include <stdio.h>\n+#include <time.h>\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n+#ifdef HAVE_FCNTL_H\n+#include <fcntl.h>\n+#endif\n+\n+#ifdef HAVE_SCHED_H\n+#include <sched.h>\n+#endif\n+\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+\n+#ifdef HAVE_SYS_STAT_H\n+#include <sys/stat.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TIME_H\n+#include <sys/time.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TYPES_H\n+#include <sys/types.h>\n+#endif\n+\n+#if defined(_WIN32)\n+/* For _getpid() */\n+#include <process.h>\n+#endif\n+\n+#include \""jansson.h\""\n+\n+\n+static uint32_t buf_to_uint32(char *data) {\n+    size_t i;\n+    uint32_t result = 0;\n+\n+    for (i = 0; i < sizeof(uint32_t); i++)\n+        result = (result << 8) | (unsigned char)data[i];\n+\n+    return result;\n+}\n+\n+\n+\n+/* /dev/urandom */\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+static int seed_from_urandom(uint32_t *seed) {\n+    /* Use unbuffered I/O if we have open(), close() and read(). Otherwise\n+       fall back to fopen() */\n+\n+    char data[sizeof(uint32_t)];\n+    int ok;\n+\n+#if defined(HAVE_OPEN) && defined(HAVE_CLOSE) && defined(HAVE_READ)\n+    int urandom;\n+    urandom = open(\""/dev/urandom\"", O_RDONLY);\n+    if (urandom == -1)\n+        return 1;\n+\n+    ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);\n+    close(urandom);\n+#else\n+    FILE *urandom;\n+\n+    urandom = fopen(\""/dev/urandom\"", \""rb\"");\n+    if (!urandom)\n+        return 1;\n+\n+    ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);\n+    fclose(urandom);\n+#endif\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32(data);\n+    return 0;\n+}\n+#endif\n+\n+/* Windows Crypto API */\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+#include <windows.h>\n+#include <wincrypt.h>\n+\n+typedef BOOL (WINAPI *CRYPTACQUIRECONTEXTA)(HCRYPTPROV *phProv, LPCSTR pszContainer, LPCSTR pszProvider, DWORD dwProvType, DWORD dwFlags);\n+typedef BOOL (WINAPI *CRYPTGENRANDOM)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);\n+typedef BOOL (WINAPI *CRYPTRELEASECONTEXT)(HCRYPTPROV hProv, DWORD dwFlags);\n+\n+static int seed_from_windows_cryptoapi(uint32_t *seed)\n+{\n+    HINSTANCE hAdvAPI32 = NULL;\n+    CRYPTACQUIRECONTEXTA pCryptAcquireContext = NULL;\n+    CRYPTGENRANDOM pCryptGenRandom = NULL;\n+    CRYPTRELEASECONTEXT pCryptReleaseContext = NULL;\n+    HCRYPTPROV hCryptProv = 0;\n+    BYTE data[sizeof(uint32_t)];\n+    int ok;\n+\n+    hAdvAPI32 = GetModuleHandle(\""advapi32.dll\"");\n+    if(hAdvAPI32 == NULL)\n+        return 1;\n+\n+    pCryptAcquireContext = (CRYPTACQUIRECONTEXTA)GetProcAddress(hAdvAPI32, \""CryptAcquireContextA\"");\n+    if (!pCryptAcquireContext)\n+        return 1;\n+\n+    pCryptGenRandom = (CRYPTGENRANDOM)GetProcAddress(hAdvAPI32, \""CryptGenRandom\"");\n+    if (!pCryptGenRandom)\n+        return 1;\n+\n+    pCryptReleaseContext = (CRYPTRELEASECONTEXT)GetProcAddress(hAdvAPI32, \""CryptReleaseContext\"");\n+    if (!pCryptReleaseContext)\n+        return 1;\n+\n+    if (!pCryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))\n+        return 1;\n+\n+    ok = CryptGenRandom(hCryptProv, sizeof(uint32_t), data);\n+    pCryptReleaseContext(hCryptProv, 0);\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32((char *)data);\n+    return 0;\n+}\n+#endif\n+\n+/* gettimeofday() and getpid() */\n+static int seed_from_timestamp_and_pid(uint32_t *seed) {\n+#ifdef HAVE_GETTIMEOFDAY\n+    /* XOR of seconds and microseconds */\n+    struct timeval tv;\n+    gettimeofday(&tv, NULL);\n+    *seed = (uint32_t)tv.tv_sec ^ (uint32_t)tv.tv_usec;\n+#else\n+    /* Seconds only */\n+    *seed = (uint32_t)time(NULL);\n+#endif\n+\n+    /* XOR with PID for more randomness */\n+#if defined(_WIN32)\n+    *seed ^= (uint32_t)_getpid();\n+#elif defined(HAVE_GETPID)\n+    *seed ^= (uint32_t)getpid();\n+#endif\n+\n+    return 0;\n+}\n+\n+static uint32_t generate_seed() {\n+    uint32_t seed;\n+    int done = 0;\n+\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+    if (!done && seed_from_urandom(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+    if (!done && seed_from_windows_cryptoapi(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+    if (!done) {\n+        /* Fall back to timestamp and PID if no better randomness is\n+           available */\n+        seed_from_timestamp_and_pid(&seed);\n+    }\n+\n+    /* Make sure the seed is never zero */\n+    if (seed == 0)\n+        seed = 1;\n+\n+    return seed;\n+}\n+\n+\n+volatile uint32_t hashtable_seed = 0;\n+\n+#if defined(HAVE_ATOMIC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+static volatile char seed_initialized = 0;\n+\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (__atomic_test_and_set(&seed_initialized, __ATOMIC_RELAXED) == 0) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            __atomic_store_n(&hashtable_seed, new_seed, __ATOMIC_ACQ_REL);\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            } while(__atomic_load_n(&hashtable_seed, __ATOMIC_ACQUIRE) == 0);\n+        }\n+    }\n+}\n+#elif defined(HAVE_SYNC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0) {\n+            /* Explicit synchronization fences are not supported by the\n+               __sync builtins, so every thread getting here has to\n+               generate the seed value.\n+            */\n+            new_seed = generate_seed();\n+        }\n+\n+        do {\n+            if (__sync_bool_compare_and_swap(&hashtable_seed, 0, new_seed)) {\n+                /* We were the first to seed */\n+                break;\n+            } else {\n+                /* Wait for another thread to do the seeding */\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            }\n+        } while(hashtable_seed == 0);\n+    }\n+}\n+#elif defined(_WIN32)\n+static long seed_initialized = 0;\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (InterlockedIncrement(&seed_initialized) == 1) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            hashtable_seed = new_seed;\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+                SwitchToThread();\n+            } while (hashtable_seed == 0);\n+        }\n+    }\n+}\n+#else\n+/* Fall back to a thread-unsafe version */\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0)\n+            new_seed = generate_seed();\n+\n+        hashtable_seed = new_seed;\n+    }\n+}\n+#endif""}<_**next**_>{""sha"": ""19096d4201e6b13f8c56765116865c71f67e9696"", ""filename"": ""src/jansson.def"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.def"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.def"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/jansson.def?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -41,6 +41,7 @@ EXPORTS\n     json_object_iter_value\n     json_object_iter_set_new\n     json_object_key_to_iter\n+    json_object_seed\n     json_dumps\n     json_dumpf\n     json_dump_file""}<_**next**_>{""sha"": ""ea230852a629e55457fba2d00e3edd8a4ad4fcec"", ""filename"": ""src/jansson.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/jansson.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -126,6 +126,7 @@ typedef struct {\n \n /* getters, setters, manipulation */\n \n+void json_object_seed(size_t seed);\n size_t json_object_size(const json_t *object);\n json_t *json_object_get(const json_t *object, const char *key);\n int json_object_set_new(json_t *object, const char *key, json_t *value);""}<_**next**_>{""sha"": ""dc76138c940516e9590784825d28d040fd1a8b25"", ""filename"": ""src/lookup3.h"", ""status"": ""added"", ""additions"": 366, ""deletions"": 0, ""changes"": 366, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/lookup3.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/lookup3.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/lookup3.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,366 @@\n+/*\n+-------------------------------------------------------------------------------\n+lookup3.c, by Bob Jenkins, May 2006, Public Domain.\n+\n+These are functions for producing 32-bit hashes for hash table lookup.\n+hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final() \n+are externally useful functions.  Routines to test the hash are included \n+if SELF_TEST is defined.  You can use this free for any purpose.  It's in\n+the public domain.  It has no warranty.\n+\n+You probably want to use hashlittle().  hashlittle() and hashbig()\n+hash byte arrays.  hashlittle() is is faster than hashbig() on\n+little-endian machines.  Intel and AMD are little-endian machines.\n+On second thought, you probably want hashlittle2(), which is identical to\n+hashlittle() except it returns two 32-bit hashes for the price of one.  \n+You could implement hashbig2() if you wanted but I haven't bothered here.\n+\n+If you want to find a hash of, say, exactly 7 integers, do\n+  a = i1;  b = i2;  c = i3;\n+  mix(a,b,c);\n+  a += i4; b += i5; c += i6;\n+  mix(a,b,c);\n+  a += i7;\n+  final(a,b,c);\n+then use c as the hash value.  If you have a variable length array of\n+4-byte integers to hash, use hashword().  If you have a byte array (like\n+a character string), use hashlittle().  If you have several byte arrays, or\n+a mix of things, see the comments above hashlittle().  \n+\n+Why is this so big?  I read 12 bytes at a time into 3 4-byte integers, \n+then mix those integers.  This is fast (you can do a lot more thorough\n+mixing with 12*3 instructions on 3 integers than you can with 3 instructions\n+on 1 byte), but shoehorning those bytes into integers efficiently is messy.\n+-------------------------------------------------------------------------------\n+*/\n+\n+#include <stdlib.h>\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>     /* defines uint32_t etc */\n+#endif\n+\n+#ifdef HAVE_SYS_PARAM_H\n+#include <sys/param.h>  /* attempt to define endianness */\n+#endif\n+\n+#ifdef HAVE_ENDIAN_H\n+# include <endian.h>    /* attempt to define endianness */\n+#endif\n+\n+/*\n+ * My best guess at if you are big-endian or little-endian.  This may\n+ * need adjustment.\n+ */\n+#if (defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && \\\n+     __BYTE_ORDER == __LITTLE_ENDIAN) || \\\n+    (defined(i386) || defined(__i386__) || defined(__i486__) || \\\n+     defined(__i586__) || defined(__i686__) || defined(vax) || defined(MIPSEL))\n+# define HASH_LITTLE_ENDIAN 1\n+# define HASH_BIG_ENDIAN 0\n+#elif (defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && \\\n+       __BYTE_ORDER == __BIG_ENDIAN) || \\\n+      (defined(sparc) || defined(POWERPC) || defined(mc68000) || defined(sel))\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 1\n+#else\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 0\n+#endif\n+\n+#define hashsize(n) ((uint32_t)1<<(n))\n+#define hashmask(n) (hashsize(n)-1)\n+#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n+\n+/*\n+-------------------------------------------------------------------------------\n+mix -- mix 3 32-bit values reversibly.\n+\n+This is reversible, so any information in (a,b,c) before mix() is\n+still in (a,b,c) after mix().\n+\n+If four pairs of (a,b,c) inputs are run through mix(), or through\n+mix() in reverse, there are at least 32 bits of the output that\n+are sometimes the same for one pair and different for another pair.\n+This was tested for:\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+Some k values for my \""a-=c; a^=rot(c,k); c+=b;\"" arrangement that\n+satisfy this are\n+    4  6  8 16 19  4\n+    9 15  3 18 27 15\n+   14  9  3  7 17  3\n+Well, \""9 15 3 18 27 15\"" didn't quite get 32 bits diffing\n+for \""differ\"" defined as + with a one-bit base and a two-bit delta.  I\n+used http://burtleburtle.net/bob/hash/avalanche.html to choose \n+the operations, constants, and arrangements of the variables.\n+\n+This does not achieve avalanche.  There are input bits of (a,b,c)\n+that fail to affect some output bits of (a,b,c), especially of a.  The\n+most thoroughly mixed value is c, but it doesn't really even achieve\n+avalanche in c.\n+\n+This allows some parallelism.  Read-after-writes are good at doubling\n+the number of bits affected, so the goal of mixing pulls in the opposite\n+direction as the goal of parallelism.  I did what I could.  Rotates\n+seem to cost as much as shifts on every machine I could lay my hands\n+on, and rotates are much kinder to the top and bottom bits, so I used\n+rotates.\n+-------------------------------------------------------------------------------\n+*/\n+#define mix(a,b,c) \\\n+{ \\\n+  a -= c;  a ^= rot(c, 4);  c += b; \\\n+  b -= a;  b ^= rot(a, 6);  a += c; \\\n+  c -= b;  c ^= rot(b, 8);  b += a; \\\n+  a -= c;  a ^= rot(c,16);  c += b; \\\n+  b -= a;  b ^= rot(a,19);  a += c; \\\n+  c -= b;  c ^= rot(b, 4);  b += a; \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+final -- final mixing of 3 32-bit values (a,b,c) into c\n+\n+Pairs of (a,b,c) values differing in only a few bits will usually\n+produce values of c that look totally different.  This was tested for\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+These constants passed:\n+ 14 11 25 16 4 14 24\n+ 12 14 25 16 4 14 24\n+and these came close:\n+  4  8 15 26 3 22 24\n+ 10  8 15 26 3 22 24\n+ 11  8 15 26 3 22 24\n+-------------------------------------------------------------------------------\n+*/\n+#define final(a,b,c) \\\n+{ \\\n+  c ^= b; c -= rot(b,14); \\\n+  a ^= c; a -= rot(c,11); \\\n+  b ^= a; b -= rot(a,25); \\\n+  c ^= b; c -= rot(b,16); \\\n+  a ^= c; a -= rot(c,4);  \\\n+  b ^= a; b -= rot(a,14); \\\n+  c ^= b; c -= rot(b,24); \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+hashlittle() -- hash a variable-length key into a 32-bit value\n+  k       : the key (the unaligned variable-length array of bytes)\n+  length  : the length of the key, counting by bytes\n+  initval : can be any 4-byte value\n+Returns a 32-bit value.  Every bit of the key affects every bit of\n+the return value.  Two keys differing by one or two bits will have\n+totally different hash values.\n+\n+The best hash table sizes are powers of 2.  There is no need to do\n+mod a prime (mod is sooo slow!).  If you need less than 32 bits,\n+use a bitmask.  For example, if you need only 10 bits, do\n+  h = (h & hashmask(10));\n+In which case, the hash table should have hashsize(10) elements.\n+\n+If you are hashing n strings (uint8_t **)k, do it like this:\n+  for (i=0, h=0; i<n; ++i) h = hashlittle( k[i], len[i], h);\n+\n+By Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this\n+code any way you wish, private, educational, or commercial.  It's free.\n+\n+Use for hash table lookup, or anything where one collision in 2^^32 is\n+acceptable.  Do NOT use for cryptographic purposes.\n+-------------------------------------------------------------------------------\n+*/\n+\n+static uint32_t hashlittle(const void *key, size_t length, uint32_t initval)\n+{\n+  uint32_t a,b,c;                                          /* internal state */\n+  union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */\n+\n+  /* Set up the internal state */\n+  a = b = c = 0xdeadbeef + ((uint32_t)length) + initval;\n+\n+  u.ptr = key;\n+  if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0)) {\n+    const uint32_t *k = (const uint32_t *)key;         /* read 32-bit chunks */\n+\n+#ifdef VALGRIND\n+    const uint8_t  *k8;\n+#endif\n+\n+    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      b += k[1];\n+      c += k[2];\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 3;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    /* \n+     * \""k[2]&0xffffff\"" actually reads beyond the end of the string, but\n+     * then masks off the part it's not allowed to read.  Because the\n+     * string is aligned, the masked-off tail is in the same word as the\n+     * rest of the string.  Every machine with memory protection I've seen\n+     * does it on word boundaries, so is OK with this.  But VALGRIND will\n+     * still catch it and complain.  The masking trick does make the hash\n+     * noticably faster for short strings (like English words).\n+     */\n+#ifndef VALGRIND\n+\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n+    case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n+    case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n+    case 6 : b+=k[1]&0xffff; a+=k[0]; break;\n+    case 5 : b+=k[1]&0xff; a+=k[0]; break;\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=k[0]&0xffffff; break;\n+    case 2 : a+=k[0]&0xffff; break;\n+    case 1 : a+=k[0]&0xff; break;\n+    case 0 : return c;              /* zero length strings require no mixing */\n+    }\n+\n+#else /* make valgrind happy */\n+\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=((uint32_t)k8[10])<<16;  /* fall through */\n+    case 10: c+=((uint32_t)k8[9])<<8;    /* fall through */\n+    case 9 : c+=k8[8];                   /* fall through */\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;   /* fall through */\n+    case 6 : b+=((uint32_t)k8[5])<<8;    /* fall through */\n+    case 5 : b+=k8[4];                   /* fall through */\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;   /* fall through */\n+    case 2 : a+=((uint32_t)k8[1])<<8;    /* fall through */\n+    case 1 : a+=k8[0]; break;\n+    case 0 : return c;\n+    }\n+\n+#endif /* !valgrind */\n+\n+  } else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0)) {\n+    const uint16_t *k = (const uint16_t *)key;         /* read 16-bit chunks */\n+    const uint8_t  *k8;\n+\n+    /*--------------- all but last block: aligned reads and different mixing */\n+    while (length > 12)\n+    {\n+      a += k[0] + (((uint32_t)k[1])<<16);\n+      b += k[2] + (((uint32_t)k[3])<<16);\n+      c += k[4] + (((uint32_t)k[5])<<16);\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 6;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[4]+(((uint32_t)k[5])<<16);\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 11: c+=((uint32_t)k8[10])<<16;     /* fall through */\n+    case 10: c+=k[4];\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 9 : c+=k8[8];                      /* fall through */\n+    case 8 : b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;      /* fall through */\n+    case 6 : b+=k[2];\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 5 : b+=k8[4];                      /* fall through */\n+    case 4 : a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;      /* fall through */\n+    case 2 : a+=k[0];\n+             break;\n+    case 1 : a+=k8[0];\n+             break;\n+    case 0 : return c;                     /* zero length requires no mixing */\n+    }\n+\n+  } else {                        /* need to read the key one byte at a time */\n+    const uint8_t *k = (const uint8_t *)key;\n+\n+    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      a += ((uint32_t)k[1])<<8;\n+      a += ((uint32_t)k[2])<<16;\n+      a += ((uint32_t)k[3])<<24;\n+      b += k[4];\n+      b += ((uint32_t)k[5])<<8;\n+      b += ((uint32_t)k[6])<<16;\n+      b += ((uint32_t)k[7])<<24;\n+      c += k[8];\n+      c += ((uint32_t)k[9])<<8;\n+      c += ((uint32_t)k[10])<<16;\n+      c += ((uint32_t)k[11])<<24;\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 12;\n+    }\n+\n+    /*-------------------------------- last block: affect all 32 bits of (c) */\n+    switch(length)                   /* all the case statements fall through */\n+    {\n+    case 12: c+=((uint32_t)k[11])<<24;\n+    case 11: c+=((uint32_t)k[10])<<16;\n+    case 10: c+=((uint32_t)k[9])<<8;\n+    case 9 : c+=k[8];\n+    case 8 : b+=((uint32_t)k[7])<<24;\n+    case 7 : b+=((uint32_t)k[6])<<16;\n+    case 6 : b+=((uint32_t)k[5])<<8;\n+    case 5 : b+=k[4];\n+    case 4 : a+=((uint32_t)k[3])<<24;\n+    case 3 : a+=((uint32_t)k[2])<<16;\n+    case 2 : a+=((uint32_t)k[1])<<8;\n+    case 1 : a+=k[0];\n+             break;\n+    case 0 : return c;\n+    }\n+  }\n+\n+  final(a,b,c);\n+  return c;\n+}""}<_**next**_>{""sha"": ""b4f109143031b2481a0d32a332c88cc1cc96c688"", ""filename"": ""src/utf.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 16, ""changes"": 20, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/utf.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/utf.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/utf.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -10,23 +10,11 @@\n \n #ifdef HAVE_CONFIG_H\n #include <config.h>\n+#endif\n \n-#ifdef HAVE_INTTYPES_H\n-/* inttypes.h includes stdint.h in a standard environment, so there's\n-no need to include stdint.h separately. If inttypes.h doesn't define\n-int32_t, it's defined in config.h. */\n-#include <inttypes.h>\n-#endif /* HAVE_INTTYPES_H */\n-\n-#else /* !HAVE_CONFIG_H */\n-#ifdef _WIN32\n-typedef int int32_t;\n-#else /* !_WIN32 */\n-/* Assume a standard environment */\n-#include <inttypes.h>\n-#endif /* _WIN32 */\n-\n-#endif /* HAVE_CONFIG_H */\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n \n int utf8_encode(int codepoint, char *buffer, int *size);\n ""}<_**next**_>{""sha"": ""1b02d90aa885f1ede146bb2077d05c8bb9096565"", ""filename"": ""src/value.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/value.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/value.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/value.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -9,11 +9,19 @@\n #define _GNU_SOURCE\n #endif\n \n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stddef.h>\n #include <stdlib.h>\n #include <string.h>\n #include <math.h>\n \n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include \""jansson.h\""\n #include \""hashtable.h\""\n #include \""jansson_private.h\""\n@@ -36,11 +44,19 @@ static JSON_INLINE void json_init(json_t *json, json_type type)\n \n /*** object ***/\n \n+extern volatile uint32_t hashtable_seed;\n+\n json_t *json_object(void)\n {\n     json_object_t *object = jsonp_malloc(sizeof(json_object_t));\n     if(!object)\n         return NULL;\n+\n+    if (!hashtable_seed) {\n+        /* Autoseed */\n+        json_object_seed(0);\n+    }\n+\n     json_init(&object->json, JSON_OBJECT);\n \n     if(hashtable_init(&object->hashtable))""}<_**next**_>{""sha"": ""e2c54bd12bd7c22de7cc3533f010b26cc1c330b0"", ""filename"": ""test/bin/json_process.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 1, ""changes"": 16, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/bin/json_process.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/bin/json_process.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/bin/json_process.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -37,6 +37,8 @@ struct config {\n     int sort_keys;\n     int strip;\n     int use_env;\n+    int have_hashseed;\n+    int hashseed;\n } conf;\n \n #define l_isspace(c) ((c) == ' ' || (c) == '\\n' || (c) == '\\r' || (c) == '\\t')\n@@ -108,6 +110,12 @@ static void read_conf(FILE *conffile)\n             conf.sort_keys = atoi(val);\n         if (!strcmp(line, \""STRIP\""))\n             conf.strip = atoi(val);\n+        if (!strcmp(line, \""HASHSEED\"")) {\n+            conf.have_hashseed = 1;\n+            conf.hashseed = atoi(val);\n+        } else {\n+            conf.have_hashseed = 0;\n+        }\n     }\n \n     free(buffer);\n@@ -188,6 +196,9 @@ int use_conf(char *test_path)\n     if (conf.sort_keys)\n         flags |= JSON_SORT_KEYS;\n \n+    if (conf.have_hashseed)\n+        json_object_seed(conf.hashseed);\n+\n     if (conf.strip) {\n         /* Load to memory, strip leading and trailing whitespace */\n         buffer = loadfile(infile);\n@@ -265,7 +276,10 @@ int use_env()\n         flags |= JSON_PRESERVE_ORDER;\n \n     if(getenv_int(\""JSON_SORT_KEYS\""))\n-         flags |= JSON_SORT_KEYS;\n+        flags |= JSON_SORT_KEYS;\n+\n+    if(getenv(\""HASHSEED\""))\n+        json_object_seed(getenv_int(\""HASHSEED\""));\n \n     if(getenv_int(\""STRIP\"")) {\n         /* Load to memory, strip leading and trailing whitespace */""}<_**next**_>{""sha"": ""84b17466fd0a753b8cbd714d0236ed9072cdd536"", ""filename"": ""test/suites/api/test_memory_funcs.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_memory_funcs.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_memory_funcs.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/api/test_memory_funcs.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -24,13 +24,13 @@ static void create_and_free_complex_object()\n \n static void *my_malloc(size_t size)\n {\n-    malloc_called += 1;\n+    malloc_called = 1;\n     return malloc(size);\n }\n \n static void my_free(void *ptr)\n {\n-    free_called += 1;\n+    free_called = 1;\n     free(ptr);\n }\n \n@@ -39,7 +39,7 @@ static void test_simple()\n     json_set_alloc_funcs(my_malloc, my_free);\n     create_and_free_complex_object();\n \n-    if(malloc_called != 20 || free_called != 20)\n+    if(malloc_called != 1 || free_called != 1)\n         fail(\""Custom allocation failed\"");\n }\n ""}<_**next**_>{""sha"": ""92e5208224b75ab45d93672446279d598052a83e"", ""filename"": ""test/suites/api/test_object.c"", ""status"": ""modified"", ""additions"": 40, ""deletions"": 24, ""changes"": 64, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_object.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_object.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/api/test_object.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -249,7 +249,11 @@ static void test_set_nocheck()\n \n static void test_iterators()\n {\n+    int i;\n     json_t *object, *foo, *bar, *baz;\n+    const char *iter_keys[3];\n+    int have_key[3] = { 0, 0, 0 };\n+    json_t *iter_values[3];\n     void *iter;\n \n     if(json_object_iter(NULL))\n@@ -276,30 +280,50 @@ static void test_iterators()\n     iter = json_object_iter(object);\n     if(!iter)\n         fail(\""unable to get iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""a\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != foo)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[0] = json_object_iter_key(iter);\n+    iter_values[0] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""b\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != bar)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[1] = json_object_iter_key(iter);\n+    iter_values[1] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[2] = json_object_iter_key(iter);\n+    iter_values[2] = json_object_iter_value(iter);\n \n     if(json_object_iter_next(object, iter) != NULL)\n         fail(\""able to iterate over the end\"");\n \n+    /* Check that keys have correct values */\n+    for (i = 0; i < 3; i++) {\n+        if (strcmp(iter_keys[i], \""a\"") == 0) {\n+            if (iter_values[i] != foo)\n+                fail(\""wrong value for iter key a\"");\n+            else\n+                have_key[0] = 1;\n+        } else if (strcmp(iter_keys[i], \""b\"") == 0) {\n+            if (iter_values[i] != bar)\n+                fail(\""wrong value for iter key b\"");\n+            else\n+                have_key[1] = 1;\n+        } else if (strcmp(iter_keys[i], \""c\"") == 0) {\n+            if (iter_values[i] != baz)\n+                fail(\""wrong value for iter key c\"");\n+            else\n+                have_key[2] = 1;\n+        }\n+    }\n+\n+    /* Check that we got all keys */\n+    for(i = 0; i < 3; i++) {\n+        if(!have_key[i])\n+            fail(\""a key wasn't iterated over\"");\n+    }\n+\n     if(json_object_iter_at(object, \""foo\""))\n         fail(\""json_object_iter_at() succeeds for non-existent key\"");\n \n@@ -312,22 +336,14 @@ static void test_iterators()\n     if(json_object_iter_value(iter) != bar)\n         fail(\""iterating failed: wrong value\"");\n \n-    iter = json_object_iter_next(object, iter);\n-    if(!iter)\n-        fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\""iterating failed: wrong value\"");\n-\n-    if(json_object_iter_set(object, iter, bar))\n+    if(json_object_iter_set(object, iter, baz))\n         fail(\""unable to set value at iterator\"");\n \n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n+    if(strcmp(json_object_iter_key(iter), \""b\""))\n         fail(\""json_object_iter_key() fails after json_object_iter_set()\"");\n-    if(json_object_iter_value(iter) != bar)\n+    if(json_object_iter_value(iter) != baz)\n         fail(\""json_object_iter_value() fails after json_object_iter_set()\"");\n-    if(json_object_get(object, \""c\"") != bar)\n+    if(json_object_get(object, \""b\"") != baz)\n         fail(\""json_object_get() fails after json_object_iter_set()\"");\n \n     json_decref(object);""}<_**next**_>{""sha"": ""93cb33ddafeb9eef6ce7ad4709ce1bcbdf25b200"", ""filename"": ""test/suites/encoding-flags/compact-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/compact-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/compact-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/compact-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,2 +1,3 @@\n JSON_COMPACT=1\n-export JSON_COMPACT\n+HASHSEED=1\n+export JSON_COMPACT HASHSEED""}<_**next**_>{""sha"": ""c73acc1792963be8a5f41ff11f6e858506ada51d"", ""filename"": ""test/suites/encoding-flags/indent-compact-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-compact-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-compact-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/indent-compact-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,3 +1,4 @@\n JSON_INDENT=4\n JSON_COMPACT=1\n-export JSON_INDENT JSON_COMPACT\n+HASHSEED=1\n+export JSON_INDENT JSON_COMPACT HASHSEED""}<_**next**_>{""sha"": ""961558ca23ceca2ce6e4d07697f4018d8475f317"", ""filename"": ""test/suites/encoding-flags/indent-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/indent-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,2 +1,3 @@\n JSON_INDENT=4\n-export JSON_INDENT\n+HASHSEED=1\n+export JSON_INDENT HASHSEED""}<_**next**_>{""sha"": ""9120b03514ec614695c2d17841ba228b102c9db6"", ""filename"": ""test/suites/encoding-flags/object/env"", ""status"": ""added"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,2 @@\n+HASHSEED=1\n+export HASHSEED""}","static void read_conf(FILE *conffile)
{
    char *buffer, *line, *val;

    buffer = loadfile(conffile);
    for (line = strtok(buffer, ""\r\n""); line; line = strtok(NULL, ""\r\n"")) {
        if (!strncmp(line, ""export "", 7))
            continue;
        val = strchr(line, '=');
        if (!val) {
            printf(""invalid configuration line\n"");
            break;
        }
        *val++ = '\0';

        if (!strcmp(line, ""JSON_INDENT""))
            conf.indent = atoi(val);
        if (!strcmp(line, ""JSON_COMPACT""))
            conf.compact = atoi(val);
        if (!strcmp(line, ""JSON_ENSURE_ASCII""))
            conf.ensure_ascii = atoi(val);
        if (!strcmp(line, ""JSON_PRESERVE_ORDER""))
            conf.preserve_order = atoi(val);
        if (!strcmp(line, ""JSON_SORT_KEYS""))
             conf.sort_keys = atoi(val);
         if (!strcmp(line, ""STRIP""))
             conf.strip = atoi(val);
        if (!strcmp(line, ""HASHSEED"")) {
            conf.have_hashseed = 1;
            conf.hashseed = atoi(val);
        } else {
            conf.have_hashseed = 0;
        }
     }
 
     free(buffer);
}
","static void read_conf(FILE *conffile)
{
    char *buffer, *line, *val;

    buffer = loadfile(conffile);
    for (line = strtok(buffer, ""\r\n""); line; line = strtok(NULL, ""\r\n"")) {
        if (!strncmp(line, ""export "", 7))
            continue;
        val = strchr(line, '=');
        if (!val) {
            printf(""invalid configuration line\n"");
            break;
        }
        *val++ = '\0';

        if (!strcmp(line, ""JSON_INDENT""))
            conf.indent = atoi(val);
        if (!strcmp(line, ""JSON_COMPACT""))
            conf.compact = atoi(val);
        if (!strcmp(line, ""JSON_ENSURE_ASCII""))
            conf.ensure_ascii = atoi(val);
        if (!strcmp(line, ""JSON_PRESERVE_ORDER""))
            conf.preserve_order = atoi(val);
        if (!strcmp(line, ""JSON_SORT_KEYS""))
             conf.sort_keys = atoi(val);
         if (!strcmp(line, ""STRIP""))
             conf.strip = atoi(val);
     }
 
     free(buffer);
}
",C,"        if (!strcmp(line, ""HASHSEED"")) {
            conf.have_hashseed = 1;
            conf.hashseed = atoi(val);
        } else {
            conf.have_hashseed = 0;
        }
",,,"@@ -37,6 +37,8 @@ struct config {
     int sort_keys;
     int strip;
     int use_env;
+    int have_hashseed;
+    int hashseed;
 } conf;
 
 #define l_isspace(c) ((c) == ' ' || (c) == '\n' || (c) == '\r' || (c) == '\t')
@@ -108,6 +110,12 @@ static void read_conf(FILE *conffile)
             conf.sort_keys = atoi(val);
         if (!strcmp(line, ""STRIP""))
             conf.strip = atoi(val);
+        if (!strcmp(line, ""HASHSEED"")) {
+            conf.have_hashseed = 1;
+            conf.hashseed = atoi(val);
+        } else {
+            conf.have_hashseed = 0;
+        }
     }
 
     free(buffer);
@@ -188,6 +196,9 @@ int use_conf(char *test_path)
     if (conf.sort_keys)
         flags |= JSON_SORT_KEYS;
 
+    if (conf.have_hashseed)
+        json_object_seed(conf.hashseed);
+
     if (conf.strip) {
         /* Load to memory, strip leading and trailing whitespace */
         buffer = loadfile(infile);
@@ -265,7 +276,10 @@ int use_env()
         flags |= JSON_PRESERVE_ORDER;
 
     if(getenv_int(""JSON_SORT_KEYS""))
-         flags |= JSON_SORT_KEYS;
+        flags |= JSON_SORT_KEYS;
+
+    if(getenv(""HASHSEED""))
+        json_object_seed(getenv_int(""HASHSEED""));
 
     if(getenv_int(""STRIP"")) {
         /* Load to memory, strip leading and trailing whitespace */",jansson,8f80c2d83808150724d31793e6ade92749b1faa4,b9c588de3deb4efdd7b9ec44aa79335dba11fd6b,1,"static void read_conf(FILE *conffile)
{
    char *buffer, *line, *val;

    buffer = loadfile(conffile);
    for (line = strtok(buffer, ""\r\n""); line; line = strtok(NULL, ""\r\n"")) {
        if (!strncmp(line, ""export "", 7))
            continue;
        val = strchr(line, '=');
        if (!val) {
            printf(""invalid configuration line\n"");
            break;
        }
        *val++ = '\0';

        if (!strcmp(line, ""JSON_INDENT""))
            conf.indent = atoi(val);
        if (!strcmp(line, ""JSON_COMPACT""))
            conf.compact = atoi(val);
        if (!strcmp(line, ""JSON_ENSURE_ASCII""))
            conf.ensure_ascii = atoi(val);
        if (!strcmp(line, ""JSON_PRESERVE_ORDER""))
            conf.preserve_order = atoi(val);
        if (!strcmp(line, ""JSON_SORT_KEYS""))
             conf.sort_keys = atoi(val);
         if (!strcmp(line, ""STRIP""))
             conf.strip = atoi(val);
//fix_flaw_line_below:
//        if (!strcmp(line, ""HASHSEED"")) {
//fix_flaw_line_below:
//            conf.have_hashseed = 1;
//fix_flaw_line_below:
//            conf.hashseed = atoi(val);
//fix_flaw_line_below:
//        } else {
//fix_flaw_line_below:
//            conf.have_hashseed = 0;
//fix_flaw_line_below:
//        }
     }
 
     free(buffer);
}
"
1973,179709,,Remote,Not required,Partial,CVE-2013-6401,https://www.cvedetails.com/cve/CVE-2013-6401/,CWE-310,Low,,,,2014-03-20,5.0,"Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document.",2014-05-23,DoS ,3,https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4,8f80c2d83808150724d31793e6ade92749b1faa4,"CVE-2013-6401: Change hash function, randomize hashes

Thanks to Florian Weimer and Eric Sesterhenn for reporting, reviewing
and testing.",0,test/bin/json_process.c,"{""sha"": ""1043c9ae4c0bc0c1f6a5913783973383832ff14b"", ""filename"": ""CMakeLists.txt"", ""status"": ""modified"", ""additions"": 39, ""deletions"": 10, ""changes"": 49, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/CMakeLists.txt"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/CMakeLists.txt"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/CMakeLists.txt?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -52,6 +52,8 @@ project (jansson C)\n \n # Options\n OPTION (BUILD_SHARED_LIBS \""Build shared libraries.\"" OFF)\n+OPTION (USE_URANDOM \""Use /dev/urandom to seed the hash function.\"" ON)\n+OPTION (USE_WINDOWS_CRYPTOAPI \""Use CryptGenRandom to seed the hash function.\"" ON)\n \n if (MSVC)\n    # This option must match the settings used in your program, in particular if you\n@@ -85,12 +87,12 @@ set (JANSSON_SOVERSION 4)\n # for CheckFunctionKeywords\n set(CMAKE_MODULE_PATH \""${CMAKE_CURRENT_SOURCE_DIR}/cmake\"")\n \n+INCLUDE (CheckCSourceCompiles)\n include (CheckFunctionExists)\n include (CheckFunctionKeywords)\n include (CheckIncludeFiles)\n include (CheckTypeSize)\n \n-\n if (MSVC)\n    # Turn off Microsofts \""security\"" warnings.\n    add_definitions( \""/W3 /D_CRT_SECURE_NO_WARNINGS /wd4005 /wd4996 /nologo\"" )\n@@ -106,14 +108,25 @@ if (CMAKE_COMPILER_IS_GNUCC OR CMAKE_COMPILER_IS_GNUCXX)\n    set(CMAKE_C_FLAGS \""-fPIC\"")\n endif()\n \n-   \n+check_include_files (endian.h HAVE_ENDIAN_H)\n+check_include_files (fcntl.h HAVE_FCNTL_H)\n+check_include_files (sched.h HAVE_SCHED_H)\n+check_include_files (unistd.h HAVE_UNISTD_H)\n+check_include_files (sys/param.h HAVE_SYS_PARAM_H)\n+check_include_files (sys/stat.h HAVE_SYS_STAT_H)\n+check_include_files (sys/time.h HAVE_SYS_TIME_H)\n+check_include_files (sys/time.h HAVE_SYS_TYPES_H)\n+\n+check_function_exists (close HAVE_CLOSE)\n+check_function_exists (getpid HAVE_GETPID)\n+check_function_exists (gettimeofday HAVE_GETTIMEOFDAY)\n+check_function_exists (open HAVE_OPEN)\n+check_function_exists (read HAVE_READ)\n+check_function_exists (sched_yield HAVE_SCHED_YIELD)\n \n # Check for the int-type includes\n-check_include_files (sys/types.h HAVE_SYS_TYPES_H)\n-check_include_files (inttypes.h HAVE_INTTYPES_H)\n check_include_files (stdint.h HAVE_STDINT_H)\n \n-\n # Check our 64 bit integer sizes\n check_type_size (__int64 __INT64)\n check_type_size (int64_t INT64_T)\n@@ -124,17 +137,32 @@ check_type_size (int32_t INT32_T)\n check_type_size (__int32 __INT32)\n check_type_size (\""long\"" LONG_INT)\n check_type_size (\""int\"" INT)\n-\n if (HAVE_INT32_T)\n    set (JSON_INT32 int32_t)\n elseif (HAVE___INT32)\n    set (JSON_INT32 __int32)\n-elseif (HAVE_LONG AND (${LONG_INT} EQUAL 4))\n+elseif (HAVE_LONG_INT AND (${LONG_INT} EQUAL 4))\n    set (JSON_INT32 long)\n elseif (HAVE_INT AND (${INT} EQUAL 4))\n    set (JSON_INT32 int)\n else ()\n-   message (FATAL_ERROR \""Could not detect a valid 32 bit integer type\"")\n+   message (FATAL_ERROR \""Could not detect a valid 32-bit integer type\"")\n+endif ()\n+\n+check_type_size (uint32_t UINT32_T)\n+check_type_size (__uint32 __UINT32)\n+check_type_size (\""unsigned long\"" UNSIGNED_LONG_INT)\n+check_type_size (\""unsigned int\"" UNSIGNED_INT)\n+if (HAVE_UINT32_T)\n+   set (JSON_UINT32 uint32_t)\n+elseif (HAVE___UINT32)\n+   set (JSON_UINT32 __uint32)\n+elseif (HAVE_UNSIGNED_LONG_INT AND (${UNSIGNED_LONG_INT} EQUAL 4))\n+   set (JSON_UINT32 \""unsigned long\"")\n+elseif (HAVE_UNSIGNED_INT AND (${UNSIGNED_INT} EQUAL 4))\n+   set (JSON_UINT32 \""unsigned int\"")\n+else ()\n+   message (FATAL_ERROR \""Could not detect a valid unsigned 32-bit integer type\"")\n endif ()\n \n # Check for ssize_t and SSIZE_T existance.\n@@ -206,11 +234,9 @@ else ()\n    set (JSON_HAVE_LOCALECONV 0)\n endif ()\n \n-\n # check if we have setlocale\n check_function_exists (setlocale HAVE_SETLOCALE)\n \n-\n # Check what the inline keyword is.\n # Note that the original JSON_INLINE was always set to just 'inline', so this goes further.\n check_function_keywords(\""inline\"")\n@@ -238,6 +264,9 @@ elseif (HAVE__SNPRINTF)\n    set (JSON_SNPRINTF _snprintf)\n endif ()\n \n+check_c_source_compiles (\""int main() { unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1); return 0; } \"" HAVE_SYNC_BUILTINS)\n+check_c_source_compiles (\""int main() { char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE); return 0; }\"" HAVE_ATOMIC_BUILTINS)\n+\n # Create pkg-conf file.\n # (We use the same files as ./configure does, so we\n #  have to defined the same variables used there).""}<_**next**_>{""sha"": ""b27b9a3a849e94686aa648c1ec4d1bd4c8e35445"", ""filename"": ""cmake/config.h.cmake"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 21, ""changes"": 46, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/cmake/config.h.cmake"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/cmake/config.h.cmake"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/cmake/config.h.cmake?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,35 +1,36 @@\n-/* Reduced down to the defines that are actually used in the code */\n-\n-/* Define to 1 if you have the <inttypes.h> (and friends) header file. */\n-#cmakedefine HAVE_INTTYPES_H 1\n-#cmakedefine HAVE_STDINT_H 1\n+#cmakedefine HAVE_ENDIAN_H 1\n+#cmakedefine HAVE_FCNTL_H 1\n+#cmakedefine HAVE_SCHED_H 1\n+#cmakedefine HAVE_UNISTD_H 1\n+#cmakedefine HAVE_SYS_PARAM_H 1\n+#cmakedefine HAVE_SYS_STAT_H 1\n+#cmakedefine HAVE_SYS_TIME_H 1\n #cmakedefine HAVE_SYS_TYPES_H 1\n+#cmakedefine HAVE_STDINT_H 1\n \n-/* We must include this here, as in (eg) utf.h it will want to use\n-   the integer type, which in MSVC2010 will be in stdint.h\n-   (there is no inttypes.h in MSVC2010) */\n-#if defined(HAVE_STDINT_H)\n-#  include <stdint.h>\n-#elif defined(HAVE_INTTYPES_H)\n-#  include <inttypes.h>\n-#elif defined(HAVE_SYS_TYPES_H)\n-#  include <sys/types.h>\n-#endif\n+#cmakedefine HAVE_CLOSE 1\n+#cmakedefine HAVE_GETPID 1\n+#cmakedefine HAVE_GETTIMEOFDAY 1\n+#cmakedefine HAVE_OPEN 1\n+#cmakedefine HAVE_READ 1\n+#cmakedefine HAVE_SCHED_YIELD 1\n \n-/* Define to 1 if you have the <locale.h> header file. */\n-#cmakedefine HAVE_LOCALE_H 1\n+#cmakedefine HAVE_SYNC_BUILTINS 1\n+#cmakedefine HAVE_ATOMIC_BUILTINS 1\n \n-/* Define to 1 if you have the 'setlocale' function. */\n+#cmakedefine HAVE_LOCALE_H 1\n #cmakedefine HAVE_SETLOCALE 1\n \n-/* Define to the type of a signed integer type of width exactly 32 bits if\n-   such a type exists and the standard includes do not define it. */\n #cmakedefine HAVE_INT32_T 1\n-\n #ifndef HAVE_INT32_T\n #  define int32_t @JSON_INT32@\n #endif\n \n+#cmakedefine HAVE_UINT32_T 1\n+#ifndef HAVE_UINT32_T\n+#  define uint32_t @JSON_UINT32@\n+#endif\n+\n #cmakedefine HAVE_SSIZE_T 1\n \n #ifndef HAVE_SSIZE_T\n@@ -43,3 +44,6 @@\n #endif\n \n #cmakedefine HAVE_VSNPRINTF\n+\n+#cmakedefine USE_URANDOM 1\n+#cmakedefine USE_WINDOWS_CRYPTOAPI 1""}<_**next**_>{""sha"": ""113cb85e17a15f2fac83b528fe1880bc99481ccb"", ""filename"": ""configure.ac"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 2, ""changes"": 50, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/configure.ac"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/configure.ac"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/configure.ac?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -14,10 +14,11 @@ AM_CONDITIONAL([GCC], [test x$GCC = xyes])\n # Checks for libraries.\n \n # Checks for header files.\n-AC_CHECK_HEADERS([locale.h])\n+AC_CHECK_HEADERS([endian.h fcntl.h locale.h sched.h unistd.h sys/param.h sys/stat.h sys/time.h sys/types.h])\n \n # Checks for typedefs, structures, and compiler characteristics.\n AC_TYPE_INT32_T\n+AC_TYPE_UINT32_T\n AC_TYPE_LONG_LONG_INT\n \n AC_C_INLINE\n@@ -29,7 +30,31 @@ esac\n AC_SUBST([json_inline])\n \n # Checks for library functions.\n-AC_CHECK_FUNCS([strtoll localeconv])\n+AC_CHECK_FUNCS([close getpid gettimeofday localeconv open read sched_yield strtoll])\n+\n+AC_MSG_CHECKING([for gcc __sync builtins])\n+have_sync_builtins=no\n+AC_TRY_LINK(\n+  [], [unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1);],\n+  [have_sync_builtins=yes],\n+)\n+if test \""x$have_sync_builtins\"" = \""xyes\""; then\n+  AC_DEFINE([HAVE_SYNC_BUILTINS], [1],\n+    [Define to 1 if gcc's __sync builtins are available])\n+fi\n+AC_MSG_RESULT([$have_sync_builtins])\n+\n+AC_MSG_CHECKING([for gcc __atomic builtins])\n+have_atomic_builtins=no\n+AC_TRY_LINK(\n+  [], [char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE);],\n+  [have_atomic_builtins=yes],\n+)\n+if test \""x$have_atomic_builtins\"" = \""xyes\""; then\n+  AC_DEFINE([HAVE_ATOMIC_BUILTINS], [1],\n+    [Define to 1 if gcc's __atomic builtins are available])\n+fi\n+AC_MSG_RESULT([$have_atomic_builtins])\n \n case \""$ac_cv_type_long_long_int$ac_cv_func_strtoll\"" in\n      yesyes) json_have_long_long=1;;\n@@ -43,6 +68,27 @@ case \""$ac_cv_header_locale_h$ac_cv_func_localeconv\"" in\n esac\n AC_SUBST([json_have_localeconv])\n \n+# Features\n+AC_ARG_ENABLE([urandom],\n+  [AS_HELP_STRING([--disable-urandom],\n+    [Don't use /dev/urandom to seed the hash function])],\n+  [use_urandom=$enableval], [use_urandom=yes])\n+\n+if test \""x$use_urandom\"" = xyes; then\n+AC_DEFINE([USE_URANDOM], [1],\n+  [Define to 1 if /dev/urandom should be used for seeding the hash function])\n+fi\n+\n+AC_ARG_ENABLE([windows-cryptoapi],\n+  [AS_HELP_STRING([--disable-windows-cryptoapi],\n+    [Don't use CryptGenRandom to seed the hash function])],\n+  [use_windows_cryptoapi=$enableval], [use_windows_cryptoapi=yes])\n+\n+if test \""x$use_windows_cryptoapi\"" = xyes; then\n+AC_DEFINE([USE_WINDOWS_CRYPTOAPI], [1],\n+  [Define to 1 if CryptGenRandom should be used for seeding the hash function])\n+fi\n+\n AC_CONFIG_FILES([\n         jansson.pc\n         Makefile""}<_**next**_>{""sha"": ""b4af562e84b5ed9dba1107af7d1768dcdb0b9a95"", ""filename"": ""src/Makefile.am"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/Makefile.am"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/Makefile.am?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -8,6 +8,7 @@ libjansson_la_SOURCES = \\\n \terror.c \\\n \thashtable.c \\\n \thashtable.h \\\n+\thashtable_seed.c \\\n \tjansson_private.h \\\n \tload.c \\\n \tmemory.c \\""}<_**next**_>{""sha"": ""abd4bf11fe7a393fcf3d533b952aa8b5efa4ea30"", ""filename"": ""src/hashtable.c"", ""status"": ""modified"", ""additions"": 26, ""deletions"": 41, ""changes"": 67, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -5,8 +5,17 @@\n  * it under the terms of the MIT license. See LICENSE for details.\n  */\n \n+#if HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stdlib.h>\n #include <string.h>\n+\n+#if HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include <jansson_config.h>   /* for JSON_INLINE */\n #include \""jansson_private.h\""  /* for container_of() */\n #include \""hashtable.h\""\n@@ -15,24 +24,13 @@ typedef struct hashtable_list list_t;\n typedef struct hashtable_pair pair_t;\n typedef struct hashtable_bucket bucket_t;\n \n-#define list_to_pair(list_)  container_of(list_, pair_t, list)\n-\n-/* From http://www.cse.yorku.ca/~oz/hash.html */\n-static size_t hash_str(const void *ptr)\n-{\n-    const char *str = (const char *)ptr;\n-\n-    size_t hash = 5381;\n-    size_t c;\n+extern volatile uint32_t hashtable_seed;\n \n-    while((c = (size_t)*str))\n-    {\n-        hash = ((hash << 5) + hash) + c;\n-        str++;\n-    }\n+/* Implementation of the hash function */\n+#include \""lookup3.h\""\n \n-    return hash;\n-}\n+#define list_to_pair(list_)  container_of(list_, pair_t, list)\n+#define hash_str(key)        ((size_t)hashlittle((key), strlen(key), hashtable_seed))\n \n static JSON_INLINE void list_init(list_t *list)\n {\n@@ -74,19 +72,6 @@ static void insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket,\n     }\n }\n \n-static const size_t primes[] = {\n-    5, 13, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,\n-    49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,\n-    12582917, 25165843, 50331653, 100663319, 201326611, 402653189,\n-    805306457, 1610612741\n-};\n-\n-static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)\n-{\n-    return primes[hashtable->num_buckets];\n-}\n-\n-\n static pair_t *hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket,\n                                    const char *key, size_t hash)\n {\n@@ -120,7 +105,7 @@ static int hashtable_do_del(hashtable_t *hashtable,\n     bucket_t *bucket;\n     size_t index;\n \n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n@@ -167,14 +152,14 @@ static int hashtable_do_rehash(hashtable_t *hashtable)\n \n     jsonp_free(hashtable->buckets);\n \n-    hashtable->num_buckets++;\n-    new_size = num_buckets(hashtable);\n+    hashtable->order++;\n+    new_size = hashsize(hashtable->order);\n \n     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -199,14 +184,14 @@ int hashtable_init(hashtable_t *hashtable)\n     size_t i;\n \n     hashtable->size = 0;\n-    hashtable->num_buckets = 0;  /* index to primes[] */\n-    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));\n+    hashtable->order = 3;\n+    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n     list_init(&hashtable->list);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -230,12 +215,12 @@ int hashtable_set(hashtable_t *hashtable,\n     size_t hash, index;\n \n     /* rehash if the load ratio exceeds 1 */\n-    if(hashtable->size >= num_buckets(hashtable))\n+    if(hashtable->size >= hashsize(hashtable->order))\n         if(hashtable_do_rehash(hashtable))\n             return -1;\n \n     hash = hash_str(key);\n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n \n@@ -273,7 +258,7 @@ void *hashtable_get(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)\n@@ -294,7 +279,7 @@ void hashtable_clear(hashtable_t *hashtable)\n \n     hashtable_do_clear(hashtable);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -316,7 +301,7 @@ void *hashtable_iter_at(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)""}<_**next**_>{""sha"": ""469c6ecd869c4698f650fa81983bb3ee03d47fab"", ""filename"": ""src/hashtable.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -32,14 +32,15 @@ struct hashtable_bucket {\n typedef struct hashtable {\n     size_t size;\n     struct hashtable_bucket *buckets;\n-    size_t num_buckets;  /* index to primes[] */\n+    size_t order;  /* hashtable has pow(2, order) buckets */\n     struct hashtable_list list;\n } hashtable_t;\n \n \n #define hashtable_key_to_iter(key_) \\\n     (&(container_of(key_, struct hashtable_pair, key)->list))\n \n+\n /**\n  * hashtable_init - Initialize a hashtable object\n  *""}<_**next**_>{""sha"": ""a07d145d10df35b933c1441dcbf42d3316b78ca5"", ""filename"": ""src/hashtable_seed.c"", ""status"": ""added"", ""additions"": 278, ""deletions"": 0, ""changes"": 278, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable_seed.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable_seed.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable_seed.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,278 @@\n+/* Generate sizeof(uint32_t) bytes of as random data as possible to seed\n+   the hash function.\n+*/\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#include <stdio.h>\n+#include <time.h>\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n+#ifdef HAVE_FCNTL_H\n+#include <fcntl.h>\n+#endif\n+\n+#ifdef HAVE_SCHED_H\n+#include <sched.h>\n+#endif\n+\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+\n+#ifdef HAVE_SYS_STAT_H\n+#include <sys/stat.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TIME_H\n+#include <sys/time.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TYPES_H\n+#include <sys/types.h>\n+#endif\n+\n+#if defined(_WIN32)\n+/* For _getpid() */\n+#include <process.h>\n+#endif\n+\n+#include \""jansson.h\""\n+\n+\n+static uint32_t buf_to_uint32(char *data) {\n+    size_t i;\n+    uint32_t result = 0;\n+\n+    for (i = 0; i < sizeof(uint32_t); i++)\n+        result = (result << 8) | (unsigned char)data[i];\n+\n+    return result;\n+}\n+\n+\n+\n+/* /dev/urandom */\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+static int seed_from_urandom(uint32_t *seed) {\n+    /* Use unbuffered I/O if we have open(), close() and read(). Otherwise\n+       fall back to fopen() */\n+\n+    char data[sizeof(uint32_t)];\n+    int ok;\n+\n+#if defined(HAVE_OPEN) && defined(HAVE_CLOSE) && defined(HAVE_READ)\n+    int urandom;\n+    urandom = open(\""/dev/urandom\"", O_RDONLY);\n+    if (urandom == -1)\n+        return 1;\n+\n+    ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);\n+    close(urandom);\n+#else\n+    FILE *urandom;\n+\n+    urandom = fopen(\""/dev/urandom\"", \""rb\"");\n+    if (!urandom)\n+        return 1;\n+\n+    ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);\n+    fclose(urandom);\n+#endif\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32(data);\n+    return 0;\n+}\n+#endif\n+\n+/* Windows Crypto API */\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+#include <windows.h>\n+#include <wincrypt.h>\n+\n+typedef BOOL (WINAPI *CRYPTACQUIRECONTEXTA)(HCRYPTPROV *phProv, LPCSTR pszContainer, LPCSTR pszProvider, DWORD dwProvType, DWORD dwFlags);\n+typedef BOOL (WINAPI *CRYPTGENRANDOM)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);\n+typedef BOOL (WINAPI *CRYPTRELEASECONTEXT)(HCRYPTPROV hProv, DWORD dwFlags);\n+\n+static int seed_from_windows_cryptoapi(uint32_t *seed)\n+{\n+    HINSTANCE hAdvAPI32 = NULL;\n+    CRYPTACQUIRECONTEXTA pCryptAcquireContext = NULL;\n+    CRYPTGENRANDOM pCryptGenRandom = NULL;\n+    CRYPTRELEASECONTEXT pCryptReleaseContext = NULL;\n+    HCRYPTPROV hCryptProv = 0;\n+    BYTE data[sizeof(uint32_t)];\n+    int ok;\n+\n+    hAdvAPI32 = GetModuleHandle(\""advapi32.dll\"");\n+    if(hAdvAPI32 == NULL)\n+        return 1;\n+\n+    pCryptAcquireContext = (CRYPTACQUIRECONTEXTA)GetProcAddress(hAdvAPI32, \""CryptAcquireContextA\"");\n+    if (!pCryptAcquireContext)\n+        return 1;\n+\n+    pCryptGenRandom = (CRYPTGENRANDOM)GetProcAddress(hAdvAPI32, \""CryptGenRandom\"");\n+    if (!pCryptGenRandom)\n+        return 1;\n+\n+    pCryptReleaseContext = (CRYPTRELEASECONTEXT)GetProcAddress(hAdvAPI32, \""CryptReleaseContext\"");\n+    if (!pCryptReleaseContext)\n+        return 1;\n+\n+    if (!pCryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))\n+        return 1;\n+\n+    ok = CryptGenRandom(hCryptProv, sizeof(uint32_t), data);\n+    pCryptReleaseContext(hCryptProv, 0);\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32((char *)data);\n+    return 0;\n+}\n+#endif\n+\n+/* gettimeofday() and getpid() */\n+static int seed_from_timestamp_and_pid(uint32_t *seed) {\n+#ifdef HAVE_GETTIMEOFDAY\n+    /* XOR of seconds and microseconds */\n+    struct timeval tv;\n+    gettimeofday(&tv, NULL);\n+    *seed = (uint32_t)tv.tv_sec ^ (uint32_t)tv.tv_usec;\n+#else\n+    /* Seconds only */\n+    *seed = (uint32_t)time(NULL);\n+#endif\n+\n+    /* XOR with PID for more randomness */\n+#if defined(_WIN32)\n+    *seed ^= (uint32_t)_getpid();\n+#elif defined(HAVE_GETPID)\n+    *seed ^= (uint32_t)getpid();\n+#endif\n+\n+    return 0;\n+}\n+\n+static uint32_t generate_seed() {\n+    uint32_t seed;\n+    int done = 0;\n+\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+    if (!done && seed_from_urandom(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+    if (!done && seed_from_windows_cryptoapi(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+    if (!done) {\n+        /* Fall back to timestamp and PID if no better randomness is\n+           available */\n+        seed_from_timestamp_and_pid(&seed);\n+    }\n+\n+    /* Make sure the seed is never zero */\n+    if (seed == 0)\n+        seed = 1;\n+\n+    return seed;\n+}\n+\n+\n+volatile uint32_t hashtable_seed = 0;\n+\n+#if defined(HAVE_ATOMIC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+static volatile char seed_initialized = 0;\n+\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (__atomic_test_and_set(&seed_initialized, __ATOMIC_RELAXED) == 0) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            __atomic_store_n(&hashtable_seed, new_seed, __ATOMIC_ACQ_REL);\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            } while(__atomic_load_n(&hashtable_seed, __ATOMIC_ACQUIRE) == 0);\n+        }\n+    }\n+}\n+#elif defined(HAVE_SYNC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0) {\n+            /* Explicit synchronization fences are not supported by the\n+               __sync builtins, so every thread getting here has to\n+               generate the seed value.\n+            */\n+            new_seed = generate_seed();\n+        }\n+\n+        do {\n+            if (__sync_bool_compare_and_swap(&hashtable_seed, 0, new_seed)) {\n+                /* We were the first to seed */\n+                break;\n+            } else {\n+                /* Wait for another thread to do the seeding */\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            }\n+        } while(hashtable_seed == 0);\n+    }\n+}\n+#elif defined(_WIN32)\n+static long seed_initialized = 0;\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (InterlockedIncrement(&seed_initialized) == 1) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            hashtable_seed = new_seed;\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+                SwitchToThread();\n+            } while (hashtable_seed == 0);\n+        }\n+    }\n+}\n+#else\n+/* Fall back to a thread-unsafe version */\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0)\n+            new_seed = generate_seed();\n+\n+        hashtable_seed = new_seed;\n+    }\n+}\n+#endif""}<_**next**_>{""sha"": ""19096d4201e6b13f8c56765116865c71f67e9696"", ""filename"": ""src/jansson.def"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.def"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.def"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/jansson.def?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -41,6 +41,7 @@ EXPORTS\n     json_object_iter_value\n     json_object_iter_set_new\n     json_object_key_to_iter\n+    json_object_seed\n     json_dumps\n     json_dumpf\n     json_dump_file""}<_**next**_>{""sha"": ""ea230852a629e55457fba2d00e3edd8a4ad4fcec"", ""filename"": ""src/jansson.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/jansson.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -126,6 +126,7 @@ typedef struct {\n \n /* getters, setters, manipulation */\n \n+void json_object_seed(size_t seed);\n size_t json_object_size(const json_t *object);\n json_t *json_object_get(const json_t *object, const char *key);\n int json_object_set_new(json_t *object, const char *key, json_t *value);""}<_**next**_>{""sha"": ""dc76138c940516e9590784825d28d040fd1a8b25"", ""filename"": ""src/lookup3.h"", ""status"": ""added"", ""additions"": 366, ""deletions"": 0, ""changes"": 366, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/lookup3.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/lookup3.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/lookup3.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,366 @@\n+/*\n+-------------------------------------------------------------------------------\n+lookup3.c, by Bob Jenkins, May 2006, Public Domain.\n+\n+These are functions for producing 32-bit hashes for hash table lookup.\n+hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final() \n+are externally useful functions.  Routines to test the hash are included \n+if SELF_TEST is defined.  You can use this free for any purpose.  It's in\n+the public domain.  It has no warranty.\n+\n+You probably want to use hashlittle().  hashlittle() and hashbig()\n+hash byte arrays.  hashlittle() is is faster than hashbig() on\n+little-endian machines.  Intel and AMD are little-endian machines.\n+On second thought, you probably want hashlittle2(), which is identical to\n+hashlittle() except it returns two 32-bit hashes for the price of one.  \n+You could implement hashbig2() if you wanted but I haven't bothered here.\n+\n+If you want to find a hash of, say, exactly 7 integers, do\n+  a = i1;  b = i2;  c = i3;\n+  mix(a,b,c);\n+  a += i4; b += i5; c += i6;\n+  mix(a,b,c);\n+  a += i7;\n+  final(a,b,c);\n+then use c as the hash value.  If you have a variable length array of\n+4-byte integers to hash, use hashword().  If you have a byte array (like\n+a character string), use hashlittle().  If you have several byte arrays, or\n+a mix of things, see the comments above hashlittle().  \n+\n+Why is this so big?  I read 12 bytes at a time into 3 4-byte integers, \n+then mix those integers.  This is fast (you can do a lot more thorough\n+mixing with 12*3 instructions on 3 integers than you can with 3 instructions\n+on 1 byte), but shoehorning those bytes into integers efficiently is messy.\n+-------------------------------------------------------------------------------\n+*/\n+\n+#include <stdlib.h>\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>     /* defines uint32_t etc */\n+#endif\n+\n+#ifdef HAVE_SYS_PARAM_H\n+#include <sys/param.h>  /* attempt to define endianness */\n+#endif\n+\n+#ifdef HAVE_ENDIAN_H\n+# include <endian.h>    /* attempt to define endianness */\n+#endif\n+\n+/*\n+ * My best guess at if you are big-endian or little-endian.  This may\n+ * need adjustment.\n+ */\n+#if (defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && \\\n+     __BYTE_ORDER == __LITTLE_ENDIAN) || \\\n+    (defined(i386) || defined(__i386__) || defined(__i486__) || \\\n+     defined(__i586__) || defined(__i686__) || defined(vax) || defined(MIPSEL))\n+# define HASH_LITTLE_ENDIAN 1\n+# define HASH_BIG_ENDIAN 0\n+#elif (defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && \\\n+       __BYTE_ORDER == __BIG_ENDIAN) || \\\n+      (defined(sparc) || defined(POWERPC) || defined(mc68000) || defined(sel))\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 1\n+#else\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 0\n+#endif\n+\n+#define hashsize(n) ((uint32_t)1<<(n))\n+#define hashmask(n) (hashsize(n)-1)\n+#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n+\n+/*\n+-------------------------------------------------------------------------------\n+mix -- mix 3 32-bit values reversibly.\n+\n+This is reversible, so any information in (a,b,c) before mix() is\n+still in (a,b,c) after mix().\n+\n+If four pairs of (a,b,c) inputs are run through mix(), or through\n+mix() in reverse, there are at least 32 bits of the output that\n+are sometimes the same for one pair and different for another pair.\n+This was tested for:\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+Some k values for my \""a-=c; a^=rot(c,k); c+=b;\"" arrangement that\n+satisfy this are\n+    4  6  8 16 19  4\n+    9 15  3 18 27 15\n+   14  9  3  7 17  3\n+Well, \""9 15 3 18 27 15\"" didn't quite get 32 bits diffing\n+for \""differ\"" defined as + with a one-bit base and a two-bit delta.  I\n+used http://burtleburtle.net/bob/hash/avalanche.html to choose \n+the operations, constants, and arrangements of the variables.\n+\n+This does not achieve avalanche.  There are input bits of (a,b,c)\n+that fail to affect some output bits of (a,b,c), especially of a.  The\n+most thoroughly mixed value is c, but it doesn't really even achieve\n+avalanche in c.\n+\n+This allows some parallelism.  Read-after-writes are good at doubling\n+the number of bits affected, so the goal of mixing pulls in the opposite\n+direction as the goal of parallelism.  I did what I could.  Rotates\n+seem to cost as much as shifts on every machine I could lay my hands\n+on, and rotates are much kinder to the top and bottom bits, so I used\n+rotates.\n+-------------------------------------------------------------------------------\n+*/\n+#define mix(a,b,c) \\\n+{ \\\n+  a -= c;  a ^= rot(c, 4);  c += b; \\\n+  b -= a;  b ^= rot(a, 6);  a += c; \\\n+  c -= b;  c ^= rot(b, 8);  b += a; \\\n+  a -= c;  a ^= rot(c,16);  c += b; \\\n+  b -= a;  b ^= rot(a,19);  a += c; \\\n+  c -= b;  c ^= rot(b, 4);  b += a; \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+final -- final mixing of 3 32-bit values (a,b,c) into c\n+\n+Pairs of (a,b,c) values differing in only a few bits will usually\n+produce values of c that look totally different.  This was tested for\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+These constants passed:\n+ 14 11 25 16 4 14 24\n+ 12 14 25 16 4 14 24\n+and these came close:\n+  4  8 15 26 3 22 24\n+ 10  8 15 26 3 22 24\n+ 11  8 15 26 3 22 24\n+-------------------------------------------------------------------------------\n+*/\n+#define final(a,b,c) \\\n+{ \\\n+  c ^= b; c -= rot(b,14); \\\n+  a ^= c; a -= rot(c,11); \\\n+  b ^= a; b -= rot(a,25); \\\n+  c ^= b; c -= rot(b,16); \\\n+  a ^= c; a -= rot(c,4);  \\\n+  b ^= a; b -= rot(a,14); \\\n+  c ^= b; c -= rot(b,24); \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+hashlittle() -- hash a variable-length key into a 32-bit value\n+  k       : the key (the unaligned variable-length array of bytes)\n+  length  : the length of the key, counting by bytes\n+  initval : can be any 4-byte value\n+Returns a 32-bit value.  Every bit of the key affects every bit of\n+the return value.  Two keys differing by one or two bits will have\n+totally different hash values.\n+\n+The best hash table sizes are powers of 2.  There is no need to do\n+mod a prime (mod is sooo slow!).  If you need less than 32 bits,\n+use a bitmask.  For example, if you need only 10 bits, do\n+  h = (h & hashmask(10));\n+In which case, the hash table should have hashsize(10) elements.\n+\n+If you are hashing n strings (uint8_t **)k, do it like this:\n+  for (i=0, h=0; i<n; ++i) h = hashlittle( k[i], len[i], h);\n+\n+By Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this\n+code any way you wish, private, educational, or commercial.  It's free.\n+\n+Use for hash table lookup, or anything where one collision in 2^^32 is\n+acceptable.  Do NOT use for cryptographic purposes.\n+-------------------------------------------------------------------------------\n+*/\n+\n+static uint32_t hashlittle(const void *key, size_t length, uint32_t initval)\n+{\n+  uint32_t a,b,c;                                          /* internal state */\n+  union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */\n+\n+  /* Set up the internal state */\n+  a = b = c = 0xdeadbeef + ((uint32_t)length) + initval;\n+\n+  u.ptr = key;\n+  if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0)) {\n+    const uint32_t *k = (const uint32_t *)key;         /* read 32-bit chunks */\n+\n+#ifdef VALGRIND\n+    const uint8_t  *k8;\n+#endif\n+\n+    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      b += k[1];\n+      c += k[2];\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 3;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    /* \n+     * \""k[2]&0xffffff\"" actually reads beyond the end of the string, but\n+     * then masks off the part it's not allowed to read.  Because the\n+     * string is aligned, the masked-off tail is in the same word as the\n+     * rest of the string.  Every machine with memory protection I've seen\n+     * does it on word boundaries, so is OK with this.  But VALGRIND will\n+     * still catch it and complain.  The masking trick does make the hash\n+     * noticably faster for short strings (like English words).\n+     */\n+#ifndef VALGRIND\n+\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n+    case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n+    case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n+    case 6 : b+=k[1]&0xffff; a+=k[0]; break;\n+    case 5 : b+=k[1]&0xff; a+=k[0]; break;\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=k[0]&0xffffff; break;\n+    case 2 : a+=k[0]&0xffff; break;\n+    case 1 : a+=k[0]&0xff; break;\n+    case 0 : return c;              /* zero length strings require no mixing */\n+    }\n+\n+#else /* make valgrind happy */\n+\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=((uint32_t)k8[10])<<16;  /* fall through */\n+    case 10: c+=((uint32_t)k8[9])<<8;    /* fall through */\n+    case 9 : c+=k8[8];                   /* fall through */\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;   /* fall through */\n+    case 6 : b+=((uint32_t)k8[5])<<8;    /* fall through */\n+    case 5 : b+=k8[4];                   /* fall through */\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;   /* fall through */\n+    case 2 : a+=((uint32_t)k8[1])<<8;    /* fall through */\n+    case 1 : a+=k8[0]; break;\n+    case 0 : return c;\n+    }\n+\n+#endif /* !valgrind */\n+\n+  } else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0)) {\n+    const uint16_t *k = (const uint16_t *)key;         /* read 16-bit chunks */\n+    const uint8_t  *k8;\n+\n+    /*--------------- all but last block: aligned reads and different mixing */\n+    while (length > 12)\n+    {\n+      a += k[0] + (((uint32_t)k[1])<<16);\n+      b += k[2] + (((uint32_t)k[3])<<16);\n+      c += k[4] + (((uint32_t)k[5])<<16);\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 6;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[4]+(((uint32_t)k[5])<<16);\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 11: c+=((uint32_t)k8[10])<<16;     /* fall through */\n+    case 10: c+=k[4];\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 9 : c+=k8[8];                      /* fall through */\n+    case 8 : b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;      /* fall through */\n+    case 6 : b+=k[2];\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 5 : b+=k8[4];                      /* fall through */\n+    case 4 : a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;      /* fall through */\n+    case 2 : a+=k[0];\n+             break;\n+    case 1 : a+=k8[0];\n+             break;\n+    case 0 : return c;                     /* zero length requires no mixing */\n+    }\n+\n+  } else {                        /* need to read the key one byte at a time */\n+    const uint8_t *k = (const uint8_t *)key;\n+\n+    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      a += ((uint32_t)k[1])<<8;\n+      a += ((uint32_t)k[2])<<16;\n+      a += ((uint32_t)k[3])<<24;\n+      b += k[4];\n+      b += ((uint32_t)k[5])<<8;\n+      b += ((uint32_t)k[6])<<16;\n+      b += ((uint32_t)k[7])<<24;\n+      c += k[8];\n+      c += ((uint32_t)k[9])<<8;\n+      c += ((uint32_t)k[10])<<16;\n+      c += ((uint32_t)k[11])<<24;\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 12;\n+    }\n+\n+    /*-------------------------------- last block: affect all 32 bits of (c) */\n+    switch(length)                   /* all the case statements fall through */\n+    {\n+    case 12: c+=((uint32_t)k[11])<<24;\n+    case 11: c+=((uint32_t)k[10])<<16;\n+    case 10: c+=((uint32_t)k[9])<<8;\n+    case 9 : c+=k[8];\n+    case 8 : b+=((uint32_t)k[7])<<24;\n+    case 7 : b+=((uint32_t)k[6])<<16;\n+    case 6 : b+=((uint32_t)k[5])<<8;\n+    case 5 : b+=k[4];\n+    case 4 : a+=((uint32_t)k[3])<<24;\n+    case 3 : a+=((uint32_t)k[2])<<16;\n+    case 2 : a+=((uint32_t)k[1])<<8;\n+    case 1 : a+=k[0];\n+             break;\n+    case 0 : return c;\n+    }\n+  }\n+\n+  final(a,b,c);\n+  return c;\n+}""}<_**next**_>{""sha"": ""b4f109143031b2481a0d32a332c88cc1cc96c688"", ""filename"": ""src/utf.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 16, ""changes"": 20, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/utf.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/utf.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/utf.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -10,23 +10,11 @@\n \n #ifdef HAVE_CONFIG_H\n #include <config.h>\n+#endif\n \n-#ifdef HAVE_INTTYPES_H\n-/* inttypes.h includes stdint.h in a standard environment, so there's\n-no need to include stdint.h separately. If inttypes.h doesn't define\n-int32_t, it's defined in config.h. */\n-#include <inttypes.h>\n-#endif /* HAVE_INTTYPES_H */\n-\n-#else /* !HAVE_CONFIG_H */\n-#ifdef _WIN32\n-typedef int int32_t;\n-#else /* !_WIN32 */\n-/* Assume a standard environment */\n-#include <inttypes.h>\n-#endif /* _WIN32 */\n-\n-#endif /* HAVE_CONFIG_H */\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n \n int utf8_encode(int codepoint, char *buffer, int *size);\n ""}<_**next**_>{""sha"": ""1b02d90aa885f1ede146bb2077d05c8bb9096565"", ""filename"": ""src/value.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/value.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/value.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/value.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -9,11 +9,19 @@\n #define _GNU_SOURCE\n #endif\n \n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stddef.h>\n #include <stdlib.h>\n #include <string.h>\n #include <math.h>\n \n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include \""jansson.h\""\n #include \""hashtable.h\""\n #include \""jansson_private.h\""\n@@ -36,11 +44,19 @@ static JSON_INLINE void json_init(json_t *json, json_type type)\n \n /*** object ***/\n \n+extern volatile uint32_t hashtable_seed;\n+\n json_t *json_object(void)\n {\n     json_object_t *object = jsonp_malloc(sizeof(json_object_t));\n     if(!object)\n         return NULL;\n+\n+    if (!hashtable_seed) {\n+        /* Autoseed */\n+        json_object_seed(0);\n+    }\n+\n     json_init(&object->json, JSON_OBJECT);\n \n     if(hashtable_init(&object->hashtable))""}<_**next**_>{""sha"": ""e2c54bd12bd7c22de7cc3533f010b26cc1c330b0"", ""filename"": ""test/bin/json_process.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 1, ""changes"": 16, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/bin/json_process.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/bin/json_process.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/bin/json_process.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -37,6 +37,8 @@ struct config {\n     int sort_keys;\n     int strip;\n     int use_env;\n+    int have_hashseed;\n+    int hashseed;\n } conf;\n \n #define l_isspace(c) ((c) == ' ' || (c) == '\\n' || (c) == '\\r' || (c) == '\\t')\n@@ -108,6 +110,12 @@ static void read_conf(FILE *conffile)\n             conf.sort_keys = atoi(val);\n         if (!strcmp(line, \""STRIP\""))\n             conf.strip = atoi(val);\n+        if (!strcmp(line, \""HASHSEED\"")) {\n+            conf.have_hashseed = 1;\n+            conf.hashseed = atoi(val);\n+        } else {\n+            conf.have_hashseed = 0;\n+        }\n     }\n \n     free(buffer);\n@@ -188,6 +196,9 @@ int use_conf(char *test_path)\n     if (conf.sort_keys)\n         flags |= JSON_SORT_KEYS;\n \n+    if (conf.have_hashseed)\n+        json_object_seed(conf.hashseed);\n+\n     if (conf.strip) {\n         /* Load to memory, strip leading and trailing whitespace */\n         buffer = loadfile(infile);\n@@ -265,7 +276,10 @@ int use_env()\n         flags |= JSON_PRESERVE_ORDER;\n \n     if(getenv_int(\""JSON_SORT_KEYS\""))\n-         flags |= JSON_SORT_KEYS;\n+        flags |= JSON_SORT_KEYS;\n+\n+    if(getenv(\""HASHSEED\""))\n+        json_object_seed(getenv_int(\""HASHSEED\""));\n \n     if(getenv_int(\""STRIP\"")) {\n         /* Load to memory, strip leading and trailing whitespace */""}<_**next**_>{""sha"": ""84b17466fd0a753b8cbd714d0236ed9072cdd536"", ""filename"": ""test/suites/api/test_memory_funcs.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_memory_funcs.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_memory_funcs.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/api/test_memory_funcs.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -24,13 +24,13 @@ static void create_and_free_complex_object()\n \n static void *my_malloc(size_t size)\n {\n-    malloc_called += 1;\n+    malloc_called = 1;\n     return malloc(size);\n }\n \n static void my_free(void *ptr)\n {\n-    free_called += 1;\n+    free_called = 1;\n     free(ptr);\n }\n \n@@ -39,7 +39,7 @@ static void test_simple()\n     json_set_alloc_funcs(my_malloc, my_free);\n     create_and_free_complex_object();\n \n-    if(malloc_called != 20 || free_called != 20)\n+    if(malloc_called != 1 || free_called != 1)\n         fail(\""Custom allocation failed\"");\n }\n ""}<_**next**_>{""sha"": ""92e5208224b75ab45d93672446279d598052a83e"", ""filename"": ""test/suites/api/test_object.c"", ""status"": ""modified"", ""additions"": 40, ""deletions"": 24, ""changes"": 64, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_object.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_object.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/api/test_object.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -249,7 +249,11 @@ static void test_set_nocheck()\n \n static void test_iterators()\n {\n+    int i;\n     json_t *object, *foo, *bar, *baz;\n+    const char *iter_keys[3];\n+    int have_key[3] = { 0, 0, 0 };\n+    json_t *iter_values[3];\n     void *iter;\n \n     if(json_object_iter(NULL))\n@@ -276,30 +280,50 @@ static void test_iterators()\n     iter = json_object_iter(object);\n     if(!iter)\n         fail(\""unable to get iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""a\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != foo)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[0] = json_object_iter_key(iter);\n+    iter_values[0] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""b\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != bar)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[1] = json_object_iter_key(iter);\n+    iter_values[1] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[2] = json_object_iter_key(iter);\n+    iter_values[2] = json_object_iter_value(iter);\n \n     if(json_object_iter_next(object, iter) != NULL)\n         fail(\""able to iterate over the end\"");\n \n+    /* Check that keys have correct values */\n+    for (i = 0; i < 3; i++) {\n+        if (strcmp(iter_keys[i], \""a\"") == 0) {\n+            if (iter_values[i] != foo)\n+                fail(\""wrong value for iter key a\"");\n+            else\n+                have_key[0] = 1;\n+        } else if (strcmp(iter_keys[i], \""b\"") == 0) {\n+            if (iter_values[i] != bar)\n+                fail(\""wrong value for iter key b\"");\n+            else\n+                have_key[1] = 1;\n+        } else if (strcmp(iter_keys[i], \""c\"") == 0) {\n+            if (iter_values[i] != baz)\n+                fail(\""wrong value for iter key c\"");\n+            else\n+                have_key[2] = 1;\n+        }\n+    }\n+\n+    /* Check that we got all keys */\n+    for(i = 0; i < 3; i++) {\n+        if(!have_key[i])\n+            fail(\""a key wasn't iterated over\"");\n+    }\n+\n     if(json_object_iter_at(object, \""foo\""))\n         fail(\""json_object_iter_at() succeeds for non-existent key\"");\n \n@@ -312,22 +336,14 @@ static void test_iterators()\n     if(json_object_iter_value(iter) != bar)\n         fail(\""iterating failed: wrong value\"");\n \n-    iter = json_object_iter_next(object, iter);\n-    if(!iter)\n-        fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\""iterating failed: wrong value\"");\n-\n-    if(json_object_iter_set(object, iter, bar))\n+    if(json_object_iter_set(object, iter, baz))\n         fail(\""unable to set value at iterator\"");\n \n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n+    if(strcmp(json_object_iter_key(iter), \""b\""))\n         fail(\""json_object_iter_key() fails after json_object_iter_set()\"");\n-    if(json_object_iter_value(iter) != bar)\n+    if(json_object_iter_value(iter) != baz)\n         fail(\""json_object_iter_value() fails after json_object_iter_set()\"");\n-    if(json_object_get(object, \""c\"") != bar)\n+    if(json_object_get(object, \""b\"") != baz)\n         fail(\""json_object_get() fails after json_object_iter_set()\"");\n \n     json_decref(object);""}<_**next**_>{""sha"": ""93cb33ddafeb9eef6ce7ad4709ce1bcbdf25b200"", ""filename"": ""test/suites/encoding-flags/compact-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/compact-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/compact-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/compact-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,2 +1,3 @@\n JSON_COMPACT=1\n-export JSON_COMPACT\n+HASHSEED=1\n+export JSON_COMPACT HASHSEED""}<_**next**_>{""sha"": ""c73acc1792963be8a5f41ff11f6e858506ada51d"", ""filename"": ""test/suites/encoding-flags/indent-compact-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-compact-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-compact-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/indent-compact-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,3 +1,4 @@\n JSON_INDENT=4\n JSON_COMPACT=1\n-export JSON_INDENT JSON_COMPACT\n+HASHSEED=1\n+export JSON_INDENT JSON_COMPACT HASHSEED""}<_**next**_>{""sha"": ""961558ca23ceca2ce6e4d07697f4018d8475f317"", ""filename"": ""test/suites/encoding-flags/indent-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/indent-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,2 +1,3 @@\n JSON_INDENT=4\n-export JSON_INDENT\n+HASHSEED=1\n+export JSON_INDENT HASHSEED""}<_**next**_>{""sha"": ""9120b03514ec614695c2d17841ba228b102c9db6"", ""filename"": ""test/suites/encoding-flags/object/env"", ""status"": ""added"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,2 @@\n+HASHSEED=1\n+export HASHSEED""}","int use_conf(char *test_path)
{
    int ret;
    size_t flags = 0;
    char filename[1024], errstr[1024];
    char *buffer;
    FILE *infile, *conffile;
    json_t *json;
    json_error_t error;

    sprintf(filename, ""%s%cinput"", test_path, dir_sep);
    if (!(infile = fopen(filename, ""rb""))) {
        fprintf(stderr, ""Could not open \""%s\""\n"", filename);
        return 2;
    }

    sprintf(filename, ""%s%cenv"", test_path, dir_sep);
    conffile = fopen(filename, ""rb"");
    if (conffile) {
        read_conf(conffile);
        fclose(conffile);
    }

    if (conf.indent < 0 || conf.indent > 255) {
        fprintf(stderr, ""invalid value for JSON_INDENT: %d\n"", conf.indent);
        return 2;
    }

    if (conf.indent)
        flags |= JSON_INDENT(conf.indent);

    if (conf.compact)
        flags |= JSON_COMPACT;

    if (conf.ensure_ascii)
        flags |= JSON_ENSURE_ASCII;

    if (conf.preserve_order)
        flags |= JSON_PRESERVE_ORDER;

     if (conf.sort_keys)
         flags |= JSON_SORT_KEYS;
 
    if (conf.have_hashseed)
        json_object_seed(conf.hashseed);

     if (conf.strip) {
         /* Load to memory, strip leading and trailing whitespace */
         buffer = loadfile(infile);
        json = json_loads(strip(buffer), 0, &error);
        free(buffer);
    }
    else
        json = json_loadf(infile, 0, &error);

    fclose(infile);

    if (!json) {
        sprintf(errstr, ""%d %d %d\n%s\n"",
                error.line, error.column, error.position,
                error.text);

        ret = cmpfile(errstr, test_path, ""error"");
        return ret;
    }

    buffer = json_dumps(json, flags);
    ret = cmpfile(buffer, test_path, ""output"");
    free(buffer);
    json_decref(json);

    return ret;
}
","int use_conf(char *test_path)
{
    int ret;
    size_t flags = 0;
    char filename[1024], errstr[1024];
    char *buffer;
    FILE *infile, *conffile;
    json_t *json;
    json_error_t error;

    sprintf(filename, ""%s%cinput"", test_path, dir_sep);
    if (!(infile = fopen(filename, ""rb""))) {
        fprintf(stderr, ""Could not open \""%s\""\n"", filename);
        return 2;
    }

    sprintf(filename, ""%s%cenv"", test_path, dir_sep);
    conffile = fopen(filename, ""rb"");
    if (conffile) {
        read_conf(conffile);
        fclose(conffile);
    }

    if (conf.indent < 0 || conf.indent > 255) {
        fprintf(stderr, ""invalid value for JSON_INDENT: %d\n"", conf.indent);
        return 2;
    }

    if (conf.indent)
        flags |= JSON_INDENT(conf.indent);

    if (conf.compact)
        flags |= JSON_COMPACT;

    if (conf.ensure_ascii)
        flags |= JSON_ENSURE_ASCII;

    if (conf.preserve_order)
        flags |= JSON_PRESERVE_ORDER;

     if (conf.sort_keys)
         flags |= JSON_SORT_KEYS;
 
     if (conf.strip) {
         /* Load to memory, strip leading and trailing whitespace */
         buffer = loadfile(infile);
        json = json_loads(strip(buffer), 0, &error);
        free(buffer);
    }
    else
        json = json_loadf(infile, 0, &error);

    fclose(infile);

    if (!json) {
        sprintf(errstr, ""%d %d %d\n%s\n"",
                error.line, error.column, error.position,
                error.text);

        ret = cmpfile(errstr, test_path, ""error"");
        return ret;
    }

    buffer = json_dumps(json, flags);
    ret = cmpfile(buffer, test_path, ""output"");
    free(buffer);
    json_decref(json);

    return ret;
}
",C,"    if (conf.have_hashseed)
        json_object_seed(conf.hashseed);

",,,"@@ -37,6 +37,8 @@ struct config {
     int sort_keys;
     int strip;
     int use_env;
+    int have_hashseed;
+    int hashseed;
 } conf;
 
 #define l_isspace(c) ((c) == ' ' || (c) == '\n' || (c) == '\r' || (c) == '\t')
@@ -108,6 +110,12 @@ static void read_conf(FILE *conffile)
             conf.sort_keys = atoi(val);
         if (!strcmp(line, ""STRIP""))
             conf.strip = atoi(val);
+        if (!strcmp(line, ""HASHSEED"")) {
+            conf.have_hashseed = 1;
+            conf.hashseed = atoi(val);
+        } else {
+            conf.have_hashseed = 0;
+        }
     }
 
     free(buffer);
@@ -188,6 +196,9 @@ int use_conf(char *test_path)
     if (conf.sort_keys)
         flags |= JSON_SORT_KEYS;
 
+    if (conf.have_hashseed)
+        json_object_seed(conf.hashseed);
+
     if (conf.strip) {
         /* Load to memory, strip leading and trailing whitespace */
         buffer = loadfile(infile);
@@ -265,7 +276,10 @@ int use_env()
         flags |= JSON_PRESERVE_ORDER;
 
     if(getenv_int(""JSON_SORT_KEYS""))
-         flags |= JSON_SORT_KEYS;
+        flags |= JSON_SORT_KEYS;
+
+    if(getenv(""HASHSEED""))
+        json_object_seed(getenv_int(""HASHSEED""));
 
     if(getenv_int(""STRIP"")) {
         /* Load to memory, strip leading and trailing whitespace */",jansson,8f80c2d83808150724d31793e6ade92749b1faa4,b9c588de3deb4efdd7b9ec44aa79335dba11fd6b,1,"int use_conf(char *test_path)
{
    int ret;
    size_t flags = 0;
    char filename[1024], errstr[1024];
    char *buffer;
    FILE *infile, *conffile;
    json_t *json;
    json_error_t error;

    sprintf(filename, ""%s%cinput"", test_path, dir_sep);
    if (!(infile = fopen(filename, ""rb""))) {
        fprintf(stderr, ""Could not open \""%s\""\n"", filename);
        return 2;
    }

    sprintf(filename, ""%s%cenv"", test_path, dir_sep);
    conffile = fopen(filename, ""rb"");
    if (conffile) {
        read_conf(conffile);
        fclose(conffile);
    }

    if (conf.indent < 0 || conf.indent > 255) {
        fprintf(stderr, ""invalid value for JSON_INDENT: %d\n"", conf.indent);
        return 2;
    }

    if (conf.indent)
        flags |= JSON_INDENT(conf.indent);

    if (conf.compact)
        flags |= JSON_COMPACT;

    if (conf.ensure_ascii)
        flags |= JSON_ENSURE_ASCII;

    if (conf.preserve_order)
        flags |= JSON_PRESERVE_ORDER;

     if (conf.sort_keys)
         flags |= JSON_SORT_KEYS;
 
//fix_flaw_line_below:
//    if (conf.have_hashseed)
//fix_flaw_line_below:
//        json_object_seed(conf.hashseed);
//fix_flaw_line_below:
//
     if (conf.strip) {
         /* Load to memory, strip leading and trailing whitespace */
         buffer = loadfile(infile);
        json = json_loads(strip(buffer), 0, &error);
        free(buffer);
    }
    else
        json = json_loadf(infile, 0, &error);

    fclose(infile);

    if (!json) {
        sprintf(errstr, ""%d %d %d\n%s\n"",
                error.line, error.column, error.position,
                error.text);

        ret = cmpfile(errstr, test_path, ""error"");
        return ret;
    }

    buffer = json_dumps(json, flags);
    ret = cmpfile(buffer, test_path, ""output"");
    free(buffer);
    json_decref(json);

    return ret;
}
"
1974,179710,,Remote,Not required,Partial,CVE-2013-6401,https://www.cvedetails.com/cve/CVE-2013-6401/,CWE-310,Low,,,,2014-03-20,5.0,"Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document.",2014-05-23,DoS ,4,https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4,8f80c2d83808150724d31793e6ade92749b1faa4,"CVE-2013-6401: Change hash function, randomize hashes

Thanks to Florian Weimer and Eric Sesterhenn for reporting, reviewing
and testing.",1,test/bin/json_process.c,"{""sha"": ""1043c9ae4c0bc0c1f6a5913783973383832ff14b"", ""filename"": ""CMakeLists.txt"", ""status"": ""modified"", ""additions"": 39, ""deletions"": 10, ""changes"": 49, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/CMakeLists.txt"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/CMakeLists.txt"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/CMakeLists.txt?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -52,6 +52,8 @@ project (jansson C)\n \n # Options\n OPTION (BUILD_SHARED_LIBS \""Build shared libraries.\"" OFF)\n+OPTION (USE_URANDOM \""Use /dev/urandom to seed the hash function.\"" ON)\n+OPTION (USE_WINDOWS_CRYPTOAPI \""Use CryptGenRandom to seed the hash function.\"" ON)\n \n if (MSVC)\n    # This option must match the settings used in your program, in particular if you\n@@ -85,12 +87,12 @@ set (JANSSON_SOVERSION 4)\n # for CheckFunctionKeywords\n set(CMAKE_MODULE_PATH \""${CMAKE_CURRENT_SOURCE_DIR}/cmake\"")\n \n+INCLUDE (CheckCSourceCompiles)\n include (CheckFunctionExists)\n include (CheckFunctionKeywords)\n include (CheckIncludeFiles)\n include (CheckTypeSize)\n \n-\n if (MSVC)\n    # Turn off Microsofts \""security\"" warnings.\n    add_definitions( \""/W3 /D_CRT_SECURE_NO_WARNINGS /wd4005 /wd4996 /nologo\"" )\n@@ -106,14 +108,25 @@ if (CMAKE_COMPILER_IS_GNUCC OR CMAKE_COMPILER_IS_GNUCXX)\n    set(CMAKE_C_FLAGS \""-fPIC\"")\n endif()\n \n-   \n+check_include_files (endian.h HAVE_ENDIAN_H)\n+check_include_files (fcntl.h HAVE_FCNTL_H)\n+check_include_files (sched.h HAVE_SCHED_H)\n+check_include_files (unistd.h HAVE_UNISTD_H)\n+check_include_files (sys/param.h HAVE_SYS_PARAM_H)\n+check_include_files (sys/stat.h HAVE_SYS_STAT_H)\n+check_include_files (sys/time.h HAVE_SYS_TIME_H)\n+check_include_files (sys/time.h HAVE_SYS_TYPES_H)\n+\n+check_function_exists (close HAVE_CLOSE)\n+check_function_exists (getpid HAVE_GETPID)\n+check_function_exists (gettimeofday HAVE_GETTIMEOFDAY)\n+check_function_exists (open HAVE_OPEN)\n+check_function_exists (read HAVE_READ)\n+check_function_exists (sched_yield HAVE_SCHED_YIELD)\n \n # Check for the int-type includes\n-check_include_files (sys/types.h HAVE_SYS_TYPES_H)\n-check_include_files (inttypes.h HAVE_INTTYPES_H)\n check_include_files (stdint.h HAVE_STDINT_H)\n \n-\n # Check our 64 bit integer sizes\n check_type_size (__int64 __INT64)\n check_type_size (int64_t INT64_T)\n@@ -124,17 +137,32 @@ check_type_size (int32_t INT32_T)\n check_type_size (__int32 __INT32)\n check_type_size (\""long\"" LONG_INT)\n check_type_size (\""int\"" INT)\n-\n if (HAVE_INT32_T)\n    set (JSON_INT32 int32_t)\n elseif (HAVE___INT32)\n    set (JSON_INT32 __int32)\n-elseif (HAVE_LONG AND (${LONG_INT} EQUAL 4))\n+elseif (HAVE_LONG_INT AND (${LONG_INT} EQUAL 4))\n    set (JSON_INT32 long)\n elseif (HAVE_INT AND (${INT} EQUAL 4))\n    set (JSON_INT32 int)\n else ()\n-   message (FATAL_ERROR \""Could not detect a valid 32 bit integer type\"")\n+   message (FATAL_ERROR \""Could not detect a valid 32-bit integer type\"")\n+endif ()\n+\n+check_type_size (uint32_t UINT32_T)\n+check_type_size (__uint32 __UINT32)\n+check_type_size (\""unsigned long\"" UNSIGNED_LONG_INT)\n+check_type_size (\""unsigned int\"" UNSIGNED_INT)\n+if (HAVE_UINT32_T)\n+   set (JSON_UINT32 uint32_t)\n+elseif (HAVE___UINT32)\n+   set (JSON_UINT32 __uint32)\n+elseif (HAVE_UNSIGNED_LONG_INT AND (${UNSIGNED_LONG_INT} EQUAL 4))\n+   set (JSON_UINT32 \""unsigned long\"")\n+elseif (HAVE_UNSIGNED_INT AND (${UNSIGNED_INT} EQUAL 4))\n+   set (JSON_UINT32 \""unsigned int\"")\n+else ()\n+   message (FATAL_ERROR \""Could not detect a valid unsigned 32-bit integer type\"")\n endif ()\n \n # Check for ssize_t and SSIZE_T existance.\n@@ -206,11 +234,9 @@ else ()\n    set (JSON_HAVE_LOCALECONV 0)\n endif ()\n \n-\n # check if we have setlocale\n check_function_exists (setlocale HAVE_SETLOCALE)\n \n-\n # Check what the inline keyword is.\n # Note that the original JSON_INLINE was always set to just 'inline', so this goes further.\n check_function_keywords(\""inline\"")\n@@ -238,6 +264,9 @@ elseif (HAVE__SNPRINTF)\n    set (JSON_SNPRINTF _snprintf)\n endif ()\n \n+check_c_source_compiles (\""int main() { unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1); return 0; } \"" HAVE_SYNC_BUILTINS)\n+check_c_source_compiles (\""int main() { char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE); return 0; }\"" HAVE_ATOMIC_BUILTINS)\n+\n # Create pkg-conf file.\n # (We use the same files as ./configure does, so we\n #  have to defined the same variables used there).""}<_**next**_>{""sha"": ""b27b9a3a849e94686aa648c1ec4d1bd4c8e35445"", ""filename"": ""cmake/config.h.cmake"", ""status"": ""modified"", ""additions"": 25, ""deletions"": 21, ""changes"": 46, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/cmake/config.h.cmake"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/cmake/config.h.cmake"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/cmake/config.h.cmake?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,35 +1,36 @@\n-/* Reduced down to the defines that are actually used in the code */\n-\n-/* Define to 1 if you have the <inttypes.h> (and friends) header file. */\n-#cmakedefine HAVE_INTTYPES_H 1\n-#cmakedefine HAVE_STDINT_H 1\n+#cmakedefine HAVE_ENDIAN_H 1\n+#cmakedefine HAVE_FCNTL_H 1\n+#cmakedefine HAVE_SCHED_H 1\n+#cmakedefine HAVE_UNISTD_H 1\n+#cmakedefine HAVE_SYS_PARAM_H 1\n+#cmakedefine HAVE_SYS_STAT_H 1\n+#cmakedefine HAVE_SYS_TIME_H 1\n #cmakedefine HAVE_SYS_TYPES_H 1\n+#cmakedefine HAVE_STDINT_H 1\n \n-/* We must include this here, as in (eg) utf.h it will want to use\n-   the integer type, which in MSVC2010 will be in stdint.h\n-   (there is no inttypes.h in MSVC2010) */\n-#if defined(HAVE_STDINT_H)\n-#  include <stdint.h>\n-#elif defined(HAVE_INTTYPES_H)\n-#  include <inttypes.h>\n-#elif defined(HAVE_SYS_TYPES_H)\n-#  include <sys/types.h>\n-#endif\n+#cmakedefine HAVE_CLOSE 1\n+#cmakedefine HAVE_GETPID 1\n+#cmakedefine HAVE_GETTIMEOFDAY 1\n+#cmakedefine HAVE_OPEN 1\n+#cmakedefine HAVE_READ 1\n+#cmakedefine HAVE_SCHED_YIELD 1\n \n-/* Define to 1 if you have the <locale.h> header file. */\n-#cmakedefine HAVE_LOCALE_H 1\n+#cmakedefine HAVE_SYNC_BUILTINS 1\n+#cmakedefine HAVE_ATOMIC_BUILTINS 1\n \n-/* Define to 1 if you have the 'setlocale' function. */\n+#cmakedefine HAVE_LOCALE_H 1\n #cmakedefine HAVE_SETLOCALE 1\n \n-/* Define to the type of a signed integer type of width exactly 32 bits if\n-   such a type exists and the standard includes do not define it. */\n #cmakedefine HAVE_INT32_T 1\n-\n #ifndef HAVE_INT32_T\n #  define int32_t @JSON_INT32@\n #endif\n \n+#cmakedefine HAVE_UINT32_T 1\n+#ifndef HAVE_UINT32_T\n+#  define uint32_t @JSON_UINT32@\n+#endif\n+\n #cmakedefine HAVE_SSIZE_T 1\n \n #ifndef HAVE_SSIZE_T\n@@ -43,3 +44,6 @@\n #endif\n \n #cmakedefine HAVE_VSNPRINTF\n+\n+#cmakedefine USE_URANDOM 1\n+#cmakedefine USE_WINDOWS_CRYPTOAPI 1""}<_**next**_>{""sha"": ""113cb85e17a15f2fac83b528fe1880bc99481ccb"", ""filename"": ""configure.ac"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 2, ""changes"": 50, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/configure.ac"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/configure.ac"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/configure.ac?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -14,10 +14,11 @@ AM_CONDITIONAL([GCC], [test x$GCC = xyes])\n # Checks for libraries.\n \n # Checks for header files.\n-AC_CHECK_HEADERS([locale.h])\n+AC_CHECK_HEADERS([endian.h fcntl.h locale.h sched.h unistd.h sys/param.h sys/stat.h sys/time.h sys/types.h])\n \n # Checks for typedefs, structures, and compiler characteristics.\n AC_TYPE_INT32_T\n+AC_TYPE_UINT32_T\n AC_TYPE_LONG_LONG_INT\n \n AC_C_INLINE\n@@ -29,7 +30,31 @@ esac\n AC_SUBST([json_inline])\n \n # Checks for library functions.\n-AC_CHECK_FUNCS([strtoll localeconv])\n+AC_CHECK_FUNCS([close getpid gettimeofday localeconv open read sched_yield strtoll])\n+\n+AC_MSG_CHECKING([for gcc __sync builtins])\n+have_sync_builtins=no\n+AC_TRY_LINK(\n+  [], [unsigned long val; __sync_bool_compare_and_swap(&val, 0, 1);],\n+  [have_sync_builtins=yes],\n+)\n+if test \""x$have_sync_builtins\"" = \""xyes\""; then\n+  AC_DEFINE([HAVE_SYNC_BUILTINS], [1],\n+    [Define to 1 if gcc's __sync builtins are available])\n+fi\n+AC_MSG_RESULT([$have_sync_builtins])\n+\n+AC_MSG_CHECKING([for gcc __atomic builtins])\n+have_atomic_builtins=no\n+AC_TRY_LINK(\n+  [], [char l; unsigned long v; __atomic_test_and_set(&l, __ATOMIC_RELAXED); __atomic_store_n(&v, 1, __ATOMIC_ACQ_REL); __atomic_load_n(&v, __ATOMIC_ACQUIRE);],\n+  [have_atomic_builtins=yes],\n+)\n+if test \""x$have_atomic_builtins\"" = \""xyes\""; then\n+  AC_DEFINE([HAVE_ATOMIC_BUILTINS], [1],\n+    [Define to 1 if gcc's __atomic builtins are available])\n+fi\n+AC_MSG_RESULT([$have_atomic_builtins])\n \n case \""$ac_cv_type_long_long_int$ac_cv_func_strtoll\"" in\n      yesyes) json_have_long_long=1;;\n@@ -43,6 +68,27 @@ case \""$ac_cv_header_locale_h$ac_cv_func_localeconv\"" in\n esac\n AC_SUBST([json_have_localeconv])\n \n+# Features\n+AC_ARG_ENABLE([urandom],\n+  [AS_HELP_STRING([--disable-urandom],\n+    [Don't use /dev/urandom to seed the hash function])],\n+  [use_urandom=$enableval], [use_urandom=yes])\n+\n+if test \""x$use_urandom\"" = xyes; then\n+AC_DEFINE([USE_URANDOM], [1],\n+  [Define to 1 if /dev/urandom should be used for seeding the hash function])\n+fi\n+\n+AC_ARG_ENABLE([windows-cryptoapi],\n+  [AS_HELP_STRING([--disable-windows-cryptoapi],\n+    [Don't use CryptGenRandom to seed the hash function])],\n+  [use_windows_cryptoapi=$enableval], [use_windows_cryptoapi=yes])\n+\n+if test \""x$use_windows_cryptoapi\"" = xyes; then\n+AC_DEFINE([USE_WINDOWS_CRYPTOAPI], [1],\n+  [Define to 1 if CryptGenRandom should be used for seeding the hash function])\n+fi\n+\n AC_CONFIG_FILES([\n         jansson.pc\n         Makefile""}<_**next**_>{""sha"": ""b4af562e84b5ed9dba1107af7d1768dcdb0b9a95"", ""filename"": ""src/Makefile.am"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/Makefile.am"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/Makefile.am?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -8,6 +8,7 @@ libjansson_la_SOURCES = \\\n \terror.c \\\n \thashtable.c \\\n \thashtable.h \\\n+\thashtable_seed.c \\\n \tjansson_private.h \\\n \tload.c \\\n \tmemory.c \\""}<_**next**_>{""sha"": ""abd4bf11fe7a393fcf3d533b952aa8b5efa4ea30"", ""filename"": ""src/hashtable.c"", ""status"": ""modified"", ""additions"": 26, ""deletions"": 41, ""changes"": 67, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -5,8 +5,17 @@\n  * it under the terms of the MIT license. See LICENSE for details.\n  */\n \n+#if HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stdlib.h>\n #include <string.h>\n+\n+#if HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include <jansson_config.h>   /* for JSON_INLINE */\n #include \""jansson_private.h\""  /* for container_of() */\n #include \""hashtable.h\""\n@@ -15,24 +24,13 @@ typedef struct hashtable_list list_t;\n typedef struct hashtable_pair pair_t;\n typedef struct hashtable_bucket bucket_t;\n \n-#define list_to_pair(list_)  container_of(list_, pair_t, list)\n-\n-/* From http://www.cse.yorku.ca/~oz/hash.html */\n-static size_t hash_str(const void *ptr)\n-{\n-    const char *str = (const char *)ptr;\n-\n-    size_t hash = 5381;\n-    size_t c;\n+extern volatile uint32_t hashtable_seed;\n \n-    while((c = (size_t)*str))\n-    {\n-        hash = ((hash << 5) + hash) + c;\n-        str++;\n-    }\n+/* Implementation of the hash function */\n+#include \""lookup3.h\""\n \n-    return hash;\n-}\n+#define list_to_pair(list_)  container_of(list_, pair_t, list)\n+#define hash_str(key)        ((size_t)hashlittle((key), strlen(key), hashtable_seed))\n \n static JSON_INLINE void list_init(list_t *list)\n {\n@@ -74,19 +72,6 @@ static void insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket,\n     }\n }\n \n-static const size_t primes[] = {\n-    5, 13, 23, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,\n-    49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,\n-    12582917, 25165843, 50331653, 100663319, 201326611, 402653189,\n-    805306457, 1610612741\n-};\n-\n-static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)\n-{\n-    return primes[hashtable->num_buckets];\n-}\n-\n-\n static pair_t *hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket,\n                                    const char *key, size_t hash)\n {\n@@ -120,7 +105,7 @@ static int hashtable_do_del(hashtable_t *hashtable,\n     bucket_t *bucket;\n     size_t index;\n \n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n@@ -167,14 +152,14 @@ static int hashtable_do_rehash(hashtable_t *hashtable)\n \n     jsonp_free(hashtable->buckets);\n \n-    hashtable->num_buckets++;\n-    new_size = num_buckets(hashtable);\n+    hashtable->order++;\n+    new_size = hashsize(hashtable->order);\n \n     hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -199,14 +184,14 @@ int hashtable_init(hashtable_t *hashtable)\n     size_t i;\n \n     hashtable->size = 0;\n-    hashtable->num_buckets = 0;  /* index to primes[] */\n-    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));\n+    hashtable->order = 3;\n+    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));\n     if(!hashtable->buckets)\n         return -1;\n \n     list_init(&hashtable->list);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -230,12 +215,12 @@ int hashtable_set(hashtable_t *hashtable,\n     size_t hash, index;\n \n     /* rehash if the load ratio exceeds 1 */\n-    if(hashtable->size >= num_buckets(hashtable))\n+    if(hashtable->size >= hashsize(hashtable->order))\n         if(hashtable_do_rehash(hashtable))\n             return -1;\n \n     hash = hash_str(key);\n-    index = hash % num_buckets(hashtable);\n+    index = hash & hashmask(hashtable->order);\n     bucket = &hashtable->buckets[index];\n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n \n@@ -273,7 +258,7 @@ void *hashtable_get(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)\n@@ -294,7 +279,7 @@ void hashtable_clear(hashtable_t *hashtable)\n \n     hashtable_do_clear(hashtable);\n \n-    for(i = 0; i < num_buckets(hashtable); i++)\n+    for(i = 0; i < hashsize(hashtable->order); i++)\n     {\n         hashtable->buckets[i].first = hashtable->buckets[i].last =\n             &hashtable->list;\n@@ -316,7 +301,7 @@ void *hashtable_iter_at(hashtable_t *hashtable, const char *key)\n     bucket_t *bucket;\n \n     hash = hash_str(key);\n-    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n+    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n \n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n     if(!pair)""}<_**next**_>{""sha"": ""469c6ecd869c4698f650fa81983bb3ee03d47fab"", ""filename"": ""src/hashtable.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -32,14 +32,15 @@ struct hashtable_bucket {\n typedef struct hashtable {\n     size_t size;\n     struct hashtable_bucket *buckets;\n-    size_t num_buckets;  /* index to primes[] */\n+    size_t order;  /* hashtable has pow(2, order) buckets */\n     struct hashtable_list list;\n } hashtable_t;\n \n \n #define hashtable_key_to_iter(key_) \\\n     (&(container_of(key_, struct hashtable_pair, key)->list))\n \n+\n /**\n  * hashtable_init - Initialize a hashtable object\n  *""}<_**next**_>{""sha"": ""a07d145d10df35b933c1441dcbf42d3316b78ca5"", ""filename"": ""src/hashtable_seed.c"", ""status"": ""added"", ""additions"": 278, ""deletions"": 0, ""changes"": 278, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable_seed.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/hashtable_seed.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/hashtable_seed.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,278 @@\n+/* Generate sizeof(uint32_t) bytes of as random data as possible to seed\n+   the hash function.\n+*/\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#include <stdio.h>\n+#include <time.h>\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n+#ifdef HAVE_FCNTL_H\n+#include <fcntl.h>\n+#endif\n+\n+#ifdef HAVE_SCHED_H\n+#include <sched.h>\n+#endif\n+\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+\n+#ifdef HAVE_SYS_STAT_H\n+#include <sys/stat.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TIME_H\n+#include <sys/time.h>\n+#endif\n+\n+#ifdef HAVE_SYS_TYPES_H\n+#include <sys/types.h>\n+#endif\n+\n+#if defined(_WIN32)\n+/* For _getpid() */\n+#include <process.h>\n+#endif\n+\n+#include \""jansson.h\""\n+\n+\n+static uint32_t buf_to_uint32(char *data) {\n+    size_t i;\n+    uint32_t result = 0;\n+\n+    for (i = 0; i < sizeof(uint32_t); i++)\n+        result = (result << 8) | (unsigned char)data[i];\n+\n+    return result;\n+}\n+\n+\n+\n+/* /dev/urandom */\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+static int seed_from_urandom(uint32_t *seed) {\n+    /* Use unbuffered I/O if we have open(), close() and read(). Otherwise\n+       fall back to fopen() */\n+\n+    char data[sizeof(uint32_t)];\n+    int ok;\n+\n+#if defined(HAVE_OPEN) && defined(HAVE_CLOSE) && defined(HAVE_READ)\n+    int urandom;\n+    urandom = open(\""/dev/urandom\"", O_RDONLY);\n+    if (urandom == -1)\n+        return 1;\n+\n+    ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);\n+    close(urandom);\n+#else\n+    FILE *urandom;\n+\n+    urandom = fopen(\""/dev/urandom\"", \""rb\"");\n+    if (!urandom)\n+        return 1;\n+\n+    ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);\n+    fclose(urandom);\n+#endif\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32(data);\n+    return 0;\n+}\n+#endif\n+\n+/* Windows Crypto API */\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+#include <windows.h>\n+#include <wincrypt.h>\n+\n+typedef BOOL (WINAPI *CRYPTACQUIRECONTEXTA)(HCRYPTPROV *phProv, LPCSTR pszContainer, LPCSTR pszProvider, DWORD dwProvType, DWORD dwFlags);\n+typedef BOOL (WINAPI *CRYPTGENRANDOM)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);\n+typedef BOOL (WINAPI *CRYPTRELEASECONTEXT)(HCRYPTPROV hProv, DWORD dwFlags);\n+\n+static int seed_from_windows_cryptoapi(uint32_t *seed)\n+{\n+    HINSTANCE hAdvAPI32 = NULL;\n+    CRYPTACQUIRECONTEXTA pCryptAcquireContext = NULL;\n+    CRYPTGENRANDOM pCryptGenRandom = NULL;\n+    CRYPTRELEASECONTEXT pCryptReleaseContext = NULL;\n+    HCRYPTPROV hCryptProv = 0;\n+    BYTE data[sizeof(uint32_t)];\n+    int ok;\n+\n+    hAdvAPI32 = GetModuleHandle(\""advapi32.dll\"");\n+    if(hAdvAPI32 == NULL)\n+        return 1;\n+\n+    pCryptAcquireContext = (CRYPTACQUIRECONTEXTA)GetProcAddress(hAdvAPI32, \""CryptAcquireContextA\"");\n+    if (!pCryptAcquireContext)\n+        return 1;\n+\n+    pCryptGenRandom = (CRYPTGENRANDOM)GetProcAddress(hAdvAPI32, \""CryptGenRandom\"");\n+    if (!pCryptGenRandom)\n+        return 1;\n+\n+    pCryptReleaseContext = (CRYPTRELEASECONTEXT)GetProcAddress(hAdvAPI32, \""CryptReleaseContext\"");\n+    if (!pCryptReleaseContext)\n+        return 1;\n+\n+    if (!pCryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))\n+        return 1;\n+\n+    ok = CryptGenRandom(hCryptProv, sizeof(uint32_t), data);\n+    pCryptReleaseContext(hCryptProv, 0);\n+\n+    if (!ok)\n+        return 1;\n+\n+    *seed = buf_to_uint32((char *)data);\n+    return 0;\n+}\n+#endif\n+\n+/* gettimeofday() and getpid() */\n+static int seed_from_timestamp_and_pid(uint32_t *seed) {\n+#ifdef HAVE_GETTIMEOFDAY\n+    /* XOR of seconds and microseconds */\n+    struct timeval tv;\n+    gettimeofday(&tv, NULL);\n+    *seed = (uint32_t)tv.tv_sec ^ (uint32_t)tv.tv_usec;\n+#else\n+    /* Seconds only */\n+    *seed = (uint32_t)time(NULL);\n+#endif\n+\n+    /* XOR with PID for more randomness */\n+#if defined(_WIN32)\n+    *seed ^= (uint32_t)_getpid();\n+#elif defined(HAVE_GETPID)\n+    *seed ^= (uint32_t)getpid();\n+#endif\n+\n+    return 0;\n+}\n+\n+static uint32_t generate_seed() {\n+    uint32_t seed;\n+    int done = 0;\n+\n+#if !defined(_WIN32) && defined(USE_URANDOM)\n+    if (!done && seed_from_urandom(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n+    if (!done && seed_from_windows_cryptoapi(&seed) == 0)\n+        done = 1;\n+#endif\n+\n+    if (!done) {\n+        /* Fall back to timestamp and PID if no better randomness is\n+           available */\n+        seed_from_timestamp_and_pid(&seed);\n+    }\n+\n+    /* Make sure the seed is never zero */\n+    if (seed == 0)\n+        seed = 1;\n+\n+    return seed;\n+}\n+\n+\n+volatile uint32_t hashtable_seed = 0;\n+\n+#if defined(HAVE_ATOMIC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+static volatile char seed_initialized = 0;\n+\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (__atomic_test_and_set(&seed_initialized, __ATOMIC_RELAXED) == 0) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            __atomic_store_n(&hashtable_seed, new_seed, __ATOMIC_ACQ_REL);\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            } while(__atomic_load_n(&hashtable_seed, __ATOMIC_ACQUIRE) == 0);\n+        }\n+    }\n+}\n+#elif defined(HAVE_SYNC_BUILTINS) && (defined(HAVE_SCHED_YIELD) || !defined(_WIN32))\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0) {\n+            /* Explicit synchronization fences are not supported by the\n+               __sync builtins, so every thread getting here has to\n+               generate the seed value.\n+            */\n+            new_seed = generate_seed();\n+        }\n+\n+        do {\n+            if (__sync_bool_compare_and_swap(&hashtable_seed, 0, new_seed)) {\n+                /* We were the first to seed */\n+                break;\n+            } else {\n+                /* Wait for another thread to do the seeding */\n+#ifdef HAVE_SCHED_YIELD\n+                sched_yield();\n+#endif\n+            }\n+        } while(hashtable_seed == 0);\n+    }\n+}\n+#elif defined(_WIN32)\n+static long seed_initialized = 0;\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (InterlockedIncrement(&seed_initialized) == 1) {\n+            /* Do the seeding ourselves */\n+            if (new_seed == 0)\n+                new_seed = generate_seed();\n+\n+            hashtable_seed = new_seed;\n+        } else {\n+            /* Wait for another thread to do the seeding */\n+            do {\n+                SwitchToThread();\n+            } while (hashtable_seed == 0);\n+        }\n+    }\n+}\n+#else\n+/* Fall back to a thread-unsafe version */\n+void json_object_seed(size_t seed) {\n+    uint32_t new_seed = (uint32_t)seed;\n+\n+    if (hashtable_seed == 0) {\n+        if (new_seed == 0)\n+            new_seed = generate_seed();\n+\n+        hashtable_seed = new_seed;\n+    }\n+}\n+#endif""}<_**next**_>{""sha"": ""19096d4201e6b13f8c56765116865c71f67e9696"", ""filename"": ""src/jansson.def"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.def"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.def"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/jansson.def?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -41,6 +41,7 @@ EXPORTS\n     json_object_iter_value\n     json_object_iter_set_new\n     json_object_key_to_iter\n+    json_object_seed\n     json_dumps\n     json_dumpf\n     json_dump_file""}<_**next**_>{""sha"": ""ea230852a629e55457fba2d00e3edd8a4ad4fcec"", ""filename"": ""src/jansson.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/jansson.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/jansson.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -126,6 +126,7 @@ typedef struct {\n \n /* getters, setters, manipulation */\n \n+void json_object_seed(size_t seed);\n size_t json_object_size(const json_t *object);\n json_t *json_object_get(const json_t *object, const char *key);\n int json_object_set_new(json_t *object, const char *key, json_t *value);""}<_**next**_>{""sha"": ""dc76138c940516e9590784825d28d040fd1a8b25"", ""filename"": ""src/lookup3.h"", ""status"": ""added"", ""additions"": 366, ""deletions"": 0, ""changes"": 366, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/lookup3.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/lookup3.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/lookup3.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,366 @@\n+/*\n+-------------------------------------------------------------------------------\n+lookup3.c, by Bob Jenkins, May 2006, Public Domain.\n+\n+These are functions for producing 32-bit hashes for hash table lookup.\n+hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final() \n+are externally useful functions.  Routines to test the hash are included \n+if SELF_TEST is defined.  You can use this free for any purpose.  It's in\n+the public domain.  It has no warranty.\n+\n+You probably want to use hashlittle().  hashlittle() and hashbig()\n+hash byte arrays.  hashlittle() is is faster than hashbig() on\n+little-endian machines.  Intel and AMD are little-endian machines.\n+On second thought, you probably want hashlittle2(), which is identical to\n+hashlittle() except it returns two 32-bit hashes for the price of one.  \n+You could implement hashbig2() if you wanted but I haven't bothered here.\n+\n+If you want to find a hash of, say, exactly 7 integers, do\n+  a = i1;  b = i2;  c = i3;\n+  mix(a,b,c);\n+  a += i4; b += i5; c += i6;\n+  mix(a,b,c);\n+  a += i7;\n+  final(a,b,c);\n+then use c as the hash value.  If you have a variable length array of\n+4-byte integers to hash, use hashword().  If you have a byte array (like\n+a character string), use hashlittle().  If you have several byte arrays, or\n+a mix of things, see the comments above hashlittle().  \n+\n+Why is this so big?  I read 12 bytes at a time into 3 4-byte integers, \n+then mix those integers.  This is fast (you can do a lot more thorough\n+mixing with 12*3 instructions on 3 integers than you can with 3 instructions\n+on 1 byte), but shoehorning those bytes into integers efficiently is messy.\n+-------------------------------------------------------------------------------\n+*/\n+\n+#include <stdlib.h>\n+\n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>     /* defines uint32_t etc */\n+#endif\n+\n+#ifdef HAVE_SYS_PARAM_H\n+#include <sys/param.h>  /* attempt to define endianness */\n+#endif\n+\n+#ifdef HAVE_ENDIAN_H\n+# include <endian.h>    /* attempt to define endianness */\n+#endif\n+\n+/*\n+ * My best guess at if you are big-endian or little-endian.  This may\n+ * need adjustment.\n+ */\n+#if (defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && \\\n+     __BYTE_ORDER == __LITTLE_ENDIAN) || \\\n+    (defined(i386) || defined(__i386__) || defined(__i486__) || \\\n+     defined(__i586__) || defined(__i686__) || defined(vax) || defined(MIPSEL))\n+# define HASH_LITTLE_ENDIAN 1\n+# define HASH_BIG_ENDIAN 0\n+#elif (defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && \\\n+       __BYTE_ORDER == __BIG_ENDIAN) || \\\n+      (defined(sparc) || defined(POWERPC) || defined(mc68000) || defined(sel))\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 1\n+#else\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 0\n+#endif\n+\n+#define hashsize(n) ((uint32_t)1<<(n))\n+#define hashmask(n) (hashsize(n)-1)\n+#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n+\n+/*\n+-------------------------------------------------------------------------------\n+mix -- mix 3 32-bit values reversibly.\n+\n+This is reversible, so any information in (a,b,c) before mix() is\n+still in (a,b,c) after mix().\n+\n+If four pairs of (a,b,c) inputs are run through mix(), or through\n+mix() in reverse, there are at least 32 bits of the output that\n+are sometimes the same for one pair and different for another pair.\n+This was tested for:\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+Some k values for my \""a-=c; a^=rot(c,k); c+=b;\"" arrangement that\n+satisfy this are\n+    4  6  8 16 19  4\n+    9 15  3 18 27 15\n+   14  9  3  7 17  3\n+Well, \""9 15 3 18 27 15\"" didn't quite get 32 bits diffing\n+for \""differ\"" defined as + with a one-bit base and a two-bit delta.  I\n+used http://burtleburtle.net/bob/hash/avalanche.html to choose \n+the operations, constants, and arrangements of the variables.\n+\n+This does not achieve avalanche.  There are input bits of (a,b,c)\n+that fail to affect some output bits of (a,b,c), especially of a.  The\n+most thoroughly mixed value is c, but it doesn't really even achieve\n+avalanche in c.\n+\n+This allows some parallelism.  Read-after-writes are good at doubling\n+the number of bits affected, so the goal of mixing pulls in the opposite\n+direction as the goal of parallelism.  I did what I could.  Rotates\n+seem to cost as much as shifts on every machine I could lay my hands\n+on, and rotates are much kinder to the top and bottom bits, so I used\n+rotates.\n+-------------------------------------------------------------------------------\n+*/\n+#define mix(a,b,c) \\\n+{ \\\n+  a -= c;  a ^= rot(c, 4);  c += b; \\\n+  b -= a;  b ^= rot(a, 6);  a += c; \\\n+  c -= b;  c ^= rot(b, 8);  b += a; \\\n+  a -= c;  a ^= rot(c,16);  c += b; \\\n+  b -= a;  b ^= rot(a,19);  a += c; \\\n+  c -= b;  c ^= rot(b, 4);  b += a; \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+final -- final mixing of 3 32-bit values (a,b,c) into c\n+\n+Pairs of (a,b,c) values differing in only a few bits will usually\n+produce values of c that look totally different.  This was tested for\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+These constants passed:\n+ 14 11 25 16 4 14 24\n+ 12 14 25 16 4 14 24\n+and these came close:\n+  4  8 15 26 3 22 24\n+ 10  8 15 26 3 22 24\n+ 11  8 15 26 3 22 24\n+-------------------------------------------------------------------------------\n+*/\n+#define final(a,b,c) \\\n+{ \\\n+  c ^= b; c -= rot(b,14); \\\n+  a ^= c; a -= rot(c,11); \\\n+  b ^= a; b -= rot(a,25); \\\n+  c ^= b; c -= rot(b,16); \\\n+  a ^= c; a -= rot(c,4);  \\\n+  b ^= a; b -= rot(a,14); \\\n+  c ^= b; c -= rot(b,24); \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+hashlittle() -- hash a variable-length key into a 32-bit value\n+  k       : the key (the unaligned variable-length array of bytes)\n+  length  : the length of the key, counting by bytes\n+  initval : can be any 4-byte value\n+Returns a 32-bit value.  Every bit of the key affects every bit of\n+the return value.  Two keys differing by one or two bits will have\n+totally different hash values.\n+\n+The best hash table sizes are powers of 2.  There is no need to do\n+mod a prime (mod is sooo slow!).  If you need less than 32 bits,\n+use a bitmask.  For example, if you need only 10 bits, do\n+  h = (h & hashmask(10));\n+In which case, the hash table should have hashsize(10) elements.\n+\n+If you are hashing n strings (uint8_t **)k, do it like this:\n+  for (i=0, h=0; i<n; ++i) h = hashlittle( k[i], len[i], h);\n+\n+By Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this\n+code any way you wish, private, educational, or commercial.  It's free.\n+\n+Use for hash table lookup, or anything where one collision in 2^^32 is\n+acceptable.  Do NOT use for cryptographic purposes.\n+-------------------------------------------------------------------------------\n+*/\n+\n+static uint32_t hashlittle(const void *key, size_t length, uint32_t initval)\n+{\n+  uint32_t a,b,c;                                          /* internal state */\n+  union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */\n+\n+  /* Set up the internal state */\n+  a = b = c = 0xdeadbeef + ((uint32_t)length) + initval;\n+\n+  u.ptr = key;\n+  if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0)) {\n+    const uint32_t *k = (const uint32_t *)key;         /* read 32-bit chunks */\n+\n+#ifdef VALGRIND\n+    const uint8_t  *k8;\n+#endif\n+\n+    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      b += k[1];\n+      c += k[2];\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 3;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    /* \n+     * \""k[2]&0xffffff\"" actually reads beyond the end of the string, but\n+     * then masks off the part it's not allowed to read.  Because the\n+     * string is aligned, the masked-off tail is in the same word as the\n+     * rest of the string.  Every machine with memory protection I've seen\n+     * does it on word boundaries, so is OK with this.  But VALGRIND will\n+     * still catch it and complain.  The masking trick does make the hash\n+     * noticably faster for short strings (like English words).\n+     */\n+#ifndef VALGRIND\n+\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n+    case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n+    case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n+    case 6 : b+=k[1]&0xffff; a+=k[0]; break;\n+    case 5 : b+=k[1]&0xff; a+=k[0]; break;\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=k[0]&0xffffff; break;\n+    case 2 : a+=k[0]&0xffff; break;\n+    case 1 : a+=k[0]&0xff; break;\n+    case 0 : return c;              /* zero length strings require no mixing */\n+    }\n+\n+#else /* make valgrind happy */\n+\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=((uint32_t)k8[10])<<16;  /* fall through */\n+    case 10: c+=((uint32_t)k8[9])<<8;    /* fall through */\n+    case 9 : c+=k8[8];                   /* fall through */\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;   /* fall through */\n+    case 6 : b+=((uint32_t)k8[5])<<8;    /* fall through */\n+    case 5 : b+=k8[4];                   /* fall through */\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;   /* fall through */\n+    case 2 : a+=((uint32_t)k8[1])<<8;    /* fall through */\n+    case 1 : a+=k8[0]; break;\n+    case 0 : return c;\n+    }\n+\n+#endif /* !valgrind */\n+\n+  } else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0)) {\n+    const uint16_t *k = (const uint16_t *)key;         /* read 16-bit chunks */\n+    const uint8_t  *k8;\n+\n+    /*--------------- all but last block: aligned reads and different mixing */\n+    while (length > 12)\n+    {\n+      a += k[0] + (((uint32_t)k[1])<<16);\n+      b += k[2] + (((uint32_t)k[3])<<16);\n+      c += k[4] + (((uint32_t)k[5])<<16);\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 6;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[4]+(((uint32_t)k[5])<<16);\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 11: c+=((uint32_t)k8[10])<<16;     /* fall through */\n+    case 10: c+=k[4];\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 9 : c+=k8[8];                      /* fall through */\n+    case 8 : b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;      /* fall through */\n+    case 6 : b+=k[2];\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 5 : b+=k8[4];                      /* fall through */\n+    case 4 : a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;      /* fall through */\n+    case 2 : a+=k[0];\n+             break;\n+    case 1 : a+=k8[0];\n+             break;\n+    case 0 : return c;                     /* zero length requires no mixing */\n+    }\n+\n+  } else {                        /* need to read the key one byte at a time */\n+    const uint8_t *k = (const uint8_t *)key;\n+\n+    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      a += ((uint32_t)k[1])<<8;\n+      a += ((uint32_t)k[2])<<16;\n+      a += ((uint32_t)k[3])<<24;\n+      b += k[4];\n+      b += ((uint32_t)k[5])<<8;\n+      b += ((uint32_t)k[6])<<16;\n+      b += ((uint32_t)k[7])<<24;\n+      c += k[8];\n+      c += ((uint32_t)k[9])<<8;\n+      c += ((uint32_t)k[10])<<16;\n+      c += ((uint32_t)k[11])<<24;\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 12;\n+    }\n+\n+    /*-------------------------------- last block: affect all 32 bits of (c) */\n+    switch(length)                   /* all the case statements fall through */\n+    {\n+    case 12: c+=((uint32_t)k[11])<<24;\n+    case 11: c+=((uint32_t)k[10])<<16;\n+    case 10: c+=((uint32_t)k[9])<<8;\n+    case 9 : c+=k[8];\n+    case 8 : b+=((uint32_t)k[7])<<24;\n+    case 7 : b+=((uint32_t)k[6])<<16;\n+    case 6 : b+=((uint32_t)k[5])<<8;\n+    case 5 : b+=k[4];\n+    case 4 : a+=((uint32_t)k[3])<<24;\n+    case 3 : a+=((uint32_t)k[2])<<16;\n+    case 2 : a+=((uint32_t)k[1])<<8;\n+    case 1 : a+=k[0];\n+             break;\n+    case 0 : return c;\n+    }\n+  }\n+\n+  final(a,b,c);\n+  return c;\n+}""}<_**next**_>{""sha"": ""b4f109143031b2481a0d32a332c88cc1cc96c688"", ""filename"": ""src/utf.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 16, ""changes"": 20, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/utf.h"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/utf.h"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/utf.h?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -10,23 +10,11 @@\n \n #ifdef HAVE_CONFIG_H\n #include <config.h>\n+#endif\n \n-#ifdef HAVE_INTTYPES_H\n-/* inttypes.h includes stdint.h in a standard environment, so there's\n-no need to include stdint.h separately. If inttypes.h doesn't define\n-int32_t, it's defined in config.h. */\n-#include <inttypes.h>\n-#endif /* HAVE_INTTYPES_H */\n-\n-#else /* !HAVE_CONFIG_H */\n-#ifdef _WIN32\n-typedef int int32_t;\n-#else /* !_WIN32 */\n-/* Assume a standard environment */\n-#include <inttypes.h>\n-#endif /* _WIN32 */\n-\n-#endif /* HAVE_CONFIG_H */\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n \n int utf8_encode(int codepoint, char *buffer, int *size);\n ""}<_**next**_>{""sha"": ""1b02d90aa885f1ede146bb2077d05c8bb9096565"", ""filename"": ""src/value.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/src/value.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/src/value.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/src/value.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -9,11 +9,19 @@\n #define _GNU_SOURCE\n #endif\n \n+#ifdef HAVE_CONFIG_H\n+#include <config.h>\n+#endif\n+\n #include <stddef.h>\n #include <stdlib.h>\n #include <string.h>\n #include <math.h>\n \n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n #include \""jansson.h\""\n #include \""hashtable.h\""\n #include \""jansson_private.h\""\n@@ -36,11 +44,19 @@ static JSON_INLINE void json_init(json_t *json, json_type type)\n \n /*** object ***/\n \n+extern volatile uint32_t hashtable_seed;\n+\n json_t *json_object(void)\n {\n     json_object_t *object = jsonp_malloc(sizeof(json_object_t));\n     if(!object)\n         return NULL;\n+\n+    if (!hashtable_seed) {\n+        /* Autoseed */\n+        json_object_seed(0);\n+    }\n+\n     json_init(&object->json, JSON_OBJECT);\n \n     if(hashtable_init(&object->hashtable))""}<_**next**_>{""sha"": ""e2c54bd12bd7c22de7cc3533f010b26cc1c330b0"", ""filename"": ""test/bin/json_process.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 1, ""changes"": 16, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/bin/json_process.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/bin/json_process.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/bin/json_process.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -37,6 +37,8 @@ struct config {\n     int sort_keys;\n     int strip;\n     int use_env;\n+    int have_hashseed;\n+    int hashseed;\n } conf;\n \n #define l_isspace(c) ((c) == ' ' || (c) == '\\n' || (c) == '\\r' || (c) == '\\t')\n@@ -108,6 +110,12 @@ static void read_conf(FILE *conffile)\n             conf.sort_keys = atoi(val);\n         if (!strcmp(line, \""STRIP\""))\n             conf.strip = atoi(val);\n+        if (!strcmp(line, \""HASHSEED\"")) {\n+            conf.have_hashseed = 1;\n+            conf.hashseed = atoi(val);\n+        } else {\n+            conf.have_hashseed = 0;\n+        }\n     }\n \n     free(buffer);\n@@ -188,6 +196,9 @@ int use_conf(char *test_path)\n     if (conf.sort_keys)\n         flags |= JSON_SORT_KEYS;\n \n+    if (conf.have_hashseed)\n+        json_object_seed(conf.hashseed);\n+\n     if (conf.strip) {\n         /* Load to memory, strip leading and trailing whitespace */\n         buffer = loadfile(infile);\n@@ -265,7 +276,10 @@ int use_env()\n         flags |= JSON_PRESERVE_ORDER;\n \n     if(getenv_int(\""JSON_SORT_KEYS\""))\n-         flags |= JSON_SORT_KEYS;\n+        flags |= JSON_SORT_KEYS;\n+\n+    if(getenv(\""HASHSEED\""))\n+        json_object_seed(getenv_int(\""HASHSEED\""));\n \n     if(getenv_int(\""STRIP\"")) {\n         /* Load to memory, strip leading and trailing whitespace */""}<_**next**_>{""sha"": ""84b17466fd0a753b8cbd714d0236ed9072cdd536"", ""filename"": ""test/suites/api/test_memory_funcs.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_memory_funcs.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_memory_funcs.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/api/test_memory_funcs.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -24,13 +24,13 @@ static void create_and_free_complex_object()\n \n static void *my_malloc(size_t size)\n {\n-    malloc_called += 1;\n+    malloc_called = 1;\n     return malloc(size);\n }\n \n static void my_free(void *ptr)\n {\n-    free_called += 1;\n+    free_called = 1;\n     free(ptr);\n }\n \n@@ -39,7 +39,7 @@ static void test_simple()\n     json_set_alloc_funcs(my_malloc, my_free);\n     create_and_free_complex_object();\n \n-    if(malloc_called != 20 || free_called != 20)\n+    if(malloc_called != 1 || free_called != 1)\n         fail(\""Custom allocation failed\"");\n }\n ""}<_**next**_>{""sha"": ""92e5208224b75ab45d93672446279d598052a83e"", ""filename"": ""test/suites/api/test_object.c"", ""status"": ""modified"", ""additions"": 40, ""deletions"": 24, ""changes"": 64, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_object.c"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/api/test_object.c"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/api/test_object.c?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -249,7 +249,11 @@ static void test_set_nocheck()\n \n static void test_iterators()\n {\n+    int i;\n     json_t *object, *foo, *bar, *baz;\n+    const char *iter_keys[3];\n+    int have_key[3] = { 0, 0, 0 };\n+    json_t *iter_values[3];\n     void *iter;\n \n     if(json_object_iter(NULL))\n@@ -276,30 +280,50 @@ static void test_iterators()\n     iter = json_object_iter(object);\n     if(!iter)\n         fail(\""unable to get iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""a\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != foo)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[0] = json_object_iter_key(iter);\n+    iter_values[0] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""b\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != bar)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[1] = json_object_iter_key(iter);\n+    iter_values[1] = json_object_iter_value(iter);\n \n     iter = json_object_iter_next(object, iter);\n     if(!iter)\n         fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\""iterating failed: wrong value\"");\n+    iter_keys[2] = json_object_iter_key(iter);\n+    iter_values[2] = json_object_iter_value(iter);\n \n     if(json_object_iter_next(object, iter) != NULL)\n         fail(\""able to iterate over the end\"");\n \n+    /* Check that keys have correct values */\n+    for (i = 0; i < 3; i++) {\n+        if (strcmp(iter_keys[i], \""a\"") == 0) {\n+            if (iter_values[i] != foo)\n+                fail(\""wrong value for iter key a\"");\n+            else\n+                have_key[0] = 1;\n+        } else if (strcmp(iter_keys[i], \""b\"") == 0) {\n+            if (iter_values[i] != bar)\n+                fail(\""wrong value for iter key b\"");\n+            else\n+                have_key[1] = 1;\n+        } else if (strcmp(iter_keys[i], \""c\"") == 0) {\n+            if (iter_values[i] != baz)\n+                fail(\""wrong value for iter key c\"");\n+            else\n+                have_key[2] = 1;\n+        }\n+    }\n+\n+    /* Check that we got all keys */\n+    for(i = 0; i < 3; i++) {\n+        if(!have_key[i])\n+            fail(\""a key wasn't iterated over\"");\n+    }\n+\n     if(json_object_iter_at(object, \""foo\""))\n         fail(\""json_object_iter_at() succeeds for non-existent key\"");\n \n@@ -312,22 +336,14 @@ static void test_iterators()\n     if(json_object_iter_value(iter) != bar)\n         fail(\""iterating failed: wrong value\"");\n \n-    iter = json_object_iter_next(object, iter);\n-    if(!iter)\n-        fail(\""unable to increment iterator\"");\n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n-        fail(\""iterating failed: wrong key\"");\n-    if(json_object_iter_value(iter) != baz)\n-        fail(\""iterating failed: wrong value\"");\n-\n-    if(json_object_iter_set(object, iter, bar))\n+    if(json_object_iter_set(object, iter, baz))\n         fail(\""unable to set value at iterator\"");\n \n-    if(strcmp(json_object_iter_key(iter), \""c\""))\n+    if(strcmp(json_object_iter_key(iter), \""b\""))\n         fail(\""json_object_iter_key() fails after json_object_iter_set()\"");\n-    if(json_object_iter_value(iter) != bar)\n+    if(json_object_iter_value(iter) != baz)\n         fail(\""json_object_iter_value() fails after json_object_iter_set()\"");\n-    if(json_object_get(object, \""c\"") != bar)\n+    if(json_object_get(object, \""b\"") != baz)\n         fail(\""json_object_get() fails after json_object_iter_set()\"");\n \n     json_decref(object);""}<_**next**_>{""sha"": ""93cb33ddafeb9eef6ce7ad4709ce1bcbdf25b200"", ""filename"": ""test/suites/encoding-flags/compact-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/compact-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/compact-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/compact-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,2 +1,3 @@\n JSON_COMPACT=1\n-export JSON_COMPACT\n+HASHSEED=1\n+export JSON_COMPACT HASHSEED""}<_**next**_>{""sha"": ""c73acc1792963be8a5f41ff11f6e858506ada51d"", ""filename"": ""test/suites/encoding-flags/indent-compact-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-compact-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-compact-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/indent-compact-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,3 +1,4 @@\n JSON_INDENT=4\n JSON_COMPACT=1\n-export JSON_INDENT JSON_COMPACT\n+HASHSEED=1\n+export JSON_INDENT JSON_COMPACT HASHSEED""}<_**next**_>{""sha"": ""961558ca23ceca2ce6e4d07697f4018d8475f317"", ""filename"": ""test/suites/encoding-flags/indent-object/env"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/indent-object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/indent-object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -1,2 +1,3 @@\n JSON_INDENT=4\n-export JSON_INDENT\n+HASHSEED=1\n+export JSON_INDENT HASHSEED""}<_**next**_>{""sha"": ""9120b03514ec614695c2d17841ba228b102c9db6"", ""filename"": ""test/suites/encoding-flags/object/env"", ""status"": ""added"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/akheron/jansson/blob/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/object/env"", ""raw_url"": ""https://github.com/akheron/jansson/raw/8f80c2d83808150724d31793e6ade92749b1faa4/test/suites/encoding-flags/object/env"", ""contents_url"": ""https://api.github.com/repos/akheron/jansson/contents/test/suites/encoding-flags/object/env?ref=8f80c2d83808150724d31793e6ade92749b1faa4"", ""patch"": ""@@ -0,0 +1,2 @@\n+HASHSEED=1\n+export HASHSEED""}","int use_env()
{
    int indent;
    size_t flags = 0;
    json_t *json;
    json_error_t error;

    #ifdef _WIN32
    /* On Windows, set stdout and stderr to binary mode to avoid
       outputting DOS line terminators */
    _setmode(_fileno(stdout), _O_BINARY);
    _setmode(_fileno(stderr), _O_BINARY);
    #endif

    indent = getenv_int(""JSON_INDENT"");
    if(indent < 0 || indent > 255) {
        fprintf(stderr, ""invalid value for JSON_INDENT: %d\n"", indent);
        return 2;
    }

    if(indent > 0)
        flags |= JSON_INDENT(indent);

    if(getenv_int(""JSON_COMPACT"") > 0)
        flags |= JSON_COMPACT;

    if(getenv_int(""JSON_ENSURE_ASCII""))
        flags |= JSON_ENSURE_ASCII;

    if(getenv_int(""JSON_PRESERVE_ORDER""))
         flags |= JSON_PRESERVE_ORDER;
 
     if(getenv_int(""JSON_SORT_KEYS""))
        flags |= JSON_SORT_KEYS;

    if(getenv(""HASHSEED""))
        json_object_seed(getenv_int(""HASHSEED""));
 
     if(getenv_int(""STRIP"")) {
         /* Load to memory, strip leading and trailing whitespace */
        size_t size = 0, used = 0;
        char *buffer = NULL;

        while(1) {
            size_t count;

            size = (size == 0 ? 128 : size * 2);
            buffer = realloc(buffer, size);
            if(!buffer) {
                fprintf(stderr, ""Unable to allocate %d bytes\n"", (int)size);
                return 1;
            }

            count = fread(buffer + used, 1, size - used, stdin);
            if(count < size - used) {
                buffer[used + count] = '\0';
                break;
            }
            used += count;
        }

        json = json_loads(strip(buffer), 0, &error);
        free(buffer);
    }
    else
        json = json_loadf(stdin, 0, &error);

    if(!json) {
        fprintf(stderr, ""%d %d %d\n%s\n"",
            error.line, error.column,
            error.position, error.text);
        return 1;
    }

    json_dumpf(json, stdout, flags);
    json_decref(json);

    return 0;
}
","int use_env()
{
    int indent;
    size_t flags = 0;
    json_t *json;
    json_error_t error;

    #ifdef _WIN32
    /* On Windows, set stdout and stderr to binary mode to avoid
       outputting DOS line terminators */
    _setmode(_fileno(stdout), _O_BINARY);
    _setmode(_fileno(stderr), _O_BINARY);
    #endif

    indent = getenv_int(""JSON_INDENT"");
    if(indent < 0 || indent > 255) {
        fprintf(stderr, ""invalid value for JSON_INDENT: %d\n"", indent);
        return 2;
    }

    if(indent > 0)
        flags |= JSON_INDENT(indent);

    if(getenv_int(""JSON_COMPACT"") > 0)
        flags |= JSON_COMPACT;

    if(getenv_int(""JSON_ENSURE_ASCII""))
        flags |= JSON_ENSURE_ASCII;

    if(getenv_int(""JSON_PRESERVE_ORDER""))
         flags |= JSON_PRESERVE_ORDER;
 
     if(getenv_int(""JSON_SORT_KEYS""))
         flags |= JSON_SORT_KEYS;
 
     if(getenv_int(""STRIP"")) {
         /* Load to memory, strip leading and trailing whitespace */
        size_t size = 0, used = 0;
        char *buffer = NULL;

        while(1) {
            size_t count;

            size = (size == 0 ? 128 : size * 2);
            buffer = realloc(buffer, size);
            if(!buffer) {
                fprintf(stderr, ""Unable to allocate %d bytes\n"", (int)size);
                return 1;
            }

            count = fread(buffer + used, 1, size - used, stdin);
            if(count < size - used) {
                buffer[used + count] = '\0';
                break;
            }
            used += count;
        }

        json = json_loads(strip(buffer), 0, &error);
        free(buffer);
    }
    else
        json = json_loadf(stdin, 0, &error);

    if(!json) {
        fprintf(stderr, ""%d %d %d\n%s\n"",
            error.line, error.column,
            error.position, error.text);
        return 1;
    }

    json_dumpf(json, stdout, flags);
    json_decref(json);

    return 0;
}
",C,"        flags |= JSON_SORT_KEYS;

    if(getenv(""HASHSEED""))
        json_object_seed(getenv_int(""HASHSEED""));
","         flags |= JSON_SORT_KEYS;
",,"@@ -37,6 +37,8 @@ struct config {
     int sort_keys;
     int strip;
     int use_env;
+    int have_hashseed;
+    int hashseed;
 } conf;
 
 #define l_isspace(c) ((c) == ' ' || (c) == '\n' || (c) == '\r' || (c) == '\t')
@@ -108,6 +110,12 @@ static void read_conf(FILE *conffile)
             conf.sort_keys = atoi(val);
         if (!strcmp(line, ""STRIP""))
             conf.strip = atoi(val);
+        if (!strcmp(line, ""HASHSEED"")) {
+            conf.have_hashseed = 1;
+            conf.hashseed = atoi(val);
+        } else {
+            conf.have_hashseed = 0;
+        }
     }
 
     free(buffer);
@@ -188,6 +196,9 @@ int use_conf(char *test_path)
     if (conf.sort_keys)
         flags |= JSON_SORT_KEYS;
 
+    if (conf.have_hashseed)
+        json_object_seed(conf.hashseed);
+
     if (conf.strip) {
         /* Load to memory, strip leading and trailing whitespace */
         buffer = loadfile(infile);
@@ -265,7 +276,10 @@ int use_env()
         flags |= JSON_PRESERVE_ORDER;
 
     if(getenv_int(""JSON_SORT_KEYS""))
-         flags |= JSON_SORT_KEYS;
+        flags |= JSON_SORT_KEYS;
+
+    if(getenv(""HASHSEED""))
+        json_object_seed(getenv_int(""HASHSEED""));
 
     if(getenv_int(""STRIP"")) {
         /* Load to memory, strip leading and trailing whitespace */",jansson,8f80c2d83808150724d31793e6ade92749b1faa4,b9c588de3deb4efdd7b9ec44aa79335dba11fd6b,1,"int use_env()
{
    int indent;
    size_t flags = 0;
    json_t *json;
    json_error_t error;

    #ifdef _WIN32
    /* On Windows, set stdout and stderr to binary mode to avoid
       outputting DOS line terminators */
    _setmode(_fileno(stdout), _O_BINARY);
    _setmode(_fileno(stderr), _O_BINARY);
    #endif

    indent = getenv_int(""JSON_INDENT"");
    if(indent < 0 || indent > 255) {
        fprintf(stderr, ""invalid value for JSON_INDENT: %d\n"", indent);
        return 2;
    }

    if(indent > 0)
        flags |= JSON_INDENT(indent);

    if(getenv_int(""JSON_COMPACT"") > 0)
        flags |= JSON_COMPACT;

    if(getenv_int(""JSON_ENSURE_ASCII""))
        flags |= JSON_ENSURE_ASCII;

    if(getenv_int(""JSON_PRESERVE_ORDER""))
         flags |= JSON_PRESERVE_ORDER;
 
     if(getenv_int(""JSON_SORT_KEYS""))
//flaw_line_below:
         flags |= JSON_SORT_KEYS;
//fix_flaw_line_below:
//        flags |= JSON_SORT_KEYS;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//    if(getenv(""HASHSEED""))
//fix_flaw_line_below:
//        json_object_seed(getenv_int(""HASHSEED""));
 
     if(getenv_int(""STRIP"")) {
         /* Load to memory, strip leading and trailing whitespace */
        size_t size = 0, used = 0;
        char *buffer = NULL;

        while(1) {
            size_t count;

            size = (size == 0 ? 128 : size * 2);
            buffer = realloc(buffer, size);
            if(!buffer) {
                fprintf(stderr, ""Unable to allocate %d bytes\n"", (int)size);
                return 1;
            }

            count = fread(buffer + used, 1, size - used, stdin);
            if(count < size - used) {
                buffer[used + count] = '\0';
                break;
            }
            used += count;
        }

        json = json_loads(strip(buffer), 0, &error);
        free(buffer);
    }
    else
        json = json_loadf(stdin, 0, &error);

    if(!json) {
        fprintf(stderr, ""%d %d %d\n%s\n"",
            error.line, error.column,
            error.position, error.text);
        return 1;
    }

    json_dumpf(json, stdout, flags);
    json_decref(json);

    return 0;
}
"
1975,179711,,Remote,Not required,Partial,CVE-2013-6371,https://www.cvedetails.com/cve/CVE-2013-6371/,CWE-310,Low,,,,2014-04-22,5.0,"The hash functionality in json-c before 0.12 allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted JSON data, involving collisions.",2017-08-28,DoS ,10,https://github.com/json-c/json-c/commit/64e36901a0614bf64a19bc3396469c66dcd0b015,64e36901a0614bf64a19bc3396469c66dcd0b015,"Patch to address the following issues:

* CVE-2013-6371: hash collision denial of service
* CVE-2013-6370: buffer overflow if size_t is larger than int",0,json_tokener.c,"{""sha"": ""26ced27080d291984cdc671cee334a870b71e765"", ""filename"": ""Makefile.am"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/json-c/json-c/blob/64e36901a0614bf64a19bc3396469c66dcd0b015/Makefile.am"", ""raw_url"": ""https://github.com/json-c/json-c/raw/64e36901a0614bf64a19bc3396469c66dcd0b015/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/json-c/json-c/contents/Makefile.am?ref=64e36901a0614bf64a19bc3396469c66dcd0b015"", ""patch"": ""@@ -23,7 +23,8 @@ libjson_cinclude_HEADERS = \\\n \tjson_tokener.h \\\n \tjson_util.h \\\n \tlinkhash.h \\\n-\tprintbuf.h\n+\tprintbuf.h \\\n+\trandom_seed.h\n \n #libjsonx_includedir = $(libdir)/json-c-@VERSION@\n #\n@@ -41,7 +42,8 @@ libjson_c_la_SOURCES = \\\n \tjson_tokener.c \\\n \tjson_util.c \\\n \tlinkhash.c \\\n-\tprintbuf.c\n+\tprintbuf.c \\\n+\trandom_seed.c\n \n \n distclean-local:""}<_**next**_>{""sha"": ""fec591b6cf31b2ac4181caa6ac7b4e2d36e4efcf"", ""filename"": ""Makefile.am.inc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/json-c/json-c/blob/64e36901a0614bf64a19bc3396469c66dcd0b015/Makefile.am.inc"", ""raw_url"": ""https://github.com/json-c/json-c/raw/64e36901a0614bf64a19bc3396469c66dcd0b015/Makefile.am.inc"", ""contents_url"": ""https://api.github.com/repos/json-c/json-c/contents/Makefile.am.inc?ref=64e36901a0614bf64a19bc3396469c66dcd0b015"", ""patch"": ""@@ -1,2 +1,2 @@\n-AM_CFLAGS = -Wall -Werror -Wextra -Wwrite-strings -Wno-unused-parameter -std=gnu99 -D_GNU_SOURCE -D_REENTRANT\n+AM_CFLAGS = -Wall -Werror -Wno-error=deprecated-declarations -Wextra -Wwrite-strings -Wno-unused-parameter -std=gnu99 -D_GNU_SOURCE -D_REENTRANT\n ""}<_**next**_>{""sha"": ""0dcab1a30015f1c1b7c4ea5df425f67b07eaf8f1"", ""filename"": ""config.h.in"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/json-c/json-c/blob/64e36901a0614bf64a19bc3396469c66dcd0b015/config.h.in"", ""raw_url"": ""https://github.com/json-c/json-c/raw/64e36901a0614bf64a19bc3396469c66dcd0b015/config.h.in"", ""contents_url"": ""https://api.github.com/repos/json-c/json-c/contents/config.h.in?ref=64e36901a0614bf64a19bc3396469c66dcd0b015"", ""patch"": ""@@ -1,5 +1,8 @@\n /* config.h.in.  Generated from configure.ac by autoheader.  */\n \n+/* Enable RDRANR Hardware RNG Hash Seed */\n+#undef ENABLE_RDRAND\n+\n /* Define if .gnu.warning accepts long strings. */\n #undef HAS_GNU_WARNING_LONG\n \n@@ -32,6 +35,9 @@\n /* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */\n #undef HAVE_DOPRNT\n \n+/* Define to 1 if you have the <endian.h> header file. */\n+#undef HAVE_ENDIAN_H\n+\n /* Define to 1 if you have the <fcntl.h> header file. */\n #undef HAVE_FCNTL_H\n ""}<_**next**_>{""sha"": ""48c8e5f382f4e7094b0ba4671e3f190ba50159ca"", ""filename"": ""configure.ac"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 1, ""changes"": 16, ""blob_url"": ""https://github.com/json-c/json-c/blob/64e36901a0614bf64a19bc3396469c66dcd0b015/configure.ac"", ""raw_url"": ""https://github.com/json-c/json-c/raw/64e36901a0614bf64a19bc3396469c66dcd0b015/configure.ac"", ""contents_url"": ""https://api.github.com/repos/json-c/json-c/contents/configure.ac?ref=64e36901a0614bf64a19bc3396469c66dcd0b015"", ""patch"": ""@@ -7,6 +7,20 @@ AM_INIT_AUTOMAKE\n \n AC_PROG_MAKE_SET\n \n+AC_ARG_ENABLE(rdrand,\n+ AS_HELP_STRING([--enable-rdrand],\n+   [Enable RDRAND Hardware RNG Hash Seed generation on supported x86/x64 platforms.]),\n+[if test x$enableval = xyes; then\n+  enable_rdrand=yes\n+  AC_DEFINE(ENABLE_RDRAND, 1, [Enable RDRANR Hardware RNG Hash Seed])\n+fi])\n+\n+if test \""x$enable_rdrand\"" = \""xyes\""; then\n+  AC_MSG_RESULT([RDRAND Hardware RNG Hash Seed enabled on supported x86/x64 platforms])\n+else\n+  AC_MSG_RESULT([RDRAND Hardware RNG Hash Seed disabled. Use --enable-rdrand to enable])\n+fi\n+\n # Checks for programs.\n \n # Checks for libraries.\n@@ -16,7 +30,7 @@ AM_PROG_CC_C_O\n AC_CONFIG_HEADER(config.h)\n AC_CONFIG_HEADER(json_config.h)\n AC_HEADER_STDC\n-AC_CHECK_HEADERS(fcntl.h limits.h strings.h syslog.h unistd.h [sys/cdefs.h] [sys/param.h] stdarg.h locale.h)\n+AC_CHECK_HEADERS(fcntl.h limits.h strings.h syslog.h unistd.h [sys/cdefs.h] [sys/param.h] stdarg.h locale.h endian.h)\n AC_CHECK_HEADER(inttypes.h,[AC_DEFINE([JSON_C_HAVE_INTTYPES_H],[1],[Public define for json_inttypes.h])])\n \n # Checks for typedefs, structures, and compiler characteristics.""}<_**next**_>{""sha"": ""200ac4031d4707e802a92059bd21e13579983eeb"", ""filename"": ""json_object.h"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 2, ""changes"": 12, ""blob_url"": ""https://github.com/json-c/json-c/blob/64e36901a0614bf64a19bc3396469c66dcd0b015/json_object.h"", ""raw_url"": ""https://github.com/json-c/json-c/raw/64e36901a0614bf64a19bc3396469c66dcd0b015/json_object.h"", ""contents_url"": ""https://api.github.com/repos/json-c/json-c/contents/json_object.h?ref=64e36901a0614bf64a19bc3396469c66dcd0b015"", ""patch"": ""@@ -13,6 +13,14 @@\n #ifndef _json_object_h_\n #define _json_object_h_\n \n+#ifdef __GNUC__\n+#define THIS_FUNCTION_IS_DEPRECATED(func) func __attribute__ ((deprecated))\n+#elif defined(_MSC_VER)\n+#define THIS_FUNCTION_IS_DEPRECATED(func) __declspec(deprecated) func\n+#else\n+#define THIS_FUNCTION_IS_DEPRECATED(func) func\n+#endif\n+\n #include \""json_inttypes.h\""\n \n #ifdef __cplusplus\n@@ -279,8 +287,8 @@ extern void json_object_object_add(struct json_object* obj, const char *key,\n  * @returns the json_object associated with the given field name\n  * @deprecated Please use json_object_object_get_ex\n  */\n-extern struct json_object* json_object_object_get(struct json_object* obj,\n-\t\t\t\t\t\t  const char *key);\n+THIS_FUNCTION_IS_DEPRECATED(extern struct json_object* json_object_object_get(struct json_object* obj,\n+\t\t\t\t\t\t  const char *key));\n \n /** Get the json_object associated with a given object field.  \n  *""}<_**next**_>{""sha"": ""19de8efc7a42a4b721535d7d0f4649a562e58a35"", ""filename"": ""json_tokener.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/json-c/json-c/blob/64e36901a0614bf64a19bc3396469c66dcd0b015/json_tokener.c"", ""raw_url"": ""https://github.com/json-c/json-c/raw/64e36901a0614bf64a19bc3396469c66dcd0b015/json_tokener.c"", ""contents_url"": ""https://api.github.com/repos/json-c/json-c/contents/json_tokener.c?ref=64e36901a0614bf64a19bc3396469c66dcd0b015"", ""patch"": ""@@ -81,6 +81,7 @@ static const char* json_tokener_errors[] = {\n   \""object value separator ',' expected\"",\n   \""invalid string sequence\"",\n   \""expected comment\"",\n+  \""buffer size overflow\""\n };\n \n const char *json_tokener_error_desc(enum json_tokener_error jerr)\n@@ -243,6 +244,16 @@ struct json_object* json_tokener_parse_ex(struct json_tokener *tok,\n   tok->char_offset = 0;\n   tok->err = json_tokener_success;\n \n+  /* this interface is presently not 64-bit clean due to the int len argument\n+     and the internal printbuf interface that takes 32-bit int len arguments\n+     so the function limits the maximum string size to INT32_MAX (2GB).\n+     If the function is called with len == -1 then strlen is called to check\n+     the string length is less than INT32_MAX (2GB) */\n+  if ((len < -1) || (len == -1 && strlen(str) > INT32_MAX)) {\n+    tok->err = json_tokener_error_size;\n+    return NULL;\n+  }\n+\n   while (PEEK_CHAR(c, tok)) {\n \n   redo_char:""}<_**next**_>{""sha"": ""a72d2bdefe0064552effd1b4a373ed8335f61a80"", ""filename"": ""json_tokener.h"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 1, ""changes"": 8, ""blob_url"": ""https://github.com/json-c/json-c/blob/64e36901a0614bf64a19bc3396469c66dcd0b015/json_tokener.h"", ""raw_url"": ""https://github.com/json-c/json-c/raw/64e36901a0614bf64a19bc3396469c66dcd0b015/json_tokener.h"", ""contents_url"": ""https://api.github.com/repos/json-c/json-c/contents/json_tokener.h?ref=64e36901a0614bf64a19bc3396469c66dcd0b015"", ""patch"": ""@@ -33,7 +33,8 @@ enum json_tokener_error {\n   json_tokener_error_parse_object_key_sep,\n   json_tokener_error_parse_object_value_sep,\n   json_tokener_error_parse_string,\n-  json_tokener_error_parse_comment\n+  json_tokener_error_parse_comment,\n+  json_tokener_error_size\n };\n \n enum json_tokener_state {\n@@ -163,6 +164,11 @@ extern void json_tokener_set_flags(struct json_tokener *tok, int flags);\n  * responsible for calling json_tokener_parse_ex with an appropriate str\n  * parameter starting with the extra characters.\n  *\n+ * This interface is presently not 64-bit clean due to the int len argument\n+ * so the function limits the maximum string size to INT32_MAX (2GB).\n+ * If the function is called with len == -1 then strlen is called to check\n+ * the string length is less than INT32_MAX (2GB)\n+ *\n  * Example:\n  * @code\n json_object *jobj = NULL;""}<_**next**_>{""sha"": ""712c3879e7081a17b35b9c73f7953294d98d378c"", ""filename"": ""linkhash.c"", ""status"": ""modified"", ""additions"": 374, ""deletions"": 5, ""changes"": 379, ""blob_url"": ""https://github.com/json-c/json-c/blob/64e36901a0614bf64a19bc3396469c66dcd0b015/linkhash.c"", ""raw_url"": ""https://github.com/json-c/json-c/raw/64e36901a0614bf64a19bc3396469c66dcd0b015/linkhash.c"", ""contents_url"": ""https://api.github.com/repos/json-c/json-c/contents/linkhash.c?ref=64e36901a0614bf64a19bc3396469c66dcd0b015"", ""patch"": ""@@ -17,6 +17,11 @@\n #include <stddef.h>\n #include <limits.h>\n \n+#ifdef HAVE_ENDIAN_H\n+# include <endian.h>    /* attempt to define endianness */\n+#endif\n+\n+#include \""random_seed.h\""\n #include \""linkhash.h\""\n \n void lh_abort(const char *msg, ...)\n@@ -39,14 +44,378 @@ int lh_ptr_equal(const void *k1, const void *k2)\n \treturn (k1 == k2);\n }\n \n+/* \n+ * hashlittle from lookup3.c, by Bob Jenkins, May 2006, Public Domain.\n+ * http://burtleburtle.net/bob/c/lookup3.c\n+ * minor modifications to make functions static so no symbols are exported\n+ * minor mofifications to compile with -Werror\n+ */\n+\n+/*\n+-------------------------------------------------------------------------------\n+lookup3.c, by Bob Jenkins, May 2006, Public Domain.\n+\n+These are functions for producing 32-bit hashes for hash table lookup.\n+hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final() \n+are externally useful functions.  Routines to test the hash are included \n+if SELF_TEST is defined.  You can use this free for any purpose.  It's in\n+the public domain.  It has no warranty.\n+\n+You probably want to use hashlittle().  hashlittle() and hashbig()\n+hash byte arrays.  hashlittle() is is faster than hashbig() on\n+little-endian machines.  Intel and AMD are little-endian machines.\n+On second thought, you probably want hashlittle2(), which is identical to\n+hashlittle() except it returns two 32-bit hashes for the price of one.  \n+You could implement hashbig2() if you wanted but I haven't bothered here.\n+\n+If you want to find a hash of, say, exactly 7 integers, do\n+  a = i1;  b = i2;  c = i3;\n+  mix(a,b,c);\n+  a += i4; b += i5; c += i6;\n+  mix(a,b,c);\n+  a += i7;\n+  final(a,b,c);\n+then use c as the hash value.  If you have a variable length array of\n+4-byte integers to hash, use hashword().  If you have a byte array (like\n+a character string), use hashlittle().  If you have several byte arrays, or\n+a mix of things, see the comments above hashlittle().  \n+\n+Why is this so big?  I read 12 bytes at a time into 3 4-byte integers, \n+then mix those integers.  This is fast (you can do a lot more thorough\n+mixing with 12*3 instructions on 3 integers than you can with 3 instructions\n+on 1 byte), but shoehorning those bytes into integers efficiently is messy.\n+-------------------------------------------------------------------------------\n+*/\n+\n+/*\n+ * My best guess at if you are big-endian or little-endian.  This may\n+ * need adjustment.\n+ */\n+#if (defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && \\\n+     __BYTE_ORDER == __LITTLE_ENDIAN) || \\\n+    (defined(i386) || defined(__i386__) || defined(__i486__) || \\\n+     defined(__i586__) || defined(__i686__) || defined(vax) || defined(MIPSEL))\n+# define HASH_LITTLE_ENDIAN 1\n+# define HASH_BIG_ENDIAN 0\n+#elif (defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && \\\n+       __BYTE_ORDER == __BIG_ENDIAN) || \\\n+      (defined(sparc) || defined(POWERPC) || defined(mc68000) || defined(sel))\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 1\n+#else\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 0\n+#endif\n+\n+#define hashsize(n) ((uint32_t)1<<(n))\n+#define hashmask(n) (hashsize(n)-1)\n+#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n+\n+/*\n+-------------------------------------------------------------------------------\n+mix -- mix 3 32-bit values reversibly.\n+\n+This is reversible, so any information in (a,b,c) before mix() is\n+still in (a,b,c) after mix().\n+\n+If four pairs of (a,b,c) inputs are run through mix(), or through\n+mix() in reverse, there are at least 32 bits of the output that\n+are sometimes the same for one pair and different for another pair.\n+This was tested for:\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+Some k values for my \""a-=c; a^=rot(c,k); c+=b;\"" arrangement that\n+satisfy this are\n+    4  6  8 16 19  4\n+    9 15  3 18 27 15\n+   14  9  3  7 17  3\n+Well, \""9 15 3 18 27 15\"" didn't quite get 32 bits diffing\n+for \""differ\"" defined as + with a one-bit base and a two-bit delta.  I\n+used http://burtleburtle.net/bob/hash/avalanche.html to choose \n+the operations, constants, and arrangements of the variables.\n+\n+This does not achieve avalanche.  There are input bits of (a,b,c)\n+that fail to affect some output bits of (a,b,c), especially of a.  The\n+most thoroughly mixed value is c, but it doesn't really even achieve\n+avalanche in c.\n+\n+This allows some parallelism.  Read-after-writes are good at doubling\n+the number of bits affected, so the goal of mixing pulls in the opposite\n+direction as the goal of parallelism.  I did what I could.  Rotates\n+seem to cost as much as shifts on every machine I could lay my hands\n+on, and rotates are much kinder to the top and bottom bits, so I used\n+rotates.\n+-------------------------------------------------------------------------------\n+*/\n+#define mix(a,b,c) \\\n+{ \\\n+  a -= c;  a ^= rot(c, 4);  c += b; \\\n+  b -= a;  b ^= rot(a, 6);  a += c; \\\n+  c -= b;  c ^= rot(b, 8);  b += a; \\\n+  a -= c;  a ^= rot(c,16);  c += b; \\\n+  b -= a;  b ^= rot(a,19);  a += c; \\\n+  c -= b;  c ^= rot(b, 4);  b += a; \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+final -- final mixing of 3 32-bit values (a,b,c) into c\n+\n+Pairs of (a,b,c) values differing in only a few bits will usually\n+produce values of c that look totally different.  This was tested for\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+These constants passed:\n+ 14 11 25 16 4 14 24\n+ 12 14 25 16 4 14 24\n+and these came close:\n+  4  8 15 26 3 22 24\n+ 10  8 15 26 3 22 24\n+ 11  8 15 26 3 22 24\n+-------------------------------------------------------------------------------\n+*/\n+#define final(a,b,c) \\\n+{ \\\n+  c ^= b; c -= rot(b,14); \\\n+  a ^= c; a -= rot(c,11); \\\n+  b ^= a; b -= rot(a,25); \\\n+  c ^= b; c -= rot(b,16); \\\n+  a ^= c; a -= rot(c,4);  \\\n+  b ^= a; b -= rot(a,14); \\\n+  c ^= b; c -= rot(b,24); \\\n+}\n+\n+\n+/*\n+-------------------------------------------------------------------------------\n+hashlittle() -- hash a variable-length key into a 32-bit value\n+  k       : the key (the unaligned variable-length array of bytes)\n+  length  : the length of the key, counting by bytes\n+  initval : can be any 4-byte value\n+Returns a 32-bit value.  Every bit of the key affects every bit of\n+the return value.  Two keys differing by one or two bits will have\n+totally different hash values.\n+\n+The best hash table sizes are powers of 2.  There is no need to do\n+mod a prime (mod is sooo slow!).  If you need less than 32 bits,\n+use a bitmask.  For example, if you need only 10 bits, do\n+  h = (h & hashmask(10));\n+In which case, the hash table should have hashsize(10) elements.\n+\n+If you are hashing n strings (uint8_t **)k, do it like this:\n+  for (i=0, h=0; i<n; ++i) h = hashlittle( k[i], len[i], h);\n+\n+By Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this\n+code any way you wish, private, educational, or commercial.  It's free.\n+\n+Use for hash table lookup, or anything where one collision in 2^^32 is\n+acceptable.  Do NOT use for cryptographic purposes.\n+-------------------------------------------------------------------------------\n+*/\n+\n+static uint32_t hashlittle( const void *key, size_t length, uint32_t initval)\n+{\n+  uint32_t a,b,c;                                          /* internal state */\n+  union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */\n+\n+  /* Set up the internal state */\n+  a = b = c = 0xdeadbeef + ((uint32_t)length) + initval;\n+\n+  u.ptr = key;\n+  if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0)) {\n+    const uint32_t *k = (const uint32_t *)key;         /* read 32-bit chunks */\n+\n+    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      b += k[1];\n+      c += k[2];\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 3;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    /* \n+     * \""k[2]&0xffffff\"" actually reads beyond the end of the string, but\n+     * then masks off the part it's not allowed to read.  Because the\n+     * string is aligned, the masked-off tail is in the same word as the\n+     * rest of the string.  Every machine with memory protection I've seen\n+     * does it on word boundaries, so is OK with this.  But VALGRIND will\n+     * still catch it and complain.  The masking trick does make the hash\n+     * noticably faster for short strings (like English words).\n+     */\n+#ifndef VALGRIND\n+\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n+    case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n+    case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n+    case 6 : b+=k[1]&0xffff; a+=k[0]; break;\n+    case 5 : b+=k[1]&0xff; a+=k[0]; break;\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=k[0]&0xffffff; break;\n+    case 2 : a+=k[0]&0xffff; break;\n+    case 1 : a+=k[0]&0xff; break;\n+    case 0 : return c;              /* zero length strings require no mixing */\n+    }\n+\n+#else /* make valgrind happy */\n+\n+    const uint8_t  *k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=((uint32_t)k8[10])<<16;  /* fall through */\n+    case 10: c+=((uint32_t)k8[9])<<8;    /* fall through */\n+    case 9 : c+=k8[8];                   /* fall through */\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;   /* fall through */\n+    case 6 : b+=((uint32_t)k8[5])<<8;    /* fall through */\n+    case 5 : b+=k8[4];                   /* fall through */\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;   /* fall through */\n+    case 2 : a+=((uint32_t)k8[1])<<8;    /* fall through */\n+    case 1 : a+=k8[0]; break;\n+    case 0 : return c;\n+    }\n+\n+#endif /* !valgrind */\n+\n+  } else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0)) {\n+    const uint16_t *k = (const uint16_t *)key;         /* read 16-bit chunks */\n+    const uint8_t  *k8;\n+\n+    /*--------------- all but last block: aligned reads and different mixing */\n+    while (length > 12)\n+    {\n+      a += k[0] + (((uint32_t)k[1])<<16);\n+      b += k[2] + (((uint32_t)k[3])<<16);\n+      c += k[4] + (((uint32_t)k[5])<<16);\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 6;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[4]+(((uint32_t)k[5])<<16);\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 11: c+=((uint32_t)k8[10])<<16;     /* fall through */\n+    case 10: c+=k[4];\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 9 : c+=k8[8];                      /* fall through */\n+    case 8 : b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;      /* fall through */\n+    case 6 : b+=k[2];\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 5 : b+=k8[4];                      /* fall through */\n+    case 4 : a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;      /* fall through */\n+    case 2 : a+=k[0];\n+             break;\n+    case 1 : a+=k8[0];\n+             break;\n+    case 0 : return c;                     /* zero length requires no mixing */\n+    }\n+\n+  } else {                        /* need to read the key one byte at a time */\n+    const uint8_t *k = (const uint8_t *)key;\n+\n+    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      a += ((uint32_t)k[1])<<8;\n+      a += ((uint32_t)k[2])<<16;\n+      a += ((uint32_t)k[3])<<24;\n+      b += k[4];\n+      b += ((uint32_t)k[5])<<8;\n+      b += ((uint32_t)k[6])<<16;\n+      b += ((uint32_t)k[7])<<24;\n+      c += k[8];\n+      c += ((uint32_t)k[9])<<8;\n+      c += ((uint32_t)k[10])<<16;\n+      c += ((uint32_t)k[11])<<24;\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 12;\n+    }\n+\n+    /*-------------------------------- last block: affect all 32 bits of (c) */\n+    switch(length)                   /* all the case statements fall through */\n+    {\n+    case 12: c+=((uint32_t)k[11])<<24;\n+    case 11: c+=((uint32_t)k[10])<<16;\n+    case 10: c+=((uint32_t)k[9])<<8;\n+    case 9 : c+=k[8];\n+    case 8 : b+=((uint32_t)k[7])<<24;\n+    case 7 : b+=((uint32_t)k[6])<<16;\n+    case 6 : b+=((uint32_t)k[5])<<8;\n+    case 5 : b+=k[4];\n+    case 4 : a+=((uint32_t)k[3])<<24;\n+    case 3 : a+=((uint32_t)k[2])<<16;\n+    case 2 : a+=((uint32_t)k[1])<<8;\n+    case 1 : a+=k[0];\n+             break;\n+    case 0 : return c;\n+    }\n+  }\n+\n+  final(a,b,c);\n+  return c;\n+}\n+\n unsigned long lh_char_hash(const void *k)\n {\n-\tunsigned int h = 0;\n-\tconst char* data = (const char*)k;\n- \n-\twhile( *data!=0 ) h = h*129 + (unsigned int)(*data++) + LH_PRIME;\n+\tstatic volatile int random_seed = -1;\n+\n+\tif (random_seed == -1) {\n+\t\tint seed;\n+\t\t/* we can't use -1 as it is the unitialized sentinel */\n+\t\twhile ((seed = json_c_get_random_seed()) == -1);\n+#if defined __GNUC__\n+\t\t__sync_val_compare_and_swap(&random_seed, -1, seed);\n+#elif defined _MSC_VER\n+\t\tInterlockedCompareExchange(&random_seed, seed, -1);\n+#else\n+#warning \""racy random seed initializtion if used by multiple threads\""\n+\t\trandom_seed = seed; /* potentially racy */\n+#endif\n+\t}\n \n-\treturn h;\n+\treturn hashlittle((const char*)k, strlen((const char*)k), random_seed); \n }\n \n int lh_char_equal(const void *k1, const void *k2)""}<_**next**_>{""sha"": ""950d09f35d70cf026852c9d50cb85a3129944e3c"", ""filename"": ""linkhash.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/json-c/json-c/blob/64e36901a0614bf64a19bc3396469c66dcd0b015/linkhash.h"", ""raw_url"": ""https://github.com/json-c/json-c/raw/64e36901a0614bf64a19bc3396469c66dcd0b015/linkhash.h"", ""contents_url"": ""https://api.github.com/repos/json-c/json-c/contents/linkhash.h?ref=64e36901a0614bf64a19bc3396469c66dcd0b015"", ""patch"": ""@@ -246,7 +246,7 @@ extern struct lh_entry* lh_table_lookup_entry(struct lh_table *t, const void *k)\n  * @return a pointer to the found value or NULL if it does not exist.\n  * @deprecated Use lh_table_lookup_ex instead.\n  */\n-extern const void* lh_table_lookup(struct lh_table *t, const void *k);\n+THIS_FUNCTION_IS_DEPRECATED(extern const void* lh_table_lookup(struct lh_table *t, const void *k));\n \n /**\n  * Lookup a record in the table""}<_**next**_>{""sha"": ""3b520d411e8a8a161f5cc256e1d98a91c8e2b3e8"", ""filename"": ""random_seed.c"", ""status"": ""added"", ""additions"": 237, ""deletions"": 0, ""changes"": 237, ""blob_url"": ""https://github.com/json-c/json-c/blob/64e36901a0614bf64a19bc3396469c66dcd0b015/random_seed.c"", ""raw_url"": ""https://github.com/json-c/json-c/raw/64e36901a0614bf64a19bc3396469c66dcd0b015/random_seed.c"", ""contents_url"": ""https://api.github.com/repos/json-c/json-c/contents/random_seed.c?ref=64e36901a0614bf64a19bc3396469c66dcd0b015"", ""patch"": ""@@ -0,0 +1,237 @@\n+/*\n+ * random_seed.c\n+ *\n+ * Copyright (c) 2013 Metaparadigm Pte. Ltd.\n+ * Michael Clark <michael@metaparadigm.com>\n+ *\n+ * This library is free software; you can redistribute it and/or modify\n+ * it under the terms of the MIT license. See COPYING for details.\n+ *\n+ */\n+\n+#include <stdio.h>\n+#include \""config.h\""\n+\n+#define DEBUG_SEED(s)\n+\n+\n+#if defined ENABLE_RDRAND\n+\n+/* cpuid */\n+\n+#if defined __GNUC__ && (defined __i386__ || defined __x86_64__)\n+#define HAS_X86_CPUID 1\n+\n+static void do_cpuid(int regs[], int h)\n+{\n+    __asm__ __volatile__(\n+#if defined __x86_64__\n+                         \""pushq %%rbx;\\n\""\n+#else\n+                         \""pushl %%ebx;\\n\""\n+#endif\n+                         \""cpuid;\\n\""\n+#if defined __x86_64__\n+                         \""popq %%rbx;\\n\""\n+#else\n+                         \""popl %%ebx;\\n\""\n+#endif\n+                         : \""=a\""(regs[0]), [ebx] \""=r\""(regs[1]), \""=c\""(regs[2]), \""=d\""(regs[3])\n+                         : \""a\""(h));\n+}\n+\n+#elif defined _MSC_VER\n+\n+#define HAS_X86_CPUID 1\n+#define do_cpuid __cpuid\n+\n+#endif\n+\n+/* has_rdrand */\n+\n+#if HAS_X86_CPUID\n+\n+static int has_rdrand()\n+{\n+    // CPUID.01H:ECX.RDRAND[bit 30] == 1\n+    int regs[4];\n+    do_cpuid(regs, 1);\n+    return (regs[2] & (1 << 30)) != 0;\n+}\n+\n+#endif\n+\n+/* get_rdrand_seed - GCC x86 and X64 */\n+\n+#if defined __GNUC__ && (defined __i386__ || defined __x86_64__)\n+\n+#define HAVE_RDRAND 1\n+\n+static int get_rdrand_seed()\n+{\n+    DEBUG_SEED(\""get_rdrand_seed\"");\n+    int _eax;\n+    // rdrand eax\n+    __asm__ __volatile__(\""1: .byte 0x0F\\n\""\n+                         \""   .byte 0xC7\\n\""\n+                         \""   .byte 0xF0\\n\""\n+                         \""   jnc 1b;\\n\""\n+                         : \""=a\"" (_eax));\n+    return _eax;\n+}\n+\n+#endif\n+\n+#if defined _MSC_VER\n+\n+#if _MSC_VER >= 1700\n+#define HAVE_RDRAND 1\n+\n+/* get_rdrand_seed - Visual Studio 2012 and above */\n+\n+static int get_rdrand_seed()\n+{\n+    DEBUG_SEED(\""get_rdrand_seed\"");\n+    int r;\n+    while (_rdrand32_step(&r) == 0);\n+    return r;\n+}\n+\n+#elif defined _M_IX86\n+#define HAVE_RDRAND 1\n+\n+/* get_rdrand_seed - Visual Studio 2010 and below - x86 only */\n+\n+static int get_rdrand_seed()\n+{\n+\tDEBUG_SEED(\""get_rdrand_seed\"");\n+\tint _eax;\n+retry:\n+\t// rdrand eax\n+\t__asm _emit 0x0F __asm _emit 0xC7 __asm _emit 0xF0\n+\t__asm jnc retry\n+\t__asm mov _eax, eax\n+\treturn _eax;\n+}\n+\n+#endif\n+#endif\n+\n+#endif /* defined ENABLE_RDRAND */\n+\n+\n+/* has_dev_urandom */\n+\n+#if defined (__APPLE__) || defined(__unix__) || defined(__linux__)\n+\n+#include <string.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+#include <errno.h>\n+#include <stdlib.h>\n+#include <sys/stat.h>\n+\n+#define HAVE_DEV_RANDOM 1\n+\n+static const char *dev_random_file = \""/dev/urandom\"";\n+\n+static int has_dev_urandom()\n+{\n+    struct stat buf;\n+    if (stat(dev_random_file, &buf)) {\n+        return 0;\n+    }\n+    return ((buf.st_mode & S_IFCHR) != 0);\n+}\n+\n+\n+/* get_dev_random_seed */\n+\n+static int get_dev_random_seed()\n+{\n+    DEBUG_SEED(\""get_dev_random_seed\"");\n+    \n+    int fd = open(dev_random_file, O_RDONLY);\n+    if (fd < 0) {\n+        fprintf(stderr, \""error opening %s: %s\"", dev_random_file, strerror(errno));\n+        exit(1);\n+    }\n+    \n+    int r;\n+    ssize_t nread = read(fd, &r, sizeof(r));\n+    if (nread != sizeof(r)) {\n+        fprintf(stderr, \""error read %s: %s\"", dev_random_file, strerror(errno));\n+        exit(1);\n+    }\n+    else if (nread != sizeof(r)) {\n+        fprintf(stderr, \""error short read %s\"", dev_random_file);\n+        exit(1);\n+    }\n+    close(fd);\n+    return r;\n+}\n+\n+#endif\n+\n+\n+/* get_cryptgenrandom_seed */\n+\n+#ifdef WIN32\n+\n+#define HAVE_CRYPTGENRANDOM 1\n+\n+#include <windows.h>\n+#pragma comment(lib, \""advapi32.lib\"")\n+\n+static int get_cryptgenrandom_seed()\n+{\n+    DEBUG_SEED(\""get_cryptgenrandom_seed\"");\n+    \n+    HCRYPTPROV hProvider = 0;\n+    int r;\n+    \n+    if (!CryptAcquireContextW(&hProvider, 0, 0, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_SILENT)) {\n+        fprintf(stderr, \""error CryptAcquireContextW\"");\n+        exit(1);\n+    }\n+    \n+    if (!CryptGenRandom(hProvider, sizeof(r), (BYTE*)&r)) {\n+        fprintf(stderr, \""error CryptGenRandom\"");\n+        exit(1);\n+    }\n+    \n+    CryptReleaseContext(hProvider, 0);\n+    \n+    return r;\n+}\n+\n+#endif\n+\n+\n+/* get_time_seed */\n+\n+#include <time.h>\n+\n+static int get_time_seed()\n+{\n+    DEBUG_SEED(\""get_time_seed\"");\n+    \n+    return (int)time(NULL) * 433494437;\n+}\n+\n+\n+/* json_c_get_random_seed */\n+\n+int json_c_get_random_seed()\n+{\n+#if HAVE_RDRAND\n+    if (has_rdrand()) return get_rdrand_seed();\n+#endif\n+#if HAVE_DEV_RANDOM\n+    if (has_dev_urandom()) return get_dev_random_seed();\n+#endif\n+#if HAVE_CRYPTGENRANDOM\n+    return get_cryptgenrandom_seed();\n+#endif\n+    return get_time_seed();\n+}""}<_**next**_>{""sha"": ""7362d67d9cd5431ca95fdfb361aef9af0b79b84e"", ""filename"": ""random_seed.h"", ""status"": ""added"", ""additions"": 25, ""deletions"": 0, ""changes"": 25, ""blob_url"": ""https://github.com/json-c/json-c/blob/64e36901a0614bf64a19bc3396469c66dcd0b015/random_seed.h"", ""raw_url"": ""https://github.com/json-c/json-c/raw/64e36901a0614bf64a19bc3396469c66dcd0b015/random_seed.h"", ""contents_url"": ""https://api.github.com/repos/json-c/json-c/contents/random_seed.h?ref=64e36901a0614bf64a19bc3396469c66dcd0b015"", ""patch"": ""@@ -0,0 +1,25 @@\n+/*\n+ * random_seed.h\n+ *\n+ * Copyright (c) 2013 Metaparadigm Pte. Ltd.\n+ * Michael Clark <michael@metaparadigm.com>\n+ *\n+ * This library is free software; you can redistribute it and/or modify\n+ * it under the terms of the MIT license. See COPYING for details.\n+ *\n+ */\n+\n+#ifndef seed_h\n+#define seed_h\n+\n+#ifdef __cplusplus\n+extern \""C\"" {\n+#endif\n+\n+extern int json_c_get_random_seed();\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif""}","struct json_object* json_tokener_parse_ex(struct json_tokener *tok,
					  const char *str, int len)
{
  struct json_object *obj = NULL;
  char c = '\1';
#ifdef HAVE_SETLOCALE
  char *oldlocale=NULL, *tmplocale;

  tmplocale = setlocale(LC_NUMERIC, NULL);
  if (tmplocale) oldlocale = strdup(tmplocale);
  setlocale(LC_NUMERIC, ""C"");
#endif

   tok->char_offset = 0;
   tok->err = json_tokener_success;
 
  /* this interface is presently not 64-bit clean due to the int len argument
     and the internal printbuf interface that takes 32-bit int len arguments
     so the function limits the maximum string size to INT32_MAX (2GB).
     If the function is called with len == -1 then strlen is called to check
     the string length is less than INT32_MAX (2GB) */
  if ((len < -1) || (len == -1 && strlen(str) > INT32_MAX)) {
    tok->err = json_tokener_error_size;
    return NULL;
  }

   while (PEEK_CHAR(c, tok)) {
 
   redo_char:
    switch(state) {

    case json_tokener_state_eatws:
      /* Advance until we change state */
      while (isspace((int)c)) {
	if ((!ADVANCE_CHAR(str, tok)) || (!PEEK_CHAR(c, tok)))
	  goto out;
      }
      if(c == '/' && !(tok->flags & JSON_TOKENER_STRICT)) {
	printbuf_reset(tok->pb);
	printbuf_memappend_fast(tok->pb, &c, 1);
	state = json_tokener_state_comment_start;
      } else {
	state = saved_state;
	goto redo_char;
      }
      break;

    case json_tokener_state_start:
      switch(c) {
      case '{':
	state = json_tokener_state_eatws;
	saved_state = json_tokener_state_object_field_start;
	current = json_object_new_object();
	break;
      case '[':
	state = json_tokener_state_eatws;
	saved_state = json_tokener_state_array;
	current = json_object_new_array();
	break;
      case 'I':
      case 'i':
	state = json_tokener_state_inf;
	printbuf_reset(tok->pb);
	tok->st_pos = 0;
	goto redo_char;
      case 'N':
      case 'n':
	state = json_tokener_state_null; // or NaN
	printbuf_reset(tok->pb);
	tok->st_pos = 0;
	goto redo_char;
      case '\'':
        if (tok->flags & JSON_TOKENER_STRICT) {
            /* in STRICT mode only double-quote are allowed */
            tok->err = json_tokener_error_parse_unexpected;
            goto out;
        }
      case '""':
	state = json_tokener_state_string;
	printbuf_reset(tok->pb);
	tok->quote_char = c;
	break;
      case 'T':
      case 't':
      case 'F':
      case 'f':
	state = json_tokener_state_boolean;
	printbuf_reset(tok->pb);
	tok->st_pos = 0;
	goto redo_char;
#if defined(__GNUC__)
	  case '0' ... '9':
#else
	  case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
#endif
      case '-':
	state = json_tokener_state_number;
	printbuf_reset(tok->pb);
	tok->is_double = 0;
	goto redo_char;
      default:
	tok->err = json_tokener_error_parse_unexpected;
	goto out;
      }
      break;

    case json_tokener_state_finish:
      if(tok->depth == 0) goto out;
      obj = json_object_get(current);
      json_tokener_reset_level(tok, tok->depth);
      tok->depth--;
      goto redo_char;

    case json_tokener_state_inf: /* aka starts with 'i' */
      {
	int size;
	int size_inf;
	int is_negative = 0;

	printbuf_memappend_fast(tok->pb, &c, 1);
	size = json_min(tok->st_pos+1, json_null_str_len);
	size_inf = json_min(tok->st_pos+1, json_inf_str_len);
	char *infbuf = tok->pb->buf;
	if (*infbuf == '-')
	{
		infbuf++;
		is_negative = 1;
	}
	if ((!(tok->flags & JSON_TOKENER_STRICT) &&
	          strncasecmp(json_inf_str, infbuf, size_inf) == 0) ||
	         (strncmp(json_inf_str, infbuf, size_inf) == 0)
	        )
	{
		if (tok->st_pos == json_inf_str_len)
		{
			current = json_object_new_double(is_negative ? -INFINITY : INFINITY); 
			saved_state = json_tokener_state_finish;
			state = json_tokener_state_eatws;
			goto redo_char;
		}
	} else {
		tok->err = json_tokener_error_parse_unexpected;
		goto out;
	}
	tok->st_pos++;
      }
      break;
    case json_tokener_state_null: /* aka starts with 'n' */
      {
	int size;
	int size_nan;
	printbuf_memappend_fast(tok->pb, &c, 1);
	size = json_min(tok->st_pos+1, json_null_str_len);
	size_nan = json_min(tok->st_pos+1, json_nan_str_len);
	if((!(tok->flags & JSON_TOKENER_STRICT) &&
	  strncasecmp(json_null_str, tok->pb->buf, size) == 0)
	  || (strncmp(json_null_str, tok->pb->buf, size) == 0)
	  ) {
	  if (tok->st_pos == json_null_str_len) {
	    current = NULL;
	    saved_state = json_tokener_state_finish;
	    state = json_tokener_state_eatws;
	    goto redo_char;
	  }
	}
	else if ((!(tok->flags & JSON_TOKENER_STRICT) &&
	          strncasecmp(json_nan_str, tok->pb->buf, size_nan) == 0) ||
	         (strncmp(json_nan_str, tok->pb->buf, size_nan) == 0)
	        )
	{
		if (tok->st_pos == json_nan_str_len)
		{
			current = json_object_new_double(NAN);
			saved_state = json_tokener_state_finish;
			state = json_tokener_state_eatws;
			goto redo_char;
		}
	} else {
	  tok->err = json_tokener_error_parse_null;
	  goto out;
	}
	tok->st_pos++;
      }
      break;

    case json_tokener_state_comment_start:
      if(c == '*') {
	state = json_tokener_state_comment;
      } else if(c == '/') {
	state = json_tokener_state_comment_eol;
      } else {
	tok->err = json_tokener_error_parse_comment;
	goto out;
      }
      printbuf_memappend_fast(tok->pb, &c, 1);
      break;

    case json_tokener_state_comment:
              {
          /* Advance until we change state */
          const char *case_start = str;
          while(c != '*') {
            if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {
              printbuf_memappend_fast(tok->pb, case_start, str-case_start);
              goto out;
            }
          }
          printbuf_memappend_fast(tok->pb, case_start, 1+str-case_start);
          state = json_tokener_state_comment_end;
        }
            break;

    case json_tokener_state_comment_eol:
      {
	/* Advance until we change state */
	const char *case_start = str;
	while(c != '\n') {
	  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {
	    printbuf_memappend_fast(tok->pb, case_start, str-case_start);
	    goto out;
	  }
	}
	printbuf_memappend_fast(tok->pb, case_start, str-case_start);
	MC_DEBUG(""json_tokener_comment: %s\n"", tok->pb->buf);
	state = json_tokener_state_eatws;
      }
      break;

    case json_tokener_state_comment_end:
      printbuf_memappend_fast(tok->pb, &c, 1);
      if(c == '/') {
	MC_DEBUG(""json_tokener_comment: %s\n"", tok->pb->buf);
	state = json_tokener_state_eatws;
      } else {
	state = json_tokener_state_comment;
      }
      break;

    case json_tokener_state_string:
      {
	/* Advance until we change state */
	const char *case_start = str;
	while(1) {
	  if(c == tok->quote_char) {
	    printbuf_memappend_fast(tok->pb, case_start, str-case_start);
	    current = json_object_new_string_len(tok->pb->buf, tok->pb->bpos);
	    saved_state = json_tokener_state_finish;
	    state = json_tokener_state_eatws;
	    break;
	  } else if(c == '\\') {
	    printbuf_memappend_fast(tok->pb, case_start, str-case_start);
	    saved_state = json_tokener_state_string;
	    state = json_tokener_state_string_escape;
	    break;
	  }
	  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {
	    printbuf_memappend_fast(tok->pb, case_start, str-case_start);
	    goto out;
	  }
	}
      }
      break;

    case json_tokener_state_string_escape:
      switch(c) {
      case '""':
      case '\\':
      case '/':
	printbuf_memappend_fast(tok->pb, &c, 1);
	state = saved_state;
	break;
      case 'b':
      case 'n':
      case 'r':
      case 't':
      case 'f':
	if(c == 'b') printbuf_memappend_fast(tok->pb, ""\b"", 1);
	else if(c == 'n') printbuf_memappend_fast(tok->pb, ""\n"", 1);
	else if(c == 'r') printbuf_memappend_fast(tok->pb, ""\r"", 1);
	else if(c == 't') printbuf_memappend_fast(tok->pb, ""\t"", 1);
	else if(c == 'f') printbuf_memappend_fast(tok->pb, ""\f"", 1);
	state = saved_state;
	break;
      case 'u':
	tok->ucs_char = 0;
	tok->st_pos = 0;
	state = json_tokener_state_escape_unicode;
	break;
      default:
	tok->err = json_tokener_error_parse_string;
	goto out;
      }
      break;

    case json_tokener_state_escape_unicode:
	{
          unsigned int got_hi_surrogate = 0;

	  /* Handle a 4-byte sequence, or two sequences if a surrogate pair */
	  while(1) {
	    if(strchr(json_hex_chars, c)) {
	      tok->ucs_char += ((unsigned int)hexdigit(c) << ((3-tok->st_pos++)*4));
	      if(tok->st_pos == 4) {
		unsigned char unescaped_utf[4];

                if (got_hi_surrogate) {
		  if (IS_LOW_SURROGATE(tok->ucs_char)) {
                    /* Recalculate the ucs_char, then fall thru to process normally */
                    tok->ucs_char = DECODE_SURROGATE_PAIR(got_hi_surrogate, tok->ucs_char);
                  } else {
                    /* Hi surrogate was not followed by a low surrogate */
                    /* Replace the hi and process the rest normally */
		    printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);
                  }
                  got_hi_surrogate = 0;
                }

		if (tok->ucs_char < 0x80) {
		  unescaped_utf[0] = tok->ucs_char;
		  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 1);
		} else if (tok->ucs_char < 0x800) {
		  unescaped_utf[0] = 0xc0 | (tok->ucs_char >> 6);
		  unescaped_utf[1] = 0x80 | (tok->ucs_char & 0x3f);
		  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 2);
		} else if (IS_HIGH_SURROGATE(tok->ucs_char)) {
                  /* Got a high surrogate.  Remember it and look for the
                   * the beginning of another sequence, which should be the
                   * low surrogate.
                   */
                  got_hi_surrogate = tok->ucs_char;
                  /* Not at end, and the next two chars should be ""\u"" */
                  if ((tok->char_offset+1 != len) &&
                      (tok->char_offset+2 != len) &&
                      (str[1] == '\\') &&
                      (str[2] == 'u'))
                  {
                /* Advance through the 16 bit surrogate, and move on to the
                 * next sequence. The next step is to process the following
                 * characters.
                 */
	            if( !ADVANCE_CHAR(str, tok) || !ADVANCE_CHAR(str, tok) ) {
                    printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);
                }
                    /* Advance to the first char of the next sequence and
                     * continue processing with the next sequence.
                     */
	            if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {
	              printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);
	              goto out;
                    }
	            tok->ucs_char = 0;
                    tok->st_pos = 0;
                    continue; /* other json_tokener_state_escape_unicode */
                  } else {
                    /* Got a high surrogate without another sequence following
                     * it.  Put a replacement char in for the hi surrogate
                     * and pretend we finished.
                     */
		    printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);
                  }
		} else if (IS_LOW_SURROGATE(tok->ucs_char)) {
                  /* Got a low surrogate not preceded by a high */
		  printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);
                } else if (tok->ucs_char < 0x10000) {
		  unescaped_utf[0] = 0xe0 | (tok->ucs_char >> 12);
		  unescaped_utf[1] = 0x80 | ((tok->ucs_char >> 6) & 0x3f);
		  unescaped_utf[2] = 0x80 | (tok->ucs_char & 0x3f);
		  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 3);
		} else if (tok->ucs_char < 0x110000) {
		  unescaped_utf[0] = 0xf0 | ((tok->ucs_char >> 18) & 0x07);
		  unescaped_utf[1] = 0x80 | ((tok->ucs_char >> 12) & 0x3f);
		  unescaped_utf[2] = 0x80 | ((tok->ucs_char >> 6) & 0x3f);
		  unescaped_utf[3] = 0x80 | (tok->ucs_char & 0x3f);
		  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 4);
		} else {
                  /* Don't know what we got--insert the replacement char */
		  printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);
                }
		state = saved_state;
		break;
	      }
	    } else {
	      tok->err = json_tokener_error_parse_string;
	      goto out;
	    }
	  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {
            if (got_hi_surrogate) /* Clean up any pending chars */
	      printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);
	    goto out;
	  }
	}
      }
      break;

    case json_tokener_state_boolean:
      {
	int size1, size2;
	printbuf_memappend_fast(tok->pb, &c, 1);
	size1 = json_min(tok->st_pos+1, json_true_str_len);
	size2 = json_min(tok->st_pos+1, json_false_str_len);
	if((!(tok->flags & JSON_TOKENER_STRICT) &&
	  strncasecmp(json_true_str, tok->pb->buf, size1) == 0)
	  || (strncmp(json_true_str, tok->pb->buf, size1) == 0)
	  ) {
	  if(tok->st_pos == json_true_str_len) {
	    current = json_object_new_boolean(1);
	    saved_state = json_tokener_state_finish;
	    state = json_tokener_state_eatws;
	    goto redo_char;
	  }
	} else if((!(tok->flags & JSON_TOKENER_STRICT) &&
	  strncasecmp(json_false_str, tok->pb->buf, size2) == 0)
	  || (strncmp(json_false_str, tok->pb->buf, size2) == 0)) {
	  if(tok->st_pos == json_false_str_len) {
	    current = json_object_new_boolean(0);
	    saved_state = json_tokener_state_finish;
	    state = json_tokener_state_eatws;
	    goto redo_char;
	  }
	} else {
	  tok->err = json_tokener_error_parse_boolean;
	  goto out;
	}
	tok->st_pos++;
      }
      break;

    case json_tokener_state_number:
      {
	/* Advance until we change state */
	const char *case_start = str;
	int case_len=0;
	while(c && strchr(json_number_chars, c)) {
	  ++case_len;
	  if(c == '.' || c == 'e' || c == 'E')
	    tok->is_double = 1;
	  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {
	    printbuf_memappend_fast(tok->pb, case_start, case_len);
	    goto out;
	  }
	}
        if (case_len>0)
          printbuf_memappend_fast(tok->pb, case_start, case_len);

	if (tok->pb->buf[0] == '-' && case_len == 1 &&
	    (c == 'i' || c == 'I'))
	{
		state = json_tokener_state_inf;
		goto redo_char;
	}
      }
      {
	int64_t num64;
	double  numd;
	if (!tok->is_double && json_parse_int64(tok->pb->buf, &num64) == 0) {
		if (num64 && tok->pb->buf[0]=='0' && (tok->flags & JSON_TOKENER_STRICT)) {
			/* in strict mode, number must not start with 0 */
			tok->err = json_tokener_error_parse_number;
			goto out;
		}
		current = json_object_new_int64(num64);
	}
	else if(tok->is_double && json_parse_double(tok->pb->buf, &numd) == 0)
	{
          current = json_object_new_double_s(numd, tok->pb->buf);
        } else {
          tok->err = json_tokener_error_parse_number;
          goto out;
        }
        saved_state = json_tokener_state_finish;
        state = json_tokener_state_eatws;
        goto redo_char;
      }
      break;

    case json_tokener_state_array_after_sep:
    case json_tokener_state_array:
      if(c == ']') {
		if (state == json_tokener_state_array_after_sep &&
			(tok->flags & JSON_TOKENER_STRICT))
		{
			tok->err = json_tokener_error_parse_unexpected;
			goto out;
		}
	saved_state = json_tokener_state_finish;
	state = json_tokener_state_eatws;
      } else {
	if(tok->depth >= tok->max_depth-1) {
	  tok->err = json_tokener_error_depth;
	  goto out;
	}
	state = json_tokener_state_array_add;
	tok->depth++;
	json_tokener_reset_level(tok, tok->depth);
	goto redo_char;
      }
      break;

    case json_tokener_state_array_add:
      json_object_array_add(current, obj);
      saved_state = json_tokener_state_array_sep;
      state = json_tokener_state_eatws;
      goto redo_char;

    case json_tokener_state_array_sep:
      if(c == ']') {
	saved_state = json_tokener_state_finish;
	state = json_tokener_state_eatws;
      } else if(c == ',') {
	saved_state = json_tokener_state_array_after_sep;
	state = json_tokener_state_eatws;
      } else {
	tok->err = json_tokener_error_parse_array;
	goto out;
      }
      break;

    case json_tokener_state_object_field_start:
    case json_tokener_state_object_field_start_after_sep:
      if(c == '}') {
		if (state == json_tokener_state_object_field_start_after_sep &&
		    (tok->flags & JSON_TOKENER_STRICT))
		{
			tok->err = json_tokener_error_parse_unexpected;
			goto out;
		}
	saved_state = json_tokener_state_finish;
	state = json_tokener_state_eatws;
      } else if (c == '""' || c == '\'') {
	tok->quote_char = c;
	printbuf_reset(tok->pb);
	state = json_tokener_state_object_field;
      } else {
	tok->err = json_tokener_error_parse_object_key_name;
	goto out;
      }
      break;

    case json_tokener_state_object_field:
      {
	/* Advance until we change state */
	const char *case_start = str;
	while(1) {
	  if(c == tok->quote_char) {
	    printbuf_memappend_fast(tok->pb, case_start, str-case_start);
	    obj_field_name = strdup(tok->pb->buf);
	    saved_state = json_tokener_state_object_field_end;
	    state = json_tokener_state_eatws;
	    break;
	  } else if(c == '\\') {
	    printbuf_memappend_fast(tok->pb, case_start, str-case_start);
	    saved_state = json_tokener_state_object_field;
	    state = json_tokener_state_string_escape;
	    break;
	  }
	  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {
	    printbuf_memappend_fast(tok->pb, case_start, str-case_start);
	    goto out;
	  }
	}
      }
      break;

    case json_tokener_state_object_field_end:
      if(c == ':') {
	saved_state = json_tokener_state_object_value;
	state = json_tokener_state_eatws;
      } else {
	tok->err = json_tokener_error_parse_object_key_sep;
	goto out;
      }
      break;

    case json_tokener_state_object_value:
      if(tok->depth >= tok->max_depth-1) {
	tok->err = json_tokener_error_depth;
	goto out;
      }
      state = json_tokener_state_object_value_add;
      tok->depth++;
      json_tokener_reset_level(tok, tok->depth);
      goto redo_char;

    case json_tokener_state_object_value_add:
      json_object_object_add(current, obj_field_name, obj);
      free(obj_field_name);
      obj_field_name = NULL;
      saved_state = json_tokener_state_object_sep;
      state = json_tokener_state_eatws;
      goto redo_char;

    case json_tokener_state_object_sep:
      if(c == '}') {
	saved_state = json_tokener_state_finish;
	state = json_tokener_state_eatws;
      } else if(c == ',') {
	saved_state = json_tokener_state_object_field_start_after_sep;
	state = json_tokener_state_eatws;
      } else {
	tok->err = json_tokener_error_parse_object_value_sep;
	goto out;
      }
      break;

    }
    if (!ADVANCE_CHAR(str, tok))
      goto out;
  } /* while(POP_CHAR) */
","struct json_object* json_tokener_parse_ex(struct json_tokener *tok,
					  const char *str, int len)
{
  struct json_object *obj = NULL;
  char c = '\1';
#ifdef HAVE_SETLOCALE
  char *oldlocale=NULL, *tmplocale;

  tmplocale = setlocale(LC_NUMERIC, NULL);
  if (tmplocale) oldlocale = strdup(tmplocale);
  setlocale(LC_NUMERIC, ""C"");
#endif

   tok->char_offset = 0;
   tok->err = json_tokener_success;
 
   while (PEEK_CHAR(c, tok)) {
 
   redo_char:
    switch(state) {

    case json_tokener_state_eatws:
      /* Advance until we change state */
      while (isspace((int)c)) {
	if ((!ADVANCE_CHAR(str, tok)) || (!PEEK_CHAR(c, tok)))
	  goto out;
      }
      if(c == '/' && !(tok->flags & JSON_TOKENER_STRICT)) {
	printbuf_reset(tok->pb);
	printbuf_memappend_fast(tok->pb, &c, 1);
	state = json_tokener_state_comment_start;
      } else {
	state = saved_state;
	goto redo_char;
      }
      break;

    case json_tokener_state_start:
      switch(c) {
      case '{':
	state = json_tokener_state_eatws;
	saved_state = json_tokener_state_object_field_start;
	current = json_object_new_object();
	break;
      case '[':
	state = json_tokener_state_eatws;
	saved_state = json_tokener_state_array;
	current = json_object_new_array();
	break;
      case 'I':
      case 'i':
	state = json_tokener_state_inf;
	printbuf_reset(tok->pb);
	tok->st_pos = 0;
	goto redo_char;
      case 'N':
      case 'n':
	state = json_tokener_state_null; // or NaN
	printbuf_reset(tok->pb);
	tok->st_pos = 0;
	goto redo_char;
      case '\'':
        if (tok->flags & JSON_TOKENER_STRICT) {
            /* in STRICT mode only double-quote are allowed */
            tok->err = json_tokener_error_parse_unexpected;
            goto out;
        }
      case '""':
	state = json_tokener_state_string;
	printbuf_reset(tok->pb);
	tok->quote_char = c;
	break;
      case 'T':
      case 't':
      case 'F':
      case 'f':
	state = json_tokener_state_boolean;
	printbuf_reset(tok->pb);
	tok->st_pos = 0;
	goto redo_char;
#if defined(__GNUC__)
	  case '0' ... '9':
#else
	  case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
#endif
      case '-':
	state = json_tokener_state_number;
	printbuf_reset(tok->pb);
	tok->is_double = 0;
	goto redo_char;
      default:
	tok->err = json_tokener_error_parse_unexpected;
	goto out;
      }
      break;

    case json_tokener_state_finish:
      if(tok->depth == 0) goto out;
      obj = json_object_get(current);
      json_tokener_reset_level(tok, tok->depth);
      tok->depth--;
      goto redo_char;

    case json_tokener_state_inf: /* aka starts with 'i' */
      {
	int size;
	int size_inf;
	int is_negative = 0;

	printbuf_memappend_fast(tok->pb, &c, 1);
	size = json_min(tok->st_pos+1, json_null_str_len);
	size_inf = json_min(tok->st_pos+1, json_inf_str_len);
	char *infbuf = tok->pb->buf;
	if (*infbuf == '-')
	{
		infbuf++;
		is_negative = 1;
	}
	if ((!(tok->flags & JSON_TOKENER_STRICT) &&
	          strncasecmp(json_inf_str, infbuf, size_inf) == 0) ||
	         (strncmp(json_inf_str, infbuf, size_inf) == 0)
	        )
	{
		if (tok->st_pos == json_inf_str_len)
		{
			current = json_object_new_double(is_negative ? -INFINITY : INFINITY); 
			saved_state = json_tokener_state_finish;
			state = json_tokener_state_eatws;
			goto redo_char;
		}
	} else {
		tok->err = json_tokener_error_parse_unexpected;
		goto out;
	}
	tok->st_pos++;
      }
      break;
    case json_tokener_state_null: /* aka starts with 'n' */
      {
	int size;
	int size_nan;
	printbuf_memappend_fast(tok->pb, &c, 1);
	size = json_min(tok->st_pos+1, json_null_str_len);
	size_nan = json_min(tok->st_pos+1, json_nan_str_len);
	if((!(tok->flags & JSON_TOKENER_STRICT) &&
	  strncasecmp(json_null_str, tok->pb->buf, size) == 0)
	  || (strncmp(json_null_str, tok->pb->buf, size) == 0)
	  ) {
	  if (tok->st_pos == json_null_str_len) {
	    current = NULL;
	    saved_state = json_tokener_state_finish;
	    state = json_tokener_state_eatws;
	    goto redo_char;
	  }
	}
	else if ((!(tok->flags & JSON_TOKENER_STRICT) &&
	          strncasecmp(json_nan_str, tok->pb->buf, size_nan) == 0) ||
	         (strncmp(json_nan_str, tok->pb->buf, size_nan) == 0)
	        )
	{
		if (tok->st_pos == json_nan_str_len)
		{
			current = json_object_new_double(NAN);
			saved_state = json_tokener_state_finish;
			state = json_tokener_state_eatws;
			goto redo_char;
		}
	} else {
	  tok->err = json_tokener_error_parse_null;
	  goto out;
	}
	tok->st_pos++;
      }
      break;

    case json_tokener_state_comment_start:
      if(c == '*') {
	state = json_tokener_state_comment;
      } else if(c == '/') {
	state = json_tokener_state_comment_eol;
      } else {
	tok->err = json_tokener_error_parse_comment;
	goto out;
      }
      printbuf_memappend_fast(tok->pb, &c, 1);
      break;

    case json_tokener_state_comment:
              {
          /* Advance until we change state */
          const char *case_start = str;
          while(c != '*') {
            if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {
              printbuf_memappend_fast(tok->pb, case_start, str-case_start);
              goto out;
            }
          }
          printbuf_memappend_fast(tok->pb, case_start, 1+str-case_start);
          state = json_tokener_state_comment_end;
        }
            break;

    case json_tokener_state_comment_eol:
      {
	/* Advance until we change state */
	const char *case_start = str;
	while(c != '\n') {
	  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {
	    printbuf_memappend_fast(tok->pb, case_start, str-case_start);
	    goto out;
	  }
	}
	printbuf_memappend_fast(tok->pb, case_start, str-case_start);
	MC_DEBUG(""json_tokener_comment: %s\n"", tok->pb->buf);
	state = json_tokener_state_eatws;
      }
      break;

    case json_tokener_state_comment_end:
      printbuf_memappend_fast(tok->pb, &c, 1);
      if(c == '/') {
	MC_DEBUG(""json_tokener_comment: %s\n"", tok->pb->buf);
	state = json_tokener_state_eatws;
      } else {
	state = json_tokener_state_comment;
      }
      break;

    case json_tokener_state_string:
      {
	/* Advance until we change state */
	const char *case_start = str;
	while(1) {
	  if(c == tok->quote_char) {
	    printbuf_memappend_fast(tok->pb, case_start, str-case_start);
	    current = json_object_new_string_len(tok->pb->buf, tok->pb->bpos);
	    saved_state = json_tokener_state_finish;
	    state = json_tokener_state_eatws;
	    break;
	  } else if(c == '\\') {
	    printbuf_memappend_fast(tok->pb, case_start, str-case_start);
	    saved_state = json_tokener_state_string;
	    state = json_tokener_state_string_escape;
	    break;
	  }
	  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {
	    printbuf_memappend_fast(tok->pb, case_start, str-case_start);
	    goto out;
	  }
	}
      }
      break;

    case json_tokener_state_string_escape:
      switch(c) {
      case '""':
      case '\\':
      case '/':
	printbuf_memappend_fast(tok->pb, &c, 1);
	state = saved_state;
	break;
      case 'b':
      case 'n':
      case 'r':
      case 't':
      case 'f':
	if(c == 'b') printbuf_memappend_fast(tok->pb, ""\b"", 1);
	else if(c == 'n') printbuf_memappend_fast(tok->pb, ""\n"", 1);
	else if(c == 'r') printbuf_memappend_fast(tok->pb, ""\r"", 1);
	else if(c == 't') printbuf_memappend_fast(tok->pb, ""\t"", 1);
	else if(c == 'f') printbuf_memappend_fast(tok->pb, ""\f"", 1);
	state = saved_state;
	break;
      case 'u':
	tok->ucs_char = 0;
	tok->st_pos = 0;
	state = json_tokener_state_escape_unicode;
	break;
      default:
	tok->err = json_tokener_error_parse_string;
	goto out;
      }
      break;

    case json_tokener_state_escape_unicode:
	{
          unsigned int got_hi_surrogate = 0;

	  /* Handle a 4-byte sequence, or two sequences if a surrogate pair */
	  while(1) {
	    if(strchr(json_hex_chars, c)) {
	      tok->ucs_char += ((unsigned int)hexdigit(c) << ((3-tok->st_pos++)*4));
	      if(tok->st_pos == 4) {
		unsigned char unescaped_utf[4];

                if (got_hi_surrogate) {
		  if (IS_LOW_SURROGATE(tok->ucs_char)) {
                    /* Recalculate the ucs_char, then fall thru to process normally */
                    tok->ucs_char = DECODE_SURROGATE_PAIR(got_hi_surrogate, tok->ucs_char);
                  } else {
                    /* Hi surrogate was not followed by a low surrogate */
                    /* Replace the hi and process the rest normally */
		    printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);
                  }
                  got_hi_surrogate = 0;
                }

		if (tok->ucs_char < 0x80) {
		  unescaped_utf[0] = tok->ucs_char;
		  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 1);
		} else if (tok->ucs_char < 0x800) {
		  unescaped_utf[0] = 0xc0 | (tok->ucs_char >> 6);
		  unescaped_utf[1] = 0x80 | (tok->ucs_char & 0x3f);
		  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 2);
		} else if (IS_HIGH_SURROGATE(tok->ucs_char)) {
                  /* Got a high surrogate.  Remember it and look for the
                   * the beginning of another sequence, which should be the
                   * low surrogate.
                   */
                  got_hi_surrogate = tok->ucs_char;
                  /* Not at end, and the next two chars should be ""\u"" */
                  if ((tok->char_offset+1 != len) &&
                      (tok->char_offset+2 != len) &&
                      (str[1] == '\\') &&
                      (str[2] == 'u'))
                  {
                /* Advance through the 16 bit surrogate, and move on to the
                 * next sequence. The next step is to process the following
                 * characters.
                 */
	            if( !ADVANCE_CHAR(str, tok) || !ADVANCE_CHAR(str, tok) ) {
                    printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);
                }
                    /* Advance to the first char of the next sequence and
                     * continue processing with the next sequence.
                     */
	            if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {
	              printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);
	              goto out;
                    }
	            tok->ucs_char = 0;
                    tok->st_pos = 0;
                    continue; /* other json_tokener_state_escape_unicode */
                  } else {
                    /* Got a high surrogate without another sequence following
                     * it.  Put a replacement char in for the hi surrogate
                     * and pretend we finished.
                     */
		    printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);
                  }
		} else if (IS_LOW_SURROGATE(tok->ucs_char)) {
                  /* Got a low surrogate not preceded by a high */
		  printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);
                } else if (tok->ucs_char < 0x10000) {
		  unescaped_utf[0] = 0xe0 | (tok->ucs_char >> 12);
		  unescaped_utf[1] = 0x80 | ((tok->ucs_char >> 6) & 0x3f);
		  unescaped_utf[2] = 0x80 | (tok->ucs_char & 0x3f);
		  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 3);
		} else if (tok->ucs_char < 0x110000) {
		  unescaped_utf[0] = 0xf0 | ((tok->ucs_char >> 18) & 0x07);
		  unescaped_utf[1] = 0x80 | ((tok->ucs_char >> 12) & 0x3f);
		  unescaped_utf[2] = 0x80 | ((tok->ucs_char >> 6) & 0x3f);
		  unescaped_utf[3] = 0x80 | (tok->ucs_char & 0x3f);
		  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 4);
		} else {
                  /* Don't know what we got--insert the replacement char */
		  printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);
                }
		state = saved_state;
		break;
	      }
	    } else {
	      tok->err = json_tokener_error_parse_string;
	      goto out;
	    }
	  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {
            if (got_hi_surrogate) /* Clean up any pending chars */
	      printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);
	    goto out;
	  }
	}
      }
      break;

    case json_tokener_state_boolean:
      {
	int size1, size2;
	printbuf_memappend_fast(tok->pb, &c, 1);
	size1 = json_min(tok->st_pos+1, json_true_str_len);
	size2 = json_min(tok->st_pos+1, json_false_str_len);
	if((!(tok->flags & JSON_TOKENER_STRICT) &&
	  strncasecmp(json_true_str, tok->pb->buf, size1) == 0)
	  || (strncmp(json_true_str, tok->pb->buf, size1) == 0)
	  ) {
	  if(tok->st_pos == json_true_str_len) {
	    current = json_object_new_boolean(1);
	    saved_state = json_tokener_state_finish;
	    state = json_tokener_state_eatws;
	    goto redo_char;
	  }
	} else if((!(tok->flags & JSON_TOKENER_STRICT) &&
	  strncasecmp(json_false_str, tok->pb->buf, size2) == 0)
	  || (strncmp(json_false_str, tok->pb->buf, size2) == 0)) {
	  if(tok->st_pos == json_false_str_len) {
	    current = json_object_new_boolean(0);
	    saved_state = json_tokener_state_finish;
	    state = json_tokener_state_eatws;
	    goto redo_char;
	  }
	} else {
	  tok->err = json_tokener_error_parse_boolean;
	  goto out;
	}
	tok->st_pos++;
      }
      break;

    case json_tokener_state_number:
      {
	/* Advance until we change state */
	const char *case_start = str;
	int case_len=0;
	while(c && strchr(json_number_chars, c)) {
	  ++case_len;
	  if(c == '.' || c == 'e' || c == 'E')
	    tok->is_double = 1;
	  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {
	    printbuf_memappend_fast(tok->pb, case_start, case_len);
	    goto out;
	  }
	}
        if (case_len>0)
          printbuf_memappend_fast(tok->pb, case_start, case_len);

	if (tok->pb->buf[0] == '-' && case_len == 1 &&
	    (c == 'i' || c == 'I'))
	{
		state = json_tokener_state_inf;
		goto redo_char;
	}
      }
      {
	int64_t num64;
	double  numd;
	if (!tok->is_double && json_parse_int64(tok->pb->buf, &num64) == 0) {
		if (num64 && tok->pb->buf[0]=='0' && (tok->flags & JSON_TOKENER_STRICT)) {
			/* in strict mode, number must not start with 0 */
			tok->err = json_tokener_error_parse_number;
			goto out;
		}
		current = json_object_new_int64(num64);
	}
	else if(tok->is_double && json_parse_double(tok->pb->buf, &numd) == 0)
	{
          current = json_object_new_double_s(numd, tok->pb->buf);
        } else {
          tok->err = json_tokener_error_parse_number;
          goto out;
        }
        saved_state = json_tokener_state_finish;
        state = json_tokener_state_eatws;
        goto redo_char;
      }
      break;

    case json_tokener_state_array_after_sep:
    case json_tokener_state_array:
      if(c == ']') {
		if (state == json_tokener_state_array_after_sep &&
			(tok->flags & JSON_TOKENER_STRICT))
		{
			tok->err = json_tokener_error_parse_unexpected;
			goto out;
		}
	saved_state = json_tokener_state_finish;
	state = json_tokener_state_eatws;
      } else {
	if(tok->depth >= tok->max_depth-1) {
	  tok->err = json_tokener_error_depth;
	  goto out;
	}
	state = json_tokener_state_array_add;
	tok->depth++;
	json_tokener_reset_level(tok, tok->depth);
	goto redo_char;
      }
      break;

    case json_tokener_state_array_add:
      json_object_array_add(current, obj);
      saved_state = json_tokener_state_array_sep;
      state = json_tokener_state_eatws;
      goto redo_char;

    case json_tokener_state_array_sep:
      if(c == ']') {
	saved_state = json_tokener_state_finish;
	state = json_tokener_state_eatws;
      } else if(c == ',') {
	saved_state = json_tokener_state_array_after_sep;
	state = json_tokener_state_eatws;
      } else {
	tok->err = json_tokener_error_parse_array;
	goto out;
      }
      break;

    case json_tokener_state_object_field_start:
    case json_tokener_state_object_field_start_after_sep:
      if(c == '}') {
		if (state == json_tokener_state_object_field_start_after_sep &&
		    (tok->flags & JSON_TOKENER_STRICT))
		{
			tok->err = json_tokener_error_parse_unexpected;
			goto out;
		}
	saved_state = json_tokener_state_finish;
	state = json_tokener_state_eatws;
      } else if (c == '""' || c == '\'') {
	tok->quote_char = c;
	printbuf_reset(tok->pb);
	state = json_tokener_state_object_field;
      } else {
	tok->err = json_tokener_error_parse_object_key_name;
	goto out;
      }
      break;

    case json_tokener_state_object_field:
      {
	/* Advance until we change state */
	const char *case_start = str;
	while(1) {
	  if(c == tok->quote_char) {
	    printbuf_memappend_fast(tok->pb, case_start, str-case_start);
	    obj_field_name = strdup(tok->pb->buf);
	    saved_state = json_tokener_state_object_field_end;
	    state = json_tokener_state_eatws;
	    break;
	  } else if(c == '\\') {
	    printbuf_memappend_fast(tok->pb, case_start, str-case_start);
	    saved_state = json_tokener_state_object_field;
	    state = json_tokener_state_string_escape;
	    break;
	  }
	  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {
	    printbuf_memappend_fast(tok->pb, case_start, str-case_start);
	    goto out;
	  }
	}
      }
      break;

    case json_tokener_state_object_field_end:
      if(c == ':') {
	saved_state = json_tokener_state_object_value;
	state = json_tokener_state_eatws;
      } else {
	tok->err = json_tokener_error_parse_object_key_sep;
	goto out;
      }
      break;

    case json_tokener_state_object_value:
      if(tok->depth >= tok->max_depth-1) {
	tok->err = json_tokener_error_depth;
	goto out;
      }
      state = json_tokener_state_object_value_add;
      tok->depth++;
      json_tokener_reset_level(tok, tok->depth);
      goto redo_char;

    case json_tokener_state_object_value_add:
      json_object_object_add(current, obj_field_name, obj);
      free(obj_field_name);
      obj_field_name = NULL;
      saved_state = json_tokener_state_object_sep;
      state = json_tokener_state_eatws;
      goto redo_char;

    case json_tokener_state_object_sep:
      if(c == '}') {
	saved_state = json_tokener_state_finish;
	state = json_tokener_state_eatws;
      } else if(c == ',') {
	saved_state = json_tokener_state_object_field_start_after_sep;
	state = json_tokener_state_eatws;
      } else {
	tok->err = json_tokener_error_parse_object_value_sep;
	goto out;
      }
      break;

    }
    if (!ADVANCE_CHAR(str, tok))
      goto out;
  } /* while(POP_CHAR) */
",C,"  /* this interface is presently not 64-bit clean due to the int len argument
     and the internal printbuf interface that takes 32-bit int len arguments
     so the function limits the maximum string size to INT32_MAX (2GB).
     If the function is called with len == -1 then strlen is called to check
     the string length is less than INT32_MAX (2GB) */
  if ((len < -1) || (len == -1 && strlen(str) > INT32_MAX)) {
    tok->err = json_tokener_error_size;
    return NULL;
  }

",,,"@@ -81,6 +81,7 @@ static const char* json_tokener_errors[] = {
   ""object value separator ',' expected"",
   ""invalid string sequence"",
   ""expected comment"",
+  ""buffer size overflow""
 };
 
 const char *json_tokener_error_desc(enum json_tokener_error jerr)
@@ -243,6 +244,16 @@ struct json_object* json_tokener_parse_ex(struct json_tokener *tok,
   tok->char_offset = 0;
   tok->err = json_tokener_success;
 
+  /* this interface is presently not 64-bit clean due to the int len argument
+     and the internal printbuf interface that takes 32-bit int len arguments
+     so the function limits the maximum string size to INT32_MAX (2GB).
+     If the function is called with len == -1 then strlen is called to check
+     the string length is less than INT32_MAX (2GB) */
+  if ((len < -1) || (len == -1 && strlen(str) > INT32_MAX)) {
+    tok->err = json_tokener_error_size;
+    return NULL;
+  }
+
   while (PEEK_CHAR(c, tok)) {
 
   redo_char:",json-c,64e36901a0614bf64a19bc3396469c66dcd0b015,784534a31f301466d9ab6f8d5b5ccd39a3b9f156,1,"struct json_object* json_tokener_parse_ex(struct json_tokener *tok,
					  const char *str, int len)
{
  struct json_object *obj = NULL;
  char c = '\1';
#ifdef HAVE_SETLOCALE
  char *oldlocale=NULL, *tmplocale;

  tmplocale = setlocale(LC_NUMERIC, NULL);
  if (tmplocale) oldlocale = strdup(tmplocale);
  setlocale(LC_NUMERIC, ""C"");
#endif

   tok->char_offset = 0;
   tok->err = json_tokener_success;
 
//fix_flaw_line_below:
//  /* this interface is presently not 64-bit clean due to the int len argument
//fix_flaw_line_below:
//     and the internal printbuf interface that takes 32-bit int len arguments
//fix_flaw_line_below:
//     so the function limits the maximum string size to INT32_MAX (2GB).
//fix_flaw_line_below:
//     If the function is called with len == -1 then strlen is called to check
//fix_flaw_line_below:
//     the string length is less than INT32_MAX (2GB) */
//fix_flaw_line_below:
//  if ((len < -1) || (len == -1 && strlen(str) > INT32_MAX)) {
//fix_flaw_line_below:
//    tok->err = json_tokener_error_size;
//fix_flaw_line_below:
//    return NULL;
//fix_flaw_line_below:
//  }
//fix_flaw_line_below:
//
   while (PEEK_CHAR(c, tok)) {
 
   redo_char:
    switch(state) {

    case json_tokener_state_eatws:
      /* Advance until we change state */
      while (isspace((int)c)) {
	if ((!ADVANCE_CHAR(str, tok)) || (!PEEK_CHAR(c, tok)))
	  goto out;
      }
      if(c == '/' && !(tok->flags & JSON_TOKENER_STRICT)) {
	printbuf_reset(tok->pb);
	printbuf_memappend_fast(tok->pb, &c, 1);
	state = json_tokener_state_comment_start;
      } else {
	state = saved_state;
	goto redo_char;
      }
      break;

    case json_tokener_state_start:
      switch(c) {
      case '{':
	state = json_tokener_state_eatws;
	saved_state = json_tokener_state_object_field_start;
	current = json_object_new_object();
	break;
      case '[':
	state = json_tokener_state_eatws;
	saved_state = json_tokener_state_array;
	current = json_object_new_array();
	break;
      case 'I':
      case 'i':
	state = json_tokener_state_inf;
	printbuf_reset(tok->pb);
	tok->st_pos = 0;
	goto redo_char;
      case 'N':
      case 'n':
	state = json_tokener_state_null; // or NaN
	printbuf_reset(tok->pb);
	tok->st_pos = 0;
	goto redo_char;
      case '\'':
        if (tok->flags & JSON_TOKENER_STRICT) {
            /* in STRICT mode only double-quote are allowed */
            tok->err = json_tokener_error_parse_unexpected;
            goto out;
        }
      case '""':
	state = json_tokener_state_string;
	printbuf_reset(tok->pb);
	tok->quote_char = c;
	break;
      case 'T':
      case 't':
      case 'F':
      case 'f':
	state = json_tokener_state_boolean;
	printbuf_reset(tok->pb);
	tok->st_pos = 0;
	goto redo_char;
#if defined(__GNUC__)
	  case '0' ... '9':
#else
	  case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
#endif
      case '-':
	state = json_tokener_state_number;
	printbuf_reset(tok->pb);
	tok->is_double = 0;
	goto redo_char;
      default:
	tok->err = json_tokener_error_parse_unexpected;
	goto out;
      }
      break;

    case json_tokener_state_finish:
      if(tok->depth == 0) goto out;
      obj = json_object_get(current);
      json_tokener_reset_level(tok, tok->depth);
      tok->depth--;
      goto redo_char;

    case json_tokener_state_inf: /* aka starts with 'i' */
      {
	int size;
	int size_inf;
	int is_negative = 0;

	printbuf_memappend_fast(tok->pb, &c, 1);
	size = json_min(tok->st_pos+1, json_null_str_len);
	size_inf = json_min(tok->st_pos+1, json_inf_str_len);
	char *infbuf = tok->pb->buf;
	if (*infbuf == '-')
	{
		infbuf++;
		is_negative = 1;
	}
	if ((!(tok->flags & JSON_TOKENER_STRICT) &&
	          strncasecmp(json_inf_str, infbuf, size_inf) == 0) ||
	         (strncmp(json_inf_str, infbuf, size_inf) == 0)
	        )
	{
		if (tok->st_pos == json_inf_str_len)
		{
			current = json_object_new_double(is_negative ? -INFINITY : INFINITY); 
			saved_state = json_tokener_state_finish;
			state = json_tokener_state_eatws;
			goto redo_char;
		}
	} else {
		tok->err = json_tokener_error_parse_unexpected;
		goto out;
	}
	tok->st_pos++;
      }
      break;
    case json_tokener_state_null: /* aka starts with 'n' */
      {
	int size;
	int size_nan;
	printbuf_memappend_fast(tok->pb, &c, 1);
	size = json_min(tok->st_pos+1, json_null_str_len);
	size_nan = json_min(tok->st_pos+1, json_nan_str_len);
	if((!(tok->flags & JSON_TOKENER_STRICT) &&
	  strncasecmp(json_null_str, tok->pb->buf, size) == 0)
	  || (strncmp(json_null_str, tok->pb->buf, size) == 0)
	  ) {
	  if (tok->st_pos == json_null_str_len) {
	    current = NULL;
	    saved_state = json_tokener_state_finish;
	    state = json_tokener_state_eatws;
	    goto redo_char;
	  }
	}
	else if ((!(tok->flags & JSON_TOKENER_STRICT) &&
	          strncasecmp(json_nan_str, tok->pb->buf, size_nan) == 0) ||
	         (strncmp(json_nan_str, tok->pb->buf, size_nan) == 0)
	        )
	{
		if (tok->st_pos == json_nan_str_len)
		{
			current = json_object_new_double(NAN);
			saved_state = json_tokener_state_finish;
			state = json_tokener_state_eatws;
			goto redo_char;
		}
	} else {
	  tok->err = json_tokener_error_parse_null;
	  goto out;
	}
	tok->st_pos++;
      }
      break;

    case json_tokener_state_comment_start:
      if(c == '*') {
	state = json_tokener_state_comment;
      } else if(c == '/') {
	state = json_tokener_state_comment_eol;
      } else {
	tok->err = json_tokener_error_parse_comment;
	goto out;
      }
      printbuf_memappend_fast(tok->pb, &c, 1);
      break;

    case json_tokener_state_comment:
              {
          /* Advance until we change state */
          const char *case_start = str;
          while(c != '*') {
            if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {
              printbuf_memappend_fast(tok->pb, case_start, str-case_start);
              goto out;
            }
          }
          printbuf_memappend_fast(tok->pb, case_start, 1+str-case_start);
          state = json_tokener_state_comment_end;
        }
            break;

    case json_tokener_state_comment_eol:
      {
	/* Advance until we change state */
	const char *case_start = str;
	while(c != '\n') {
	  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {
	    printbuf_memappend_fast(tok->pb, case_start, str-case_start);
	    goto out;
	  }
	}
	printbuf_memappend_fast(tok->pb, case_start, str-case_start);
	MC_DEBUG(""json_tokener_comment: %s\n"", tok->pb->buf);
	state = json_tokener_state_eatws;
      }
      break;

    case json_tokener_state_comment_end:
      printbuf_memappend_fast(tok->pb, &c, 1);
      if(c == '/') {
	MC_DEBUG(""json_tokener_comment: %s\n"", tok->pb->buf);
	state = json_tokener_state_eatws;
      } else {
	state = json_tokener_state_comment;
      }
      break;

    case json_tokener_state_string:
      {
	/* Advance until we change state */
	const char *case_start = str;
	while(1) {
	  if(c == tok->quote_char) {
	    printbuf_memappend_fast(tok->pb, case_start, str-case_start);
	    current = json_object_new_string_len(tok->pb->buf, tok->pb->bpos);
	    saved_state = json_tokener_state_finish;
	    state = json_tokener_state_eatws;
	    break;
	  } else if(c == '\\') {
	    printbuf_memappend_fast(tok->pb, case_start, str-case_start);
	    saved_state = json_tokener_state_string;
	    state = json_tokener_state_string_escape;
	    break;
	  }
	  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {
	    printbuf_memappend_fast(tok->pb, case_start, str-case_start);
	    goto out;
	  }
	}
      }
      break;

    case json_tokener_state_string_escape:
      switch(c) {
      case '""':
      case '\\':
      case '/':
	printbuf_memappend_fast(tok->pb, &c, 1);
	state = saved_state;
	break;
      case 'b':
      case 'n':
      case 'r':
      case 't':
      case 'f':
	if(c == 'b') printbuf_memappend_fast(tok->pb, ""\b"", 1);
	else if(c == 'n') printbuf_memappend_fast(tok->pb, ""\n"", 1);
	else if(c == 'r') printbuf_memappend_fast(tok->pb, ""\r"", 1);
	else if(c == 't') printbuf_memappend_fast(tok->pb, ""\t"", 1);
	else if(c == 'f') printbuf_memappend_fast(tok->pb, ""\f"", 1);
	state = saved_state;
	break;
      case 'u':
	tok->ucs_char = 0;
	tok->st_pos = 0;
	state = json_tokener_state_escape_unicode;
	break;
      default:
	tok->err = json_tokener_error_parse_string;
	goto out;
      }
      break;

    case json_tokener_state_escape_unicode:
	{
          unsigned int got_hi_surrogate = 0;

	  /* Handle a 4-byte sequence, or two sequences if a surrogate pair */
	  while(1) {
	    if(strchr(json_hex_chars, c)) {
	      tok->ucs_char += ((unsigned int)hexdigit(c) << ((3-tok->st_pos++)*4));
	      if(tok->st_pos == 4) {
		unsigned char unescaped_utf[4];

                if (got_hi_surrogate) {
		  if (IS_LOW_SURROGATE(tok->ucs_char)) {
                    /* Recalculate the ucs_char, then fall thru to process normally */
                    tok->ucs_char = DECODE_SURROGATE_PAIR(got_hi_surrogate, tok->ucs_char);
                  } else {
                    /* Hi surrogate was not followed by a low surrogate */
                    /* Replace the hi and process the rest normally */
		    printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);
                  }
                  got_hi_surrogate = 0;
                }

		if (tok->ucs_char < 0x80) {
		  unescaped_utf[0] = tok->ucs_char;
		  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 1);
		} else if (tok->ucs_char < 0x800) {
		  unescaped_utf[0] = 0xc0 | (tok->ucs_char >> 6);
		  unescaped_utf[1] = 0x80 | (tok->ucs_char & 0x3f);
		  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 2);
		} else if (IS_HIGH_SURROGATE(tok->ucs_char)) {
                  /* Got a high surrogate.  Remember it and look for the
                   * the beginning of another sequence, which should be the
                   * low surrogate.
                   */
                  got_hi_surrogate = tok->ucs_char;
                  /* Not at end, and the next two chars should be ""\u"" */
                  if ((tok->char_offset+1 != len) &&
                      (tok->char_offset+2 != len) &&
                      (str[1] == '\\') &&
                      (str[2] == 'u'))
                  {
                /* Advance through the 16 bit surrogate, and move on to the
                 * next sequence. The next step is to process the following
                 * characters.
                 */
	            if( !ADVANCE_CHAR(str, tok) || !ADVANCE_CHAR(str, tok) ) {
                    printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);
                }
                    /* Advance to the first char of the next sequence and
                     * continue processing with the next sequence.
                     */
	            if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {
	              printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);
	              goto out;
                    }
	            tok->ucs_char = 0;
                    tok->st_pos = 0;
                    continue; /* other json_tokener_state_escape_unicode */
                  } else {
                    /* Got a high surrogate without another sequence following
                     * it.  Put a replacement char in for the hi surrogate
                     * and pretend we finished.
                     */
		    printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);
                  }
		} else if (IS_LOW_SURROGATE(tok->ucs_char)) {
                  /* Got a low surrogate not preceded by a high */
		  printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);
                } else if (tok->ucs_char < 0x10000) {
		  unescaped_utf[0] = 0xe0 | (tok->ucs_char >> 12);
		  unescaped_utf[1] = 0x80 | ((tok->ucs_char >> 6) & 0x3f);
		  unescaped_utf[2] = 0x80 | (tok->ucs_char & 0x3f);
		  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 3);
		} else if (tok->ucs_char < 0x110000) {
		  unescaped_utf[0] = 0xf0 | ((tok->ucs_char >> 18) & 0x07);
		  unescaped_utf[1] = 0x80 | ((tok->ucs_char >> 12) & 0x3f);
		  unescaped_utf[2] = 0x80 | ((tok->ucs_char >> 6) & 0x3f);
		  unescaped_utf[3] = 0x80 | (tok->ucs_char & 0x3f);
		  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 4);
		} else {
                  /* Don't know what we got--insert the replacement char */
		  printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);
                }
		state = saved_state;
		break;
	      }
	    } else {
	      tok->err = json_tokener_error_parse_string;
	      goto out;
	    }
	  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {
            if (got_hi_surrogate) /* Clean up any pending chars */
	      printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);
	    goto out;
	  }
	}
      }
      break;

    case json_tokener_state_boolean:
      {
	int size1, size2;
	printbuf_memappend_fast(tok->pb, &c, 1);
	size1 = json_min(tok->st_pos+1, json_true_str_len);
	size2 = json_min(tok->st_pos+1, json_false_str_len);
	if((!(tok->flags & JSON_TOKENER_STRICT) &&
	  strncasecmp(json_true_str, tok->pb->buf, size1) == 0)
	  || (strncmp(json_true_str, tok->pb->buf, size1) == 0)
	  ) {
	  if(tok->st_pos == json_true_str_len) {
	    current = json_object_new_boolean(1);
	    saved_state = json_tokener_state_finish;
	    state = json_tokener_state_eatws;
	    goto redo_char;
	  }
	} else if((!(tok->flags & JSON_TOKENER_STRICT) &&
	  strncasecmp(json_false_str, tok->pb->buf, size2) == 0)
	  || (strncmp(json_false_str, tok->pb->buf, size2) == 0)) {
	  if(tok->st_pos == json_false_str_len) {
	    current = json_object_new_boolean(0);
	    saved_state = json_tokener_state_finish;
	    state = json_tokener_state_eatws;
	    goto redo_char;
	  }
	} else {
	  tok->err = json_tokener_error_parse_boolean;
	  goto out;
	}
	tok->st_pos++;
      }
      break;

    case json_tokener_state_number:
      {
	/* Advance until we change state */
	const char *case_start = str;
	int case_len=0;
	while(c && strchr(json_number_chars, c)) {
	  ++case_len;
	  if(c == '.' || c == 'e' || c == 'E')
	    tok->is_double = 1;
	  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {
	    printbuf_memappend_fast(tok->pb, case_start, case_len);
	    goto out;
	  }
	}
        if (case_len>0)
          printbuf_memappend_fast(tok->pb, case_start, case_len);

	// Check for -Infinity
	if (tok->pb->buf[0] == '-' && case_len == 1 &&
	    (c == 'i' || c == 'I'))
	{
		state = json_tokener_state_inf;
		goto redo_char;
	}
      }
      {
	int64_t num64;
	double  numd;
	if (!tok->is_double && json_parse_int64(tok->pb->buf, &num64) == 0) {
		if (num64 && tok->pb->buf[0]=='0' && (tok->flags & JSON_TOKENER_STRICT)) {
			/* in strict mode, number must not start with 0 */
			tok->err = json_tokener_error_parse_number;
			goto out;
		}
		current = json_object_new_int64(num64);
	}
	else if(tok->is_double && json_parse_double(tok->pb->buf, &numd) == 0)
	{
          current = json_object_new_double_s(numd, tok->pb->buf);
        } else {
          tok->err = json_tokener_error_parse_number;
          goto out;
        }
        saved_state = json_tokener_state_finish;
        state = json_tokener_state_eatws;
        goto redo_char;
      }
      break;

    case json_tokener_state_array_after_sep:
    case json_tokener_state_array:
      if(c == ']') {
		if (state == json_tokener_state_array_after_sep &&
			(tok->flags & JSON_TOKENER_STRICT))
		{
			tok->err = json_tokener_error_parse_unexpected;
			goto out;
		}
	saved_state = json_tokener_state_finish;
	state = json_tokener_state_eatws;
      } else {
	if(tok->depth >= tok->max_depth-1) {
	  tok->err = json_tokener_error_depth;
	  goto out;
	}
	state = json_tokener_state_array_add;
	tok->depth++;
	json_tokener_reset_level(tok, tok->depth);
	goto redo_char;
      }
      break;

    case json_tokener_state_array_add:
      json_object_array_add(current, obj);
      saved_state = json_tokener_state_array_sep;
      state = json_tokener_state_eatws;
      goto redo_char;

    case json_tokener_state_array_sep:
      if(c == ']') {
	saved_state = json_tokener_state_finish;
	state = json_tokener_state_eatws;
      } else if(c == ',') {
	saved_state = json_tokener_state_array_after_sep;
	state = json_tokener_state_eatws;
      } else {
	tok->err = json_tokener_error_parse_array;
	goto out;
      }
      break;

    case json_tokener_state_object_field_start:
    case json_tokener_state_object_field_start_after_sep:
      if(c == '}') {
		if (state == json_tokener_state_object_field_start_after_sep &&
		    (tok->flags & JSON_TOKENER_STRICT))
		{
			tok->err = json_tokener_error_parse_unexpected;
			goto out;
		}
	saved_state = json_tokener_state_finish;
	state = json_tokener_state_eatws;
      } else if (c == '""' || c == '\'') {
	tok->quote_char = c;
	printbuf_reset(tok->pb);
	state = json_tokener_state_object_field;
      } else {
	tok->err = json_tokener_error_parse_object_key_name;
	goto out;
      }
      break;

    case json_tokener_state_object_field:
      {
	/* Advance until we change state */
	const char *case_start = str;
	while(1) {
	  if(c == tok->quote_char) {
	    printbuf_memappend_fast(tok->pb, case_start, str-case_start);
	    obj_field_name = strdup(tok->pb->buf);
	    saved_state = json_tokener_state_object_field_end;
	    state = json_tokener_state_eatws;
	    break;
	  } else if(c == '\\') {
	    printbuf_memappend_fast(tok->pb, case_start, str-case_start);
	    saved_state = json_tokener_state_object_field;
	    state = json_tokener_state_string_escape;
	    break;
	  }
	  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {
	    printbuf_memappend_fast(tok->pb, case_start, str-case_start);
	    goto out;
	  }
	}
      }
      break;

    case json_tokener_state_object_field_end:
      if(c == ':') {
	saved_state = json_tokener_state_object_value;
	state = json_tokener_state_eatws;
      } else {
	tok->err = json_tokener_error_parse_object_key_sep;
	goto out;
      }
      break;

    case json_tokener_state_object_value:
      if(tok->depth >= tok->max_depth-1) {
	tok->err = json_tokener_error_depth;
	goto out;
      }
      state = json_tokener_state_object_value_add;
      tok->depth++;
      json_tokener_reset_level(tok, tok->depth);
      goto redo_char;

    case json_tokener_state_object_value_add:
      json_object_object_add(current, obj_field_name, obj);
      free(obj_field_name);
      obj_field_name = NULL;
      saved_state = json_tokener_state_object_sep;
      state = json_tokener_state_eatws;
      goto redo_char;

    case json_tokener_state_object_sep:
      if(c == '}') {
	saved_state = json_tokener_state_finish;
	state = json_tokener_state_eatws;
      } else if(c == ',') {
	saved_state = json_tokener_state_object_field_start_after_sep;
	state = json_tokener_state_eatws;
      } else {
	tok->err = json_tokener_error_parse_object_value_sep;
	goto out;
      }
      break;

    }
    if (!ADVANCE_CHAR(str, tok))
      goto out;
  } /* while(POP_CHAR) */
"
1976,179712,,Remote,Not required,Partial,CVE-2013-6371,https://www.cvedetails.com/cve/CVE-2013-6371/,CWE-310,Low,,,,2014-04-22,5.0,"The hash functionality in json-c before 0.12 allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted JSON data, involving collisions.",2017-08-28,DoS ,16,https://github.com/json-c/json-c/commit/64e36901a0614bf64a19bc3396469c66dcd0b015,64e36901a0614bf64a19bc3396469c66dcd0b015,"Patch to address the following issues:

* CVE-2013-6371: hash collision denial of service
* CVE-2013-6370: buffer overflow if size_t is larger than int",4,linkhash.c,"{""sha"": ""26ced27080d291984cdc671cee334a870b71e765"", ""filename"": ""Makefile.am"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/json-c/json-c/blob/64e36901a0614bf64a19bc3396469c66dcd0b015/Makefile.am"", ""raw_url"": ""https://github.com/json-c/json-c/raw/64e36901a0614bf64a19bc3396469c66dcd0b015/Makefile.am"", ""contents_url"": ""https://api.github.com/repos/json-c/json-c/contents/Makefile.am?ref=64e36901a0614bf64a19bc3396469c66dcd0b015"", ""patch"": ""@@ -23,7 +23,8 @@ libjson_cinclude_HEADERS = \\\n \tjson_tokener.h \\\n \tjson_util.h \\\n \tlinkhash.h \\\n-\tprintbuf.h\n+\tprintbuf.h \\\n+\trandom_seed.h\n \n #libjsonx_includedir = $(libdir)/json-c-@VERSION@\n #\n@@ -41,7 +42,8 @@ libjson_c_la_SOURCES = \\\n \tjson_tokener.c \\\n \tjson_util.c \\\n \tlinkhash.c \\\n-\tprintbuf.c\n+\tprintbuf.c \\\n+\trandom_seed.c\n \n \n distclean-local:""}<_**next**_>{""sha"": ""fec591b6cf31b2ac4181caa6ac7b4e2d36e4efcf"", ""filename"": ""Makefile.am.inc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/json-c/json-c/blob/64e36901a0614bf64a19bc3396469c66dcd0b015/Makefile.am.inc"", ""raw_url"": ""https://github.com/json-c/json-c/raw/64e36901a0614bf64a19bc3396469c66dcd0b015/Makefile.am.inc"", ""contents_url"": ""https://api.github.com/repos/json-c/json-c/contents/Makefile.am.inc?ref=64e36901a0614bf64a19bc3396469c66dcd0b015"", ""patch"": ""@@ -1,2 +1,2 @@\n-AM_CFLAGS = -Wall -Werror -Wextra -Wwrite-strings -Wno-unused-parameter -std=gnu99 -D_GNU_SOURCE -D_REENTRANT\n+AM_CFLAGS = -Wall -Werror -Wno-error=deprecated-declarations -Wextra -Wwrite-strings -Wno-unused-parameter -std=gnu99 -D_GNU_SOURCE -D_REENTRANT\n ""}<_**next**_>{""sha"": ""0dcab1a30015f1c1b7c4ea5df425f67b07eaf8f1"", ""filename"": ""config.h.in"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/json-c/json-c/blob/64e36901a0614bf64a19bc3396469c66dcd0b015/config.h.in"", ""raw_url"": ""https://github.com/json-c/json-c/raw/64e36901a0614bf64a19bc3396469c66dcd0b015/config.h.in"", ""contents_url"": ""https://api.github.com/repos/json-c/json-c/contents/config.h.in?ref=64e36901a0614bf64a19bc3396469c66dcd0b015"", ""patch"": ""@@ -1,5 +1,8 @@\n /* config.h.in.  Generated from configure.ac by autoheader.  */\n \n+/* Enable RDRANR Hardware RNG Hash Seed */\n+#undef ENABLE_RDRAND\n+\n /* Define if .gnu.warning accepts long strings. */\n #undef HAS_GNU_WARNING_LONG\n \n@@ -32,6 +35,9 @@\n /* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */\n #undef HAVE_DOPRNT\n \n+/* Define to 1 if you have the <endian.h> header file. */\n+#undef HAVE_ENDIAN_H\n+\n /* Define to 1 if you have the <fcntl.h> header file. */\n #undef HAVE_FCNTL_H\n ""}<_**next**_>{""sha"": ""48c8e5f382f4e7094b0ba4671e3f190ba50159ca"", ""filename"": ""configure.ac"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 1, ""changes"": 16, ""blob_url"": ""https://github.com/json-c/json-c/blob/64e36901a0614bf64a19bc3396469c66dcd0b015/configure.ac"", ""raw_url"": ""https://github.com/json-c/json-c/raw/64e36901a0614bf64a19bc3396469c66dcd0b015/configure.ac"", ""contents_url"": ""https://api.github.com/repos/json-c/json-c/contents/configure.ac?ref=64e36901a0614bf64a19bc3396469c66dcd0b015"", ""patch"": ""@@ -7,6 +7,20 @@ AM_INIT_AUTOMAKE\n \n AC_PROG_MAKE_SET\n \n+AC_ARG_ENABLE(rdrand,\n+ AS_HELP_STRING([--enable-rdrand],\n+   [Enable RDRAND Hardware RNG Hash Seed generation on supported x86/x64 platforms.]),\n+[if test x$enableval = xyes; then\n+  enable_rdrand=yes\n+  AC_DEFINE(ENABLE_RDRAND, 1, [Enable RDRANR Hardware RNG Hash Seed])\n+fi])\n+\n+if test \""x$enable_rdrand\"" = \""xyes\""; then\n+  AC_MSG_RESULT([RDRAND Hardware RNG Hash Seed enabled on supported x86/x64 platforms])\n+else\n+  AC_MSG_RESULT([RDRAND Hardware RNG Hash Seed disabled. Use --enable-rdrand to enable])\n+fi\n+\n # Checks for programs.\n \n # Checks for libraries.\n@@ -16,7 +30,7 @@ AM_PROG_CC_C_O\n AC_CONFIG_HEADER(config.h)\n AC_CONFIG_HEADER(json_config.h)\n AC_HEADER_STDC\n-AC_CHECK_HEADERS(fcntl.h limits.h strings.h syslog.h unistd.h [sys/cdefs.h] [sys/param.h] stdarg.h locale.h)\n+AC_CHECK_HEADERS(fcntl.h limits.h strings.h syslog.h unistd.h [sys/cdefs.h] [sys/param.h] stdarg.h locale.h endian.h)\n AC_CHECK_HEADER(inttypes.h,[AC_DEFINE([JSON_C_HAVE_INTTYPES_H],[1],[Public define for json_inttypes.h])])\n \n # Checks for typedefs, structures, and compiler characteristics.""}<_**next**_>{""sha"": ""200ac4031d4707e802a92059bd21e13579983eeb"", ""filename"": ""json_object.h"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 2, ""changes"": 12, ""blob_url"": ""https://github.com/json-c/json-c/blob/64e36901a0614bf64a19bc3396469c66dcd0b015/json_object.h"", ""raw_url"": ""https://github.com/json-c/json-c/raw/64e36901a0614bf64a19bc3396469c66dcd0b015/json_object.h"", ""contents_url"": ""https://api.github.com/repos/json-c/json-c/contents/json_object.h?ref=64e36901a0614bf64a19bc3396469c66dcd0b015"", ""patch"": ""@@ -13,6 +13,14 @@\n #ifndef _json_object_h_\n #define _json_object_h_\n \n+#ifdef __GNUC__\n+#define THIS_FUNCTION_IS_DEPRECATED(func) func __attribute__ ((deprecated))\n+#elif defined(_MSC_VER)\n+#define THIS_FUNCTION_IS_DEPRECATED(func) __declspec(deprecated) func\n+#else\n+#define THIS_FUNCTION_IS_DEPRECATED(func) func\n+#endif\n+\n #include \""json_inttypes.h\""\n \n #ifdef __cplusplus\n@@ -279,8 +287,8 @@ extern void json_object_object_add(struct json_object* obj, const char *key,\n  * @returns the json_object associated with the given field name\n  * @deprecated Please use json_object_object_get_ex\n  */\n-extern struct json_object* json_object_object_get(struct json_object* obj,\n-\t\t\t\t\t\t  const char *key);\n+THIS_FUNCTION_IS_DEPRECATED(extern struct json_object* json_object_object_get(struct json_object* obj,\n+\t\t\t\t\t\t  const char *key));\n \n /** Get the json_object associated with a given object field.  \n  *""}<_**next**_>{""sha"": ""19de8efc7a42a4b721535d7d0f4649a562e58a35"", ""filename"": ""json_tokener.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/json-c/json-c/blob/64e36901a0614bf64a19bc3396469c66dcd0b015/json_tokener.c"", ""raw_url"": ""https://github.com/json-c/json-c/raw/64e36901a0614bf64a19bc3396469c66dcd0b015/json_tokener.c"", ""contents_url"": ""https://api.github.com/repos/json-c/json-c/contents/json_tokener.c?ref=64e36901a0614bf64a19bc3396469c66dcd0b015"", ""patch"": ""@@ -81,6 +81,7 @@ static const char* json_tokener_errors[] = {\n   \""object value separator ',' expected\"",\n   \""invalid string sequence\"",\n   \""expected comment\"",\n+  \""buffer size overflow\""\n };\n \n const char *json_tokener_error_desc(enum json_tokener_error jerr)\n@@ -243,6 +244,16 @@ struct json_object* json_tokener_parse_ex(struct json_tokener *tok,\n   tok->char_offset = 0;\n   tok->err = json_tokener_success;\n \n+  /* this interface is presently not 64-bit clean due to the int len argument\n+     and the internal printbuf interface that takes 32-bit int len arguments\n+     so the function limits the maximum string size to INT32_MAX (2GB).\n+     If the function is called with len == -1 then strlen is called to check\n+     the string length is less than INT32_MAX (2GB) */\n+  if ((len < -1) || (len == -1 && strlen(str) > INT32_MAX)) {\n+    tok->err = json_tokener_error_size;\n+    return NULL;\n+  }\n+\n   while (PEEK_CHAR(c, tok)) {\n \n   redo_char:""}<_**next**_>{""sha"": ""a72d2bdefe0064552effd1b4a373ed8335f61a80"", ""filename"": ""json_tokener.h"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 1, ""changes"": 8, ""blob_url"": ""https://github.com/json-c/json-c/blob/64e36901a0614bf64a19bc3396469c66dcd0b015/json_tokener.h"", ""raw_url"": ""https://github.com/json-c/json-c/raw/64e36901a0614bf64a19bc3396469c66dcd0b015/json_tokener.h"", ""contents_url"": ""https://api.github.com/repos/json-c/json-c/contents/json_tokener.h?ref=64e36901a0614bf64a19bc3396469c66dcd0b015"", ""patch"": ""@@ -33,7 +33,8 @@ enum json_tokener_error {\n   json_tokener_error_parse_object_key_sep,\n   json_tokener_error_parse_object_value_sep,\n   json_tokener_error_parse_string,\n-  json_tokener_error_parse_comment\n+  json_tokener_error_parse_comment,\n+  json_tokener_error_size\n };\n \n enum json_tokener_state {\n@@ -163,6 +164,11 @@ extern void json_tokener_set_flags(struct json_tokener *tok, int flags);\n  * responsible for calling json_tokener_parse_ex with an appropriate str\n  * parameter starting with the extra characters.\n  *\n+ * This interface is presently not 64-bit clean due to the int len argument\n+ * so the function limits the maximum string size to INT32_MAX (2GB).\n+ * If the function is called with len == -1 then strlen is called to check\n+ * the string length is less than INT32_MAX (2GB)\n+ *\n  * Example:\n  * @code\n json_object *jobj = NULL;""}<_**next**_>{""sha"": ""712c3879e7081a17b35b9c73f7953294d98d378c"", ""filename"": ""linkhash.c"", ""status"": ""modified"", ""additions"": 374, ""deletions"": 5, ""changes"": 379, ""blob_url"": ""https://github.com/json-c/json-c/blob/64e36901a0614bf64a19bc3396469c66dcd0b015/linkhash.c"", ""raw_url"": ""https://github.com/json-c/json-c/raw/64e36901a0614bf64a19bc3396469c66dcd0b015/linkhash.c"", ""contents_url"": ""https://api.github.com/repos/json-c/json-c/contents/linkhash.c?ref=64e36901a0614bf64a19bc3396469c66dcd0b015"", ""patch"": ""@@ -17,6 +17,11 @@\n #include <stddef.h>\n #include <limits.h>\n \n+#ifdef HAVE_ENDIAN_H\n+# include <endian.h>    /* attempt to define endianness */\n+#endif\n+\n+#include \""random_seed.h\""\n #include \""linkhash.h\""\n \n void lh_abort(const char *msg, ...)\n@@ -39,14 +44,378 @@ int lh_ptr_equal(const void *k1, const void *k2)\n \treturn (k1 == k2);\n }\n \n+/* \n+ * hashlittle from lookup3.c, by Bob Jenkins, May 2006, Public Domain.\n+ * http://burtleburtle.net/bob/c/lookup3.c\n+ * minor modifications to make functions static so no symbols are exported\n+ * minor mofifications to compile with -Werror\n+ */\n+\n+/*\n+-------------------------------------------------------------------------------\n+lookup3.c, by Bob Jenkins, May 2006, Public Domain.\n+\n+These are functions for producing 32-bit hashes for hash table lookup.\n+hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final() \n+are externally useful functions.  Routines to test the hash are included \n+if SELF_TEST is defined.  You can use this free for any purpose.  It's in\n+the public domain.  It has no warranty.\n+\n+You probably want to use hashlittle().  hashlittle() and hashbig()\n+hash byte arrays.  hashlittle() is is faster than hashbig() on\n+little-endian machines.  Intel and AMD are little-endian machines.\n+On second thought, you probably want hashlittle2(), which is identical to\n+hashlittle() except it returns two 32-bit hashes for the price of one.  \n+You could implement hashbig2() if you wanted but I haven't bothered here.\n+\n+If you want to find a hash of, say, exactly 7 integers, do\n+  a = i1;  b = i2;  c = i3;\n+  mix(a,b,c);\n+  a += i4; b += i5; c += i6;\n+  mix(a,b,c);\n+  a += i7;\n+  final(a,b,c);\n+then use c as the hash value.  If you have a variable length array of\n+4-byte integers to hash, use hashword().  If you have a byte array (like\n+a character string), use hashlittle().  If you have several byte arrays, or\n+a mix of things, see the comments above hashlittle().  \n+\n+Why is this so big?  I read 12 bytes at a time into 3 4-byte integers, \n+then mix those integers.  This is fast (you can do a lot more thorough\n+mixing with 12*3 instructions on 3 integers than you can with 3 instructions\n+on 1 byte), but shoehorning those bytes into integers efficiently is messy.\n+-------------------------------------------------------------------------------\n+*/\n+\n+/*\n+ * My best guess at if you are big-endian or little-endian.  This may\n+ * need adjustment.\n+ */\n+#if (defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && \\\n+     __BYTE_ORDER == __LITTLE_ENDIAN) || \\\n+    (defined(i386) || defined(__i386__) || defined(__i486__) || \\\n+     defined(__i586__) || defined(__i686__) || defined(vax) || defined(MIPSEL))\n+# define HASH_LITTLE_ENDIAN 1\n+# define HASH_BIG_ENDIAN 0\n+#elif (defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && \\\n+       __BYTE_ORDER == __BIG_ENDIAN) || \\\n+      (defined(sparc) || defined(POWERPC) || defined(mc68000) || defined(sel))\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 1\n+#else\n+# define HASH_LITTLE_ENDIAN 0\n+# define HASH_BIG_ENDIAN 0\n+#endif\n+\n+#define hashsize(n) ((uint32_t)1<<(n))\n+#define hashmask(n) (hashsize(n)-1)\n+#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n+\n+/*\n+-------------------------------------------------------------------------------\n+mix -- mix 3 32-bit values reversibly.\n+\n+This is reversible, so any information in (a,b,c) before mix() is\n+still in (a,b,c) after mix().\n+\n+If four pairs of (a,b,c) inputs are run through mix(), or through\n+mix() in reverse, there are at least 32 bits of the output that\n+are sometimes the same for one pair and different for another pair.\n+This was tested for:\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+Some k values for my \""a-=c; a^=rot(c,k); c+=b;\"" arrangement that\n+satisfy this are\n+    4  6  8 16 19  4\n+    9 15  3 18 27 15\n+   14  9  3  7 17  3\n+Well, \""9 15 3 18 27 15\"" didn't quite get 32 bits diffing\n+for \""differ\"" defined as + with a one-bit base and a two-bit delta.  I\n+used http://burtleburtle.net/bob/hash/avalanche.html to choose \n+the operations, constants, and arrangements of the variables.\n+\n+This does not achieve avalanche.  There are input bits of (a,b,c)\n+that fail to affect some output bits of (a,b,c), especially of a.  The\n+most thoroughly mixed value is c, but it doesn't really even achieve\n+avalanche in c.\n+\n+This allows some parallelism.  Read-after-writes are good at doubling\n+the number of bits affected, so the goal of mixing pulls in the opposite\n+direction as the goal of parallelism.  I did what I could.  Rotates\n+seem to cost as much as shifts on every machine I could lay my hands\n+on, and rotates are much kinder to the top and bottom bits, so I used\n+rotates.\n+-------------------------------------------------------------------------------\n+*/\n+#define mix(a,b,c) \\\n+{ \\\n+  a -= c;  a ^= rot(c, 4);  c += b; \\\n+  b -= a;  b ^= rot(a, 6);  a += c; \\\n+  c -= b;  c ^= rot(b, 8);  b += a; \\\n+  a -= c;  a ^= rot(c,16);  c += b; \\\n+  b -= a;  b ^= rot(a,19);  a += c; \\\n+  c -= b;  c ^= rot(b, 4);  b += a; \\\n+}\n+\n+/*\n+-------------------------------------------------------------------------------\n+final -- final mixing of 3 32-bit values (a,b,c) into c\n+\n+Pairs of (a,b,c) values differing in only a few bits will usually\n+produce values of c that look totally different.  This was tested for\n+* pairs that differed by one bit, by two bits, in any combination\n+  of top bits of (a,b,c), or in any combination of bottom bits of\n+  (a,b,c).\n+* \""differ\"" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n+  is commonly produced by subtraction) look like a single 1-bit\n+  difference.\n+* the base values were pseudorandom, all zero but one bit set, or \n+  all zero plus a counter that starts at zero.\n+\n+These constants passed:\n+ 14 11 25 16 4 14 24\n+ 12 14 25 16 4 14 24\n+and these came close:\n+  4  8 15 26 3 22 24\n+ 10  8 15 26 3 22 24\n+ 11  8 15 26 3 22 24\n+-------------------------------------------------------------------------------\n+*/\n+#define final(a,b,c) \\\n+{ \\\n+  c ^= b; c -= rot(b,14); \\\n+  a ^= c; a -= rot(c,11); \\\n+  b ^= a; b -= rot(a,25); \\\n+  c ^= b; c -= rot(b,16); \\\n+  a ^= c; a -= rot(c,4);  \\\n+  b ^= a; b -= rot(a,14); \\\n+  c ^= b; c -= rot(b,24); \\\n+}\n+\n+\n+/*\n+-------------------------------------------------------------------------------\n+hashlittle() -- hash a variable-length key into a 32-bit value\n+  k       : the key (the unaligned variable-length array of bytes)\n+  length  : the length of the key, counting by bytes\n+  initval : can be any 4-byte value\n+Returns a 32-bit value.  Every bit of the key affects every bit of\n+the return value.  Two keys differing by one or two bits will have\n+totally different hash values.\n+\n+The best hash table sizes are powers of 2.  There is no need to do\n+mod a prime (mod is sooo slow!).  If you need less than 32 bits,\n+use a bitmask.  For example, if you need only 10 bits, do\n+  h = (h & hashmask(10));\n+In which case, the hash table should have hashsize(10) elements.\n+\n+If you are hashing n strings (uint8_t **)k, do it like this:\n+  for (i=0, h=0; i<n; ++i) h = hashlittle( k[i], len[i], h);\n+\n+By Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this\n+code any way you wish, private, educational, or commercial.  It's free.\n+\n+Use for hash table lookup, or anything where one collision in 2^^32 is\n+acceptable.  Do NOT use for cryptographic purposes.\n+-------------------------------------------------------------------------------\n+*/\n+\n+static uint32_t hashlittle( const void *key, size_t length, uint32_t initval)\n+{\n+  uint32_t a,b,c;                                          /* internal state */\n+  union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */\n+\n+  /* Set up the internal state */\n+  a = b = c = 0xdeadbeef + ((uint32_t)length) + initval;\n+\n+  u.ptr = key;\n+  if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0)) {\n+    const uint32_t *k = (const uint32_t *)key;         /* read 32-bit chunks */\n+\n+    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      b += k[1];\n+      c += k[2];\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 3;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    /* \n+     * \""k[2]&0xffffff\"" actually reads beyond the end of the string, but\n+     * then masks off the part it's not allowed to read.  Because the\n+     * string is aligned, the masked-off tail is in the same word as the\n+     * rest of the string.  Every machine with memory protection I've seen\n+     * does it on word boundaries, so is OK with this.  But VALGRIND will\n+     * still catch it and complain.  The masking trick does make the hash\n+     * noticably faster for short strings (like English words).\n+     */\n+#ifndef VALGRIND\n+\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n+    case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n+    case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n+    case 6 : b+=k[1]&0xffff; a+=k[0]; break;\n+    case 5 : b+=k[1]&0xff; a+=k[0]; break;\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=k[0]&0xffffff; break;\n+    case 2 : a+=k[0]&0xffff; break;\n+    case 1 : a+=k[0]&0xff; break;\n+    case 0 : return c;              /* zero length strings require no mixing */\n+    }\n+\n+#else /* make valgrind happy */\n+\n+    const uint8_t  *k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n+    case 11: c+=((uint32_t)k8[10])<<16;  /* fall through */\n+    case 10: c+=((uint32_t)k8[9])<<8;    /* fall through */\n+    case 9 : c+=k8[8];                   /* fall through */\n+    case 8 : b+=k[1]; a+=k[0]; break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;   /* fall through */\n+    case 6 : b+=((uint32_t)k8[5])<<8;    /* fall through */\n+    case 5 : b+=k8[4];                   /* fall through */\n+    case 4 : a+=k[0]; break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;   /* fall through */\n+    case 2 : a+=((uint32_t)k8[1])<<8;    /* fall through */\n+    case 1 : a+=k8[0]; break;\n+    case 0 : return c;\n+    }\n+\n+#endif /* !valgrind */\n+\n+  } else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0)) {\n+    const uint16_t *k = (const uint16_t *)key;         /* read 16-bit chunks */\n+    const uint8_t  *k8;\n+\n+    /*--------------- all but last block: aligned reads and different mixing */\n+    while (length > 12)\n+    {\n+      a += k[0] + (((uint32_t)k[1])<<16);\n+      b += k[2] + (((uint32_t)k[3])<<16);\n+      c += k[4] + (((uint32_t)k[5])<<16);\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 6;\n+    }\n+\n+    /*----------------------------- handle the last (probably partial) block */\n+    k8 = (const uint8_t *)k;\n+    switch(length)\n+    {\n+    case 12: c+=k[4]+(((uint32_t)k[5])<<16);\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 11: c+=((uint32_t)k8[10])<<16;     /* fall through */\n+    case 10: c+=k[4];\n+             b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 9 : c+=k8[8];                      /* fall through */\n+    case 8 : b+=k[2]+(((uint32_t)k[3])<<16);\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 7 : b+=((uint32_t)k8[6])<<16;      /* fall through */\n+    case 6 : b+=k[2];\n+             a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 5 : b+=k8[4];                      /* fall through */\n+    case 4 : a+=k[0]+(((uint32_t)k[1])<<16);\n+             break;\n+    case 3 : a+=((uint32_t)k8[2])<<16;      /* fall through */\n+    case 2 : a+=k[0];\n+             break;\n+    case 1 : a+=k8[0];\n+             break;\n+    case 0 : return c;                     /* zero length requires no mixing */\n+    }\n+\n+  } else {                        /* need to read the key one byte at a time */\n+    const uint8_t *k = (const uint8_t *)key;\n+\n+    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */\n+    while (length > 12)\n+    {\n+      a += k[0];\n+      a += ((uint32_t)k[1])<<8;\n+      a += ((uint32_t)k[2])<<16;\n+      a += ((uint32_t)k[3])<<24;\n+      b += k[4];\n+      b += ((uint32_t)k[5])<<8;\n+      b += ((uint32_t)k[6])<<16;\n+      b += ((uint32_t)k[7])<<24;\n+      c += k[8];\n+      c += ((uint32_t)k[9])<<8;\n+      c += ((uint32_t)k[10])<<16;\n+      c += ((uint32_t)k[11])<<24;\n+      mix(a,b,c);\n+      length -= 12;\n+      k += 12;\n+    }\n+\n+    /*-------------------------------- last block: affect all 32 bits of (c) */\n+    switch(length)                   /* all the case statements fall through */\n+    {\n+    case 12: c+=((uint32_t)k[11])<<24;\n+    case 11: c+=((uint32_t)k[10])<<16;\n+    case 10: c+=((uint32_t)k[9])<<8;\n+    case 9 : c+=k[8];\n+    case 8 : b+=((uint32_t)k[7])<<24;\n+    case 7 : b+=((uint32_t)k[6])<<16;\n+    case 6 : b+=((uint32_t)k[5])<<8;\n+    case 5 : b+=k[4];\n+    case 4 : a+=((uint32_t)k[3])<<24;\n+    case 3 : a+=((uint32_t)k[2])<<16;\n+    case 2 : a+=((uint32_t)k[1])<<8;\n+    case 1 : a+=k[0];\n+             break;\n+    case 0 : return c;\n+    }\n+  }\n+\n+  final(a,b,c);\n+  return c;\n+}\n+\n unsigned long lh_char_hash(const void *k)\n {\n-\tunsigned int h = 0;\n-\tconst char* data = (const char*)k;\n- \n-\twhile( *data!=0 ) h = h*129 + (unsigned int)(*data++) + LH_PRIME;\n+\tstatic volatile int random_seed = -1;\n+\n+\tif (random_seed == -1) {\n+\t\tint seed;\n+\t\t/* we can't use -1 as it is the unitialized sentinel */\n+\t\twhile ((seed = json_c_get_random_seed()) == -1);\n+#if defined __GNUC__\n+\t\t__sync_val_compare_and_swap(&random_seed, -1, seed);\n+#elif defined _MSC_VER\n+\t\tInterlockedCompareExchange(&random_seed, seed, -1);\n+#else\n+#warning \""racy random seed initializtion if used by multiple threads\""\n+\t\trandom_seed = seed; /* potentially racy */\n+#endif\n+\t}\n \n-\treturn h;\n+\treturn hashlittle((const char*)k, strlen((const char*)k), random_seed); \n }\n \n int lh_char_equal(const void *k1, const void *k2)""}<_**next**_>{""sha"": ""950d09f35d70cf026852c9d50cb85a3129944e3c"", ""filename"": ""linkhash.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/json-c/json-c/blob/64e36901a0614bf64a19bc3396469c66dcd0b015/linkhash.h"", ""raw_url"": ""https://github.com/json-c/json-c/raw/64e36901a0614bf64a19bc3396469c66dcd0b015/linkhash.h"", ""contents_url"": ""https://api.github.com/repos/json-c/json-c/contents/linkhash.h?ref=64e36901a0614bf64a19bc3396469c66dcd0b015"", ""patch"": ""@@ -246,7 +246,7 @@ extern struct lh_entry* lh_table_lookup_entry(struct lh_table *t, const void *k)\n  * @return a pointer to the found value or NULL if it does not exist.\n  * @deprecated Use lh_table_lookup_ex instead.\n  */\n-extern const void* lh_table_lookup(struct lh_table *t, const void *k);\n+THIS_FUNCTION_IS_DEPRECATED(extern const void* lh_table_lookup(struct lh_table *t, const void *k));\n \n /**\n  * Lookup a record in the table""}<_**next**_>{""sha"": ""3b520d411e8a8a161f5cc256e1d98a91c8e2b3e8"", ""filename"": ""random_seed.c"", ""status"": ""added"", ""additions"": 237, ""deletions"": 0, ""changes"": 237, ""blob_url"": ""https://github.com/json-c/json-c/blob/64e36901a0614bf64a19bc3396469c66dcd0b015/random_seed.c"", ""raw_url"": ""https://github.com/json-c/json-c/raw/64e36901a0614bf64a19bc3396469c66dcd0b015/random_seed.c"", ""contents_url"": ""https://api.github.com/repos/json-c/json-c/contents/random_seed.c?ref=64e36901a0614bf64a19bc3396469c66dcd0b015"", ""patch"": ""@@ -0,0 +1,237 @@\n+/*\n+ * random_seed.c\n+ *\n+ * Copyright (c) 2013 Metaparadigm Pte. Ltd.\n+ * Michael Clark <michael@metaparadigm.com>\n+ *\n+ * This library is free software; you can redistribute it and/or modify\n+ * it under the terms of the MIT license. See COPYING for details.\n+ *\n+ */\n+\n+#include <stdio.h>\n+#include \""config.h\""\n+\n+#define DEBUG_SEED(s)\n+\n+\n+#if defined ENABLE_RDRAND\n+\n+/* cpuid */\n+\n+#if defined __GNUC__ && (defined __i386__ || defined __x86_64__)\n+#define HAS_X86_CPUID 1\n+\n+static void do_cpuid(int regs[], int h)\n+{\n+    __asm__ __volatile__(\n+#if defined __x86_64__\n+                         \""pushq %%rbx;\\n\""\n+#else\n+                         \""pushl %%ebx;\\n\""\n+#endif\n+                         \""cpuid;\\n\""\n+#if defined __x86_64__\n+                         \""popq %%rbx;\\n\""\n+#else\n+                         \""popl %%ebx;\\n\""\n+#endif\n+                         : \""=a\""(regs[0]), [ebx] \""=r\""(regs[1]), \""=c\""(regs[2]), \""=d\""(regs[3])\n+                         : \""a\""(h));\n+}\n+\n+#elif defined _MSC_VER\n+\n+#define HAS_X86_CPUID 1\n+#define do_cpuid __cpuid\n+\n+#endif\n+\n+/* has_rdrand */\n+\n+#if HAS_X86_CPUID\n+\n+static int has_rdrand()\n+{\n+    // CPUID.01H:ECX.RDRAND[bit 30] == 1\n+    int regs[4];\n+    do_cpuid(regs, 1);\n+    return (regs[2] & (1 << 30)) != 0;\n+}\n+\n+#endif\n+\n+/* get_rdrand_seed - GCC x86 and X64 */\n+\n+#if defined __GNUC__ && (defined __i386__ || defined __x86_64__)\n+\n+#define HAVE_RDRAND 1\n+\n+static int get_rdrand_seed()\n+{\n+    DEBUG_SEED(\""get_rdrand_seed\"");\n+    int _eax;\n+    // rdrand eax\n+    __asm__ __volatile__(\""1: .byte 0x0F\\n\""\n+                         \""   .byte 0xC7\\n\""\n+                         \""   .byte 0xF0\\n\""\n+                         \""   jnc 1b;\\n\""\n+                         : \""=a\"" (_eax));\n+    return _eax;\n+}\n+\n+#endif\n+\n+#if defined _MSC_VER\n+\n+#if _MSC_VER >= 1700\n+#define HAVE_RDRAND 1\n+\n+/* get_rdrand_seed - Visual Studio 2012 and above */\n+\n+static int get_rdrand_seed()\n+{\n+    DEBUG_SEED(\""get_rdrand_seed\"");\n+    int r;\n+    while (_rdrand32_step(&r) == 0);\n+    return r;\n+}\n+\n+#elif defined _M_IX86\n+#define HAVE_RDRAND 1\n+\n+/* get_rdrand_seed - Visual Studio 2010 and below - x86 only */\n+\n+static int get_rdrand_seed()\n+{\n+\tDEBUG_SEED(\""get_rdrand_seed\"");\n+\tint _eax;\n+retry:\n+\t// rdrand eax\n+\t__asm _emit 0x0F __asm _emit 0xC7 __asm _emit 0xF0\n+\t__asm jnc retry\n+\t__asm mov _eax, eax\n+\treturn _eax;\n+}\n+\n+#endif\n+#endif\n+\n+#endif /* defined ENABLE_RDRAND */\n+\n+\n+/* has_dev_urandom */\n+\n+#if defined (__APPLE__) || defined(__unix__) || defined(__linux__)\n+\n+#include <string.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+#include <errno.h>\n+#include <stdlib.h>\n+#include <sys/stat.h>\n+\n+#define HAVE_DEV_RANDOM 1\n+\n+static const char *dev_random_file = \""/dev/urandom\"";\n+\n+static int has_dev_urandom()\n+{\n+    struct stat buf;\n+    if (stat(dev_random_file, &buf)) {\n+        return 0;\n+    }\n+    return ((buf.st_mode & S_IFCHR) != 0);\n+}\n+\n+\n+/* get_dev_random_seed */\n+\n+static int get_dev_random_seed()\n+{\n+    DEBUG_SEED(\""get_dev_random_seed\"");\n+    \n+    int fd = open(dev_random_file, O_RDONLY);\n+    if (fd < 0) {\n+        fprintf(stderr, \""error opening %s: %s\"", dev_random_file, strerror(errno));\n+        exit(1);\n+    }\n+    \n+    int r;\n+    ssize_t nread = read(fd, &r, sizeof(r));\n+    if (nread != sizeof(r)) {\n+        fprintf(stderr, \""error read %s: %s\"", dev_random_file, strerror(errno));\n+        exit(1);\n+    }\n+    else if (nread != sizeof(r)) {\n+        fprintf(stderr, \""error short read %s\"", dev_random_file);\n+        exit(1);\n+    }\n+    close(fd);\n+    return r;\n+}\n+\n+#endif\n+\n+\n+/* get_cryptgenrandom_seed */\n+\n+#ifdef WIN32\n+\n+#define HAVE_CRYPTGENRANDOM 1\n+\n+#include <windows.h>\n+#pragma comment(lib, \""advapi32.lib\"")\n+\n+static int get_cryptgenrandom_seed()\n+{\n+    DEBUG_SEED(\""get_cryptgenrandom_seed\"");\n+    \n+    HCRYPTPROV hProvider = 0;\n+    int r;\n+    \n+    if (!CryptAcquireContextW(&hProvider, 0, 0, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_SILENT)) {\n+        fprintf(stderr, \""error CryptAcquireContextW\"");\n+        exit(1);\n+    }\n+    \n+    if (!CryptGenRandom(hProvider, sizeof(r), (BYTE*)&r)) {\n+        fprintf(stderr, \""error CryptGenRandom\"");\n+        exit(1);\n+    }\n+    \n+    CryptReleaseContext(hProvider, 0);\n+    \n+    return r;\n+}\n+\n+#endif\n+\n+\n+/* get_time_seed */\n+\n+#include <time.h>\n+\n+static int get_time_seed()\n+{\n+    DEBUG_SEED(\""get_time_seed\"");\n+    \n+    return (int)time(NULL) * 433494437;\n+}\n+\n+\n+/* json_c_get_random_seed */\n+\n+int json_c_get_random_seed()\n+{\n+#if HAVE_RDRAND\n+    if (has_rdrand()) return get_rdrand_seed();\n+#endif\n+#if HAVE_DEV_RANDOM\n+    if (has_dev_urandom()) return get_dev_random_seed();\n+#endif\n+#if HAVE_CRYPTGENRANDOM\n+    return get_cryptgenrandom_seed();\n+#endif\n+    return get_time_seed();\n+}""}<_**next**_>{""sha"": ""7362d67d9cd5431ca95fdfb361aef9af0b79b84e"", ""filename"": ""random_seed.h"", ""status"": ""added"", ""additions"": 25, ""deletions"": 0, ""changes"": 25, ""blob_url"": ""https://github.com/json-c/json-c/blob/64e36901a0614bf64a19bc3396469c66dcd0b015/random_seed.h"", ""raw_url"": ""https://github.com/json-c/json-c/raw/64e36901a0614bf64a19bc3396469c66dcd0b015/random_seed.h"", ""contents_url"": ""https://api.github.com/repos/json-c/json-c/contents/random_seed.h?ref=64e36901a0614bf64a19bc3396469c66dcd0b015"", ""patch"": ""@@ -0,0 +1,25 @@\n+/*\n+ * random_seed.h\n+ *\n+ * Copyright (c) 2013 Metaparadigm Pte. Ltd.\n+ * Michael Clark <michael@metaparadigm.com>\n+ *\n+ * This library is free software; you can redistribute it and/or modify\n+ * it under the terms of the MIT license. See COPYING for details.\n+ *\n+ */\n+\n+#ifndef seed_h\n+#define seed_h\n+\n+#ifdef __cplusplus\n+extern \""C\"" {\n+#endif\n+\n+extern int json_c_get_random_seed();\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif""}"," unsigned long lh_char_hash(const void *k)
 {
	static volatile int random_seed = -1;

	if (random_seed == -1) {
		int seed;
		/* we can't use -1 as it is the unitialized sentinel */
		while ((seed = json_c_get_random_seed()) == -1);
#if defined __GNUC__
		__sync_val_compare_and_swap(&random_seed, -1, seed);
#elif defined _MSC_VER
		InterlockedCompareExchange(&random_seed, seed, -1);
#else
#warning ""racy random seed initializtion if used by multiple threads""
		random_seed = seed; /* potentially racy */
#endif
	}
 
	return hashlittle((const char*)k, strlen((const char*)k), random_seed); 
 }
"," unsigned long lh_char_hash(const void *k)
 {
	unsigned int h = 0;
	const char* data = (const char*)k;
	while( *data!=0 ) h = h*129 + (unsigned int)(*data++) + LH_PRIME;
 
	return h;
 }
",C,"	static volatile int random_seed = -1;

	if (random_seed == -1) {
		int seed;
		/* we can't use -1 as it is the unitialized sentinel */
		while ((seed = json_c_get_random_seed()) == -1);
#if defined __GNUC__
		__sync_val_compare_and_swap(&random_seed, -1, seed);
#elif defined _MSC_VER
		InterlockedCompareExchange(&random_seed, seed, -1);
#else
#warning ""racy random seed initializtion if used by multiple threads""
		random_seed = seed; /* potentially racy */
#endif
	}
	return hashlittle((const char*)k, strlen((const char*)k), random_seed); 
","	unsigned int h = 0;
	const char* data = (const char*)k;
	while( *data!=0 ) h = h*129 + (unsigned int)(*data++) + LH_PRIME;
	return h;
",,"@@ -17,6 +17,11 @@
 #include <stddef.h>
 #include <limits.h>
 
+#ifdef HAVE_ENDIAN_H
+# include <endian.h>    /* attempt to define endianness */
+#endif
+
+#include ""random_seed.h""
 #include ""linkhash.h""
 
 void lh_abort(const char *msg, ...)
@@ -39,14 +44,378 @@ int lh_ptr_equal(const void *k1, const void *k2)
 	return (k1 == k2);
 }
 
+/* 
+ * hashlittle from lookup3.c, by Bob Jenkins, May 2006, Public Domain.
+ * http://burtleburtle.net/bob/c/lookup3.c
+ * minor modifications to make functions static so no symbols are exported
+ * minor mofifications to compile with -Werror
+ */
+
+/*
+-------------------------------------------------------------------------------
+lookup3.c, by Bob Jenkins, May 2006, Public Domain.
+
+These are functions for producing 32-bit hashes for hash table lookup.
+hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final() 
+are externally useful functions.  Routines to test the hash are included 
+if SELF_TEST is defined.  You can use this free for any purpose.  It's in
+the public domain.  It has no warranty.
+
+You probably want to use hashlittle().  hashlittle() and hashbig()
+hash byte arrays.  hashlittle() is is faster than hashbig() on
+little-endian machines.  Intel and AMD are little-endian machines.
+On second thought, you probably want hashlittle2(), which is identical to
+hashlittle() except it returns two 32-bit hashes for the price of one.  
+You could implement hashbig2() if you wanted but I haven't bothered here.
+
+If you want to find a hash of, say, exactly 7 integers, do
+  a = i1;  b = i2;  c = i3;
+  mix(a,b,c);
+  a += i4; b += i5; c += i6;
+  mix(a,b,c);
+  a += i7;
+  final(a,b,c);
+then use c as the hash value.  If you have a variable length array of
+4-byte integers to hash, use hashword().  If you have a byte array (like
+a character string), use hashlittle().  If you have several byte arrays, or
+a mix of things, see the comments above hashlittle().  
+
+Why is this so big?  I read 12 bytes at a time into 3 4-byte integers, 
+then mix those integers.  This is fast (you can do a lot more thorough
+mixing with 12*3 instructions on 3 integers than you can with 3 instructions
+on 1 byte), but shoehorning those bytes into integers efficiently is messy.
+-------------------------------------------------------------------------------
+*/
+
+/*
+ * My best guess at if you are big-endian or little-endian.  This may
+ * need adjustment.
+ */
+#if (defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && \
+     __BYTE_ORDER == __LITTLE_ENDIAN) || \
+    (defined(i386) || defined(__i386__) || defined(__i486__) || \
+     defined(__i586__) || defined(__i686__) || defined(vax) || defined(MIPSEL))
+# define HASH_LITTLE_ENDIAN 1
+# define HASH_BIG_ENDIAN 0
+#elif (defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && \
+       __BYTE_ORDER == __BIG_ENDIAN) || \
+      (defined(sparc) || defined(POWERPC) || defined(mc68000) || defined(sel))
+# define HASH_LITTLE_ENDIAN 0
+# define HASH_BIG_ENDIAN 1
+#else
+# define HASH_LITTLE_ENDIAN 0
+# define HASH_BIG_ENDIAN 0
+#endif
+
+#define hashsize(n) ((uint32_t)1<<(n))
+#define hashmask(n) (hashsize(n)-1)
+#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))
+
+/*
+-------------------------------------------------------------------------------
+mix -- mix 3 32-bit values reversibly.
+
+This is reversible, so any information in (a,b,c) before mix() is
+still in (a,b,c) after mix().
+
+If four pairs of (a,b,c) inputs are run through mix(), or through
+mix() in reverse, there are at least 32 bits of the output that
+are sometimes the same for one pair and different for another pair.
+This was tested for:
+* pairs that differed by one bit, by two bits, in any combination
+  of top bits of (a,b,c), or in any combination of bottom bits of
+  (a,b,c).
+* ""differ"" is defined as +, -, ^, or ~^.  For + and -, I transformed
+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as
+  is commonly produced by subtraction) look like a single 1-bit
+  difference.
+* the base values were pseudorandom, all zero but one bit set, or 
+  all zero plus a counter that starts at zero.
+
+Some k values for my ""a-=c; a^=rot(c,k); c+=b;"" arrangement that
+satisfy this are
+    4  6  8 16 19  4
+    9 15  3 18 27 15
+   14  9  3  7 17  3
+Well, ""9 15 3 18 27 15"" didn't quite get 32 bits diffing
+for ""differ"" defined as + with a one-bit base and a two-bit delta.  I
+used http://burtleburtle.net/bob/hash/avalanche.html to choose 
+the operations, constants, and arrangements of the variables.
+
+This does not achieve avalanche.  There are input bits of (a,b,c)
+that fail to affect some output bits of (a,b,c), especially of a.  The
+most thoroughly mixed value is c, but it doesn't really even achieve
+avalanche in c.
+
+This allows some parallelism.  Read-after-writes are good at doubling
+the number of bits affected, so the goal of mixing pulls in the opposite
+direction as the goal of parallelism.  I did what I could.  Rotates
+seem to cost as much as shifts on every machine I could lay my hands
+on, and rotates are much kinder to the top and bottom bits, so I used
+rotates.
+-------------------------------------------------------------------------------
+*/
+#define mix(a,b,c) \
+{ \
+  a -= c;  a ^= rot(c, 4);  c += b; \
+  b -= a;  b ^= rot(a, 6);  a += c; \
+  c -= b;  c ^= rot(b, 8);  b += a; \
+  a -= c;  a ^= rot(c,16);  c += b; \
+  b -= a;  b ^= rot(a,19);  a += c; \
+  c -= b;  c ^= rot(b, 4);  b += a; \
+}
+
+/*
+-------------------------------------------------------------------------------
+final -- final mixing of 3 32-bit values (a,b,c) into c
+
+Pairs of (a,b,c) values differing in only a few bits will usually
+produce values of c that look totally different.  This was tested for
+* pairs that differed by one bit, by two bits, in any combination
+  of top bits of (a,b,c), or in any combination of bottom bits of
+  (a,b,c).
+* ""differ"" is defined as +, -, ^, or ~^.  For + and -, I transformed
+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as
+  is commonly produced by subtraction) look like a single 1-bit
+  difference.
+* the base values were pseudorandom, all zero but one bit set, or 
+  all zero plus a counter that starts at zero.
+
+These constants passed:
+ 14 11 25 16 4 14 24
+ 12 14 25 16 4 14 24
+and these came close:
+  4  8 15 26 3 22 24
+ 10  8 15 26 3 22 24
+ 11  8 15 26 3 22 24
+-------------------------------------------------------------------------------
+*/
+#define final(a,b,c) \
+{ \
+  c ^= b; c -= rot(b,14); \
+  a ^= c; a -= rot(c,11); \
+  b ^= a; b -= rot(a,25); \
+  c ^= b; c -= rot(b,16); \
+  a ^= c; a -= rot(c,4);  \
+  b ^= a; b -= rot(a,14); \
+  c ^= b; c -= rot(b,24); \
+}
+
+
+/*
+-------------------------------------------------------------------------------
+hashlittle() -- hash a variable-length key into a 32-bit value
+  k       : the key (the unaligned variable-length array of bytes)
+  length  : the length of the key, counting by bytes
+  initval : can be any 4-byte value
+Returns a 32-bit value.  Every bit of the key affects every bit of
+the return value.  Two keys differing by one or two bits will have
+totally different hash values.
+
+The best hash table sizes are powers of 2.  There is no need to do
+mod a prime (mod is sooo slow!).  If you need less than 32 bits,
+use a bitmask.  For example, if you need only 10 bits, do
+  h = (h & hashmask(10));
+In which case, the hash table should have hashsize(10) elements.
+
+If you are hashing n strings (uint8_t **)k, do it like this:
+  for (i=0, h=0; i<n; ++i) h = hashlittle( k[i], len[i], h);
+
+By Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this
+code any way you wish, private, educational, or commercial.  It's free.
+
+Use for hash table lookup, or anything where one collision in 2^^32 is
+acceptable.  Do NOT use for cryptographic purposes.
+-------------------------------------------------------------------------------
+*/
+
+static uint32_t hashlittle( const void *key, size_t length, uint32_t initval)
+{
+  uint32_t a,b,c;                                          /* internal state */
+  union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */
+
+  /* Set up the internal state */
+  a = b = c = 0xdeadbeef + ((uint32_t)length) + initval;
+
+  u.ptr = key;
+  if (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0)) {
+    const uint32_t *k = (const uint32_t *)key;         /* read 32-bit chunks */
+
+    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */
+    while (length > 12)
+    {
+      a += k[0];
+      b += k[1];
+      c += k[2];
+      mix(a,b,c);
+      length -= 12;
+      k += 3;
+    }
+
+    /*----------------------------- handle the last (probably partial) block */
+    /* 
+     * ""k[2]&0xffffff"" actually reads beyond the end of the string, but
+     * then masks off the part it's not allowed to read.  Because the
+     * string is aligned, the masked-off tail is in the same word as the
+     * rest of the string.  Every machine with memory protection I've seen
+     * does it on word boundaries, so is OK with this.  But VALGRIND will
+     * still catch it and complain.  The masking trick does make the hash
+     * noticably faster for short strings (like English words).
+     */
+#ifndef VALGRIND
+
+    switch(length)
+    {
+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;
+    case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;
+    case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;
+    case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;
+    case 8 : b+=k[1]; a+=k[0]; break;
+    case 7 : b+=k[1]&0xffffff; a+=k[0]; break;
+    case 6 : b+=k[1]&0xffff; a+=k[0]; break;
+    case 5 : b+=k[1]&0xff; a+=k[0]; break;
+    case 4 : a+=k[0]; break;
+    case 3 : a+=k[0]&0xffffff; break;
+    case 2 : a+=k[0]&0xffff; break;
+    case 1 : a+=k[0]&0xff; break;
+    case 0 : return c;              /* zero length strings require no mixing */
+    }
+
+#else /* make valgrind happy */
+
+    const uint8_t  *k8 = (const uint8_t *)k;
+    switch(length)
+    {
+    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;
+    case 11: c+=((uint32_t)k8[10])<<16;  /* fall through */
+    case 10: c+=((uint32_t)k8[9])<<8;    /* fall through */
+    case 9 : c+=k8[8];                   /* fall through */
+    case 8 : b+=k[1]; a+=k[0]; break;
+    case 7 : b+=((uint32_t)k8[6])<<16;   /* fall through */
+    case 6 : b+=((uint32_t)k8[5])<<8;    /* fall through */
+    case 5 : b+=k8[4];                   /* fall through */
+    case 4 : a+=k[0]; break;
+    case 3 : a+=((uint32_t)k8[2])<<16;   /* fall through */
+    case 2 : a+=((uint32_t)k8[1])<<8;    /* fall through */
+    case 1 : a+=k8[0]; break;
+    case 0 : return c;
+    }
+
+#endif /* !valgrind */
+
+  } else if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0)) {
+    const uint16_t *k = (const uint16_t *)key;         /* read 16-bit chunks */
+    const uint8_t  *k8;
+
+    /*--------------- all but last block: aligned reads and different mixing */
+    while (length > 12)
+    {
+      a += k[0] + (((uint32_t)k[1])<<16);
+      b += k[2] + (((uint32_t)k[3])<<16);
+      c += k[4] + (((uint32_t)k[5])<<16);
+      mix(a,b,c);
+      length -= 12;
+      k += 6;
+    }
+
+    /*----------------------------- handle the last (probably partial) block */
+    k8 = (const uint8_t *)k;
+    switch(length)
+    {
+    case 12: c+=k[4]+(((uint32_t)k[5])<<16);
+             b+=k[2]+(((uint32_t)k[3])<<16);
+             a+=k[0]+(((uint32_t)k[1])<<16);
+             break;
+    case 11: c+=((uint32_t)k8[10])<<16;     /* fall through */
+    case 10: c+=k[4];
+             b+=k[2]+(((uint32_t)k[3])<<16);
+             a+=k[0]+(((uint32_t)k[1])<<16);
+             break;
+    case 9 : c+=k8[8];                      /* fall through */
+    case 8 : b+=k[2]+(((uint32_t)k[3])<<16);
+             a+=k[0]+(((uint32_t)k[1])<<16);
+             break;
+    case 7 : b+=((uint32_t)k8[6])<<16;      /* fall through */
+    case 6 : b+=k[2];
+             a+=k[0]+(((uint32_t)k[1])<<16);
+             break;
+    case 5 : b+=k8[4];                      /* fall through */
+    case 4 : a+=k[0]+(((uint32_t)k[1])<<16);
+             break;
+    case 3 : a+=((uint32_t)k8[2])<<16;      /* fall through */
+    case 2 : a+=k[0];
+             break;
+    case 1 : a+=k8[0];
+             break;
+    case 0 : return c;                     /* zero length requires no mixing */
+    }
+
+  } else {                        /* need to read the key one byte at a time */
+    const uint8_t *k = (const uint8_t *)key;
+
+    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */
+    while (length > 12)
+    {
+      a += k[0];
+      a += ((uint32_t)k[1])<<8;
+      a += ((uint32_t)k[2])<<16;
+      a += ((uint32_t)k[3])<<24;
+      b += k[4];
+      b += ((uint32_t)k[5])<<8;
+      b += ((uint32_t)k[6])<<16;
+      b += ((uint32_t)k[7])<<24;
+      c += k[8];
+      c += ((uint32_t)k[9])<<8;
+      c += ((uint32_t)k[10])<<16;
+      c += ((uint32_t)k[11])<<24;
+      mix(a,b,c);
+      length -= 12;
+      k += 12;
+    }
+
+    /*-------------------------------- last block: affect all 32 bits of (c) */
+    switch(length)                   /* all the case statements fall through */
+    {
+    case 12: c+=((uint32_t)k[11])<<24;
+    case 11: c+=((uint32_t)k[10])<<16;
+    case 10: c+=((uint32_t)k[9])<<8;
+    case 9 : c+=k[8];
+    case 8 : b+=((uint32_t)k[7])<<24;
+    case 7 : b+=((uint32_t)k[6])<<16;
+    case 6 : b+=((uint32_t)k[5])<<8;
+    case 5 : b+=k[4];
+    case 4 : a+=((uint32_t)k[3])<<24;
+    case 3 : a+=((uint32_t)k[2])<<16;
+    case 2 : a+=((uint32_t)k[1])<<8;
+    case 1 : a+=k[0];
+             break;
+    case 0 : return c;
+    }
+  }
+
+  final(a,b,c);
+  return c;
+}
+
 unsigned long lh_char_hash(const void *k)
 {
-	unsigned int h = 0;
-	const char* data = (const char*)k;
- 
-	while( *data!=0 ) h = h*129 + (unsigned int)(*data++) + LH_PRIME;
+	static volatile int random_seed = -1;
+
+	if (random_seed == -1) {
+		int seed;
+		/* we can't use -1 as it is the unitialized sentinel */
+		while ((seed = json_c_get_random_seed()) == -1);
+#if defined __GNUC__
+		__sync_val_compare_and_swap(&random_seed, -1, seed);
+#elif defined _MSC_VER
+		InterlockedCompareExchange(&random_seed, seed, -1);
+#else
+#warning ""racy random seed initializtion if used by multiple threads""
+		random_seed = seed; /* potentially racy */
+#endif
+	}
 
-	return h;
+	return hashlittle((const char*)k, strlen((const char*)k), random_seed); 
 }
 
 int lh_char_equal(const void *k1, const void *k2)",json-c,64e36901a0614bf64a19bc3396469c66dcd0b015,784534a31f301466d9ab6f8d5b5ccd39a3b9f156,1," unsigned long lh_char_hash(const void *k)
 {
//flaw_line_below:
	unsigned int h = 0;
//flaw_line_below:
	const char* data = (const char*)k;
//flaw_line_below:
 
//flaw_line_below:
	while( *data!=0 ) h = h*129 + (unsigned int)(*data++) + LH_PRIME;
//fix_flaw_line_below:
//	static volatile int random_seed = -1;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (random_seed == -1) {
//fix_flaw_line_below:
//		int seed;
//fix_flaw_line_below:
//		/* we can't use -1 as it is the unitialized sentinel */
//fix_flaw_line_below:
//		while ((seed = json_c_get_random_seed()) == -1);
//fix_flaw_line_below:
//#if defined __GNUC__
//fix_flaw_line_below:
//		__sync_val_compare_and_swap(&random_seed, -1, seed);
//fix_flaw_line_below:
//#elif defined _MSC_VER
//fix_flaw_line_below:
//		InterlockedCompareExchange(&random_seed, seed, -1);
//fix_flaw_line_below:
//#else
//fix_flaw_line_below:
//#warning ""racy random seed initializtion if used by multiple threads""
//fix_flaw_line_below:
//		random_seed = seed; /* potentially racy */
//fix_flaw_line_below:
//#endif
//fix_flaw_line_below:
//	}
 
//flaw_line_below:
	return h;
//fix_flaw_line_below:
//	return hashlittle((const char*)k, strlen((const char*)k), random_seed); 
 }
"
2186,179922,,Remote,Not required,,CVE-2015-0205,https://www.cvedetails.com/cve/CVE-2015-0205/,CWE-310,Low,,Partial,,2015-01-08,5.0,"The ssl3_get_cert_verify function in s3_srvr.c in OpenSSL 1.0.0 before 1.0.0p and 1.0.1 before 1.0.1k accepts client authentication with a Diffie-Hellman (DH) certificate without requiring a CertificateVerify message, which allows remote attackers to obtain access without knowledge of a private key via crafted TLS Handshake Protocol traffic to a server that recognizes a Certification Authority with DH support.",2017-11-14,,1,https://github.com/openssl/openssl/commit/1421e0c584ae9120ca1b88098f13d6d2e90b83a3,1421e0c584ae9120ca1b88098f13d6d2e90b83a3,"Unauthenticated DH client certificate fix.

Fix to prevent use of DH client certificates without sending
certificate verify message.

If we've used a client certificate to generate the premaster secret
ssl3_get_client_key_exchange returns 2 and ssl3_get_cert_verify is
never called.

We can only skip the certificate verify message in
ssl3_get_cert_verify if the client didn't send a certificate.

Thanks to Karthikeyan Bhargavan for reporting this issue.
CVE-2015-0205
Reviewed-by: Matt Caswell <matt@openssl.org>",1,ssl/s3_srvr.c,"{""sha"": ""8550c1b7833e7ce5b2e585f614623a44ebdf2d2f"", ""filename"": ""ssl/s3_srvr.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/openssl/openssl/blob/1421e0c584ae9120ca1b88098f13d6d2e90b83a3/ssl/s3_srvr.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/1421e0c584ae9120ca1b88098f13d6d2e90b83a3/ssl/s3_srvr.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/ssl/s3_srvr.c?ref=1421e0c584ae9120ca1b88098f13d6d2e90b83a3"", ""patch"": ""@@ -3056,7 +3056,7 @@ int ssl3_get_cert_verify(SSL *s)\n \tif (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_VERIFY)\n \t\t{\n \t\ts->s3->tmp.reuse_message=1;\n-\t\tif ((peer != NULL) && (type & EVP_PKT_SIGN))\n+\t\tif (peer != NULL)\n \t\t\t{\n \t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n \t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_MISSING_VERIFY_MESSAGE);""}","int ssl3_get_cert_verify(SSL *s)
	{
	EVP_PKEY *pkey=NULL;
	unsigned char *p;
	int al,ok,ret=0;
	long n;
	int type=0,i,j;
	X509 *peer;
	const EVP_MD *md = NULL;
	EVP_MD_CTX mctx;
	EVP_MD_CTX_init(&mctx);

	n=s->method->ssl_get_message(s,
		SSL3_ST_SR_CERT_VRFY_A,
		SSL3_ST_SR_CERT_VRFY_B,
		-1,
		SSL3_RT_MAX_PLAIN_LENGTH,
		&ok);

	if (!ok) return((int)n);

	if (s->session->peer != NULL)
		{
		peer=s->session->peer;
		pkey=X509_get_pubkey(peer);
		type=X509_certificate_type(peer,pkey);
		}
	else
		{
		peer=NULL;
		pkey=NULL;
		}

 	if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_VERIFY)
 		{
 		s->s3->tmp.reuse_message=1;
		if (peer != NULL)
 			{
 			al=SSL_AD_UNEXPECTED_MESSAGE;
 			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_MISSING_VERIFY_MESSAGE);
			goto f_err;
			}
		ret=1;
		goto end;
		}

	if (peer == NULL)
		{
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_NO_CLIENT_CERT_RECEIVED);
		al=SSL_AD_UNEXPECTED_MESSAGE;
		goto f_err;
		}

	if (!(type & EVP_PKT_SIGN))
		{
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE);
		al=SSL_AD_ILLEGAL_PARAMETER;
		goto f_err;
		}

	if (s->s3->change_cipher_spec)
		{
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_CCS_RECEIVED_EARLY);
		al=SSL_AD_UNEXPECTED_MESSAGE;
		goto f_err;
		}

	/* we now have a signature that we need to verify */
	p=(unsigned char *)s->init_msg;
	/* Check for broken implementations of GOST ciphersuites */
	/* If key is GOST and n is exactly 64, it is bare
	 * signature without length field */
	if (n==64 && (pkey->type==NID_id_GostR3410_94 ||
		pkey->type == NID_id_GostR3410_2001) )
		{
		i=64;
		} 
	else 
		{	
		if (SSL_USE_SIGALGS(s))
			{
			int rv = tls12_check_peer_sigalg(&md, s, p, pkey);
			if (rv == -1)
				{
				al = SSL_AD_INTERNAL_ERROR;
				goto f_err;
				}
			else if (rv == 0)
				{
				al = SSL_AD_DECODE_ERROR;
				goto f_err;
				}
#ifdef SSL_DEBUG
fprintf(stderr, ""USING TLSv1.2 HASH %s\n"", EVP_MD_name(md));
#endif
			p += 2;
			n -= 2;
			}
		n2s(p,i);
		n-=2;
		if (i > n)
			{
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_LENGTH_MISMATCH);
			al=SSL_AD_DECODE_ERROR;
			goto f_err;
			}
    	}
	j=EVP_PKEY_size(pkey);
	if ((i > j) || (n > j) || (n <= 0))
		{
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_SIZE);
		al=SSL_AD_DECODE_ERROR;
		goto f_err;
		}

	if (SSL_USE_SIGALGS(s))
		{
		long hdatalen = 0;
		void *hdata;
		hdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata);
		if (hdatalen <= 0)
			{
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_INTERNAL_ERROR);
			al=SSL_AD_INTERNAL_ERROR;
			goto f_err;
			}
#ifdef SSL_DEBUG
		fprintf(stderr, ""Using TLS 1.2 with client verify alg %s\n"",
							EVP_MD_name(md));
#endif
		if (!EVP_VerifyInit_ex(&mctx, md, NULL)
			|| !EVP_VerifyUpdate(&mctx, hdata, hdatalen))
			{
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_EVP_LIB);
			al=SSL_AD_INTERNAL_ERROR;
			goto f_err;
			}

		if (EVP_VerifyFinal(&mctx, p , i, pkey) <= 0)
			{
			al=SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_SIGNATURE);
			goto f_err;
			}
		}
	else
#ifndef OPENSSL_NO_RSA 
	if (pkey->type == EVP_PKEY_RSA)
		{
		i=RSA_verify(NID_md5_sha1, s->s3->tmp.cert_verify_md,
			MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH, p, i, 
							pkey->pkey.rsa);
		if (i < 0)
			{
			al=SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_DECRYPT);
			goto f_err;
			}
		if (i == 0)
			{
			al=SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_SIGNATURE);
			goto f_err;
			}
		}
	else
#endif
#ifndef OPENSSL_NO_DSA
		if (pkey->type == EVP_PKEY_DSA)
		{
		j=DSA_verify(pkey->save_type,
			&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),
			SHA_DIGEST_LENGTH,p,i,pkey->pkey.dsa);
		if (j <= 0)
			{
			/* bad signature */
			al=SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_DSA_SIGNATURE);
			goto f_err;
			}
		}
	else
#endif
#ifndef OPENSSL_NO_ECDSA
		if (pkey->type == EVP_PKEY_EC)
		{
		j=ECDSA_verify(pkey->save_type,
			&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),
			SHA_DIGEST_LENGTH,p,i,pkey->pkey.ec);
		if (j <= 0)
			{
			/* bad signature */
			al=SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
			    SSL_R_BAD_ECDSA_SIGNATURE);
			goto f_err;
			}
		}
	else
#endif
	if (pkey->type == NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001)
		{   unsigned char signature[64];
			int idx;
			EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new(pkey,NULL);
			EVP_PKEY_verify_init(pctx);
			if (i!=64) {
				fprintf(stderr,""GOST signature length is %d"",i);
			}	
			for (idx=0;idx<64;idx++) {
				signature[63-idx]=p[idx];
			}	
			j=EVP_PKEY_verify(pctx,signature,64,s->s3->tmp.cert_verify_md,32);
			EVP_PKEY_CTX_free(pctx);
			if (j<=0) 
				{
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
					SSL_R_BAD_ECDSA_SIGNATURE);
				goto f_err;
				}	
		}
	else	
		{
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR);
		al=SSL_AD_UNSUPPORTED_CERTIFICATE;
		goto f_err;
		}


	ret=1;
	if (0)
		{
f_err:
		ssl3_send_alert(s,SSL3_AL_FATAL,al);
		}
end:
	if (s->s3->handshake_buffer)
		{
		BIO_free(s->s3->handshake_buffer);
		s->s3->handshake_buffer = NULL;
		s->s3->flags &= ~TLS1_FLAGS_KEEP_HANDSHAKE;
		}
	EVP_MD_CTX_cleanup(&mctx);
	EVP_PKEY_free(pkey);
	return(ret);
	}
","int ssl3_get_cert_verify(SSL *s)
	{
	EVP_PKEY *pkey=NULL;
	unsigned char *p;
	int al,ok,ret=0;
	long n;
	int type=0,i,j;
	X509 *peer;
	const EVP_MD *md = NULL;
	EVP_MD_CTX mctx;
	EVP_MD_CTX_init(&mctx);

	n=s->method->ssl_get_message(s,
		SSL3_ST_SR_CERT_VRFY_A,
		SSL3_ST_SR_CERT_VRFY_B,
		-1,
		SSL3_RT_MAX_PLAIN_LENGTH,
		&ok);

	if (!ok) return((int)n);

	if (s->session->peer != NULL)
		{
		peer=s->session->peer;
		pkey=X509_get_pubkey(peer);
		type=X509_certificate_type(peer,pkey);
		}
	else
		{
		peer=NULL;
		pkey=NULL;
		}

 	if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_VERIFY)
 		{
 		s->s3->tmp.reuse_message=1;
		if ((peer != NULL) && (type & EVP_PKT_SIGN))
 			{
 			al=SSL_AD_UNEXPECTED_MESSAGE;
 			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_MISSING_VERIFY_MESSAGE);
			goto f_err;
			}
		ret=1;
		goto end;
		}

	if (peer == NULL)
		{
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_NO_CLIENT_CERT_RECEIVED);
		al=SSL_AD_UNEXPECTED_MESSAGE;
		goto f_err;
		}

	if (!(type & EVP_PKT_SIGN))
		{
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE);
		al=SSL_AD_ILLEGAL_PARAMETER;
		goto f_err;
		}

	if (s->s3->change_cipher_spec)
		{
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_CCS_RECEIVED_EARLY);
		al=SSL_AD_UNEXPECTED_MESSAGE;
		goto f_err;
		}

	/* we now have a signature that we need to verify */
	p=(unsigned char *)s->init_msg;
	/* Check for broken implementations of GOST ciphersuites */
	/* If key is GOST and n is exactly 64, it is bare
	 * signature without length field */
	if (n==64 && (pkey->type==NID_id_GostR3410_94 ||
		pkey->type == NID_id_GostR3410_2001) )
		{
		i=64;
		} 
	else 
		{	
		if (SSL_USE_SIGALGS(s))
			{
			int rv = tls12_check_peer_sigalg(&md, s, p, pkey);
			if (rv == -1)
				{
				al = SSL_AD_INTERNAL_ERROR;
				goto f_err;
				}
			else if (rv == 0)
				{
				al = SSL_AD_DECODE_ERROR;
				goto f_err;
				}
#ifdef SSL_DEBUG
fprintf(stderr, ""USING TLSv1.2 HASH %s\n"", EVP_MD_name(md));
#endif
			p += 2;
			n -= 2;
			}
		n2s(p,i);
		n-=2;
		if (i > n)
			{
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_LENGTH_MISMATCH);
			al=SSL_AD_DECODE_ERROR;
			goto f_err;
			}
    	}
	j=EVP_PKEY_size(pkey);
	if ((i > j) || (n > j) || (n <= 0))
		{
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_SIZE);
		al=SSL_AD_DECODE_ERROR;
		goto f_err;
		}

	if (SSL_USE_SIGALGS(s))
		{
		long hdatalen = 0;
		void *hdata;
		hdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata);
		if (hdatalen <= 0)
			{
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_INTERNAL_ERROR);
			al=SSL_AD_INTERNAL_ERROR;
			goto f_err;
			}
#ifdef SSL_DEBUG
		fprintf(stderr, ""Using TLS 1.2 with client verify alg %s\n"",
							EVP_MD_name(md));
#endif
		if (!EVP_VerifyInit_ex(&mctx, md, NULL)
			|| !EVP_VerifyUpdate(&mctx, hdata, hdatalen))
			{
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_EVP_LIB);
			al=SSL_AD_INTERNAL_ERROR;
			goto f_err;
			}

		if (EVP_VerifyFinal(&mctx, p , i, pkey) <= 0)
			{
			al=SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_SIGNATURE);
			goto f_err;
			}
		}
	else
#ifndef OPENSSL_NO_RSA 
	if (pkey->type == EVP_PKEY_RSA)
		{
		i=RSA_verify(NID_md5_sha1, s->s3->tmp.cert_verify_md,
			MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH, p, i, 
							pkey->pkey.rsa);
		if (i < 0)
			{
			al=SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_DECRYPT);
			goto f_err;
			}
		if (i == 0)
			{
			al=SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_SIGNATURE);
			goto f_err;
			}
		}
	else
#endif
#ifndef OPENSSL_NO_DSA
		if (pkey->type == EVP_PKEY_DSA)
		{
		j=DSA_verify(pkey->save_type,
			&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),
			SHA_DIGEST_LENGTH,p,i,pkey->pkey.dsa);
		if (j <= 0)
			{
			/* bad signature */
			al=SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_DSA_SIGNATURE);
			goto f_err;
			}
		}
	else
#endif
#ifndef OPENSSL_NO_ECDSA
		if (pkey->type == EVP_PKEY_EC)
		{
		j=ECDSA_verify(pkey->save_type,
			&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),
			SHA_DIGEST_LENGTH,p,i,pkey->pkey.ec);
		if (j <= 0)
			{
			/* bad signature */
			al=SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
			    SSL_R_BAD_ECDSA_SIGNATURE);
			goto f_err;
			}
		}
	else
#endif
	if (pkey->type == NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001)
		{   unsigned char signature[64];
			int idx;
			EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new(pkey,NULL);
			EVP_PKEY_verify_init(pctx);
			if (i!=64) {
				fprintf(stderr,""GOST signature length is %d"",i);
			}	
			for (idx=0;idx<64;idx++) {
				signature[63-idx]=p[idx];
			}	
			j=EVP_PKEY_verify(pctx,signature,64,s->s3->tmp.cert_verify_md,32);
			EVP_PKEY_CTX_free(pctx);
			if (j<=0) 
				{
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
					SSL_R_BAD_ECDSA_SIGNATURE);
				goto f_err;
				}	
		}
	else	
		{
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR);
		al=SSL_AD_UNSUPPORTED_CERTIFICATE;
		goto f_err;
		}


	ret=1;
	if (0)
		{
f_err:
		ssl3_send_alert(s,SSL3_AL_FATAL,al);
		}
end:
	if (s->s3->handshake_buffer)
		{
		BIO_free(s->s3->handshake_buffer);
		s->s3->handshake_buffer = NULL;
		s->s3->flags &= ~TLS1_FLAGS_KEEP_HANDSHAKE;
		}
	EVP_MD_CTX_cleanup(&mctx);
	EVP_PKEY_free(pkey);
	return(ret);
	}
",C,"		if (peer != NULL)
","		if ((peer != NULL) && (type & EVP_PKT_SIGN))
",,"@@ -3056,7 +3056,7 @@ int ssl3_get_cert_verify(SSL *s)
 	if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_VERIFY)
 		{
 		s->s3->tmp.reuse_message=1;
-		if ((peer != NULL) && (type & EVP_PKT_SIGN))
+		if (peer != NULL)
 			{
 			al=SSL_AD_UNEXPECTED_MESSAGE;
 			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_MISSING_VERIFY_MESSAGE);",openssl,1421e0c584ae9120ca1b88098f13d6d2e90b83a3,a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,1,"int ssl3_get_cert_verify(SSL *s)
	{
	EVP_PKEY *pkey=NULL;
	unsigned char *p;
	int al,ok,ret=0;
	long n;
	int type=0,i,j;
	X509 *peer;
	const EVP_MD *md = NULL;
	EVP_MD_CTX mctx;
	EVP_MD_CTX_init(&mctx);

	n=s->method->ssl_get_message(s,
		SSL3_ST_SR_CERT_VRFY_A,
		SSL3_ST_SR_CERT_VRFY_B,
		-1,
		SSL3_RT_MAX_PLAIN_LENGTH,
		&ok);

	if (!ok) return((int)n);

	if (s->session->peer != NULL)
		{
		peer=s->session->peer;
		pkey=X509_get_pubkey(peer);
		type=X509_certificate_type(peer,pkey);
		}
	else
		{
		peer=NULL;
		pkey=NULL;
		}

 	if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_VERIFY)
 		{
 		s->s3->tmp.reuse_message=1;
//flaw_line_below:
		if ((peer != NULL) && (type & EVP_PKT_SIGN))
//fix_flaw_line_below:
//		if (peer != NULL)
 			{
 			al=SSL_AD_UNEXPECTED_MESSAGE;
 			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_MISSING_VERIFY_MESSAGE);
			goto f_err;
			}
		ret=1;
		goto end;
		}

	if (peer == NULL)
		{
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_NO_CLIENT_CERT_RECEIVED);
		al=SSL_AD_UNEXPECTED_MESSAGE;
		goto f_err;
		}

	if (!(type & EVP_PKT_SIGN))
		{
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE);
		al=SSL_AD_ILLEGAL_PARAMETER;
		goto f_err;
		}

	if (s->s3->change_cipher_spec)
		{
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_CCS_RECEIVED_EARLY);
		al=SSL_AD_UNEXPECTED_MESSAGE;
		goto f_err;
		}

	/* we now have a signature that we need to verify */
	p=(unsigned char *)s->init_msg;
	/* Check for broken implementations of GOST ciphersuites */
	/* If key is GOST and n is exactly 64, it is bare
	 * signature without length field */
	if (n==64 && (pkey->type==NID_id_GostR3410_94 ||
		pkey->type == NID_id_GostR3410_2001) )
		{
		i=64;
		} 
	else 
		{	
		if (SSL_USE_SIGALGS(s))
			{
			int rv = tls12_check_peer_sigalg(&md, s, p, pkey);
			if (rv == -1)
				{
				al = SSL_AD_INTERNAL_ERROR;
				goto f_err;
				}
			else if (rv == 0)
				{
				al = SSL_AD_DECODE_ERROR;
				goto f_err;
				}
#ifdef SSL_DEBUG
fprintf(stderr, ""USING TLSv1.2 HASH %s\n"", EVP_MD_name(md));
#endif
			p += 2;
			n -= 2;
			}
		n2s(p,i);
		n-=2;
		if (i > n)
			{
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_LENGTH_MISMATCH);
			al=SSL_AD_DECODE_ERROR;
			goto f_err;
			}
    	}
	j=EVP_PKEY_size(pkey);
	if ((i > j) || (n > j) || (n <= 0))
		{
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_SIZE);
		al=SSL_AD_DECODE_ERROR;
		goto f_err;
		}

	if (SSL_USE_SIGALGS(s))
		{
		long hdatalen = 0;
		void *hdata;
		hdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata);
		if (hdatalen <= 0)
			{
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_INTERNAL_ERROR);
			al=SSL_AD_INTERNAL_ERROR;
			goto f_err;
			}
#ifdef SSL_DEBUG
		fprintf(stderr, ""Using TLS 1.2 with client verify alg %s\n"",
							EVP_MD_name(md));
#endif
		if (!EVP_VerifyInit_ex(&mctx, md, NULL)
			|| !EVP_VerifyUpdate(&mctx, hdata, hdatalen))
			{
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_EVP_LIB);
			al=SSL_AD_INTERNAL_ERROR;
			goto f_err;
			}

		if (EVP_VerifyFinal(&mctx, p , i, pkey) <= 0)
			{
			al=SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_SIGNATURE);
			goto f_err;
			}
		}
	else
#ifndef OPENSSL_NO_RSA 
	if (pkey->type == EVP_PKEY_RSA)
		{
		i=RSA_verify(NID_md5_sha1, s->s3->tmp.cert_verify_md,
			MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH, p, i, 
							pkey->pkey.rsa);
		if (i < 0)
			{
			al=SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_DECRYPT);
			goto f_err;
			}
		if (i == 0)
			{
			al=SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_SIGNATURE);
			goto f_err;
			}
		}
	else
#endif
#ifndef OPENSSL_NO_DSA
		if (pkey->type == EVP_PKEY_DSA)
		{
		j=DSA_verify(pkey->save_type,
			&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),
			SHA_DIGEST_LENGTH,p,i,pkey->pkey.dsa);
		if (j <= 0)
			{
			/* bad signature */
			al=SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_DSA_SIGNATURE);
			goto f_err;
			}
		}
	else
#endif
#ifndef OPENSSL_NO_ECDSA
		if (pkey->type == EVP_PKEY_EC)
		{
		j=ECDSA_verify(pkey->save_type,
			&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),
			SHA_DIGEST_LENGTH,p,i,pkey->pkey.ec);
		if (j <= 0)
			{
			/* bad signature */
			al=SSL_AD_DECRYPT_ERROR;
			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
			    SSL_R_BAD_ECDSA_SIGNATURE);
			goto f_err;
			}
		}
	else
#endif
	if (pkey->type == NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001)
		{   unsigned char signature[64];
			int idx;
			EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new(pkey,NULL);
			EVP_PKEY_verify_init(pctx);
			if (i!=64) {
				fprintf(stderr,""GOST signature length is %d"",i);
			}	
			for (idx=0;idx<64;idx++) {
				signature[63-idx]=p[idx];
			}	
			j=EVP_PKEY_verify(pctx,signature,64,s->s3->tmp.cert_verify_md,32);
			EVP_PKEY_CTX_free(pctx);
			if (j<=0) 
				{
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
					SSL_R_BAD_ECDSA_SIGNATURE);
				goto f_err;
				}	
		}
	else	
		{
		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR);
		al=SSL_AD_UNSUPPORTED_CERTIFICATE;
		goto f_err;
		}


	ret=1;
	if (0)
		{
f_err:
		ssl3_send_alert(s,SSL3_AL_FATAL,al);
		}
end:
	if (s->s3->handshake_buffer)
		{
		BIO_free(s->s3->handshake_buffer);
		s->s3->handshake_buffer = NULL;
		s->s3->flags &= ~TLS1_FLAGS_KEEP_HANDSHAKE;
		}
	EVP_MD_CTX_cleanup(&mctx);
	EVP_PKEY_free(pkey);
	return(ret);
	}
"
2187,179923,,Remote,Not required,,CVE-2015-0204,https://www.cvedetails.com/cve/CVE-2015-0204/,CWE-310,Medium,,Partial,,2015-01-08,4.3,"The ssl3_get_key_exchange function in s3_clnt.c in OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k allows remote SSL servers to conduct RSA-to-EXPORT_RSA downgrade attacks and facilitate brute-force decryption by offering a weak ephemeral RSA key in a noncompliant role, related to the *FREAK* issue.  NOTE: the scope of this CVE is only client code based on OpenSSL, not EXPORT_RSA issues associated with servers or other TLS implementations.",2018-07-18,,6,https://github.com/openssl/openssl/commit/ce325c60c74b0fa784f5872404b722e120e5cab0,ce325c60c74b0fa784f5872404b722e120e5cab0,"Only allow ephemeral RSA keys in export ciphersuites.

OpenSSL clients would tolerate temporary RSA keys in non-export
ciphersuites. It also had an option SSL_OP_EPHEMERAL_RSA which
enabled this server side. Remove both options as they are a
protocol violation.

Thanks to Karthikeyan Bhargavan for reporting this issue.
(CVE-2015-0204)
Reviewed-by: Matt Caswell <matt@openssl.org>",15,ssl/d1_srvr.c,"{""sha"": ""c9c19c3ae3866f62c66803160e8870ebe6c720ef"", ""filename"": ""CHANGES"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/openssl/openssl/blob/ce325c60c74b0fa784f5872404b722e120e5cab0/CHANGES"", ""raw_url"": ""https://github.com/openssl/openssl/raw/ce325c60c74b0fa784f5872404b722e120e5cab0/CHANGES"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/CHANGES?ref=ce325c60c74b0fa784f5872404b722e120e5cab0"", ""patch"": ""@@ -666,6 +666,14 @@\n      (CVE-2014-3572)\n      [Steve Henson]\n \n+  *) Remove non-export ephemeral RSA code on client and server. This code\n+     violated the TLS standard by allowing the use of temporary RSA keys in\n+     non-export ciphersuites and could be used by a server to effectively\n+     downgrade the RSA key length used to a value smaller than the server\n+     certificate. Thanks for Karthikeyan Bhargavan for reporting this issue.\n+     (CVE-2015-0204)\n+     [Steve Henson]\n+\n   *) Ensure that the session ID context of an SSL is updated when its\n      SSL_CTX is updated via SSL_set_SSL_CTX.\n ""}<_**next**_>{""sha"": ""593435c493eaf609a04d4c180ac3fce1600be3a1"", ""filename"": ""doc/ssl/SSL_CTX_set_options.pod"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 9, ""changes"": 10, ""blob_url"": ""https://github.com/openssl/openssl/blob/ce325c60c74b0fa784f5872404b722e120e5cab0/doc/ssl/SSL_CTX_set_options.pod"", ""raw_url"": ""https://github.com/openssl/openssl/raw/ce325c60c74b0fa784f5872404b722e120e5cab0/doc/ssl/SSL_CTX_set_options.pod"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/doc/ssl/SSL_CTX_set_options.pod?ref=ce325c60c74b0fa784f5872404b722e120e5cab0"", ""patch"": ""@@ -151,15 +151,7 @@ temporary/ephemeral DH parameters are used.\n \n =item SSL_OP_EPHEMERAL_RSA\n \n-Always use ephemeral (temporary) RSA key when doing RSA operations\n-(see L<SSL_CTX_set_tmp_rsa_callback(3)|SSL_CTX_set_tmp_rsa_callback(3)>).\n-According to the specifications this is only done, when a RSA key\n-can only be used for signature operations (namely under export ciphers\n-with restricted RSA keylength). By setting this option, ephemeral\n-RSA keys are always used. This option breaks compatibility with the\n-SSL/TLS specifications and may lead to interoperability problems with\n-clients and should therefore never be used. Ciphers with DHE (ephemeral\n-Diffie-Hellman) key exchange should be used instead.\n+This option is no longer implemented and is treated as no op.\n \n =item SSL_OP_CIPHER_SERVER_PREFERENCE\n ""}<_**next**_>{""sha"": ""94c55b8045359f3122c324ca031e8350ef68b12c"", ""filename"": ""doc/ssl/SSL_CTX_set_tmp_rsa_callback.pod"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 15, ""changes"": 23, ""blob_url"": ""https://github.com/openssl/openssl/blob/ce325c60c74b0fa784f5872404b722e120e5cab0/doc/ssl/SSL_CTX_set_tmp_rsa_callback.pod"", ""raw_url"": ""https://github.com/openssl/openssl/raw/ce325c60c74b0fa784f5872404b722e120e5cab0/doc/ssl/SSL_CTX_set_tmp_rsa_callback.pod"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/doc/ssl/SSL_CTX_set_tmp_rsa_callback.pod?ref=ce325c60c74b0fa784f5872404b722e120e5cab0"", ""patch"": ""@@ -74,21 +74,14 @@ exchange and use DHE (Ephemeral Diffie-Hellman) key exchange instead\n in order to achieve forward secrecy (see\n L<SSL_CTX_set_tmp_dh_callback(3)|SSL_CTX_set_tmp_dh_callback(3)>).\n \n-On OpenSSL servers ephemeral RSA key exchange is therefore disabled by default\n-and must be explicitly enabled  using the SSL_OP_EPHEMERAL_RSA option of\n-L<SSL_CTX_set_options(3)|SSL_CTX_set_options(3)>, violating the TLS/SSL\n-standard. When ephemeral RSA key exchange is required for export ciphers,\n-it will automatically be used without this option!\n-\n-An application may either directly specify the key or can supply the key via\n-a callback function. The callback approach has the advantage, that the\n-callback may generate the key only in case it is actually needed. As the\n-generation of a RSA key is however costly, it will lead to a significant\n-delay in the handshake procedure.  Another advantage of the callback function\n-is that it can supply keys of different size (e.g. for SSL_OP_EPHEMERAL_RSA\n-usage) while the explicit setting of the key is only useful for key size of\n-512 bits to satisfy the export restricted ciphers and does give away key length\n-if a longer key would be allowed.\n+An application may either directly specify the key or can supply the key via a\n+callback function. The callback approach has the advantage, that the callback\n+may generate the key only in case it is actually needed. As the generation of a\n+RSA key is however costly, it will lead to a significant delay in the handshake\n+procedure.  Another advantage of the callback function is that it can supply\n+keys of different size while the explicit setting of the key is only useful for\n+key size of 512 bits to satisfy the export restricted ciphers and does give\n+away key length if a longer key would be allowed.\n \n The B<tmp_rsa_callback> is called with the B<keylength> needed and\n the B<is_export> information. The B<is_export> flag is set, when the""}<_**next**_>{""sha"": ""8a5c5a1cd2204884685cf81c6c1ad57a4a65f761"", ""filename"": ""ssl/d1_srvr.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 15, ""changes"": 21, ""blob_url"": ""https://github.com/openssl/openssl/blob/ce325c60c74b0fa784f5872404b722e120e5cab0/ssl/d1_srvr.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/ce325c60c74b0fa784f5872404b722e120e5cab0/ssl/d1_srvr.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/ssl/d1_srvr.c?ref=ce325c60c74b0fa784f5872404b722e120e5cab0"", ""patch"": ""@@ -472,24 +472,15 @@ int dtls1_accept(SSL *s)\n \t\tcase SSL3_ST_SW_KEY_EXCH_B:\n \t\t\talg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n \n-\t\t\t/* clear this, it may get reset by\n-\t\t\t * send_server_key_exchange */\n-\t\t\tif ((s->options & SSL_OP_EPHEMERAL_RSA)\n-#ifndef OPENSSL_NO_KRB5\n-\t\t\t\t&& !(alg_k & SSL_kKRB5)\n-#endif /* OPENSSL_NO_KRB5 */\n-\t\t\t\t)\n-\t\t\t\t/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key\n-\t\t\t\t * even when forbidden by protocol specs\n-\t\t\t\t * (handshake may fail as clients are not required to\n-\t\t\t\t * be able to handle this) */\n-\t\t\t\ts->s3->tmp.use_rsa_tmp=1;\n-\t\t\telse\n-\t\t\t\ts->s3->tmp.use_rsa_tmp=0;\n+\t\t\t/*\n+\t\t\t * clear this, it may get reset by\n+\t\t\t * send_server_key_exchange\n+\t\t\t */\n+\t\t\ts->s3->tmp.use_rsa_tmp=0;\n \n \t\t\t/* only send if a DH key exchange or\n \t\t\t * RSA but we have a sign only certificate */\n-\t\t\tif (s->s3->tmp.use_rsa_tmp\n+\t\t\tif (\n \t\t\t/* PSK: send ServerKeyExchange if PSK identity\n \t\t\t * hint if provided */\n #ifndef OPENSSL_NO_PSK""}<_**next**_>{""sha"": ""aa9dcbb5b3aa1e05794adaaa1ad1a95f76a250ff"", ""filename"": ""ssl/s3_clnt.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/openssl/openssl/blob/ce325c60c74b0fa784f5872404b722e120e5cab0/ssl/s3_clnt.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/ce325c60c74b0fa784f5872404b722e120e5cab0/ssl/s3_clnt.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/ssl/s3_clnt.c?ref=ce325c60c74b0fa784f5872404b722e120e5cab0"", ""patch"": ""@@ -1636,6 +1636,13 @@ int ssl3_get_key_exchange(SSL *s)\n #ifndef OPENSSL_NO_RSA\n \tif (alg_k & SSL_kRSA)\n \t\t{\n+\t\t/* Temporary RSA keys only allowed in export ciphersuites */\n+\t\tif (!SSL_C_IS_EXPORT(s->s3->tmp.new_cipher))\n+\t\t\t{\n+\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n+\t\t\tSSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_UNEXPECTED_MESSAGE);\n+\t\t\tgoto f_err;\n+\t\t\t}\n \t\tif ((rsa=RSA_new()) == NULL)\n \t\t\t{\n \t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);""}<_**next**_>{""sha"": ""e5a32ee90f382dfeb75813ad3fd61def9f801a37"", ""filename"": ""ssl/s3_srvr.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 15, ""changes"": 21, ""blob_url"": ""https://github.com/openssl/openssl/blob/ce325c60c74b0fa784f5872404b722e120e5cab0/ssl/s3_srvr.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/ce325c60c74b0fa784f5872404b722e120e5cab0/ssl/s3_srvr.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/ssl/s3_srvr.c?ref=ce325c60c74b0fa784f5872404b722e120e5cab0"", ""patch"": ""@@ -453,20 +453,11 @@ int ssl3_accept(SSL *s)\n \t\tcase SSL3_ST_SW_KEY_EXCH_B:\n \t\t\talg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n \n-\t\t\t/* clear this, it may get reset by\n-\t\t\t * send_server_key_exchange */\n-\t\t\tif ((s->options & SSL_OP_EPHEMERAL_RSA)\n-#ifndef OPENSSL_NO_KRB5\n-\t\t\t\t&& !(alg_k & SSL_kKRB5)\n-#endif /* OPENSSL_NO_KRB5 */\n-\t\t\t\t)\n-\t\t\t\t/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key\n-\t\t\t\t * even when forbidden by protocol specs\n-\t\t\t\t * (handshake may fail as clients are not required to\n-\t\t\t\t * be able to handle this) */\n-\t\t\t\ts->s3->tmp.use_rsa_tmp=1;\n-\t\t\telse\n-\t\t\t\ts->s3->tmp.use_rsa_tmp=0;\n+\t\t\t/*\n+\t\t\t * clear this, it may get reset by\n+\t\t\t * send_server_key_exchange\n+\t\t\t */\n+\t\t\ts->s3->tmp.use_rsa_tmp=0;\n \n \n \t\t\t/* only send if a DH key exchange, fortezza or\n@@ -480,7 +471,7 @@ int ssl3_accept(SSL *s)\n \t\t\t * server certificate contains the server's\n \t\t\t * public key for key exchange.\n \t\t\t */\n-\t\t\tif (s->s3->tmp.use_rsa_tmp\n+\t\t\tif (\n \t\t\t/* PSK: send ServerKeyExchange if PSK identity\n \t\t\t * hint if provided */\n #ifndef OPENSSL_NO_PSK""}<_**next**_>{""sha"": ""98661d0ab89d2d334c656fcabcf847f8b84d2fb9"", ""filename"": ""ssl/ssl.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 3, ""changes"": 5, ""blob_url"": ""https://github.com/openssl/openssl/blob/ce325c60c74b0fa784f5872404b722e120e5cab0/ssl/ssl.h"", ""raw_url"": ""https://github.com/openssl/openssl/raw/ce325c60c74b0fa784f5872404b722e120e5cab0/ssl/ssl.h"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/ssl/ssl.h?ref=ce325c60c74b0fa784f5872404b722e120e5cab0"", ""patch"": ""@@ -606,9 +606,8 @@ struct ssl_session_st\n #define SSL_OP_SINGLE_ECDH_USE\t\t\t\t0x00080000L\n /* If set, always create a new key when using tmp_dh parameters */\n #define SSL_OP_SINGLE_DH_USE\t\t\t\t0x00100000L\n-/* Set to always use the tmp_rsa key when doing RSA operations,\n- * even when this violates protocol specs */\n-#define SSL_OP_EPHEMERAL_RSA\t\t\t\t0x00200000L\n+/* Does nothing: retained for compatibiity */\n+#define SSL_OP_EPHEMERAL_RSA\t\t\t\t0x0\n /* Set on servers to choose the cipher according to the server's\n  * preferences */\n #define SSL_OP_CIPHER_SERVER_PREFERENCE\t\t\t0x00400000L""}","IMPLEMENT_dtls1_meth_func(DTLS1_VERSION,
			DTLSv1_server_method,
			dtls1_accept,
			ssl_undefined_function,
			dtls1_get_server_method,
			DTLSv1_enc_data)

IMPLEMENT_dtls1_meth_func(DTLS1_2_VERSION,
			DTLSv1_2_server_method,
			dtls1_accept,
			ssl_undefined_function,
			dtls1_get_server_method,
			DTLSv1_2_enc_data)

IMPLEMENT_dtls1_meth_func(DTLS_ANY_VERSION,
			DTLS_server_method,
			dtls1_accept,
			ssl_undefined_function,
			dtls1_get_server_method,
			DTLSv1_2_enc_data)

int dtls1_accept(SSL *s)
	{
	BUF_MEM *buf;
	unsigned long Time=(unsigned long)time(NULL);
	void (*cb)(const SSL *ssl,int type,int val)=NULL;
	unsigned long alg_k;
	int ret= -1;
	int new_state,state,skip=0;
	int listen;
#ifndef OPENSSL_NO_SCTP
	unsigned char sctpauthkey[64];
	char labelbuffer[sizeof(DTLS1_SCTP_AUTH_LABEL)];
#endif

	RAND_add(&Time,sizeof(Time),0);
	ERR_clear_error();
	clear_sys_error();

	if (s->info_callback != NULL)
		cb=s->info_callback;
	else if (s->ctx->info_callback != NULL)
		cb=s->ctx->info_callback;
	
	listen = s->d1->listen;

	/* init things to blank */
	s->in_handshake++;
	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);

	s->d1->listen = listen;
#ifndef OPENSSL_NO_SCTP
	/* Notify SCTP BIO socket to enter handshake
	 * mode and prevent stream identifier other
	 * than 0. Will be ignored if no SCTP is used.
	 */
	BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE, s->in_handshake, NULL);
#endif

	if (s->cert == NULL)
		{
		SSLerr(SSL_F_DTLS1_ACCEPT,SSL_R_NO_CERTIFICATE_SET);
		return(-1);
		}

#ifndef OPENSSL_NO_HEARTBEATS
	/* If we're awaiting a HeartbeatResponse, pretend we
	 * already got and don't await it anymore, because
	 * Heartbeats don't make sense during handshakes anyway.
	 */
	if (s->tlsext_hb_pending)
		{
		dtls1_stop_timer(s);
		s->tlsext_hb_pending = 0;
		s->tlsext_hb_seq++;
		}
#endif

	for (;;)
		{
		state=s->state;

		switch (s->state)
			{
		case SSL_ST_RENEGOTIATE:
			s->renegotiate=1;
			/* s->state=SSL_ST_ACCEPT; */

		case SSL_ST_BEFORE:
		case SSL_ST_ACCEPT:
		case SSL_ST_BEFORE|SSL_ST_ACCEPT:
		case SSL_ST_OK|SSL_ST_ACCEPT:

			s->server=1;
			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);

			if ((s->version & 0xff00) != (DTLS1_VERSION & 0xff00))
				{
				SSLerr(SSL_F_DTLS1_ACCEPT, ERR_R_INTERNAL_ERROR);
				return -1;
				}
			s->type=SSL_ST_ACCEPT;

			if (s->init_buf == NULL)
				{
				if ((buf=BUF_MEM_new()) == NULL)
					{
					ret= -1;
					goto end;
					}
				if (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))
					{
					BUF_MEM_free(buf);
					ret= -1;
					goto end;
					}
				s->init_buf=buf;
				}

			if (!ssl3_setup_buffers(s))
				{
				ret= -1;
				goto end;
				}

			s->init_num=0;
			s->d1->change_cipher_spec_ok = 0;
			/* Should have been reset by ssl3_get_finished, too. */
			s->s3->change_cipher_spec = 0;

			if (s->state != SSL_ST_RENEGOTIATE)
				{
				/* Ok, we now need to push on a buffering BIO so that
				 * the output is sent in a way that TCP likes :-)
				 * ...but not with SCTP :-)
				 */
#ifndef OPENSSL_NO_SCTP
				if (!BIO_dgram_is_sctp(SSL_get_wbio(s)))
#endif
					if (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }

				ssl3_init_finished_mac(s);
				s->state=SSL3_ST_SR_CLNT_HELLO_A;
				s->ctx->stats.sess_accept++;
				}
			else
				{
				/* s->state == SSL_ST_RENEGOTIATE,
				 * we will just send a HelloRequest */
				s->ctx->stats.sess_accept_renegotiate++;
				s->state=SSL3_ST_SW_HELLO_REQ_A;
				}

			break;

		case SSL3_ST_SW_HELLO_REQ_A:
		case SSL3_ST_SW_HELLO_REQ_B:

			s->shutdown=0;
			dtls1_clear_record_buffer(s);
			dtls1_start_timer(s);
			ret=ssl3_send_hello_request(s);
			if (ret <= 0) goto end;
			s->s3->tmp.next_state=SSL3_ST_SR_CLNT_HELLO_A;
			s->state=SSL3_ST_SW_FLUSH;
			s->init_num=0;

			ssl3_init_finished_mac(s);
			break;

		case SSL3_ST_SW_HELLO_REQ_C:
			s->state=SSL_ST_OK;
			break;

		case SSL3_ST_SR_CLNT_HELLO_A:
		case SSL3_ST_SR_CLNT_HELLO_B:
		case SSL3_ST_SR_CLNT_HELLO_C:

			s->shutdown=0;
			ret=ssl3_get_client_hello(s);
			if (ret <= 0) goto end;
			dtls1_stop_timer(s);

			if (ret == 1 && (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE))
				s->state = DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A;
			else
				s->state = SSL3_ST_SW_SRVR_HELLO_A;

			s->init_num=0;

			/* Reflect ClientHello sequence to remain stateless while listening */
			if (listen)
				{
				memcpy(s->s3->write_sequence, s->s3->read_sequence, sizeof(s->s3->write_sequence));
				}

			/* If we're just listening, stop here */
			if (listen && s->state == SSL3_ST_SW_SRVR_HELLO_A)
				{
				ret = 2;
				s->d1->listen = 0;
				/* Set expected sequence numbers
				 * to continue the handshake.
				 */
				s->d1->handshake_read_seq = 2;
				s->d1->handshake_write_seq = 1;
				s->d1->next_handshake_write_seq = 1;
				goto end;
				}
			
			break;
			
		case DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A:
		case DTLS1_ST_SW_HELLO_VERIFY_REQUEST_B:

			ret = dtls1_send_hello_verify_request(s);
			if ( ret <= 0) goto end;
			s->state=SSL3_ST_SW_FLUSH;
			s->s3->tmp.next_state=SSL3_ST_SR_CLNT_HELLO_A;

			/* HelloVerifyRequest resets Finished MAC */
			if (s->version != DTLS1_BAD_VER)
				ssl3_init_finished_mac(s);
			break;
			
#ifndef OPENSSL_NO_SCTP
		case DTLS1_SCTP_ST_SR_READ_SOCK:
			
			if (BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s)))		
				{
				s->s3->in_read_app_data=2;
				s->rwstate=SSL_READING;
				BIO_clear_retry_flags(SSL_get_rbio(s));
				BIO_set_retry_read(SSL_get_rbio(s));
				ret = -1;
				goto end;
				}
			
			s->state=SSL3_ST_SR_FINISHED_A;
			break;
			
		case DTLS1_SCTP_ST_SW_WRITE_SOCK:
			ret = BIO_dgram_sctp_wait_for_dry(SSL_get_wbio(s));
			if (ret < 0) goto end;
			
			if (ret == 0)
				{
				if (s->d1->next_state != SSL_ST_OK)
					{
					s->s3->in_read_app_data=2;
					s->rwstate=SSL_READING;
					BIO_clear_retry_flags(SSL_get_rbio(s));
					BIO_set_retry_read(SSL_get_rbio(s));
					ret = -1;
					goto end;
					}
				}

			s->state=s->d1->next_state;
			break;
#endif

		case SSL3_ST_SW_SRVR_HELLO_A:
		case SSL3_ST_SW_SRVR_HELLO_B:
			s->renegotiate = 2;
			dtls1_start_timer(s);
			ret=ssl3_send_server_hello(s);
			if (ret <= 0) goto end;

			if (s->hit)
				{
#ifndef OPENSSL_NO_SCTP
				/* Add new shared key for SCTP-Auth,
				 * will be ignored if no SCTP used.
				 */
				snprintf((char*) labelbuffer, sizeof(DTLS1_SCTP_AUTH_LABEL),
				         DTLS1_SCTP_AUTH_LABEL);

				SSL_export_keying_material(s, sctpauthkey,
				                           sizeof(sctpauthkey), labelbuffer,
				                           sizeof(labelbuffer), NULL, 0, 0);
				
				BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY,
                         sizeof(sctpauthkey), sctpauthkey);
#endif
#ifndef OPENSSL_NO_TLSEXT
				if (s->tlsext_ticket_expected)
					s->state=SSL3_ST_SW_SESSION_TICKET_A;
				else
					s->state=SSL3_ST_SW_CHANGE_A;
#else
				s->state=SSL3_ST_SW_CHANGE_A;
#endif
				}
			else
				s->state=SSL3_ST_SW_CERT_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_CERT_A:
		case SSL3_ST_SW_CERT_B:
			/* Check if it is anon DH or normal PSK */
			if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)
				&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
				{
				dtls1_start_timer(s);
				ret=ssl3_send_server_certificate(s);
				if (ret <= 0) goto end;
#ifndef OPENSSL_NO_TLSEXT
				if (s->tlsext_status_expected)
					s->state=SSL3_ST_SW_CERT_STATUS_A;
				else
					s->state=SSL3_ST_SW_KEY_EXCH_A;
				}
			else
				{
				skip = 1;
				s->state=SSL3_ST_SW_KEY_EXCH_A;
				}
#else
				}
			else
				skip=1;

			s->state=SSL3_ST_SW_KEY_EXCH_A;
#endif
			s->init_num=0;
			break;

		case SSL3_ST_SW_KEY_EXCH_A:
 		case SSL3_ST_SW_KEY_EXCH_B:
 			alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
 
			/*
			 * clear this, it may get reset by
			 * send_server_key_exchange
			 */
			s->s3->tmp.use_rsa_tmp=0;
 
 			/* only send if a DH key exchange or
 			 * RSA but we have a sign only certificate */
			if (
 			/* PSK: send ServerKeyExchange if PSK identity
 			 * hint if provided */
 #ifndef OPENSSL_NO_PSK
			    || ((alg_k & SSL_kPSK) && s->ctx->psk_identity_hint)
#endif
			    || (alg_k & (SSL_kDHE|SSL_kDHr|SSL_kDHd))
			    || (alg_k & SSL_kECDHE)
			    || ((alg_k & SSL_kRSA)
				&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL
				    || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)
					&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)
					)
				    )
				)
			    )
				{
				dtls1_start_timer(s);
				ret=ssl3_send_server_key_exchange(s);
				if (ret <= 0) goto end;
				}
			else
				skip=1;

			s->state=SSL3_ST_SW_CERT_REQ_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_CERT_REQ_A:
		case SSL3_ST_SW_CERT_REQ_B:
			if (/* don't request cert unless asked for it: */
				!(s->verify_mode & SSL_VERIFY_PEER) ||
				/* if SSL_VERIFY_CLIENT_ONCE is set,
				 * don't request cert during re-negotiation: */
				((s->session->peer != NULL) &&
				 (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||
				/* never request cert in anonymous ciphersuites
				 * (see section ""Certificate request"" in SSL 3 drafts
				 * and in RFC 2246): */
				((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&
				 /* ... except when the application insists on verification
				  * (against the specs, but s3_clnt.c accepts this for SSL 3) */
				 !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||
				 /* never request cert in Kerberos ciphersuites */
				(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5)
				/* With normal PSK Certificates and
				 * Certificate Requests are omitted */
				|| (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
				{
				/* no cert request */
				skip=1;
				s->s3->tmp.cert_request=0;
				s->state=SSL3_ST_SW_SRVR_DONE_A;
#ifndef OPENSSL_NO_SCTP
				if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
					{
					s->d1->next_state = SSL3_ST_SW_SRVR_DONE_A;
					s->state = DTLS1_SCTP_ST_SW_WRITE_SOCK;
					}
#endif
				}
			else
				{
				s->s3->tmp.cert_request=1;
				dtls1_start_timer(s);
				ret=ssl3_send_certificate_request(s);
				if (ret <= 0) goto end;
#ifndef NETSCAPE_HANG_BUG
				s->state=SSL3_ST_SW_SRVR_DONE_A;
#ifndef OPENSSL_NO_SCTP
				if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
					{
					s->d1->next_state = SSL3_ST_SW_SRVR_DONE_A;
					s->state = DTLS1_SCTP_ST_SW_WRITE_SOCK;
					}
#endif
#else
				s->state=SSL3_ST_SW_FLUSH;
				s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
#ifndef OPENSSL_NO_SCTP
				if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
					{
					s->d1->next_state = s->s3->tmp.next_state;
					s->s3->tmp.next_state=DTLS1_SCTP_ST_SW_WRITE_SOCK;
					}
#endif
#endif
				s->init_num=0;
				}
			break;

		case SSL3_ST_SW_SRVR_DONE_A:
		case SSL3_ST_SW_SRVR_DONE_B:
			dtls1_start_timer(s);
			ret=ssl3_send_server_done(s);
			if (ret <= 0) goto end;
			s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
			s->state=SSL3_ST_SW_FLUSH;
			s->init_num=0;
			break;
		
		case SSL3_ST_SW_FLUSH:
			s->rwstate=SSL_WRITING;
			if (BIO_flush(s->wbio) <= 0)
				{
				/* If the write error was fatal, stop trying */
				if (!BIO_should_retry(s->wbio))
					{
					s->rwstate=SSL_NOTHING;
					s->state=s->s3->tmp.next_state;
					}
				
				ret= -1;
				goto end;
				}
			s->rwstate=SSL_NOTHING;
			s->state=s->s3->tmp.next_state;
			break;

		case SSL3_ST_SR_CERT_A:
		case SSL3_ST_SR_CERT_B:
			if (s->s3->tmp.cert_request)
				{
				ret=ssl3_get_client_certificate(s);
				if (ret <= 0) goto end;
				}
			s->init_num=0;
			s->state=SSL3_ST_SR_KEY_EXCH_A;
			break;

		case SSL3_ST_SR_KEY_EXCH_A:
		case SSL3_ST_SR_KEY_EXCH_B:
			ret=ssl3_get_client_key_exchange(s);
			if (ret <= 0) goto end;
#ifndef OPENSSL_NO_SCTP
			/* Add new shared key for SCTP-Auth,
			 * will be ignored if no SCTP used.
			 */
			snprintf((char *) labelbuffer, sizeof(DTLS1_SCTP_AUTH_LABEL),
			         DTLS1_SCTP_AUTH_LABEL);

			SSL_export_keying_material(s, sctpauthkey,
			                           sizeof(sctpauthkey), labelbuffer,
			                           sizeof(labelbuffer), NULL, 0, 0);

			BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY,
			         sizeof(sctpauthkey), sctpauthkey);
#endif

			s->state=SSL3_ST_SR_CERT_VRFY_A;
			s->init_num=0;

			if (ret == 2)
				{
				/* For the ECDH ciphersuites when
				 * the client sends its ECDH pub key in
				 * a certificate, the CertificateVerify
				 * message is not sent.
				 */
				s->state=SSL3_ST_SR_FINISHED_A;
				s->init_num = 0;
				}
			else if (SSL_USE_SIGALGS(s))
				{
				s->state=SSL3_ST_SR_CERT_VRFY_A;
				s->init_num=0;
				if (!s->session->peer)
					break;
				/* For sigalgs freeze the handshake buffer
				 * at this point and digest cached records.
				 */
				if (!s->s3->handshake_buffer)
					{
					SSLerr(SSL_F_DTLS1_ACCEPT,ERR_R_INTERNAL_ERROR);
					return -1;
					}
				s->s3->flags |= TLS1_FLAGS_KEEP_HANDSHAKE;
				if (!ssl3_digest_cached_records(s))
					return -1;
				}
			else
				{
				s->state=SSL3_ST_SR_CERT_VRFY_A;
				s->init_num=0;

				/* We need to get hashes here so if there is
				 * a client cert, it can be verified */ 
				s->method->ssl3_enc->cert_verify_mac(s,
					NID_md5,
					&(s->s3->tmp.cert_verify_md[0]));
				s->method->ssl3_enc->cert_verify_mac(s,
					NID_sha1,
					&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]));
				}
			break;

		case SSL3_ST_SR_CERT_VRFY_A:
		case SSL3_ST_SR_CERT_VRFY_B:
			/*
			 * This *should* be the first time we enable CCS, but be
			 * extra careful about surrounding code changes. We need
			 * to set this here because we don't know if we're
			 * expecting a CertificateVerify or not.
			 */
			if (!s->s3->change_cipher_spec)
				s->d1->change_cipher_spec_ok = 1;
			/* we should decide if we expected this one */
			ret=ssl3_get_cert_verify(s);
			if (ret <= 0) goto end;
#ifndef OPENSSL_NO_SCTP
			if (BIO_dgram_is_sctp(SSL_get_wbio(s)) &&
			    state == SSL_ST_RENEGOTIATE)
				s->state=DTLS1_SCTP_ST_SR_READ_SOCK;
			else
#endif			
				s->state=SSL3_ST_SR_FINISHED_A;
			s->init_num=0;
			break;

		case SSL3_ST_SR_FINISHED_A:
		case SSL3_ST_SR_FINISHED_B:
			/*
			 * Enable CCS for resumed handshakes.
			 * In a full handshake, we end up here through
			 * SSL3_ST_SR_CERT_VRFY_B, so change_cipher_spec_ok was
			 * already set. Receiving a CCS clears the flag, so make
			 * sure not to re-enable it to ban duplicates.
			 * s->s3->change_cipher_spec is set when a CCS is
			 * processed in d1_pkt.c, and remains set until
			 * the client's Finished message is read.
			 */
			if (!s->s3->change_cipher_spec)
				s->d1->change_cipher_spec_ok = 1;
			ret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,
				SSL3_ST_SR_FINISHED_B);
			if (ret <= 0) goto end;
			dtls1_stop_timer(s);
			if (s->hit)
				s->state=SSL_ST_OK;
#ifndef OPENSSL_NO_TLSEXT
			else if (s->tlsext_ticket_expected)
				s->state=SSL3_ST_SW_SESSION_TICKET_A;
#endif
			else
				s->state=SSL3_ST_SW_CHANGE_A;
			s->init_num=0;
			break;

#ifndef OPENSSL_NO_TLSEXT
		case SSL3_ST_SW_SESSION_TICKET_A:
		case SSL3_ST_SW_SESSION_TICKET_B:
			ret=ssl3_send_newsession_ticket(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_CHANGE_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_CERT_STATUS_A:
		case SSL3_ST_SW_CERT_STATUS_B:
			ret=ssl3_send_cert_status(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_KEY_EXCH_A;
			s->init_num=0;
			break;

#endif

		case SSL3_ST_SW_CHANGE_A:
		case SSL3_ST_SW_CHANGE_B:

			s->session->cipher=s->s3->tmp.new_cipher;
			if (!s->method->ssl3_enc->setup_key_block(s))
				{ ret= -1; goto end; }

			ret=dtls1_send_change_cipher_spec(s,
				SSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);

			if (ret <= 0) goto end;

#ifndef OPENSSL_NO_SCTP
			if (!s->hit)
				{
				/* Change to new shared key of SCTP-Auth,
				 * will be ignored if no SCTP used.
				 */
				BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);
				}
#endif

			s->state=SSL3_ST_SW_FINISHED_A;
			s->init_num=0;

			if (!s->method->ssl3_enc->change_cipher_state(s,
				SSL3_CHANGE_CIPHER_SERVER_WRITE))
				{
				ret= -1;
				goto end;
				}

			dtls1_reset_seq_numbers(s, SSL3_CC_WRITE);
			break;

		case SSL3_ST_SW_FINISHED_A:
		case SSL3_ST_SW_FINISHED_B:
			ret=ssl3_send_finished(s,
				SSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,
				s->method->ssl3_enc->server_finished_label,
				s->method->ssl3_enc->server_finished_label_len);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_FLUSH;
			if (s->hit)
				{
				s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;

#ifndef OPENSSL_NO_SCTP
				/* Change to new shared key of SCTP-Auth,
				 * will be ignored if no SCTP used.
				 */
				BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);
#endif
				}
			else
				{
				s->s3->tmp.next_state=SSL_ST_OK;
#ifndef OPENSSL_NO_SCTP
				if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
					{
					s->d1->next_state = s->s3->tmp.next_state;
					s->s3->tmp.next_state=DTLS1_SCTP_ST_SW_WRITE_SOCK;
					}
#endif
				}
			s->init_num=0;
			break;

		case SSL_ST_OK:
			/* clean a few things up */
			ssl3_cleanup_key_block(s);

#if 0
			BUF_MEM_free(s->init_buf);
			s->init_buf=NULL;
#endif

			/* remove buffering on output */
			ssl_free_wbio_buffer(s);

			s->init_num=0;

			if (s->renegotiate == 2) /* skipped if we just sent a HelloRequest */
				{
				s->renegotiate=0;
				s->new_session=0;
				
				ssl_update_cache(s,SSL_SESS_CACHE_SERVER);
				
				s->ctx->stats.sess_accept_good++;
				/* s->server=1; */
				s->handshake_func=dtls1_accept;

				if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);
				}
			
			ret = 1;

			/* done handshaking, next message is client hello */
			s->d1->handshake_read_seq = 0;
			/* next message is server hello */
			s->d1->handshake_write_seq = 0;
			s->d1->next_handshake_write_seq = 0;
			goto end;
			/* break; */

		default:
			SSLerr(SSL_F_DTLS1_ACCEPT,SSL_R_UNKNOWN_STATE);
			ret= -1;
			goto end;
			/* break; */
			}
		
		if (!s->s3->tmp.reuse_message && !skip)
			{
			if (s->debug)
				{
				if ((ret=BIO_flush(s->wbio)) <= 0)
					goto end;
				}


			if ((cb != NULL) && (s->state != state))
				{
				new_state=s->state;
				s->state=state;
				cb(s,SSL_CB_ACCEPT_LOOP,1);
				s->state=new_state;
				}
			}
		skip=0;
		}
","IMPLEMENT_dtls1_meth_func(DTLS1_VERSION,
			DTLSv1_server_method,
			dtls1_accept,
			ssl_undefined_function,
			dtls1_get_server_method,
			DTLSv1_enc_data)

IMPLEMENT_dtls1_meth_func(DTLS1_2_VERSION,
			DTLSv1_2_server_method,
			dtls1_accept,
			ssl_undefined_function,
			dtls1_get_server_method,
			DTLSv1_2_enc_data)

IMPLEMENT_dtls1_meth_func(DTLS_ANY_VERSION,
			DTLS_server_method,
			dtls1_accept,
			ssl_undefined_function,
			dtls1_get_server_method,
			DTLSv1_2_enc_data)

int dtls1_accept(SSL *s)
	{
	BUF_MEM *buf;
	unsigned long Time=(unsigned long)time(NULL);
	void (*cb)(const SSL *ssl,int type,int val)=NULL;
	unsigned long alg_k;
	int ret= -1;
	int new_state,state,skip=0;
	int listen;
#ifndef OPENSSL_NO_SCTP
	unsigned char sctpauthkey[64];
	char labelbuffer[sizeof(DTLS1_SCTP_AUTH_LABEL)];
#endif

	RAND_add(&Time,sizeof(Time),0);
	ERR_clear_error();
	clear_sys_error();

	if (s->info_callback != NULL)
		cb=s->info_callback;
	else if (s->ctx->info_callback != NULL)
		cb=s->ctx->info_callback;
	
	listen = s->d1->listen;

	/* init things to blank */
	s->in_handshake++;
	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);

	s->d1->listen = listen;
#ifndef OPENSSL_NO_SCTP
	/* Notify SCTP BIO socket to enter handshake
	 * mode and prevent stream identifier other
	 * than 0. Will be ignored if no SCTP is used.
	 */
	BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE, s->in_handshake, NULL);
#endif

	if (s->cert == NULL)
		{
		SSLerr(SSL_F_DTLS1_ACCEPT,SSL_R_NO_CERTIFICATE_SET);
		return(-1);
		}

#ifndef OPENSSL_NO_HEARTBEATS
	/* If we're awaiting a HeartbeatResponse, pretend we
	 * already got and don't await it anymore, because
	 * Heartbeats don't make sense during handshakes anyway.
	 */
	if (s->tlsext_hb_pending)
		{
		dtls1_stop_timer(s);
		s->tlsext_hb_pending = 0;
		s->tlsext_hb_seq++;
		}
#endif

	for (;;)
		{
		state=s->state;

		switch (s->state)
			{
		case SSL_ST_RENEGOTIATE:
			s->renegotiate=1;
			/* s->state=SSL_ST_ACCEPT; */

		case SSL_ST_BEFORE:
		case SSL_ST_ACCEPT:
		case SSL_ST_BEFORE|SSL_ST_ACCEPT:
		case SSL_ST_OK|SSL_ST_ACCEPT:

			s->server=1;
			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);

			if ((s->version & 0xff00) != (DTLS1_VERSION & 0xff00))
				{
				SSLerr(SSL_F_DTLS1_ACCEPT, ERR_R_INTERNAL_ERROR);
				return -1;
				}
			s->type=SSL_ST_ACCEPT;

			if (s->init_buf == NULL)
				{
				if ((buf=BUF_MEM_new()) == NULL)
					{
					ret= -1;
					goto end;
					}
				if (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))
					{
					BUF_MEM_free(buf);
					ret= -1;
					goto end;
					}
				s->init_buf=buf;
				}

			if (!ssl3_setup_buffers(s))
				{
				ret= -1;
				goto end;
				}

			s->init_num=0;
			s->d1->change_cipher_spec_ok = 0;
			/* Should have been reset by ssl3_get_finished, too. */
			s->s3->change_cipher_spec = 0;

			if (s->state != SSL_ST_RENEGOTIATE)
				{
				/* Ok, we now need to push on a buffering BIO so that
				 * the output is sent in a way that TCP likes :-)
				 * ...but not with SCTP :-)
				 */
#ifndef OPENSSL_NO_SCTP
				if (!BIO_dgram_is_sctp(SSL_get_wbio(s)))
#endif
					if (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }

				ssl3_init_finished_mac(s);
				s->state=SSL3_ST_SR_CLNT_HELLO_A;
				s->ctx->stats.sess_accept++;
				}
			else
				{
				/* s->state == SSL_ST_RENEGOTIATE,
				 * we will just send a HelloRequest */
				s->ctx->stats.sess_accept_renegotiate++;
				s->state=SSL3_ST_SW_HELLO_REQ_A;
				}

			break;

		case SSL3_ST_SW_HELLO_REQ_A:
		case SSL3_ST_SW_HELLO_REQ_B:

			s->shutdown=0;
			dtls1_clear_record_buffer(s);
			dtls1_start_timer(s);
			ret=ssl3_send_hello_request(s);
			if (ret <= 0) goto end;
			s->s3->tmp.next_state=SSL3_ST_SR_CLNT_HELLO_A;
			s->state=SSL3_ST_SW_FLUSH;
			s->init_num=0;

			ssl3_init_finished_mac(s);
			break;

		case SSL3_ST_SW_HELLO_REQ_C:
			s->state=SSL_ST_OK;
			break;

		case SSL3_ST_SR_CLNT_HELLO_A:
		case SSL3_ST_SR_CLNT_HELLO_B:
		case SSL3_ST_SR_CLNT_HELLO_C:

			s->shutdown=0;
			ret=ssl3_get_client_hello(s);
			if (ret <= 0) goto end;
			dtls1_stop_timer(s);

			if (ret == 1 && (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE))
				s->state = DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A;
			else
				s->state = SSL3_ST_SW_SRVR_HELLO_A;

			s->init_num=0;

			/* Reflect ClientHello sequence to remain stateless while listening */
			if (listen)
				{
				memcpy(s->s3->write_sequence, s->s3->read_sequence, sizeof(s->s3->write_sequence));
				}

			/* If we're just listening, stop here */
			if (listen && s->state == SSL3_ST_SW_SRVR_HELLO_A)
				{
				ret = 2;
				s->d1->listen = 0;
				/* Set expected sequence numbers
				 * to continue the handshake.
				 */
				s->d1->handshake_read_seq = 2;
				s->d1->handshake_write_seq = 1;
				s->d1->next_handshake_write_seq = 1;
				goto end;
				}
			
			break;
			
		case DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A:
		case DTLS1_ST_SW_HELLO_VERIFY_REQUEST_B:

			ret = dtls1_send_hello_verify_request(s);
			if ( ret <= 0) goto end;
			s->state=SSL3_ST_SW_FLUSH;
			s->s3->tmp.next_state=SSL3_ST_SR_CLNT_HELLO_A;

			/* HelloVerifyRequest resets Finished MAC */
			if (s->version != DTLS1_BAD_VER)
				ssl3_init_finished_mac(s);
			break;
			
#ifndef OPENSSL_NO_SCTP
		case DTLS1_SCTP_ST_SR_READ_SOCK:
			
			if (BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s)))		
				{
				s->s3->in_read_app_data=2;
				s->rwstate=SSL_READING;
				BIO_clear_retry_flags(SSL_get_rbio(s));
				BIO_set_retry_read(SSL_get_rbio(s));
				ret = -1;
				goto end;
				}
			
			s->state=SSL3_ST_SR_FINISHED_A;
			break;
			
		case DTLS1_SCTP_ST_SW_WRITE_SOCK:
			ret = BIO_dgram_sctp_wait_for_dry(SSL_get_wbio(s));
			if (ret < 0) goto end;
			
			if (ret == 0)
				{
				if (s->d1->next_state != SSL_ST_OK)
					{
					s->s3->in_read_app_data=2;
					s->rwstate=SSL_READING;
					BIO_clear_retry_flags(SSL_get_rbio(s));
					BIO_set_retry_read(SSL_get_rbio(s));
					ret = -1;
					goto end;
					}
				}

			s->state=s->d1->next_state;
			break;
#endif

		case SSL3_ST_SW_SRVR_HELLO_A:
		case SSL3_ST_SW_SRVR_HELLO_B:
			s->renegotiate = 2;
			dtls1_start_timer(s);
			ret=ssl3_send_server_hello(s);
			if (ret <= 0) goto end;

			if (s->hit)
				{
#ifndef OPENSSL_NO_SCTP
				/* Add new shared key for SCTP-Auth,
				 * will be ignored if no SCTP used.
				 */
				snprintf((char*) labelbuffer, sizeof(DTLS1_SCTP_AUTH_LABEL),
				         DTLS1_SCTP_AUTH_LABEL);

				SSL_export_keying_material(s, sctpauthkey,
				                           sizeof(sctpauthkey), labelbuffer,
				                           sizeof(labelbuffer), NULL, 0, 0);
				
				BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY,
                         sizeof(sctpauthkey), sctpauthkey);
#endif
#ifndef OPENSSL_NO_TLSEXT
				if (s->tlsext_ticket_expected)
					s->state=SSL3_ST_SW_SESSION_TICKET_A;
				else
					s->state=SSL3_ST_SW_CHANGE_A;
#else
				s->state=SSL3_ST_SW_CHANGE_A;
#endif
				}
			else
				s->state=SSL3_ST_SW_CERT_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_CERT_A:
		case SSL3_ST_SW_CERT_B:
			/* Check if it is anon DH or normal PSK */
			if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)
				&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
				{
				dtls1_start_timer(s);
				ret=ssl3_send_server_certificate(s);
				if (ret <= 0) goto end;
#ifndef OPENSSL_NO_TLSEXT
				if (s->tlsext_status_expected)
					s->state=SSL3_ST_SW_CERT_STATUS_A;
				else
					s->state=SSL3_ST_SW_KEY_EXCH_A;
				}
			else
				{
				skip = 1;
				s->state=SSL3_ST_SW_KEY_EXCH_A;
				}
#else
				}
			else
				skip=1;

			s->state=SSL3_ST_SW_KEY_EXCH_A;
#endif
			s->init_num=0;
			break;

		case SSL3_ST_SW_KEY_EXCH_A:
 		case SSL3_ST_SW_KEY_EXCH_B:
 			alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
 
			/* clear this, it may get reset by
			 * send_server_key_exchange */
			if ((s->options & SSL_OP_EPHEMERAL_RSA)
#ifndef OPENSSL_NO_KRB5
				&& !(alg_k & SSL_kKRB5)
#endif /* OPENSSL_NO_KRB5 */
				)
				/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key
				 * even when forbidden by protocol specs
				 * (handshake may fail as clients are not required to
				 * be able to handle this) */
				s->s3->tmp.use_rsa_tmp=1;
			else
				s->s3->tmp.use_rsa_tmp=0;
 
 			/* only send if a DH key exchange or
 			 * RSA but we have a sign only certificate */
			if (s->s3->tmp.use_rsa_tmp
 			/* PSK: send ServerKeyExchange if PSK identity
 			 * hint if provided */
 #ifndef OPENSSL_NO_PSK
			    || ((alg_k & SSL_kPSK) && s->ctx->psk_identity_hint)
#endif
			    || (alg_k & (SSL_kDHE|SSL_kDHr|SSL_kDHd))
			    || (alg_k & SSL_kECDHE)
			    || ((alg_k & SSL_kRSA)
				&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL
				    || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)
					&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)
					)
				    )
				)
			    )
				{
				dtls1_start_timer(s);
				ret=ssl3_send_server_key_exchange(s);
				if (ret <= 0) goto end;
				}
			else
				skip=1;

			s->state=SSL3_ST_SW_CERT_REQ_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_CERT_REQ_A:
		case SSL3_ST_SW_CERT_REQ_B:
			if (/* don't request cert unless asked for it: */
				!(s->verify_mode & SSL_VERIFY_PEER) ||
				/* if SSL_VERIFY_CLIENT_ONCE is set,
				 * don't request cert during re-negotiation: */
				((s->session->peer != NULL) &&
				 (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||
				/* never request cert in anonymous ciphersuites
				 * (see section ""Certificate request"" in SSL 3 drafts
				 * and in RFC 2246): */
				((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&
				 /* ... except when the application insists on verification
				  * (against the specs, but s3_clnt.c accepts this for SSL 3) */
				 !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||
				 /* never request cert in Kerberos ciphersuites */
				(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5)
				/* With normal PSK Certificates and
				 * Certificate Requests are omitted */
				|| (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
				{
				/* no cert request */
				skip=1;
				s->s3->tmp.cert_request=0;
				s->state=SSL3_ST_SW_SRVR_DONE_A;
#ifndef OPENSSL_NO_SCTP
				if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
					{
					s->d1->next_state = SSL3_ST_SW_SRVR_DONE_A;
					s->state = DTLS1_SCTP_ST_SW_WRITE_SOCK;
					}
#endif
				}
			else
				{
				s->s3->tmp.cert_request=1;
				dtls1_start_timer(s);
				ret=ssl3_send_certificate_request(s);
				if (ret <= 0) goto end;
#ifndef NETSCAPE_HANG_BUG
				s->state=SSL3_ST_SW_SRVR_DONE_A;
#ifndef OPENSSL_NO_SCTP
				if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
					{
					s->d1->next_state = SSL3_ST_SW_SRVR_DONE_A;
					s->state = DTLS1_SCTP_ST_SW_WRITE_SOCK;
					}
#endif
#else
				s->state=SSL3_ST_SW_FLUSH;
				s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
#ifndef OPENSSL_NO_SCTP
				if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
					{
					s->d1->next_state = s->s3->tmp.next_state;
					s->s3->tmp.next_state=DTLS1_SCTP_ST_SW_WRITE_SOCK;
					}
#endif
#endif
				s->init_num=0;
				}
			break;

		case SSL3_ST_SW_SRVR_DONE_A:
		case SSL3_ST_SW_SRVR_DONE_B:
			dtls1_start_timer(s);
			ret=ssl3_send_server_done(s);
			if (ret <= 0) goto end;
			s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
			s->state=SSL3_ST_SW_FLUSH;
			s->init_num=0;
			break;
		
		case SSL3_ST_SW_FLUSH:
			s->rwstate=SSL_WRITING;
			if (BIO_flush(s->wbio) <= 0)
				{
				/* If the write error was fatal, stop trying */
				if (!BIO_should_retry(s->wbio))
					{
					s->rwstate=SSL_NOTHING;
					s->state=s->s3->tmp.next_state;
					}
				
				ret= -1;
				goto end;
				}
			s->rwstate=SSL_NOTHING;
			s->state=s->s3->tmp.next_state;
			break;

		case SSL3_ST_SR_CERT_A:
		case SSL3_ST_SR_CERT_B:
			if (s->s3->tmp.cert_request)
				{
				ret=ssl3_get_client_certificate(s);
				if (ret <= 0) goto end;
				}
			s->init_num=0;
			s->state=SSL3_ST_SR_KEY_EXCH_A;
			break;

		case SSL3_ST_SR_KEY_EXCH_A:
		case SSL3_ST_SR_KEY_EXCH_B:
			ret=ssl3_get_client_key_exchange(s);
			if (ret <= 0) goto end;
#ifndef OPENSSL_NO_SCTP
			/* Add new shared key for SCTP-Auth,
			 * will be ignored if no SCTP used.
			 */
			snprintf((char *) labelbuffer, sizeof(DTLS1_SCTP_AUTH_LABEL),
			         DTLS1_SCTP_AUTH_LABEL);

			SSL_export_keying_material(s, sctpauthkey,
			                           sizeof(sctpauthkey), labelbuffer,
			                           sizeof(labelbuffer), NULL, 0, 0);

			BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY,
			         sizeof(sctpauthkey), sctpauthkey);
#endif

			s->state=SSL3_ST_SR_CERT_VRFY_A;
			s->init_num=0;

			if (ret == 2)
				{
				/* For the ECDH ciphersuites when
				 * the client sends its ECDH pub key in
				 * a certificate, the CertificateVerify
				 * message is not sent.
				 */
				s->state=SSL3_ST_SR_FINISHED_A;
				s->init_num = 0;
				}
			else if (SSL_USE_SIGALGS(s))
				{
				s->state=SSL3_ST_SR_CERT_VRFY_A;
				s->init_num=0;
				if (!s->session->peer)
					break;
				/* For sigalgs freeze the handshake buffer
				 * at this point and digest cached records.
				 */
				if (!s->s3->handshake_buffer)
					{
					SSLerr(SSL_F_DTLS1_ACCEPT,ERR_R_INTERNAL_ERROR);
					return -1;
					}
				s->s3->flags |= TLS1_FLAGS_KEEP_HANDSHAKE;
				if (!ssl3_digest_cached_records(s))
					return -1;
				}
			else
				{
				s->state=SSL3_ST_SR_CERT_VRFY_A;
				s->init_num=0;

				/* We need to get hashes here so if there is
				 * a client cert, it can be verified */ 
				s->method->ssl3_enc->cert_verify_mac(s,
					NID_md5,
					&(s->s3->tmp.cert_verify_md[0]));
				s->method->ssl3_enc->cert_verify_mac(s,
					NID_sha1,
					&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]));
				}
			break;

		case SSL3_ST_SR_CERT_VRFY_A:
		case SSL3_ST_SR_CERT_VRFY_B:
			/*
			 * This *should* be the first time we enable CCS, but be
			 * extra careful about surrounding code changes. We need
			 * to set this here because we don't know if we're
			 * expecting a CertificateVerify or not.
			 */
			if (!s->s3->change_cipher_spec)
				s->d1->change_cipher_spec_ok = 1;
			/* we should decide if we expected this one */
			ret=ssl3_get_cert_verify(s);
			if (ret <= 0) goto end;
#ifndef OPENSSL_NO_SCTP
			if (BIO_dgram_is_sctp(SSL_get_wbio(s)) &&
			    state == SSL_ST_RENEGOTIATE)
				s->state=DTLS1_SCTP_ST_SR_READ_SOCK;
			else
#endif			
				s->state=SSL3_ST_SR_FINISHED_A;
			s->init_num=0;
			break;

		case SSL3_ST_SR_FINISHED_A:
		case SSL3_ST_SR_FINISHED_B:
			/*
			 * Enable CCS for resumed handshakes.
			 * In a full handshake, we end up here through
			 * SSL3_ST_SR_CERT_VRFY_B, so change_cipher_spec_ok was
			 * already set. Receiving a CCS clears the flag, so make
			 * sure not to re-enable it to ban duplicates.
			 * s->s3->change_cipher_spec is set when a CCS is
			 * processed in d1_pkt.c, and remains set until
			 * the client's Finished message is read.
			 */
			if (!s->s3->change_cipher_spec)
				s->d1->change_cipher_spec_ok = 1;
			ret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,
				SSL3_ST_SR_FINISHED_B);
			if (ret <= 0) goto end;
			dtls1_stop_timer(s);
			if (s->hit)
				s->state=SSL_ST_OK;
#ifndef OPENSSL_NO_TLSEXT
			else if (s->tlsext_ticket_expected)
				s->state=SSL3_ST_SW_SESSION_TICKET_A;
#endif
			else
				s->state=SSL3_ST_SW_CHANGE_A;
			s->init_num=0;
			break;

#ifndef OPENSSL_NO_TLSEXT
		case SSL3_ST_SW_SESSION_TICKET_A:
		case SSL3_ST_SW_SESSION_TICKET_B:
			ret=ssl3_send_newsession_ticket(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_CHANGE_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_CERT_STATUS_A:
		case SSL3_ST_SW_CERT_STATUS_B:
			ret=ssl3_send_cert_status(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_KEY_EXCH_A;
			s->init_num=0;
			break;

#endif

		case SSL3_ST_SW_CHANGE_A:
		case SSL3_ST_SW_CHANGE_B:

			s->session->cipher=s->s3->tmp.new_cipher;
			if (!s->method->ssl3_enc->setup_key_block(s))
				{ ret= -1; goto end; }

			ret=dtls1_send_change_cipher_spec(s,
				SSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);

			if (ret <= 0) goto end;

#ifndef OPENSSL_NO_SCTP
			if (!s->hit)
				{
				/* Change to new shared key of SCTP-Auth,
				 * will be ignored if no SCTP used.
				 */
				BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);
				}
#endif

			s->state=SSL3_ST_SW_FINISHED_A;
			s->init_num=0;

			if (!s->method->ssl3_enc->change_cipher_state(s,
				SSL3_CHANGE_CIPHER_SERVER_WRITE))
				{
				ret= -1;
				goto end;
				}

			dtls1_reset_seq_numbers(s, SSL3_CC_WRITE);
			break;

		case SSL3_ST_SW_FINISHED_A:
		case SSL3_ST_SW_FINISHED_B:
			ret=ssl3_send_finished(s,
				SSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,
				s->method->ssl3_enc->server_finished_label,
				s->method->ssl3_enc->server_finished_label_len);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_FLUSH;
			if (s->hit)
				{
				s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;

#ifndef OPENSSL_NO_SCTP
				/* Change to new shared key of SCTP-Auth,
				 * will be ignored if no SCTP used.
				 */
				BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);
#endif
				}
			else
				{
				s->s3->tmp.next_state=SSL_ST_OK;
#ifndef OPENSSL_NO_SCTP
				if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
					{
					s->d1->next_state = s->s3->tmp.next_state;
					s->s3->tmp.next_state=DTLS1_SCTP_ST_SW_WRITE_SOCK;
					}
#endif
				}
			s->init_num=0;
			break;

		case SSL_ST_OK:
			/* clean a few things up */
			ssl3_cleanup_key_block(s);

#if 0
			BUF_MEM_free(s->init_buf);
			s->init_buf=NULL;
#endif

			/* remove buffering on output */
			ssl_free_wbio_buffer(s);

			s->init_num=0;

			if (s->renegotiate == 2) /* skipped if we just sent a HelloRequest */
				{
				s->renegotiate=0;
				s->new_session=0;
				
				ssl_update_cache(s,SSL_SESS_CACHE_SERVER);
				
				s->ctx->stats.sess_accept_good++;
				/* s->server=1; */
				s->handshake_func=dtls1_accept;

				if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);
				}
			
			ret = 1;

			/* done handshaking, next message is client hello */
			s->d1->handshake_read_seq = 0;
			/* next message is server hello */
			s->d1->handshake_write_seq = 0;
			s->d1->next_handshake_write_seq = 0;
			goto end;
			/* break; */

		default:
			SSLerr(SSL_F_DTLS1_ACCEPT,SSL_R_UNKNOWN_STATE);
			ret= -1;
			goto end;
			/* break; */
			}
		
		if (!s->s3->tmp.reuse_message && !skip)
			{
			if (s->debug)
				{
				if ((ret=BIO_flush(s->wbio)) <= 0)
					goto end;
				}


			if ((cb != NULL) && (s->state != state))
				{
				new_state=s->state;
				s->state=state;
				cb(s,SSL_CB_ACCEPT_LOOP,1);
				s->state=new_state;
				}
			}
		skip=0;
		}
",C,"			/*
			 * clear this, it may get reset by
			 * send_server_key_exchange
			 */
			s->s3->tmp.use_rsa_tmp=0;
			if (
","			/* clear this, it may get reset by
			 * send_server_key_exchange */
			if ((s->options & SSL_OP_EPHEMERAL_RSA)
#ifndef OPENSSL_NO_KRB5
				&& !(alg_k & SSL_kKRB5)
#endif /* OPENSSL_NO_KRB5 */
				)
				/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key
				 * even when forbidden by protocol specs
				 * (handshake may fail as clients are not required to
				 * be able to handle this) */
				s->s3->tmp.use_rsa_tmp=1;
			else
				s->s3->tmp.use_rsa_tmp=0;
			if (s->s3->tmp.use_rsa_tmp
",,"@@ -472,24 +472,15 @@ int dtls1_accept(SSL *s)
 		case SSL3_ST_SW_KEY_EXCH_B:
 			alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
 
-			/* clear this, it may get reset by
-			 * send_server_key_exchange */
-			if ((s->options & SSL_OP_EPHEMERAL_RSA)
-#ifndef OPENSSL_NO_KRB5
-				&& !(alg_k & SSL_kKRB5)
-#endif /* OPENSSL_NO_KRB5 */
-				)
-				/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key
-				 * even when forbidden by protocol specs
-				 * (handshake may fail as clients are not required to
-				 * be able to handle this) */
-				s->s3->tmp.use_rsa_tmp=1;
-			else
-				s->s3->tmp.use_rsa_tmp=0;
+			/*
+			 * clear this, it may get reset by
+			 * send_server_key_exchange
+			 */
+			s->s3->tmp.use_rsa_tmp=0;
 
 			/* only send if a DH key exchange or
 			 * RSA but we have a sign only certificate */
-			if (s->s3->tmp.use_rsa_tmp
+			if (
 			/* PSK: send ServerKeyExchange if PSK identity
 			 * hint if provided */
 #ifndef OPENSSL_NO_PSK",openssl,ce325c60c74b0fa784f5872404b722e120e5cab0,b15f8769644b00ef7283521593360b7b2135cb63,1,"IMPLEMENT_dtls1_meth_func(DTLS1_VERSION,
			DTLSv1_server_method,
			dtls1_accept,
			ssl_undefined_function,
			dtls1_get_server_method,
			DTLSv1_enc_data)

IMPLEMENT_dtls1_meth_func(DTLS1_2_VERSION,
			DTLSv1_2_server_method,
			dtls1_accept,
			ssl_undefined_function,
			dtls1_get_server_method,
			DTLSv1_2_enc_data)

IMPLEMENT_dtls1_meth_func(DTLS_ANY_VERSION,
			DTLS_server_method,
			dtls1_accept,
			ssl_undefined_function,
			dtls1_get_server_method,
			DTLSv1_2_enc_data)

int dtls1_accept(SSL *s)
	{
	BUF_MEM *buf;
	unsigned long Time=(unsigned long)time(NULL);
	void (*cb)(const SSL *ssl,int type,int val)=NULL;
	unsigned long alg_k;
	int ret= -1;
	int new_state,state,skip=0;
	int listen;
#ifndef OPENSSL_NO_SCTP
	unsigned char sctpauthkey[64];
	char labelbuffer[sizeof(DTLS1_SCTP_AUTH_LABEL)];
#endif

	RAND_add(&Time,sizeof(Time),0);
	ERR_clear_error();
	clear_sys_error();

	if (s->info_callback != NULL)
		cb=s->info_callback;
	else if (s->ctx->info_callback != NULL)
		cb=s->ctx->info_callback;
	
	listen = s->d1->listen;

	/* init things to blank */
	s->in_handshake++;
	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);

	s->d1->listen = listen;
#ifndef OPENSSL_NO_SCTP
	/* Notify SCTP BIO socket to enter handshake
	 * mode and prevent stream identifier other
	 * than 0. Will be ignored if no SCTP is used.
	 */
	BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE, s->in_handshake, NULL);
#endif

	if (s->cert == NULL)
		{
		SSLerr(SSL_F_DTLS1_ACCEPT,SSL_R_NO_CERTIFICATE_SET);
		return(-1);
		}

#ifndef OPENSSL_NO_HEARTBEATS
	/* If we're awaiting a HeartbeatResponse, pretend we
	 * already got and don't await it anymore, because
	 * Heartbeats don't make sense during handshakes anyway.
	 */
	if (s->tlsext_hb_pending)
		{
		dtls1_stop_timer(s);
		s->tlsext_hb_pending = 0;
		s->tlsext_hb_seq++;
		}
#endif

	for (;;)
		{
		state=s->state;

		switch (s->state)
			{
		case SSL_ST_RENEGOTIATE:
			s->renegotiate=1;
			/* s->state=SSL_ST_ACCEPT; */

		case SSL_ST_BEFORE:
		case SSL_ST_ACCEPT:
		case SSL_ST_BEFORE|SSL_ST_ACCEPT:
		case SSL_ST_OK|SSL_ST_ACCEPT:

			s->server=1;
			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);

			if ((s->version & 0xff00) != (DTLS1_VERSION & 0xff00))
				{
				SSLerr(SSL_F_DTLS1_ACCEPT, ERR_R_INTERNAL_ERROR);
				return -1;
				}
			s->type=SSL_ST_ACCEPT;

			if (s->init_buf == NULL)
				{
				if ((buf=BUF_MEM_new()) == NULL)
					{
					ret= -1;
					goto end;
					}
				if (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))
					{
					BUF_MEM_free(buf);
					ret= -1;
					goto end;
					}
				s->init_buf=buf;
				}

			if (!ssl3_setup_buffers(s))
				{
				ret= -1;
				goto end;
				}

			s->init_num=0;
			s->d1->change_cipher_spec_ok = 0;
			/* Should have been reset by ssl3_get_finished, too. */
			s->s3->change_cipher_spec = 0;

			if (s->state != SSL_ST_RENEGOTIATE)
				{
				/* Ok, we now need to push on a buffering BIO so that
				 * the output is sent in a way that TCP likes :-)
				 * ...but not with SCTP :-)
				 */
#ifndef OPENSSL_NO_SCTP
				if (!BIO_dgram_is_sctp(SSL_get_wbio(s)))
#endif
					if (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }

				ssl3_init_finished_mac(s);
				s->state=SSL3_ST_SR_CLNT_HELLO_A;
				s->ctx->stats.sess_accept++;
				}
			else
				{
				/* s->state == SSL_ST_RENEGOTIATE,
				 * we will just send a HelloRequest */
				s->ctx->stats.sess_accept_renegotiate++;
				s->state=SSL3_ST_SW_HELLO_REQ_A;
				}

			break;

		case SSL3_ST_SW_HELLO_REQ_A:
		case SSL3_ST_SW_HELLO_REQ_B:

			s->shutdown=0;
			dtls1_clear_record_buffer(s);
			dtls1_start_timer(s);
			ret=ssl3_send_hello_request(s);
			if (ret <= 0) goto end;
			s->s3->tmp.next_state=SSL3_ST_SR_CLNT_HELLO_A;
			s->state=SSL3_ST_SW_FLUSH;
			s->init_num=0;

			ssl3_init_finished_mac(s);
			break;

		case SSL3_ST_SW_HELLO_REQ_C:
			s->state=SSL_ST_OK;
			break;

		case SSL3_ST_SR_CLNT_HELLO_A:
		case SSL3_ST_SR_CLNT_HELLO_B:
		case SSL3_ST_SR_CLNT_HELLO_C:

			s->shutdown=0;
			ret=ssl3_get_client_hello(s);
			if (ret <= 0) goto end;
			dtls1_stop_timer(s);

			if (ret == 1 && (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE))
				s->state = DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A;
			else
				s->state = SSL3_ST_SW_SRVR_HELLO_A;

			s->init_num=0;

			/* Reflect ClientHello sequence to remain stateless while listening */
			if (listen)
				{
				memcpy(s->s3->write_sequence, s->s3->read_sequence, sizeof(s->s3->write_sequence));
				}

			/* If we're just listening, stop here */
			if (listen && s->state == SSL3_ST_SW_SRVR_HELLO_A)
				{
				ret = 2;
				s->d1->listen = 0;
				/* Set expected sequence numbers
				 * to continue the handshake.
				 */
				s->d1->handshake_read_seq = 2;
				s->d1->handshake_write_seq = 1;
				s->d1->next_handshake_write_seq = 1;
				goto end;
				}
			
			break;
			
		case DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A:
		case DTLS1_ST_SW_HELLO_VERIFY_REQUEST_B:

			ret = dtls1_send_hello_verify_request(s);
			if ( ret <= 0) goto end;
			s->state=SSL3_ST_SW_FLUSH;
			s->s3->tmp.next_state=SSL3_ST_SR_CLNT_HELLO_A;

			/* HelloVerifyRequest resets Finished MAC */
			if (s->version != DTLS1_BAD_VER)
				ssl3_init_finished_mac(s);
			break;
			
#ifndef OPENSSL_NO_SCTP
		case DTLS1_SCTP_ST_SR_READ_SOCK:
			
			if (BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s)))		
				{
				s->s3->in_read_app_data=2;
				s->rwstate=SSL_READING;
				BIO_clear_retry_flags(SSL_get_rbio(s));
				BIO_set_retry_read(SSL_get_rbio(s));
				ret = -1;
				goto end;
				}
			
			s->state=SSL3_ST_SR_FINISHED_A;
			break;
			
		case DTLS1_SCTP_ST_SW_WRITE_SOCK:
			ret = BIO_dgram_sctp_wait_for_dry(SSL_get_wbio(s));
			if (ret < 0) goto end;
			
			if (ret == 0)
				{
				if (s->d1->next_state != SSL_ST_OK)
					{
					s->s3->in_read_app_data=2;
					s->rwstate=SSL_READING;
					BIO_clear_retry_flags(SSL_get_rbio(s));
					BIO_set_retry_read(SSL_get_rbio(s));
					ret = -1;
					goto end;
					}
				}

			s->state=s->d1->next_state;
			break;
#endif

		case SSL3_ST_SW_SRVR_HELLO_A:
		case SSL3_ST_SW_SRVR_HELLO_B:
			s->renegotiate = 2;
			dtls1_start_timer(s);
			ret=ssl3_send_server_hello(s);
			if (ret <= 0) goto end;

			if (s->hit)
				{
#ifndef OPENSSL_NO_SCTP
				/* Add new shared key for SCTP-Auth,
				 * will be ignored if no SCTP used.
				 */
				snprintf((char*) labelbuffer, sizeof(DTLS1_SCTP_AUTH_LABEL),
				         DTLS1_SCTP_AUTH_LABEL);

				SSL_export_keying_material(s, sctpauthkey,
				                           sizeof(sctpauthkey), labelbuffer,
				                           sizeof(labelbuffer), NULL, 0, 0);
				
				BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY,
                         sizeof(sctpauthkey), sctpauthkey);
#endif
#ifndef OPENSSL_NO_TLSEXT
				if (s->tlsext_ticket_expected)
					s->state=SSL3_ST_SW_SESSION_TICKET_A;
				else
					s->state=SSL3_ST_SW_CHANGE_A;
#else
				s->state=SSL3_ST_SW_CHANGE_A;
#endif
				}
			else
				s->state=SSL3_ST_SW_CERT_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_CERT_A:
		case SSL3_ST_SW_CERT_B:
			/* Check if it is anon DH or normal PSK */
			if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)
				&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
				{
				dtls1_start_timer(s);
				ret=ssl3_send_server_certificate(s);
				if (ret <= 0) goto end;
#ifndef OPENSSL_NO_TLSEXT
				if (s->tlsext_status_expected)
					s->state=SSL3_ST_SW_CERT_STATUS_A;
				else
					s->state=SSL3_ST_SW_KEY_EXCH_A;
				}
			else
				{
				skip = 1;
				s->state=SSL3_ST_SW_KEY_EXCH_A;
				}
#else
				}
			else
				skip=1;

			s->state=SSL3_ST_SW_KEY_EXCH_A;
#endif
			s->init_num=0;
			break;

		case SSL3_ST_SW_KEY_EXCH_A:
 		case SSL3_ST_SW_KEY_EXCH_B:
 			alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
 
//flaw_line_below:
			/* clear this, it may get reset by
//flaw_line_below:
			 * send_server_key_exchange */
//flaw_line_below:
			if ((s->options & SSL_OP_EPHEMERAL_RSA)
//flaw_line_below:
#ifndef OPENSSL_NO_KRB5
//flaw_line_below:
				&& !(alg_k & SSL_kKRB5)
//flaw_line_below:
#endif /* OPENSSL_NO_KRB5 */
//flaw_line_below:
				)
//flaw_line_below:
				/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key
//flaw_line_below:
				 * even when forbidden by protocol specs
//flaw_line_below:
				 * (handshake may fail as clients are not required to
//flaw_line_below:
				 * be able to handle this) */
//flaw_line_below:
				s->s3->tmp.use_rsa_tmp=1;
//flaw_line_below:
			else
//flaw_line_below:
				s->s3->tmp.use_rsa_tmp=0;
//fix_flaw_line_below:
//			/*
//fix_flaw_line_below:
//			 * clear this, it may get reset by
//fix_flaw_line_below:
//			 * send_server_key_exchange
//fix_flaw_line_below:
//			 */
//fix_flaw_line_below:
//			s->s3->tmp.use_rsa_tmp=0;
 
 			/* only send if a DH key exchange or
 			 * RSA but we have a sign only certificate */
//flaw_line_below:
			if (s->s3->tmp.use_rsa_tmp
//fix_flaw_line_below:
//			if (
 			/* PSK: send ServerKeyExchange if PSK identity
 			 * hint if provided */
 #ifndef OPENSSL_NO_PSK
			    || ((alg_k & SSL_kPSK) && s->ctx->psk_identity_hint)
#endif
			    || (alg_k & (SSL_kDHE|SSL_kDHr|SSL_kDHd))
			    || (alg_k & SSL_kECDHE)
			    || ((alg_k & SSL_kRSA)
				&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL
				    || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)
					&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)
					)
				    )
				)
			    )
				{
				dtls1_start_timer(s);
				ret=ssl3_send_server_key_exchange(s);
				if (ret <= 0) goto end;
				}
			else
				skip=1;

			s->state=SSL3_ST_SW_CERT_REQ_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_CERT_REQ_A:
		case SSL3_ST_SW_CERT_REQ_B:
			if (/* don't request cert unless asked for it: */
				!(s->verify_mode & SSL_VERIFY_PEER) ||
				/* if SSL_VERIFY_CLIENT_ONCE is set,
				 * don't request cert during re-negotiation: */
				((s->session->peer != NULL) &&
				 (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||
				/* never request cert in anonymous ciphersuites
				 * (see section ""Certificate request"" in SSL 3 drafts
				 * and in RFC 2246): */
				((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&
				 /* ... except when the application insists on verification
				  * (against the specs, but s3_clnt.c accepts this for SSL 3) */
				 !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||
				 /* never request cert in Kerberos ciphersuites */
				(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5)
				/* With normal PSK Certificates and
				 * Certificate Requests are omitted */
				|| (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
				{
				/* no cert request */
				skip=1;
				s->s3->tmp.cert_request=0;
				s->state=SSL3_ST_SW_SRVR_DONE_A;
#ifndef OPENSSL_NO_SCTP
				if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
					{
					s->d1->next_state = SSL3_ST_SW_SRVR_DONE_A;
					s->state = DTLS1_SCTP_ST_SW_WRITE_SOCK;
					}
#endif
				}
			else
				{
				s->s3->tmp.cert_request=1;
				dtls1_start_timer(s);
				ret=ssl3_send_certificate_request(s);
				if (ret <= 0) goto end;
#ifndef NETSCAPE_HANG_BUG
				s->state=SSL3_ST_SW_SRVR_DONE_A;
#ifndef OPENSSL_NO_SCTP
				if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
					{
					s->d1->next_state = SSL3_ST_SW_SRVR_DONE_A;
					s->state = DTLS1_SCTP_ST_SW_WRITE_SOCK;
					}
#endif
#else
				s->state=SSL3_ST_SW_FLUSH;
				s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
#ifndef OPENSSL_NO_SCTP
				if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
					{
					s->d1->next_state = s->s3->tmp.next_state;
					s->s3->tmp.next_state=DTLS1_SCTP_ST_SW_WRITE_SOCK;
					}
#endif
#endif
				s->init_num=0;
				}
			break;

		case SSL3_ST_SW_SRVR_DONE_A:
		case SSL3_ST_SW_SRVR_DONE_B:
			dtls1_start_timer(s);
			ret=ssl3_send_server_done(s);
			if (ret <= 0) goto end;
			s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
			s->state=SSL3_ST_SW_FLUSH;
			s->init_num=0;
			break;
		
		case SSL3_ST_SW_FLUSH:
			s->rwstate=SSL_WRITING;
			if (BIO_flush(s->wbio) <= 0)
				{
				/* If the write error was fatal, stop trying */
				if (!BIO_should_retry(s->wbio))
					{
					s->rwstate=SSL_NOTHING;
					s->state=s->s3->tmp.next_state;
					}
				
				ret= -1;
				goto end;
				}
			s->rwstate=SSL_NOTHING;
			s->state=s->s3->tmp.next_state;
			break;

		case SSL3_ST_SR_CERT_A:
		case SSL3_ST_SR_CERT_B:
			if (s->s3->tmp.cert_request)
				{
				ret=ssl3_get_client_certificate(s);
				if (ret <= 0) goto end;
				}
			s->init_num=0;
			s->state=SSL3_ST_SR_KEY_EXCH_A;
			break;

		case SSL3_ST_SR_KEY_EXCH_A:
		case SSL3_ST_SR_KEY_EXCH_B:
			ret=ssl3_get_client_key_exchange(s);
			if (ret <= 0) goto end;
#ifndef OPENSSL_NO_SCTP
			/* Add new shared key for SCTP-Auth,
			 * will be ignored if no SCTP used.
			 */
			snprintf((char *) labelbuffer, sizeof(DTLS1_SCTP_AUTH_LABEL),
			         DTLS1_SCTP_AUTH_LABEL);

			SSL_export_keying_material(s, sctpauthkey,
			                           sizeof(sctpauthkey), labelbuffer,
			                           sizeof(labelbuffer), NULL, 0, 0);

			BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY,
			         sizeof(sctpauthkey), sctpauthkey);
#endif

			s->state=SSL3_ST_SR_CERT_VRFY_A;
			s->init_num=0;

			if (ret == 2)
				{
				/* For the ECDH ciphersuites when
				 * the client sends its ECDH pub key in
				 * a certificate, the CertificateVerify
				 * message is not sent.
				 */
				s->state=SSL3_ST_SR_FINISHED_A;
				s->init_num = 0;
				}
			else if (SSL_USE_SIGALGS(s))
				{
				s->state=SSL3_ST_SR_CERT_VRFY_A;
				s->init_num=0;
				if (!s->session->peer)
					break;
				/* For sigalgs freeze the handshake buffer
				 * at this point and digest cached records.
				 */
				if (!s->s3->handshake_buffer)
					{
					SSLerr(SSL_F_DTLS1_ACCEPT,ERR_R_INTERNAL_ERROR);
					return -1;
					}
				s->s3->flags |= TLS1_FLAGS_KEEP_HANDSHAKE;
				if (!ssl3_digest_cached_records(s))
					return -1;
				}
			else
				{
				s->state=SSL3_ST_SR_CERT_VRFY_A;
				s->init_num=0;

				/* We need to get hashes here so if there is
				 * a client cert, it can be verified */ 
				s->method->ssl3_enc->cert_verify_mac(s,
					NID_md5,
					&(s->s3->tmp.cert_verify_md[0]));
				s->method->ssl3_enc->cert_verify_mac(s,
					NID_sha1,
					&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]));
				}
			break;

		case SSL3_ST_SR_CERT_VRFY_A:
		case SSL3_ST_SR_CERT_VRFY_B:
			/*
			 * This *should* be the first time we enable CCS, but be
			 * extra careful about surrounding code changes. We need
			 * to set this here because we don't know if we're
			 * expecting a CertificateVerify or not.
			 */
			if (!s->s3->change_cipher_spec)
				s->d1->change_cipher_spec_ok = 1;
			/* we should decide if we expected this one */
			ret=ssl3_get_cert_verify(s);
			if (ret <= 0) goto end;
#ifndef OPENSSL_NO_SCTP
			if (BIO_dgram_is_sctp(SSL_get_wbio(s)) &&
			    state == SSL_ST_RENEGOTIATE)
				s->state=DTLS1_SCTP_ST_SR_READ_SOCK;
			else
#endif			
				s->state=SSL3_ST_SR_FINISHED_A;
			s->init_num=0;
			break;

		case SSL3_ST_SR_FINISHED_A:
		case SSL3_ST_SR_FINISHED_B:
			/*
			 * Enable CCS for resumed handshakes.
			 * In a full handshake, we end up here through
			 * SSL3_ST_SR_CERT_VRFY_B, so change_cipher_spec_ok was
			 * already set. Receiving a CCS clears the flag, so make
			 * sure not to re-enable it to ban duplicates.
			 * s->s3->change_cipher_spec is set when a CCS is
			 * processed in d1_pkt.c, and remains set until
			 * the client's Finished message is read.
			 */
			if (!s->s3->change_cipher_spec)
				s->d1->change_cipher_spec_ok = 1;
			ret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,
				SSL3_ST_SR_FINISHED_B);
			if (ret <= 0) goto end;
			dtls1_stop_timer(s);
			if (s->hit)
				s->state=SSL_ST_OK;
#ifndef OPENSSL_NO_TLSEXT
			else if (s->tlsext_ticket_expected)
				s->state=SSL3_ST_SW_SESSION_TICKET_A;
#endif
			else
				s->state=SSL3_ST_SW_CHANGE_A;
			s->init_num=0;
			break;

#ifndef OPENSSL_NO_TLSEXT
		case SSL3_ST_SW_SESSION_TICKET_A:
		case SSL3_ST_SW_SESSION_TICKET_B:
			ret=ssl3_send_newsession_ticket(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_CHANGE_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_CERT_STATUS_A:
		case SSL3_ST_SW_CERT_STATUS_B:
			ret=ssl3_send_cert_status(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_KEY_EXCH_A;
			s->init_num=0;
			break;

#endif

		case SSL3_ST_SW_CHANGE_A:
		case SSL3_ST_SW_CHANGE_B:

			s->session->cipher=s->s3->tmp.new_cipher;
			if (!s->method->ssl3_enc->setup_key_block(s))
				{ ret= -1; goto end; }

			ret=dtls1_send_change_cipher_spec(s,
				SSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);

			if (ret <= 0) goto end;

#ifndef OPENSSL_NO_SCTP
			if (!s->hit)
				{
				/* Change to new shared key of SCTP-Auth,
				 * will be ignored if no SCTP used.
				 */
				BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);
				}
#endif

			s->state=SSL3_ST_SW_FINISHED_A;
			s->init_num=0;

			if (!s->method->ssl3_enc->change_cipher_state(s,
				SSL3_CHANGE_CIPHER_SERVER_WRITE))
				{
				ret= -1;
				goto end;
				}

			dtls1_reset_seq_numbers(s, SSL3_CC_WRITE);
			break;

		case SSL3_ST_SW_FINISHED_A:
		case SSL3_ST_SW_FINISHED_B:
			ret=ssl3_send_finished(s,
				SSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,
				s->method->ssl3_enc->server_finished_label,
				s->method->ssl3_enc->server_finished_label_len);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_FLUSH;
			if (s->hit)
				{
				s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;

#ifndef OPENSSL_NO_SCTP
				/* Change to new shared key of SCTP-Auth,
				 * will be ignored if no SCTP used.
				 */
				BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);
#endif
				}
			else
				{
				s->s3->tmp.next_state=SSL_ST_OK;
#ifndef OPENSSL_NO_SCTP
				if (BIO_dgram_is_sctp(SSL_get_wbio(s)))
					{
					s->d1->next_state = s->s3->tmp.next_state;
					s->s3->tmp.next_state=DTLS1_SCTP_ST_SW_WRITE_SOCK;
					}
#endif
				}
			s->init_num=0;
			break;

		case SSL_ST_OK:
			/* clean a few things up */
			ssl3_cleanup_key_block(s);

#if 0
			BUF_MEM_free(s->init_buf);
			s->init_buf=NULL;
#endif

			/* remove buffering on output */
			ssl_free_wbio_buffer(s);

			s->init_num=0;

			if (s->renegotiate == 2) /* skipped if we just sent a HelloRequest */
				{
				s->renegotiate=0;
				s->new_session=0;
				
				ssl_update_cache(s,SSL_SESS_CACHE_SERVER);
				
				s->ctx->stats.sess_accept_good++;
				/* s->server=1; */
				s->handshake_func=dtls1_accept;

				if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);
				}
			
			ret = 1;

			/* done handshaking, next message is client hello */
			s->d1->handshake_read_seq = 0;
			/* next message is server hello */
			s->d1->handshake_write_seq = 0;
			s->d1->next_handshake_write_seq = 0;
			goto end;
			/* break; */

		default:
			SSLerr(SSL_F_DTLS1_ACCEPT,SSL_R_UNKNOWN_STATE);
			ret= -1;
			goto end;
			/* break; */
			}
		
		if (!s->s3->tmp.reuse_message && !skip)
			{
			if (s->debug)
				{
				if ((ret=BIO_flush(s->wbio)) <= 0)
					goto end;
				}


			if ((cb != NULL) && (s->state != state))
				{
				new_state=s->state;
				s->state=state;
				cb(s,SSL_CB_ACCEPT_LOOP,1);
				s->state=new_state;
				}
			}
		skip=0;
		}
"
2188,179924,,Remote,Not required,,CVE-2015-0204,https://www.cvedetails.com/cve/CVE-2015-0204/,CWE-310,Medium,,Partial,,2015-01-08,4.3,"The ssl3_get_key_exchange function in s3_clnt.c in OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k allows remote SSL servers to conduct RSA-to-EXPORT_RSA downgrade attacks and facilitate brute-force decryption by offering a weak ephemeral RSA key in a noncompliant role, related to the *FREAK* issue.  NOTE: the scope of this CVE is only client code based on OpenSSL, not EXPORT_RSA issues associated with servers or other TLS implementations.",2018-07-18,,7,https://github.com/openssl/openssl/commit/ce325c60c74b0fa784f5872404b722e120e5cab0,ce325c60c74b0fa784f5872404b722e120e5cab0,"Only allow ephemeral RSA keys in export ciphersuites.

OpenSSL clients would tolerate temporary RSA keys in non-export
ciphersuites. It also had an option SSL_OP_EPHEMERAL_RSA which
enabled this server side. Remove both options as they are a
protocol violation.

Thanks to Karthikeyan Bhargavan for reporting this issue.
(CVE-2015-0204)
Reviewed-by: Matt Caswell <matt@openssl.org>",0,ssl/s3_clnt.c,"{""sha"": ""c9c19c3ae3866f62c66803160e8870ebe6c720ef"", ""filename"": ""CHANGES"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/openssl/openssl/blob/ce325c60c74b0fa784f5872404b722e120e5cab0/CHANGES"", ""raw_url"": ""https://github.com/openssl/openssl/raw/ce325c60c74b0fa784f5872404b722e120e5cab0/CHANGES"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/CHANGES?ref=ce325c60c74b0fa784f5872404b722e120e5cab0"", ""patch"": ""@@ -666,6 +666,14 @@\n      (CVE-2014-3572)\n      [Steve Henson]\n \n+  *) Remove non-export ephemeral RSA code on client and server. This code\n+     violated the TLS standard by allowing the use of temporary RSA keys in\n+     non-export ciphersuites and could be used by a server to effectively\n+     downgrade the RSA key length used to a value smaller than the server\n+     certificate. Thanks for Karthikeyan Bhargavan for reporting this issue.\n+     (CVE-2015-0204)\n+     [Steve Henson]\n+\n   *) Ensure that the session ID context of an SSL is updated when its\n      SSL_CTX is updated via SSL_set_SSL_CTX.\n ""}<_**next**_>{""sha"": ""593435c493eaf609a04d4c180ac3fce1600be3a1"", ""filename"": ""doc/ssl/SSL_CTX_set_options.pod"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 9, ""changes"": 10, ""blob_url"": ""https://github.com/openssl/openssl/blob/ce325c60c74b0fa784f5872404b722e120e5cab0/doc/ssl/SSL_CTX_set_options.pod"", ""raw_url"": ""https://github.com/openssl/openssl/raw/ce325c60c74b0fa784f5872404b722e120e5cab0/doc/ssl/SSL_CTX_set_options.pod"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/doc/ssl/SSL_CTX_set_options.pod?ref=ce325c60c74b0fa784f5872404b722e120e5cab0"", ""patch"": ""@@ -151,15 +151,7 @@ temporary/ephemeral DH parameters are used.\n \n =item SSL_OP_EPHEMERAL_RSA\n \n-Always use ephemeral (temporary) RSA key when doing RSA operations\n-(see L<SSL_CTX_set_tmp_rsa_callback(3)|SSL_CTX_set_tmp_rsa_callback(3)>).\n-According to the specifications this is only done, when a RSA key\n-can only be used for signature operations (namely under export ciphers\n-with restricted RSA keylength). By setting this option, ephemeral\n-RSA keys are always used. This option breaks compatibility with the\n-SSL/TLS specifications and may lead to interoperability problems with\n-clients and should therefore never be used. Ciphers with DHE (ephemeral\n-Diffie-Hellman) key exchange should be used instead.\n+This option is no longer implemented and is treated as no op.\n \n =item SSL_OP_CIPHER_SERVER_PREFERENCE\n ""}<_**next**_>{""sha"": ""94c55b8045359f3122c324ca031e8350ef68b12c"", ""filename"": ""doc/ssl/SSL_CTX_set_tmp_rsa_callback.pod"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 15, ""changes"": 23, ""blob_url"": ""https://github.com/openssl/openssl/blob/ce325c60c74b0fa784f5872404b722e120e5cab0/doc/ssl/SSL_CTX_set_tmp_rsa_callback.pod"", ""raw_url"": ""https://github.com/openssl/openssl/raw/ce325c60c74b0fa784f5872404b722e120e5cab0/doc/ssl/SSL_CTX_set_tmp_rsa_callback.pod"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/doc/ssl/SSL_CTX_set_tmp_rsa_callback.pod?ref=ce325c60c74b0fa784f5872404b722e120e5cab0"", ""patch"": ""@@ -74,21 +74,14 @@ exchange and use DHE (Ephemeral Diffie-Hellman) key exchange instead\n in order to achieve forward secrecy (see\n L<SSL_CTX_set_tmp_dh_callback(3)|SSL_CTX_set_tmp_dh_callback(3)>).\n \n-On OpenSSL servers ephemeral RSA key exchange is therefore disabled by default\n-and must be explicitly enabled  using the SSL_OP_EPHEMERAL_RSA option of\n-L<SSL_CTX_set_options(3)|SSL_CTX_set_options(3)>, violating the TLS/SSL\n-standard. When ephemeral RSA key exchange is required for export ciphers,\n-it will automatically be used without this option!\n-\n-An application may either directly specify the key or can supply the key via\n-a callback function. The callback approach has the advantage, that the\n-callback may generate the key only in case it is actually needed. As the\n-generation of a RSA key is however costly, it will lead to a significant\n-delay in the handshake procedure.  Another advantage of the callback function\n-is that it can supply keys of different size (e.g. for SSL_OP_EPHEMERAL_RSA\n-usage) while the explicit setting of the key is only useful for key size of\n-512 bits to satisfy the export restricted ciphers and does give away key length\n-if a longer key would be allowed.\n+An application may either directly specify the key or can supply the key via a\n+callback function. The callback approach has the advantage, that the callback\n+may generate the key only in case it is actually needed. As the generation of a\n+RSA key is however costly, it will lead to a significant delay in the handshake\n+procedure.  Another advantage of the callback function is that it can supply\n+keys of different size while the explicit setting of the key is only useful for\n+key size of 512 bits to satisfy the export restricted ciphers and does give\n+away key length if a longer key would be allowed.\n \n The B<tmp_rsa_callback> is called with the B<keylength> needed and\n the B<is_export> information. The B<is_export> flag is set, when the""}<_**next**_>{""sha"": ""8a5c5a1cd2204884685cf81c6c1ad57a4a65f761"", ""filename"": ""ssl/d1_srvr.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 15, ""changes"": 21, ""blob_url"": ""https://github.com/openssl/openssl/blob/ce325c60c74b0fa784f5872404b722e120e5cab0/ssl/d1_srvr.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/ce325c60c74b0fa784f5872404b722e120e5cab0/ssl/d1_srvr.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/ssl/d1_srvr.c?ref=ce325c60c74b0fa784f5872404b722e120e5cab0"", ""patch"": ""@@ -472,24 +472,15 @@ int dtls1_accept(SSL *s)\n \t\tcase SSL3_ST_SW_KEY_EXCH_B:\n \t\t\talg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n \n-\t\t\t/* clear this, it may get reset by\n-\t\t\t * send_server_key_exchange */\n-\t\t\tif ((s->options & SSL_OP_EPHEMERAL_RSA)\n-#ifndef OPENSSL_NO_KRB5\n-\t\t\t\t&& !(alg_k & SSL_kKRB5)\n-#endif /* OPENSSL_NO_KRB5 */\n-\t\t\t\t)\n-\t\t\t\t/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key\n-\t\t\t\t * even when forbidden by protocol specs\n-\t\t\t\t * (handshake may fail as clients are not required to\n-\t\t\t\t * be able to handle this) */\n-\t\t\t\ts->s3->tmp.use_rsa_tmp=1;\n-\t\t\telse\n-\t\t\t\ts->s3->tmp.use_rsa_tmp=0;\n+\t\t\t/*\n+\t\t\t * clear this, it may get reset by\n+\t\t\t * send_server_key_exchange\n+\t\t\t */\n+\t\t\ts->s3->tmp.use_rsa_tmp=0;\n \n \t\t\t/* only send if a DH key exchange or\n \t\t\t * RSA but we have a sign only certificate */\n-\t\t\tif (s->s3->tmp.use_rsa_tmp\n+\t\t\tif (\n \t\t\t/* PSK: send ServerKeyExchange if PSK identity\n \t\t\t * hint if provided */\n #ifndef OPENSSL_NO_PSK""}<_**next**_>{""sha"": ""aa9dcbb5b3aa1e05794adaaa1ad1a95f76a250ff"", ""filename"": ""ssl/s3_clnt.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/openssl/openssl/blob/ce325c60c74b0fa784f5872404b722e120e5cab0/ssl/s3_clnt.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/ce325c60c74b0fa784f5872404b722e120e5cab0/ssl/s3_clnt.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/ssl/s3_clnt.c?ref=ce325c60c74b0fa784f5872404b722e120e5cab0"", ""patch"": ""@@ -1636,6 +1636,13 @@ int ssl3_get_key_exchange(SSL *s)\n #ifndef OPENSSL_NO_RSA\n \tif (alg_k & SSL_kRSA)\n \t\t{\n+\t\t/* Temporary RSA keys only allowed in export ciphersuites */\n+\t\tif (!SSL_C_IS_EXPORT(s->s3->tmp.new_cipher))\n+\t\t\t{\n+\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n+\t\t\tSSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_UNEXPECTED_MESSAGE);\n+\t\t\tgoto f_err;\n+\t\t\t}\n \t\tif ((rsa=RSA_new()) == NULL)\n \t\t\t{\n \t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);""}<_**next**_>{""sha"": ""e5a32ee90f382dfeb75813ad3fd61def9f801a37"", ""filename"": ""ssl/s3_srvr.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 15, ""changes"": 21, ""blob_url"": ""https://github.com/openssl/openssl/blob/ce325c60c74b0fa784f5872404b722e120e5cab0/ssl/s3_srvr.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/ce325c60c74b0fa784f5872404b722e120e5cab0/ssl/s3_srvr.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/ssl/s3_srvr.c?ref=ce325c60c74b0fa784f5872404b722e120e5cab0"", ""patch"": ""@@ -453,20 +453,11 @@ int ssl3_accept(SSL *s)\n \t\tcase SSL3_ST_SW_KEY_EXCH_B:\n \t\t\talg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n \n-\t\t\t/* clear this, it may get reset by\n-\t\t\t * send_server_key_exchange */\n-\t\t\tif ((s->options & SSL_OP_EPHEMERAL_RSA)\n-#ifndef OPENSSL_NO_KRB5\n-\t\t\t\t&& !(alg_k & SSL_kKRB5)\n-#endif /* OPENSSL_NO_KRB5 */\n-\t\t\t\t)\n-\t\t\t\t/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key\n-\t\t\t\t * even when forbidden by protocol specs\n-\t\t\t\t * (handshake may fail as clients are not required to\n-\t\t\t\t * be able to handle this) */\n-\t\t\t\ts->s3->tmp.use_rsa_tmp=1;\n-\t\t\telse\n-\t\t\t\ts->s3->tmp.use_rsa_tmp=0;\n+\t\t\t/*\n+\t\t\t * clear this, it may get reset by\n+\t\t\t * send_server_key_exchange\n+\t\t\t */\n+\t\t\ts->s3->tmp.use_rsa_tmp=0;\n \n \n \t\t\t/* only send if a DH key exchange, fortezza or\n@@ -480,7 +471,7 @@ int ssl3_accept(SSL *s)\n \t\t\t * server certificate contains the server's\n \t\t\t * public key for key exchange.\n \t\t\t */\n-\t\t\tif (s->s3->tmp.use_rsa_tmp\n+\t\t\tif (\n \t\t\t/* PSK: send ServerKeyExchange if PSK identity\n \t\t\t * hint if provided */\n #ifndef OPENSSL_NO_PSK""}<_**next**_>{""sha"": ""98661d0ab89d2d334c656fcabcf847f8b84d2fb9"", ""filename"": ""ssl/ssl.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 3, ""changes"": 5, ""blob_url"": ""https://github.com/openssl/openssl/blob/ce325c60c74b0fa784f5872404b722e120e5cab0/ssl/ssl.h"", ""raw_url"": ""https://github.com/openssl/openssl/raw/ce325c60c74b0fa784f5872404b722e120e5cab0/ssl/ssl.h"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/ssl/ssl.h?ref=ce325c60c74b0fa784f5872404b722e120e5cab0"", ""patch"": ""@@ -606,9 +606,8 @@ struct ssl_session_st\n #define SSL_OP_SINGLE_ECDH_USE\t\t\t\t0x00080000L\n /* If set, always create a new key when using tmp_dh parameters */\n #define SSL_OP_SINGLE_DH_USE\t\t\t\t0x00100000L\n-/* Set to always use the tmp_rsa key when doing RSA operations,\n- * even when this violates protocol specs */\n-#define SSL_OP_EPHEMERAL_RSA\t\t\t\t0x00200000L\n+/* Does nothing: retained for compatibiity */\n+#define SSL_OP_EPHEMERAL_RSA\t\t\t\t0x0\n /* Set on servers to choose the cipher according to the server's\n  * preferences */\n #define SSL_OP_CIPHER_SERVER_PREFERENCE\t\t\t0x00400000L""}","int ssl3_get_key_exchange(SSL *s)
	{
#ifndef OPENSSL_NO_RSA
	unsigned char *q,md_buf[EVP_MAX_MD_SIZE*2];
#endif
	EVP_MD_CTX md_ctx;
	unsigned char *param,*p;
	int al,j,ok;
	long i,param_len,n,alg_k,alg_a;
	EVP_PKEY *pkey=NULL;
	const EVP_MD *md = NULL;
#ifndef OPENSSL_NO_RSA
	RSA *rsa=NULL;
#endif
#ifndef OPENSSL_NO_DH
	DH *dh=NULL;
#endif
#ifndef OPENSSL_NO_ECDH
	EC_KEY *ecdh = NULL;
	BN_CTX *bn_ctx = NULL;
	EC_POINT *srvr_ecpoint = NULL;
	int curve_nid = 0;
	int encoded_pt_len = 0;
#endif

	EVP_MD_CTX_init(&md_ctx);

	/* use same message size as in ssl3_get_certificate_request()
	 * as ServerKeyExchange message may be skipped */
	n=s->method->ssl_get_message(s,
		SSL3_ST_CR_KEY_EXCH_A,
		SSL3_ST_CR_KEY_EXCH_B,
		-1,
		s->max_cert_list,
		&ok);
	if (!ok) return((int)n);

	alg_k=s->s3->tmp.new_cipher->algorithm_mkey;

	if (s->s3->tmp.message_type != SSL3_MT_SERVER_KEY_EXCHANGE)
		{
		/*
		 * Can't skip server key exchange if this is an ephemeral
		 * ciphersuite.
		 */
		if (alg_k & (SSL_kDHE|SSL_kECDHE))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);
			al = SSL_AD_UNEXPECTED_MESSAGE;
			goto f_err;
			}
#ifndef OPENSSL_NO_PSK
		/* In plain PSK ciphersuite, ServerKeyExchange can be
		   omitted if no identity hint is sent. Set
		   session->sess_cert anyway to avoid problems
		   later.*/
		if (alg_k & SSL_kPSK)
			{
			s->session->sess_cert=ssl_sess_cert_new();
			if (s->ctx->psk_identity_hint)
				OPENSSL_free(s->ctx->psk_identity_hint);
			s->ctx->psk_identity_hint = NULL;
			}
#endif
		s->s3->tmp.reuse_message=1;
		return(1);
		}

	param=p=(unsigned char *)s->init_msg;
	if (s->session->sess_cert != NULL)
		{
#ifndef OPENSSL_NO_RSA
		if (s->session->sess_cert->peer_rsa_tmp != NULL)
			{
			RSA_free(s->session->sess_cert->peer_rsa_tmp);
			s->session->sess_cert->peer_rsa_tmp=NULL;
			}
#endif
#ifndef OPENSSL_NO_DH
		if (s->session->sess_cert->peer_dh_tmp)
			{
			DH_free(s->session->sess_cert->peer_dh_tmp);
			s->session->sess_cert->peer_dh_tmp=NULL;
			}
#endif
#ifndef OPENSSL_NO_ECDH
		if (s->session->sess_cert->peer_ecdh_tmp)
			{
			EC_KEY_free(s->session->sess_cert->peer_ecdh_tmp);
			s->session->sess_cert->peer_ecdh_tmp=NULL;
			}
#endif
		}
	else
		{
		s->session->sess_cert=ssl_sess_cert_new();
		}

	/* Total length of the parameters including the length prefix */
	param_len=0;

	alg_a=s->s3->tmp.new_cipher->algorithm_auth;

	al=SSL_AD_DECODE_ERROR;

#ifndef OPENSSL_NO_PSK
	if (alg_k & SSL_kPSK)
		{
		char tmp_id_hint[PSK_MAX_IDENTITY_LEN+1];

		param_len = 2;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);

		/* Store PSK identity hint for later use, hint is used
		 * in ssl3_send_client_key_exchange.  Assume that the
		 * maximum length of a PSK identity hint can be as
		 * long as the maximum length of a PSK identity. */
		if (i > PSK_MAX_IDENTITY_LEN)
			{
			al=SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_DATA_LENGTH_TOO_LONG);
			goto f_err;
			}
		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_BAD_PSK_IDENTITY_HINT_LENGTH);
			goto f_err;
			}
		param_len += i;

		/* If received PSK identity hint contains NULL
		 * characters, the hint is truncated from the first
		 * NULL. p may not be ending with NULL, so create a
		 * NULL-terminated string. */
		memcpy(tmp_id_hint, p, i);
		memset(tmp_id_hint+i, 0, PSK_MAX_IDENTITY_LEN+1-i);
		if (s->ctx->psk_identity_hint != NULL)
			OPENSSL_free(s->ctx->psk_identity_hint);
		s->ctx->psk_identity_hint = BUF_strdup(tmp_id_hint);
		if (s->ctx->psk_identity_hint == NULL)
			{
			al=SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);
			goto f_err;
			}	   

		p+=i;
		n-=param_len;
		}
	else
#endif /* !OPENSSL_NO_PSK */
#ifndef OPENSSL_NO_SRP
	if (alg_k & SSL_kSRP)
		{
		param_len = 2;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_N_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(s->srp_ctx.N=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;


		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_G_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(s->srp_ctx.g=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;


		if (1 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 1;

		i = (unsigned int)(p[0]);
		p++;

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_S_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(s->srp_ctx.s=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_B_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(s->srp_ctx.B=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;
		n-=param_len;

		if (!srp_verify_server_param(s, &al))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_PARAMETERS);
			goto f_err;
			}

/* We must check if there is a certificate */
#ifndef OPENSSL_NO_RSA
		if (alg_a & SSL_aRSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
#else
		if (0)
			;
#endif
#ifndef OPENSSL_NO_DSA
		else if (alg_a & SSL_aDSS)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);
#endif
		}
	else
#endif /* !OPENSSL_NO_SRP */
 #ifndef OPENSSL_NO_RSA
 	if (alg_k & SSL_kRSA)
 		{
		/* Temporary RSA keys only allowed in export ciphersuites */
		if (!SSL_C_IS_EXPORT(s->s3->tmp.new_cipher))
			{
			al=SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_UNEXPECTED_MESSAGE);
			goto f_err;
			}
 		if ((rsa=RSA_new()) == NULL)
 			{
 			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
			goto err;
			}

		param_len = 2;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_MODULUS_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(rsa->n=BN_bin2bn(p,i,rsa->n)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_E_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(rsa->e=BN_bin2bn(p,i,rsa->e)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;
		n-=param_len;

		/* this should be because we are using an export cipher */
		if (alg_a & SSL_aRSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
		else
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
			goto err;
			}
		s->session->sess_cert->peer_rsa_tmp=rsa;
		rsa=NULL;
		}
#else /* OPENSSL_NO_RSA */
	if (0)
		;
#endif
#ifndef OPENSSL_NO_DH
	else if (alg_k & SSL_kDHE)
		{
		if ((dh=DH_new()) == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_DH_LIB);
			goto err;
			}

		param_len = 2;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_P_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(dh->p=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_G_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(dh->g=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_PUB_KEY_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(dh->pub_key=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;
		n-=param_len;

		if (!ssl_security(s, SSL_SECOP_TMP_DH,
						DH_security_bits(dh), 0, dh))
			{
			al=SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_DH_KEY_TOO_SMALL);
			goto f_err;
			}

#ifndef OPENSSL_NO_RSA
		if (alg_a & SSL_aRSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
#else
		if (0)
			;
#endif
#ifndef OPENSSL_NO_DSA
		else if (alg_a & SSL_aDSS)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);
#endif
		/* else anonymous DH, so no certificate or pkey. */

		s->session->sess_cert->peer_dh_tmp=dh;
		dh=NULL;
		}
	else if ((alg_k & SSL_kDHr) || (alg_k & SSL_kDHd))
		{
		al=SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);
		goto f_err;
		}
#endif /* !OPENSSL_NO_DH */

#ifndef OPENSSL_NO_ECDH
	else if (alg_k & SSL_kECDHE)
		{
		EC_GROUP *ngroup;
		const EC_GROUP *group;

		if ((ecdh=EC_KEY_new()) == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
			goto err;
			}

		/* Extract elliptic curve parameters and the
		 * server's ephemeral ECDH public key.
		 * Keep accumulating lengths of various components in
		 * param_len and make sure it never exceeds n.
		 */

		/* XXX: For now we only support named (not generic) curves
		 * and the ECParameters in this case is just three bytes. We
		 * also need one byte for the length of the encoded point
		 */
		param_len=4;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		/* Check curve is one of our preferences, if not server has
		 * sent an invalid curve. ECParameters is 3 bytes.
		 */
		if (!tls1_check_curve(s, p, 3))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_CURVE);
			goto f_err;
			}

		if ((curve_nid = tls1_ec_curve_id2nid(*(p + 2))) == 0) 
			{
			al=SSL_AD_INTERNAL_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);
			goto f_err;
			}

		ngroup = EC_GROUP_new_by_curve_name(curve_nid);
		if (ngroup == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);
			goto err;
			}
		if (EC_KEY_set_group(ecdh, ngroup) == 0)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);
			goto err;
			}
		EC_GROUP_free(ngroup);

		group = EC_KEY_get0_group(ecdh);

		if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&
		    (EC_GROUP_get_degree(group) > 163))
			{
			al=SSL_AD_EXPORT_RESTRICTION;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);
			goto f_err;
			}

		p+=3;

		/* Next, get the encoded ECPoint */
		if (((srvr_ecpoint = EC_POINT_new(group)) == NULL) ||
		    ((bn_ctx = BN_CTX_new()) == NULL))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
			goto err;
			}

		encoded_pt_len = *p;  /* length of encoded point */
		p+=1;

		if ((encoded_pt_len > n - param_len) ||
		    (EC_POINT_oct2point(group, srvr_ecpoint, 
			p, encoded_pt_len, bn_ctx) == 0))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_ECPOINT);
			goto f_err;
			}
		param_len += encoded_pt_len;

		n-=param_len;
		p+=encoded_pt_len;

		/* The ECC/TLS specification does not mention
		 * the use of DSA to sign ECParameters in the server
		 * key exchange message. We do support RSA and ECDSA.
		 */
		if (0) ;
#ifndef OPENSSL_NO_RSA
		else if (alg_a & SSL_aRSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
#endif
#ifndef OPENSSL_NO_ECDSA
		else if (alg_a & SSL_aECDSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);
#endif
		/* else anonymous ECDH, so no certificate or pkey. */
		EC_KEY_set_public_key(ecdh, srvr_ecpoint);
		s->session->sess_cert->peer_ecdh_tmp=ecdh;
		ecdh=NULL;
		BN_CTX_free(bn_ctx);
		bn_ctx = NULL;
		EC_POINT_free(srvr_ecpoint);
		srvr_ecpoint = NULL;
		}
	else if (alg_k)
		{
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);
		goto f_err;
		}
#endif /* !OPENSSL_NO_ECDH */


	/* p points to the next byte, there are 'n' bytes left */

	/* if it was signed, check the signature */
	if (pkey != NULL)
		{
		if (SSL_USE_SIGALGS(s))
			{
			int rv;
			if (2 > n)
				{
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
					SSL_R_LENGTH_TOO_SHORT);
				goto f_err;
				}
			rv = tls12_check_peer_sigalg(&md, s, p, pkey);
			if (rv == -1)
				goto err;
			else if (rv == 0)
				{
				goto f_err;
				}
#ifdef SSL_DEBUG
fprintf(stderr, ""USING TLSv1.2 HASH %s\n"", EVP_MD_name(md));
#endif
			p += 2;
			n -= 2;
			}
		else
			md = EVP_sha1();

		if (2 > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);
		n-=2;
		j=EVP_PKEY_size(pkey);

		/* Check signature length. If n is 0 then signature is empty */
		if ((i != n) || (n > j) || (n <= 0))
			{
			/* wrong packet length */
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_SIGNATURE_LENGTH);
			goto f_err;
			}

#ifndef OPENSSL_NO_RSA
		if (pkey->type == EVP_PKEY_RSA && !SSL_USE_SIGALGS(s))
			{
			int num;
			unsigned int size;

			j=0;
			q=md_buf;
			for (num=2; num > 0; num--)
				{
				EVP_MD_CTX_set_flags(&md_ctx,
					EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
				EVP_DigestInit_ex(&md_ctx,(num == 2)
					?s->ctx->md5:s->ctx->sha1, NULL);
				EVP_DigestUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
				EVP_DigestUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
				EVP_DigestUpdate(&md_ctx,param,param_len);
				EVP_DigestFinal_ex(&md_ctx,q,&size);
				q+=size;
				j+=size;
				}
			i=RSA_verify(NID_md5_sha1, md_buf, j, p, n,
								pkey->pkey.rsa);
			if (i < 0)
				{
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_DECRYPT);
				goto f_err;
				}
			if (i == 0)
				{
				/* bad signature */
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);
				goto f_err;
				}
			}
		else
#endif
			{
			EVP_VerifyInit_ex(&md_ctx, md, NULL);
			EVP_VerifyUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
			EVP_VerifyUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
			EVP_VerifyUpdate(&md_ctx,param,param_len);
			if (EVP_VerifyFinal(&md_ctx,p,(int)n,pkey) <= 0)
				{
				/* bad signature */
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);
				goto f_err;
				}
			}
		}
	else
		{
		/* aNULL, aSRP or kPSK do not need public keys */
		if (!(alg_a & (SSL_aNULL|SSL_aSRP)) && !(alg_k & SSL_kPSK))
			{
			/* Might be wrong key type, check it */
			if (ssl3_check_cert_and_algorithm(s))
				/* Otherwise this shouldn't happen */
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
			goto err;
			}
		/* still data left over */
		if (n != 0)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_EXTRA_DATA_IN_MESSAGE);
			goto f_err;
			}
		}
	EVP_PKEY_free(pkey);
	EVP_MD_CTX_cleanup(&md_ctx);
	return(1);
f_err:
	ssl3_send_alert(s,SSL3_AL_FATAL,al);
err:
	EVP_PKEY_free(pkey);
#ifndef OPENSSL_NO_RSA
	if (rsa != NULL)
		RSA_free(rsa);
#endif
#ifndef OPENSSL_NO_DH
	if (dh != NULL)
		DH_free(dh);
#endif
#ifndef OPENSSL_NO_ECDH
	BN_CTX_free(bn_ctx);
	EC_POINT_free(srvr_ecpoint);
	if (ecdh != NULL)
		EC_KEY_free(ecdh);
#endif
	EVP_MD_CTX_cleanup(&md_ctx);
	return(-1);
	}
","int ssl3_get_key_exchange(SSL *s)
	{
#ifndef OPENSSL_NO_RSA
	unsigned char *q,md_buf[EVP_MAX_MD_SIZE*2];
#endif
	EVP_MD_CTX md_ctx;
	unsigned char *param,*p;
	int al,j,ok;
	long i,param_len,n,alg_k,alg_a;
	EVP_PKEY *pkey=NULL;
	const EVP_MD *md = NULL;
#ifndef OPENSSL_NO_RSA
	RSA *rsa=NULL;
#endif
#ifndef OPENSSL_NO_DH
	DH *dh=NULL;
#endif
#ifndef OPENSSL_NO_ECDH
	EC_KEY *ecdh = NULL;
	BN_CTX *bn_ctx = NULL;
	EC_POINT *srvr_ecpoint = NULL;
	int curve_nid = 0;
	int encoded_pt_len = 0;
#endif

	EVP_MD_CTX_init(&md_ctx);

	/* use same message size as in ssl3_get_certificate_request()
	 * as ServerKeyExchange message may be skipped */
	n=s->method->ssl_get_message(s,
		SSL3_ST_CR_KEY_EXCH_A,
		SSL3_ST_CR_KEY_EXCH_B,
		-1,
		s->max_cert_list,
		&ok);
	if (!ok) return((int)n);

	alg_k=s->s3->tmp.new_cipher->algorithm_mkey;

	if (s->s3->tmp.message_type != SSL3_MT_SERVER_KEY_EXCHANGE)
		{
		/*
		 * Can't skip server key exchange if this is an ephemeral
		 * ciphersuite.
		 */
		if (alg_k & (SSL_kDHE|SSL_kECDHE))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);
			al = SSL_AD_UNEXPECTED_MESSAGE;
			goto f_err;
			}
#ifndef OPENSSL_NO_PSK
		/* In plain PSK ciphersuite, ServerKeyExchange can be
		   omitted if no identity hint is sent. Set
		   session->sess_cert anyway to avoid problems
		   later.*/
		if (alg_k & SSL_kPSK)
			{
			s->session->sess_cert=ssl_sess_cert_new();
			if (s->ctx->psk_identity_hint)
				OPENSSL_free(s->ctx->psk_identity_hint);
			s->ctx->psk_identity_hint = NULL;
			}
#endif
		s->s3->tmp.reuse_message=1;
		return(1);
		}

	param=p=(unsigned char *)s->init_msg;
	if (s->session->sess_cert != NULL)
		{
#ifndef OPENSSL_NO_RSA
		if (s->session->sess_cert->peer_rsa_tmp != NULL)
			{
			RSA_free(s->session->sess_cert->peer_rsa_tmp);
			s->session->sess_cert->peer_rsa_tmp=NULL;
			}
#endif
#ifndef OPENSSL_NO_DH
		if (s->session->sess_cert->peer_dh_tmp)
			{
			DH_free(s->session->sess_cert->peer_dh_tmp);
			s->session->sess_cert->peer_dh_tmp=NULL;
			}
#endif
#ifndef OPENSSL_NO_ECDH
		if (s->session->sess_cert->peer_ecdh_tmp)
			{
			EC_KEY_free(s->session->sess_cert->peer_ecdh_tmp);
			s->session->sess_cert->peer_ecdh_tmp=NULL;
			}
#endif
		}
	else
		{
		s->session->sess_cert=ssl_sess_cert_new();
		}

	/* Total length of the parameters including the length prefix */
	param_len=0;

	alg_a=s->s3->tmp.new_cipher->algorithm_auth;

	al=SSL_AD_DECODE_ERROR;

#ifndef OPENSSL_NO_PSK
	if (alg_k & SSL_kPSK)
		{
		char tmp_id_hint[PSK_MAX_IDENTITY_LEN+1];

		param_len = 2;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);

		/* Store PSK identity hint for later use, hint is used
		 * in ssl3_send_client_key_exchange.  Assume that the
		 * maximum length of a PSK identity hint can be as
		 * long as the maximum length of a PSK identity. */
		if (i > PSK_MAX_IDENTITY_LEN)
			{
			al=SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_DATA_LENGTH_TOO_LONG);
			goto f_err;
			}
		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_BAD_PSK_IDENTITY_HINT_LENGTH);
			goto f_err;
			}
		param_len += i;

		/* If received PSK identity hint contains NULL
		 * characters, the hint is truncated from the first
		 * NULL. p may not be ending with NULL, so create a
		 * NULL-terminated string. */
		memcpy(tmp_id_hint, p, i);
		memset(tmp_id_hint+i, 0, PSK_MAX_IDENTITY_LEN+1-i);
		if (s->ctx->psk_identity_hint != NULL)
			OPENSSL_free(s->ctx->psk_identity_hint);
		s->ctx->psk_identity_hint = BUF_strdup(tmp_id_hint);
		if (s->ctx->psk_identity_hint == NULL)
			{
			al=SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);
			goto f_err;
			}	   

		p+=i;
		n-=param_len;
		}
	else
#endif /* !OPENSSL_NO_PSK */
#ifndef OPENSSL_NO_SRP
	if (alg_k & SSL_kSRP)
		{
		param_len = 2;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_N_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(s->srp_ctx.N=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;


		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_G_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(s->srp_ctx.g=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;


		if (1 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 1;

		i = (unsigned int)(p[0]);
		p++;

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_S_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(s->srp_ctx.s=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_B_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(s->srp_ctx.B=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;
		n-=param_len;

		if (!srp_verify_server_param(s, &al))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_PARAMETERS);
			goto f_err;
			}

/* We must check if there is a certificate */
#ifndef OPENSSL_NO_RSA
		if (alg_a & SSL_aRSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
#else
		if (0)
			;
#endif
#ifndef OPENSSL_NO_DSA
		else if (alg_a & SSL_aDSS)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);
#endif
		}
	else
#endif /* !OPENSSL_NO_SRP */
 #ifndef OPENSSL_NO_RSA
 	if (alg_k & SSL_kRSA)
 		{
 		if ((rsa=RSA_new()) == NULL)
 			{
 			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
			goto err;
			}

		param_len = 2;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_MODULUS_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(rsa->n=BN_bin2bn(p,i,rsa->n)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_E_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(rsa->e=BN_bin2bn(p,i,rsa->e)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;
		n-=param_len;

		/* this should be because we are using an export cipher */
		if (alg_a & SSL_aRSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
		else
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
			goto err;
			}
		s->session->sess_cert->peer_rsa_tmp=rsa;
		rsa=NULL;
		}
#else /* OPENSSL_NO_RSA */
	if (0)
		;
#endif
#ifndef OPENSSL_NO_DH
	else if (alg_k & SSL_kDHE)
		{
		if ((dh=DH_new()) == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_DH_LIB);
			goto err;
			}

		param_len = 2;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_P_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(dh->p=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_G_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(dh->g=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_PUB_KEY_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(dh->pub_key=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;
		n-=param_len;

		if (!ssl_security(s, SSL_SECOP_TMP_DH,
						DH_security_bits(dh), 0, dh))
			{
			al=SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_DH_KEY_TOO_SMALL);
			goto f_err;
			}

#ifndef OPENSSL_NO_RSA
		if (alg_a & SSL_aRSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
#else
		if (0)
			;
#endif
#ifndef OPENSSL_NO_DSA
		else if (alg_a & SSL_aDSS)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);
#endif
		/* else anonymous DH, so no certificate or pkey. */

		s->session->sess_cert->peer_dh_tmp=dh;
		dh=NULL;
		}
	else if ((alg_k & SSL_kDHr) || (alg_k & SSL_kDHd))
		{
		al=SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);
		goto f_err;
		}
#endif /* !OPENSSL_NO_DH */

#ifndef OPENSSL_NO_ECDH
	else if (alg_k & SSL_kECDHE)
		{
		EC_GROUP *ngroup;
		const EC_GROUP *group;

		if ((ecdh=EC_KEY_new()) == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
			goto err;
			}

		/* Extract elliptic curve parameters and the
		 * server's ephemeral ECDH public key.
		 * Keep accumulating lengths of various components in
		 * param_len and make sure it never exceeds n.
		 */

		/* XXX: For now we only support named (not generic) curves
		 * and the ECParameters in this case is just three bytes. We
		 * also need one byte for the length of the encoded point
		 */
		param_len=4;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		/* Check curve is one of our preferences, if not server has
		 * sent an invalid curve. ECParameters is 3 bytes.
		 */
		if (!tls1_check_curve(s, p, 3))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_CURVE);
			goto f_err;
			}

		if ((curve_nid = tls1_ec_curve_id2nid(*(p + 2))) == 0) 
			{
			al=SSL_AD_INTERNAL_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);
			goto f_err;
			}

		ngroup = EC_GROUP_new_by_curve_name(curve_nid);
		if (ngroup == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);
			goto err;
			}
		if (EC_KEY_set_group(ecdh, ngroup) == 0)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);
			goto err;
			}
		EC_GROUP_free(ngroup);

		group = EC_KEY_get0_group(ecdh);

		if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&
		    (EC_GROUP_get_degree(group) > 163))
			{
			al=SSL_AD_EXPORT_RESTRICTION;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);
			goto f_err;
			}

		p+=3;

		/* Next, get the encoded ECPoint */
		if (((srvr_ecpoint = EC_POINT_new(group)) == NULL) ||
		    ((bn_ctx = BN_CTX_new()) == NULL))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
			goto err;
			}

		encoded_pt_len = *p;  /* length of encoded point */
		p+=1;

		if ((encoded_pt_len > n - param_len) ||
		    (EC_POINT_oct2point(group, srvr_ecpoint, 
			p, encoded_pt_len, bn_ctx) == 0))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_ECPOINT);
			goto f_err;
			}
		param_len += encoded_pt_len;

		n-=param_len;
		p+=encoded_pt_len;

		/* The ECC/TLS specification does not mention
		 * the use of DSA to sign ECParameters in the server
		 * key exchange message. We do support RSA and ECDSA.
		 */
		if (0) ;
#ifndef OPENSSL_NO_RSA
		else if (alg_a & SSL_aRSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
#endif
#ifndef OPENSSL_NO_ECDSA
		else if (alg_a & SSL_aECDSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);
#endif
		/* else anonymous ECDH, so no certificate or pkey. */
		EC_KEY_set_public_key(ecdh, srvr_ecpoint);
		s->session->sess_cert->peer_ecdh_tmp=ecdh;
		ecdh=NULL;
		BN_CTX_free(bn_ctx);
		bn_ctx = NULL;
		EC_POINT_free(srvr_ecpoint);
		srvr_ecpoint = NULL;
		}
	else if (alg_k)
		{
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);
		goto f_err;
		}
#endif /* !OPENSSL_NO_ECDH */


	/* p points to the next byte, there are 'n' bytes left */

	/* if it was signed, check the signature */
	if (pkey != NULL)
		{
		if (SSL_USE_SIGALGS(s))
			{
			int rv;
			if (2 > n)
				{
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
					SSL_R_LENGTH_TOO_SHORT);
				goto f_err;
				}
			rv = tls12_check_peer_sigalg(&md, s, p, pkey);
			if (rv == -1)
				goto err;
			else if (rv == 0)
				{
				goto f_err;
				}
#ifdef SSL_DEBUG
fprintf(stderr, ""USING TLSv1.2 HASH %s\n"", EVP_MD_name(md));
#endif
			p += 2;
			n -= 2;
			}
		else
			md = EVP_sha1();

		if (2 > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);
		n-=2;
		j=EVP_PKEY_size(pkey);

		/* Check signature length. If n is 0 then signature is empty */
		if ((i != n) || (n > j) || (n <= 0))
			{
			/* wrong packet length */
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_SIGNATURE_LENGTH);
			goto f_err;
			}

#ifndef OPENSSL_NO_RSA
		if (pkey->type == EVP_PKEY_RSA && !SSL_USE_SIGALGS(s))
			{
			int num;
			unsigned int size;

			j=0;
			q=md_buf;
			for (num=2; num > 0; num--)
				{
				EVP_MD_CTX_set_flags(&md_ctx,
					EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
				EVP_DigestInit_ex(&md_ctx,(num == 2)
					?s->ctx->md5:s->ctx->sha1, NULL);
				EVP_DigestUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
				EVP_DigestUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
				EVP_DigestUpdate(&md_ctx,param,param_len);
				EVP_DigestFinal_ex(&md_ctx,q,&size);
				q+=size;
				j+=size;
				}
			i=RSA_verify(NID_md5_sha1, md_buf, j, p, n,
								pkey->pkey.rsa);
			if (i < 0)
				{
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_DECRYPT);
				goto f_err;
				}
			if (i == 0)
				{
				/* bad signature */
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);
				goto f_err;
				}
			}
		else
#endif
			{
			EVP_VerifyInit_ex(&md_ctx, md, NULL);
			EVP_VerifyUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
			EVP_VerifyUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
			EVP_VerifyUpdate(&md_ctx,param,param_len);
			if (EVP_VerifyFinal(&md_ctx,p,(int)n,pkey) <= 0)
				{
				/* bad signature */
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);
				goto f_err;
				}
			}
		}
	else
		{
		/* aNULL, aSRP or kPSK do not need public keys */
		if (!(alg_a & (SSL_aNULL|SSL_aSRP)) && !(alg_k & SSL_kPSK))
			{
			/* Might be wrong key type, check it */
			if (ssl3_check_cert_and_algorithm(s))
				/* Otherwise this shouldn't happen */
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
			goto err;
			}
		/* still data left over */
		if (n != 0)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_EXTRA_DATA_IN_MESSAGE);
			goto f_err;
			}
		}
	EVP_PKEY_free(pkey);
	EVP_MD_CTX_cleanup(&md_ctx);
	return(1);
f_err:
	ssl3_send_alert(s,SSL3_AL_FATAL,al);
err:
	EVP_PKEY_free(pkey);
#ifndef OPENSSL_NO_RSA
	if (rsa != NULL)
		RSA_free(rsa);
#endif
#ifndef OPENSSL_NO_DH
	if (dh != NULL)
		DH_free(dh);
#endif
#ifndef OPENSSL_NO_ECDH
	BN_CTX_free(bn_ctx);
	EC_POINT_free(srvr_ecpoint);
	if (ecdh != NULL)
		EC_KEY_free(ecdh);
#endif
	EVP_MD_CTX_cleanup(&md_ctx);
	return(-1);
	}
",C,"		/* Temporary RSA keys only allowed in export ciphersuites */
		if (!SSL_C_IS_EXPORT(s->s3->tmp.new_cipher))
			{
			al=SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_UNEXPECTED_MESSAGE);
			goto f_err;
			}
",,,"@@ -1636,6 +1636,13 @@ int ssl3_get_key_exchange(SSL *s)
 #ifndef OPENSSL_NO_RSA
 	if (alg_k & SSL_kRSA)
 		{
+		/* Temporary RSA keys only allowed in export ciphersuites */
+		if (!SSL_C_IS_EXPORT(s->s3->tmp.new_cipher))
+			{
+			al=SSL_AD_UNEXPECTED_MESSAGE;
+			SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_UNEXPECTED_MESSAGE);
+			goto f_err;
+			}
 		if ((rsa=RSA_new()) == NULL)
 			{
 			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);",openssl,ce325c60c74b0fa784f5872404b722e120e5cab0,b15f8769644b00ef7283521593360b7b2135cb63,1,"int ssl3_get_key_exchange(SSL *s)
	{
#ifndef OPENSSL_NO_RSA
	unsigned char *q,md_buf[EVP_MAX_MD_SIZE*2];
#endif
	EVP_MD_CTX md_ctx;
	unsigned char *param,*p;
	int al,j,ok;
	long i,param_len,n,alg_k,alg_a;
	EVP_PKEY *pkey=NULL;
	const EVP_MD *md = NULL;
#ifndef OPENSSL_NO_RSA
	RSA *rsa=NULL;
#endif
#ifndef OPENSSL_NO_DH
	DH *dh=NULL;
#endif
#ifndef OPENSSL_NO_ECDH
	EC_KEY *ecdh = NULL;
	BN_CTX *bn_ctx = NULL;
	EC_POINT *srvr_ecpoint = NULL;
	int curve_nid = 0;
	int encoded_pt_len = 0;
#endif

	EVP_MD_CTX_init(&md_ctx);

	/* use same message size as in ssl3_get_certificate_request()
	 * as ServerKeyExchange message may be skipped */
	n=s->method->ssl_get_message(s,
		SSL3_ST_CR_KEY_EXCH_A,
		SSL3_ST_CR_KEY_EXCH_B,
		-1,
		s->max_cert_list,
		&ok);
	if (!ok) return((int)n);

	alg_k=s->s3->tmp.new_cipher->algorithm_mkey;

	if (s->s3->tmp.message_type != SSL3_MT_SERVER_KEY_EXCHANGE)
		{
		/*
		 * Can't skip server key exchange if this is an ephemeral
		 * ciphersuite.
		 */
		if (alg_k & (SSL_kDHE|SSL_kECDHE))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);
			al = SSL_AD_UNEXPECTED_MESSAGE;
			goto f_err;
			}
#ifndef OPENSSL_NO_PSK
		/* In plain PSK ciphersuite, ServerKeyExchange can be
		   omitted if no identity hint is sent. Set
		   session->sess_cert anyway to avoid problems
		   later.*/
		if (alg_k & SSL_kPSK)
			{
			s->session->sess_cert=ssl_sess_cert_new();
			if (s->ctx->psk_identity_hint)
				OPENSSL_free(s->ctx->psk_identity_hint);
			s->ctx->psk_identity_hint = NULL;
			}
#endif
		s->s3->tmp.reuse_message=1;
		return(1);
		}

	param=p=(unsigned char *)s->init_msg;
	if (s->session->sess_cert != NULL)
		{
#ifndef OPENSSL_NO_RSA
		if (s->session->sess_cert->peer_rsa_tmp != NULL)
			{
			RSA_free(s->session->sess_cert->peer_rsa_tmp);
			s->session->sess_cert->peer_rsa_tmp=NULL;
			}
#endif
#ifndef OPENSSL_NO_DH
		if (s->session->sess_cert->peer_dh_tmp)
			{
			DH_free(s->session->sess_cert->peer_dh_tmp);
			s->session->sess_cert->peer_dh_tmp=NULL;
			}
#endif
#ifndef OPENSSL_NO_ECDH
		if (s->session->sess_cert->peer_ecdh_tmp)
			{
			EC_KEY_free(s->session->sess_cert->peer_ecdh_tmp);
			s->session->sess_cert->peer_ecdh_tmp=NULL;
			}
#endif
		}
	else
		{
		s->session->sess_cert=ssl_sess_cert_new();
		}

	/* Total length of the parameters including the length prefix */
	param_len=0;

	alg_a=s->s3->tmp.new_cipher->algorithm_auth;

	al=SSL_AD_DECODE_ERROR;

#ifndef OPENSSL_NO_PSK
	if (alg_k & SSL_kPSK)
		{
		char tmp_id_hint[PSK_MAX_IDENTITY_LEN+1];

		param_len = 2;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);

		/* Store PSK identity hint for later use, hint is used
		 * in ssl3_send_client_key_exchange.  Assume that the
		 * maximum length of a PSK identity hint can be as
		 * long as the maximum length of a PSK identity. */
		if (i > PSK_MAX_IDENTITY_LEN)
			{
			al=SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_DATA_LENGTH_TOO_LONG);
			goto f_err;
			}
		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_BAD_PSK_IDENTITY_HINT_LENGTH);
			goto f_err;
			}
		param_len += i;

		/* If received PSK identity hint contains NULL
		 * characters, the hint is truncated from the first
		 * NULL. p may not be ending with NULL, so create a
		 * NULL-terminated string. */
		memcpy(tmp_id_hint, p, i);
		memset(tmp_id_hint+i, 0, PSK_MAX_IDENTITY_LEN+1-i);
		if (s->ctx->psk_identity_hint != NULL)
			OPENSSL_free(s->ctx->psk_identity_hint);
		s->ctx->psk_identity_hint = BUF_strdup(tmp_id_hint);
		if (s->ctx->psk_identity_hint == NULL)
			{
			al=SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);
			goto f_err;
			}	   

		p+=i;
		n-=param_len;
		}
	else
#endif /* !OPENSSL_NO_PSK */
#ifndef OPENSSL_NO_SRP
	if (alg_k & SSL_kSRP)
		{
		param_len = 2;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_N_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(s->srp_ctx.N=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;


		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_G_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(s->srp_ctx.g=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;


		if (1 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 1;

		i = (unsigned int)(p[0]);
		p++;

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_S_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(s->srp_ctx.s=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_B_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(s->srp_ctx.B=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;
		n-=param_len;

		if (!srp_verify_server_param(s, &al))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_PARAMETERS);
			goto f_err;
			}

/* We must check if there is a certificate */
#ifndef OPENSSL_NO_RSA
		if (alg_a & SSL_aRSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
#else
		if (0)
			;
#endif
#ifndef OPENSSL_NO_DSA
		else if (alg_a & SSL_aDSS)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);
#endif
		}
	else
#endif /* !OPENSSL_NO_SRP */
 #ifndef OPENSSL_NO_RSA
 	if (alg_k & SSL_kRSA)
 		{
//fix_flaw_line_below:
//		/* Temporary RSA keys only allowed in export ciphersuites */
//fix_flaw_line_below:
//		if (!SSL_C_IS_EXPORT(s->s3->tmp.new_cipher))
//fix_flaw_line_below:
//			{
//fix_flaw_line_below:
//			al=SSL_AD_UNEXPECTED_MESSAGE;
//fix_flaw_line_below:
//			SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_UNEXPECTED_MESSAGE);
//fix_flaw_line_below:
//			goto f_err;
//fix_flaw_line_below:
//			}
 		if ((rsa=RSA_new()) == NULL)
 			{
 			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
			goto err;
			}

		param_len = 2;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_MODULUS_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(rsa->n=BN_bin2bn(p,i,rsa->n)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_E_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(rsa->e=BN_bin2bn(p,i,rsa->e)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;
		n-=param_len;

		/* this should be because we are using an export cipher */
		if (alg_a & SSL_aRSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
		else
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
			goto err;
			}
		s->session->sess_cert->peer_rsa_tmp=rsa;
		rsa=NULL;
		}
#else /* OPENSSL_NO_RSA */
	if (0)
		;
#endif
#ifndef OPENSSL_NO_DH
	else if (alg_k & SSL_kDHE)
		{
		if ((dh=DH_new()) == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_DH_LIB);
			goto err;
			}

		param_len = 2;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_P_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(dh->p=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_G_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(dh->g=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_PUB_KEY_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(dh->pub_key=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;
		n-=param_len;

		if (!ssl_security(s, SSL_SECOP_TMP_DH,
						DH_security_bits(dh), 0, dh))
			{
			al=SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_DH_KEY_TOO_SMALL);
			goto f_err;
			}

#ifndef OPENSSL_NO_RSA
		if (alg_a & SSL_aRSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
#else
		if (0)
			;
#endif
#ifndef OPENSSL_NO_DSA
		else if (alg_a & SSL_aDSS)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);
#endif
		/* else anonymous DH, so no certificate or pkey. */

		s->session->sess_cert->peer_dh_tmp=dh;
		dh=NULL;
		}
	else if ((alg_k & SSL_kDHr) || (alg_k & SSL_kDHd))
		{
		al=SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);
		goto f_err;
		}
#endif /* !OPENSSL_NO_DH */

#ifndef OPENSSL_NO_ECDH
	else if (alg_k & SSL_kECDHE)
		{
		EC_GROUP *ngroup;
		const EC_GROUP *group;

		if ((ecdh=EC_KEY_new()) == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
			goto err;
			}

		/* Extract elliptic curve parameters and the
		 * server's ephemeral ECDH public key.
		 * Keep accumulating lengths of various components in
		 * param_len and make sure it never exceeds n.
		 */

		/* XXX: For now we only support named (not generic) curves
		 * and the ECParameters in this case is just three bytes. We
		 * also need one byte for the length of the encoded point
		 */
		param_len=4;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		/* Check curve is one of our preferences, if not server has
		 * sent an invalid curve. ECParameters is 3 bytes.
		 */
		if (!tls1_check_curve(s, p, 3))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_CURVE);
			goto f_err;
			}

		if ((curve_nid = tls1_ec_curve_id2nid(*(p + 2))) == 0) 
			{
			al=SSL_AD_INTERNAL_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);
			goto f_err;
			}

		ngroup = EC_GROUP_new_by_curve_name(curve_nid);
		if (ngroup == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);
			goto err;
			}
		if (EC_KEY_set_group(ecdh, ngroup) == 0)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);
			goto err;
			}
		EC_GROUP_free(ngroup);

		group = EC_KEY_get0_group(ecdh);

		if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&
		    (EC_GROUP_get_degree(group) > 163))
			{
			al=SSL_AD_EXPORT_RESTRICTION;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);
			goto f_err;
			}

		p+=3;

		/* Next, get the encoded ECPoint */
		if (((srvr_ecpoint = EC_POINT_new(group)) == NULL) ||
		    ((bn_ctx = BN_CTX_new()) == NULL))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
			goto err;
			}

		encoded_pt_len = *p;  /* length of encoded point */
		p+=1;

		if ((encoded_pt_len > n - param_len) ||
		    (EC_POINT_oct2point(group, srvr_ecpoint, 
			p, encoded_pt_len, bn_ctx) == 0))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_ECPOINT);
			goto f_err;
			}
		param_len += encoded_pt_len;

		n-=param_len;
		p+=encoded_pt_len;

		/* The ECC/TLS specification does not mention
		 * the use of DSA to sign ECParameters in the server
		 * key exchange message. We do support RSA and ECDSA.
		 */
		if (0) ;
#ifndef OPENSSL_NO_RSA
		else if (alg_a & SSL_aRSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
#endif
#ifndef OPENSSL_NO_ECDSA
		else if (alg_a & SSL_aECDSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);
#endif
		/* else anonymous ECDH, so no certificate or pkey. */
		EC_KEY_set_public_key(ecdh, srvr_ecpoint);
		s->session->sess_cert->peer_ecdh_tmp=ecdh;
		ecdh=NULL;
		BN_CTX_free(bn_ctx);
		bn_ctx = NULL;
		EC_POINT_free(srvr_ecpoint);
		srvr_ecpoint = NULL;
		}
	else if (alg_k)
		{
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);
		goto f_err;
		}
#endif /* !OPENSSL_NO_ECDH */


	/* p points to the next byte, there are 'n' bytes left */

	/* if it was signed, check the signature */
	if (pkey != NULL)
		{
		if (SSL_USE_SIGALGS(s))
			{
			int rv;
			if (2 > n)
				{
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
					SSL_R_LENGTH_TOO_SHORT);
				goto f_err;
				}
			rv = tls12_check_peer_sigalg(&md, s, p, pkey);
			if (rv == -1)
				goto err;
			else if (rv == 0)
				{
				goto f_err;
				}
#ifdef SSL_DEBUG
fprintf(stderr, ""USING TLSv1.2 HASH %s\n"", EVP_MD_name(md));
#endif
			p += 2;
			n -= 2;
			}
		else
			md = EVP_sha1();

		if (2 > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);
		n-=2;
		j=EVP_PKEY_size(pkey);

		/* Check signature length. If n is 0 then signature is empty */
		if ((i != n) || (n > j) || (n <= 0))
			{
			/* wrong packet length */
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_SIGNATURE_LENGTH);
			goto f_err;
			}

#ifndef OPENSSL_NO_RSA
		if (pkey->type == EVP_PKEY_RSA && !SSL_USE_SIGALGS(s))
			{
			int num;
			unsigned int size;

			j=0;
			q=md_buf;
			for (num=2; num > 0; num--)
				{
				EVP_MD_CTX_set_flags(&md_ctx,
					EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
				EVP_DigestInit_ex(&md_ctx,(num == 2)
					?s->ctx->md5:s->ctx->sha1, NULL);
				EVP_DigestUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
				EVP_DigestUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
				EVP_DigestUpdate(&md_ctx,param,param_len);
				EVP_DigestFinal_ex(&md_ctx,q,&size);
				q+=size;
				j+=size;
				}
			i=RSA_verify(NID_md5_sha1, md_buf, j, p, n,
								pkey->pkey.rsa);
			if (i < 0)
				{
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_DECRYPT);
				goto f_err;
				}
			if (i == 0)
				{
				/* bad signature */
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);
				goto f_err;
				}
			}
		else
#endif
			{
			EVP_VerifyInit_ex(&md_ctx, md, NULL);
			EVP_VerifyUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
			EVP_VerifyUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
			EVP_VerifyUpdate(&md_ctx,param,param_len);
			if (EVP_VerifyFinal(&md_ctx,p,(int)n,pkey) <= 0)
				{
				/* bad signature */
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);
				goto f_err;
				}
			}
		}
	else
		{
		/* aNULL, aSRP or kPSK do not need public keys */
		if (!(alg_a & (SSL_aNULL|SSL_aSRP)) && !(alg_k & SSL_kPSK))
			{
			/* Might be wrong key type, check it */
			if (ssl3_check_cert_and_algorithm(s))
				/* Otherwise this shouldn't happen */
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
			goto err;
			}
		/* still data left over */
		if (n != 0)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_EXTRA_DATA_IN_MESSAGE);
			goto f_err;
			}
		}
	EVP_PKEY_free(pkey);
	EVP_MD_CTX_cleanup(&md_ctx);
	return(1);
f_err:
	ssl3_send_alert(s,SSL3_AL_FATAL,al);
err:
	EVP_PKEY_free(pkey);
#ifndef OPENSSL_NO_RSA
	if (rsa != NULL)
		RSA_free(rsa);
#endif
#ifndef OPENSSL_NO_DH
	if (dh != NULL)
		DH_free(dh);
#endif
#ifndef OPENSSL_NO_ECDH
	BN_CTX_free(bn_ctx);
	EC_POINT_free(srvr_ecpoint);
	if (ecdh != NULL)
		EC_KEY_free(ecdh);
#endif
	EVP_MD_CTX_cleanup(&md_ctx);
	return(-1);
	}
"
2189,179925,,Remote,Not required,,CVE-2015-0204,https://www.cvedetails.com/cve/CVE-2015-0204/,CWE-310,Medium,,Partial,,2015-01-08,4.3,"The ssl3_get_key_exchange function in s3_clnt.c in OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k allows remote SSL servers to conduct RSA-to-EXPORT_RSA downgrade attacks and facilitate brute-force decryption by offering a weak ephemeral RSA key in a noncompliant role, related to the *FREAK* issue.  NOTE: the scope of this CVE is only client code based on OpenSSL, not EXPORT_RSA issues associated with servers or other TLS implementations.",2018-07-18,,6,https://github.com/openssl/openssl/commit/ce325c60c74b0fa784f5872404b722e120e5cab0,ce325c60c74b0fa784f5872404b722e120e5cab0,"Only allow ephemeral RSA keys in export ciphersuites.

OpenSSL clients would tolerate temporary RSA keys in non-export
ciphersuites. It also had an option SSL_OP_EPHEMERAL_RSA which
enabled this server side. Remove both options as they are a
protocol violation.

Thanks to Karthikeyan Bhargavan for reporting this issue.
(CVE-2015-0204)
Reviewed-by: Matt Caswell <matt@openssl.org>",15,ssl/s3_srvr.c,"{""sha"": ""c9c19c3ae3866f62c66803160e8870ebe6c720ef"", ""filename"": ""CHANGES"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/openssl/openssl/blob/ce325c60c74b0fa784f5872404b722e120e5cab0/CHANGES"", ""raw_url"": ""https://github.com/openssl/openssl/raw/ce325c60c74b0fa784f5872404b722e120e5cab0/CHANGES"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/CHANGES?ref=ce325c60c74b0fa784f5872404b722e120e5cab0"", ""patch"": ""@@ -666,6 +666,14 @@\n      (CVE-2014-3572)\n      [Steve Henson]\n \n+  *) Remove non-export ephemeral RSA code on client and server. This code\n+     violated the TLS standard by allowing the use of temporary RSA keys in\n+     non-export ciphersuites and could be used by a server to effectively\n+     downgrade the RSA key length used to a value smaller than the server\n+     certificate. Thanks for Karthikeyan Bhargavan for reporting this issue.\n+     (CVE-2015-0204)\n+     [Steve Henson]\n+\n   *) Ensure that the session ID context of an SSL is updated when its\n      SSL_CTX is updated via SSL_set_SSL_CTX.\n ""}<_**next**_>{""sha"": ""593435c493eaf609a04d4c180ac3fce1600be3a1"", ""filename"": ""doc/ssl/SSL_CTX_set_options.pod"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 9, ""changes"": 10, ""blob_url"": ""https://github.com/openssl/openssl/blob/ce325c60c74b0fa784f5872404b722e120e5cab0/doc/ssl/SSL_CTX_set_options.pod"", ""raw_url"": ""https://github.com/openssl/openssl/raw/ce325c60c74b0fa784f5872404b722e120e5cab0/doc/ssl/SSL_CTX_set_options.pod"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/doc/ssl/SSL_CTX_set_options.pod?ref=ce325c60c74b0fa784f5872404b722e120e5cab0"", ""patch"": ""@@ -151,15 +151,7 @@ temporary/ephemeral DH parameters are used.\n \n =item SSL_OP_EPHEMERAL_RSA\n \n-Always use ephemeral (temporary) RSA key when doing RSA operations\n-(see L<SSL_CTX_set_tmp_rsa_callback(3)|SSL_CTX_set_tmp_rsa_callback(3)>).\n-According to the specifications this is only done, when a RSA key\n-can only be used for signature operations (namely under export ciphers\n-with restricted RSA keylength). By setting this option, ephemeral\n-RSA keys are always used. This option breaks compatibility with the\n-SSL/TLS specifications and may lead to interoperability problems with\n-clients and should therefore never be used. Ciphers with DHE (ephemeral\n-Diffie-Hellman) key exchange should be used instead.\n+This option is no longer implemented and is treated as no op.\n \n =item SSL_OP_CIPHER_SERVER_PREFERENCE\n ""}<_**next**_>{""sha"": ""94c55b8045359f3122c324ca031e8350ef68b12c"", ""filename"": ""doc/ssl/SSL_CTX_set_tmp_rsa_callback.pod"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 15, ""changes"": 23, ""blob_url"": ""https://github.com/openssl/openssl/blob/ce325c60c74b0fa784f5872404b722e120e5cab0/doc/ssl/SSL_CTX_set_tmp_rsa_callback.pod"", ""raw_url"": ""https://github.com/openssl/openssl/raw/ce325c60c74b0fa784f5872404b722e120e5cab0/doc/ssl/SSL_CTX_set_tmp_rsa_callback.pod"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/doc/ssl/SSL_CTX_set_tmp_rsa_callback.pod?ref=ce325c60c74b0fa784f5872404b722e120e5cab0"", ""patch"": ""@@ -74,21 +74,14 @@ exchange and use DHE (Ephemeral Diffie-Hellman) key exchange instead\n in order to achieve forward secrecy (see\n L<SSL_CTX_set_tmp_dh_callback(3)|SSL_CTX_set_tmp_dh_callback(3)>).\n \n-On OpenSSL servers ephemeral RSA key exchange is therefore disabled by default\n-and must be explicitly enabled  using the SSL_OP_EPHEMERAL_RSA option of\n-L<SSL_CTX_set_options(3)|SSL_CTX_set_options(3)>, violating the TLS/SSL\n-standard. When ephemeral RSA key exchange is required for export ciphers,\n-it will automatically be used without this option!\n-\n-An application may either directly specify the key or can supply the key via\n-a callback function. The callback approach has the advantage, that the\n-callback may generate the key only in case it is actually needed. As the\n-generation of a RSA key is however costly, it will lead to a significant\n-delay in the handshake procedure.  Another advantage of the callback function\n-is that it can supply keys of different size (e.g. for SSL_OP_EPHEMERAL_RSA\n-usage) while the explicit setting of the key is only useful for key size of\n-512 bits to satisfy the export restricted ciphers and does give away key length\n-if a longer key would be allowed.\n+An application may either directly specify the key or can supply the key via a\n+callback function. The callback approach has the advantage, that the callback\n+may generate the key only in case it is actually needed. As the generation of a\n+RSA key is however costly, it will lead to a significant delay in the handshake\n+procedure.  Another advantage of the callback function is that it can supply\n+keys of different size while the explicit setting of the key is only useful for\n+key size of 512 bits to satisfy the export restricted ciphers and does give\n+away key length if a longer key would be allowed.\n \n The B<tmp_rsa_callback> is called with the B<keylength> needed and\n the B<is_export> information. The B<is_export> flag is set, when the""}<_**next**_>{""sha"": ""8a5c5a1cd2204884685cf81c6c1ad57a4a65f761"", ""filename"": ""ssl/d1_srvr.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 15, ""changes"": 21, ""blob_url"": ""https://github.com/openssl/openssl/blob/ce325c60c74b0fa784f5872404b722e120e5cab0/ssl/d1_srvr.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/ce325c60c74b0fa784f5872404b722e120e5cab0/ssl/d1_srvr.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/ssl/d1_srvr.c?ref=ce325c60c74b0fa784f5872404b722e120e5cab0"", ""patch"": ""@@ -472,24 +472,15 @@ int dtls1_accept(SSL *s)\n \t\tcase SSL3_ST_SW_KEY_EXCH_B:\n \t\t\talg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n \n-\t\t\t/* clear this, it may get reset by\n-\t\t\t * send_server_key_exchange */\n-\t\t\tif ((s->options & SSL_OP_EPHEMERAL_RSA)\n-#ifndef OPENSSL_NO_KRB5\n-\t\t\t\t&& !(alg_k & SSL_kKRB5)\n-#endif /* OPENSSL_NO_KRB5 */\n-\t\t\t\t)\n-\t\t\t\t/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key\n-\t\t\t\t * even when forbidden by protocol specs\n-\t\t\t\t * (handshake may fail as clients are not required to\n-\t\t\t\t * be able to handle this) */\n-\t\t\t\ts->s3->tmp.use_rsa_tmp=1;\n-\t\t\telse\n-\t\t\t\ts->s3->tmp.use_rsa_tmp=0;\n+\t\t\t/*\n+\t\t\t * clear this, it may get reset by\n+\t\t\t * send_server_key_exchange\n+\t\t\t */\n+\t\t\ts->s3->tmp.use_rsa_tmp=0;\n \n \t\t\t/* only send if a DH key exchange or\n \t\t\t * RSA but we have a sign only certificate */\n-\t\t\tif (s->s3->tmp.use_rsa_tmp\n+\t\t\tif (\n \t\t\t/* PSK: send ServerKeyExchange if PSK identity\n \t\t\t * hint if provided */\n #ifndef OPENSSL_NO_PSK""}<_**next**_>{""sha"": ""aa9dcbb5b3aa1e05794adaaa1ad1a95f76a250ff"", ""filename"": ""ssl/s3_clnt.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/openssl/openssl/blob/ce325c60c74b0fa784f5872404b722e120e5cab0/ssl/s3_clnt.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/ce325c60c74b0fa784f5872404b722e120e5cab0/ssl/s3_clnt.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/ssl/s3_clnt.c?ref=ce325c60c74b0fa784f5872404b722e120e5cab0"", ""patch"": ""@@ -1636,6 +1636,13 @@ int ssl3_get_key_exchange(SSL *s)\n #ifndef OPENSSL_NO_RSA\n \tif (alg_k & SSL_kRSA)\n \t\t{\n+\t\t/* Temporary RSA keys only allowed in export ciphersuites */\n+\t\tif (!SSL_C_IS_EXPORT(s->s3->tmp.new_cipher))\n+\t\t\t{\n+\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n+\t\t\tSSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_UNEXPECTED_MESSAGE);\n+\t\t\tgoto f_err;\n+\t\t\t}\n \t\tif ((rsa=RSA_new()) == NULL)\n \t\t\t{\n \t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);""}<_**next**_>{""sha"": ""e5a32ee90f382dfeb75813ad3fd61def9f801a37"", ""filename"": ""ssl/s3_srvr.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 15, ""changes"": 21, ""blob_url"": ""https://github.com/openssl/openssl/blob/ce325c60c74b0fa784f5872404b722e120e5cab0/ssl/s3_srvr.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/ce325c60c74b0fa784f5872404b722e120e5cab0/ssl/s3_srvr.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/ssl/s3_srvr.c?ref=ce325c60c74b0fa784f5872404b722e120e5cab0"", ""patch"": ""@@ -453,20 +453,11 @@ int ssl3_accept(SSL *s)\n \t\tcase SSL3_ST_SW_KEY_EXCH_B:\n \t\t\talg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n \n-\t\t\t/* clear this, it may get reset by\n-\t\t\t * send_server_key_exchange */\n-\t\t\tif ((s->options & SSL_OP_EPHEMERAL_RSA)\n-#ifndef OPENSSL_NO_KRB5\n-\t\t\t\t&& !(alg_k & SSL_kKRB5)\n-#endif /* OPENSSL_NO_KRB5 */\n-\t\t\t\t)\n-\t\t\t\t/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key\n-\t\t\t\t * even when forbidden by protocol specs\n-\t\t\t\t * (handshake may fail as clients are not required to\n-\t\t\t\t * be able to handle this) */\n-\t\t\t\ts->s3->tmp.use_rsa_tmp=1;\n-\t\t\telse\n-\t\t\t\ts->s3->tmp.use_rsa_tmp=0;\n+\t\t\t/*\n+\t\t\t * clear this, it may get reset by\n+\t\t\t * send_server_key_exchange\n+\t\t\t */\n+\t\t\ts->s3->tmp.use_rsa_tmp=0;\n \n \n \t\t\t/* only send if a DH key exchange, fortezza or\n@@ -480,7 +471,7 @@ int ssl3_accept(SSL *s)\n \t\t\t * server certificate contains the server's\n \t\t\t * public key for key exchange.\n \t\t\t */\n-\t\t\tif (s->s3->tmp.use_rsa_tmp\n+\t\t\tif (\n \t\t\t/* PSK: send ServerKeyExchange if PSK identity\n \t\t\t * hint if provided */\n #ifndef OPENSSL_NO_PSK""}<_**next**_>{""sha"": ""98661d0ab89d2d334c656fcabcf847f8b84d2fb9"", ""filename"": ""ssl/ssl.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 3, ""changes"": 5, ""blob_url"": ""https://github.com/openssl/openssl/blob/ce325c60c74b0fa784f5872404b722e120e5cab0/ssl/ssl.h"", ""raw_url"": ""https://github.com/openssl/openssl/raw/ce325c60c74b0fa784f5872404b722e120e5cab0/ssl/ssl.h"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/ssl/ssl.h?ref=ce325c60c74b0fa784f5872404b722e120e5cab0"", ""patch"": ""@@ -606,9 +606,8 @@ struct ssl_session_st\n #define SSL_OP_SINGLE_ECDH_USE\t\t\t\t0x00080000L\n /* If set, always create a new key when using tmp_dh parameters */\n #define SSL_OP_SINGLE_DH_USE\t\t\t\t0x00100000L\n-/* Set to always use the tmp_rsa key when doing RSA operations,\n- * even when this violates protocol specs */\n-#define SSL_OP_EPHEMERAL_RSA\t\t\t\t0x00200000L\n+/* Does nothing: retained for compatibiity */\n+#define SSL_OP_EPHEMERAL_RSA\t\t\t\t0x0\n /* Set on servers to choose the cipher according to the server's\n  * preferences */\n #define SSL_OP_CIPHER_SERVER_PREFERENCE\t\t\t0x00400000L""}","int ssl3_accept(SSL *s)
	{
	BUF_MEM *buf;
	unsigned long alg_k,Time=(unsigned long)time(NULL);
	void (*cb)(const SSL *ssl,int type,int val)=NULL;
	int ret= -1;
	int new_state,state,skip=0;

	RAND_add(&Time,sizeof(Time),0);
	ERR_clear_error();
	clear_sys_error();

	if (s->info_callback != NULL)
		cb=s->info_callback;
	else if (s->ctx->info_callback != NULL)
		cb=s->ctx->info_callback;

	/* init things to blank */
	s->in_handshake++;
	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);

	if (s->cert == NULL)
		{
		SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_NO_CERTIFICATE_SET);
		return(-1);
		}

#ifndef OPENSSL_NO_HEARTBEATS
	/* If we're awaiting a HeartbeatResponse, pretend we
	 * already got and don't await it anymore, because
	 * Heartbeats don't make sense during handshakes anyway.
	 */
	if (s->tlsext_hb_pending)
		{
		s->tlsext_hb_pending = 0;
		s->tlsext_hb_seq++;
		}
#endif

	for (;;)
		{
		state=s->state;

		switch (s->state)
			{
		case SSL_ST_RENEGOTIATE:
			s->renegotiate=1;
			/* s->state=SSL_ST_ACCEPT; */

		case SSL_ST_BEFORE:
		case SSL_ST_ACCEPT:
		case SSL_ST_BEFORE|SSL_ST_ACCEPT:
		case SSL_ST_OK|SSL_ST_ACCEPT:

			s->server=1;
			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);

			if ((s->version>>8) != 3)
				{
				SSLerr(SSL_F_SSL3_ACCEPT, ERR_R_INTERNAL_ERROR);
				return -1;
				}

			if (!ssl_security(s, SSL_SECOP_VERSION, 0,
							s->version, NULL))
				{
				SSLerr(SSL_F_SSL3_ACCEPT, SSL_R_VERSION_TOO_LOW);
				return -1;
				}

			s->type=SSL_ST_ACCEPT;

			if (s->init_buf == NULL)
				{
				if ((buf=BUF_MEM_new()) == NULL)
					{
					ret= -1;
					goto end;
					}
				if (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))
					{
					BUF_MEM_free(buf);
					ret= -1;
					goto end;
					}
				s->init_buf=buf;
				}

			if (!ssl3_setup_buffers(s))
				{
				ret= -1;
				goto end;
				}

			s->init_num=0;
			s->s3->flags &= ~TLS1_FLAGS_SKIP_CERT_VERIFY;
			s->s3->flags &= ~SSL3_FLAGS_CCS_OK;
			/* Should have been reset by ssl3_get_finished, too. */
			s->s3->change_cipher_spec = 0;

			if (s->state != SSL_ST_RENEGOTIATE)
				{
				/* Ok, we now need to push on a buffering BIO so that
				 * the output is sent in a way that TCP likes :-)
				 */
				if (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }
				
				ssl3_init_finished_mac(s);
				s->state=SSL3_ST_SR_CLNT_HELLO_A;
				s->ctx->stats.sess_accept++;
				}
			else if (!s->s3->send_connection_binding &&
				!(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))
				{
				/* Server attempting to renegotiate with
				 * client that doesn't support secure
				 * renegotiation.
				 */
				SSLerr(SSL_F_SSL3_ACCEPT, SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);
				ret = -1;
				goto end;
				}
			else
				{
				/* s->state == SSL_ST_RENEGOTIATE,
				 * we will just send a HelloRequest */
				s->ctx->stats.sess_accept_renegotiate++;
				s->state=SSL3_ST_SW_HELLO_REQ_A;
				}
			break;

		case SSL3_ST_SW_HELLO_REQ_A:
		case SSL3_ST_SW_HELLO_REQ_B:

			s->shutdown=0;
			ret=ssl3_send_hello_request(s);
			if (ret <= 0) goto end;
			s->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C;
			s->state=SSL3_ST_SW_FLUSH;
			s->init_num=0;

			ssl3_init_finished_mac(s);
			break;

		case SSL3_ST_SW_HELLO_REQ_C:
			s->state=SSL_ST_OK;
			break;

		case SSL3_ST_SR_CLNT_HELLO_A:
		case SSL3_ST_SR_CLNT_HELLO_B:
		case SSL3_ST_SR_CLNT_HELLO_C:

			ret=ssl3_get_client_hello(s);
			if (ret <= 0) goto end;
#ifndef OPENSSL_NO_SRP
			s->state = SSL3_ST_SR_CLNT_HELLO_D;
		case SSL3_ST_SR_CLNT_HELLO_D:
			{
			int al;
			if ((ret = ssl_check_srp_ext_ClientHello(s,&al))  < 0)
					{
					/* callback indicates firther work to be done */
					s->rwstate=SSL_X509_LOOKUP;
					goto end;
					}
			if (ret != SSL_ERROR_NONE)
				{
				ssl3_send_alert(s,SSL3_AL_FATAL,al);	
				/* This is not really an error but the only means to
                                   for a client to detect whether srp is supported. */
 				   if (al != TLS1_AD_UNKNOWN_PSK_IDENTITY) 	
					SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_CLIENTHELLO_TLSEXT);			
				ret = SSL_TLSEXT_ERR_ALERT_FATAL;			
				ret= -1;
				goto end;	
				}
			}
#endif		
			
			s->renegotiate = 2;
			s->state=SSL3_ST_SW_SRVR_HELLO_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_SRVR_HELLO_A:
		case SSL3_ST_SW_SRVR_HELLO_B:
			ret=ssl3_send_server_hello(s);
			if (ret <= 0) goto end;
#ifndef OPENSSL_NO_TLSEXT
			if (s->hit)
				{
				if (s->tlsext_ticket_expected)
					s->state=SSL3_ST_SW_SESSION_TICKET_A;
				else
					s->state=SSL3_ST_SW_CHANGE_A;
				}
#else
			if (s->hit)
					s->state=SSL3_ST_SW_CHANGE_A;
#endif
			else
					s->state = SSL3_ST_SW_CERT_A;
			s->init_num = 0;
			break;

		case SSL3_ST_SW_CERT_A:
		case SSL3_ST_SW_CERT_B:
			/* Check if it is anon DH or anon ECDH, */
			/* normal PSK or KRB5 or SRP */
			if (!(s->s3->tmp.new_cipher->algorithm_auth & (SSL_aNULL|SSL_aKRB5|SSL_aSRP))
				&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
				{
				ret=ssl3_send_server_certificate(s);
				if (ret <= 0) goto end;
#ifndef OPENSSL_NO_TLSEXT
				if (s->tlsext_status_expected)
					s->state=SSL3_ST_SW_CERT_STATUS_A;
				else
					s->state=SSL3_ST_SW_KEY_EXCH_A;
				}
			else
				{
				skip = 1;
				s->state=SSL3_ST_SW_KEY_EXCH_A;
				}
#else
				}
			else
				skip=1;

			s->state=SSL3_ST_SW_KEY_EXCH_A;
#endif
			s->init_num=0;
			break;

		case SSL3_ST_SW_KEY_EXCH_A:
 		case SSL3_ST_SW_KEY_EXCH_B:
 			alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
 
			/*
			 * clear this, it may get reset by
			 * send_server_key_exchange
			 */
			s->s3->tmp.use_rsa_tmp=0;
 
 
 			/* only send if a DH key exchange, fortezza or
			 * RSA but we have a sign only certificate
			 *
			 * PSK: may send PSK identity hints
			 *
			 * For ECC ciphersuites, we send a serverKeyExchange
			 * message only if the cipher suite is either
			 * ECDH-anon or ECDHE. In other cases, the
 			 * server certificate contains the server's
 			 * public key for key exchange.
 			 */
			if (
 			/* PSK: send ServerKeyExchange if PSK identity
 			 * hint if provided */
 #ifndef OPENSSL_NO_PSK
			    || ((alg_k & SSL_kPSK) && s->ctx->psk_identity_hint)
#endif
#ifndef OPENSSL_NO_SRP
			    /* SRP: send ServerKeyExchange */
			    || (alg_k & SSL_kSRP)
#endif
			    || (alg_k & SSL_kDHE)
			    || (alg_k & SSL_kECDHE)
			    || ((alg_k & SSL_kRSA)
				&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL
				    || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)
					&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)
					)
				    )
				)
			    )
				{
				ret=ssl3_send_server_key_exchange(s);
				if (ret <= 0) goto end;
				}
			else
				skip=1;

			s->state=SSL3_ST_SW_CERT_REQ_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_CERT_REQ_A:
		case SSL3_ST_SW_CERT_REQ_B:
			if (/* don't request cert unless asked for it: */
				!(s->verify_mode & SSL_VERIFY_PEER) ||
				/* if SSL_VERIFY_CLIENT_ONCE is set,
				 * don't request cert during re-negotiation: */
				((s->session->peer != NULL) &&
				 (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||
				/* never request cert in anonymous ciphersuites
				 * (see section ""Certificate request"" in SSL 3 drafts
				 * and in RFC 2246): */
				((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&
				 /* ... except when the application insists on verification
				  * (against the specs, but s3_clnt.c accepts this for SSL 3) */
				 !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||
				 /* never request cert in Kerberos ciphersuites */
				(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5) ||
				/* don't request certificate for SRP auth */
				(s->s3->tmp.new_cipher->algorithm_auth & SSL_aSRP)
				/* With normal PSK Certificates and
				 * Certificate Requests are omitted */
				|| (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
				{
				/* no cert request */
				skip=1;
				s->s3->tmp.cert_request=0;
				s->state=SSL3_ST_SW_SRVR_DONE_A;
				if (s->s3->handshake_buffer)
					if (!ssl3_digest_cached_records(s))
						return -1;
				}
			else
				{
				s->s3->tmp.cert_request=1;
				ret=ssl3_send_certificate_request(s);
				if (ret <= 0) goto end;
#ifndef NETSCAPE_HANG_BUG
				s->state=SSL3_ST_SW_SRVR_DONE_A;
#else
				s->state=SSL3_ST_SW_FLUSH;
				s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
#endif
				s->init_num=0;
				}
			break;

		case SSL3_ST_SW_SRVR_DONE_A:
		case SSL3_ST_SW_SRVR_DONE_B:
			ret=ssl3_send_server_done(s);
			if (ret <= 0) goto end;
			s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
			s->state=SSL3_ST_SW_FLUSH;
			s->init_num=0;
			break;
		
		case SSL3_ST_SW_FLUSH:

			/* This code originally checked to see if
			 * any data was pending using BIO_CTRL_INFO
			 * and then flushed. This caused problems
			 * as documented in PR#1939. The proposed
			 * fix doesn't completely resolve this issue
			 * as buggy implementations of BIO_CTRL_PENDING
			 * still exist. So instead we just flush
			 * unconditionally.
			 */

			s->rwstate=SSL_WRITING;
			if (BIO_flush(s->wbio) <= 0)
				{
				ret= -1;
				goto end;
				}
			s->rwstate=SSL_NOTHING;

			s->state=s->s3->tmp.next_state;
			break;

		case SSL3_ST_SR_CERT_A:
		case SSL3_ST_SR_CERT_B:
			if (s->s3->tmp.cert_request)
				{
				ret=ssl3_get_client_certificate(s);
				if (ret <= 0) goto end;
				}
			s->init_num=0;
			s->state=SSL3_ST_SR_KEY_EXCH_A;
			break;

		case SSL3_ST_SR_KEY_EXCH_A:
		case SSL3_ST_SR_KEY_EXCH_B:
			ret=ssl3_get_client_key_exchange(s);
			if (ret <= 0)
				goto end;
			if (ret == 2)
				{
				/* For the ECDH ciphersuites when
				 * the client sends its ECDH pub key in
				 * a certificate, the CertificateVerify
				 * message is not sent.
				 * Also for GOST ciphersuites when
				 * the client uses its key from the certificate
				 * for key exchange.
				 */
#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
				s->state=SSL3_ST_SR_FINISHED_A;
#else
				if (s->s3->next_proto_neg_seen)
					s->state=SSL3_ST_SR_NEXT_PROTO_A;
				else
					s->state=SSL3_ST_SR_FINISHED_A;
#endif
				s->init_num = 0;
				}
			else if (SSL_USE_SIGALGS(s))
				{
				s->state=SSL3_ST_SR_CERT_VRFY_A;
				s->init_num=0;
				if (!s->session->peer)
					break;
				/* For sigalgs freeze the handshake buffer
				 * at this point and digest cached records.
				 */
				if (!s->s3->handshake_buffer)
					{
					SSLerr(SSL_F_SSL3_ACCEPT,ERR_R_INTERNAL_ERROR);
					return -1;
					}
				s->s3->flags |= TLS1_FLAGS_KEEP_HANDSHAKE;
				if (!ssl3_digest_cached_records(s))
					return -1;
				}
			else
				{
				int offset=0;
				int dgst_num;

				s->state=SSL3_ST_SR_CERT_VRFY_A;
				s->init_num=0;

				/* We need to get hashes here so if there is
				 * a client cert, it can be verified
				 * FIXME - digest processing for CertificateVerify
				 * should be generalized. But it is next step
				 */
				if (s->s3->handshake_buffer)
					if (!ssl3_digest_cached_records(s))
						return -1;
				for (dgst_num=0; dgst_num<SSL_MAX_DIGEST;dgst_num++)	
					if (s->s3->handshake_dgst[dgst_num]) 
						{
						int dgst_size;

						s->method->ssl3_enc->cert_verify_mac(s,EVP_MD_CTX_type(s->s3->handshake_dgst[dgst_num]),&(s->s3->tmp.cert_verify_md[offset]));
						dgst_size=EVP_MD_CTX_size(s->s3->handshake_dgst[dgst_num]);
						if (dgst_size < 0)
							{
							ret = -1;
							goto end;
							}
						offset+=dgst_size;
						}		
				}
			break;

		case SSL3_ST_SR_CERT_VRFY_A:
		case SSL3_ST_SR_CERT_VRFY_B:
			/*
			 * This *should* be the first time we enable CCS, but be
			 * extra careful about surrounding code changes. We need
			 * to set this here because we don't know if we're
			 * expecting a CertificateVerify or not.
			 */
			if (!s->s3->change_cipher_spec)
				s->s3->flags |= SSL3_FLAGS_CCS_OK;
			/* we should decide if we expected this one */
			ret=ssl3_get_cert_verify(s);
			if (ret <= 0) goto end;

#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
			s->state=SSL3_ST_SR_FINISHED_A;
#else
			if (s->s3->next_proto_neg_seen)
				s->state=SSL3_ST_SR_NEXT_PROTO_A;
			else
				s->state=SSL3_ST_SR_FINISHED_A;
#endif
			s->init_num=0;
			break;

#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
		case SSL3_ST_SR_NEXT_PROTO_A:
		case SSL3_ST_SR_NEXT_PROTO_B:
			/*
			 * Enable CCS for resumed handshakes with NPN.
			 * In a full handshake with NPN, we end up here through
			 * SSL3_ST_SR_CERT_VRFY_B, where SSL3_FLAGS_CCS_OK was
			 * already set. Receiving a CCS clears the flag, so make
			 * sure not to re-enable it to ban duplicates.
			 * s->s3->change_cipher_spec is set when a CCS is
			 * processed in s3_pkt.c, and remains set until
			 * the client's Finished message is read.
			 */
			if (!s->s3->change_cipher_spec)
				s->s3->flags |= SSL3_FLAGS_CCS_OK;

			ret=ssl3_get_next_proto(s);
			if (ret <= 0) goto end;
			s->init_num = 0;
			s->state=SSL3_ST_SR_FINISHED_A;
			break;
#endif

		case SSL3_ST_SR_FINISHED_A:
		case SSL3_ST_SR_FINISHED_B:
			/*
			 * Enable CCS for resumed handshakes without NPN.
			 * In a full handshake, we end up here through
			 * SSL3_ST_SR_CERT_VRFY_B, where SSL3_FLAGS_CCS_OK was
			 * already set. Receiving a CCS clears the flag, so make
			 * sure not to re-enable it to ban duplicates.
			 * s->s3->change_cipher_spec is set when a CCS is
			 * processed in s3_pkt.c, and remains set until
			 * the client's Finished message is read.
			 */
			if (!s->s3->change_cipher_spec)
				s->s3->flags |= SSL3_FLAGS_CCS_OK;
			ret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,
				SSL3_ST_SR_FINISHED_B);
			if (ret <= 0) goto end;
			if (s->hit)
				s->state=SSL_ST_OK;
#ifndef OPENSSL_NO_TLSEXT
			else if (s->tlsext_ticket_expected)
				s->state=SSL3_ST_SW_SESSION_TICKET_A;
#endif
			else
				s->state=SSL3_ST_SW_CHANGE_A;
			s->init_num=0;
			break;

#ifndef OPENSSL_NO_TLSEXT
		case SSL3_ST_SW_SESSION_TICKET_A:
		case SSL3_ST_SW_SESSION_TICKET_B:
			ret=ssl3_send_newsession_ticket(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_CHANGE_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_CERT_STATUS_A:
		case SSL3_ST_SW_CERT_STATUS_B:
			ret=ssl3_send_cert_status(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_KEY_EXCH_A;
			s->init_num=0;
			break;

#endif

		case SSL3_ST_SW_CHANGE_A:
		case SSL3_ST_SW_CHANGE_B:

			s->session->cipher=s->s3->tmp.new_cipher;
			if (!s->method->ssl3_enc->setup_key_block(s))
				{ ret= -1; goto end; }

			ret=ssl3_send_change_cipher_spec(s,
				SSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);

			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_FINISHED_A;
			s->init_num=0;

			if (!s->method->ssl3_enc->change_cipher_state(s,
				SSL3_CHANGE_CIPHER_SERVER_WRITE))
				{
				ret= -1;
				goto end;
				}

			break;

		case SSL3_ST_SW_FINISHED_A:
		case SSL3_ST_SW_FINISHED_B:
			ret=ssl3_send_finished(s,
				SSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,
				s->method->ssl3_enc->server_finished_label,
				s->method->ssl3_enc->server_finished_label_len);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_FLUSH;
			if (s->hit)
				{
#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
				s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;
#else
				if (s->s3->next_proto_neg_seen)
					{
					s->s3->tmp.next_state=SSL3_ST_SR_NEXT_PROTO_A;
					}
				else
					s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;
#endif
				}
			else
				s->s3->tmp.next_state=SSL_ST_OK;
			s->init_num=0;
			break;

		case SSL_ST_OK:
			/* clean a few things up */
			ssl3_cleanup_key_block(s);

			BUF_MEM_free(s->init_buf);
			s->init_buf=NULL;

			/* remove buffering on output */
			ssl_free_wbio_buffer(s);

			s->init_num=0;

			if (s->renegotiate == 2) /* skipped if we just sent a HelloRequest */
				{
				s->renegotiate=0;
				s->new_session=0;
				
				ssl_update_cache(s,SSL_SESS_CACHE_SERVER);
				
				s->ctx->stats.sess_accept_good++;
				/* s->server=1; */
				s->handshake_func=ssl3_accept;

				if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);
				}
			
			ret = 1;
			goto end;
			/* break; */

		default:
			SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_UNKNOWN_STATE);
			ret= -1;
			goto end;
			/* break; */
			}
		
		if (!s->s3->tmp.reuse_message && !skip)
			{
			if (s->debug)
				{
				if ((ret=BIO_flush(s->wbio)) <= 0)
					goto end;
				}


			if ((cb != NULL) && (s->state != state))
				{
				new_state=s->state;
				s->state=state;
				cb(s,SSL_CB_ACCEPT_LOOP,1);
				s->state=new_state;
				}
			}
		skip=0;
		}
","int ssl3_accept(SSL *s)
	{
	BUF_MEM *buf;
	unsigned long alg_k,Time=(unsigned long)time(NULL);
	void (*cb)(const SSL *ssl,int type,int val)=NULL;
	int ret= -1;
	int new_state,state,skip=0;

	RAND_add(&Time,sizeof(Time),0);
	ERR_clear_error();
	clear_sys_error();

	if (s->info_callback != NULL)
		cb=s->info_callback;
	else if (s->ctx->info_callback != NULL)
		cb=s->ctx->info_callback;

	/* init things to blank */
	s->in_handshake++;
	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);

	if (s->cert == NULL)
		{
		SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_NO_CERTIFICATE_SET);
		return(-1);
		}

#ifndef OPENSSL_NO_HEARTBEATS
	/* If we're awaiting a HeartbeatResponse, pretend we
	 * already got and don't await it anymore, because
	 * Heartbeats don't make sense during handshakes anyway.
	 */
	if (s->tlsext_hb_pending)
		{
		s->tlsext_hb_pending = 0;
		s->tlsext_hb_seq++;
		}
#endif

	for (;;)
		{
		state=s->state;

		switch (s->state)
			{
		case SSL_ST_RENEGOTIATE:
			s->renegotiate=1;
			/* s->state=SSL_ST_ACCEPT; */

		case SSL_ST_BEFORE:
		case SSL_ST_ACCEPT:
		case SSL_ST_BEFORE|SSL_ST_ACCEPT:
		case SSL_ST_OK|SSL_ST_ACCEPT:

			s->server=1;
			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);

			if ((s->version>>8) != 3)
				{
				SSLerr(SSL_F_SSL3_ACCEPT, ERR_R_INTERNAL_ERROR);
				return -1;
				}

			if (!ssl_security(s, SSL_SECOP_VERSION, 0,
							s->version, NULL))
				{
				SSLerr(SSL_F_SSL3_ACCEPT, SSL_R_VERSION_TOO_LOW);
				return -1;
				}

			s->type=SSL_ST_ACCEPT;

			if (s->init_buf == NULL)
				{
				if ((buf=BUF_MEM_new()) == NULL)
					{
					ret= -1;
					goto end;
					}
				if (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))
					{
					BUF_MEM_free(buf);
					ret= -1;
					goto end;
					}
				s->init_buf=buf;
				}

			if (!ssl3_setup_buffers(s))
				{
				ret= -1;
				goto end;
				}

			s->init_num=0;
			s->s3->flags &= ~TLS1_FLAGS_SKIP_CERT_VERIFY;
			s->s3->flags &= ~SSL3_FLAGS_CCS_OK;
			/* Should have been reset by ssl3_get_finished, too. */
			s->s3->change_cipher_spec = 0;

			if (s->state != SSL_ST_RENEGOTIATE)
				{
				/* Ok, we now need to push on a buffering BIO so that
				 * the output is sent in a way that TCP likes :-)
				 */
				if (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }
				
				ssl3_init_finished_mac(s);
				s->state=SSL3_ST_SR_CLNT_HELLO_A;
				s->ctx->stats.sess_accept++;
				}
			else if (!s->s3->send_connection_binding &&
				!(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))
				{
				/* Server attempting to renegotiate with
				 * client that doesn't support secure
				 * renegotiation.
				 */
				SSLerr(SSL_F_SSL3_ACCEPT, SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);
				ret = -1;
				goto end;
				}
			else
				{
				/* s->state == SSL_ST_RENEGOTIATE,
				 * we will just send a HelloRequest */
				s->ctx->stats.sess_accept_renegotiate++;
				s->state=SSL3_ST_SW_HELLO_REQ_A;
				}
			break;

		case SSL3_ST_SW_HELLO_REQ_A:
		case SSL3_ST_SW_HELLO_REQ_B:

			s->shutdown=0;
			ret=ssl3_send_hello_request(s);
			if (ret <= 0) goto end;
			s->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C;
			s->state=SSL3_ST_SW_FLUSH;
			s->init_num=0;

			ssl3_init_finished_mac(s);
			break;

		case SSL3_ST_SW_HELLO_REQ_C:
			s->state=SSL_ST_OK;
			break;

		case SSL3_ST_SR_CLNT_HELLO_A:
		case SSL3_ST_SR_CLNT_HELLO_B:
		case SSL3_ST_SR_CLNT_HELLO_C:

			ret=ssl3_get_client_hello(s);
			if (ret <= 0) goto end;
#ifndef OPENSSL_NO_SRP
			s->state = SSL3_ST_SR_CLNT_HELLO_D;
		case SSL3_ST_SR_CLNT_HELLO_D:
			{
			int al;
			if ((ret = ssl_check_srp_ext_ClientHello(s,&al))  < 0)
					{
					/* callback indicates firther work to be done */
					s->rwstate=SSL_X509_LOOKUP;
					goto end;
					}
			if (ret != SSL_ERROR_NONE)
				{
				ssl3_send_alert(s,SSL3_AL_FATAL,al);	
				/* This is not really an error but the only means to
                                   for a client to detect whether srp is supported. */
 				   if (al != TLS1_AD_UNKNOWN_PSK_IDENTITY) 	
					SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_CLIENTHELLO_TLSEXT);			
				ret = SSL_TLSEXT_ERR_ALERT_FATAL;			
				ret= -1;
				goto end;	
				}
			}
#endif		
			
			s->renegotiate = 2;
			s->state=SSL3_ST_SW_SRVR_HELLO_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_SRVR_HELLO_A:
		case SSL3_ST_SW_SRVR_HELLO_B:
			ret=ssl3_send_server_hello(s);
			if (ret <= 0) goto end;
#ifndef OPENSSL_NO_TLSEXT
			if (s->hit)
				{
				if (s->tlsext_ticket_expected)
					s->state=SSL3_ST_SW_SESSION_TICKET_A;
				else
					s->state=SSL3_ST_SW_CHANGE_A;
				}
#else
			if (s->hit)
					s->state=SSL3_ST_SW_CHANGE_A;
#endif
			else
					s->state = SSL3_ST_SW_CERT_A;
			s->init_num = 0;
			break;

		case SSL3_ST_SW_CERT_A:
		case SSL3_ST_SW_CERT_B:
			/* Check if it is anon DH or anon ECDH, */
			/* normal PSK or KRB5 or SRP */
			if (!(s->s3->tmp.new_cipher->algorithm_auth & (SSL_aNULL|SSL_aKRB5|SSL_aSRP))
				&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
				{
				ret=ssl3_send_server_certificate(s);
				if (ret <= 0) goto end;
#ifndef OPENSSL_NO_TLSEXT
				if (s->tlsext_status_expected)
					s->state=SSL3_ST_SW_CERT_STATUS_A;
				else
					s->state=SSL3_ST_SW_KEY_EXCH_A;
				}
			else
				{
				skip = 1;
				s->state=SSL3_ST_SW_KEY_EXCH_A;
				}
#else
				}
			else
				skip=1;

			s->state=SSL3_ST_SW_KEY_EXCH_A;
#endif
			s->init_num=0;
			break;

		case SSL3_ST_SW_KEY_EXCH_A:
 		case SSL3_ST_SW_KEY_EXCH_B:
 			alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
 
			/* clear this, it may get reset by
			 * send_server_key_exchange */
			if ((s->options & SSL_OP_EPHEMERAL_RSA)
#ifndef OPENSSL_NO_KRB5
				&& !(alg_k & SSL_kKRB5)
#endif /* OPENSSL_NO_KRB5 */
				)
				/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key
				 * even when forbidden by protocol specs
				 * (handshake may fail as clients are not required to
				 * be able to handle this) */
				s->s3->tmp.use_rsa_tmp=1;
			else
				s->s3->tmp.use_rsa_tmp=0;
 
 
 			/* only send if a DH key exchange, fortezza or
			 * RSA but we have a sign only certificate
			 *
			 * PSK: may send PSK identity hints
			 *
			 * For ECC ciphersuites, we send a serverKeyExchange
			 * message only if the cipher suite is either
			 * ECDH-anon or ECDHE. In other cases, the
 			 * server certificate contains the server's
 			 * public key for key exchange.
 			 */
			if (s->s3->tmp.use_rsa_tmp
 			/* PSK: send ServerKeyExchange if PSK identity
 			 * hint if provided */
 #ifndef OPENSSL_NO_PSK
			    || ((alg_k & SSL_kPSK) && s->ctx->psk_identity_hint)
#endif
#ifndef OPENSSL_NO_SRP
			    /* SRP: send ServerKeyExchange */
			    || (alg_k & SSL_kSRP)
#endif
			    || (alg_k & SSL_kDHE)
			    || (alg_k & SSL_kECDHE)
			    || ((alg_k & SSL_kRSA)
				&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL
				    || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)
					&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)
					)
				    )
				)
			    )
				{
				ret=ssl3_send_server_key_exchange(s);
				if (ret <= 0) goto end;
				}
			else
				skip=1;

			s->state=SSL3_ST_SW_CERT_REQ_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_CERT_REQ_A:
		case SSL3_ST_SW_CERT_REQ_B:
			if (/* don't request cert unless asked for it: */
				!(s->verify_mode & SSL_VERIFY_PEER) ||
				/* if SSL_VERIFY_CLIENT_ONCE is set,
				 * don't request cert during re-negotiation: */
				((s->session->peer != NULL) &&
				 (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||
				/* never request cert in anonymous ciphersuites
				 * (see section ""Certificate request"" in SSL 3 drafts
				 * and in RFC 2246): */
				((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&
				 /* ... except when the application insists on verification
				  * (against the specs, but s3_clnt.c accepts this for SSL 3) */
				 !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||
				 /* never request cert in Kerberos ciphersuites */
				(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5) ||
				/* don't request certificate for SRP auth */
				(s->s3->tmp.new_cipher->algorithm_auth & SSL_aSRP)
				/* With normal PSK Certificates and
				 * Certificate Requests are omitted */
				|| (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
				{
				/* no cert request */
				skip=1;
				s->s3->tmp.cert_request=0;
				s->state=SSL3_ST_SW_SRVR_DONE_A;
				if (s->s3->handshake_buffer)
					if (!ssl3_digest_cached_records(s))
						return -1;
				}
			else
				{
				s->s3->tmp.cert_request=1;
				ret=ssl3_send_certificate_request(s);
				if (ret <= 0) goto end;
#ifndef NETSCAPE_HANG_BUG
				s->state=SSL3_ST_SW_SRVR_DONE_A;
#else
				s->state=SSL3_ST_SW_FLUSH;
				s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
#endif
				s->init_num=0;
				}
			break;

		case SSL3_ST_SW_SRVR_DONE_A:
		case SSL3_ST_SW_SRVR_DONE_B:
			ret=ssl3_send_server_done(s);
			if (ret <= 0) goto end;
			s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
			s->state=SSL3_ST_SW_FLUSH;
			s->init_num=0;
			break;
		
		case SSL3_ST_SW_FLUSH:

			/* This code originally checked to see if
			 * any data was pending using BIO_CTRL_INFO
			 * and then flushed. This caused problems
			 * as documented in PR#1939. The proposed
			 * fix doesn't completely resolve this issue
			 * as buggy implementations of BIO_CTRL_PENDING
			 * still exist. So instead we just flush
			 * unconditionally.
			 */

			s->rwstate=SSL_WRITING;
			if (BIO_flush(s->wbio) <= 0)
				{
				ret= -1;
				goto end;
				}
			s->rwstate=SSL_NOTHING;

			s->state=s->s3->tmp.next_state;
			break;

		case SSL3_ST_SR_CERT_A:
		case SSL3_ST_SR_CERT_B:
			if (s->s3->tmp.cert_request)
				{
				ret=ssl3_get_client_certificate(s);
				if (ret <= 0) goto end;
				}
			s->init_num=0;
			s->state=SSL3_ST_SR_KEY_EXCH_A;
			break;

		case SSL3_ST_SR_KEY_EXCH_A:
		case SSL3_ST_SR_KEY_EXCH_B:
			ret=ssl3_get_client_key_exchange(s);
			if (ret <= 0)
				goto end;
			if (ret == 2)
				{
				/* For the ECDH ciphersuites when
				 * the client sends its ECDH pub key in
				 * a certificate, the CertificateVerify
				 * message is not sent.
				 * Also for GOST ciphersuites when
				 * the client uses its key from the certificate
				 * for key exchange.
				 */
#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
				s->state=SSL3_ST_SR_FINISHED_A;
#else
				if (s->s3->next_proto_neg_seen)
					s->state=SSL3_ST_SR_NEXT_PROTO_A;
				else
					s->state=SSL3_ST_SR_FINISHED_A;
#endif
				s->init_num = 0;
				}
			else if (SSL_USE_SIGALGS(s))
				{
				s->state=SSL3_ST_SR_CERT_VRFY_A;
				s->init_num=0;
				if (!s->session->peer)
					break;
				/* For sigalgs freeze the handshake buffer
				 * at this point and digest cached records.
				 */
				if (!s->s3->handshake_buffer)
					{
					SSLerr(SSL_F_SSL3_ACCEPT,ERR_R_INTERNAL_ERROR);
					return -1;
					}
				s->s3->flags |= TLS1_FLAGS_KEEP_HANDSHAKE;
				if (!ssl3_digest_cached_records(s))
					return -1;
				}
			else
				{
				int offset=0;
				int dgst_num;

				s->state=SSL3_ST_SR_CERT_VRFY_A;
				s->init_num=0;

				/* We need to get hashes here so if there is
				 * a client cert, it can be verified
				 * FIXME - digest processing for CertificateVerify
				 * should be generalized. But it is next step
				 */
				if (s->s3->handshake_buffer)
					if (!ssl3_digest_cached_records(s))
						return -1;
				for (dgst_num=0; dgst_num<SSL_MAX_DIGEST;dgst_num++)	
					if (s->s3->handshake_dgst[dgst_num]) 
						{
						int dgst_size;

						s->method->ssl3_enc->cert_verify_mac(s,EVP_MD_CTX_type(s->s3->handshake_dgst[dgst_num]),&(s->s3->tmp.cert_verify_md[offset]));
						dgst_size=EVP_MD_CTX_size(s->s3->handshake_dgst[dgst_num]);
						if (dgst_size < 0)
							{
							ret = -1;
							goto end;
							}
						offset+=dgst_size;
						}		
				}
			break;

		case SSL3_ST_SR_CERT_VRFY_A:
		case SSL3_ST_SR_CERT_VRFY_B:
			/*
			 * This *should* be the first time we enable CCS, but be
			 * extra careful about surrounding code changes. We need
			 * to set this here because we don't know if we're
			 * expecting a CertificateVerify or not.
			 */
			if (!s->s3->change_cipher_spec)
				s->s3->flags |= SSL3_FLAGS_CCS_OK;
			/* we should decide if we expected this one */
			ret=ssl3_get_cert_verify(s);
			if (ret <= 0) goto end;

#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
			s->state=SSL3_ST_SR_FINISHED_A;
#else
			if (s->s3->next_proto_neg_seen)
				s->state=SSL3_ST_SR_NEXT_PROTO_A;
			else
				s->state=SSL3_ST_SR_FINISHED_A;
#endif
			s->init_num=0;
			break;

#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
		case SSL3_ST_SR_NEXT_PROTO_A:
		case SSL3_ST_SR_NEXT_PROTO_B:
			/*
			 * Enable CCS for resumed handshakes with NPN.
			 * In a full handshake with NPN, we end up here through
			 * SSL3_ST_SR_CERT_VRFY_B, where SSL3_FLAGS_CCS_OK was
			 * already set. Receiving a CCS clears the flag, so make
			 * sure not to re-enable it to ban duplicates.
			 * s->s3->change_cipher_spec is set when a CCS is
			 * processed in s3_pkt.c, and remains set until
			 * the client's Finished message is read.
			 */
			if (!s->s3->change_cipher_spec)
				s->s3->flags |= SSL3_FLAGS_CCS_OK;

			ret=ssl3_get_next_proto(s);
			if (ret <= 0) goto end;
			s->init_num = 0;
			s->state=SSL3_ST_SR_FINISHED_A;
			break;
#endif

		case SSL3_ST_SR_FINISHED_A:
		case SSL3_ST_SR_FINISHED_B:
			/*
			 * Enable CCS for resumed handshakes without NPN.
			 * In a full handshake, we end up here through
			 * SSL3_ST_SR_CERT_VRFY_B, where SSL3_FLAGS_CCS_OK was
			 * already set. Receiving a CCS clears the flag, so make
			 * sure not to re-enable it to ban duplicates.
			 * s->s3->change_cipher_spec is set when a CCS is
			 * processed in s3_pkt.c, and remains set until
			 * the client's Finished message is read.
			 */
			if (!s->s3->change_cipher_spec)
				s->s3->flags |= SSL3_FLAGS_CCS_OK;
			ret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,
				SSL3_ST_SR_FINISHED_B);
			if (ret <= 0) goto end;
			if (s->hit)
				s->state=SSL_ST_OK;
#ifndef OPENSSL_NO_TLSEXT
			else if (s->tlsext_ticket_expected)
				s->state=SSL3_ST_SW_SESSION_TICKET_A;
#endif
			else
				s->state=SSL3_ST_SW_CHANGE_A;
			s->init_num=0;
			break;

#ifndef OPENSSL_NO_TLSEXT
		case SSL3_ST_SW_SESSION_TICKET_A:
		case SSL3_ST_SW_SESSION_TICKET_B:
			ret=ssl3_send_newsession_ticket(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_CHANGE_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_CERT_STATUS_A:
		case SSL3_ST_SW_CERT_STATUS_B:
			ret=ssl3_send_cert_status(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_KEY_EXCH_A;
			s->init_num=0;
			break;

#endif

		case SSL3_ST_SW_CHANGE_A:
		case SSL3_ST_SW_CHANGE_B:

			s->session->cipher=s->s3->tmp.new_cipher;
			if (!s->method->ssl3_enc->setup_key_block(s))
				{ ret= -1; goto end; }

			ret=ssl3_send_change_cipher_spec(s,
				SSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);

			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_FINISHED_A;
			s->init_num=0;

			if (!s->method->ssl3_enc->change_cipher_state(s,
				SSL3_CHANGE_CIPHER_SERVER_WRITE))
				{
				ret= -1;
				goto end;
				}

			break;

		case SSL3_ST_SW_FINISHED_A:
		case SSL3_ST_SW_FINISHED_B:
			ret=ssl3_send_finished(s,
				SSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,
				s->method->ssl3_enc->server_finished_label,
				s->method->ssl3_enc->server_finished_label_len);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_FLUSH;
			if (s->hit)
				{
#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
				s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;
#else
				if (s->s3->next_proto_neg_seen)
					{
					s->s3->tmp.next_state=SSL3_ST_SR_NEXT_PROTO_A;
					}
				else
					s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;
#endif
				}
			else
				s->s3->tmp.next_state=SSL_ST_OK;
			s->init_num=0;
			break;

		case SSL_ST_OK:
			/* clean a few things up */
			ssl3_cleanup_key_block(s);

			BUF_MEM_free(s->init_buf);
			s->init_buf=NULL;

			/* remove buffering on output */
			ssl_free_wbio_buffer(s);

			s->init_num=0;

			if (s->renegotiate == 2) /* skipped if we just sent a HelloRequest */
				{
				s->renegotiate=0;
				s->new_session=0;
				
				ssl_update_cache(s,SSL_SESS_CACHE_SERVER);
				
				s->ctx->stats.sess_accept_good++;
				/* s->server=1; */
				s->handshake_func=ssl3_accept;

				if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);
				}
			
			ret = 1;
			goto end;
			/* break; */

		default:
			SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_UNKNOWN_STATE);
			ret= -1;
			goto end;
			/* break; */
			}
		
		if (!s->s3->tmp.reuse_message && !skip)
			{
			if (s->debug)
				{
				if ((ret=BIO_flush(s->wbio)) <= 0)
					goto end;
				}


			if ((cb != NULL) && (s->state != state))
				{
				new_state=s->state;
				s->state=state;
				cb(s,SSL_CB_ACCEPT_LOOP,1);
				s->state=new_state;
				}
			}
		skip=0;
		}
",C,"			/*
			 * clear this, it may get reset by
			 * send_server_key_exchange
			 */
			s->s3->tmp.use_rsa_tmp=0;
			if (
","			/* clear this, it may get reset by
			 * send_server_key_exchange */
			if ((s->options & SSL_OP_EPHEMERAL_RSA)
#ifndef OPENSSL_NO_KRB5
				&& !(alg_k & SSL_kKRB5)
#endif /* OPENSSL_NO_KRB5 */
				)
				/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key
				 * even when forbidden by protocol specs
				 * (handshake may fail as clients are not required to
				 * be able to handle this) */
				s->s3->tmp.use_rsa_tmp=1;
			else
				s->s3->tmp.use_rsa_tmp=0;
			if (s->s3->tmp.use_rsa_tmp
",,"@@ -453,20 +453,11 @@ int ssl3_accept(SSL *s)
 		case SSL3_ST_SW_KEY_EXCH_B:
 			alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
 
-			/* clear this, it may get reset by
-			 * send_server_key_exchange */
-			if ((s->options & SSL_OP_EPHEMERAL_RSA)
-#ifndef OPENSSL_NO_KRB5
-				&& !(alg_k & SSL_kKRB5)
-#endif /* OPENSSL_NO_KRB5 */
-				)
-				/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key
-				 * even when forbidden by protocol specs
-				 * (handshake may fail as clients are not required to
-				 * be able to handle this) */
-				s->s3->tmp.use_rsa_tmp=1;
-			else
-				s->s3->tmp.use_rsa_tmp=0;
+			/*
+			 * clear this, it may get reset by
+			 * send_server_key_exchange
+			 */
+			s->s3->tmp.use_rsa_tmp=0;
 
 
 			/* only send if a DH key exchange, fortezza or
@@ -480,7 +471,7 @@ int ssl3_accept(SSL *s)
 			 * server certificate contains the server's
 			 * public key for key exchange.
 			 */
-			if (s->s3->tmp.use_rsa_tmp
+			if (
 			/* PSK: send ServerKeyExchange if PSK identity
 			 * hint if provided */
 #ifndef OPENSSL_NO_PSK",openssl,ce325c60c74b0fa784f5872404b722e120e5cab0,b15f8769644b00ef7283521593360b7b2135cb63,1,"int ssl3_accept(SSL *s)
	{
	BUF_MEM *buf;
	unsigned long alg_k,Time=(unsigned long)time(NULL);
	void (*cb)(const SSL *ssl,int type,int val)=NULL;
	int ret= -1;
	int new_state,state,skip=0;

	RAND_add(&Time,sizeof(Time),0);
	ERR_clear_error();
	clear_sys_error();

	if (s->info_callback != NULL)
		cb=s->info_callback;
	else if (s->ctx->info_callback != NULL)
		cb=s->ctx->info_callback;

	/* init things to blank */
	s->in_handshake++;
	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);

	if (s->cert == NULL)
		{
		SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_NO_CERTIFICATE_SET);
		return(-1);
		}

#ifndef OPENSSL_NO_HEARTBEATS
	/* If we're awaiting a HeartbeatResponse, pretend we
	 * already got and don't await it anymore, because
	 * Heartbeats don't make sense during handshakes anyway.
	 */
	if (s->tlsext_hb_pending)
		{
		s->tlsext_hb_pending = 0;
		s->tlsext_hb_seq++;
		}
#endif

	for (;;)
		{
		state=s->state;

		switch (s->state)
			{
		case SSL_ST_RENEGOTIATE:
			s->renegotiate=1;
			/* s->state=SSL_ST_ACCEPT; */

		case SSL_ST_BEFORE:
		case SSL_ST_ACCEPT:
		case SSL_ST_BEFORE|SSL_ST_ACCEPT:
		case SSL_ST_OK|SSL_ST_ACCEPT:

			s->server=1;
			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);

			if ((s->version>>8) != 3)
				{
				SSLerr(SSL_F_SSL3_ACCEPT, ERR_R_INTERNAL_ERROR);
				return -1;
				}

			if (!ssl_security(s, SSL_SECOP_VERSION, 0,
							s->version, NULL))
				{
				SSLerr(SSL_F_SSL3_ACCEPT, SSL_R_VERSION_TOO_LOW);
				return -1;
				}

			s->type=SSL_ST_ACCEPT;

			if (s->init_buf == NULL)
				{
				if ((buf=BUF_MEM_new()) == NULL)
					{
					ret= -1;
					goto end;
					}
				if (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))
					{
					BUF_MEM_free(buf);
					ret= -1;
					goto end;
					}
				s->init_buf=buf;
				}

			if (!ssl3_setup_buffers(s))
				{
				ret= -1;
				goto end;
				}

			s->init_num=0;
			s->s3->flags &= ~TLS1_FLAGS_SKIP_CERT_VERIFY;
			s->s3->flags &= ~SSL3_FLAGS_CCS_OK;
			/* Should have been reset by ssl3_get_finished, too. */
			s->s3->change_cipher_spec = 0;

			if (s->state != SSL_ST_RENEGOTIATE)
				{
				/* Ok, we now need to push on a buffering BIO so that
				 * the output is sent in a way that TCP likes :-)
				 */
				if (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }
				
				ssl3_init_finished_mac(s);
				s->state=SSL3_ST_SR_CLNT_HELLO_A;
				s->ctx->stats.sess_accept++;
				}
			else if (!s->s3->send_connection_binding &&
				!(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))
				{
				/* Server attempting to renegotiate with
				 * client that doesn't support secure
				 * renegotiation.
				 */
				SSLerr(SSL_F_SSL3_ACCEPT, SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);
				ret = -1;
				goto end;
				}
			else
				{
				/* s->state == SSL_ST_RENEGOTIATE,
				 * we will just send a HelloRequest */
				s->ctx->stats.sess_accept_renegotiate++;
				s->state=SSL3_ST_SW_HELLO_REQ_A;
				}
			break;

		case SSL3_ST_SW_HELLO_REQ_A:
		case SSL3_ST_SW_HELLO_REQ_B:

			s->shutdown=0;
			ret=ssl3_send_hello_request(s);
			if (ret <= 0) goto end;
			s->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C;
			s->state=SSL3_ST_SW_FLUSH;
			s->init_num=0;

			ssl3_init_finished_mac(s);
			break;

		case SSL3_ST_SW_HELLO_REQ_C:
			s->state=SSL_ST_OK;
			break;

		case SSL3_ST_SR_CLNT_HELLO_A:
		case SSL3_ST_SR_CLNT_HELLO_B:
		case SSL3_ST_SR_CLNT_HELLO_C:

			ret=ssl3_get_client_hello(s);
			if (ret <= 0) goto end;
#ifndef OPENSSL_NO_SRP
			s->state = SSL3_ST_SR_CLNT_HELLO_D;
		case SSL3_ST_SR_CLNT_HELLO_D:
			{
			int al;
			if ((ret = ssl_check_srp_ext_ClientHello(s,&al))  < 0)
					{
					/* callback indicates firther work to be done */
					s->rwstate=SSL_X509_LOOKUP;
					goto end;
					}
			if (ret != SSL_ERROR_NONE)
				{
				ssl3_send_alert(s,SSL3_AL_FATAL,al);	
				/* This is not really an error but the only means to
                                   for a client to detect whether srp is supported. */
 				   if (al != TLS1_AD_UNKNOWN_PSK_IDENTITY) 	
					SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_CLIENTHELLO_TLSEXT);			
				ret = SSL_TLSEXT_ERR_ALERT_FATAL;			
				ret= -1;
				goto end;	
				}
			}
#endif		
			
			s->renegotiate = 2;
			s->state=SSL3_ST_SW_SRVR_HELLO_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_SRVR_HELLO_A:
		case SSL3_ST_SW_SRVR_HELLO_B:
			ret=ssl3_send_server_hello(s);
			if (ret <= 0) goto end;
#ifndef OPENSSL_NO_TLSEXT
			if (s->hit)
				{
				if (s->tlsext_ticket_expected)
					s->state=SSL3_ST_SW_SESSION_TICKET_A;
				else
					s->state=SSL3_ST_SW_CHANGE_A;
				}
#else
			if (s->hit)
					s->state=SSL3_ST_SW_CHANGE_A;
#endif
			else
					s->state = SSL3_ST_SW_CERT_A;
			s->init_num = 0;
			break;

		case SSL3_ST_SW_CERT_A:
		case SSL3_ST_SW_CERT_B:
			/* Check if it is anon DH or anon ECDH, */
			/* normal PSK or KRB5 or SRP */
			if (!(s->s3->tmp.new_cipher->algorithm_auth & (SSL_aNULL|SSL_aKRB5|SSL_aSRP))
				&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
				{
				ret=ssl3_send_server_certificate(s);
				if (ret <= 0) goto end;
#ifndef OPENSSL_NO_TLSEXT
				if (s->tlsext_status_expected)
					s->state=SSL3_ST_SW_CERT_STATUS_A;
				else
					s->state=SSL3_ST_SW_KEY_EXCH_A;
				}
			else
				{
				skip = 1;
				s->state=SSL3_ST_SW_KEY_EXCH_A;
				}
#else
				}
			else
				skip=1;

			s->state=SSL3_ST_SW_KEY_EXCH_A;
#endif
			s->init_num=0;
			break;

		case SSL3_ST_SW_KEY_EXCH_A:
 		case SSL3_ST_SW_KEY_EXCH_B:
 			alg_k = s->s3->tmp.new_cipher->algorithm_mkey;
 
//flaw_line_below:
			/* clear this, it may get reset by
//flaw_line_below:
			 * send_server_key_exchange */
//flaw_line_below:
			if ((s->options & SSL_OP_EPHEMERAL_RSA)
//flaw_line_below:
#ifndef OPENSSL_NO_KRB5
//flaw_line_below:
				&& !(alg_k & SSL_kKRB5)
//flaw_line_below:
#endif /* OPENSSL_NO_KRB5 */
//flaw_line_below:
				)
//flaw_line_below:
				/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key
//flaw_line_below:
				 * even when forbidden by protocol specs
//flaw_line_below:
				 * (handshake may fail as clients are not required to
//flaw_line_below:
				 * be able to handle this) */
//flaw_line_below:
				s->s3->tmp.use_rsa_tmp=1;
//flaw_line_below:
			else
//flaw_line_below:
				s->s3->tmp.use_rsa_tmp=0;
//fix_flaw_line_below:
//			/*
//fix_flaw_line_below:
//			 * clear this, it may get reset by
//fix_flaw_line_below:
//			 * send_server_key_exchange
//fix_flaw_line_below:
//			 */
//fix_flaw_line_below:
//			s->s3->tmp.use_rsa_tmp=0;
 
 
 			/* only send if a DH key exchange, fortezza or
			 * RSA but we have a sign only certificate
			 *
			 * PSK: may send PSK identity hints
			 *
			 * For ECC ciphersuites, we send a serverKeyExchange
			 * message only if the cipher suite is either
			 * ECDH-anon or ECDHE. In other cases, the
 			 * server certificate contains the server's
 			 * public key for key exchange.
 			 */
//flaw_line_below:
			if (s->s3->tmp.use_rsa_tmp
//fix_flaw_line_below:
//			if (
 			/* PSK: send ServerKeyExchange if PSK identity
 			 * hint if provided */
 #ifndef OPENSSL_NO_PSK
			    || ((alg_k & SSL_kPSK) && s->ctx->psk_identity_hint)
#endif
#ifndef OPENSSL_NO_SRP
			    /* SRP: send ServerKeyExchange */
			    || (alg_k & SSL_kSRP)
#endif
			    || (alg_k & SSL_kDHE)
			    || (alg_k & SSL_kECDHE)
			    || ((alg_k & SSL_kRSA)
				&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL
				    || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)
					&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)
					)
				    )
				)
			    )
				{
				ret=ssl3_send_server_key_exchange(s);
				if (ret <= 0) goto end;
				}
			else
				skip=1;

			s->state=SSL3_ST_SW_CERT_REQ_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_CERT_REQ_A:
		case SSL3_ST_SW_CERT_REQ_B:
			if (/* don't request cert unless asked for it: */
				!(s->verify_mode & SSL_VERIFY_PEER) ||
				/* if SSL_VERIFY_CLIENT_ONCE is set,
				 * don't request cert during re-negotiation: */
				((s->session->peer != NULL) &&
				 (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||
				/* never request cert in anonymous ciphersuites
				 * (see section ""Certificate request"" in SSL 3 drafts
				 * and in RFC 2246): */
				((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&
				 /* ... except when the application insists on verification
				  * (against the specs, but s3_clnt.c accepts this for SSL 3) */
				 !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||
				 /* never request cert in Kerberos ciphersuites */
				(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5) ||
				/* don't request certificate for SRP auth */
				(s->s3->tmp.new_cipher->algorithm_auth & SSL_aSRP)
				/* With normal PSK Certificates and
				 * Certificate Requests are omitted */
				|| (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))
				{
				/* no cert request */
				skip=1;
				s->s3->tmp.cert_request=0;
				s->state=SSL3_ST_SW_SRVR_DONE_A;
				if (s->s3->handshake_buffer)
					if (!ssl3_digest_cached_records(s))
						return -1;
				}
			else
				{
				s->s3->tmp.cert_request=1;
				ret=ssl3_send_certificate_request(s);
				if (ret <= 0) goto end;
#ifndef NETSCAPE_HANG_BUG
				s->state=SSL3_ST_SW_SRVR_DONE_A;
#else
				s->state=SSL3_ST_SW_FLUSH;
				s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
#endif
				s->init_num=0;
				}
			break;

		case SSL3_ST_SW_SRVR_DONE_A:
		case SSL3_ST_SW_SRVR_DONE_B:
			ret=ssl3_send_server_done(s);
			if (ret <= 0) goto end;
			s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
			s->state=SSL3_ST_SW_FLUSH;
			s->init_num=0;
			break;
		
		case SSL3_ST_SW_FLUSH:

			/* This code originally checked to see if
			 * any data was pending using BIO_CTRL_INFO
			 * and then flushed. This caused problems
			 * as documented in PR#1939. The proposed
			 * fix doesn't completely resolve this issue
			 * as buggy implementations of BIO_CTRL_PENDING
			 * still exist. So instead we just flush
			 * unconditionally.
			 */

			s->rwstate=SSL_WRITING;
			if (BIO_flush(s->wbio) <= 0)
				{
				ret= -1;
				goto end;
				}
			s->rwstate=SSL_NOTHING;

			s->state=s->s3->tmp.next_state;
			break;

		case SSL3_ST_SR_CERT_A:
		case SSL3_ST_SR_CERT_B:
			if (s->s3->tmp.cert_request)
				{
				ret=ssl3_get_client_certificate(s);
				if (ret <= 0) goto end;
				}
			s->init_num=0;
			s->state=SSL3_ST_SR_KEY_EXCH_A;
			break;

		case SSL3_ST_SR_KEY_EXCH_A:
		case SSL3_ST_SR_KEY_EXCH_B:
			ret=ssl3_get_client_key_exchange(s);
			if (ret <= 0)
				goto end;
			if (ret == 2)
				{
				/* For the ECDH ciphersuites when
				 * the client sends its ECDH pub key in
				 * a certificate, the CertificateVerify
				 * message is not sent.
				 * Also for GOST ciphersuites when
				 * the client uses its key from the certificate
				 * for key exchange.
				 */
#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
				s->state=SSL3_ST_SR_FINISHED_A;
#else
				if (s->s3->next_proto_neg_seen)
					s->state=SSL3_ST_SR_NEXT_PROTO_A;
				else
					s->state=SSL3_ST_SR_FINISHED_A;
#endif
				s->init_num = 0;
				}
			else if (SSL_USE_SIGALGS(s))
				{
				s->state=SSL3_ST_SR_CERT_VRFY_A;
				s->init_num=0;
				if (!s->session->peer)
					break;
				/* For sigalgs freeze the handshake buffer
				 * at this point and digest cached records.
				 */
				if (!s->s3->handshake_buffer)
					{
					SSLerr(SSL_F_SSL3_ACCEPT,ERR_R_INTERNAL_ERROR);
					return -1;
					}
				s->s3->flags |= TLS1_FLAGS_KEEP_HANDSHAKE;
				if (!ssl3_digest_cached_records(s))
					return -1;
				}
			else
				{
				int offset=0;
				int dgst_num;

				s->state=SSL3_ST_SR_CERT_VRFY_A;
				s->init_num=0;

				/* We need to get hashes here so if there is
				 * a client cert, it can be verified
				 * FIXME - digest processing for CertificateVerify
				 * should be generalized. But it is next step
				 */
				if (s->s3->handshake_buffer)
					if (!ssl3_digest_cached_records(s))
						return -1;
				for (dgst_num=0; dgst_num<SSL_MAX_DIGEST;dgst_num++)	
					if (s->s3->handshake_dgst[dgst_num]) 
						{
						int dgst_size;

						s->method->ssl3_enc->cert_verify_mac(s,EVP_MD_CTX_type(s->s3->handshake_dgst[dgst_num]),&(s->s3->tmp.cert_verify_md[offset]));
						dgst_size=EVP_MD_CTX_size(s->s3->handshake_dgst[dgst_num]);
						if (dgst_size < 0)
							{
							ret = -1;
							goto end;
							}
						offset+=dgst_size;
						}		
				}
			break;

		case SSL3_ST_SR_CERT_VRFY_A:
		case SSL3_ST_SR_CERT_VRFY_B:
			/*
			 * This *should* be the first time we enable CCS, but be
			 * extra careful about surrounding code changes. We need
			 * to set this here because we don't know if we're
			 * expecting a CertificateVerify or not.
			 */
			if (!s->s3->change_cipher_spec)
				s->s3->flags |= SSL3_FLAGS_CCS_OK;
			/* we should decide if we expected this one */
			ret=ssl3_get_cert_verify(s);
			if (ret <= 0) goto end;

#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
			s->state=SSL3_ST_SR_FINISHED_A;
#else
			if (s->s3->next_proto_neg_seen)
				s->state=SSL3_ST_SR_NEXT_PROTO_A;
			else
				s->state=SSL3_ST_SR_FINISHED_A;
#endif
			s->init_num=0;
			break;

#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
		case SSL3_ST_SR_NEXT_PROTO_A:
		case SSL3_ST_SR_NEXT_PROTO_B:
			/*
			 * Enable CCS for resumed handshakes with NPN.
			 * In a full handshake with NPN, we end up here through
			 * SSL3_ST_SR_CERT_VRFY_B, where SSL3_FLAGS_CCS_OK was
			 * already set. Receiving a CCS clears the flag, so make
			 * sure not to re-enable it to ban duplicates.
			 * s->s3->change_cipher_spec is set when a CCS is
			 * processed in s3_pkt.c, and remains set until
			 * the client's Finished message is read.
			 */
			if (!s->s3->change_cipher_spec)
				s->s3->flags |= SSL3_FLAGS_CCS_OK;

			ret=ssl3_get_next_proto(s);
			if (ret <= 0) goto end;
			s->init_num = 0;
			s->state=SSL3_ST_SR_FINISHED_A;
			break;
#endif

		case SSL3_ST_SR_FINISHED_A:
		case SSL3_ST_SR_FINISHED_B:
			/*
			 * Enable CCS for resumed handshakes without NPN.
			 * In a full handshake, we end up here through
			 * SSL3_ST_SR_CERT_VRFY_B, where SSL3_FLAGS_CCS_OK was
			 * already set. Receiving a CCS clears the flag, so make
			 * sure not to re-enable it to ban duplicates.
			 * s->s3->change_cipher_spec is set when a CCS is
			 * processed in s3_pkt.c, and remains set until
			 * the client's Finished message is read.
			 */
			if (!s->s3->change_cipher_spec)
				s->s3->flags |= SSL3_FLAGS_CCS_OK;
			ret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,
				SSL3_ST_SR_FINISHED_B);
			if (ret <= 0) goto end;
			if (s->hit)
				s->state=SSL_ST_OK;
#ifndef OPENSSL_NO_TLSEXT
			else if (s->tlsext_ticket_expected)
				s->state=SSL3_ST_SW_SESSION_TICKET_A;
#endif
			else
				s->state=SSL3_ST_SW_CHANGE_A;
			s->init_num=0;
			break;

#ifndef OPENSSL_NO_TLSEXT
		case SSL3_ST_SW_SESSION_TICKET_A:
		case SSL3_ST_SW_SESSION_TICKET_B:
			ret=ssl3_send_newsession_ticket(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_CHANGE_A;
			s->init_num=0;
			break;

		case SSL3_ST_SW_CERT_STATUS_A:
		case SSL3_ST_SW_CERT_STATUS_B:
			ret=ssl3_send_cert_status(s);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_KEY_EXCH_A;
			s->init_num=0;
			break;

#endif

		case SSL3_ST_SW_CHANGE_A:
		case SSL3_ST_SW_CHANGE_B:

			s->session->cipher=s->s3->tmp.new_cipher;
			if (!s->method->ssl3_enc->setup_key_block(s))
				{ ret= -1; goto end; }

			ret=ssl3_send_change_cipher_spec(s,
				SSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);

			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_FINISHED_A;
			s->init_num=0;

			if (!s->method->ssl3_enc->change_cipher_state(s,
				SSL3_CHANGE_CIPHER_SERVER_WRITE))
				{
				ret= -1;
				goto end;
				}

			break;

		case SSL3_ST_SW_FINISHED_A:
		case SSL3_ST_SW_FINISHED_B:
			ret=ssl3_send_finished(s,
				SSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,
				s->method->ssl3_enc->server_finished_label,
				s->method->ssl3_enc->server_finished_label_len);
			if (ret <= 0) goto end;
			s->state=SSL3_ST_SW_FLUSH;
			if (s->hit)
				{
#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
				s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;
#else
				if (s->s3->next_proto_neg_seen)
					{
					s->s3->tmp.next_state=SSL3_ST_SR_NEXT_PROTO_A;
					}
				else
					s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;
#endif
				}
			else
				s->s3->tmp.next_state=SSL_ST_OK;
			s->init_num=0;
			break;

		case SSL_ST_OK:
			/* clean a few things up */
			ssl3_cleanup_key_block(s);

			BUF_MEM_free(s->init_buf);
			s->init_buf=NULL;

			/* remove buffering on output */
			ssl_free_wbio_buffer(s);

			s->init_num=0;

			if (s->renegotiate == 2) /* skipped if we just sent a HelloRequest */
				{
				s->renegotiate=0;
				s->new_session=0;
				
				ssl_update_cache(s,SSL_SESS_CACHE_SERVER);
				
				s->ctx->stats.sess_accept_good++;
				/* s->server=1; */
				s->handshake_func=ssl3_accept;

				if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);
				}
			
			ret = 1;
			goto end;
			/* break; */

		default:
			SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_UNKNOWN_STATE);
			ret= -1;
			goto end;
			/* break; */
			}
		
		if (!s->s3->tmp.reuse_message && !skip)
			{
			if (s->debug)
				{
				if ((ret=BIO_flush(s->wbio)) <= 0)
					goto end;
				}


			if ((cb != NULL) && (s->state != state))
				{
				new_state=s->state;
				s->state=state;
				cb(s,SSL_CB_ACCEPT_LOOP,1);
				s->state=new_state;
				}
			}
		skip=0;
		}
"
2229,179965,,Remote,Not required,,CVE-2014-8275,https://www.cvedetails.com/cve/CVE-2014-8275/,CWE-310,Low,,Partial,,2015-01-08,5.0,"OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not enforce certain constraints on certificate data, which allows remote attackers to defeat a fingerprint-based certificate-blacklist protection mechanism by including crafted data within a certificate's unsigned portion, related to crypto/asn1/a_verify.c, crypto/dsa/dsa_asn1.c, crypto/ecdsa/ecs_vrf.c, and crypto/x509/x_all.c.",2017-11-14,,1,https://github.com/openssl/openssl/commit/cb62ab4b17818fe66d2fed0a7fe71969131c811b,cb62ab4b17818fe66d2fed0a7fe71969131c811b,"use correct function name

Reviewed-by: Rich Salz <rsalz@openssl.org>
Reviewed-by: Matt Caswell <matt@openssl.org>",1,crypto/asn1/a_verify.c,"{""sha"": ""e85d4d2b7764c17e1f9629413a72b29e86cfe500"", ""filename"": ""crypto/asn1/a_verify.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/openssl/openssl/blob/cb62ab4b17818fe66d2fed0a7fe71969131c811b/crypto/asn1/a_verify.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/cb62ab4b17818fe66d2fed0a7fe71969131c811b/crypto/asn1/a_verify.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/asn1/a_verify.c?ref=cb62ab4b17818fe66d2fed0a7fe71969131c811b"", ""patch"": ""@@ -158,7 +158,7 @@ int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,\n \n \tif (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)\n \t\t{\n-\t\tASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);\n+\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);\n \t\treturn -1;\n \t\t}\n ""}","int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,
		ASN1_BIT_STRING *signature, void *asn, EVP_PKEY *pkey)
	{
	EVP_MD_CTX ctx;
	unsigned char *buf_in=NULL;
	int ret= -1,inl;

	int mdnid, pknid;

	if (!pkey)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);
		return -1;
		}
 
 	if (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)
 		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);
 		return -1;
 		}
 
	EVP_MD_CTX_init(&ctx);

	/* Convert signature OID into digest and public key OIDs */
	if (!OBJ_find_sigid_algs(OBJ_obj2nid(a->algorithm), &mdnid, &pknid))
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);
		goto err;
		}
	if (mdnid == NID_undef)
		{
		if (!pkey->ameth || !pkey->ameth->item_verify)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);
			goto err;
			}
		ret = pkey->ameth->item_verify(&ctx, it, asn, a,
							signature, pkey);
		/* Return value of 2 means carry on, anything else means we
		 * exit straight away: either a fatal error of the underlying
		 * verification routine handles all verification.
		 */
		if (ret != 2)
			goto err;
		ret = -1;
		}
	else
		{
		const EVP_MD *type;
		type=EVP_get_digestbynid(mdnid);
		if (type == NULL)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);
			goto err;
			}

		/* Check public key OID matches public key type */
		if (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);
			goto err;
			}

		if (!EVP_DigestVerifyInit(&ctx, NULL, type, NULL, pkey))
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
			ret=0;
			goto err;
			}

		}

	inl = ASN1_item_i2d(asn, &buf_in, it);
	
	if (buf_in == NULL)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);
		goto err;
		}

	ret = EVP_DigestVerifyUpdate(&ctx,buf_in,inl);

	OPENSSL_cleanse(buf_in,(unsigned int)inl);
	OPENSSL_free(buf_in);

	if (!ret)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		goto err;
		}
	ret = -1;

	if (EVP_DigestVerifyFinal(&ctx,signature->data,
			(size_t)signature->length) <= 0)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}
	/* we don't need to zero the 'ctx' because we just checked
	 * public information */
	/* memset(&ctx,0,sizeof(ctx)); */
	ret=1;
err:
	EVP_MD_CTX_cleanup(&ctx);
	return(ret);
	}
","int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,
		ASN1_BIT_STRING *signature, void *asn, EVP_PKEY *pkey)
	{
	EVP_MD_CTX ctx;
	unsigned char *buf_in=NULL;
	int ret= -1,inl;

	int mdnid, pknid;

	if (!pkey)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);
		return -1;
		}
 
 	if (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)
 		{
		ASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);
 		return -1;
 		}
 
	EVP_MD_CTX_init(&ctx);

	/* Convert signature OID into digest and public key OIDs */
	if (!OBJ_find_sigid_algs(OBJ_obj2nid(a->algorithm), &mdnid, &pknid))
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);
		goto err;
		}
	if (mdnid == NID_undef)
		{
		if (!pkey->ameth || !pkey->ameth->item_verify)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);
			goto err;
			}
		ret = pkey->ameth->item_verify(&ctx, it, asn, a,
							signature, pkey);
		/* Return value of 2 means carry on, anything else means we
		 * exit straight away: either a fatal error of the underlying
		 * verification routine handles all verification.
		 */
		if (ret != 2)
			goto err;
		ret = -1;
		}
	else
		{
		const EVP_MD *type;
		type=EVP_get_digestbynid(mdnid);
		if (type == NULL)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);
			goto err;
			}

		/* Check public key OID matches public key type */
		if (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);
			goto err;
			}

		if (!EVP_DigestVerifyInit(&ctx, NULL, type, NULL, pkey))
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
			ret=0;
			goto err;
			}

		}

	inl = ASN1_item_i2d(asn, &buf_in, it);
	
	if (buf_in == NULL)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);
		goto err;
		}

	ret = EVP_DigestVerifyUpdate(&ctx,buf_in,inl);

	OPENSSL_cleanse(buf_in,(unsigned int)inl);
	OPENSSL_free(buf_in);

	if (!ret)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		goto err;
		}
	ret = -1;

	if (EVP_DigestVerifyFinal(&ctx,signature->data,
			(size_t)signature->length) <= 0)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}
	/* we don't need to zero the 'ctx' because we just checked
	 * public information */
	/* memset(&ctx,0,sizeof(ctx)); */
	ret=1;
err:
	EVP_MD_CTX_cleanup(&ctx);
	return(ret);
	}
",C,"		ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);
","		ASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);
",,"@@ -158,7 +158,7 @@ int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,
 
 	if (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)
 		{
-		ASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);
+		ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);
 		return -1;
 		}
 ",openssl,cb62ab4b17818fe66d2fed0a7fe71969131c811b,77ff1f3b8bfaa348956c5096a2b829f2e767b4f1,1,"int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,
		ASN1_BIT_STRING *signature, void *asn, EVP_PKEY *pkey)
	{
	EVP_MD_CTX ctx;
	unsigned char *buf_in=NULL;
	int ret= -1,inl;

	int mdnid, pknid;

	if (!pkey)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);
		return -1;
		}
 
 	if (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)
 		{
//flaw_line_below:
		ASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);
//fix_flaw_line_below:
//		ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);
 		return -1;
 		}
 
	EVP_MD_CTX_init(&ctx);

	/* Convert signature OID into digest and public key OIDs */
	if (!OBJ_find_sigid_algs(OBJ_obj2nid(a->algorithm), &mdnid, &pknid))
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);
		goto err;
		}
	if (mdnid == NID_undef)
		{
		if (!pkey->ameth || !pkey->ameth->item_verify)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);
			goto err;
			}
		ret = pkey->ameth->item_verify(&ctx, it, asn, a,
							signature, pkey);
		/* Return value of 2 means carry on, anything else means we
		 * exit straight away: either a fatal error of the underlying
		 * verification routine handles all verification.
		 */
		if (ret != 2)
			goto err;
		ret = -1;
		}
	else
		{
		const EVP_MD *type;
		type=EVP_get_digestbynid(mdnid);
		if (type == NULL)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);
			goto err;
			}

		/* Check public key OID matches public key type */
		if (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);
			goto err;
			}

		if (!EVP_DigestVerifyInit(&ctx, NULL, type, NULL, pkey))
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
			ret=0;
			goto err;
			}

		}

	inl = ASN1_item_i2d(asn, &buf_in, it);
	
	if (buf_in == NULL)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);
		goto err;
		}

	ret = EVP_DigestVerifyUpdate(&ctx,buf_in,inl);

	OPENSSL_cleanse(buf_in,(unsigned int)inl);
	OPENSSL_free(buf_in);

	if (!ret)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		goto err;
		}
	ret = -1;

	if (EVP_DigestVerifyFinal(&ctx,signature->data,
			(size_t)signature->length) <= 0)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}
	/* we don't need to zero the 'ctx' because we just checked
	 * public information */
	/* memset(&ctx,0,sizeof(ctx)); */
	ret=1;
err:
	EVP_MD_CTX_cleanup(&ctx);
	return(ret);
	}
"
2262,179998,,Remote,Not required,,CVE-2014-3572,https://www.cvedetails.com/cve/CVE-2014-3572/,CWE-310,Low,,Partial,,2015-01-08,5.0,"The ssl3_get_key_exchange function in s3_clnt.c in OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k allows remote SSL servers to conduct ECDHE-to-ECDH downgrade attacks and trigger a loss of forward secrecy by omitting the ServerKeyExchange message.",2017-11-14,,15,https://github.com/openssl/openssl/commit/b15f8769644b00ef7283521593360b7b2135cb63,b15f8769644b00ef7283521593360b7b2135cb63,"ECDH downgrade bug fix.

Fix bug where an OpenSSL client would accept a handshake using an
ephemeral ECDH ciphersuites with the server key exchange message omitted.

Thanks to Karthikeyan Bhargavan for reporting this issue.

CVE-2014-3572
Reviewed-by: Matt Caswell <matt@openssl.org>",3,ssl/s3_clnt.c,"{""sha"": ""0252eb570671c68678128e4c231c651b4b16d093"", ""filename"": ""CHANGES"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/openssl/openssl/blob/b15f8769644b00ef7283521593360b7b2135cb63/CHANGES"", ""raw_url"": ""https://github.com/openssl/openssl/raw/b15f8769644b00ef7283521593360b7b2135cb63/CHANGES"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/CHANGES?ref=b15f8769644b00ef7283521593360b7b2135cb63"", ""patch"": ""@@ -659,6 +659,13 @@\n \n  Changes between 1.0.1j and 1.0.1k [xx XXX xxxx]\n \n+  *) Abort handshake if server key exchange message is omitted for ephemeral\n+     ECDH ciphersuites.\n+\n+     Thanks to Karthikeyan Bhargavan for reporting this issue.\n+     (CVE-2014-3572)\n+     [Steve Henson]\n+\n   *) Ensure that the session ID context of an SSL is updated when its\n      SSL_CTX is updated via SSL_set_SSL_CTX.\n ""}<_**next**_>{""sha"": ""2313fbc1e749c94003330c6d12812b0f7997b5a2"", ""filename"": ""ssl/s3_clnt.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 3, ""changes"": 18, ""blob_url"": ""https://github.com/openssl/openssl/blob/b15f8769644b00ef7283521593360b7b2135cb63/ssl/s3_clnt.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/b15f8769644b00ef7283521593360b7b2135cb63/ssl/s3_clnt.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/ssl/s3_clnt.c?ref=b15f8769644b00ef7283521593360b7b2135cb63"", ""patch"": ""@@ -1376,6 +1376,8 @@ int ssl3_get_key_exchange(SSL *s)\n \tint encoded_pt_len = 0;\n #endif\n \n+\tEVP_MD_CTX_init(&md_ctx);\n+\n \t/* use same message size as in ssl3_get_certificate_request()\n \t * as ServerKeyExchange message may be skipped */\n \tn=s->method->ssl_get_message(s,\n@@ -1386,14 +1388,26 @@ int ssl3_get_key_exchange(SSL *s)\n \t\t&ok);\n \tif (!ok) return((int)n);\n \n+\talg_k=s->s3->tmp.new_cipher->algorithm_mkey;\n+\n \tif (s->s3->tmp.message_type != SSL3_MT_SERVER_KEY_EXCHANGE)\n \t\t{\n+\t\t/*\n+\t\t * Can't skip server key exchange if this is an ephemeral\n+\t\t * ciphersuite.\n+\t\t */\n+\t\tif (alg_k & (SSL_kDHE|SSL_kECDHE))\n+\t\t\t{\n+\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);\n+\t\t\tal = SSL_AD_UNEXPECTED_MESSAGE;\n+\t\t\tgoto f_err;\n+\t\t\t}\n #ifndef OPENSSL_NO_PSK\n \t\t/* In plain PSK ciphersuite, ServerKeyExchange can be\n \t\t   omitted if no identity hint is sent. Set\n \t\t   session->sess_cert anyway to avoid problems\n \t\t   later.*/\n-\t\tif (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)\n+\t\tif (alg_k & SSL_kPSK)\n \t\t\t{\n \t\t\ts->session->sess_cert=ssl_sess_cert_new();\n \t\t\tif (s->ctx->psk_identity_hint)\n@@ -1438,9 +1452,7 @@ int ssl3_get_key_exchange(SSL *s)\n \t/* Total length of the parameters including the length prefix */\n \tparam_len=0;\n \n-\talg_k=s->s3->tmp.new_cipher->algorithm_mkey;\n \talg_a=s->s3->tmp.new_cipher->algorithm_auth;\n-\tEVP_MD_CTX_init(&md_ctx);\n \n \tal=SSL_AD_DECODE_ERROR;\n ""}","int ssl3_get_key_exchange(SSL *s)
	{
#ifndef OPENSSL_NO_RSA
	unsigned char *q,md_buf[EVP_MAX_MD_SIZE*2];
#endif
	EVP_MD_CTX md_ctx;
	unsigned char *param,*p;
	int al,j,ok;
	long i,param_len,n,alg_k,alg_a;
	EVP_PKEY *pkey=NULL;
	const EVP_MD *md = NULL;
#ifndef OPENSSL_NO_RSA
	RSA *rsa=NULL;
#endif
#ifndef OPENSSL_NO_DH
	DH *dh=NULL;
#endif
#ifndef OPENSSL_NO_ECDH
	EC_KEY *ecdh = NULL;
	BN_CTX *bn_ctx = NULL;
	EC_POINT *srvr_ecpoint = NULL;
	int curve_nid = 0;
 	int encoded_pt_len = 0;
 #endif
 
	EVP_MD_CTX_init(&md_ctx);

 	/* use same message size as in ssl3_get_certificate_request()
 	 * as ServerKeyExchange message may be skipped */
 	n=s->method->ssl_get_message(s,
		SSL3_ST_CR_KEY_EXCH_A,
		SSL3_ST_CR_KEY_EXCH_B,
		-1,
		s->max_cert_list,
 		&ok);
 	if (!ok) return((int)n);
 
	alg_k=s->s3->tmp.new_cipher->algorithm_mkey;

 	if (s->s3->tmp.message_type != SSL3_MT_SERVER_KEY_EXCHANGE)
 		{
		/*
		 * Can't skip server key exchange if this is an ephemeral
		 * ciphersuite.
		 */
		if (alg_k & (SSL_kDHE|SSL_kECDHE))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);
			al = SSL_AD_UNEXPECTED_MESSAGE;
			goto f_err;
			}
 #ifndef OPENSSL_NO_PSK
 		/* In plain PSK ciphersuite, ServerKeyExchange can be
 		   omitted if no identity hint is sent. Set
 		   session->sess_cert anyway to avoid problems
 		   later.*/
		if (alg_k & SSL_kPSK)
 			{
 			s->session->sess_cert=ssl_sess_cert_new();
 			if (s->ctx->psk_identity_hint)
				OPENSSL_free(s->ctx->psk_identity_hint);
			s->ctx->psk_identity_hint = NULL;
			}
#endif
		s->s3->tmp.reuse_message=1;
		return(1);
		}

	param=p=(unsigned char *)s->init_msg;
	if (s->session->sess_cert != NULL)
		{
#ifndef OPENSSL_NO_RSA
		if (s->session->sess_cert->peer_rsa_tmp != NULL)
			{
			RSA_free(s->session->sess_cert->peer_rsa_tmp);
			s->session->sess_cert->peer_rsa_tmp=NULL;
			}
#endif
#ifndef OPENSSL_NO_DH
		if (s->session->sess_cert->peer_dh_tmp)
			{
			DH_free(s->session->sess_cert->peer_dh_tmp);
			s->session->sess_cert->peer_dh_tmp=NULL;
			}
#endif
#ifndef OPENSSL_NO_ECDH
		if (s->session->sess_cert->peer_ecdh_tmp)
			{
			EC_KEY_free(s->session->sess_cert->peer_ecdh_tmp);
			s->session->sess_cert->peer_ecdh_tmp=NULL;
			}
#endif
		}
	else
		{
		s->session->sess_cert=ssl_sess_cert_new();
		}

 	/* Total length of the parameters including the length prefix */
 	param_len=0;
 
 	alg_a=s->s3->tmp.new_cipher->algorithm_auth;
 
 	al=SSL_AD_DECODE_ERROR;
 
#ifndef OPENSSL_NO_PSK
	if (alg_k & SSL_kPSK)
		{
		char tmp_id_hint[PSK_MAX_IDENTITY_LEN+1];

		param_len = 2;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);

		/* Store PSK identity hint for later use, hint is used
		 * in ssl3_send_client_key_exchange.  Assume that the
		 * maximum length of a PSK identity hint can be as
		 * long as the maximum length of a PSK identity. */
		if (i > PSK_MAX_IDENTITY_LEN)
			{
			al=SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_DATA_LENGTH_TOO_LONG);
			goto f_err;
			}
		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_BAD_PSK_IDENTITY_HINT_LENGTH);
			goto f_err;
			}
		param_len += i;

		/* If received PSK identity hint contains NULL
		 * characters, the hint is truncated from the first
		 * NULL. p may not be ending with NULL, so create a
		 * NULL-terminated string. */
		memcpy(tmp_id_hint, p, i);
		memset(tmp_id_hint+i, 0, PSK_MAX_IDENTITY_LEN+1-i);
		if (s->ctx->psk_identity_hint != NULL)
			OPENSSL_free(s->ctx->psk_identity_hint);
		s->ctx->psk_identity_hint = BUF_strdup(tmp_id_hint);
		if (s->ctx->psk_identity_hint == NULL)
			{
			al=SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);
			goto f_err;
			}	   

		p+=i;
		n-=param_len;
		}
	else
#endif /* !OPENSSL_NO_PSK */
#ifndef OPENSSL_NO_SRP
	if (alg_k & SSL_kSRP)
		{
		param_len = 2;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_N_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(s->srp_ctx.N=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;


		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_G_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(s->srp_ctx.g=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;


		if (1 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 1;

		i = (unsigned int)(p[0]);
		p++;

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_S_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(s->srp_ctx.s=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_B_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(s->srp_ctx.B=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;
		n-=param_len;

		if (!srp_verify_server_param(s, &al))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_PARAMETERS);
			goto f_err;
			}

/* We must check if there is a certificate */
#ifndef OPENSSL_NO_RSA
		if (alg_a & SSL_aRSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
#else
		if (0)
			;
#endif
#ifndef OPENSSL_NO_DSA
		else if (alg_a & SSL_aDSS)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);
#endif
		}
	else
#endif /* !OPENSSL_NO_SRP */
#ifndef OPENSSL_NO_RSA
	if (alg_k & SSL_kRSA)
		{
		if ((rsa=RSA_new()) == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
			goto err;
			}

		param_len = 2;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_MODULUS_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(rsa->n=BN_bin2bn(p,i,rsa->n)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_E_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(rsa->e=BN_bin2bn(p,i,rsa->e)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;
		n-=param_len;

		/* this should be because we are using an export cipher */
		if (alg_a & SSL_aRSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
		else
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
			goto err;
			}
		s->session->sess_cert->peer_rsa_tmp=rsa;
		rsa=NULL;
		}
#else /* OPENSSL_NO_RSA */
	if (0)
		;
#endif
#ifndef OPENSSL_NO_DH
	else if (alg_k & SSL_kDHE)
		{
		if ((dh=DH_new()) == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_DH_LIB);
			goto err;
			}

		param_len = 2;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_P_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(dh->p=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_G_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(dh->g=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_PUB_KEY_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(dh->pub_key=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;
		n-=param_len;

		if (!ssl_security(s, SSL_SECOP_TMP_DH,
						DH_security_bits(dh), 0, dh))
			{
			al=SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_DH_KEY_TOO_SMALL);
			goto f_err;
			}

#ifndef OPENSSL_NO_RSA
		if (alg_a & SSL_aRSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
#else
		if (0)
			;
#endif
#ifndef OPENSSL_NO_DSA
		else if (alg_a & SSL_aDSS)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);
#endif
		/* else anonymous DH, so no certificate or pkey. */

		s->session->sess_cert->peer_dh_tmp=dh;
		dh=NULL;
		}
	else if ((alg_k & SSL_kDHr) || (alg_k & SSL_kDHd))
		{
		al=SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);
		goto f_err;
		}
#endif /* !OPENSSL_NO_DH */

#ifndef OPENSSL_NO_ECDH
	else if (alg_k & SSL_kECDHE)
		{
		EC_GROUP *ngroup;
		const EC_GROUP *group;

		if ((ecdh=EC_KEY_new()) == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
			goto err;
			}

		/* Extract elliptic curve parameters and the
		 * server's ephemeral ECDH public key.
		 * Keep accumulating lengths of various components in
		 * param_len and make sure it never exceeds n.
		 */

		/* XXX: For now we only support named (not generic) curves
		 * and the ECParameters in this case is just three bytes. We
		 * also need one byte for the length of the encoded point
		 */
		param_len=4;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		/* Check curve is one of our preferences, if not server has
		 * sent an invalid curve. ECParameters is 3 bytes.
		 */
		if (!tls1_check_curve(s, p, 3))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_CURVE);
			goto f_err;
			}

		if ((curve_nid = tls1_ec_curve_id2nid(*(p + 2))) == 0) 
			{
			al=SSL_AD_INTERNAL_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);
			goto f_err;
			}

		ngroup = EC_GROUP_new_by_curve_name(curve_nid);
		if (ngroup == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);
			goto err;
			}
		if (EC_KEY_set_group(ecdh, ngroup) == 0)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);
			goto err;
			}
		EC_GROUP_free(ngroup);

		group = EC_KEY_get0_group(ecdh);

		if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&
		    (EC_GROUP_get_degree(group) > 163))
			{
			al=SSL_AD_EXPORT_RESTRICTION;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);
			goto f_err;
			}

		p+=3;

		/* Next, get the encoded ECPoint */
		if (((srvr_ecpoint = EC_POINT_new(group)) == NULL) ||
		    ((bn_ctx = BN_CTX_new()) == NULL))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
			goto err;
			}

		encoded_pt_len = *p;  /* length of encoded point */
		p+=1;

		if ((encoded_pt_len > n - param_len) ||
		    (EC_POINT_oct2point(group, srvr_ecpoint, 
			p, encoded_pt_len, bn_ctx) == 0))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_ECPOINT);
			goto f_err;
			}
		param_len += encoded_pt_len;

		n-=param_len;
		p+=encoded_pt_len;

		/* The ECC/TLS specification does not mention
		 * the use of DSA to sign ECParameters in the server
		 * key exchange message. We do support RSA and ECDSA.
		 */
		if (0) ;
#ifndef OPENSSL_NO_RSA
		else if (alg_a & SSL_aRSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
#endif
#ifndef OPENSSL_NO_ECDSA
		else if (alg_a & SSL_aECDSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);
#endif
		/* else anonymous ECDH, so no certificate or pkey. */
		EC_KEY_set_public_key(ecdh, srvr_ecpoint);
		s->session->sess_cert->peer_ecdh_tmp=ecdh;
		ecdh=NULL;
		BN_CTX_free(bn_ctx);
		bn_ctx = NULL;
		EC_POINT_free(srvr_ecpoint);
		srvr_ecpoint = NULL;
		}
	else if (alg_k)
		{
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);
		goto f_err;
		}
#endif /* !OPENSSL_NO_ECDH */


	/* p points to the next byte, there are 'n' bytes left */

	/* if it was signed, check the signature */
	if (pkey != NULL)
		{
		if (SSL_USE_SIGALGS(s))
			{
			int rv;
			if (2 > n)
				{
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
					SSL_R_LENGTH_TOO_SHORT);
				goto f_err;
				}
			rv = tls12_check_peer_sigalg(&md, s, p, pkey);
			if (rv == -1)
				goto err;
			else if (rv == 0)
				{
				goto f_err;
				}
#ifdef SSL_DEBUG
fprintf(stderr, ""USING TLSv1.2 HASH %s\n"", EVP_MD_name(md));
#endif
			p += 2;
			n -= 2;
			}
		else
			md = EVP_sha1();

		if (2 > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);
		n-=2;
		j=EVP_PKEY_size(pkey);

		/* Check signature length. If n is 0 then signature is empty */
		if ((i != n) || (n > j) || (n <= 0))
			{
			/* wrong packet length */
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_SIGNATURE_LENGTH);
			goto f_err;
			}

#ifndef OPENSSL_NO_RSA
		if (pkey->type == EVP_PKEY_RSA && !SSL_USE_SIGALGS(s))
			{
			int num;
			unsigned int size;

			j=0;
			q=md_buf;
			for (num=2; num > 0; num--)
				{
				EVP_MD_CTX_set_flags(&md_ctx,
					EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
				EVP_DigestInit_ex(&md_ctx,(num == 2)
					?s->ctx->md5:s->ctx->sha1, NULL);
				EVP_DigestUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
				EVP_DigestUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
				EVP_DigestUpdate(&md_ctx,param,param_len);
				EVP_DigestFinal_ex(&md_ctx,q,&size);
				q+=size;
				j+=size;
				}
			i=RSA_verify(NID_md5_sha1, md_buf, j, p, n,
								pkey->pkey.rsa);
			if (i < 0)
				{
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_DECRYPT);
				goto f_err;
				}
			if (i == 0)
				{
				/* bad signature */
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);
				goto f_err;
				}
			}
		else
#endif
			{
			EVP_VerifyInit_ex(&md_ctx, md, NULL);
			EVP_VerifyUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
			EVP_VerifyUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
			EVP_VerifyUpdate(&md_ctx,param,param_len);
			if (EVP_VerifyFinal(&md_ctx,p,(int)n,pkey) <= 0)
				{
				/* bad signature */
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);
				goto f_err;
				}
			}
		}
	else
		{
		/* aNULL, aSRP or kPSK do not need public keys */
		if (!(alg_a & (SSL_aNULL|SSL_aSRP)) && !(alg_k & SSL_kPSK))
			{
			/* Might be wrong key type, check it */
			if (ssl3_check_cert_and_algorithm(s))
				/* Otherwise this shouldn't happen */
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
			goto err;
			}
		/* still data left over */
		if (n != 0)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_EXTRA_DATA_IN_MESSAGE);
			goto f_err;
			}
		}
	EVP_PKEY_free(pkey);
	EVP_MD_CTX_cleanup(&md_ctx);
	return(1);
f_err:
	ssl3_send_alert(s,SSL3_AL_FATAL,al);
err:
	EVP_PKEY_free(pkey);
#ifndef OPENSSL_NO_RSA
	if (rsa != NULL)
		RSA_free(rsa);
#endif
#ifndef OPENSSL_NO_DH
	if (dh != NULL)
		DH_free(dh);
#endif
#ifndef OPENSSL_NO_ECDH
	BN_CTX_free(bn_ctx);
	EC_POINT_free(srvr_ecpoint);
	if (ecdh != NULL)
		EC_KEY_free(ecdh);
#endif
	EVP_MD_CTX_cleanup(&md_ctx);
	return(-1);
	}
","int ssl3_get_key_exchange(SSL *s)
	{
#ifndef OPENSSL_NO_RSA
	unsigned char *q,md_buf[EVP_MAX_MD_SIZE*2];
#endif
	EVP_MD_CTX md_ctx;
	unsigned char *param,*p;
	int al,j,ok;
	long i,param_len,n,alg_k,alg_a;
	EVP_PKEY *pkey=NULL;
	const EVP_MD *md = NULL;
#ifndef OPENSSL_NO_RSA
	RSA *rsa=NULL;
#endif
#ifndef OPENSSL_NO_DH
	DH *dh=NULL;
#endif
#ifndef OPENSSL_NO_ECDH
	EC_KEY *ecdh = NULL;
	BN_CTX *bn_ctx = NULL;
	EC_POINT *srvr_ecpoint = NULL;
	int curve_nid = 0;
 	int encoded_pt_len = 0;
 #endif
 
 	/* use same message size as in ssl3_get_certificate_request()
 	 * as ServerKeyExchange message may be skipped */
 	n=s->method->ssl_get_message(s,
		SSL3_ST_CR_KEY_EXCH_A,
		SSL3_ST_CR_KEY_EXCH_B,
		-1,
		s->max_cert_list,
 		&ok);
 	if (!ok) return((int)n);
 
 	if (s->s3->tmp.message_type != SSL3_MT_SERVER_KEY_EXCHANGE)
 		{
 #ifndef OPENSSL_NO_PSK
 		/* In plain PSK ciphersuite, ServerKeyExchange can be
 		   omitted if no identity hint is sent. Set
 		   session->sess_cert anyway to avoid problems
 		   later.*/
		if (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)
 			{
 			s->session->sess_cert=ssl_sess_cert_new();
 			if (s->ctx->psk_identity_hint)
				OPENSSL_free(s->ctx->psk_identity_hint);
			s->ctx->psk_identity_hint = NULL;
			}
#endif
		s->s3->tmp.reuse_message=1;
		return(1);
		}

	param=p=(unsigned char *)s->init_msg;
	if (s->session->sess_cert != NULL)
		{
#ifndef OPENSSL_NO_RSA
		if (s->session->sess_cert->peer_rsa_tmp != NULL)
			{
			RSA_free(s->session->sess_cert->peer_rsa_tmp);
			s->session->sess_cert->peer_rsa_tmp=NULL;
			}
#endif
#ifndef OPENSSL_NO_DH
		if (s->session->sess_cert->peer_dh_tmp)
			{
			DH_free(s->session->sess_cert->peer_dh_tmp);
			s->session->sess_cert->peer_dh_tmp=NULL;
			}
#endif
#ifndef OPENSSL_NO_ECDH
		if (s->session->sess_cert->peer_ecdh_tmp)
			{
			EC_KEY_free(s->session->sess_cert->peer_ecdh_tmp);
			s->session->sess_cert->peer_ecdh_tmp=NULL;
			}
#endif
		}
	else
		{
		s->session->sess_cert=ssl_sess_cert_new();
		}

 	/* Total length of the parameters including the length prefix */
 	param_len=0;
 
	alg_k=s->s3->tmp.new_cipher->algorithm_mkey;
 	alg_a=s->s3->tmp.new_cipher->algorithm_auth;
	EVP_MD_CTX_init(&md_ctx);
 
 	al=SSL_AD_DECODE_ERROR;
 
#ifndef OPENSSL_NO_PSK
	if (alg_k & SSL_kPSK)
		{
		char tmp_id_hint[PSK_MAX_IDENTITY_LEN+1];

		param_len = 2;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);

		/* Store PSK identity hint for later use, hint is used
		 * in ssl3_send_client_key_exchange.  Assume that the
		 * maximum length of a PSK identity hint can be as
		 * long as the maximum length of a PSK identity. */
		if (i > PSK_MAX_IDENTITY_LEN)
			{
			al=SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_DATA_LENGTH_TOO_LONG);
			goto f_err;
			}
		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_BAD_PSK_IDENTITY_HINT_LENGTH);
			goto f_err;
			}
		param_len += i;

		/* If received PSK identity hint contains NULL
		 * characters, the hint is truncated from the first
		 * NULL. p may not be ending with NULL, so create a
		 * NULL-terminated string. */
		memcpy(tmp_id_hint, p, i);
		memset(tmp_id_hint+i, 0, PSK_MAX_IDENTITY_LEN+1-i);
		if (s->ctx->psk_identity_hint != NULL)
			OPENSSL_free(s->ctx->psk_identity_hint);
		s->ctx->psk_identity_hint = BUF_strdup(tmp_id_hint);
		if (s->ctx->psk_identity_hint == NULL)
			{
			al=SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);
			goto f_err;
			}	   

		p+=i;
		n-=param_len;
		}
	else
#endif /* !OPENSSL_NO_PSK */
#ifndef OPENSSL_NO_SRP
	if (alg_k & SSL_kSRP)
		{
		param_len = 2;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_N_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(s->srp_ctx.N=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;


		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_G_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(s->srp_ctx.g=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;


		if (1 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 1;

		i = (unsigned int)(p[0]);
		p++;

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_S_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(s->srp_ctx.s=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_B_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(s->srp_ctx.B=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;
		n-=param_len;

		if (!srp_verify_server_param(s, &al))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_PARAMETERS);
			goto f_err;
			}

/* We must check if there is a certificate */
#ifndef OPENSSL_NO_RSA
		if (alg_a & SSL_aRSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
#else
		if (0)
			;
#endif
#ifndef OPENSSL_NO_DSA
		else if (alg_a & SSL_aDSS)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);
#endif
		}
	else
#endif /* !OPENSSL_NO_SRP */
#ifndef OPENSSL_NO_RSA
	if (alg_k & SSL_kRSA)
		{
		if ((rsa=RSA_new()) == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
			goto err;
			}

		param_len = 2;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_MODULUS_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(rsa->n=BN_bin2bn(p,i,rsa->n)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_E_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(rsa->e=BN_bin2bn(p,i,rsa->e)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;
		n-=param_len;

		/* this should be because we are using an export cipher */
		if (alg_a & SSL_aRSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
		else
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
			goto err;
			}
		s->session->sess_cert->peer_rsa_tmp=rsa;
		rsa=NULL;
		}
#else /* OPENSSL_NO_RSA */
	if (0)
		;
#endif
#ifndef OPENSSL_NO_DH
	else if (alg_k & SSL_kDHE)
		{
		if ((dh=DH_new()) == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_DH_LIB);
			goto err;
			}

		param_len = 2;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_P_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(dh->p=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_G_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(dh->g=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_PUB_KEY_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(dh->pub_key=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;
		n-=param_len;

		if (!ssl_security(s, SSL_SECOP_TMP_DH,
						DH_security_bits(dh), 0, dh))
			{
			al=SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_DH_KEY_TOO_SMALL);
			goto f_err;
			}

#ifndef OPENSSL_NO_RSA
		if (alg_a & SSL_aRSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
#else
		if (0)
			;
#endif
#ifndef OPENSSL_NO_DSA
		else if (alg_a & SSL_aDSS)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);
#endif
		/* else anonymous DH, so no certificate or pkey. */

		s->session->sess_cert->peer_dh_tmp=dh;
		dh=NULL;
		}
	else if ((alg_k & SSL_kDHr) || (alg_k & SSL_kDHd))
		{
		al=SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);
		goto f_err;
		}
#endif /* !OPENSSL_NO_DH */

#ifndef OPENSSL_NO_ECDH
	else if (alg_k & SSL_kECDHE)
		{
		EC_GROUP *ngroup;
		const EC_GROUP *group;

		if ((ecdh=EC_KEY_new()) == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
			goto err;
			}

		/* Extract elliptic curve parameters and the
		 * server's ephemeral ECDH public key.
		 * Keep accumulating lengths of various components in
		 * param_len and make sure it never exceeds n.
		 */

		/* XXX: For now we only support named (not generic) curves
		 * and the ECParameters in this case is just three bytes. We
		 * also need one byte for the length of the encoded point
		 */
		param_len=4;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		/* Check curve is one of our preferences, if not server has
		 * sent an invalid curve. ECParameters is 3 bytes.
		 */
		if (!tls1_check_curve(s, p, 3))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_CURVE);
			goto f_err;
			}

		if ((curve_nid = tls1_ec_curve_id2nid(*(p + 2))) == 0) 
			{
			al=SSL_AD_INTERNAL_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);
			goto f_err;
			}

		ngroup = EC_GROUP_new_by_curve_name(curve_nid);
		if (ngroup == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);
			goto err;
			}
		if (EC_KEY_set_group(ecdh, ngroup) == 0)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);
			goto err;
			}
		EC_GROUP_free(ngroup);

		group = EC_KEY_get0_group(ecdh);

		if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&
		    (EC_GROUP_get_degree(group) > 163))
			{
			al=SSL_AD_EXPORT_RESTRICTION;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);
			goto f_err;
			}

		p+=3;

		/* Next, get the encoded ECPoint */
		if (((srvr_ecpoint = EC_POINT_new(group)) == NULL) ||
		    ((bn_ctx = BN_CTX_new()) == NULL))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
			goto err;
			}

		encoded_pt_len = *p;  /* length of encoded point */
		p+=1;

		if ((encoded_pt_len > n - param_len) ||
		    (EC_POINT_oct2point(group, srvr_ecpoint, 
			p, encoded_pt_len, bn_ctx) == 0))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_ECPOINT);
			goto f_err;
			}
		param_len += encoded_pt_len;

		n-=param_len;
		p+=encoded_pt_len;

		/* The ECC/TLS specification does not mention
		 * the use of DSA to sign ECParameters in the server
		 * key exchange message. We do support RSA and ECDSA.
		 */
		if (0) ;
#ifndef OPENSSL_NO_RSA
		else if (alg_a & SSL_aRSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
#endif
#ifndef OPENSSL_NO_ECDSA
		else if (alg_a & SSL_aECDSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);
#endif
		/* else anonymous ECDH, so no certificate or pkey. */
		EC_KEY_set_public_key(ecdh, srvr_ecpoint);
		s->session->sess_cert->peer_ecdh_tmp=ecdh;
		ecdh=NULL;
		BN_CTX_free(bn_ctx);
		bn_ctx = NULL;
		EC_POINT_free(srvr_ecpoint);
		srvr_ecpoint = NULL;
		}
	else if (alg_k)
		{
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);
		goto f_err;
		}
#endif /* !OPENSSL_NO_ECDH */


	/* p points to the next byte, there are 'n' bytes left */

	/* if it was signed, check the signature */
	if (pkey != NULL)
		{
		if (SSL_USE_SIGALGS(s))
			{
			int rv;
			if (2 > n)
				{
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
					SSL_R_LENGTH_TOO_SHORT);
				goto f_err;
				}
			rv = tls12_check_peer_sigalg(&md, s, p, pkey);
			if (rv == -1)
				goto err;
			else if (rv == 0)
				{
				goto f_err;
				}
#ifdef SSL_DEBUG
fprintf(stderr, ""USING TLSv1.2 HASH %s\n"", EVP_MD_name(md));
#endif
			p += 2;
			n -= 2;
			}
		else
			md = EVP_sha1();

		if (2 > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);
		n-=2;
		j=EVP_PKEY_size(pkey);

		/* Check signature length. If n is 0 then signature is empty */
		if ((i != n) || (n > j) || (n <= 0))
			{
			/* wrong packet length */
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_SIGNATURE_LENGTH);
			goto f_err;
			}

#ifndef OPENSSL_NO_RSA
		if (pkey->type == EVP_PKEY_RSA && !SSL_USE_SIGALGS(s))
			{
			int num;
			unsigned int size;

			j=0;
			q=md_buf;
			for (num=2; num > 0; num--)
				{
				EVP_MD_CTX_set_flags(&md_ctx,
					EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
				EVP_DigestInit_ex(&md_ctx,(num == 2)
					?s->ctx->md5:s->ctx->sha1, NULL);
				EVP_DigestUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
				EVP_DigestUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
				EVP_DigestUpdate(&md_ctx,param,param_len);
				EVP_DigestFinal_ex(&md_ctx,q,&size);
				q+=size;
				j+=size;
				}
			i=RSA_verify(NID_md5_sha1, md_buf, j, p, n,
								pkey->pkey.rsa);
			if (i < 0)
				{
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_DECRYPT);
				goto f_err;
				}
			if (i == 0)
				{
				/* bad signature */
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);
				goto f_err;
				}
			}
		else
#endif
			{
			EVP_VerifyInit_ex(&md_ctx, md, NULL);
			EVP_VerifyUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
			EVP_VerifyUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
			EVP_VerifyUpdate(&md_ctx,param,param_len);
			if (EVP_VerifyFinal(&md_ctx,p,(int)n,pkey) <= 0)
				{
				/* bad signature */
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);
				goto f_err;
				}
			}
		}
	else
		{
		/* aNULL, aSRP or kPSK do not need public keys */
		if (!(alg_a & (SSL_aNULL|SSL_aSRP)) && !(alg_k & SSL_kPSK))
			{
			/* Might be wrong key type, check it */
			if (ssl3_check_cert_and_algorithm(s))
				/* Otherwise this shouldn't happen */
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
			goto err;
			}
		/* still data left over */
		if (n != 0)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_EXTRA_DATA_IN_MESSAGE);
			goto f_err;
			}
		}
	EVP_PKEY_free(pkey);
	EVP_MD_CTX_cleanup(&md_ctx);
	return(1);
f_err:
	ssl3_send_alert(s,SSL3_AL_FATAL,al);
err:
	EVP_PKEY_free(pkey);
#ifndef OPENSSL_NO_RSA
	if (rsa != NULL)
		RSA_free(rsa);
#endif
#ifndef OPENSSL_NO_DH
	if (dh != NULL)
		DH_free(dh);
#endif
#ifndef OPENSSL_NO_ECDH
	BN_CTX_free(bn_ctx);
	EC_POINT_free(srvr_ecpoint);
	if (ecdh != NULL)
		EC_KEY_free(ecdh);
#endif
	EVP_MD_CTX_cleanup(&md_ctx);
	return(-1);
	}
",C,"	EVP_MD_CTX_init(&md_ctx);

	alg_k=s->s3->tmp.new_cipher->algorithm_mkey;

		/*
		 * Can't skip server key exchange if this is an ephemeral
		 * ciphersuite.
		 */
		if (alg_k & (SSL_kDHE|SSL_kECDHE))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);
			al = SSL_AD_UNEXPECTED_MESSAGE;
			goto f_err;
			}
		if (alg_k & SSL_kPSK)
","		if (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)
	alg_k=s->s3->tmp.new_cipher->algorithm_mkey;
	EVP_MD_CTX_init(&md_ctx);
",,"@@ -1376,6 +1376,8 @@ int ssl3_get_key_exchange(SSL *s)
 	int encoded_pt_len = 0;
 #endif
 
+	EVP_MD_CTX_init(&md_ctx);
+
 	/* use same message size as in ssl3_get_certificate_request()
 	 * as ServerKeyExchange message may be skipped */
 	n=s->method->ssl_get_message(s,
@@ -1386,14 +1388,26 @@ int ssl3_get_key_exchange(SSL *s)
 		&ok);
 	if (!ok) return((int)n);
 
+	alg_k=s->s3->tmp.new_cipher->algorithm_mkey;
+
 	if (s->s3->tmp.message_type != SSL3_MT_SERVER_KEY_EXCHANGE)
 		{
+		/*
+		 * Can't skip server key exchange if this is an ephemeral
+		 * ciphersuite.
+		 */
+		if (alg_k & (SSL_kDHE|SSL_kECDHE))
+			{
+			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);
+			al = SSL_AD_UNEXPECTED_MESSAGE;
+			goto f_err;
+			}
 #ifndef OPENSSL_NO_PSK
 		/* In plain PSK ciphersuite, ServerKeyExchange can be
 		   omitted if no identity hint is sent. Set
 		   session->sess_cert anyway to avoid problems
 		   later.*/
-		if (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)
+		if (alg_k & SSL_kPSK)
 			{
 			s->session->sess_cert=ssl_sess_cert_new();
 			if (s->ctx->psk_identity_hint)
@@ -1438,9 +1452,7 @@ int ssl3_get_key_exchange(SSL *s)
 	/* Total length of the parameters including the length prefix */
 	param_len=0;
 
-	alg_k=s->s3->tmp.new_cipher->algorithm_mkey;
 	alg_a=s->s3->tmp.new_cipher->algorithm_auth;
-	EVP_MD_CTX_init(&md_ctx);
 
 	al=SSL_AD_DECODE_ERROR;
 ",openssl,b15f8769644b00ef7283521593360b7b2135cb63,b5526482ef81ee7906b967e326d23a45fbcf3abc,1,"int ssl3_get_key_exchange(SSL *s)
	{
#ifndef OPENSSL_NO_RSA
	unsigned char *q,md_buf[EVP_MAX_MD_SIZE*2];
#endif
	EVP_MD_CTX md_ctx;
	unsigned char *param,*p;
	int al,j,ok;
	long i,param_len,n,alg_k,alg_a;
	EVP_PKEY *pkey=NULL;
	const EVP_MD *md = NULL;
#ifndef OPENSSL_NO_RSA
	RSA *rsa=NULL;
#endif
#ifndef OPENSSL_NO_DH
	DH *dh=NULL;
#endif
#ifndef OPENSSL_NO_ECDH
	EC_KEY *ecdh = NULL;
	BN_CTX *bn_ctx = NULL;
	EC_POINT *srvr_ecpoint = NULL;
	int curve_nid = 0;
 	int encoded_pt_len = 0;
 #endif
 
//fix_flaw_line_below:
//	EVP_MD_CTX_init(&md_ctx);
//fix_flaw_line_below:
//
 	/* use same message size as in ssl3_get_certificate_request()
 	 * as ServerKeyExchange message may be skipped */
 	n=s->method->ssl_get_message(s,
		SSL3_ST_CR_KEY_EXCH_A,
		SSL3_ST_CR_KEY_EXCH_B,
		-1,
		s->max_cert_list,
 		&ok);
 	if (!ok) return((int)n);
 
//fix_flaw_line_below:
//	alg_k=s->s3->tmp.new_cipher->algorithm_mkey;
//fix_flaw_line_below:
//
 	if (s->s3->tmp.message_type != SSL3_MT_SERVER_KEY_EXCHANGE)
 		{
//fix_flaw_line_below:
//		/*
//fix_flaw_line_below:
//		 * Can't skip server key exchange if this is an ephemeral
//fix_flaw_line_below:
//		 * ciphersuite.
//fix_flaw_line_below:
//		 */
//fix_flaw_line_below:
//		if (alg_k & (SSL_kDHE|SSL_kECDHE))
//fix_flaw_line_below:
//			{
//fix_flaw_line_below:
//			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_UNEXPECTED_MESSAGE);
//fix_flaw_line_below:
//			al = SSL_AD_UNEXPECTED_MESSAGE;
//fix_flaw_line_below:
//			goto f_err;
//fix_flaw_line_below:
//			}
 #ifndef OPENSSL_NO_PSK
 		/* In plain PSK ciphersuite, ServerKeyExchange can be
 		   omitted if no identity hint is sent. Set
 		   session->sess_cert anyway to avoid problems
 		   later.*/
//flaw_line_below:
		if (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)
//fix_flaw_line_below:
//		if (alg_k & SSL_kPSK)
 			{
 			s->session->sess_cert=ssl_sess_cert_new();
 			if (s->ctx->psk_identity_hint)
				OPENSSL_free(s->ctx->psk_identity_hint);
			s->ctx->psk_identity_hint = NULL;
			}
#endif
		s->s3->tmp.reuse_message=1;
		return(1);
		}

	param=p=(unsigned char *)s->init_msg;
	if (s->session->sess_cert != NULL)
		{
#ifndef OPENSSL_NO_RSA
		if (s->session->sess_cert->peer_rsa_tmp != NULL)
			{
			RSA_free(s->session->sess_cert->peer_rsa_tmp);
			s->session->sess_cert->peer_rsa_tmp=NULL;
			}
#endif
#ifndef OPENSSL_NO_DH
		if (s->session->sess_cert->peer_dh_tmp)
			{
			DH_free(s->session->sess_cert->peer_dh_tmp);
			s->session->sess_cert->peer_dh_tmp=NULL;
			}
#endif
#ifndef OPENSSL_NO_ECDH
		if (s->session->sess_cert->peer_ecdh_tmp)
			{
			EC_KEY_free(s->session->sess_cert->peer_ecdh_tmp);
			s->session->sess_cert->peer_ecdh_tmp=NULL;
			}
#endif
		}
	else
		{
		s->session->sess_cert=ssl_sess_cert_new();
		}

 	/* Total length of the parameters including the length prefix */
 	param_len=0;
 
//flaw_line_below:
	alg_k=s->s3->tmp.new_cipher->algorithm_mkey;
 	alg_a=s->s3->tmp.new_cipher->algorithm_auth;
//flaw_line_below:
	EVP_MD_CTX_init(&md_ctx);
 
 	al=SSL_AD_DECODE_ERROR;
 
#ifndef OPENSSL_NO_PSK
	if (alg_k & SSL_kPSK)
		{
		char tmp_id_hint[PSK_MAX_IDENTITY_LEN+1];

		param_len = 2;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);

		/* Store PSK identity hint for later use, hint is used
		 * in ssl3_send_client_key_exchange.  Assume that the
		 * maximum length of a PSK identity hint can be as
		 * long as the maximum length of a PSK identity. */
		if (i > PSK_MAX_IDENTITY_LEN)
			{
			al=SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_DATA_LENGTH_TOO_LONG);
			goto f_err;
			}
		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_BAD_PSK_IDENTITY_HINT_LENGTH);
			goto f_err;
			}
		param_len += i;

		/* If received PSK identity hint contains NULL
		 * characters, the hint is truncated from the first
		 * NULL. p may not be ending with NULL, so create a
		 * NULL-terminated string. */
		memcpy(tmp_id_hint, p, i);
		memset(tmp_id_hint+i, 0, PSK_MAX_IDENTITY_LEN+1-i);
		if (s->ctx->psk_identity_hint != NULL)
			OPENSSL_free(s->ctx->psk_identity_hint);
		s->ctx->psk_identity_hint = BUF_strdup(tmp_id_hint);
		if (s->ctx->psk_identity_hint == NULL)
			{
			al=SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);
			goto f_err;
			}	   

		p+=i;
		n-=param_len;
		}
	else
#endif /* !OPENSSL_NO_PSK */
#ifndef OPENSSL_NO_SRP
	if (alg_k & SSL_kSRP)
		{
		param_len = 2;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_N_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(s->srp_ctx.N=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;


		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_G_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(s->srp_ctx.g=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;


		if (1 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 1;

		i = (unsigned int)(p[0]);
		p++;

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_S_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(s->srp_ctx.s=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_B_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(s->srp_ctx.B=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;
		n-=param_len;

		if (!srp_verify_server_param(s, &al))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SRP_PARAMETERS);
			goto f_err;
			}

/* We must check if there is a certificate */
#ifndef OPENSSL_NO_RSA
		if (alg_a & SSL_aRSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
#else
		if (0)
			;
#endif
#ifndef OPENSSL_NO_DSA
		else if (alg_a & SSL_aDSS)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);
#endif
		}
	else
#endif /* !OPENSSL_NO_SRP */
#ifndef OPENSSL_NO_RSA
	if (alg_k & SSL_kRSA)
		{
		if ((rsa=RSA_new()) == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
			goto err;
			}

		param_len = 2;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_MODULUS_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(rsa->n=BN_bin2bn(p,i,rsa->n)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_E_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(rsa->e=BN_bin2bn(p,i,rsa->e)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;
		n-=param_len;

		/* this should be because we are using an export cipher */
		if (alg_a & SSL_aRSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
		else
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
			goto err;
			}
		s->session->sess_cert->peer_rsa_tmp=rsa;
		rsa=NULL;
		}
#else /* OPENSSL_NO_RSA */
	if (0)
		;
#endif
#ifndef OPENSSL_NO_DH
	else if (alg_k & SSL_kDHE)
		{
		if ((dh=DH_new()) == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_DH_LIB);
			goto err;
			}

		param_len = 2;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_P_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(dh->p=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_G_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(dh->g=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;

		if (2 > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		param_len += 2;

		n2s(p,i);

		if (i > n - param_len)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_PUB_KEY_LENGTH);
			goto f_err;
			}
		param_len += i;

		if (!(dh->pub_key=BN_bin2bn(p,i,NULL)))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
			goto err;
			}
		p+=i;
		n-=param_len;

		if (!ssl_security(s, SSL_SECOP_TMP_DH,
						DH_security_bits(dh), 0, dh))
			{
			al=SSL_AD_HANDSHAKE_FAILURE;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_DH_KEY_TOO_SMALL);
			goto f_err;
			}

#ifndef OPENSSL_NO_RSA
		if (alg_a & SSL_aRSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
#else
		if (0)
			;
#endif
#ifndef OPENSSL_NO_DSA
		else if (alg_a & SSL_aDSS)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);
#endif
		/* else anonymous DH, so no certificate or pkey. */

		s->session->sess_cert->peer_dh_tmp=dh;
		dh=NULL;
		}
	else if ((alg_k & SSL_kDHr) || (alg_k & SSL_kDHd))
		{
		al=SSL_AD_ILLEGAL_PARAMETER;
		SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);
		goto f_err;
		}
#endif /* !OPENSSL_NO_DH */

#ifndef OPENSSL_NO_ECDH
	else if (alg_k & SSL_kECDHE)
		{
		EC_GROUP *ngroup;
		const EC_GROUP *group;

		if ((ecdh=EC_KEY_new()) == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
			goto err;
			}

		/* Extract elliptic curve parameters and the
		 * server's ephemeral ECDH public key.
		 * Keep accumulating lengths of various components in
		 * param_len and make sure it never exceeds n.
		 */

		/* XXX: For now we only support named (not generic) curves
		 * and the ECParameters in this case is just three bytes. We
		 * also need one byte for the length of the encoded point
		 */
		param_len=4;
		if (param_len > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		/* Check curve is one of our preferences, if not server has
		 * sent an invalid curve. ECParameters is 3 bytes.
		 */
		if (!tls1_check_curve(s, p, 3))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_CURVE);
			goto f_err;
			}

		if ((curve_nid = tls1_ec_curve_id2nid(*(p + 2))) == 0) 
			{
			al=SSL_AD_INTERNAL_ERROR;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);
			goto f_err;
			}

		ngroup = EC_GROUP_new_by_curve_name(curve_nid);
		if (ngroup == NULL)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);
			goto err;
			}
		if (EC_KEY_set_group(ecdh, ngroup) == 0)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);
			goto err;
			}
		EC_GROUP_free(ngroup);

		group = EC_KEY_get0_group(ecdh);

		if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&
		    (EC_GROUP_get_degree(group) > 163))
			{
			al=SSL_AD_EXPORT_RESTRICTION;
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);
			goto f_err;
			}

		p+=3;

		/* Next, get the encoded ECPoint */
		if (((srvr_ecpoint = EC_POINT_new(group)) == NULL) ||
		    ((bn_ctx = BN_CTX_new()) == NULL))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
			goto err;
			}

		encoded_pt_len = *p;  /* length of encoded point */
		p+=1;

		if ((encoded_pt_len > n - param_len) ||
		    (EC_POINT_oct2point(group, srvr_ecpoint, 
			p, encoded_pt_len, bn_ctx) == 0))
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_ECPOINT);
			goto f_err;
			}
		param_len += encoded_pt_len;

		n-=param_len;
		p+=encoded_pt_len;

		/* The ECC/TLS specification does not mention
		 * the use of DSA to sign ECParameters in the server
		 * key exchange message. We do support RSA and ECDSA.
		 */
		if (0) ;
#ifndef OPENSSL_NO_RSA
		else if (alg_a & SSL_aRSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
#endif
#ifndef OPENSSL_NO_ECDSA
		else if (alg_a & SSL_aECDSA)
			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);
#endif
		/* else anonymous ECDH, so no certificate or pkey. */
		EC_KEY_set_public_key(ecdh, srvr_ecpoint);
		s->session->sess_cert->peer_ecdh_tmp=ecdh;
		ecdh=NULL;
		BN_CTX_free(bn_ctx);
		bn_ctx = NULL;
		EC_POINT_free(srvr_ecpoint);
		srvr_ecpoint = NULL;
		}
	else if (alg_k)
		{
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);
		goto f_err;
		}
#endif /* !OPENSSL_NO_ECDH */


	/* p points to the next byte, there are 'n' bytes left */

	/* if it was signed, check the signature */
	if (pkey != NULL)
		{
		if (SSL_USE_SIGALGS(s))
			{
			int rv;
			if (2 > n)
				{
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
					SSL_R_LENGTH_TOO_SHORT);
				goto f_err;
				}
			rv = tls12_check_peer_sigalg(&md, s, p, pkey);
			if (rv == -1)
				goto err;
			else if (rv == 0)
				{
				goto f_err;
				}
#ifdef SSL_DEBUG
fprintf(stderr, ""USING TLSv1.2 HASH %s\n"", EVP_MD_name(md));
#endif
			p += 2;
			n -= 2;
			}
		else
			md = EVP_sha1();

		if (2 > n)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,
				SSL_R_LENGTH_TOO_SHORT);
			goto f_err;
			}
		n2s(p,i);
		n-=2;
		j=EVP_PKEY_size(pkey);

		/* Check signature length. If n is 0 then signature is empty */
		if ((i != n) || (n > j) || (n <= 0))
			{
			/* wrong packet length */
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_SIGNATURE_LENGTH);
			goto f_err;
			}

#ifndef OPENSSL_NO_RSA
		if (pkey->type == EVP_PKEY_RSA && !SSL_USE_SIGALGS(s))
			{
			int num;
			unsigned int size;

			j=0;
			q=md_buf;
			for (num=2; num > 0; num--)
				{
				EVP_MD_CTX_set_flags(&md_ctx,
					EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
				EVP_DigestInit_ex(&md_ctx,(num == 2)
					?s->ctx->md5:s->ctx->sha1, NULL);
				EVP_DigestUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
				EVP_DigestUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
				EVP_DigestUpdate(&md_ctx,param,param_len);
				EVP_DigestFinal_ex(&md_ctx,q,&size);
				q+=size;
				j+=size;
				}
			i=RSA_verify(NID_md5_sha1, md_buf, j, p, n,
								pkey->pkey.rsa);
			if (i < 0)
				{
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_DECRYPT);
				goto f_err;
				}
			if (i == 0)
				{
				/* bad signature */
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);
				goto f_err;
				}
			}
		else
#endif
			{
			EVP_VerifyInit_ex(&md_ctx, md, NULL);
			EVP_VerifyUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
			EVP_VerifyUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
			EVP_VerifyUpdate(&md_ctx,param,param_len);
			if (EVP_VerifyFinal(&md_ctx,p,(int)n,pkey) <= 0)
				{
				/* bad signature */
				al=SSL_AD_DECRYPT_ERROR;
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);
				goto f_err;
				}
			}
		}
	else
		{
		/* aNULL, aSRP or kPSK do not need public keys */
		if (!(alg_a & (SSL_aNULL|SSL_aSRP)) && !(alg_k & SSL_kPSK))
			{
			/* Might be wrong key type, check it */
			if (ssl3_check_cert_and_algorithm(s))
				/* Otherwise this shouldn't happen */
				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
			goto err;
			}
		/* still data left over */
		if (n != 0)
			{
			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_EXTRA_DATA_IN_MESSAGE);
			goto f_err;
			}
		}
	EVP_PKEY_free(pkey);
	EVP_MD_CTX_cleanup(&md_ctx);
	return(1);
f_err:
	ssl3_send_alert(s,SSL3_AL_FATAL,al);
err:
	EVP_PKEY_free(pkey);
#ifndef OPENSSL_NO_RSA
	if (rsa != NULL)
		RSA_free(rsa);
#endif
#ifndef OPENSSL_NO_DH
	if (dh != NULL)
		DH_free(dh);
#endif
#ifndef OPENSSL_NO_ECDH
	BN_CTX_free(bn_ctx);
	EC_POINT_free(srvr_ecpoint);
	if (ecdh != NULL)
		EC_KEY_free(ecdh);
#endif
	EVP_MD_CTX_cleanup(&md_ctx);
	return(-1);
	}
"
2264,180000,,Remote,Not required,,CVE-2014-3570,https://www.cvedetails.com/cve/CVE-2014-3570/,CWE-310,Low,Partial,,,2015-01-08,5.0,"The BN_sqr implementation in OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not properly calculate the square of a BIGNUM value, which might make it easier for remote attackers to defeat cryptographic protection mechanisms via unspecified vectors, related to crypto/bn/asm/mips.pl, crypto/bn/asm/x86_64-gcc.c, and crypto/bn/bn_asm.c.",2017-11-14,,0,https://github.com/openssl/openssl/commit/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,"Fix for CVE-2014-3570 (with minor bn_asm.c revamp).

Reviewed-by: Emilia Kasper <emilia@openssl.org>",1,crypto/bn/asm/x86_64-gcc.c,"{""sha"": ""acafde5e5685ccb7e2d59b218d45d1bda0572fbd"", ""filename"": ""crypto/bn/asm/mips.pl"", ""status"": ""modified"", ""additions"": 131, ""deletions"": 480, ""changes"": 611, ""blob_url"": ""https://github.com/openssl/openssl/blob/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/asm/mips.pl"", ""raw_url"": ""https://github.com/openssl/openssl/raw/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/asm/mips.pl"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/bn/asm/mips.pl?ref=a7a44ba55cb4f884c6bc9ceac90072dea38e66d0"", ""patch"": ""@@ -1872,6 +1872,41 @@\n \n ($a_4,$a_5,$a_6,$a_7)=($b_0,$b_1,$b_2,$b_3);\n \n+sub add_c2 () {\n+my ($hi,$lo,$c0,$c1,$c2,\n+    $warm,      # !$warm denotes first call with specific sequence of\n+                # $c_[XYZ] when there is no Z-carry to accumulate yet;\n+    $an,$bn     # these two are arguments for multiplication which\n+                # result is used in *next* step [which is why it's\n+                # commented as \""forward multiplication\"" below];\n+    )=@_;\n+$code.=<<___;\n+\tmflo\t$lo\n+\tmfhi\t$hi\n+\t$ADDU\t$c0,$lo\n+\tsltu\t$at,$c0,$lo\n+\t $MULTU\t$an,$bn\t\t\t# forward multiplication\n+\t$ADDU\t$c0,$lo\n+\t$ADDU\t$at,$hi\n+\tsltu\t$lo,$c0,$lo\n+\t$ADDU\t$c1,$at\n+\t$ADDU\t$hi,$lo\n+___\n+$code.=<<___\tif (!$warm);\n+\tsltu\t$c2,$c1,$at\n+\t$ADDU\t$c1,$hi\n+\tsltu\t$hi,$c1,$hi\n+\t$ADDU\t$c2,$hi\n+___\n+$code.=<<___\tif ($warm);\n+\tsltu\t$at,$c1,$at\n+\t$ADDU\t$c1,$hi\n+\t$ADDU\t$c2,$at\n+\tsltu\t$hi,$c1,$hi\n+\t$ADDU\t$c2,$hi\n+___\n+}\n+\n $code.=<<___;\n \n .align\t5\n@@ -1920,21 +1955,10 @@\n \tsltu\t$at,$c_2,$t_1\n \t$ADDU\t$c_3,$t_2,$at\n \t$ST\t$c_2,$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_1\t\t# mul_add_c(a[1],b[1],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_1,$a_1);\t\t# mul_add_c(a[1],b[1],c3,c1,c2);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_3,$t_1\n@@ -1945,67 +1969,19 @@\n \tsltu\t$at,$c_1,$t_2\n \t$ADDU\t$c_2,$at\n \t$ST\t$c_3,2*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_3,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_2\t\t# mul_add_c2(a[1],b[2],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t $MULTU\t$a_4,$a_0\t\t# mul_add_c2(a[4],b[0],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,0,\n+\t\t$a_1,$a_2);\t\t# mul_add_c2(a[1],b[2],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_4,$a_0);\t\t# mul_add_c2(a[4],b[0],c2,c3,c1);\n+$code.=<<___;\n \t$ST\t$c_1,3*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_1,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_3,$a_1\t\t# mul_add_c2(a[3],b[1],c2,c3,c1);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_1,$at\n-\t$MULTU\t$a_2,$a_2\t\t# mul_add_c(a[2],b[2],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,0,\n+\t\t$a_3,$a_1);\t\t# mul_add_c2(a[3],b[1],c2,c3,c1);\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,1,\n+\t\t$a_2,$a_2);\t\t# mul_add_c(a[2],b[2],c2,c3,c1);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_2,$t_1\n@@ -2016,97 +1992,23 @@\n \tsltu\t$at,$c_3,$t_2\n \t$ADDU\t$c_1,$at\n \t$ST\t$c_2,4*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_4\t\t# mul_add_c2(a[1],b[4],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_2,$at\n-\t$MULTU\t$a_2,$a_3\t\t# mul_add_c2(a[2],b[3],c3,c1,c2);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t $MULTU\t$a_6,$a_0\t\t# mul_add_c2(a[6],b[0],c1,c2,c3);\n-\t$ADDU\t$c_2,$at\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_1,$a_4);\t\t# mul_add_c2(a[1],b[4],c3,c1,c2);\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,1,\n+\t\t$a_2,$a_3);\t\t# mul_add_c2(a[2],b[3],c3,c1,c2);\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,1,\n+\t\t$a_6,$a_0);\t\t# mul_add_c2(a[6],b[0],c1,c2,c3);\n+$code.=<<___;\n \t$ST\t$c_3,5*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_3,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_5,$a_1\t\t# mul_add_c2(a[5],b[1],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t$MULTU\t$a_4,$a_2\t\t# mul_add_c2(a[4],b[2],c1,c2,c3);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t$MULTU\t$a_3,$a_3\t\t# mul_add_c(a[3],b[3],c1,c2,c3);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,0,\n+\t\t$a_5,$a_1);\t\t# mul_add_c2(a[5],b[1],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_4,$a_2);\t\t# mul_add_c2(a[4],b[2],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_3,$a_3);\t\t# mul_add_c(a[3],b[3],c1,c2,c3);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_1,$t_1\n@@ -2117,112 +2019,25 @@\n \tsltu\t$at,$c_2,$t_2\n \t$ADDU\t$c_3,$at\n \t$ST\t$c_1,6*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_1,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_6\t\t# mul_add_c2(a[1],b[6],c2,c3,c1);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_1,$at\n-\t$MULTU\t$a_2,$a_5\t\t# mul_add_c2(a[2],b[5],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_1,$at\n-\t$MULTU\t$a_3,$a_4\t\t# mul_add_c2(a[3],b[4],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_1,$at\n-\t $MULTU\t$a_7,$a_1\t\t# mul_add_c2(a[7],b[1],c3,c1,c2);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,0,\n+\t\t$a_1,$a_6);\t\t# mul_add_c2(a[1],b[6],c2,c3,c1);\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,1,\n+\t\t$a_2,$a_5);\t\t# mul_add_c2(a[2],b[5],c2,c3,c1);\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,1,\n+\t\t$a_3,$a_4);\t\t# mul_add_c2(a[3],b[4],c2,c3,c1);\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,1,\n+\t\t$a_7,$a_1);\t\t# mul_add_c2(a[7],b[1],c3,c1,c2);\n+$code.=<<___;\n \t$ST\t$c_2,7*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_6,$a_2\t\t# mul_add_c2(a[6],b[2],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_2,$at\n-\t$MULTU\t$a_5,$a_3\t\t# mul_add_c2(a[5],b[3],c3,c1,c2);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_2,$at\n-\t$MULTU\t$a_4,$a_4\t\t# mul_add_c(a[4],b[4],c3,c1,c2);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_6,$a_2);\t\t# mul_add_c2(a[6],b[2],c3,c1,c2);\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,1,\n+\t\t$a_5,$a_3);\t\t# mul_add_c2(a[5],b[3],c3,c1,c2);\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,1,\n+\t\t$a_4,$a_4);\t\t# mul_add_c(a[4],b[4],c3,c1,c2);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_3,$t_1\n@@ -2233,82 +2048,21 @@\n \tsltu\t$at,$c_1,$t_2\n \t$ADDU\t$c_2,$at\n \t$ST\t$c_3,8*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_3,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_3,$a_6\t\t# mul_add_c2(a[3],b[6],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t$MULTU\t$a_4,$a_5\t\t# mul_add_c2(a[4],b[5],c1,c2,c3);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t $MULTU\t$a_7,$a_3\t\t# mul_add_c2(a[7],b[3],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,0,\n+\t\t$a_3,$a_6);\t\t# mul_add_c2(a[3],b[6],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_4,$a_5);\t\t# mul_add_c2(a[4],b[5],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_7,$a_3);\t\t# mul_add_c2(a[7],b[3],c2,c3,c1);\n+$code.=<<___;\n \t$ST\t$c_1,9*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_1,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_6,$a_4\t\t# mul_add_c2(a[6],b[4],c2,c3,c1);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_1,$at\n-\t$MULTU\t$a_5,$a_5\t\t# mul_add_c(a[5],b[5],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,0,\n+\t\t$a_6,$a_4);\t\t# mul_add_c2(a[6],b[4],c2,c3,c1);\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,1,\n+\t\t$a_5,$a_5);\t\t# mul_add_c(a[5],b[5],c2,c3,c1);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_2,$t_1\n@@ -2319,52 +2073,17 @@\n \tsltu\t$at,$c_3,$t_2\n \t$ADDU\t$c_1,$at\n \t$ST\t$c_2,10*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_5,$a_6\t\t# mul_add_c2(a[5],b[6],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_2,$at\n-\t $MULTU\t$a_7,$a_5\t\t# mul_add_c2(a[7],b[5],c1,c2,c3);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_5,$a_6);\t\t# mul_add_c2(a[5],b[6],c3,c1,c2);\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,1,\n+\t\t$a_7,$a_5);\t\t# mul_add_c2(a[7],b[5],c1,c2,c3);\n+$code.=<<___;\n \t$ST\t$c_3,11*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_3,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_6,$a_6\t\t# mul_add_c(a[6],b[6],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,0,\n+\t\t$a_6,$a_6);\t\t# mul_add_c(a[6],b[6],c1,c2,c3);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_1,$t_1\n@@ -2375,21 +2094,10 @@\n \tsltu\t$at,$c_2,$t_2\n \t$ADDU\t$c_3,$at\n \t$ST\t$c_1,12*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_1,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t $MULTU\t$a_7,$a_7\t\t# mul_add_c(a[7],b[7],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,0,\n+\t\t$a_7,$a_7);\t\t# mul_add_c(a[7],b[7],c3,c1,c2);\n+$code.=<<___;\n \t$ST\t$c_2,13*$BNSZ($a0)\n \n \tmflo\t$t_1\n@@ -2457,21 +2165,10 @@\n \tsltu\t$at,$c_2,$t_1\n \t$ADDU\t$c_3,$t_2,$at\n \t$ST\t$c_2,$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_1\t\t# mul_add_c(a[1],b[1],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_1,$a_1);\t\t# mul_add_c(a[1],b[1],c3,c1,c2);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_3,$t_1\n@@ -2482,52 +2179,17 @@\n \tsltu\t$at,$c_1,$t_2\n \t$ADDU\t$c_2,$at\n \t$ST\t$c_3,2*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_3,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_2\t\t# mul_add_c(a2[1],b[2],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t $MULTU\t$a_3,$a_1\t\t# mul_add_c2(a[3],b[1],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,0,\n+\t\t$a_1,$a_2);\t\t# mul_add_c2(a2[1],b[2],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_3,$a_1);\t\t# mul_add_c2(a[3],b[1],c2,c3,c1);\n+$code.=<<___;\n \t$ST\t$c_1,3*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_1,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_2,$a_2\t\t# mul_add_c(a[2],b[2],c2,c3,c1);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,0,\n+\t\t$a_2,$a_2);\t\t# mul_add_c(a[2],b[2],c2,c3,c1);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_2,$t_1\n@@ -2538,21 +2200,10 @@\n \tsltu\t$at,$c_3,$t_2\n \t$ADDU\t$c_1,$at\n \t$ST\t$c_2,4*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t $MULTU\t$a_3,$a_3\t\t# mul_add_c(a[3],b[3],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_3,$a_3);\t\t# mul_add_c(a[3],b[3],c1,c2,c3);\n+$code.=<<___;\n \t$ST\t$c_3,5*$BNSZ($a0)\n \n \tmflo\t$t_1""}<_**next**_>{""sha"": ""7f7e5c2f0ae57a3c82c80e566c04df94b25c1a6a"", ""filename"": ""crypto/bn/asm/x86_64-gcc.c"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 53, ""changes"": 101, ""blob_url"": ""https://github.com/openssl/openssl/blob/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/asm/x86_64-gcc.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/asm/x86_64-gcc.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/bn/asm/x86_64-gcc.c?ref=a7a44ba55cb4f884c6bc9ceac90072dea38e66d0"", ""patch"": ""@@ -276,77 +276,76 @@ BN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)\n /* sqr_add_c(a,i,c0,c1,c2)  -- c+=a[i]^2 for three word number c=(c2,c1,c0) */\n /* sqr_add_c2(a,i,c0,c1,c2) -- c+=2*a[i]*a[j] for three word number c=(c2,c1,c0) */\n \n+/*\n+ * Keep in mind that carrying into high part of multiplication result\n+ * can not overflow, because it cannot be all-ones.\n+ */\n #if 0\n /* original macros are kept for reference purposes */\n-#define mul_add_c(a,b,c0,c1,c2) {\t\\\n-\tBN_ULONG ta=(a),tb=(b);\t\t\\\n-\tt1 = ta * tb;\t\t\t\\\n-\tt2 = BN_UMULT_HIGH(ta,tb);\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n-\n-#define mul_add_c2(a,b,c0,c1,c2) {\t\\\n-\tBN_ULONG ta=(a),tb=(b),t0;\t\\\n-\tt1 = BN_UMULT_HIGH(ta,tb);\t\\\n-\tt0 = ta * tb;\t\t\t\\\n-\tt2 = t1+t1; c2 += (t2<t1)?1:0;\t\\\n-\tt1 = t0+t0; t2 += (t1<t0)?1:0;\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n+#define mul_add_c(a,b,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b);\t\t\\\n+\tBN_ULONG lo, hi;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,tb);\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define mul_add_c2(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b);\t\t\\\n+\tBN_ULONG lo, hi, tt;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,tb);\t\t\\\n+\tc0 += lo; tt = hi+((c0<lo)?1:0);\t\\\n+\tc1 += tt; c2 += (c1<tt)?1:0;\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define sqr_add_c(a,i,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a)[i];\t\t\t\\\n+\tBN_ULONG lo, hi;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,ta);\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n #else\n #define mul_add_c(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG t1,t2;\t\t\t\\\n \tasm (\""mulq %3\""\t\t\t\\\n \t\t: \""=a\""(t1),\""=d\""(t2)\t\\\n \t\t: \""a\""(a),\""m\""(b)\t\t\\\n \t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c0),\""+d\""(t2)\t\\\n-\t\t: \""a\""(t1),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c1),\""+r\""(c2)\t\\\n-\t\t: \""d\""(t2),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n+\tasm (\""addq %3,%0; adcq %4,%1; adcq %5,%2\""\t\\\n+\t\t: \""+r\""(c0),\""+r\""(c1),\""+r\""(c2)\t\t\\\n+\t\t: \""r\""(t1),\""r\""(t2),\""g\""(0)\t\t\\\n+\t\t: \""cc\"");\t\t\t\t\\\n \t} while (0)\n \n #define sqr_add_c(a,i,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG t1,t2;\t\t\t\\\n \tasm (\""mulq %2\""\t\t\t\\\n \t\t: \""=a\""(t1),\""=d\""(t2)\t\\\n \t\t: \""a\""(a[i])\t\t\\\n \t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c0),\""+d\""(t2)\t\\\n-\t\t: \""a\""(t1),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c1),\""+r\""(c2)\t\\\n-\t\t: \""d\""(t2),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n+\tasm (\""addq %3,%0; adcq %4,%1; adcq %5,%2\""\t\\\n+\t\t: \""+r\""(c0),\""+r\""(c1),\""+r\""(c2)\t\t\\\n+\t\t: \""r\""(t1),\""r\""(t2),\""g\""(0)\t\t\\\n+\t\t: \""cc\"");\t\t\t\t\\\n \t} while (0)\n \n #define mul_add_c2(a,b,c0,c1,c2) do {\t\\\n+\tBN_ULONG t1,t2;\t\t\t\\\n \tasm (\""mulq %3\""\t\t\t\\\n \t\t: \""=a\""(t1),\""=d\""(t2)\t\\\n \t\t: \""a\""(a),\""m\""(b)\t\t\\\n \t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %0,%0; adcq %2,%1\""\t\\\n-\t\t: \""+d\""(t2),\""+r\""(c2)\t\\\n-\t\t: \""g\""(0)\t\t\\\n-\t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %0,%0; adcq %2,%1\""\t\\\n-\t\t: \""+a\""(t1),\""+d\""(t2)\t\\\n-\t\t: \""g\""(0)\t\t\\\n-\t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c0),\""+d\""(t2)\t\\\n-\t\t: \""a\""(t1),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c1),\""+r\""(c2)\t\\\n-\t\t: \""d\""(t2),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n+\tasm (\""addq %3,%0; adcq %4,%1; adcq %5,%2\""\t\\\n+\t\t: \""+r\""(c0),\""+r\""(c1),\""+r\""(c2)\t\t\\\n+\t\t: \""r\""(t1),\""r\""(t2),\""g\""(0)\t\t\\\n+\t\t: \""cc\"");\t\t\t\t\\\n+\tasm (\""addq %3,%0; adcq %4,%1; adcq %5,%2\""\t\\\n+\t\t: \""+r\""(c0),\""+r\""(c1),\""+r\""(c2)\t\t\\\n+\t\t: \""r\""(t1),\""r\""(t2),\""g\""(0)\t\t\\\n+\t\t: \""cc\"");\t\t\t\t\\\n \t} while (0)\n #endif\n \n@@ -355,7 +354,6 @@ BN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)\n \n void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \t{\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -459,7 +457,6 @@ void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \n void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \t{\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -499,7 +496,6 @@ void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \n void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\n \t{\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -575,7 +571,6 @@ void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\n \n void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n \t{\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;""}<_**next**_>{""sha"": ""5027a583205b53135bc4e3e44b09a8c05b1fbbe6"", ""filename"": ""crypto/bn/bn_asm.c"", ""status"": ""modified"", ""additions"": 122, ""deletions"": 119, ""changes"": 241, ""blob_url"": ""https://github.com/openssl/openssl/blob/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/bn_asm.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/bn_asm.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/bn/bn_asm.c?ref=a7a44ba55cb4f884c6bc9ceac90072dea38e66d0"", ""patch"": ""@@ -439,129 +439,150 @@ BN_ULONG bn_sub_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b, int n)\n /* sqr_add_c2(a,i,c0,c1,c2) -- c+=2*a[i]*a[j] for three word number c=(c2,c1,c0) */\n \n #ifdef BN_LLONG\n-#define mul_add_c(a,b,c0,c1,c2) \\\n-\tt=(BN_ULLONG)a*b; \\\n-\tt1=(BN_ULONG)Lw(t); \\\n-\tt2=(BN_ULONG)Hw(t); \\\n-\tc0=(c0+t1)&BN_MASK2; if ((c0) < t1) t2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n-\n-#define mul_add_c2(a,b,c0,c1,c2) \\\n-\tt=(BN_ULLONG)a*b; \\\n-\ttt=(t+t)&BN_MASK; \\\n-\tif (tt < t) c2++; \\\n-\tt1=(BN_ULONG)Lw(tt); \\\n-\tt2=(BN_ULONG)Hw(tt); \\\n-\tc0=(c0+t1)&BN_MASK2;  \\\n-\tif ((c0 < t1) && (((++t2)&BN_MASK2) == 0)) c2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n-\n-#define sqr_add_c(a,i,c0,c1,c2) \\\n-\tt=(BN_ULLONG)a[i]*a[i]; \\\n-\tt1=(BN_ULONG)Lw(t); \\\n-\tt2=(BN_ULONG)Hw(t); \\\n-\tc0=(c0+t1)&BN_MASK2; if ((c0) < t1) t2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n+/*\n+ * Keep in mind that additions to multiplication result can not\n+ * overflow, because its high half cannot be all-ones.\n+ */\n+#define mul_add_c(a,b,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG hi;\t\t\t\t\\\n+\tBN_ULLONG t = (BN_ULLONG)(a)*(b);\t\\\n+\tt += c0;\t\t/* no carry */\t\\\n+\tc0 = (BN_ULONG)Lw(t);\t\t\t\\\n+\thi = (BN_ULONG)Hw(t);\t\t\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n+\n+#define mul_add_c2(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG hi;\t\t\t\t\\\n+\tBN_ULLONG t = (BN_ULLONG)(a)*(b);\t\\\n+\tBN_ULLONG tt = t+c0;\t/* no carry */\t\\\n+\tc0 = (BN_ULONG)Lw(tt);\t\t\t\\\n+\thi = (BN_ULONG)Hw(tt);\t\t\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\tt += c0;\t\t/* no carry */\t\\\n+\tc0 = (BN_ULONG)Lw(t);\t\t\t\\\n+\thi = (BN_ULONG)Hw(t);\t\t\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n+\n+#define sqr_add_c(a,i,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG hi;\t\t\t\t\\\n+\tBN_ULLONG t = (BN_ULLONG)a[i]*a[i];\t\\\n+\tt += c0;\t\t/* no carry */\t\\\n+\tc0 = (BN_ULONG)Lw(t);\t\t\t\\\n+\thi = (BN_ULONG)Hw(t);\t\t\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n \n #define sqr_add_c2(a,i,j,c0,c1,c2) \\\n \tmul_add_c2((a)[i],(a)[j],c0,c1,c2)\n \n #elif defined(BN_UMULT_LOHI)\n-\n-#define mul_add_c(a,b,c0,c1,c2)\t{\t\\\n-\tBN_ULONG ta=(a),tb=(b);\t\t\\\n-\tBN_UMULT_LOHI(t1,t2,ta,tb);\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n-\n-#define mul_add_c2(a,b,c0,c1,c2) {\t\\\n-\tBN_ULONG ta=(a),tb=(b),t0;\t\\\n-\tBN_UMULT_LOHI(t0,t1,ta,tb);\t\\\n-\tt2 = t1+t1; c2 += (t2<t1)?1:0;\t\\\n-\tt1 = t0+t0; t2 += (t1<t0)?1:0;\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n-\n-#define sqr_add_c(a,i,c0,c1,c2)\t{\t\\\n-\tBN_ULONG ta=(a)[i];\t\t\\\n-\tBN_UMULT_LOHI(t1,t2,ta,ta);\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n+/*\n+ * Keep in mind that additions to hi can not overflow, because\n+ * the high word of a multiplication result cannot be all-ones.\n+ */\n+#define mul_add_c(a,b,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b);\t\t\\\n+\tBN_ULONG lo, hi;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,tb);\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define mul_add_c2(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b);\t\t\\\n+\tBN_ULONG lo, hi, tt;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,tb);\t\t\\\n+\tc0 += lo; tt = hi+((c0<lo)?1:0);\t\\\n+\tc1 += tt; c2 += (c1<tt)?1:0;\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define sqr_add_c(a,i,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a)[i];\t\t\t\\\n+\tBN_ULONG lo, hi;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,ta);\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n \n #define sqr_add_c2(a,i,j,c0,c1,c2)\t\\\n \tmul_add_c2((a)[i],(a)[j],c0,c1,c2)\n \n #elif defined(BN_UMULT_HIGH)\n-\n-#define mul_add_c(a,b,c0,c1,c2)\t{\t\\\n-\tBN_ULONG ta=(a),tb=(b);\t\t\\\n-\tt1 = ta * tb;\t\t\t\\\n-\tt2 = BN_UMULT_HIGH(ta,tb);\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n-\n-#define mul_add_c2(a,b,c0,c1,c2) {\t\\\n-\tBN_ULONG ta=(a),tb=(b),t0;\t\\\n-\tt1 = BN_UMULT_HIGH(ta,tb);\t\\\n-\tt0 = ta * tb;\t\t\t\\\n-\tt2 = t1+t1; c2 += (t2<t1)?1:0;\t\\\n-\tt1 = t0+t0; t2 += (t1<t0)?1:0;\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n-\n-#define sqr_add_c(a,i,c0,c1,c2)\t{\t\\\n-\tBN_ULONG ta=(a)[i];\t\t\\\n-\tt1 = ta * ta;\t\t\t\\\n-\tt2 = BN_UMULT_HIGH(ta,ta);\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n+/*\n+ * Keep in mind that additions to hi can not overflow, because\n+ * the high word of a multiplication result cannot be all-ones.\n+ */\n+#define mul_add_c(a,b,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b);\t\t\\\n+\tBN_ULONG lo = ta * tb;\t\t\t\\\n+\tBN_ULONG hi = BN_UMULT_HIGH(ta,tb);\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define mul_add_c2(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b), tt;\t\\\n+\tBN_ULONG lo = ta * tb;\t\t\t\\\n+\tBN_ULONG hi = BN_UMULT_HIGH(ta,tb);\t\\\n+\tc0 += lo; tt = hi + ((c0<lo)?1:0);\t\\\n+\tc1 += tt; c2 += (c1<tt)?1:0;\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define sqr_add_c(a,i,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a)[i];\t\t\t\\\n+\tBN_ULONG lo = ta * ta;\t\t\t\\\n+\tBN_ULONG hi = BN_UMULT_HIGH(ta,ta);\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n \n #define sqr_add_c2(a,i,j,c0,c1,c2)\t\\\n \tmul_add_c2((a)[i],(a)[j],c0,c1,c2)\n \n #else /* !BN_LLONG */\n-#define mul_add_c(a,b,c0,c1,c2) \\\n-\tt1=LBITS(a); t2=HBITS(a); \\\n-\tbl=LBITS(b); bh=HBITS(b); \\\n-\tmul64(t1,t2,bl,bh); \\\n-\tc0=(c0+t1)&BN_MASK2; if ((c0) < t1) t2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n-\n-#define mul_add_c2(a,b,c0,c1,c2) \\\n-\tt1=LBITS(a); t2=HBITS(a); \\\n-\tbl=LBITS(b); bh=HBITS(b); \\\n-\tmul64(t1,t2,bl,bh); \\\n-\tif (t2 & BN_TBIT) c2++; \\\n-\tt2=(t2+t2)&BN_MASK2; \\\n-\tif (t1 & BN_TBIT) t2++; \\\n-\tt1=(t1+t1)&BN_MASK2; \\\n-\tc0=(c0+t1)&BN_MASK2;  \\\n-\tif ((c0 < t1) && (((++t2)&BN_MASK2) == 0)) c2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n-\n-#define sqr_add_c(a,i,c0,c1,c2) \\\n-\tsqr64(t1,t2,(a)[i]); \\\n-\tc0=(c0+t1)&BN_MASK2; if ((c0) < t1) t2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n+/*\n+ * Keep in mind that additions to hi can not overflow, because\n+ * the high word of a multiplication result cannot be all-ones.\n+ */\n+#define mul_add_c(a,b,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG lo = LBITS(a), hi = HBITS(a);\t\\\n+\tBN_ULONG bl = LBITS(b), bh = HBITS(b);\t\\\n+\tmul64(lo,hi,bl,bh);\t\t\t\\\n+\tc0 = (c0+lo)&BN_MASK2; if (c0<lo) hi++;\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n+\n+#define mul_add_c2(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG tt;\t\t\t\t\\\n+\tBN_ULONG lo = LBITS(a), hi = HBITS(a);\t\\\n+\tBN_ULONG bl = LBITS(b), bh = HBITS(b);\t\\\n+\tmul64(lo,hi,bl,bh);\t\t\t\\\n+\ttt = hi;\t\t\t\t\\\n+\tc0 = (c0+lo)&BN_MASK2; if (c0<lo) tt++;\t\\\n+\tc1 = (c1+tt)&BN_MASK2; if (c1<tt) c2++;\t\\\n+\tc0 = (c0+lo)&BN_MASK2; if (c0<lo) hi++;\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n+\n+#define sqr_add_c(a,i,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG lo, hi;\t\t\t\\\n+\tsqr64(lo,hi,(a)[i]);\t\t\t\\\n+\tc0 = (c0+lo)&BN_MASK2; if (c0<lo) hi++;\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n \n #define sqr_add_c2(a,i,j,c0,c1,c2) \\\n \tmul_add_c2((a)[i],(a)[j],c0,c1,c2)\n #endif /* !BN_LLONG */\n \n void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \t{\n-#ifdef BN_LLONG\n-\tBN_ULLONG t;\n-#else\n-\tBN_ULONG bl,bh;\n-#endif\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -665,12 +686,6 @@ void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \n void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \t{\n-#ifdef BN_LLONG\n-\tBN_ULLONG t;\n-#else\n-\tBN_ULONG bl,bh;\n-#endif\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -710,12 +725,6 @@ void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \n void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\n \t{\n-#ifdef BN_LLONG\n-\tBN_ULLONG t,tt;\n-#else\n-\tBN_ULONG bl,bh;\n-#endif\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -791,12 +800,6 @@ void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\n \n void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n \t{\n-#ifdef BN_LLONG\n-\tBN_ULLONG t,tt;\n-#else\n-\tBN_ULONG bl,bh;\n-#endif\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;""}<_**next**_>{""sha"": ""869ae05a901d51ee69ad4d181337ba1d8c34e7a4"", ""filename"": ""crypto/bn/bntest.c"", ""status"": ""modified"", ""additions"": 78, ""deletions"": 24, ""changes"": 102, ""blob_url"": ""https://github.com/openssl/openssl/blob/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/bntest.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/bntest.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/bn/bntest.c?ref=a7a44ba55cb4f884c6bc9ceac90072dea38e66d0"", ""patch"": ""@@ -689,44 +689,98 @@ int test_mul(BIO *bp)\n \n int test_sqr(BIO *bp, BN_CTX *ctx)\n \t{\n-\tBIGNUM a,c,d,e;\n-\tint i;\n+\tBIGNUM *a,*c,*d,*e;\n+\tint i, ret = 0;\n \n-\tBN_init(&a);\n-\tBN_init(&c);\n-\tBN_init(&d);\n-\tBN_init(&e);\n+\ta = BN_new();\n+\tc = BN_new();\n+\td = BN_new();\n+\te = BN_new();\n+\tif (a == NULL || c == NULL || d == NULL || e == NULL)\n+\t\t{\n+\t\tgoto err;\n+\t\t}\n \n \tfor (i=0; i<num0; i++)\n \t\t{\n-\t\tBN_bntest_rand(&a,40+i*10,0,0);\n-\t\ta.neg=rand_neg();\n-\t\tBN_sqr(&c,&a,ctx);\n+\t\tBN_bntest_rand(a,40+i*10,0,0);\n+\t\ta->neg=rand_neg();\n+\t\tBN_sqr(c,a,ctx);\n \t\tif (bp != NULL)\n \t\t\t{\n \t\t\tif (!results)\n \t\t\t\t{\n-\t\t\t\tBN_print(bp,&a);\n+\t\t\t\tBN_print(bp,a);\n \t\t\t\tBIO_puts(bp,\"" * \"");\n-\t\t\t\tBN_print(bp,&a);\n+\t\t\t\tBN_print(bp,a);\n \t\t\t\tBIO_puts(bp,\"" - \"");\n \t\t\t\t}\n-\t\t\tBN_print(bp,&c);\n+\t\t\tBN_print(bp,c);\n \t\t\tBIO_puts(bp,\""\\n\"");\n \t\t\t}\n-\t\tBN_div(&d,&e,&c,&a,ctx);\n-\t\tBN_sub(&d,&d,&a);\n-\t\tif(!BN_is_zero(&d) || !BN_is_zero(&e))\n-\t\t    {\n-\t\t    fprintf(stderr,\""Square test failed!\\n\"");\n-\t\t    return 0;\n-\t\t    }\n+\t\tBN_div(d,e,c,a,ctx);\n+\t\tBN_sub(d,d,a);\n+\t\tif(!BN_is_zero(d) || !BN_is_zero(e))\n+\t\t\t{\n+\t\t\tfprintf(stderr,\""Square test failed!\\n\"");\n+\t\t\tgoto err;\n+\t\t\t}\n \t\t}\n-\tBN_free(&a);\n-\tBN_free(&c);\n-\tBN_free(&d);\n-\tBN_free(&e);\n-\treturn(1);\n+\n+\t/* Regression test for a BN_sqr overflow bug. */\n+\tBN_hex2bn(&a,\n+\t\t\""80000000000000008000000000000001FFFFFFFFFFFFFFFE0000000000000000\"");\n+\tBN_sqr(c, a, ctx);\n+\tif (bp != NULL)\n+\t\t{\n+\t\tif (!results)\n+\t\t\t{\n+\t\t\tBN_print(bp,a);\n+\t\t\tBIO_puts(bp,\"" * \"");\n+\t\t\tBN_print(bp,a);\n+\t\t\tBIO_puts(bp,\"" - \"");\n+\t\t\t}\n+\t\tBN_print(bp,c);\n+\t\tBIO_puts(bp,\""\\n\"");\n+\t\t}\n+\tBN_mul(d, a, a, ctx);\n+\tif (BN_cmp(c, d))\n+\t\t{\n+\t\tfprintf(stderr, \""Square test failed: BN_sqr and BN_mul produce \""\n+\t\t\t\""different results!\\n\"");\n+\t\tgoto err;\n+\t\t}\n+\n+\t/* Regression test for a BN_sqr overflow bug. */\n+\tBN_hex2bn(&a,\n+\t\t\""80000000000000000000000080000001FFFFFFFE000000000000000000000000\"");\n+\tBN_sqr(c, a, ctx);\n+\tif (bp != NULL)\n+\t\t{\n+\t\tif (!results)\n+\t\t\t{\n+\t\t\tBN_print(bp,a);\n+\t\t\tBIO_puts(bp,\"" * \"");\n+\t\t\tBN_print(bp,a);\n+\t\t\tBIO_puts(bp,\"" - \"");\n+\t\t\t}\n+\t\tBN_print(bp,c);\n+\t\tBIO_puts(bp,\""\\n\"");\n+\t\t}\n+\tBN_mul(d, a, a, ctx);\n+\tif (BN_cmp(c, d))\n+\t\t{\n+\t\tfprintf(stderr, \""Square test failed: BN_sqr and BN_mul produce \""\n+\t\t\t\""different results!\\n\"");\n+\t\tgoto err;\n+\t\t}\n+\tret = 1;\n+err:\n+\tif (a != NULL) BN_free(a);\n+\tif (c != NULL) BN_free(c);\n+\tif (d != NULL) BN_free(d);\n+\tif (e != NULL) BN_free(e);\n+\treturn ret;\n \t}\n \n int test_mont(BIO *bp, BN_CTX *ctx)""}"," void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
 	{
 	BN_ULONG c1,c2,c3;
 
 	c1=0;
	c2=0;
	c3=0;
	mul_add_c(a[0],b[0],c1,c2,c3);
	r[0]=c1;
	c1=0;
	mul_add_c(a[0],b[1],c2,c3,c1);
	mul_add_c(a[1],b[0],c2,c3,c1);
	r[1]=c2;
	c2=0;
	mul_add_c(a[2],b[0],c3,c1,c2);
	mul_add_c(a[1],b[1],c3,c1,c2);
	mul_add_c(a[0],b[2],c3,c1,c2);
	r[2]=c3;
	c3=0;
	mul_add_c(a[0],b[3],c1,c2,c3);
	mul_add_c(a[1],b[2],c1,c2,c3);
	mul_add_c(a[2],b[1],c1,c2,c3);
	mul_add_c(a[3],b[0],c1,c2,c3);
	r[3]=c1;
	c1=0;
	mul_add_c(a[3],b[1],c2,c3,c1);
	mul_add_c(a[2],b[2],c2,c3,c1);
	mul_add_c(a[1],b[3],c2,c3,c1);
	r[4]=c2;
	c2=0;
	mul_add_c(a[2],b[3],c3,c1,c2);
	mul_add_c(a[3],b[2],c3,c1,c2);
	r[5]=c3;
	c3=0;
	mul_add_c(a[3],b[3],c1,c2,c3);
	r[6]=c1;
	r[7]=c2;
	}
"," void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
 	{
	BN_ULONG t1,t2;
 	BN_ULONG c1,c2,c3;
 
 	c1=0;
	c2=0;
	c3=0;
	mul_add_c(a[0],b[0],c1,c2,c3);
	r[0]=c1;
	c1=0;
	mul_add_c(a[0],b[1],c2,c3,c1);
	mul_add_c(a[1],b[0],c2,c3,c1);
	r[1]=c2;
	c2=0;
	mul_add_c(a[2],b[0],c3,c1,c2);
	mul_add_c(a[1],b[1],c3,c1,c2);
	mul_add_c(a[0],b[2],c3,c1,c2);
	r[2]=c3;
	c3=0;
	mul_add_c(a[0],b[3],c1,c2,c3);
	mul_add_c(a[1],b[2],c1,c2,c3);
	mul_add_c(a[2],b[1],c1,c2,c3);
	mul_add_c(a[3],b[0],c1,c2,c3);
	r[3]=c1;
	c1=0;
	mul_add_c(a[3],b[1],c2,c3,c1);
	mul_add_c(a[2],b[2],c2,c3,c1);
	mul_add_c(a[1],b[3],c2,c3,c1);
	r[4]=c2;
	c2=0;
	mul_add_c(a[2],b[3],c3,c1,c2);
	mul_add_c(a[3],b[2],c3,c1,c2);
	r[5]=c3;
	c3=0;
	mul_add_c(a[3],b[3],c1,c2,c3);
	r[6]=c1;
	r[7]=c2;
	}
",C,,"	BN_ULONG t1,t2;
",,"@@ -276,77 +276,76 @@ BN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)
 /* sqr_add_c(a,i,c0,c1,c2)  -- c+=a[i]^2 for three word number c=(c2,c1,c0) */
 /* sqr_add_c2(a,i,c0,c1,c2) -- c+=2*a[i]*a[j] for three word number c=(c2,c1,c0) */
 
+/*
+ * Keep in mind that carrying into high part of multiplication result
+ * can not overflow, because it cannot be all-ones.
+ */
 #if 0
 /* original macros are kept for reference purposes */
-#define mul_add_c(a,b,c0,c1,c2) {	\
-	BN_ULONG ta=(a),tb=(b);		\
-	t1 = ta * tb;			\
-	t2 = BN_UMULT_HIGH(ta,tb);	\
-	c0 += t1; t2 += (c0<t1)?1:0;	\
-	c1 += t2; c2 += (c1<t2)?1:0;	\
-	}
-
-#define mul_add_c2(a,b,c0,c1,c2) {	\
-	BN_ULONG ta=(a),tb=(b),t0;	\
-	t1 = BN_UMULT_HIGH(ta,tb);	\
-	t0 = ta * tb;			\
-	t2 = t1+t1; c2 += (t2<t1)?1:0;	\
-	t1 = t0+t0; t2 += (t1<t0)?1:0;	\
-	c0 += t1; t2 += (c0<t1)?1:0;	\
-	c1 += t2; c2 += (c1<t2)?1:0;	\
-	}
+#define mul_add_c(a,b,c0,c1,c2)		do {	\
+	BN_ULONG ta = (a), tb = (b);		\
+	BN_ULONG lo, hi;			\
+	BN_UMULT_LOHI(lo,hi,ta,tb);		\
+	c0 += lo; hi += (c0<lo)?1:0;		\
+	c1 += hi; c2 += (c1<hi)?1:0;		\
+	} while(0)
+
+#define mul_add_c2(a,b,c0,c1,c2)	do {	\
+	BN_ULONG ta = (a), tb = (b);		\
+	BN_ULONG lo, hi, tt;			\
+	BN_UMULT_LOHI(lo,hi,ta,tb);		\
+	c0 += lo; tt = hi+((c0<lo)?1:0);	\
+	c1 += tt; c2 += (c1<tt)?1:0;		\
+	c0 += lo; hi += (c0<lo)?1:0;		\
+	c1 += hi; c2 += (c1<hi)?1:0;		\
+	} while(0)
+
+#define sqr_add_c(a,i,c0,c1,c2)		do {	\
+	BN_ULONG ta = (a)[i];			\
+	BN_ULONG lo, hi;			\
+	BN_UMULT_LOHI(lo,hi,ta,ta);		\
+	c0 += lo; hi += (c0<lo)?1:0;		\
+	c1 += hi; c2 += (c1<hi)?1:0;		\
+	} while(0)
 #else
 #define mul_add_c(a,b,c0,c1,c2)	do {	\
+	BN_ULONG t1,t2;			\
 	asm (""mulq %3""			\
 		: ""=a""(t1),""=d""(t2)	\
 		: ""a""(a),""m""(b)		\
 		: ""cc"");		\
-	asm (""addq %2,%0; adcq %3,%1""	\
-		: ""+r""(c0),""+d""(t2)	\
-		: ""a""(t1),""g""(0)	\
-		: ""cc"");		\
-	asm (""addq %2,%0; adcq %3,%1""	\
-		: ""+r""(c1),""+r""(c2)	\
-		: ""d""(t2),""g""(0)	\
-		: ""cc"");		\
+	asm (""addq %3,%0; adcq %4,%1; adcq %5,%2""	\
+		: ""+r""(c0),""+r""(c1),""+r""(c2)		\
+		: ""r""(t1),""r""(t2),""g""(0)		\
+		: ""cc"");				\
 	} while (0)
 
 #define sqr_add_c(a,i,c0,c1,c2)	do {	\
+	BN_ULONG t1,t2;			\
 	asm (""mulq %2""			\
 		: ""=a""(t1),""=d""(t2)	\
 		: ""a""(a[i])		\
 		: ""cc"");		\
-	asm (""addq %2,%0; adcq %3,%1""	\
-		: ""+r""(c0),""+d""(t2)	\
-		: ""a""(t1),""g""(0)	\
-		: ""cc"");		\
-	asm (""addq %2,%0; adcq %3,%1""	\
-		: ""+r""(c1),""+r""(c2)	\
-		: ""d""(t2),""g""(0)	\
-		: ""cc"");		\
+	asm (""addq %3,%0; adcq %4,%1; adcq %5,%2""	\
+		: ""+r""(c0),""+r""(c1),""+r""(c2)		\
+		: ""r""(t1),""r""(t2),""g""(0)		\
+		: ""cc"");				\
 	} while (0)
 
 #define mul_add_c2(a,b,c0,c1,c2) do {	\
+	BN_ULONG t1,t2;			\
 	asm (""mulq %3""			\
 		: ""=a""(t1),""=d""(t2)	\
 		: ""a""(a),""m""(b)		\
 		: ""cc"");		\
-	asm (""addq %0,%0; adcq %2,%1""	\
-		: ""+d""(t2),""+r""(c2)	\
-		: ""g""(0)		\
-		: ""cc"");		\
-	asm (""addq %0,%0; adcq %2,%1""	\
-		: ""+a""(t1),""+d""(t2)	\
-		: ""g""(0)		\
-		: ""cc"");		\
-	asm (""addq %2,%0; adcq %3,%1""	\
-		: ""+r""(c0),""+d""(t2)	\
-		: ""a""(t1),""g""(0)	\
-		: ""cc"");		\
-	asm (""addq %2,%0; adcq %3,%1""	\
-		: ""+r""(c1),""+r""(c2)	\
-		: ""d""(t2),""g""(0)	\
-		: ""cc"");		\
+	asm (""addq %3,%0; adcq %4,%1; adcq %5,%2""	\
+		: ""+r""(c0),""+r""(c1),""+r""(c2)		\
+		: ""r""(t1),""r""(t2),""g""(0)		\
+		: ""cc"");				\
+	asm (""addq %3,%0; adcq %4,%1; adcq %5,%2""	\
+		: ""+r""(c0),""+r""(c1),""+r""(c2)		\
+		: ""r""(t1),""r""(t2),""g""(0)		\
+		: ""cc"");				\
 	} while (0)
 #endif
 
@@ -355,7 +354,6 @@ BN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)
 
 void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
 	{
-	BN_ULONG t1,t2;
 	BN_ULONG c1,c2,c3;
 
 	c1=0;
@@ -459,7 +457,6 @@ void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
 
 void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
 	{
-	BN_ULONG t1,t2;
 	BN_ULONG c1,c2,c3;
 
 	c1=0;
@@ -499,7 +496,6 @@ void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
 
 void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)
 	{
-	BN_ULONG t1,t2;
 	BN_ULONG c1,c2,c3;
 
 	c1=0;
@@ -575,7 +571,6 @@ void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)
 
 void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)
 	{
-	BN_ULONG t1,t2;
 	BN_ULONG c1,c2,c3;
 
 	c1=0;",openssl,a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,248385c606620b29ecc96ca9d3603463f879652b,1," void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
 	{
//flaw_line_below:
	BN_ULONG t1,t2;
 	BN_ULONG c1,c2,c3;
 
 	c1=0;
	c2=0;
	c3=0;
	mul_add_c(a[0],b[0],c1,c2,c3);
	r[0]=c1;
	c1=0;
	mul_add_c(a[0],b[1],c2,c3,c1);
	mul_add_c(a[1],b[0],c2,c3,c1);
	r[1]=c2;
	c2=0;
	mul_add_c(a[2],b[0],c3,c1,c2);
	mul_add_c(a[1],b[1],c3,c1,c2);
	mul_add_c(a[0],b[2],c3,c1,c2);
	r[2]=c3;
	c3=0;
	mul_add_c(a[0],b[3],c1,c2,c3);
	mul_add_c(a[1],b[2],c1,c2,c3);
	mul_add_c(a[2],b[1],c1,c2,c3);
	mul_add_c(a[3],b[0],c1,c2,c3);
	r[3]=c1;
	c1=0;
	mul_add_c(a[3],b[1],c2,c3,c1);
	mul_add_c(a[2],b[2],c2,c3,c1);
	mul_add_c(a[1],b[3],c2,c3,c1);
	r[4]=c2;
	c2=0;
	mul_add_c(a[2],b[3],c3,c1,c2);
	mul_add_c(a[3],b[2],c3,c1,c2);
	r[5]=c3;
	c3=0;
	mul_add_c(a[3],b[3],c1,c2,c3);
	r[6]=c1;
	r[7]=c2;
	}
"
2265,180001,,Remote,Not required,,CVE-2014-3570,https://www.cvedetails.com/cve/CVE-2014-3570/,CWE-310,Low,Partial,,,2015-01-08,5.0,"The BN_sqr implementation in OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not properly calculate the square of a BIGNUM value, which might make it easier for remote attackers to defeat cryptographic protection mechanisms via unspecified vectors, related to crypto/bn/asm/mips.pl, crypto/bn/asm/x86_64-gcc.c, and crypto/bn/bn_asm.c.",2017-11-14,,0,https://github.com/openssl/openssl/commit/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,"Fix for CVE-2014-3570 (with minor bn_asm.c revamp).

Reviewed-by: Emilia Kasper <emilia@openssl.org>",1,crypto/bn/asm/x86_64-gcc.c,"{""sha"": ""acafde5e5685ccb7e2d59b218d45d1bda0572fbd"", ""filename"": ""crypto/bn/asm/mips.pl"", ""status"": ""modified"", ""additions"": 131, ""deletions"": 480, ""changes"": 611, ""blob_url"": ""https://github.com/openssl/openssl/blob/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/asm/mips.pl"", ""raw_url"": ""https://github.com/openssl/openssl/raw/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/asm/mips.pl"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/bn/asm/mips.pl?ref=a7a44ba55cb4f884c6bc9ceac90072dea38e66d0"", ""patch"": ""@@ -1872,6 +1872,41 @@\n \n ($a_4,$a_5,$a_6,$a_7)=($b_0,$b_1,$b_2,$b_3);\n \n+sub add_c2 () {\n+my ($hi,$lo,$c0,$c1,$c2,\n+    $warm,      # !$warm denotes first call with specific sequence of\n+                # $c_[XYZ] when there is no Z-carry to accumulate yet;\n+    $an,$bn     # these two are arguments for multiplication which\n+                # result is used in *next* step [which is why it's\n+                # commented as \""forward multiplication\"" below];\n+    )=@_;\n+$code.=<<___;\n+\tmflo\t$lo\n+\tmfhi\t$hi\n+\t$ADDU\t$c0,$lo\n+\tsltu\t$at,$c0,$lo\n+\t $MULTU\t$an,$bn\t\t\t# forward multiplication\n+\t$ADDU\t$c0,$lo\n+\t$ADDU\t$at,$hi\n+\tsltu\t$lo,$c0,$lo\n+\t$ADDU\t$c1,$at\n+\t$ADDU\t$hi,$lo\n+___\n+$code.=<<___\tif (!$warm);\n+\tsltu\t$c2,$c1,$at\n+\t$ADDU\t$c1,$hi\n+\tsltu\t$hi,$c1,$hi\n+\t$ADDU\t$c2,$hi\n+___\n+$code.=<<___\tif ($warm);\n+\tsltu\t$at,$c1,$at\n+\t$ADDU\t$c1,$hi\n+\t$ADDU\t$c2,$at\n+\tsltu\t$hi,$c1,$hi\n+\t$ADDU\t$c2,$hi\n+___\n+}\n+\n $code.=<<___;\n \n .align\t5\n@@ -1920,21 +1955,10 @@\n \tsltu\t$at,$c_2,$t_1\n \t$ADDU\t$c_3,$t_2,$at\n \t$ST\t$c_2,$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_1\t\t# mul_add_c(a[1],b[1],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_1,$a_1);\t\t# mul_add_c(a[1],b[1],c3,c1,c2);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_3,$t_1\n@@ -1945,67 +1969,19 @@\n \tsltu\t$at,$c_1,$t_2\n \t$ADDU\t$c_2,$at\n \t$ST\t$c_3,2*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_3,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_2\t\t# mul_add_c2(a[1],b[2],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t $MULTU\t$a_4,$a_0\t\t# mul_add_c2(a[4],b[0],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,0,\n+\t\t$a_1,$a_2);\t\t# mul_add_c2(a[1],b[2],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_4,$a_0);\t\t# mul_add_c2(a[4],b[0],c2,c3,c1);\n+$code.=<<___;\n \t$ST\t$c_1,3*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_1,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_3,$a_1\t\t# mul_add_c2(a[3],b[1],c2,c3,c1);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_1,$at\n-\t$MULTU\t$a_2,$a_2\t\t# mul_add_c(a[2],b[2],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,0,\n+\t\t$a_3,$a_1);\t\t# mul_add_c2(a[3],b[1],c2,c3,c1);\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,1,\n+\t\t$a_2,$a_2);\t\t# mul_add_c(a[2],b[2],c2,c3,c1);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_2,$t_1\n@@ -2016,97 +1992,23 @@\n \tsltu\t$at,$c_3,$t_2\n \t$ADDU\t$c_1,$at\n \t$ST\t$c_2,4*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_4\t\t# mul_add_c2(a[1],b[4],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_2,$at\n-\t$MULTU\t$a_2,$a_3\t\t# mul_add_c2(a[2],b[3],c3,c1,c2);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t $MULTU\t$a_6,$a_0\t\t# mul_add_c2(a[6],b[0],c1,c2,c3);\n-\t$ADDU\t$c_2,$at\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_1,$a_4);\t\t# mul_add_c2(a[1],b[4],c3,c1,c2);\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,1,\n+\t\t$a_2,$a_3);\t\t# mul_add_c2(a[2],b[3],c3,c1,c2);\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,1,\n+\t\t$a_6,$a_0);\t\t# mul_add_c2(a[6],b[0],c1,c2,c3);\n+$code.=<<___;\n \t$ST\t$c_3,5*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_3,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_5,$a_1\t\t# mul_add_c2(a[5],b[1],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t$MULTU\t$a_4,$a_2\t\t# mul_add_c2(a[4],b[2],c1,c2,c3);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t$MULTU\t$a_3,$a_3\t\t# mul_add_c(a[3],b[3],c1,c2,c3);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,0,\n+\t\t$a_5,$a_1);\t\t# mul_add_c2(a[5],b[1],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_4,$a_2);\t\t# mul_add_c2(a[4],b[2],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_3,$a_3);\t\t# mul_add_c(a[3],b[3],c1,c2,c3);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_1,$t_1\n@@ -2117,112 +2019,25 @@\n \tsltu\t$at,$c_2,$t_2\n \t$ADDU\t$c_3,$at\n \t$ST\t$c_1,6*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_1,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_6\t\t# mul_add_c2(a[1],b[6],c2,c3,c1);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_1,$at\n-\t$MULTU\t$a_2,$a_5\t\t# mul_add_c2(a[2],b[5],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_1,$at\n-\t$MULTU\t$a_3,$a_4\t\t# mul_add_c2(a[3],b[4],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_1,$at\n-\t $MULTU\t$a_7,$a_1\t\t# mul_add_c2(a[7],b[1],c3,c1,c2);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,0,\n+\t\t$a_1,$a_6);\t\t# mul_add_c2(a[1],b[6],c2,c3,c1);\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,1,\n+\t\t$a_2,$a_5);\t\t# mul_add_c2(a[2],b[5],c2,c3,c1);\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,1,\n+\t\t$a_3,$a_4);\t\t# mul_add_c2(a[3],b[4],c2,c3,c1);\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,1,\n+\t\t$a_7,$a_1);\t\t# mul_add_c2(a[7],b[1],c3,c1,c2);\n+$code.=<<___;\n \t$ST\t$c_2,7*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_6,$a_2\t\t# mul_add_c2(a[6],b[2],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_2,$at\n-\t$MULTU\t$a_5,$a_3\t\t# mul_add_c2(a[5],b[3],c3,c1,c2);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_2,$at\n-\t$MULTU\t$a_4,$a_4\t\t# mul_add_c(a[4],b[4],c3,c1,c2);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_6,$a_2);\t\t# mul_add_c2(a[6],b[2],c3,c1,c2);\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,1,\n+\t\t$a_5,$a_3);\t\t# mul_add_c2(a[5],b[3],c3,c1,c2);\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,1,\n+\t\t$a_4,$a_4);\t\t# mul_add_c(a[4],b[4],c3,c1,c2);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_3,$t_1\n@@ -2233,82 +2048,21 @@\n \tsltu\t$at,$c_1,$t_2\n \t$ADDU\t$c_2,$at\n \t$ST\t$c_3,8*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_3,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_3,$a_6\t\t# mul_add_c2(a[3],b[6],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t$MULTU\t$a_4,$a_5\t\t# mul_add_c2(a[4],b[5],c1,c2,c3);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t $MULTU\t$a_7,$a_3\t\t# mul_add_c2(a[7],b[3],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,0,\n+\t\t$a_3,$a_6);\t\t# mul_add_c2(a[3],b[6],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_4,$a_5);\t\t# mul_add_c2(a[4],b[5],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_7,$a_3);\t\t# mul_add_c2(a[7],b[3],c2,c3,c1);\n+$code.=<<___;\n \t$ST\t$c_1,9*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_1,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_6,$a_4\t\t# mul_add_c2(a[6],b[4],c2,c3,c1);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_1,$at\n-\t$MULTU\t$a_5,$a_5\t\t# mul_add_c(a[5],b[5],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,0,\n+\t\t$a_6,$a_4);\t\t# mul_add_c2(a[6],b[4],c2,c3,c1);\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,1,\n+\t\t$a_5,$a_5);\t\t# mul_add_c(a[5],b[5],c2,c3,c1);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_2,$t_1\n@@ -2319,52 +2073,17 @@\n \tsltu\t$at,$c_3,$t_2\n \t$ADDU\t$c_1,$at\n \t$ST\t$c_2,10*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_5,$a_6\t\t# mul_add_c2(a[5],b[6],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_2,$at\n-\t $MULTU\t$a_7,$a_5\t\t# mul_add_c2(a[7],b[5],c1,c2,c3);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_5,$a_6);\t\t# mul_add_c2(a[5],b[6],c3,c1,c2);\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,1,\n+\t\t$a_7,$a_5);\t\t# mul_add_c2(a[7],b[5],c1,c2,c3);\n+$code.=<<___;\n \t$ST\t$c_3,11*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_3,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_6,$a_6\t\t# mul_add_c(a[6],b[6],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,0,\n+\t\t$a_6,$a_6);\t\t# mul_add_c(a[6],b[6],c1,c2,c3);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_1,$t_1\n@@ -2375,21 +2094,10 @@\n \tsltu\t$at,$c_2,$t_2\n \t$ADDU\t$c_3,$at\n \t$ST\t$c_1,12*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_1,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t $MULTU\t$a_7,$a_7\t\t# mul_add_c(a[7],b[7],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,0,\n+\t\t$a_7,$a_7);\t\t# mul_add_c(a[7],b[7],c3,c1,c2);\n+$code.=<<___;\n \t$ST\t$c_2,13*$BNSZ($a0)\n \n \tmflo\t$t_1\n@@ -2457,21 +2165,10 @@\n \tsltu\t$at,$c_2,$t_1\n \t$ADDU\t$c_3,$t_2,$at\n \t$ST\t$c_2,$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_1\t\t# mul_add_c(a[1],b[1],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_1,$a_1);\t\t# mul_add_c(a[1],b[1],c3,c1,c2);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_3,$t_1\n@@ -2482,52 +2179,17 @@\n \tsltu\t$at,$c_1,$t_2\n \t$ADDU\t$c_2,$at\n \t$ST\t$c_3,2*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_3,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_2\t\t# mul_add_c(a2[1],b[2],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t $MULTU\t$a_3,$a_1\t\t# mul_add_c2(a[3],b[1],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,0,\n+\t\t$a_1,$a_2);\t\t# mul_add_c2(a2[1],b[2],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_3,$a_1);\t\t# mul_add_c2(a[3],b[1],c2,c3,c1);\n+$code.=<<___;\n \t$ST\t$c_1,3*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_1,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_2,$a_2\t\t# mul_add_c(a[2],b[2],c2,c3,c1);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,0,\n+\t\t$a_2,$a_2);\t\t# mul_add_c(a[2],b[2],c2,c3,c1);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_2,$t_1\n@@ -2538,21 +2200,10 @@\n \tsltu\t$at,$c_3,$t_2\n \t$ADDU\t$c_1,$at\n \t$ST\t$c_2,4*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t $MULTU\t$a_3,$a_3\t\t# mul_add_c(a[3],b[3],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_3,$a_3);\t\t# mul_add_c(a[3],b[3],c1,c2,c3);\n+$code.=<<___;\n \t$ST\t$c_3,5*$BNSZ($a0)\n \n \tmflo\t$t_1""}<_**next**_>{""sha"": ""7f7e5c2f0ae57a3c82c80e566c04df94b25c1a6a"", ""filename"": ""crypto/bn/asm/x86_64-gcc.c"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 53, ""changes"": 101, ""blob_url"": ""https://github.com/openssl/openssl/blob/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/asm/x86_64-gcc.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/asm/x86_64-gcc.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/bn/asm/x86_64-gcc.c?ref=a7a44ba55cb4f884c6bc9ceac90072dea38e66d0"", ""patch"": ""@@ -276,77 +276,76 @@ BN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)\n /* sqr_add_c(a,i,c0,c1,c2)  -- c+=a[i]^2 for three word number c=(c2,c1,c0) */\n /* sqr_add_c2(a,i,c0,c1,c2) -- c+=2*a[i]*a[j] for three word number c=(c2,c1,c0) */\n \n+/*\n+ * Keep in mind that carrying into high part of multiplication result\n+ * can not overflow, because it cannot be all-ones.\n+ */\n #if 0\n /* original macros are kept for reference purposes */\n-#define mul_add_c(a,b,c0,c1,c2) {\t\\\n-\tBN_ULONG ta=(a),tb=(b);\t\t\\\n-\tt1 = ta * tb;\t\t\t\\\n-\tt2 = BN_UMULT_HIGH(ta,tb);\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n-\n-#define mul_add_c2(a,b,c0,c1,c2) {\t\\\n-\tBN_ULONG ta=(a),tb=(b),t0;\t\\\n-\tt1 = BN_UMULT_HIGH(ta,tb);\t\\\n-\tt0 = ta * tb;\t\t\t\\\n-\tt2 = t1+t1; c2 += (t2<t1)?1:0;\t\\\n-\tt1 = t0+t0; t2 += (t1<t0)?1:0;\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n+#define mul_add_c(a,b,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b);\t\t\\\n+\tBN_ULONG lo, hi;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,tb);\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define mul_add_c2(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b);\t\t\\\n+\tBN_ULONG lo, hi, tt;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,tb);\t\t\\\n+\tc0 += lo; tt = hi+((c0<lo)?1:0);\t\\\n+\tc1 += tt; c2 += (c1<tt)?1:0;\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define sqr_add_c(a,i,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a)[i];\t\t\t\\\n+\tBN_ULONG lo, hi;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,ta);\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n #else\n #define mul_add_c(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG t1,t2;\t\t\t\\\n \tasm (\""mulq %3\""\t\t\t\\\n \t\t: \""=a\""(t1),\""=d\""(t2)\t\\\n \t\t: \""a\""(a),\""m\""(b)\t\t\\\n \t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c0),\""+d\""(t2)\t\\\n-\t\t: \""a\""(t1),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c1),\""+r\""(c2)\t\\\n-\t\t: \""d\""(t2),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n+\tasm (\""addq %3,%0; adcq %4,%1; adcq %5,%2\""\t\\\n+\t\t: \""+r\""(c0),\""+r\""(c1),\""+r\""(c2)\t\t\\\n+\t\t: \""r\""(t1),\""r\""(t2),\""g\""(0)\t\t\\\n+\t\t: \""cc\"");\t\t\t\t\\\n \t} while (0)\n \n #define sqr_add_c(a,i,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG t1,t2;\t\t\t\\\n \tasm (\""mulq %2\""\t\t\t\\\n \t\t: \""=a\""(t1),\""=d\""(t2)\t\\\n \t\t: \""a\""(a[i])\t\t\\\n \t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c0),\""+d\""(t2)\t\\\n-\t\t: \""a\""(t1),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c1),\""+r\""(c2)\t\\\n-\t\t: \""d\""(t2),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n+\tasm (\""addq %3,%0; adcq %4,%1; adcq %5,%2\""\t\\\n+\t\t: \""+r\""(c0),\""+r\""(c1),\""+r\""(c2)\t\t\\\n+\t\t: \""r\""(t1),\""r\""(t2),\""g\""(0)\t\t\\\n+\t\t: \""cc\"");\t\t\t\t\\\n \t} while (0)\n \n #define mul_add_c2(a,b,c0,c1,c2) do {\t\\\n+\tBN_ULONG t1,t2;\t\t\t\\\n \tasm (\""mulq %3\""\t\t\t\\\n \t\t: \""=a\""(t1),\""=d\""(t2)\t\\\n \t\t: \""a\""(a),\""m\""(b)\t\t\\\n \t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %0,%0; adcq %2,%1\""\t\\\n-\t\t: \""+d\""(t2),\""+r\""(c2)\t\\\n-\t\t: \""g\""(0)\t\t\\\n-\t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %0,%0; adcq %2,%1\""\t\\\n-\t\t: \""+a\""(t1),\""+d\""(t2)\t\\\n-\t\t: \""g\""(0)\t\t\\\n-\t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c0),\""+d\""(t2)\t\\\n-\t\t: \""a\""(t1),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c1),\""+r\""(c2)\t\\\n-\t\t: \""d\""(t2),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n+\tasm (\""addq %3,%0; adcq %4,%1; adcq %5,%2\""\t\\\n+\t\t: \""+r\""(c0),\""+r\""(c1),\""+r\""(c2)\t\t\\\n+\t\t: \""r\""(t1),\""r\""(t2),\""g\""(0)\t\t\\\n+\t\t: \""cc\"");\t\t\t\t\\\n+\tasm (\""addq %3,%0; adcq %4,%1; adcq %5,%2\""\t\\\n+\t\t: \""+r\""(c0),\""+r\""(c1),\""+r\""(c2)\t\t\\\n+\t\t: \""r\""(t1),\""r\""(t2),\""g\""(0)\t\t\\\n+\t\t: \""cc\"");\t\t\t\t\\\n \t} while (0)\n #endif\n \n@@ -355,7 +354,6 @@ BN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)\n \n void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \t{\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -459,7 +457,6 @@ void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \n void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \t{\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -499,7 +496,6 @@ void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \n void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\n \t{\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -575,7 +571,6 @@ void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\n \n void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n \t{\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;""}<_**next**_>{""sha"": ""5027a583205b53135bc4e3e44b09a8c05b1fbbe6"", ""filename"": ""crypto/bn/bn_asm.c"", ""status"": ""modified"", ""additions"": 122, ""deletions"": 119, ""changes"": 241, ""blob_url"": ""https://github.com/openssl/openssl/blob/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/bn_asm.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/bn_asm.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/bn/bn_asm.c?ref=a7a44ba55cb4f884c6bc9ceac90072dea38e66d0"", ""patch"": ""@@ -439,129 +439,150 @@ BN_ULONG bn_sub_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b, int n)\n /* sqr_add_c2(a,i,c0,c1,c2) -- c+=2*a[i]*a[j] for three word number c=(c2,c1,c0) */\n \n #ifdef BN_LLONG\n-#define mul_add_c(a,b,c0,c1,c2) \\\n-\tt=(BN_ULLONG)a*b; \\\n-\tt1=(BN_ULONG)Lw(t); \\\n-\tt2=(BN_ULONG)Hw(t); \\\n-\tc0=(c0+t1)&BN_MASK2; if ((c0) < t1) t2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n-\n-#define mul_add_c2(a,b,c0,c1,c2) \\\n-\tt=(BN_ULLONG)a*b; \\\n-\ttt=(t+t)&BN_MASK; \\\n-\tif (tt < t) c2++; \\\n-\tt1=(BN_ULONG)Lw(tt); \\\n-\tt2=(BN_ULONG)Hw(tt); \\\n-\tc0=(c0+t1)&BN_MASK2;  \\\n-\tif ((c0 < t1) && (((++t2)&BN_MASK2) == 0)) c2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n-\n-#define sqr_add_c(a,i,c0,c1,c2) \\\n-\tt=(BN_ULLONG)a[i]*a[i]; \\\n-\tt1=(BN_ULONG)Lw(t); \\\n-\tt2=(BN_ULONG)Hw(t); \\\n-\tc0=(c0+t1)&BN_MASK2; if ((c0) < t1) t2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n+/*\n+ * Keep in mind that additions to multiplication result can not\n+ * overflow, because its high half cannot be all-ones.\n+ */\n+#define mul_add_c(a,b,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG hi;\t\t\t\t\\\n+\tBN_ULLONG t = (BN_ULLONG)(a)*(b);\t\\\n+\tt += c0;\t\t/* no carry */\t\\\n+\tc0 = (BN_ULONG)Lw(t);\t\t\t\\\n+\thi = (BN_ULONG)Hw(t);\t\t\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n+\n+#define mul_add_c2(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG hi;\t\t\t\t\\\n+\tBN_ULLONG t = (BN_ULLONG)(a)*(b);\t\\\n+\tBN_ULLONG tt = t+c0;\t/* no carry */\t\\\n+\tc0 = (BN_ULONG)Lw(tt);\t\t\t\\\n+\thi = (BN_ULONG)Hw(tt);\t\t\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\tt += c0;\t\t/* no carry */\t\\\n+\tc0 = (BN_ULONG)Lw(t);\t\t\t\\\n+\thi = (BN_ULONG)Hw(t);\t\t\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n+\n+#define sqr_add_c(a,i,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG hi;\t\t\t\t\\\n+\tBN_ULLONG t = (BN_ULLONG)a[i]*a[i];\t\\\n+\tt += c0;\t\t/* no carry */\t\\\n+\tc0 = (BN_ULONG)Lw(t);\t\t\t\\\n+\thi = (BN_ULONG)Hw(t);\t\t\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n \n #define sqr_add_c2(a,i,j,c0,c1,c2) \\\n \tmul_add_c2((a)[i],(a)[j],c0,c1,c2)\n \n #elif defined(BN_UMULT_LOHI)\n-\n-#define mul_add_c(a,b,c0,c1,c2)\t{\t\\\n-\tBN_ULONG ta=(a),tb=(b);\t\t\\\n-\tBN_UMULT_LOHI(t1,t2,ta,tb);\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n-\n-#define mul_add_c2(a,b,c0,c1,c2) {\t\\\n-\tBN_ULONG ta=(a),tb=(b),t0;\t\\\n-\tBN_UMULT_LOHI(t0,t1,ta,tb);\t\\\n-\tt2 = t1+t1; c2 += (t2<t1)?1:0;\t\\\n-\tt1 = t0+t0; t2 += (t1<t0)?1:0;\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n-\n-#define sqr_add_c(a,i,c0,c1,c2)\t{\t\\\n-\tBN_ULONG ta=(a)[i];\t\t\\\n-\tBN_UMULT_LOHI(t1,t2,ta,ta);\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n+/*\n+ * Keep in mind that additions to hi can not overflow, because\n+ * the high word of a multiplication result cannot be all-ones.\n+ */\n+#define mul_add_c(a,b,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b);\t\t\\\n+\tBN_ULONG lo, hi;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,tb);\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define mul_add_c2(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b);\t\t\\\n+\tBN_ULONG lo, hi, tt;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,tb);\t\t\\\n+\tc0 += lo; tt = hi+((c0<lo)?1:0);\t\\\n+\tc1 += tt; c2 += (c1<tt)?1:0;\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define sqr_add_c(a,i,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a)[i];\t\t\t\\\n+\tBN_ULONG lo, hi;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,ta);\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n \n #define sqr_add_c2(a,i,j,c0,c1,c2)\t\\\n \tmul_add_c2((a)[i],(a)[j],c0,c1,c2)\n \n #elif defined(BN_UMULT_HIGH)\n-\n-#define mul_add_c(a,b,c0,c1,c2)\t{\t\\\n-\tBN_ULONG ta=(a),tb=(b);\t\t\\\n-\tt1 = ta * tb;\t\t\t\\\n-\tt2 = BN_UMULT_HIGH(ta,tb);\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n-\n-#define mul_add_c2(a,b,c0,c1,c2) {\t\\\n-\tBN_ULONG ta=(a),tb=(b),t0;\t\\\n-\tt1 = BN_UMULT_HIGH(ta,tb);\t\\\n-\tt0 = ta * tb;\t\t\t\\\n-\tt2 = t1+t1; c2 += (t2<t1)?1:0;\t\\\n-\tt1 = t0+t0; t2 += (t1<t0)?1:0;\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n-\n-#define sqr_add_c(a,i,c0,c1,c2)\t{\t\\\n-\tBN_ULONG ta=(a)[i];\t\t\\\n-\tt1 = ta * ta;\t\t\t\\\n-\tt2 = BN_UMULT_HIGH(ta,ta);\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n+/*\n+ * Keep in mind that additions to hi can not overflow, because\n+ * the high word of a multiplication result cannot be all-ones.\n+ */\n+#define mul_add_c(a,b,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b);\t\t\\\n+\tBN_ULONG lo = ta * tb;\t\t\t\\\n+\tBN_ULONG hi = BN_UMULT_HIGH(ta,tb);\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define mul_add_c2(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b), tt;\t\\\n+\tBN_ULONG lo = ta * tb;\t\t\t\\\n+\tBN_ULONG hi = BN_UMULT_HIGH(ta,tb);\t\\\n+\tc0 += lo; tt = hi + ((c0<lo)?1:0);\t\\\n+\tc1 += tt; c2 += (c1<tt)?1:0;\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define sqr_add_c(a,i,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a)[i];\t\t\t\\\n+\tBN_ULONG lo = ta * ta;\t\t\t\\\n+\tBN_ULONG hi = BN_UMULT_HIGH(ta,ta);\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n \n #define sqr_add_c2(a,i,j,c0,c1,c2)\t\\\n \tmul_add_c2((a)[i],(a)[j],c0,c1,c2)\n \n #else /* !BN_LLONG */\n-#define mul_add_c(a,b,c0,c1,c2) \\\n-\tt1=LBITS(a); t2=HBITS(a); \\\n-\tbl=LBITS(b); bh=HBITS(b); \\\n-\tmul64(t1,t2,bl,bh); \\\n-\tc0=(c0+t1)&BN_MASK2; if ((c0) < t1) t2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n-\n-#define mul_add_c2(a,b,c0,c1,c2) \\\n-\tt1=LBITS(a); t2=HBITS(a); \\\n-\tbl=LBITS(b); bh=HBITS(b); \\\n-\tmul64(t1,t2,bl,bh); \\\n-\tif (t2 & BN_TBIT) c2++; \\\n-\tt2=(t2+t2)&BN_MASK2; \\\n-\tif (t1 & BN_TBIT) t2++; \\\n-\tt1=(t1+t1)&BN_MASK2; \\\n-\tc0=(c0+t1)&BN_MASK2;  \\\n-\tif ((c0 < t1) && (((++t2)&BN_MASK2) == 0)) c2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n-\n-#define sqr_add_c(a,i,c0,c1,c2) \\\n-\tsqr64(t1,t2,(a)[i]); \\\n-\tc0=(c0+t1)&BN_MASK2; if ((c0) < t1) t2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n+/*\n+ * Keep in mind that additions to hi can not overflow, because\n+ * the high word of a multiplication result cannot be all-ones.\n+ */\n+#define mul_add_c(a,b,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG lo = LBITS(a), hi = HBITS(a);\t\\\n+\tBN_ULONG bl = LBITS(b), bh = HBITS(b);\t\\\n+\tmul64(lo,hi,bl,bh);\t\t\t\\\n+\tc0 = (c0+lo)&BN_MASK2; if (c0<lo) hi++;\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n+\n+#define mul_add_c2(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG tt;\t\t\t\t\\\n+\tBN_ULONG lo = LBITS(a), hi = HBITS(a);\t\\\n+\tBN_ULONG bl = LBITS(b), bh = HBITS(b);\t\\\n+\tmul64(lo,hi,bl,bh);\t\t\t\\\n+\ttt = hi;\t\t\t\t\\\n+\tc0 = (c0+lo)&BN_MASK2; if (c0<lo) tt++;\t\\\n+\tc1 = (c1+tt)&BN_MASK2; if (c1<tt) c2++;\t\\\n+\tc0 = (c0+lo)&BN_MASK2; if (c0<lo) hi++;\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n+\n+#define sqr_add_c(a,i,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG lo, hi;\t\t\t\\\n+\tsqr64(lo,hi,(a)[i]);\t\t\t\\\n+\tc0 = (c0+lo)&BN_MASK2; if (c0<lo) hi++;\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n \n #define sqr_add_c2(a,i,j,c0,c1,c2) \\\n \tmul_add_c2((a)[i],(a)[j],c0,c1,c2)\n #endif /* !BN_LLONG */\n \n void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \t{\n-#ifdef BN_LLONG\n-\tBN_ULLONG t;\n-#else\n-\tBN_ULONG bl,bh;\n-#endif\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -665,12 +686,6 @@ void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \n void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \t{\n-#ifdef BN_LLONG\n-\tBN_ULLONG t;\n-#else\n-\tBN_ULONG bl,bh;\n-#endif\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -710,12 +725,6 @@ void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \n void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\n \t{\n-#ifdef BN_LLONG\n-\tBN_ULLONG t,tt;\n-#else\n-\tBN_ULONG bl,bh;\n-#endif\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -791,12 +800,6 @@ void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\n \n void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n \t{\n-#ifdef BN_LLONG\n-\tBN_ULLONG t,tt;\n-#else\n-\tBN_ULONG bl,bh;\n-#endif\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;""}<_**next**_>{""sha"": ""869ae05a901d51ee69ad4d181337ba1d8c34e7a4"", ""filename"": ""crypto/bn/bntest.c"", ""status"": ""modified"", ""additions"": 78, ""deletions"": 24, ""changes"": 102, ""blob_url"": ""https://github.com/openssl/openssl/blob/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/bntest.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/bntest.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/bn/bntest.c?ref=a7a44ba55cb4f884c6bc9ceac90072dea38e66d0"", ""patch"": ""@@ -689,44 +689,98 @@ int test_mul(BIO *bp)\n \n int test_sqr(BIO *bp, BN_CTX *ctx)\n \t{\n-\tBIGNUM a,c,d,e;\n-\tint i;\n+\tBIGNUM *a,*c,*d,*e;\n+\tint i, ret = 0;\n \n-\tBN_init(&a);\n-\tBN_init(&c);\n-\tBN_init(&d);\n-\tBN_init(&e);\n+\ta = BN_new();\n+\tc = BN_new();\n+\td = BN_new();\n+\te = BN_new();\n+\tif (a == NULL || c == NULL || d == NULL || e == NULL)\n+\t\t{\n+\t\tgoto err;\n+\t\t}\n \n \tfor (i=0; i<num0; i++)\n \t\t{\n-\t\tBN_bntest_rand(&a,40+i*10,0,0);\n-\t\ta.neg=rand_neg();\n-\t\tBN_sqr(&c,&a,ctx);\n+\t\tBN_bntest_rand(a,40+i*10,0,0);\n+\t\ta->neg=rand_neg();\n+\t\tBN_sqr(c,a,ctx);\n \t\tif (bp != NULL)\n \t\t\t{\n \t\t\tif (!results)\n \t\t\t\t{\n-\t\t\t\tBN_print(bp,&a);\n+\t\t\t\tBN_print(bp,a);\n \t\t\t\tBIO_puts(bp,\"" * \"");\n-\t\t\t\tBN_print(bp,&a);\n+\t\t\t\tBN_print(bp,a);\n \t\t\t\tBIO_puts(bp,\"" - \"");\n \t\t\t\t}\n-\t\t\tBN_print(bp,&c);\n+\t\t\tBN_print(bp,c);\n \t\t\tBIO_puts(bp,\""\\n\"");\n \t\t\t}\n-\t\tBN_div(&d,&e,&c,&a,ctx);\n-\t\tBN_sub(&d,&d,&a);\n-\t\tif(!BN_is_zero(&d) || !BN_is_zero(&e))\n-\t\t    {\n-\t\t    fprintf(stderr,\""Square test failed!\\n\"");\n-\t\t    return 0;\n-\t\t    }\n+\t\tBN_div(d,e,c,a,ctx);\n+\t\tBN_sub(d,d,a);\n+\t\tif(!BN_is_zero(d) || !BN_is_zero(e))\n+\t\t\t{\n+\t\t\tfprintf(stderr,\""Square test failed!\\n\"");\n+\t\t\tgoto err;\n+\t\t\t}\n \t\t}\n-\tBN_free(&a);\n-\tBN_free(&c);\n-\tBN_free(&d);\n-\tBN_free(&e);\n-\treturn(1);\n+\n+\t/* Regression test for a BN_sqr overflow bug. */\n+\tBN_hex2bn(&a,\n+\t\t\""80000000000000008000000000000001FFFFFFFFFFFFFFFE0000000000000000\"");\n+\tBN_sqr(c, a, ctx);\n+\tif (bp != NULL)\n+\t\t{\n+\t\tif (!results)\n+\t\t\t{\n+\t\t\tBN_print(bp,a);\n+\t\t\tBIO_puts(bp,\"" * \"");\n+\t\t\tBN_print(bp,a);\n+\t\t\tBIO_puts(bp,\"" - \"");\n+\t\t\t}\n+\t\tBN_print(bp,c);\n+\t\tBIO_puts(bp,\""\\n\"");\n+\t\t}\n+\tBN_mul(d, a, a, ctx);\n+\tif (BN_cmp(c, d))\n+\t\t{\n+\t\tfprintf(stderr, \""Square test failed: BN_sqr and BN_mul produce \""\n+\t\t\t\""different results!\\n\"");\n+\t\tgoto err;\n+\t\t}\n+\n+\t/* Regression test for a BN_sqr overflow bug. */\n+\tBN_hex2bn(&a,\n+\t\t\""80000000000000000000000080000001FFFFFFFE000000000000000000000000\"");\n+\tBN_sqr(c, a, ctx);\n+\tif (bp != NULL)\n+\t\t{\n+\t\tif (!results)\n+\t\t\t{\n+\t\t\tBN_print(bp,a);\n+\t\t\tBIO_puts(bp,\"" * \"");\n+\t\t\tBN_print(bp,a);\n+\t\t\tBIO_puts(bp,\"" - \"");\n+\t\t\t}\n+\t\tBN_print(bp,c);\n+\t\tBIO_puts(bp,\""\\n\"");\n+\t\t}\n+\tBN_mul(d, a, a, ctx);\n+\tif (BN_cmp(c, d))\n+\t\t{\n+\t\tfprintf(stderr, \""Square test failed: BN_sqr and BN_mul produce \""\n+\t\t\t\""different results!\\n\"");\n+\t\tgoto err;\n+\t\t}\n+\tret = 1;\n+err:\n+\tif (a != NULL) BN_free(a);\n+\tif (c != NULL) BN_free(c);\n+\tif (d != NULL) BN_free(d);\n+\tif (e != NULL) BN_free(e);\n+\treturn ret;\n \t}\n \n int test_mont(BIO *bp, BN_CTX *ctx)""}"," void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
 	{
 	BN_ULONG c1,c2,c3;
 
 	c1=0;
	c2=0;
	c3=0;
	mul_add_c(a[0],b[0],c1,c2,c3);
	r[0]=c1;
	c1=0;
	mul_add_c(a[0],b[1],c2,c3,c1);
	mul_add_c(a[1],b[0],c2,c3,c1);
	r[1]=c2;
	c2=0;
	mul_add_c(a[2],b[0],c3,c1,c2);
	mul_add_c(a[1],b[1],c3,c1,c2);
	mul_add_c(a[0],b[2],c3,c1,c2);
	r[2]=c3;
	c3=0;
	mul_add_c(a[0],b[3],c1,c2,c3);
	mul_add_c(a[1],b[2],c1,c2,c3);
	mul_add_c(a[2],b[1],c1,c2,c3);
	mul_add_c(a[3],b[0],c1,c2,c3);
	r[3]=c1;
	c1=0;
	mul_add_c(a[4],b[0],c2,c3,c1);
	mul_add_c(a[3],b[1],c2,c3,c1);
	mul_add_c(a[2],b[2],c2,c3,c1);
	mul_add_c(a[1],b[3],c2,c3,c1);
	mul_add_c(a[0],b[4],c2,c3,c1);
	r[4]=c2;
	c2=0;
	mul_add_c(a[0],b[5],c3,c1,c2);
	mul_add_c(a[1],b[4],c3,c1,c2);
	mul_add_c(a[2],b[3],c3,c1,c2);
	mul_add_c(a[3],b[2],c3,c1,c2);
	mul_add_c(a[4],b[1],c3,c1,c2);
	mul_add_c(a[5],b[0],c3,c1,c2);
	r[5]=c3;
	c3=0;
	mul_add_c(a[6],b[0],c1,c2,c3);
	mul_add_c(a[5],b[1],c1,c2,c3);
	mul_add_c(a[4],b[2],c1,c2,c3);
	mul_add_c(a[3],b[3],c1,c2,c3);
	mul_add_c(a[2],b[4],c1,c2,c3);
	mul_add_c(a[1],b[5],c1,c2,c3);
	mul_add_c(a[0],b[6],c1,c2,c3);
	r[6]=c1;
	c1=0;
	mul_add_c(a[0],b[7],c2,c3,c1);
	mul_add_c(a[1],b[6],c2,c3,c1);
	mul_add_c(a[2],b[5],c2,c3,c1);
	mul_add_c(a[3],b[4],c2,c3,c1);
	mul_add_c(a[4],b[3],c2,c3,c1);
	mul_add_c(a[5],b[2],c2,c3,c1);
	mul_add_c(a[6],b[1],c2,c3,c1);
	mul_add_c(a[7],b[0],c2,c3,c1);
	r[7]=c2;
	c2=0;
	mul_add_c(a[7],b[1],c3,c1,c2);
	mul_add_c(a[6],b[2],c3,c1,c2);
	mul_add_c(a[5],b[3],c3,c1,c2);
	mul_add_c(a[4],b[4],c3,c1,c2);
	mul_add_c(a[3],b[5],c3,c1,c2);
	mul_add_c(a[2],b[6],c3,c1,c2);
	mul_add_c(a[1],b[7],c3,c1,c2);
	r[8]=c3;
	c3=0;
	mul_add_c(a[2],b[7],c1,c2,c3);
	mul_add_c(a[3],b[6],c1,c2,c3);
	mul_add_c(a[4],b[5],c1,c2,c3);
	mul_add_c(a[5],b[4],c1,c2,c3);
	mul_add_c(a[6],b[3],c1,c2,c3);
	mul_add_c(a[7],b[2],c1,c2,c3);
	r[9]=c1;
	c1=0;
	mul_add_c(a[7],b[3],c2,c3,c1);
	mul_add_c(a[6],b[4],c2,c3,c1);
	mul_add_c(a[5],b[5],c2,c3,c1);
	mul_add_c(a[4],b[6],c2,c3,c1);
	mul_add_c(a[3],b[7],c2,c3,c1);
	r[10]=c2;
	c2=0;
	mul_add_c(a[4],b[7],c3,c1,c2);
	mul_add_c(a[5],b[6],c3,c1,c2);
	mul_add_c(a[6],b[5],c3,c1,c2);
	mul_add_c(a[7],b[4],c3,c1,c2);
	r[11]=c3;
	c3=0;
	mul_add_c(a[7],b[5],c1,c2,c3);
	mul_add_c(a[6],b[6],c1,c2,c3);
	mul_add_c(a[5],b[7],c1,c2,c3);
	r[12]=c1;
	c1=0;
	mul_add_c(a[6],b[7],c2,c3,c1);
	mul_add_c(a[7],b[6],c2,c3,c1);
	r[13]=c2;
	c2=0;
	mul_add_c(a[7],b[7],c3,c1,c2);
	r[14]=c3;
	r[15]=c1;
	}
"," void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
 	{
	BN_ULONG t1,t2;
 	BN_ULONG c1,c2,c3;
 
 	c1=0;
	c2=0;
	c3=0;
	mul_add_c(a[0],b[0],c1,c2,c3);
	r[0]=c1;
	c1=0;
	mul_add_c(a[0],b[1],c2,c3,c1);
	mul_add_c(a[1],b[0],c2,c3,c1);
	r[1]=c2;
	c2=0;
	mul_add_c(a[2],b[0],c3,c1,c2);
	mul_add_c(a[1],b[1],c3,c1,c2);
	mul_add_c(a[0],b[2],c3,c1,c2);
	r[2]=c3;
	c3=0;
	mul_add_c(a[0],b[3],c1,c2,c3);
	mul_add_c(a[1],b[2],c1,c2,c3);
	mul_add_c(a[2],b[1],c1,c2,c3);
	mul_add_c(a[3],b[0],c1,c2,c3);
	r[3]=c1;
	c1=0;
	mul_add_c(a[4],b[0],c2,c3,c1);
	mul_add_c(a[3],b[1],c2,c3,c1);
	mul_add_c(a[2],b[2],c2,c3,c1);
	mul_add_c(a[1],b[3],c2,c3,c1);
	mul_add_c(a[0],b[4],c2,c3,c1);
	r[4]=c2;
	c2=0;
	mul_add_c(a[0],b[5],c3,c1,c2);
	mul_add_c(a[1],b[4],c3,c1,c2);
	mul_add_c(a[2],b[3],c3,c1,c2);
	mul_add_c(a[3],b[2],c3,c1,c2);
	mul_add_c(a[4],b[1],c3,c1,c2);
	mul_add_c(a[5],b[0],c3,c1,c2);
	r[5]=c3;
	c3=0;
	mul_add_c(a[6],b[0],c1,c2,c3);
	mul_add_c(a[5],b[1],c1,c2,c3);
	mul_add_c(a[4],b[2],c1,c2,c3);
	mul_add_c(a[3],b[3],c1,c2,c3);
	mul_add_c(a[2],b[4],c1,c2,c3);
	mul_add_c(a[1],b[5],c1,c2,c3);
	mul_add_c(a[0],b[6],c1,c2,c3);
	r[6]=c1;
	c1=0;
	mul_add_c(a[0],b[7],c2,c3,c1);
	mul_add_c(a[1],b[6],c2,c3,c1);
	mul_add_c(a[2],b[5],c2,c3,c1);
	mul_add_c(a[3],b[4],c2,c3,c1);
	mul_add_c(a[4],b[3],c2,c3,c1);
	mul_add_c(a[5],b[2],c2,c3,c1);
	mul_add_c(a[6],b[1],c2,c3,c1);
	mul_add_c(a[7],b[0],c2,c3,c1);
	r[7]=c2;
	c2=0;
	mul_add_c(a[7],b[1],c3,c1,c2);
	mul_add_c(a[6],b[2],c3,c1,c2);
	mul_add_c(a[5],b[3],c3,c1,c2);
	mul_add_c(a[4],b[4],c3,c1,c2);
	mul_add_c(a[3],b[5],c3,c1,c2);
	mul_add_c(a[2],b[6],c3,c1,c2);
	mul_add_c(a[1],b[7],c3,c1,c2);
	r[8]=c3;
	c3=0;
	mul_add_c(a[2],b[7],c1,c2,c3);
	mul_add_c(a[3],b[6],c1,c2,c3);
	mul_add_c(a[4],b[5],c1,c2,c3);
	mul_add_c(a[5],b[4],c1,c2,c3);
	mul_add_c(a[6],b[3],c1,c2,c3);
	mul_add_c(a[7],b[2],c1,c2,c3);
	r[9]=c1;
	c1=0;
	mul_add_c(a[7],b[3],c2,c3,c1);
	mul_add_c(a[6],b[4],c2,c3,c1);
	mul_add_c(a[5],b[5],c2,c3,c1);
	mul_add_c(a[4],b[6],c2,c3,c1);
	mul_add_c(a[3],b[7],c2,c3,c1);
	r[10]=c2;
	c2=0;
	mul_add_c(a[4],b[7],c3,c1,c2);
	mul_add_c(a[5],b[6],c3,c1,c2);
	mul_add_c(a[6],b[5],c3,c1,c2);
	mul_add_c(a[7],b[4],c3,c1,c2);
	r[11]=c3;
	c3=0;
	mul_add_c(a[7],b[5],c1,c2,c3);
	mul_add_c(a[6],b[6],c1,c2,c3);
	mul_add_c(a[5],b[7],c1,c2,c3);
	r[12]=c1;
	c1=0;
	mul_add_c(a[6],b[7],c2,c3,c1);
	mul_add_c(a[7],b[6],c2,c3,c1);
	r[13]=c2;
	c2=0;
	mul_add_c(a[7],b[7],c3,c1,c2);
	r[14]=c3;
	r[15]=c1;
	}
",C,,"	BN_ULONG t1,t2;
",,"@@ -276,77 +276,76 @@ BN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)
 /* sqr_add_c(a,i,c0,c1,c2)  -- c+=a[i]^2 for three word number c=(c2,c1,c0) */
 /* sqr_add_c2(a,i,c0,c1,c2) -- c+=2*a[i]*a[j] for three word number c=(c2,c1,c0) */
 
+/*
+ * Keep in mind that carrying into high part of multiplication result
+ * can not overflow, because it cannot be all-ones.
+ */
 #if 0
 /* original macros are kept for reference purposes */
-#define mul_add_c(a,b,c0,c1,c2) {	\
-	BN_ULONG ta=(a),tb=(b);		\
-	t1 = ta * tb;			\
-	t2 = BN_UMULT_HIGH(ta,tb);	\
-	c0 += t1; t2 += (c0<t1)?1:0;	\
-	c1 += t2; c2 += (c1<t2)?1:0;	\
-	}
-
-#define mul_add_c2(a,b,c0,c1,c2) {	\
-	BN_ULONG ta=(a),tb=(b),t0;	\
-	t1 = BN_UMULT_HIGH(ta,tb);	\
-	t0 = ta * tb;			\
-	t2 = t1+t1; c2 += (t2<t1)?1:0;	\
-	t1 = t0+t0; t2 += (t1<t0)?1:0;	\
-	c0 += t1; t2 += (c0<t1)?1:0;	\
-	c1 += t2; c2 += (c1<t2)?1:0;	\
-	}
+#define mul_add_c(a,b,c0,c1,c2)		do {	\
+	BN_ULONG ta = (a), tb = (b);		\
+	BN_ULONG lo, hi;			\
+	BN_UMULT_LOHI(lo,hi,ta,tb);		\
+	c0 += lo; hi += (c0<lo)?1:0;		\
+	c1 += hi; c2 += (c1<hi)?1:0;		\
+	} while(0)
+
+#define mul_add_c2(a,b,c0,c1,c2)	do {	\
+	BN_ULONG ta = (a), tb = (b);		\
+	BN_ULONG lo, hi, tt;			\
+	BN_UMULT_LOHI(lo,hi,ta,tb);		\
+	c0 += lo; tt = hi+((c0<lo)?1:0);	\
+	c1 += tt; c2 += (c1<tt)?1:0;		\
+	c0 += lo; hi += (c0<lo)?1:0;		\
+	c1 += hi; c2 += (c1<hi)?1:0;		\
+	} while(0)
+
+#define sqr_add_c(a,i,c0,c1,c2)		do {	\
+	BN_ULONG ta = (a)[i];			\
+	BN_ULONG lo, hi;			\
+	BN_UMULT_LOHI(lo,hi,ta,ta);		\
+	c0 += lo; hi += (c0<lo)?1:0;		\
+	c1 += hi; c2 += (c1<hi)?1:0;		\
+	} while(0)
 #else
 #define mul_add_c(a,b,c0,c1,c2)	do {	\
+	BN_ULONG t1,t2;			\
 	asm (""mulq %3""			\
 		: ""=a""(t1),""=d""(t2)	\
 		: ""a""(a),""m""(b)		\
 		: ""cc"");		\
-	asm (""addq %2,%0; adcq %3,%1""	\
-		: ""+r""(c0),""+d""(t2)	\
-		: ""a""(t1),""g""(0)	\
-		: ""cc"");		\
-	asm (""addq %2,%0; adcq %3,%1""	\
-		: ""+r""(c1),""+r""(c2)	\
-		: ""d""(t2),""g""(0)	\
-		: ""cc"");		\
+	asm (""addq %3,%0; adcq %4,%1; adcq %5,%2""	\
+		: ""+r""(c0),""+r""(c1),""+r""(c2)		\
+		: ""r""(t1),""r""(t2),""g""(0)		\
+		: ""cc"");				\
 	} while (0)
 
 #define sqr_add_c(a,i,c0,c1,c2)	do {	\
+	BN_ULONG t1,t2;			\
 	asm (""mulq %2""			\
 		: ""=a""(t1),""=d""(t2)	\
 		: ""a""(a[i])		\
 		: ""cc"");		\
-	asm (""addq %2,%0; adcq %3,%1""	\
-		: ""+r""(c0),""+d""(t2)	\
-		: ""a""(t1),""g""(0)	\
-		: ""cc"");		\
-	asm (""addq %2,%0; adcq %3,%1""	\
-		: ""+r""(c1),""+r""(c2)	\
-		: ""d""(t2),""g""(0)	\
-		: ""cc"");		\
+	asm (""addq %3,%0; adcq %4,%1; adcq %5,%2""	\
+		: ""+r""(c0),""+r""(c1),""+r""(c2)		\
+		: ""r""(t1),""r""(t2),""g""(0)		\
+		: ""cc"");				\
 	} while (0)
 
 #define mul_add_c2(a,b,c0,c1,c2) do {	\
+	BN_ULONG t1,t2;			\
 	asm (""mulq %3""			\
 		: ""=a""(t1),""=d""(t2)	\
 		: ""a""(a),""m""(b)		\
 		: ""cc"");		\
-	asm (""addq %0,%0; adcq %2,%1""	\
-		: ""+d""(t2),""+r""(c2)	\
-		: ""g""(0)		\
-		: ""cc"");		\
-	asm (""addq %0,%0; adcq %2,%1""	\
-		: ""+a""(t1),""+d""(t2)	\
-		: ""g""(0)		\
-		: ""cc"");		\
-	asm (""addq %2,%0; adcq %3,%1""	\
-		: ""+r""(c0),""+d""(t2)	\
-		: ""a""(t1),""g""(0)	\
-		: ""cc"");		\
-	asm (""addq %2,%0; adcq %3,%1""	\
-		: ""+r""(c1),""+r""(c2)	\
-		: ""d""(t2),""g""(0)	\
-		: ""cc"");		\
+	asm (""addq %3,%0; adcq %4,%1; adcq %5,%2""	\
+		: ""+r""(c0),""+r""(c1),""+r""(c2)		\
+		: ""r""(t1),""r""(t2),""g""(0)		\
+		: ""cc"");				\
+	asm (""addq %3,%0; adcq %4,%1; adcq %5,%2""	\
+		: ""+r""(c0),""+r""(c1),""+r""(c2)		\
+		: ""r""(t1),""r""(t2),""g""(0)		\
+		: ""cc"");				\
 	} while (0)
 #endif
 
@@ -355,7 +354,6 @@ BN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)
 
 void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
 	{
-	BN_ULONG t1,t2;
 	BN_ULONG c1,c2,c3;
 
 	c1=0;
@@ -459,7 +457,6 @@ void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
 
 void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
 	{
-	BN_ULONG t1,t2;
 	BN_ULONG c1,c2,c3;
 
 	c1=0;
@@ -499,7 +496,6 @@ void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
 
 void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)
 	{
-	BN_ULONG t1,t2;
 	BN_ULONG c1,c2,c3;
 
 	c1=0;
@@ -575,7 +571,6 @@ void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)
 
 void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)
 	{
-	BN_ULONG t1,t2;
 	BN_ULONG c1,c2,c3;
 
 	c1=0;",openssl,a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,248385c606620b29ecc96ca9d3603463f879652b,1," void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
 	{
//flaw_line_below:
	BN_ULONG t1,t2;
 	BN_ULONG c1,c2,c3;
 
 	c1=0;
	c2=0;
	c3=0;
	mul_add_c(a[0],b[0],c1,c2,c3);
	r[0]=c1;
	c1=0;
	mul_add_c(a[0],b[1],c2,c3,c1);
	mul_add_c(a[1],b[0],c2,c3,c1);
	r[1]=c2;
	c2=0;
	mul_add_c(a[2],b[0],c3,c1,c2);
	mul_add_c(a[1],b[1],c3,c1,c2);
	mul_add_c(a[0],b[2],c3,c1,c2);
	r[2]=c3;
	c3=0;
	mul_add_c(a[0],b[3],c1,c2,c3);
	mul_add_c(a[1],b[2],c1,c2,c3);
	mul_add_c(a[2],b[1],c1,c2,c3);
	mul_add_c(a[3],b[0],c1,c2,c3);
	r[3]=c1;
	c1=0;
	mul_add_c(a[4],b[0],c2,c3,c1);
	mul_add_c(a[3],b[1],c2,c3,c1);
	mul_add_c(a[2],b[2],c2,c3,c1);
	mul_add_c(a[1],b[3],c2,c3,c1);
	mul_add_c(a[0],b[4],c2,c3,c1);
	r[4]=c2;
	c2=0;
	mul_add_c(a[0],b[5],c3,c1,c2);
	mul_add_c(a[1],b[4],c3,c1,c2);
	mul_add_c(a[2],b[3],c3,c1,c2);
	mul_add_c(a[3],b[2],c3,c1,c2);
	mul_add_c(a[4],b[1],c3,c1,c2);
	mul_add_c(a[5],b[0],c3,c1,c2);
	r[5]=c3;
	c3=0;
	mul_add_c(a[6],b[0],c1,c2,c3);
	mul_add_c(a[5],b[1],c1,c2,c3);
	mul_add_c(a[4],b[2],c1,c2,c3);
	mul_add_c(a[3],b[3],c1,c2,c3);
	mul_add_c(a[2],b[4],c1,c2,c3);
	mul_add_c(a[1],b[5],c1,c2,c3);
	mul_add_c(a[0],b[6],c1,c2,c3);
	r[6]=c1;
	c1=0;
	mul_add_c(a[0],b[7],c2,c3,c1);
	mul_add_c(a[1],b[6],c2,c3,c1);
	mul_add_c(a[2],b[5],c2,c3,c1);
	mul_add_c(a[3],b[4],c2,c3,c1);
	mul_add_c(a[4],b[3],c2,c3,c1);
	mul_add_c(a[5],b[2],c2,c3,c1);
	mul_add_c(a[6],b[1],c2,c3,c1);
	mul_add_c(a[7],b[0],c2,c3,c1);
	r[7]=c2;
	c2=0;
	mul_add_c(a[7],b[1],c3,c1,c2);
	mul_add_c(a[6],b[2],c3,c1,c2);
	mul_add_c(a[5],b[3],c3,c1,c2);
	mul_add_c(a[4],b[4],c3,c1,c2);
	mul_add_c(a[3],b[5],c3,c1,c2);
	mul_add_c(a[2],b[6],c3,c1,c2);
	mul_add_c(a[1],b[7],c3,c1,c2);
	r[8]=c3;
	c3=0;
	mul_add_c(a[2],b[7],c1,c2,c3);
	mul_add_c(a[3],b[6],c1,c2,c3);
	mul_add_c(a[4],b[5],c1,c2,c3);
	mul_add_c(a[5],b[4],c1,c2,c3);
	mul_add_c(a[6],b[3],c1,c2,c3);
	mul_add_c(a[7],b[2],c1,c2,c3);
	r[9]=c1;
	c1=0;
	mul_add_c(a[7],b[3],c2,c3,c1);
	mul_add_c(a[6],b[4],c2,c3,c1);
	mul_add_c(a[5],b[5],c2,c3,c1);
	mul_add_c(a[4],b[6],c2,c3,c1);
	mul_add_c(a[3],b[7],c2,c3,c1);
	r[10]=c2;
	c2=0;
	mul_add_c(a[4],b[7],c3,c1,c2);
	mul_add_c(a[5],b[6],c3,c1,c2);
	mul_add_c(a[6],b[5],c3,c1,c2);
	mul_add_c(a[7],b[4],c3,c1,c2);
	r[11]=c3;
	c3=0;
	mul_add_c(a[7],b[5],c1,c2,c3);
	mul_add_c(a[6],b[6],c1,c2,c3);
	mul_add_c(a[5],b[7],c1,c2,c3);
	r[12]=c1;
	c1=0;
	mul_add_c(a[6],b[7],c2,c3,c1);
	mul_add_c(a[7],b[6],c2,c3,c1);
	r[13]=c2;
	c2=0;
	mul_add_c(a[7],b[7],c3,c1,c2);
	r[14]=c3;
	r[15]=c1;
	}
"
2266,180002,,Remote,Not required,,CVE-2014-3570,https://www.cvedetails.com/cve/CVE-2014-3570/,CWE-310,Low,Partial,,,2015-01-08,5.0,"The BN_sqr implementation in OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not properly calculate the square of a BIGNUM value, which might make it easier for remote attackers to defeat cryptographic protection mechanisms via unspecified vectors, related to crypto/bn/asm/mips.pl, crypto/bn/asm/x86_64-gcc.c, and crypto/bn/bn_asm.c.",2017-11-14,,0,https://github.com/openssl/openssl/commit/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,"Fix for CVE-2014-3570 (with minor bn_asm.c revamp).

Reviewed-by: Emilia Kasper <emilia@openssl.org>",1,crypto/bn/asm/x86_64-gcc.c,"{""sha"": ""acafde5e5685ccb7e2d59b218d45d1bda0572fbd"", ""filename"": ""crypto/bn/asm/mips.pl"", ""status"": ""modified"", ""additions"": 131, ""deletions"": 480, ""changes"": 611, ""blob_url"": ""https://github.com/openssl/openssl/blob/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/asm/mips.pl"", ""raw_url"": ""https://github.com/openssl/openssl/raw/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/asm/mips.pl"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/bn/asm/mips.pl?ref=a7a44ba55cb4f884c6bc9ceac90072dea38e66d0"", ""patch"": ""@@ -1872,6 +1872,41 @@\n \n ($a_4,$a_5,$a_6,$a_7)=($b_0,$b_1,$b_2,$b_3);\n \n+sub add_c2 () {\n+my ($hi,$lo,$c0,$c1,$c2,\n+    $warm,      # !$warm denotes first call with specific sequence of\n+                # $c_[XYZ] when there is no Z-carry to accumulate yet;\n+    $an,$bn     # these two are arguments for multiplication which\n+                # result is used in *next* step [which is why it's\n+                # commented as \""forward multiplication\"" below];\n+    )=@_;\n+$code.=<<___;\n+\tmflo\t$lo\n+\tmfhi\t$hi\n+\t$ADDU\t$c0,$lo\n+\tsltu\t$at,$c0,$lo\n+\t $MULTU\t$an,$bn\t\t\t# forward multiplication\n+\t$ADDU\t$c0,$lo\n+\t$ADDU\t$at,$hi\n+\tsltu\t$lo,$c0,$lo\n+\t$ADDU\t$c1,$at\n+\t$ADDU\t$hi,$lo\n+___\n+$code.=<<___\tif (!$warm);\n+\tsltu\t$c2,$c1,$at\n+\t$ADDU\t$c1,$hi\n+\tsltu\t$hi,$c1,$hi\n+\t$ADDU\t$c2,$hi\n+___\n+$code.=<<___\tif ($warm);\n+\tsltu\t$at,$c1,$at\n+\t$ADDU\t$c1,$hi\n+\t$ADDU\t$c2,$at\n+\tsltu\t$hi,$c1,$hi\n+\t$ADDU\t$c2,$hi\n+___\n+}\n+\n $code.=<<___;\n \n .align\t5\n@@ -1920,21 +1955,10 @@\n \tsltu\t$at,$c_2,$t_1\n \t$ADDU\t$c_3,$t_2,$at\n \t$ST\t$c_2,$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_1\t\t# mul_add_c(a[1],b[1],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_1,$a_1);\t\t# mul_add_c(a[1],b[1],c3,c1,c2);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_3,$t_1\n@@ -1945,67 +1969,19 @@\n \tsltu\t$at,$c_1,$t_2\n \t$ADDU\t$c_2,$at\n \t$ST\t$c_3,2*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_3,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_2\t\t# mul_add_c2(a[1],b[2],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t $MULTU\t$a_4,$a_0\t\t# mul_add_c2(a[4],b[0],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,0,\n+\t\t$a_1,$a_2);\t\t# mul_add_c2(a[1],b[2],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_4,$a_0);\t\t# mul_add_c2(a[4],b[0],c2,c3,c1);\n+$code.=<<___;\n \t$ST\t$c_1,3*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_1,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_3,$a_1\t\t# mul_add_c2(a[3],b[1],c2,c3,c1);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_1,$at\n-\t$MULTU\t$a_2,$a_2\t\t# mul_add_c(a[2],b[2],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,0,\n+\t\t$a_3,$a_1);\t\t# mul_add_c2(a[3],b[1],c2,c3,c1);\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,1,\n+\t\t$a_2,$a_2);\t\t# mul_add_c(a[2],b[2],c2,c3,c1);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_2,$t_1\n@@ -2016,97 +1992,23 @@\n \tsltu\t$at,$c_3,$t_2\n \t$ADDU\t$c_1,$at\n \t$ST\t$c_2,4*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_4\t\t# mul_add_c2(a[1],b[4],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_2,$at\n-\t$MULTU\t$a_2,$a_3\t\t# mul_add_c2(a[2],b[3],c3,c1,c2);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t $MULTU\t$a_6,$a_0\t\t# mul_add_c2(a[6],b[0],c1,c2,c3);\n-\t$ADDU\t$c_2,$at\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_1,$a_4);\t\t# mul_add_c2(a[1],b[4],c3,c1,c2);\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,1,\n+\t\t$a_2,$a_3);\t\t# mul_add_c2(a[2],b[3],c3,c1,c2);\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,1,\n+\t\t$a_6,$a_0);\t\t# mul_add_c2(a[6],b[0],c1,c2,c3);\n+$code.=<<___;\n \t$ST\t$c_3,5*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_3,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_5,$a_1\t\t# mul_add_c2(a[5],b[1],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t$MULTU\t$a_4,$a_2\t\t# mul_add_c2(a[4],b[2],c1,c2,c3);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t$MULTU\t$a_3,$a_3\t\t# mul_add_c(a[3],b[3],c1,c2,c3);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,0,\n+\t\t$a_5,$a_1);\t\t# mul_add_c2(a[5],b[1],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_4,$a_2);\t\t# mul_add_c2(a[4],b[2],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_3,$a_3);\t\t# mul_add_c(a[3],b[3],c1,c2,c3);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_1,$t_1\n@@ -2117,112 +2019,25 @@\n \tsltu\t$at,$c_2,$t_2\n \t$ADDU\t$c_3,$at\n \t$ST\t$c_1,6*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_1,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_6\t\t# mul_add_c2(a[1],b[6],c2,c3,c1);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_1,$at\n-\t$MULTU\t$a_2,$a_5\t\t# mul_add_c2(a[2],b[5],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_1,$at\n-\t$MULTU\t$a_3,$a_4\t\t# mul_add_c2(a[3],b[4],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_1,$at\n-\t $MULTU\t$a_7,$a_1\t\t# mul_add_c2(a[7],b[1],c3,c1,c2);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,0,\n+\t\t$a_1,$a_6);\t\t# mul_add_c2(a[1],b[6],c2,c3,c1);\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,1,\n+\t\t$a_2,$a_5);\t\t# mul_add_c2(a[2],b[5],c2,c3,c1);\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,1,\n+\t\t$a_3,$a_4);\t\t# mul_add_c2(a[3],b[4],c2,c3,c1);\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,1,\n+\t\t$a_7,$a_1);\t\t# mul_add_c2(a[7],b[1],c3,c1,c2);\n+$code.=<<___;\n \t$ST\t$c_2,7*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_6,$a_2\t\t# mul_add_c2(a[6],b[2],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_2,$at\n-\t$MULTU\t$a_5,$a_3\t\t# mul_add_c2(a[5],b[3],c3,c1,c2);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_2,$at\n-\t$MULTU\t$a_4,$a_4\t\t# mul_add_c(a[4],b[4],c3,c1,c2);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_6,$a_2);\t\t# mul_add_c2(a[6],b[2],c3,c1,c2);\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,1,\n+\t\t$a_5,$a_3);\t\t# mul_add_c2(a[5],b[3],c3,c1,c2);\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,1,\n+\t\t$a_4,$a_4);\t\t# mul_add_c(a[4],b[4],c3,c1,c2);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_3,$t_1\n@@ -2233,82 +2048,21 @@\n \tsltu\t$at,$c_1,$t_2\n \t$ADDU\t$c_2,$at\n \t$ST\t$c_3,8*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_3,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_3,$a_6\t\t# mul_add_c2(a[3],b[6],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t$MULTU\t$a_4,$a_5\t\t# mul_add_c2(a[4],b[5],c1,c2,c3);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t $MULTU\t$a_7,$a_3\t\t# mul_add_c2(a[7],b[3],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,0,\n+\t\t$a_3,$a_6);\t\t# mul_add_c2(a[3],b[6],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_4,$a_5);\t\t# mul_add_c2(a[4],b[5],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_7,$a_3);\t\t# mul_add_c2(a[7],b[3],c2,c3,c1);\n+$code.=<<___;\n \t$ST\t$c_1,9*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_1,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_6,$a_4\t\t# mul_add_c2(a[6],b[4],c2,c3,c1);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_1,$at\n-\t$MULTU\t$a_5,$a_5\t\t# mul_add_c(a[5],b[5],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,0,\n+\t\t$a_6,$a_4);\t\t# mul_add_c2(a[6],b[4],c2,c3,c1);\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,1,\n+\t\t$a_5,$a_5);\t\t# mul_add_c(a[5],b[5],c2,c3,c1);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_2,$t_1\n@@ -2319,52 +2073,17 @@\n \tsltu\t$at,$c_3,$t_2\n \t$ADDU\t$c_1,$at\n \t$ST\t$c_2,10*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_5,$a_6\t\t# mul_add_c2(a[5],b[6],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_2,$at\n-\t $MULTU\t$a_7,$a_5\t\t# mul_add_c2(a[7],b[5],c1,c2,c3);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_5,$a_6);\t\t# mul_add_c2(a[5],b[6],c3,c1,c2);\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,1,\n+\t\t$a_7,$a_5);\t\t# mul_add_c2(a[7],b[5],c1,c2,c3);\n+$code.=<<___;\n \t$ST\t$c_3,11*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_3,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_6,$a_6\t\t# mul_add_c(a[6],b[6],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,0,\n+\t\t$a_6,$a_6);\t\t# mul_add_c(a[6],b[6],c1,c2,c3);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_1,$t_1\n@@ -2375,21 +2094,10 @@\n \tsltu\t$at,$c_2,$t_2\n \t$ADDU\t$c_3,$at\n \t$ST\t$c_1,12*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_1,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t $MULTU\t$a_7,$a_7\t\t# mul_add_c(a[7],b[7],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,0,\n+\t\t$a_7,$a_7);\t\t# mul_add_c(a[7],b[7],c3,c1,c2);\n+$code.=<<___;\n \t$ST\t$c_2,13*$BNSZ($a0)\n \n \tmflo\t$t_1\n@@ -2457,21 +2165,10 @@\n \tsltu\t$at,$c_2,$t_1\n \t$ADDU\t$c_3,$t_2,$at\n \t$ST\t$c_2,$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_1\t\t# mul_add_c(a[1],b[1],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_1,$a_1);\t\t# mul_add_c(a[1],b[1],c3,c1,c2);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_3,$t_1\n@@ -2482,52 +2179,17 @@\n \tsltu\t$at,$c_1,$t_2\n \t$ADDU\t$c_2,$at\n \t$ST\t$c_3,2*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_3,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_2\t\t# mul_add_c(a2[1],b[2],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t $MULTU\t$a_3,$a_1\t\t# mul_add_c2(a[3],b[1],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,0,\n+\t\t$a_1,$a_2);\t\t# mul_add_c2(a2[1],b[2],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_3,$a_1);\t\t# mul_add_c2(a[3],b[1],c2,c3,c1);\n+$code.=<<___;\n \t$ST\t$c_1,3*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_1,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_2,$a_2\t\t# mul_add_c(a[2],b[2],c2,c3,c1);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,0,\n+\t\t$a_2,$a_2);\t\t# mul_add_c(a[2],b[2],c2,c3,c1);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_2,$t_1\n@@ -2538,21 +2200,10 @@\n \tsltu\t$at,$c_3,$t_2\n \t$ADDU\t$c_1,$at\n \t$ST\t$c_2,4*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t $MULTU\t$a_3,$a_3\t\t# mul_add_c(a[3],b[3],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_3,$a_3);\t\t# mul_add_c(a[3],b[3],c1,c2,c3);\n+$code.=<<___;\n \t$ST\t$c_3,5*$BNSZ($a0)\n \n \tmflo\t$t_1""}<_**next**_>{""sha"": ""7f7e5c2f0ae57a3c82c80e566c04df94b25c1a6a"", ""filename"": ""crypto/bn/asm/x86_64-gcc.c"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 53, ""changes"": 101, ""blob_url"": ""https://github.com/openssl/openssl/blob/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/asm/x86_64-gcc.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/asm/x86_64-gcc.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/bn/asm/x86_64-gcc.c?ref=a7a44ba55cb4f884c6bc9ceac90072dea38e66d0"", ""patch"": ""@@ -276,77 +276,76 @@ BN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)\n /* sqr_add_c(a,i,c0,c1,c2)  -- c+=a[i]^2 for three word number c=(c2,c1,c0) */\n /* sqr_add_c2(a,i,c0,c1,c2) -- c+=2*a[i]*a[j] for three word number c=(c2,c1,c0) */\n \n+/*\n+ * Keep in mind that carrying into high part of multiplication result\n+ * can not overflow, because it cannot be all-ones.\n+ */\n #if 0\n /* original macros are kept for reference purposes */\n-#define mul_add_c(a,b,c0,c1,c2) {\t\\\n-\tBN_ULONG ta=(a),tb=(b);\t\t\\\n-\tt1 = ta * tb;\t\t\t\\\n-\tt2 = BN_UMULT_HIGH(ta,tb);\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n-\n-#define mul_add_c2(a,b,c0,c1,c2) {\t\\\n-\tBN_ULONG ta=(a),tb=(b),t0;\t\\\n-\tt1 = BN_UMULT_HIGH(ta,tb);\t\\\n-\tt0 = ta * tb;\t\t\t\\\n-\tt2 = t1+t1; c2 += (t2<t1)?1:0;\t\\\n-\tt1 = t0+t0; t2 += (t1<t0)?1:0;\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n+#define mul_add_c(a,b,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b);\t\t\\\n+\tBN_ULONG lo, hi;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,tb);\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define mul_add_c2(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b);\t\t\\\n+\tBN_ULONG lo, hi, tt;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,tb);\t\t\\\n+\tc0 += lo; tt = hi+((c0<lo)?1:0);\t\\\n+\tc1 += tt; c2 += (c1<tt)?1:0;\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define sqr_add_c(a,i,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a)[i];\t\t\t\\\n+\tBN_ULONG lo, hi;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,ta);\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n #else\n #define mul_add_c(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG t1,t2;\t\t\t\\\n \tasm (\""mulq %3\""\t\t\t\\\n \t\t: \""=a\""(t1),\""=d\""(t2)\t\\\n \t\t: \""a\""(a),\""m\""(b)\t\t\\\n \t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c0),\""+d\""(t2)\t\\\n-\t\t: \""a\""(t1),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c1),\""+r\""(c2)\t\\\n-\t\t: \""d\""(t2),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n+\tasm (\""addq %3,%0; adcq %4,%1; adcq %5,%2\""\t\\\n+\t\t: \""+r\""(c0),\""+r\""(c1),\""+r\""(c2)\t\t\\\n+\t\t: \""r\""(t1),\""r\""(t2),\""g\""(0)\t\t\\\n+\t\t: \""cc\"");\t\t\t\t\\\n \t} while (0)\n \n #define sqr_add_c(a,i,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG t1,t2;\t\t\t\\\n \tasm (\""mulq %2\""\t\t\t\\\n \t\t: \""=a\""(t1),\""=d\""(t2)\t\\\n \t\t: \""a\""(a[i])\t\t\\\n \t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c0),\""+d\""(t2)\t\\\n-\t\t: \""a\""(t1),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c1),\""+r\""(c2)\t\\\n-\t\t: \""d\""(t2),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n+\tasm (\""addq %3,%0; adcq %4,%1; adcq %5,%2\""\t\\\n+\t\t: \""+r\""(c0),\""+r\""(c1),\""+r\""(c2)\t\t\\\n+\t\t: \""r\""(t1),\""r\""(t2),\""g\""(0)\t\t\\\n+\t\t: \""cc\"");\t\t\t\t\\\n \t} while (0)\n \n #define mul_add_c2(a,b,c0,c1,c2) do {\t\\\n+\tBN_ULONG t1,t2;\t\t\t\\\n \tasm (\""mulq %3\""\t\t\t\\\n \t\t: \""=a\""(t1),\""=d\""(t2)\t\\\n \t\t: \""a\""(a),\""m\""(b)\t\t\\\n \t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %0,%0; adcq %2,%1\""\t\\\n-\t\t: \""+d\""(t2),\""+r\""(c2)\t\\\n-\t\t: \""g\""(0)\t\t\\\n-\t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %0,%0; adcq %2,%1\""\t\\\n-\t\t: \""+a\""(t1),\""+d\""(t2)\t\\\n-\t\t: \""g\""(0)\t\t\\\n-\t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c0),\""+d\""(t2)\t\\\n-\t\t: \""a\""(t1),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c1),\""+r\""(c2)\t\\\n-\t\t: \""d\""(t2),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n+\tasm (\""addq %3,%0; adcq %4,%1; adcq %5,%2\""\t\\\n+\t\t: \""+r\""(c0),\""+r\""(c1),\""+r\""(c2)\t\t\\\n+\t\t: \""r\""(t1),\""r\""(t2),\""g\""(0)\t\t\\\n+\t\t: \""cc\"");\t\t\t\t\\\n+\tasm (\""addq %3,%0; adcq %4,%1; adcq %5,%2\""\t\\\n+\t\t: \""+r\""(c0),\""+r\""(c1),\""+r\""(c2)\t\t\\\n+\t\t: \""r\""(t1),\""r\""(t2),\""g\""(0)\t\t\\\n+\t\t: \""cc\"");\t\t\t\t\\\n \t} while (0)\n #endif\n \n@@ -355,7 +354,6 @@ BN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)\n \n void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \t{\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -459,7 +457,6 @@ void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \n void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \t{\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -499,7 +496,6 @@ void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \n void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\n \t{\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -575,7 +571,6 @@ void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\n \n void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n \t{\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;""}<_**next**_>{""sha"": ""5027a583205b53135bc4e3e44b09a8c05b1fbbe6"", ""filename"": ""crypto/bn/bn_asm.c"", ""status"": ""modified"", ""additions"": 122, ""deletions"": 119, ""changes"": 241, ""blob_url"": ""https://github.com/openssl/openssl/blob/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/bn_asm.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/bn_asm.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/bn/bn_asm.c?ref=a7a44ba55cb4f884c6bc9ceac90072dea38e66d0"", ""patch"": ""@@ -439,129 +439,150 @@ BN_ULONG bn_sub_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b, int n)\n /* sqr_add_c2(a,i,c0,c1,c2) -- c+=2*a[i]*a[j] for three word number c=(c2,c1,c0) */\n \n #ifdef BN_LLONG\n-#define mul_add_c(a,b,c0,c1,c2) \\\n-\tt=(BN_ULLONG)a*b; \\\n-\tt1=(BN_ULONG)Lw(t); \\\n-\tt2=(BN_ULONG)Hw(t); \\\n-\tc0=(c0+t1)&BN_MASK2; if ((c0) < t1) t2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n-\n-#define mul_add_c2(a,b,c0,c1,c2) \\\n-\tt=(BN_ULLONG)a*b; \\\n-\ttt=(t+t)&BN_MASK; \\\n-\tif (tt < t) c2++; \\\n-\tt1=(BN_ULONG)Lw(tt); \\\n-\tt2=(BN_ULONG)Hw(tt); \\\n-\tc0=(c0+t1)&BN_MASK2;  \\\n-\tif ((c0 < t1) && (((++t2)&BN_MASK2) == 0)) c2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n-\n-#define sqr_add_c(a,i,c0,c1,c2) \\\n-\tt=(BN_ULLONG)a[i]*a[i]; \\\n-\tt1=(BN_ULONG)Lw(t); \\\n-\tt2=(BN_ULONG)Hw(t); \\\n-\tc0=(c0+t1)&BN_MASK2; if ((c0) < t1) t2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n+/*\n+ * Keep in mind that additions to multiplication result can not\n+ * overflow, because its high half cannot be all-ones.\n+ */\n+#define mul_add_c(a,b,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG hi;\t\t\t\t\\\n+\tBN_ULLONG t = (BN_ULLONG)(a)*(b);\t\\\n+\tt += c0;\t\t/* no carry */\t\\\n+\tc0 = (BN_ULONG)Lw(t);\t\t\t\\\n+\thi = (BN_ULONG)Hw(t);\t\t\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n+\n+#define mul_add_c2(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG hi;\t\t\t\t\\\n+\tBN_ULLONG t = (BN_ULLONG)(a)*(b);\t\\\n+\tBN_ULLONG tt = t+c0;\t/* no carry */\t\\\n+\tc0 = (BN_ULONG)Lw(tt);\t\t\t\\\n+\thi = (BN_ULONG)Hw(tt);\t\t\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\tt += c0;\t\t/* no carry */\t\\\n+\tc0 = (BN_ULONG)Lw(t);\t\t\t\\\n+\thi = (BN_ULONG)Hw(t);\t\t\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n+\n+#define sqr_add_c(a,i,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG hi;\t\t\t\t\\\n+\tBN_ULLONG t = (BN_ULLONG)a[i]*a[i];\t\\\n+\tt += c0;\t\t/* no carry */\t\\\n+\tc0 = (BN_ULONG)Lw(t);\t\t\t\\\n+\thi = (BN_ULONG)Hw(t);\t\t\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n \n #define sqr_add_c2(a,i,j,c0,c1,c2) \\\n \tmul_add_c2((a)[i],(a)[j],c0,c1,c2)\n \n #elif defined(BN_UMULT_LOHI)\n-\n-#define mul_add_c(a,b,c0,c1,c2)\t{\t\\\n-\tBN_ULONG ta=(a),tb=(b);\t\t\\\n-\tBN_UMULT_LOHI(t1,t2,ta,tb);\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n-\n-#define mul_add_c2(a,b,c0,c1,c2) {\t\\\n-\tBN_ULONG ta=(a),tb=(b),t0;\t\\\n-\tBN_UMULT_LOHI(t0,t1,ta,tb);\t\\\n-\tt2 = t1+t1; c2 += (t2<t1)?1:0;\t\\\n-\tt1 = t0+t0; t2 += (t1<t0)?1:0;\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n-\n-#define sqr_add_c(a,i,c0,c1,c2)\t{\t\\\n-\tBN_ULONG ta=(a)[i];\t\t\\\n-\tBN_UMULT_LOHI(t1,t2,ta,ta);\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n+/*\n+ * Keep in mind that additions to hi can not overflow, because\n+ * the high word of a multiplication result cannot be all-ones.\n+ */\n+#define mul_add_c(a,b,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b);\t\t\\\n+\tBN_ULONG lo, hi;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,tb);\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define mul_add_c2(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b);\t\t\\\n+\tBN_ULONG lo, hi, tt;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,tb);\t\t\\\n+\tc0 += lo; tt = hi+((c0<lo)?1:0);\t\\\n+\tc1 += tt; c2 += (c1<tt)?1:0;\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define sqr_add_c(a,i,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a)[i];\t\t\t\\\n+\tBN_ULONG lo, hi;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,ta);\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n \n #define sqr_add_c2(a,i,j,c0,c1,c2)\t\\\n \tmul_add_c2((a)[i],(a)[j],c0,c1,c2)\n \n #elif defined(BN_UMULT_HIGH)\n-\n-#define mul_add_c(a,b,c0,c1,c2)\t{\t\\\n-\tBN_ULONG ta=(a),tb=(b);\t\t\\\n-\tt1 = ta * tb;\t\t\t\\\n-\tt2 = BN_UMULT_HIGH(ta,tb);\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n-\n-#define mul_add_c2(a,b,c0,c1,c2) {\t\\\n-\tBN_ULONG ta=(a),tb=(b),t0;\t\\\n-\tt1 = BN_UMULT_HIGH(ta,tb);\t\\\n-\tt0 = ta * tb;\t\t\t\\\n-\tt2 = t1+t1; c2 += (t2<t1)?1:0;\t\\\n-\tt1 = t0+t0; t2 += (t1<t0)?1:0;\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n-\n-#define sqr_add_c(a,i,c0,c1,c2)\t{\t\\\n-\tBN_ULONG ta=(a)[i];\t\t\\\n-\tt1 = ta * ta;\t\t\t\\\n-\tt2 = BN_UMULT_HIGH(ta,ta);\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n+/*\n+ * Keep in mind that additions to hi can not overflow, because\n+ * the high word of a multiplication result cannot be all-ones.\n+ */\n+#define mul_add_c(a,b,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b);\t\t\\\n+\tBN_ULONG lo = ta * tb;\t\t\t\\\n+\tBN_ULONG hi = BN_UMULT_HIGH(ta,tb);\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define mul_add_c2(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b), tt;\t\\\n+\tBN_ULONG lo = ta * tb;\t\t\t\\\n+\tBN_ULONG hi = BN_UMULT_HIGH(ta,tb);\t\\\n+\tc0 += lo; tt = hi + ((c0<lo)?1:0);\t\\\n+\tc1 += tt; c2 += (c1<tt)?1:0;\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define sqr_add_c(a,i,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a)[i];\t\t\t\\\n+\tBN_ULONG lo = ta * ta;\t\t\t\\\n+\tBN_ULONG hi = BN_UMULT_HIGH(ta,ta);\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n \n #define sqr_add_c2(a,i,j,c0,c1,c2)\t\\\n \tmul_add_c2((a)[i],(a)[j],c0,c1,c2)\n \n #else /* !BN_LLONG */\n-#define mul_add_c(a,b,c0,c1,c2) \\\n-\tt1=LBITS(a); t2=HBITS(a); \\\n-\tbl=LBITS(b); bh=HBITS(b); \\\n-\tmul64(t1,t2,bl,bh); \\\n-\tc0=(c0+t1)&BN_MASK2; if ((c0) < t1) t2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n-\n-#define mul_add_c2(a,b,c0,c1,c2) \\\n-\tt1=LBITS(a); t2=HBITS(a); \\\n-\tbl=LBITS(b); bh=HBITS(b); \\\n-\tmul64(t1,t2,bl,bh); \\\n-\tif (t2 & BN_TBIT) c2++; \\\n-\tt2=(t2+t2)&BN_MASK2; \\\n-\tif (t1 & BN_TBIT) t2++; \\\n-\tt1=(t1+t1)&BN_MASK2; \\\n-\tc0=(c0+t1)&BN_MASK2;  \\\n-\tif ((c0 < t1) && (((++t2)&BN_MASK2) == 0)) c2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n-\n-#define sqr_add_c(a,i,c0,c1,c2) \\\n-\tsqr64(t1,t2,(a)[i]); \\\n-\tc0=(c0+t1)&BN_MASK2; if ((c0) < t1) t2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n+/*\n+ * Keep in mind that additions to hi can not overflow, because\n+ * the high word of a multiplication result cannot be all-ones.\n+ */\n+#define mul_add_c(a,b,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG lo = LBITS(a), hi = HBITS(a);\t\\\n+\tBN_ULONG bl = LBITS(b), bh = HBITS(b);\t\\\n+\tmul64(lo,hi,bl,bh);\t\t\t\\\n+\tc0 = (c0+lo)&BN_MASK2; if (c0<lo) hi++;\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n+\n+#define mul_add_c2(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG tt;\t\t\t\t\\\n+\tBN_ULONG lo = LBITS(a), hi = HBITS(a);\t\\\n+\tBN_ULONG bl = LBITS(b), bh = HBITS(b);\t\\\n+\tmul64(lo,hi,bl,bh);\t\t\t\\\n+\ttt = hi;\t\t\t\t\\\n+\tc0 = (c0+lo)&BN_MASK2; if (c0<lo) tt++;\t\\\n+\tc1 = (c1+tt)&BN_MASK2; if (c1<tt) c2++;\t\\\n+\tc0 = (c0+lo)&BN_MASK2; if (c0<lo) hi++;\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n+\n+#define sqr_add_c(a,i,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG lo, hi;\t\t\t\\\n+\tsqr64(lo,hi,(a)[i]);\t\t\t\\\n+\tc0 = (c0+lo)&BN_MASK2; if (c0<lo) hi++;\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n \n #define sqr_add_c2(a,i,j,c0,c1,c2) \\\n \tmul_add_c2((a)[i],(a)[j],c0,c1,c2)\n #endif /* !BN_LLONG */\n \n void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \t{\n-#ifdef BN_LLONG\n-\tBN_ULLONG t;\n-#else\n-\tBN_ULONG bl,bh;\n-#endif\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -665,12 +686,6 @@ void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \n void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \t{\n-#ifdef BN_LLONG\n-\tBN_ULLONG t;\n-#else\n-\tBN_ULONG bl,bh;\n-#endif\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -710,12 +725,6 @@ void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \n void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\n \t{\n-#ifdef BN_LLONG\n-\tBN_ULLONG t,tt;\n-#else\n-\tBN_ULONG bl,bh;\n-#endif\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -791,12 +800,6 @@ void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\n \n void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n \t{\n-#ifdef BN_LLONG\n-\tBN_ULLONG t,tt;\n-#else\n-\tBN_ULONG bl,bh;\n-#endif\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;""}<_**next**_>{""sha"": ""869ae05a901d51ee69ad4d181337ba1d8c34e7a4"", ""filename"": ""crypto/bn/bntest.c"", ""status"": ""modified"", ""additions"": 78, ""deletions"": 24, ""changes"": 102, ""blob_url"": ""https://github.com/openssl/openssl/blob/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/bntest.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/bntest.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/bn/bntest.c?ref=a7a44ba55cb4f884c6bc9ceac90072dea38e66d0"", ""patch"": ""@@ -689,44 +689,98 @@ int test_mul(BIO *bp)\n \n int test_sqr(BIO *bp, BN_CTX *ctx)\n \t{\n-\tBIGNUM a,c,d,e;\n-\tint i;\n+\tBIGNUM *a,*c,*d,*e;\n+\tint i, ret = 0;\n \n-\tBN_init(&a);\n-\tBN_init(&c);\n-\tBN_init(&d);\n-\tBN_init(&e);\n+\ta = BN_new();\n+\tc = BN_new();\n+\td = BN_new();\n+\te = BN_new();\n+\tif (a == NULL || c == NULL || d == NULL || e == NULL)\n+\t\t{\n+\t\tgoto err;\n+\t\t}\n \n \tfor (i=0; i<num0; i++)\n \t\t{\n-\t\tBN_bntest_rand(&a,40+i*10,0,0);\n-\t\ta.neg=rand_neg();\n-\t\tBN_sqr(&c,&a,ctx);\n+\t\tBN_bntest_rand(a,40+i*10,0,0);\n+\t\ta->neg=rand_neg();\n+\t\tBN_sqr(c,a,ctx);\n \t\tif (bp != NULL)\n \t\t\t{\n \t\t\tif (!results)\n \t\t\t\t{\n-\t\t\t\tBN_print(bp,&a);\n+\t\t\t\tBN_print(bp,a);\n \t\t\t\tBIO_puts(bp,\"" * \"");\n-\t\t\t\tBN_print(bp,&a);\n+\t\t\t\tBN_print(bp,a);\n \t\t\t\tBIO_puts(bp,\"" - \"");\n \t\t\t\t}\n-\t\t\tBN_print(bp,&c);\n+\t\t\tBN_print(bp,c);\n \t\t\tBIO_puts(bp,\""\\n\"");\n \t\t\t}\n-\t\tBN_div(&d,&e,&c,&a,ctx);\n-\t\tBN_sub(&d,&d,&a);\n-\t\tif(!BN_is_zero(&d) || !BN_is_zero(&e))\n-\t\t    {\n-\t\t    fprintf(stderr,\""Square test failed!\\n\"");\n-\t\t    return 0;\n-\t\t    }\n+\t\tBN_div(d,e,c,a,ctx);\n+\t\tBN_sub(d,d,a);\n+\t\tif(!BN_is_zero(d) || !BN_is_zero(e))\n+\t\t\t{\n+\t\t\tfprintf(stderr,\""Square test failed!\\n\"");\n+\t\t\tgoto err;\n+\t\t\t}\n \t\t}\n-\tBN_free(&a);\n-\tBN_free(&c);\n-\tBN_free(&d);\n-\tBN_free(&e);\n-\treturn(1);\n+\n+\t/* Regression test for a BN_sqr overflow bug. */\n+\tBN_hex2bn(&a,\n+\t\t\""80000000000000008000000000000001FFFFFFFFFFFFFFFE0000000000000000\"");\n+\tBN_sqr(c, a, ctx);\n+\tif (bp != NULL)\n+\t\t{\n+\t\tif (!results)\n+\t\t\t{\n+\t\t\tBN_print(bp,a);\n+\t\t\tBIO_puts(bp,\"" * \"");\n+\t\t\tBN_print(bp,a);\n+\t\t\tBIO_puts(bp,\"" - \"");\n+\t\t\t}\n+\t\tBN_print(bp,c);\n+\t\tBIO_puts(bp,\""\\n\"");\n+\t\t}\n+\tBN_mul(d, a, a, ctx);\n+\tif (BN_cmp(c, d))\n+\t\t{\n+\t\tfprintf(stderr, \""Square test failed: BN_sqr and BN_mul produce \""\n+\t\t\t\""different results!\\n\"");\n+\t\tgoto err;\n+\t\t}\n+\n+\t/* Regression test for a BN_sqr overflow bug. */\n+\tBN_hex2bn(&a,\n+\t\t\""80000000000000000000000080000001FFFFFFFE000000000000000000000000\"");\n+\tBN_sqr(c, a, ctx);\n+\tif (bp != NULL)\n+\t\t{\n+\t\tif (!results)\n+\t\t\t{\n+\t\t\tBN_print(bp,a);\n+\t\t\tBIO_puts(bp,\"" * \"");\n+\t\t\tBN_print(bp,a);\n+\t\t\tBIO_puts(bp,\"" - \"");\n+\t\t\t}\n+\t\tBN_print(bp,c);\n+\t\tBIO_puts(bp,\""\\n\"");\n+\t\t}\n+\tBN_mul(d, a, a, ctx);\n+\tif (BN_cmp(c, d))\n+\t\t{\n+\t\tfprintf(stderr, \""Square test failed: BN_sqr and BN_mul produce \""\n+\t\t\t\""different results!\\n\"");\n+\t\tgoto err;\n+\t\t}\n+\tret = 1;\n+err:\n+\tif (a != NULL) BN_free(a);\n+\tif (c != NULL) BN_free(c);\n+\tif (d != NULL) BN_free(d);\n+\tif (e != NULL) BN_free(e);\n+\treturn ret;\n \t}\n \n int test_mont(BIO *bp, BN_CTX *ctx)""}"," void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)
 	{
 	BN_ULONG c1,c2,c3;
 
 	c1=0;
	c2=0;
	c3=0;
	sqr_add_c(a,0,c1,c2,c3);
	r[0]=c1;
	c1=0;
	sqr_add_c2(a,1,0,c2,c3,c1);
	r[1]=c2;
	c2=0;
	sqr_add_c(a,1,c3,c1,c2);
	sqr_add_c2(a,2,0,c3,c1,c2);
	r[2]=c3;
	c3=0;
	sqr_add_c2(a,3,0,c1,c2,c3);
	sqr_add_c2(a,2,1,c1,c2,c3);
	r[3]=c1;
	c1=0;
	sqr_add_c(a,2,c2,c3,c1);
	sqr_add_c2(a,3,1,c2,c3,c1);
	r[4]=c2;
	c2=0;
	sqr_add_c2(a,3,2,c3,c1,c2);
	r[5]=c3;
	c3=0;
	sqr_add_c(a,3,c1,c2,c3);
	r[6]=c1;
	r[7]=c2;
	}
"," void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)
 	{
	BN_ULONG t1,t2;
 	BN_ULONG c1,c2,c3;
 
 	c1=0;
	c2=0;
	c3=0;
	sqr_add_c(a,0,c1,c2,c3);
	r[0]=c1;
	c1=0;
	sqr_add_c2(a,1,0,c2,c3,c1);
	r[1]=c2;
	c2=0;
	sqr_add_c(a,1,c3,c1,c2);
	sqr_add_c2(a,2,0,c3,c1,c2);
	r[2]=c3;
	c3=0;
	sqr_add_c2(a,3,0,c1,c2,c3);
	sqr_add_c2(a,2,1,c1,c2,c3);
	r[3]=c1;
	c1=0;
	sqr_add_c(a,2,c2,c3,c1);
	sqr_add_c2(a,3,1,c2,c3,c1);
	r[4]=c2;
	c2=0;
	sqr_add_c2(a,3,2,c3,c1,c2);
	r[5]=c3;
	c3=0;
	sqr_add_c(a,3,c1,c2,c3);
	r[6]=c1;
	r[7]=c2;
	}
",C,,"	BN_ULONG t1,t2;
",,"@@ -276,77 +276,76 @@ BN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)
 /* sqr_add_c(a,i,c0,c1,c2)  -- c+=a[i]^2 for three word number c=(c2,c1,c0) */
 /* sqr_add_c2(a,i,c0,c1,c2) -- c+=2*a[i]*a[j] for three word number c=(c2,c1,c0) */
 
+/*
+ * Keep in mind that carrying into high part of multiplication result
+ * can not overflow, because it cannot be all-ones.
+ */
 #if 0
 /* original macros are kept for reference purposes */
-#define mul_add_c(a,b,c0,c1,c2) {	\
-	BN_ULONG ta=(a),tb=(b);		\
-	t1 = ta * tb;			\
-	t2 = BN_UMULT_HIGH(ta,tb);	\
-	c0 += t1; t2 += (c0<t1)?1:0;	\
-	c1 += t2; c2 += (c1<t2)?1:0;	\
-	}
-
-#define mul_add_c2(a,b,c0,c1,c2) {	\
-	BN_ULONG ta=(a),tb=(b),t0;	\
-	t1 = BN_UMULT_HIGH(ta,tb);	\
-	t0 = ta * tb;			\
-	t2 = t1+t1; c2 += (t2<t1)?1:0;	\
-	t1 = t0+t0; t2 += (t1<t0)?1:0;	\
-	c0 += t1; t2 += (c0<t1)?1:0;	\
-	c1 += t2; c2 += (c1<t2)?1:0;	\
-	}
+#define mul_add_c(a,b,c0,c1,c2)		do {	\
+	BN_ULONG ta = (a), tb = (b);		\
+	BN_ULONG lo, hi;			\
+	BN_UMULT_LOHI(lo,hi,ta,tb);		\
+	c0 += lo; hi += (c0<lo)?1:0;		\
+	c1 += hi; c2 += (c1<hi)?1:0;		\
+	} while(0)
+
+#define mul_add_c2(a,b,c0,c1,c2)	do {	\
+	BN_ULONG ta = (a), tb = (b);		\
+	BN_ULONG lo, hi, tt;			\
+	BN_UMULT_LOHI(lo,hi,ta,tb);		\
+	c0 += lo; tt = hi+((c0<lo)?1:0);	\
+	c1 += tt; c2 += (c1<tt)?1:0;		\
+	c0 += lo; hi += (c0<lo)?1:0;		\
+	c1 += hi; c2 += (c1<hi)?1:0;		\
+	} while(0)
+
+#define sqr_add_c(a,i,c0,c1,c2)		do {	\
+	BN_ULONG ta = (a)[i];			\
+	BN_ULONG lo, hi;			\
+	BN_UMULT_LOHI(lo,hi,ta,ta);		\
+	c0 += lo; hi += (c0<lo)?1:0;		\
+	c1 += hi; c2 += (c1<hi)?1:0;		\
+	} while(0)
 #else
 #define mul_add_c(a,b,c0,c1,c2)	do {	\
+	BN_ULONG t1,t2;			\
 	asm (""mulq %3""			\
 		: ""=a""(t1),""=d""(t2)	\
 		: ""a""(a),""m""(b)		\
 		: ""cc"");		\
-	asm (""addq %2,%0; adcq %3,%1""	\
-		: ""+r""(c0),""+d""(t2)	\
-		: ""a""(t1),""g""(0)	\
-		: ""cc"");		\
-	asm (""addq %2,%0; adcq %3,%1""	\
-		: ""+r""(c1),""+r""(c2)	\
-		: ""d""(t2),""g""(0)	\
-		: ""cc"");		\
+	asm (""addq %3,%0; adcq %4,%1; adcq %5,%2""	\
+		: ""+r""(c0),""+r""(c1),""+r""(c2)		\
+		: ""r""(t1),""r""(t2),""g""(0)		\
+		: ""cc"");				\
 	} while (0)
 
 #define sqr_add_c(a,i,c0,c1,c2)	do {	\
+	BN_ULONG t1,t2;			\
 	asm (""mulq %2""			\
 		: ""=a""(t1),""=d""(t2)	\
 		: ""a""(a[i])		\
 		: ""cc"");		\
-	asm (""addq %2,%0; adcq %3,%1""	\
-		: ""+r""(c0),""+d""(t2)	\
-		: ""a""(t1),""g""(0)	\
-		: ""cc"");		\
-	asm (""addq %2,%0; adcq %3,%1""	\
-		: ""+r""(c1),""+r""(c2)	\
-		: ""d""(t2),""g""(0)	\
-		: ""cc"");		\
+	asm (""addq %3,%0; adcq %4,%1; adcq %5,%2""	\
+		: ""+r""(c0),""+r""(c1),""+r""(c2)		\
+		: ""r""(t1),""r""(t2),""g""(0)		\
+		: ""cc"");				\
 	} while (0)
 
 #define mul_add_c2(a,b,c0,c1,c2) do {	\
+	BN_ULONG t1,t2;			\
 	asm (""mulq %3""			\
 		: ""=a""(t1),""=d""(t2)	\
 		: ""a""(a),""m""(b)		\
 		: ""cc"");		\
-	asm (""addq %0,%0; adcq %2,%1""	\
-		: ""+d""(t2),""+r""(c2)	\
-		: ""g""(0)		\
-		: ""cc"");		\
-	asm (""addq %0,%0; adcq %2,%1""	\
-		: ""+a""(t1),""+d""(t2)	\
-		: ""g""(0)		\
-		: ""cc"");		\
-	asm (""addq %2,%0; adcq %3,%1""	\
-		: ""+r""(c0),""+d""(t2)	\
-		: ""a""(t1),""g""(0)	\
-		: ""cc"");		\
-	asm (""addq %2,%0; adcq %3,%1""	\
-		: ""+r""(c1),""+r""(c2)	\
-		: ""d""(t2),""g""(0)	\
-		: ""cc"");		\
+	asm (""addq %3,%0; adcq %4,%1; adcq %5,%2""	\
+		: ""+r""(c0),""+r""(c1),""+r""(c2)		\
+		: ""r""(t1),""r""(t2),""g""(0)		\
+		: ""cc"");				\
+	asm (""addq %3,%0; adcq %4,%1; adcq %5,%2""	\
+		: ""+r""(c0),""+r""(c1),""+r""(c2)		\
+		: ""r""(t1),""r""(t2),""g""(0)		\
+		: ""cc"");				\
 	} while (0)
 #endif
 
@@ -355,7 +354,6 @@ BN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)
 
 void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
 	{
-	BN_ULONG t1,t2;
 	BN_ULONG c1,c2,c3;
 
 	c1=0;
@@ -459,7 +457,6 @@ void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
 
 void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
 	{
-	BN_ULONG t1,t2;
 	BN_ULONG c1,c2,c3;
 
 	c1=0;
@@ -499,7 +496,6 @@ void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
 
 void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)
 	{
-	BN_ULONG t1,t2;
 	BN_ULONG c1,c2,c3;
 
 	c1=0;
@@ -575,7 +571,6 @@ void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)
 
 void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)
 	{
-	BN_ULONG t1,t2;
 	BN_ULONG c1,c2,c3;
 
 	c1=0;",openssl,a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,248385c606620b29ecc96ca9d3603463f879652b,1," void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)
 	{
//flaw_line_below:
	BN_ULONG t1,t2;
 	BN_ULONG c1,c2,c3;
 
 	c1=0;
	c2=0;
	c3=0;
	sqr_add_c(a,0,c1,c2,c3);
	r[0]=c1;
	c1=0;
	sqr_add_c2(a,1,0,c2,c3,c1);
	r[1]=c2;
	c2=0;
	sqr_add_c(a,1,c3,c1,c2);
	sqr_add_c2(a,2,0,c3,c1,c2);
	r[2]=c3;
	c3=0;
	sqr_add_c2(a,3,0,c1,c2,c3);
	sqr_add_c2(a,2,1,c1,c2,c3);
	r[3]=c1;
	c1=0;
	sqr_add_c(a,2,c2,c3,c1);
	sqr_add_c2(a,3,1,c2,c3,c1);
	r[4]=c2;
	c2=0;
	sqr_add_c2(a,3,2,c3,c1,c2);
	r[5]=c3;
	c3=0;
	sqr_add_c(a,3,c1,c2,c3);
	r[6]=c1;
	r[7]=c2;
	}
"
2267,180003,,Remote,Not required,,CVE-2014-3570,https://www.cvedetails.com/cve/CVE-2014-3570/,CWE-310,Low,Partial,,,2015-01-08,5.0,"The BN_sqr implementation in OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not properly calculate the square of a BIGNUM value, which might make it easier for remote attackers to defeat cryptographic protection mechanisms via unspecified vectors, related to crypto/bn/asm/mips.pl, crypto/bn/asm/x86_64-gcc.c, and crypto/bn/bn_asm.c.",2017-11-14,,0,https://github.com/openssl/openssl/commit/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,"Fix for CVE-2014-3570 (with minor bn_asm.c revamp).

Reviewed-by: Emilia Kasper <emilia@openssl.org>",1,crypto/bn/asm/x86_64-gcc.c,"{""sha"": ""acafde5e5685ccb7e2d59b218d45d1bda0572fbd"", ""filename"": ""crypto/bn/asm/mips.pl"", ""status"": ""modified"", ""additions"": 131, ""deletions"": 480, ""changes"": 611, ""blob_url"": ""https://github.com/openssl/openssl/blob/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/asm/mips.pl"", ""raw_url"": ""https://github.com/openssl/openssl/raw/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/asm/mips.pl"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/bn/asm/mips.pl?ref=a7a44ba55cb4f884c6bc9ceac90072dea38e66d0"", ""patch"": ""@@ -1872,6 +1872,41 @@\n \n ($a_4,$a_5,$a_6,$a_7)=($b_0,$b_1,$b_2,$b_3);\n \n+sub add_c2 () {\n+my ($hi,$lo,$c0,$c1,$c2,\n+    $warm,      # !$warm denotes first call with specific sequence of\n+                # $c_[XYZ] when there is no Z-carry to accumulate yet;\n+    $an,$bn     # these two are arguments for multiplication which\n+                # result is used in *next* step [which is why it's\n+                # commented as \""forward multiplication\"" below];\n+    )=@_;\n+$code.=<<___;\n+\tmflo\t$lo\n+\tmfhi\t$hi\n+\t$ADDU\t$c0,$lo\n+\tsltu\t$at,$c0,$lo\n+\t $MULTU\t$an,$bn\t\t\t# forward multiplication\n+\t$ADDU\t$c0,$lo\n+\t$ADDU\t$at,$hi\n+\tsltu\t$lo,$c0,$lo\n+\t$ADDU\t$c1,$at\n+\t$ADDU\t$hi,$lo\n+___\n+$code.=<<___\tif (!$warm);\n+\tsltu\t$c2,$c1,$at\n+\t$ADDU\t$c1,$hi\n+\tsltu\t$hi,$c1,$hi\n+\t$ADDU\t$c2,$hi\n+___\n+$code.=<<___\tif ($warm);\n+\tsltu\t$at,$c1,$at\n+\t$ADDU\t$c1,$hi\n+\t$ADDU\t$c2,$at\n+\tsltu\t$hi,$c1,$hi\n+\t$ADDU\t$c2,$hi\n+___\n+}\n+\n $code.=<<___;\n \n .align\t5\n@@ -1920,21 +1955,10 @@\n \tsltu\t$at,$c_2,$t_1\n \t$ADDU\t$c_3,$t_2,$at\n \t$ST\t$c_2,$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_1\t\t# mul_add_c(a[1],b[1],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_1,$a_1);\t\t# mul_add_c(a[1],b[1],c3,c1,c2);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_3,$t_1\n@@ -1945,67 +1969,19 @@\n \tsltu\t$at,$c_1,$t_2\n \t$ADDU\t$c_2,$at\n \t$ST\t$c_3,2*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_3,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_2\t\t# mul_add_c2(a[1],b[2],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t $MULTU\t$a_4,$a_0\t\t# mul_add_c2(a[4],b[0],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,0,\n+\t\t$a_1,$a_2);\t\t# mul_add_c2(a[1],b[2],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_4,$a_0);\t\t# mul_add_c2(a[4],b[0],c2,c3,c1);\n+$code.=<<___;\n \t$ST\t$c_1,3*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_1,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_3,$a_1\t\t# mul_add_c2(a[3],b[1],c2,c3,c1);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_1,$at\n-\t$MULTU\t$a_2,$a_2\t\t# mul_add_c(a[2],b[2],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,0,\n+\t\t$a_3,$a_1);\t\t# mul_add_c2(a[3],b[1],c2,c3,c1);\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,1,\n+\t\t$a_2,$a_2);\t\t# mul_add_c(a[2],b[2],c2,c3,c1);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_2,$t_1\n@@ -2016,97 +1992,23 @@\n \tsltu\t$at,$c_3,$t_2\n \t$ADDU\t$c_1,$at\n \t$ST\t$c_2,4*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_4\t\t# mul_add_c2(a[1],b[4],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_2,$at\n-\t$MULTU\t$a_2,$a_3\t\t# mul_add_c2(a[2],b[3],c3,c1,c2);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t $MULTU\t$a_6,$a_0\t\t# mul_add_c2(a[6],b[0],c1,c2,c3);\n-\t$ADDU\t$c_2,$at\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_1,$a_4);\t\t# mul_add_c2(a[1],b[4],c3,c1,c2);\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,1,\n+\t\t$a_2,$a_3);\t\t# mul_add_c2(a[2],b[3],c3,c1,c2);\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,1,\n+\t\t$a_6,$a_0);\t\t# mul_add_c2(a[6],b[0],c1,c2,c3);\n+$code.=<<___;\n \t$ST\t$c_3,5*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_3,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_5,$a_1\t\t# mul_add_c2(a[5],b[1],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t$MULTU\t$a_4,$a_2\t\t# mul_add_c2(a[4],b[2],c1,c2,c3);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t$MULTU\t$a_3,$a_3\t\t# mul_add_c(a[3],b[3],c1,c2,c3);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,0,\n+\t\t$a_5,$a_1);\t\t# mul_add_c2(a[5],b[1],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_4,$a_2);\t\t# mul_add_c2(a[4],b[2],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_3,$a_3);\t\t# mul_add_c(a[3],b[3],c1,c2,c3);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_1,$t_1\n@@ -2117,112 +2019,25 @@\n \tsltu\t$at,$c_2,$t_2\n \t$ADDU\t$c_3,$at\n \t$ST\t$c_1,6*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_1,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_6\t\t# mul_add_c2(a[1],b[6],c2,c3,c1);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_1,$at\n-\t$MULTU\t$a_2,$a_5\t\t# mul_add_c2(a[2],b[5],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_1,$at\n-\t$MULTU\t$a_3,$a_4\t\t# mul_add_c2(a[3],b[4],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_1,$at\n-\t $MULTU\t$a_7,$a_1\t\t# mul_add_c2(a[7],b[1],c3,c1,c2);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,0,\n+\t\t$a_1,$a_6);\t\t# mul_add_c2(a[1],b[6],c2,c3,c1);\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,1,\n+\t\t$a_2,$a_5);\t\t# mul_add_c2(a[2],b[5],c2,c3,c1);\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,1,\n+\t\t$a_3,$a_4);\t\t# mul_add_c2(a[3],b[4],c2,c3,c1);\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,1,\n+\t\t$a_7,$a_1);\t\t# mul_add_c2(a[7],b[1],c3,c1,c2);\n+$code.=<<___;\n \t$ST\t$c_2,7*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_6,$a_2\t\t# mul_add_c2(a[6],b[2],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_2,$at\n-\t$MULTU\t$a_5,$a_3\t\t# mul_add_c2(a[5],b[3],c3,c1,c2);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_2,$at\n-\t$MULTU\t$a_4,$a_4\t\t# mul_add_c(a[4],b[4],c3,c1,c2);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_6,$a_2);\t\t# mul_add_c2(a[6],b[2],c3,c1,c2);\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,1,\n+\t\t$a_5,$a_3);\t\t# mul_add_c2(a[5],b[3],c3,c1,c2);\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,1,\n+\t\t$a_4,$a_4);\t\t# mul_add_c(a[4],b[4],c3,c1,c2);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_3,$t_1\n@@ -2233,82 +2048,21 @@\n \tsltu\t$at,$c_1,$t_2\n \t$ADDU\t$c_2,$at\n \t$ST\t$c_3,8*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_3,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_3,$a_6\t\t# mul_add_c2(a[3],b[6],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t$MULTU\t$a_4,$a_5\t\t# mul_add_c2(a[4],b[5],c1,c2,c3);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t $MULTU\t$a_7,$a_3\t\t# mul_add_c2(a[7],b[3],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,0,\n+\t\t$a_3,$a_6);\t\t# mul_add_c2(a[3],b[6],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_4,$a_5);\t\t# mul_add_c2(a[4],b[5],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_7,$a_3);\t\t# mul_add_c2(a[7],b[3],c2,c3,c1);\n+$code.=<<___;\n \t$ST\t$c_1,9*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_1,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_6,$a_4\t\t# mul_add_c2(a[6],b[4],c2,c3,c1);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_1,$at\n-\t$MULTU\t$a_5,$a_5\t\t# mul_add_c(a[5],b[5],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,0,\n+\t\t$a_6,$a_4);\t\t# mul_add_c2(a[6],b[4],c2,c3,c1);\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,1,\n+\t\t$a_5,$a_5);\t\t# mul_add_c(a[5],b[5],c2,c3,c1);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_2,$t_1\n@@ -2319,52 +2073,17 @@\n \tsltu\t$at,$c_3,$t_2\n \t$ADDU\t$c_1,$at\n \t$ST\t$c_2,10*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_5,$a_6\t\t# mul_add_c2(a[5],b[6],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_2,$at\n-\t $MULTU\t$a_7,$a_5\t\t# mul_add_c2(a[7],b[5],c1,c2,c3);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_5,$a_6);\t\t# mul_add_c2(a[5],b[6],c3,c1,c2);\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,1,\n+\t\t$a_7,$a_5);\t\t# mul_add_c2(a[7],b[5],c1,c2,c3);\n+$code.=<<___;\n \t$ST\t$c_3,11*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_3,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_6,$a_6\t\t# mul_add_c(a[6],b[6],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,0,\n+\t\t$a_6,$a_6);\t\t# mul_add_c(a[6],b[6],c1,c2,c3);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_1,$t_1\n@@ -2375,21 +2094,10 @@\n \tsltu\t$at,$c_2,$t_2\n \t$ADDU\t$c_3,$at\n \t$ST\t$c_1,12*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_1,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t $MULTU\t$a_7,$a_7\t\t# mul_add_c(a[7],b[7],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,0,\n+\t\t$a_7,$a_7);\t\t# mul_add_c(a[7],b[7],c3,c1,c2);\n+$code.=<<___;\n \t$ST\t$c_2,13*$BNSZ($a0)\n \n \tmflo\t$t_1\n@@ -2457,21 +2165,10 @@\n \tsltu\t$at,$c_2,$t_1\n \t$ADDU\t$c_3,$t_2,$at\n \t$ST\t$c_2,$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_1\t\t# mul_add_c(a[1],b[1],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_1,$a_1);\t\t# mul_add_c(a[1],b[1],c3,c1,c2);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_3,$t_1\n@@ -2482,52 +2179,17 @@\n \tsltu\t$at,$c_1,$t_2\n \t$ADDU\t$c_2,$at\n \t$ST\t$c_3,2*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_3,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_2\t\t# mul_add_c(a2[1],b[2],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t $MULTU\t$a_3,$a_1\t\t# mul_add_c2(a[3],b[1],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,0,\n+\t\t$a_1,$a_2);\t\t# mul_add_c2(a2[1],b[2],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_3,$a_1);\t\t# mul_add_c2(a[3],b[1],c2,c3,c1);\n+$code.=<<___;\n \t$ST\t$c_1,3*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_1,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_2,$a_2\t\t# mul_add_c(a[2],b[2],c2,c3,c1);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,0,\n+\t\t$a_2,$a_2);\t\t# mul_add_c(a[2],b[2],c2,c3,c1);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_2,$t_1\n@@ -2538,21 +2200,10 @@\n \tsltu\t$at,$c_3,$t_2\n \t$ADDU\t$c_1,$at\n \t$ST\t$c_2,4*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t $MULTU\t$a_3,$a_3\t\t# mul_add_c(a[3],b[3],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_3,$a_3);\t\t# mul_add_c(a[3],b[3],c1,c2,c3);\n+$code.=<<___;\n \t$ST\t$c_3,5*$BNSZ($a0)\n \n \tmflo\t$t_1""}<_**next**_>{""sha"": ""7f7e5c2f0ae57a3c82c80e566c04df94b25c1a6a"", ""filename"": ""crypto/bn/asm/x86_64-gcc.c"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 53, ""changes"": 101, ""blob_url"": ""https://github.com/openssl/openssl/blob/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/asm/x86_64-gcc.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/asm/x86_64-gcc.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/bn/asm/x86_64-gcc.c?ref=a7a44ba55cb4f884c6bc9ceac90072dea38e66d0"", ""patch"": ""@@ -276,77 +276,76 @@ BN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)\n /* sqr_add_c(a,i,c0,c1,c2)  -- c+=a[i]^2 for three word number c=(c2,c1,c0) */\n /* sqr_add_c2(a,i,c0,c1,c2) -- c+=2*a[i]*a[j] for three word number c=(c2,c1,c0) */\n \n+/*\n+ * Keep in mind that carrying into high part of multiplication result\n+ * can not overflow, because it cannot be all-ones.\n+ */\n #if 0\n /* original macros are kept for reference purposes */\n-#define mul_add_c(a,b,c0,c1,c2) {\t\\\n-\tBN_ULONG ta=(a),tb=(b);\t\t\\\n-\tt1 = ta * tb;\t\t\t\\\n-\tt2 = BN_UMULT_HIGH(ta,tb);\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n-\n-#define mul_add_c2(a,b,c0,c1,c2) {\t\\\n-\tBN_ULONG ta=(a),tb=(b),t0;\t\\\n-\tt1 = BN_UMULT_HIGH(ta,tb);\t\\\n-\tt0 = ta * tb;\t\t\t\\\n-\tt2 = t1+t1; c2 += (t2<t1)?1:0;\t\\\n-\tt1 = t0+t0; t2 += (t1<t0)?1:0;\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n+#define mul_add_c(a,b,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b);\t\t\\\n+\tBN_ULONG lo, hi;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,tb);\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define mul_add_c2(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b);\t\t\\\n+\tBN_ULONG lo, hi, tt;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,tb);\t\t\\\n+\tc0 += lo; tt = hi+((c0<lo)?1:0);\t\\\n+\tc1 += tt; c2 += (c1<tt)?1:0;\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define sqr_add_c(a,i,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a)[i];\t\t\t\\\n+\tBN_ULONG lo, hi;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,ta);\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n #else\n #define mul_add_c(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG t1,t2;\t\t\t\\\n \tasm (\""mulq %3\""\t\t\t\\\n \t\t: \""=a\""(t1),\""=d\""(t2)\t\\\n \t\t: \""a\""(a),\""m\""(b)\t\t\\\n \t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c0),\""+d\""(t2)\t\\\n-\t\t: \""a\""(t1),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c1),\""+r\""(c2)\t\\\n-\t\t: \""d\""(t2),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n+\tasm (\""addq %3,%0; adcq %4,%1; adcq %5,%2\""\t\\\n+\t\t: \""+r\""(c0),\""+r\""(c1),\""+r\""(c2)\t\t\\\n+\t\t: \""r\""(t1),\""r\""(t2),\""g\""(0)\t\t\\\n+\t\t: \""cc\"");\t\t\t\t\\\n \t} while (0)\n \n #define sqr_add_c(a,i,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG t1,t2;\t\t\t\\\n \tasm (\""mulq %2\""\t\t\t\\\n \t\t: \""=a\""(t1),\""=d\""(t2)\t\\\n \t\t: \""a\""(a[i])\t\t\\\n \t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c0),\""+d\""(t2)\t\\\n-\t\t: \""a\""(t1),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c1),\""+r\""(c2)\t\\\n-\t\t: \""d\""(t2),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n+\tasm (\""addq %3,%0; adcq %4,%1; adcq %5,%2\""\t\\\n+\t\t: \""+r\""(c0),\""+r\""(c1),\""+r\""(c2)\t\t\\\n+\t\t: \""r\""(t1),\""r\""(t2),\""g\""(0)\t\t\\\n+\t\t: \""cc\"");\t\t\t\t\\\n \t} while (0)\n \n #define mul_add_c2(a,b,c0,c1,c2) do {\t\\\n+\tBN_ULONG t1,t2;\t\t\t\\\n \tasm (\""mulq %3\""\t\t\t\\\n \t\t: \""=a\""(t1),\""=d\""(t2)\t\\\n \t\t: \""a\""(a),\""m\""(b)\t\t\\\n \t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %0,%0; adcq %2,%1\""\t\\\n-\t\t: \""+d\""(t2),\""+r\""(c2)\t\\\n-\t\t: \""g\""(0)\t\t\\\n-\t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %0,%0; adcq %2,%1\""\t\\\n-\t\t: \""+a\""(t1),\""+d\""(t2)\t\\\n-\t\t: \""g\""(0)\t\t\\\n-\t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c0),\""+d\""(t2)\t\\\n-\t\t: \""a\""(t1),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c1),\""+r\""(c2)\t\\\n-\t\t: \""d\""(t2),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n+\tasm (\""addq %3,%0; adcq %4,%1; adcq %5,%2\""\t\\\n+\t\t: \""+r\""(c0),\""+r\""(c1),\""+r\""(c2)\t\t\\\n+\t\t: \""r\""(t1),\""r\""(t2),\""g\""(0)\t\t\\\n+\t\t: \""cc\"");\t\t\t\t\\\n+\tasm (\""addq %3,%0; adcq %4,%1; adcq %5,%2\""\t\\\n+\t\t: \""+r\""(c0),\""+r\""(c1),\""+r\""(c2)\t\t\\\n+\t\t: \""r\""(t1),\""r\""(t2),\""g\""(0)\t\t\\\n+\t\t: \""cc\"");\t\t\t\t\\\n \t} while (0)\n #endif\n \n@@ -355,7 +354,6 @@ BN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)\n \n void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \t{\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -459,7 +457,6 @@ void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \n void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \t{\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -499,7 +496,6 @@ void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \n void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\n \t{\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -575,7 +571,6 @@ void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\n \n void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n \t{\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;""}<_**next**_>{""sha"": ""5027a583205b53135bc4e3e44b09a8c05b1fbbe6"", ""filename"": ""crypto/bn/bn_asm.c"", ""status"": ""modified"", ""additions"": 122, ""deletions"": 119, ""changes"": 241, ""blob_url"": ""https://github.com/openssl/openssl/blob/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/bn_asm.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/bn_asm.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/bn/bn_asm.c?ref=a7a44ba55cb4f884c6bc9ceac90072dea38e66d0"", ""patch"": ""@@ -439,129 +439,150 @@ BN_ULONG bn_sub_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b, int n)\n /* sqr_add_c2(a,i,c0,c1,c2) -- c+=2*a[i]*a[j] for three word number c=(c2,c1,c0) */\n \n #ifdef BN_LLONG\n-#define mul_add_c(a,b,c0,c1,c2) \\\n-\tt=(BN_ULLONG)a*b; \\\n-\tt1=(BN_ULONG)Lw(t); \\\n-\tt2=(BN_ULONG)Hw(t); \\\n-\tc0=(c0+t1)&BN_MASK2; if ((c0) < t1) t2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n-\n-#define mul_add_c2(a,b,c0,c1,c2) \\\n-\tt=(BN_ULLONG)a*b; \\\n-\ttt=(t+t)&BN_MASK; \\\n-\tif (tt < t) c2++; \\\n-\tt1=(BN_ULONG)Lw(tt); \\\n-\tt2=(BN_ULONG)Hw(tt); \\\n-\tc0=(c0+t1)&BN_MASK2;  \\\n-\tif ((c0 < t1) && (((++t2)&BN_MASK2) == 0)) c2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n-\n-#define sqr_add_c(a,i,c0,c1,c2) \\\n-\tt=(BN_ULLONG)a[i]*a[i]; \\\n-\tt1=(BN_ULONG)Lw(t); \\\n-\tt2=(BN_ULONG)Hw(t); \\\n-\tc0=(c0+t1)&BN_MASK2; if ((c0) < t1) t2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n+/*\n+ * Keep in mind that additions to multiplication result can not\n+ * overflow, because its high half cannot be all-ones.\n+ */\n+#define mul_add_c(a,b,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG hi;\t\t\t\t\\\n+\tBN_ULLONG t = (BN_ULLONG)(a)*(b);\t\\\n+\tt += c0;\t\t/* no carry */\t\\\n+\tc0 = (BN_ULONG)Lw(t);\t\t\t\\\n+\thi = (BN_ULONG)Hw(t);\t\t\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n+\n+#define mul_add_c2(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG hi;\t\t\t\t\\\n+\tBN_ULLONG t = (BN_ULLONG)(a)*(b);\t\\\n+\tBN_ULLONG tt = t+c0;\t/* no carry */\t\\\n+\tc0 = (BN_ULONG)Lw(tt);\t\t\t\\\n+\thi = (BN_ULONG)Hw(tt);\t\t\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\tt += c0;\t\t/* no carry */\t\\\n+\tc0 = (BN_ULONG)Lw(t);\t\t\t\\\n+\thi = (BN_ULONG)Hw(t);\t\t\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n+\n+#define sqr_add_c(a,i,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG hi;\t\t\t\t\\\n+\tBN_ULLONG t = (BN_ULLONG)a[i]*a[i];\t\\\n+\tt += c0;\t\t/* no carry */\t\\\n+\tc0 = (BN_ULONG)Lw(t);\t\t\t\\\n+\thi = (BN_ULONG)Hw(t);\t\t\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n \n #define sqr_add_c2(a,i,j,c0,c1,c2) \\\n \tmul_add_c2((a)[i],(a)[j],c0,c1,c2)\n \n #elif defined(BN_UMULT_LOHI)\n-\n-#define mul_add_c(a,b,c0,c1,c2)\t{\t\\\n-\tBN_ULONG ta=(a),tb=(b);\t\t\\\n-\tBN_UMULT_LOHI(t1,t2,ta,tb);\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n-\n-#define mul_add_c2(a,b,c0,c1,c2) {\t\\\n-\tBN_ULONG ta=(a),tb=(b),t0;\t\\\n-\tBN_UMULT_LOHI(t0,t1,ta,tb);\t\\\n-\tt2 = t1+t1; c2 += (t2<t1)?1:0;\t\\\n-\tt1 = t0+t0; t2 += (t1<t0)?1:0;\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n-\n-#define sqr_add_c(a,i,c0,c1,c2)\t{\t\\\n-\tBN_ULONG ta=(a)[i];\t\t\\\n-\tBN_UMULT_LOHI(t1,t2,ta,ta);\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n+/*\n+ * Keep in mind that additions to hi can not overflow, because\n+ * the high word of a multiplication result cannot be all-ones.\n+ */\n+#define mul_add_c(a,b,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b);\t\t\\\n+\tBN_ULONG lo, hi;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,tb);\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define mul_add_c2(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b);\t\t\\\n+\tBN_ULONG lo, hi, tt;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,tb);\t\t\\\n+\tc0 += lo; tt = hi+((c0<lo)?1:0);\t\\\n+\tc1 += tt; c2 += (c1<tt)?1:0;\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define sqr_add_c(a,i,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a)[i];\t\t\t\\\n+\tBN_ULONG lo, hi;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,ta);\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n \n #define sqr_add_c2(a,i,j,c0,c1,c2)\t\\\n \tmul_add_c2((a)[i],(a)[j],c0,c1,c2)\n \n #elif defined(BN_UMULT_HIGH)\n-\n-#define mul_add_c(a,b,c0,c1,c2)\t{\t\\\n-\tBN_ULONG ta=(a),tb=(b);\t\t\\\n-\tt1 = ta * tb;\t\t\t\\\n-\tt2 = BN_UMULT_HIGH(ta,tb);\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n-\n-#define mul_add_c2(a,b,c0,c1,c2) {\t\\\n-\tBN_ULONG ta=(a),tb=(b),t0;\t\\\n-\tt1 = BN_UMULT_HIGH(ta,tb);\t\\\n-\tt0 = ta * tb;\t\t\t\\\n-\tt2 = t1+t1; c2 += (t2<t1)?1:0;\t\\\n-\tt1 = t0+t0; t2 += (t1<t0)?1:0;\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n-\n-#define sqr_add_c(a,i,c0,c1,c2)\t{\t\\\n-\tBN_ULONG ta=(a)[i];\t\t\\\n-\tt1 = ta * ta;\t\t\t\\\n-\tt2 = BN_UMULT_HIGH(ta,ta);\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n+/*\n+ * Keep in mind that additions to hi can not overflow, because\n+ * the high word of a multiplication result cannot be all-ones.\n+ */\n+#define mul_add_c(a,b,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b);\t\t\\\n+\tBN_ULONG lo = ta * tb;\t\t\t\\\n+\tBN_ULONG hi = BN_UMULT_HIGH(ta,tb);\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define mul_add_c2(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b), tt;\t\\\n+\tBN_ULONG lo = ta * tb;\t\t\t\\\n+\tBN_ULONG hi = BN_UMULT_HIGH(ta,tb);\t\\\n+\tc0 += lo; tt = hi + ((c0<lo)?1:0);\t\\\n+\tc1 += tt; c2 += (c1<tt)?1:0;\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define sqr_add_c(a,i,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a)[i];\t\t\t\\\n+\tBN_ULONG lo = ta * ta;\t\t\t\\\n+\tBN_ULONG hi = BN_UMULT_HIGH(ta,ta);\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n \n #define sqr_add_c2(a,i,j,c0,c1,c2)\t\\\n \tmul_add_c2((a)[i],(a)[j],c0,c1,c2)\n \n #else /* !BN_LLONG */\n-#define mul_add_c(a,b,c0,c1,c2) \\\n-\tt1=LBITS(a); t2=HBITS(a); \\\n-\tbl=LBITS(b); bh=HBITS(b); \\\n-\tmul64(t1,t2,bl,bh); \\\n-\tc0=(c0+t1)&BN_MASK2; if ((c0) < t1) t2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n-\n-#define mul_add_c2(a,b,c0,c1,c2) \\\n-\tt1=LBITS(a); t2=HBITS(a); \\\n-\tbl=LBITS(b); bh=HBITS(b); \\\n-\tmul64(t1,t2,bl,bh); \\\n-\tif (t2 & BN_TBIT) c2++; \\\n-\tt2=(t2+t2)&BN_MASK2; \\\n-\tif (t1 & BN_TBIT) t2++; \\\n-\tt1=(t1+t1)&BN_MASK2; \\\n-\tc0=(c0+t1)&BN_MASK2;  \\\n-\tif ((c0 < t1) && (((++t2)&BN_MASK2) == 0)) c2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n-\n-#define sqr_add_c(a,i,c0,c1,c2) \\\n-\tsqr64(t1,t2,(a)[i]); \\\n-\tc0=(c0+t1)&BN_MASK2; if ((c0) < t1) t2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n+/*\n+ * Keep in mind that additions to hi can not overflow, because\n+ * the high word of a multiplication result cannot be all-ones.\n+ */\n+#define mul_add_c(a,b,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG lo = LBITS(a), hi = HBITS(a);\t\\\n+\tBN_ULONG bl = LBITS(b), bh = HBITS(b);\t\\\n+\tmul64(lo,hi,bl,bh);\t\t\t\\\n+\tc0 = (c0+lo)&BN_MASK2; if (c0<lo) hi++;\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n+\n+#define mul_add_c2(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG tt;\t\t\t\t\\\n+\tBN_ULONG lo = LBITS(a), hi = HBITS(a);\t\\\n+\tBN_ULONG bl = LBITS(b), bh = HBITS(b);\t\\\n+\tmul64(lo,hi,bl,bh);\t\t\t\\\n+\ttt = hi;\t\t\t\t\\\n+\tc0 = (c0+lo)&BN_MASK2; if (c0<lo) tt++;\t\\\n+\tc1 = (c1+tt)&BN_MASK2; if (c1<tt) c2++;\t\\\n+\tc0 = (c0+lo)&BN_MASK2; if (c0<lo) hi++;\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n+\n+#define sqr_add_c(a,i,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG lo, hi;\t\t\t\\\n+\tsqr64(lo,hi,(a)[i]);\t\t\t\\\n+\tc0 = (c0+lo)&BN_MASK2; if (c0<lo) hi++;\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n \n #define sqr_add_c2(a,i,j,c0,c1,c2) \\\n \tmul_add_c2((a)[i],(a)[j],c0,c1,c2)\n #endif /* !BN_LLONG */\n \n void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \t{\n-#ifdef BN_LLONG\n-\tBN_ULLONG t;\n-#else\n-\tBN_ULONG bl,bh;\n-#endif\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -665,12 +686,6 @@ void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \n void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \t{\n-#ifdef BN_LLONG\n-\tBN_ULLONG t;\n-#else\n-\tBN_ULONG bl,bh;\n-#endif\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -710,12 +725,6 @@ void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \n void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\n \t{\n-#ifdef BN_LLONG\n-\tBN_ULLONG t,tt;\n-#else\n-\tBN_ULONG bl,bh;\n-#endif\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -791,12 +800,6 @@ void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\n \n void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n \t{\n-#ifdef BN_LLONG\n-\tBN_ULLONG t,tt;\n-#else\n-\tBN_ULONG bl,bh;\n-#endif\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;""}<_**next**_>{""sha"": ""869ae05a901d51ee69ad4d181337ba1d8c34e7a4"", ""filename"": ""crypto/bn/bntest.c"", ""status"": ""modified"", ""additions"": 78, ""deletions"": 24, ""changes"": 102, ""blob_url"": ""https://github.com/openssl/openssl/blob/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/bntest.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/bntest.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/bn/bntest.c?ref=a7a44ba55cb4f884c6bc9ceac90072dea38e66d0"", ""patch"": ""@@ -689,44 +689,98 @@ int test_mul(BIO *bp)\n \n int test_sqr(BIO *bp, BN_CTX *ctx)\n \t{\n-\tBIGNUM a,c,d,e;\n-\tint i;\n+\tBIGNUM *a,*c,*d,*e;\n+\tint i, ret = 0;\n \n-\tBN_init(&a);\n-\tBN_init(&c);\n-\tBN_init(&d);\n-\tBN_init(&e);\n+\ta = BN_new();\n+\tc = BN_new();\n+\td = BN_new();\n+\te = BN_new();\n+\tif (a == NULL || c == NULL || d == NULL || e == NULL)\n+\t\t{\n+\t\tgoto err;\n+\t\t}\n \n \tfor (i=0; i<num0; i++)\n \t\t{\n-\t\tBN_bntest_rand(&a,40+i*10,0,0);\n-\t\ta.neg=rand_neg();\n-\t\tBN_sqr(&c,&a,ctx);\n+\t\tBN_bntest_rand(a,40+i*10,0,0);\n+\t\ta->neg=rand_neg();\n+\t\tBN_sqr(c,a,ctx);\n \t\tif (bp != NULL)\n \t\t\t{\n \t\t\tif (!results)\n \t\t\t\t{\n-\t\t\t\tBN_print(bp,&a);\n+\t\t\t\tBN_print(bp,a);\n \t\t\t\tBIO_puts(bp,\"" * \"");\n-\t\t\t\tBN_print(bp,&a);\n+\t\t\t\tBN_print(bp,a);\n \t\t\t\tBIO_puts(bp,\"" - \"");\n \t\t\t\t}\n-\t\t\tBN_print(bp,&c);\n+\t\t\tBN_print(bp,c);\n \t\t\tBIO_puts(bp,\""\\n\"");\n \t\t\t}\n-\t\tBN_div(&d,&e,&c,&a,ctx);\n-\t\tBN_sub(&d,&d,&a);\n-\t\tif(!BN_is_zero(&d) || !BN_is_zero(&e))\n-\t\t    {\n-\t\t    fprintf(stderr,\""Square test failed!\\n\"");\n-\t\t    return 0;\n-\t\t    }\n+\t\tBN_div(d,e,c,a,ctx);\n+\t\tBN_sub(d,d,a);\n+\t\tif(!BN_is_zero(d) || !BN_is_zero(e))\n+\t\t\t{\n+\t\t\tfprintf(stderr,\""Square test failed!\\n\"");\n+\t\t\tgoto err;\n+\t\t\t}\n \t\t}\n-\tBN_free(&a);\n-\tBN_free(&c);\n-\tBN_free(&d);\n-\tBN_free(&e);\n-\treturn(1);\n+\n+\t/* Regression test for a BN_sqr overflow bug. */\n+\tBN_hex2bn(&a,\n+\t\t\""80000000000000008000000000000001FFFFFFFFFFFFFFFE0000000000000000\"");\n+\tBN_sqr(c, a, ctx);\n+\tif (bp != NULL)\n+\t\t{\n+\t\tif (!results)\n+\t\t\t{\n+\t\t\tBN_print(bp,a);\n+\t\t\tBIO_puts(bp,\"" * \"");\n+\t\t\tBN_print(bp,a);\n+\t\t\tBIO_puts(bp,\"" - \"");\n+\t\t\t}\n+\t\tBN_print(bp,c);\n+\t\tBIO_puts(bp,\""\\n\"");\n+\t\t}\n+\tBN_mul(d, a, a, ctx);\n+\tif (BN_cmp(c, d))\n+\t\t{\n+\t\tfprintf(stderr, \""Square test failed: BN_sqr and BN_mul produce \""\n+\t\t\t\""different results!\\n\"");\n+\t\tgoto err;\n+\t\t}\n+\n+\t/* Regression test for a BN_sqr overflow bug. */\n+\tBN_hex2bn(&a,\n+\t\t\""80000000000000000000000080000001FFFFFFFE000000000000000000000000\"");\n+\tBN_sqr(c, a, ctx);\n+\tif (bp != NULL)\n+\t\t{\n+\t\tif (!results)\n+\t\t\t{\n+\t\t\tBN_print(bp,a);\n+\t\t\tBIO_puts(bp,\"" * \"");\n+\t\t\tBN_print(bp,a);\n+\t\t\tBIO_puts(bp,\"" - \"");\n+\t\t\t}\n+\t\tBN_print(bp,c);\n+\t\tBIO_puts(bp,\""\\n\"");\n+\t\t}\n+\tBN_mul(d, a, a, ctx);\n+\tif (BN_cmp(c, d))\n+\t\t{\n+\t\tfprintf(stderr, \""Square test failed: BN_sqr and BN_mul produce \""\n+\t\t\t\""different results!\\n\"");\n+\t\tgoto err;\n+\t\t}\n+\tret = 1;\n+err:\n+\tif (a != NULL) BN_free(a);\n+\tif (c != NULL) BN_free(c);\n+\tif (d != NULL) BN_free(d);\n+\tif (e != NULL) BN_free(e);\n+\treturn ret;\n \t}\n \n int test_mont(BIO *bp, BN_CTX *ctx)""}"," void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)
 	{
 	BN_ULONG c1,c2,c3;
 
 	c1=0;
	c2=0;
	c3=0;
	sqr_add_c(a,0,c1,c2,c3);
	r[0]=c1;
	c1=0;
	sqr_add_c2(a,1,0,c2,c3,c1);
	r[1]=c2;
	c2=0;
	sqr_add_c(a,1,c3,c1,c2);
	sqr_add_c2(a,2,0,c3,c1,c2);
	r[2]=c3;
	c3=0;
	sqr_add_c2(a,3,0,c1,c2,c3);
	sqr_add_c2(a,2,1,c1,c2,c3);
	r[3]=c1;
	c1=0;
	sqr_add_c(a,2,c2,c3,c1);
	sqr_add_c2(a,3,1,c2,c3,c1);
	sqr_add_c2(a,4,0,c2,c3,c1);
	r[4]=c2;
	c2=0;
	sqr_add_c2(a,5,0,c3,c1,c2);
	sqr_add_c2(a,4,1,c3,c1,c2);
	sqr_add_c2(a,3,2,c3,c1,c2);
	r[5]=c3;
	c3=0;
	sqr_add_c(a,3,c1,c2,c3);
	sqr_add_c2(a,4,2,c1,c2,c3);
	sqr_add_c2(a,5,1,c1,c2,c3);
	sqr_add_c2(a,6,0,c1,c2,c3);
	r[6]=c1;
	c1=0;
	sqr_add_c2(a,7,0,c2,c3,c1);
	sqr_add_c2(a,6,1,c2,c3,c1);
	sqr_add_c2(a,5,2,c2,c3,c1);
	sqr_add_c2(a,4,3,c2,c3,c1);
	r[7]=c2;
	c2=0;
	sqr_add_c(a,4,c3,c1,c2);
	sqr_add_c2(a,5,3,c3,c1,c2);
	sqr_add_c2(a,6,2,c3,c1,c2);
	sqr_add_c2(a,7,1,c3,c1,c2);
	r[8]=c3;
	c3=0;
	sqr_add_c2(a,7,2,c1,c2,c3);
	sqr_add_c2(a,6,3,c1,c2,c3);
	sqr_add_c2(a,5,4,c1,c2,c3);
	r[9]=c1;
	c1=0;
	sqr_add_c(a,5,c2,c3,c1);
	sqr_add_c2(a,6,4,c2,c3,c1);
	sqr_add_c2(a,7,3,c2,c3,c1);
	r[10]=c2;
	c2=0;
	sqr_add_c2(a,7,4,c3,c1,c2);
	sqr_add_c2(a,6,5,c3,c1,c2);
	r[11]=c3;
	c3=0;
	sqr_add_c(a,6,c1,c2,c3);
	sqr_add_c2(a,7,5,c1,c2,c3);
	r[12]=c1;
	c1=0;
	sqr_add_c2(a,7,6,c2,c3,c1);
	r[13]=c2;
	c2=0;
	sqr_add_c(a,7,c3,c1,c2);
	r[14]=c3;
	r[15]=c1;
	}
"," void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)
 	{
	BN_ULONG t1,t2;
 	BN_ULONG c1,c2,c3;
 
 	c1=0;
	c2=0;
	c3=0;
	sqr_add_c(a,0,c1,c2,c3);
	r[0]=c1;
	c1=0;
	sqr_add_c2(a,1,0,c2,c3,c1);
	r[1]=c2;
	c2=0;
	sqr_add_c(a,1,c3,c1,c2);
	sqr_add_c2(a,2,0,c3,c1,c2);
	r[2]=c3;
	c3=0;
	sqr_add_c2(a,3,0,c1,c2,c3);
	sqr_add_c2(a,2,1,c1,c2,c3);
	r[3]=c1;
	c1=0;
	sqr_add_c(a,2,c2,c3,c1);
	sqr_add_c2(a,3,1,c2,c3,c1);
	sqr_add_c2(a,4,0,c2,c3,c1);
	r[4]=c2;
	c2=0;
	sqr_add_c2(a,5,0,c3,c1,c2);
	sqr_add_c2(a,4,1,c3,c1,c2);
	sqr_add_c2(a,3,2,c3,c1,c2);
	r[5]=c3;
	c3=0;
	sqr_add_c(a,3,c1,c2,c3);
	sqr_add_c2(a,4,2,c1,c2,c3);
	sqr_add_c2(a,5,1,c1,c2,c3);
	sqr_add_c2(a,6,0,c1,c2,c3);
	r[6]=c1;
	c1=0;
	sqr_add_c2(a,7,0,c2,c3,c1);
	sqr_add_c2(a,6,1,c2,c3,c1);
	sqr_add_c2(a,5,2,c2,c3,c1);
	sqr_add_c2(a,4,3,c2,c3,c1);
	r[7]=c2;
	c2=0;
	sqr_add_c(a,4,c3,c1,c2);
	sqr_add_c2(a,5,3,c3,c1,c2);
	sqr_add_c2(a,6,2,c3,c1,c2);
	sqr_add_c2(a,7,1,c3,c1,c2);
	r[8]=c3;
	c3=0;
	sqr_add_c2(a,7,2,c1,c2,c3);
	sqr_add_c2(a,6,3,c1,c2,c3);
	sqr_add_c2(a,5,4,c1,c2,c3);
	r[9]=c1;
	c1=0;
	sqr_add_c(a,5,c2,c3,c1);
	sqr_add_c2(a,6,4,c2,c3,c1);
	sqr_add_c2(a,7,3,c2,c3,c1);
	r[10]=c2;
	c2=0;
	sqr_add_c2(a,7,4,c3,c1,c2);
	sqr_add_c2(a,6,5,c3,c1,c2);
	r[11]=c3;
	c3=0;
	sqr_add_c(a,6,c1,c2,c3);
	sqr_add_c2(a,7,5,c1,c2,c3);
	r[12]=c1;
	c1=0;
	sqr_add_c2(a,7,6,c2,c3,c1);
	r[13]=c2;
	c2=0;
	sqr_add_c(a,7,c3,c1,c2);
	r[14]=c3;
	r[15]=c1;
	}
",C,,"	BN_ULONG t1,t2;
",,"@@ -276,77 +276,76 @@ BN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)
 /* sqr_add_c(a,i,c0,c1,c2)  -- c+=a[i]^2 for three word number c=(c2,c1,c0) */
 /* sqr_add_c2(a,i,c0,c1,c2) -- c+=2*a[i]*a[j] for three word number c=(c2,c1,c0) */
 
+/*
+ * Keep in mind that carrying into high part of multiplication result
+ * can not overflow, because it cannot be all-ones.
+ */
 #if 0
 /* original macros are kept for reference purposes */
-#define mul_add_c(a,b,c0,c1,c2) {	\
-	BN_ULONG ta=(a),tb=(b);		\
-	t1 = ta * tb;			\
-	t2 = BN_UMULT_HIGH(ta,tb);	\
-	c0 += t1; t2 += (c0<t1)?1:0;	\
-	c1 += t2; c2 += (c1<t2)?1:0;	\
-	}
-
-#define mul_add_c2(a,b,c0,c1,c2) {	\
-	BN_ULONG ta=(a),tb=(b),t0;	\
-	t1 = BN_UMULT_HIGH(ta,tb);	\
-	t0 = ta * tb;			\
-	t2 = t1+t1; c2 += (t2<t1)?1:0;	\
-	t1 = t0+t0; t2 += (t1<t0)?1:0;	\
-	c0 += t1; t2 += (c0<t1)?1:0;	\
-	c1 += t2; c2 += (c1<t2)?1:0;	\
-	}
+#define mul_add_c(a,b,c0,c1,c2)		do {	\
+	BN_ULONG ta = (a), tb = (b);		\
+	BN_ULONG lo, hi;			\
+	BN_UMULT_LOHI(lo,hi,ta,tb);		\
+	c0 += lo; hi += (c0<lo)?1:0;		\
+	c1 += hi; c2 += (c1<hi)?1:0;		\
+	} while(0)
+
+#define mul_add_c2(a,b,c0,c1,c2)	do {	\
+	BN_ULONG ta = (a), tb = (b);		\
+	BN_ULONG lo, hi, tt;			\
+	BN_UMULT_LOHI(lo,hi,ta,tb);		\
+	c0 += lo; tt = hi+((c0<lo)?1:0);	\
+	c1 += tt; c2 += (c1<tt)?1:0;		\
+	c0 += lo; hi += (c0<lo)?1:0;		\
+	c1 += hi; c2 += (c1<hi)?1:0;		\
+	} while(0)
+
+#define sqr_add_c(a,i,c0,c1,c2)		do {	\
+	BN_ULONG ta = (a)[i];			\
+	BN_ULONG lo, hi;			\
+	BN_UMULT_LOHI(lo,hi,ta,ta);		\
+	c0 += lo; hi += (c0<lo)?1:0;		\
+	c1 += hi; c2 += (c1<hi)?1:0;		\
+	} while(0)
 #else
 #define mul_add_c(a,b,c0,c1,c2)	do {	\
+	BN_ULONG t1,t2;			\
 	asm (""mulq %3""			\
 		: ""=a""(t1),""=d""(t2)	\
 		: ""a""(a),""m""(b)		\
 		: ""cc"");		\
-	asm (""addq %2,%0; adcq %3,%1""	\
-		: ""+r""(c0),""+d""(t2)	\
-		: ""a""(t1),""g""(0)	\
-		: ""cc"");		\
-	asm (""addq %2,%0; adcq %3,%1""	\
-		: ""+r""(c1),""+r""(c2)	\
-		: ""d""(t2),""g""(0)	\
-		: ""cc"");		\
+	asm (""addq %3,%0; adcq %4,%1; adcq %5,%2""	\
+		: ""+r""(c0),""+r""(c1),""+r""(c2)		\
+		: ""r""(t1),""r""(t2),""g""(0)		\
+		: ""cc"");				\
 	} while (0)
 
 #define sqr_add_c(a,i,c0,c1,c2)	do {	\
+	BN_ULONG t1,t2;			\
 	asm (""mulq %2""			\
 		: ""=a""(t1),""=d""(t2)	\
 		: ""a""(a[i])		\
 		: ""cc"");		\
-	asm (""addq %2,%0; adcq %3,%1""	\
-		: ""+r""(c0),""+d""(t2)	\
-		: ""a""(t1),""g""(0)	\
-		: ""cc"");		\
-	asm (""addq %2,%0; adcq %3,%1""	\
-		: ""+r""(c1),""+r""(c2)	\
-		: ""d""(t2),""g""(0)	\
-		: ""cc"");		\
+	asm (""addq %3,%0; adcq %4,%1; adcq %5,%2""	\
+		: ""+r""(c0),""+r""(c1),""+r""(c2)		\
+		: ""r""(t1),""r""(t2),""g""(0)		\
+		: ""cc"");				\
 	} while (0)
 
 #define mul_add_c2(a,b,c0,c1,c2) do {	\
+	BN_ULONG t1,t2;			\
 	asm (""mulq %3""			\
 		: ""=a""(t1),""=d""(t2)	\
 		: ""a""(a),""m""(b)		\
 		: ""cc"");		\
-	asm (""addq %0,%0; adcq %2,%1""	\
-		: ""+d""(t2),""+r""(c2)	\
-		: ""g""(0)		\
-		: ""cc"");		\
-	asm (""addq %0,%0; adcq %2,%1""	\
-		: ""+a""(t1),""+d""(t2)	\
-		: ""g""(0)		\
-		: ""cc"");		\
-	asm (""addq %2,%0; adcq %3,%1""	\
-		: ""+r""(c0),""+d""(t2)	\
-		: ""a""(t1),""g""(0)	\
-		: ""cc"");		\
-	asm (""addq %2,%0; adcq %3,%1""	\
-		: ""+r""(c1),""+r""(c2)	\
-		: ""d""(t2),""g""(0)	\
-		: ""cc"");		\
+	asm (""addq %3,%0; adcq %4,%1; adcq %5,%2""	\
+		: ""+r""(c0),""+r""(c1),""+r""(c2)		\
+		: ""r""(t1),""r""(t2),""g""(0)		\
+		: ""cc"");				\
+	asm (""addq %3,%0; adcq %4,%1; adcq %5,%2""	\
+		: ""+r""(c0),""+r""(c1),""+r""(c2)		\
+		: ""r""(t1),""r""(t2),""g""(0)		\
+		: ""cc"");				\
 	} while (0)
 #endif
 
@@ -355,7 +354,6 @@ BN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)
 
 void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
 	{
-	BN_ULONG t1,t2;
 	BN_ULONG c1,c2,c3;
 
 	c1=0;
@@ -459,7 +457,6 @@ void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
 
 void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
 	{
-	BN_ULONG t1,t2;
 	BN_ULONG c1,c2,c3;
 
 	c1=0;
@@ -499,7 +496,6 @@ void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
 
 void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)
 	{
-	BN_ULONG t1,t2;
 	BN_ULONG c1,c2,c3;
 
 	c1=0;
@@ -575,7 +571,6 @@ void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)
 
 void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)
 	{
-	BN_ULONG t1,t2;
 	BN_ULONG c1,c2,c3;
 
 	c1=0;",openssl,a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,248385c606620b29ecc96ca9d3603463f879652b,1," void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)
 	{
//flaw_line_below:
	BN_ULONG t1,t2;
 	BN_ULONG c1,c2,c3;
 
 	c1=0;
	c2=0;
	c3=0;
	sqr_add_c(a,0,c1,c2,c3);
	r[0]=c1;
	c1=0;
	sqr_add_c2(a,1,0,c2,c3,c1);
	r[1]=c2;
	c2=0;
	sqr_add_c(a,1,c3,c1,c2);
	sqr_add_c2(a,2,0,c3,c1,c2);
	r[2]=c3;
	c3=0;
	sqr_add_c2(a,3,0,c1,c2,c3);
	sqr_add_c2(a,2,1,c1,c2,c3);
	r[3]=c1;
	c1=0;
	sqr_add_c(a,2,c2,c3,c1);
	sqr_add_c2(a,3,1,c2,c3,c1);
	sqr_add_c2(a,4,0,c2,c3,c1);
	r[4]=c2;
	c2=0;
	sqr_add_c2(a,5,0,c3,c1,c2);
	sqr_add_c2(a,4,1,c3,c1,c2);
	sqr_add_c2(a,3,2,c3,c1,c2);
	r[5]=c3;
	c3=0;
	sqr_add_c(a,3,c1,c2,c3);
	sqr_add_c2(a,4,2,c1,c2,c3);
	sqr_add_c2(a,5,1,c1,c2,c3);
	sqr_add_c2(a,6,0,c1,c2,c3);
	r[6]=c1;
	c1=0;
	sqr_add_c2(a,7,0,c2,c3,c1);
	sqr_add_c2(a,6,1,c2,c3,c1);
	sqr_add_c2(a,5,2,c2,c3,c1);
	sqr_add_c2(a,4,3,c2,c3,c1);
	r[7]=c2;
	c2=0;
	sqr_add_c(a,4,c3,c1,c2);
	sqr_add_c2(a,5,3,c3,c1,c2);
	sqr_add_c2(a,6,2,c3,c1,c2);
	sqr_add_c2(a,7,1,c3,c1,c2);
	r[8]=c3;
	c3=0;
	sqr_add_c2(a,7,2,c1,c2,c3);
	sqr_add_c2(a,6,3,c1,c2,c3);
	sqr_add_c2(a,5,4,c1,c2,c3);
	r[9]=c1;
	c1=0;
	sqr_add_c(a,5,c2,c3,c1);
	sqr_add_c2(a,6,4,c2,c3,c1);
	sqr_add_c2(a,7,3,c2,c3,c1);
	r[10]=c2;
	c2=0;
	sqr_add_c2(a,7,4,c3,c1,c2);
	sqr_add_c2(a,6,5,c3,c1,c2);
	r[11]=c3;
	c3=0;
	sqr_add_c(a,6,c1,c2,c3);
	sqr_add_c2(a,7,5,c1,c2,c3);
	r[12]=c1;
	c1=0;
	sqr_add_c2(a,7,6,c2,c3,c1);
	r[13]=c2;
	c2=0;
	sqr_add_c(a,7,c3,c1,c2);
	r[14]=c3;
	r[15]=c1;
	}
"
2268,180004,,Remote,Not required,,CVE-2014-3570,https://www.cvedetails.com/cve/CVE-2014-3570/,CWE-310,Low,Partial,,,2015-01-08,5.0,"The BN_sqr implementation in OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not properly calculate the square of a BIGNUM value, which might make it easier for remote attackers to defeat cryptographic protection mechanisms via unspecified vectors, related to crypto/bn/asm/mips.pl, crypto/bn/asm/x86_64-gcc.c, and crypto/bn/bn_asm.c.",2017-11-14,,78,https://github.com/openssl/openssl/commit/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,"Fix for CVE-2014-3570 (with minor bn_asm.c revamp).

Reviewed-by: Emilia Kasper <emilia@openssl.org>",24,crypto/bn/bntest.c,"{""sha"": ""acafde5e5685ccb7e2d59b218d45d1bda0572fbd"", ""filename"": ""crypto/bn/asm/mips.pl"", ""status"": ""modified"", ""additions"": 131, ""deletions"": 480, ""changes"": 611, ""blob_url"": ""https://github.com/openssl/openssl/blob/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/asm/mips.pl"", ""raw_url"": ""https://github.com/openssl/openssl/raw/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/asm/mips.pl"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/bn/asm/mips.pl?ref=a7a44ba55cb4f884c6bc9ceac90072dea38e66d0"", ""patch"": ""@@ -1872,6 +1872,41 @@\n \n ($a_4,$a_5,$a_6,$a_7)=($b_0,$b_1,$b_2,$b_3);\n \n+sub add_c2 () {\n+my ($hi,$lo,$c0,$c1,$c2,\n+    $warm,      # !$warm denotes first call with specific sequence of\n+                # $c_[XYZ] when there is no Z-carry to accumulate yet;\n+    $an,$bn     # these two are arguments for multiplication which\n+                # result is used in *next* step [which is why it's\n+                # commented as \""forward multiplication\"" below];\n+    )=@_;\n+$code.=<<___;\n+\tmflo\t$lo\n+\tmfhi\t$hi\n+\t$ADDU\t$c0,$lo\n+\tsltu\t$at,$c0,$lo\n+\t $MULTU\t$an,$bn\t\t\t# forward multiplication\n+\t$ADDU\t$c0,$lo\n+\t$ADDU\t$at,$hi\n+\tsltu\t$lo,$c0,$lo\n+\t$ADDU\t$c1,$at\n+\t$ADDU\t$hi,$lo\n+___\n+$code.=<<___\tif (!$warm);\n+\tsltu\t$c2,$c1,$at\n+\t$ADDU\t$c1,$hi\n+\tsltu\t$hi,$c1,$hi\n+\t$ADDU\t$c2,$hi\n+___\n+$code.=<<___\tif ($warm);\n+\tsltu\t$at,$c1,$at\n+\t$ADDU\t$c1,$hi\n+\t$ADDU\t$c2,$at\n+\tsltu\t$hi,$c1,$hi\n+\t$ADDU\t$c2,$hi\n+___\n+}\n+\n $code.=<<___;\n \n .align\t5\n@@ -1920,21 +1955,10 @@\n \tsltu\t$at,$c_2,$t_1\n \t$ADDU\t$c_3,$t_2,$at\n \t$ST\t$c_2,$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_1\t\t# mul_add_c(a[1],b[1],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_1,$a_1);\t\t# mul_add_c(a[1],b[1],c3,c1,c2);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_3,$t_1\n@@ -1945,67 +1969,19 @@\n \tsltu\t$at,$c_1,$t_2\n \t$ADDU\t$c_2,$at\n \t$ST\t$c_3,2*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_3,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_2\t\t# mul_add_c2(a[1],b[2],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t $MULTU\t$a_4,$a_0\t\t# mul_add_c2(a[4],b[0],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,0,\n+\t\t$a_1,$a_2);\t\t# mul_add_c2(a[1],b[2],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_4,$a_0);\t\t# mul_add_c2(a[4],b[0],c2,c3,c1);\n+$code.=<<___;\n \t$ST\t$c_1,3*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_1,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_3,$a_1\t\t# mul_add_c2(a[3],b[1],c2,c3,c1);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_1,$at\n-\t$MULTU\t$a_2,$a_2\t\t# mul_add_c(a[2],b[2],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,0,\n+\t\t$a_3,$a_1);\t\t# mul_add_c2(a[3],b[1],c2,c3,c1);\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,1,\n+\t\t$a_2,$a_2);\t\t# mul_add_c(a[2],b[2],c2,c3,c1);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_2,$t_1\n@@ -2016,97 +1992,23 @@\n \tsltu\t$at,$c_3,$t_2\n \t$ADDU\t$c_1,$at\n \t$ST\t$c_2,4*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_4\t\t# mul_add_c2(a[1],b[4],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_2,$at\n-\t$MULTU\t$a_2,$a_3\t\t# mul_add_c2(a[2],b[3],c3,c1,c2);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t $MULTU\t$a_6,$a_0\t\t# mul_add_c2(a[6],b[0],c1,c2,c3);\n-\t$ADDU\t$c_2,$at\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_1,$a_4);\t\t# mul_add_c2(a[1],b[4],c3,c1,c2);\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,1,\n+\t\t$a_2,$a_3);\t\t# mul_add_c2(a[2],b[3],c3,c1,c2);\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,1,\n+\t\t$a_6,$a_0);\t\t# mul_add_c2(a[6],b[0],c1,c2,c3);\n+$code.=<<___;\n \t$ST\t$c_3,5*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_3,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_5,$a_1\t\t# mul_add_c2(a[5],b[1],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t$MULTU\t$a_4,$a_2\t\t# mul_add_c2(a[4],b[2],c1,c2,c3);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t$MULTU\t$a_3,$a_3\t\t# mul_add_c(a[3],b[3],c1,c2,c3);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,0,\n+\t\t$a_5,$a_1);\t\t# mul_add_c2(a[5],b[1],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_4,$a_2);\t\t# mul_add_c2(a[4],b[2],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_3,$a_3);\t\t# mul_add_c(a[3],b[3],c1,c2,c3);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_1,$t_1\n@@ -2117,112 +2019,25 @@\n \tsltu\t$at,$c_2,$t_2\n \t$ADDU\t$c_3,$at\n \t$ST\t$c_1,6*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_1,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_6\t\t# mul_add_c2(a[1],b[6],c2,c3,c1);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_1,$at\n-\t$MULTU\t$a_2,$a_5\t\t# mul_add_c2(a[2],b[5],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_1,$at\n-\t$MULTU\t$a_3,$a_4\t\t# mul_add_c2(a[3],b[4],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_1,$at\n-\t $MULTU\t$a_7,$a_1\t\t# mul_add_c2(a[7],b[1],c3,c1,c2);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,0,\n+\t\t$a_1,$a_6);\t\t# mul_add_c2(a[1],b[6],c2,c3,c1);\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,1,\n+\t\t$a_2,$a_5);\t\t# mul_add_c2(a[2],b[5],c2,c3,c1);\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,1,\n+\t\t$a_3,$a_4);\t\t# mul_add_c2(a[3],b[4],c2,c3,c1);\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,1,\n+\t\t$a_7,$a_1);\t\t# mul_add_c2(a[7],b[1],c3,c1,c2);\n+$code.=<<___;\n \t$ST\t$c_2,7*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_6,$a_2\t\t# mul_add_c2(a[6],b[2],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_2,$at\n-\t$MULTU\t$a_5,$a_3\t\t# mul_add_c2(a[5],b[3],c3,c1,c2);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_2,$at\n-\t$MULTU\t$a_4,$a_4\t\t# mul_add_c(a[4],b[4],c3,c1,c2);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_6,$a_2);\t\t# mul_add_c2(a[6],b[2],c3,c1,c2);\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,1,\n+\t\t$a_5,$a_3);\t\t# mul_add_c2(a[5],b[3],c3,c1,c2);\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,1,\n+\t\t$a_4,$a_4);\t\t# mul_add_c(a[4],b[4],c3,c1,c2);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_3,$t_1\n@@ -2233,82 +2048,21 @@\n \tsltu\t$at,$c_1,$t_2\n \t$ADDU\t$c_2,$at\n \t$ST\t$c_3,8*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_3,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_3,$a_6\t\t# mul_add_c2(a[3],b[6],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t$MULTU\t$a_4,$a_5\t\t# mul_add_c2(a[4],b[5],c1,c2,c3);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t $MULTU\t$a_7,$a_3\t\t# mul_add_c2(a[7],b[3],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,0,\n+\t\t$a_3,$a_6);\t\t# mul_add_c2(a[3],b[6],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_4,$a_5);\t\t# mul_add_c2(a[4],b[5],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_7,$a_3);\t\t# mul_add_c2(a[7],b[3],c2,c3,c1);\n+$code.=<<___;\n \t$ST\t$c_1,9*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_1,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_6,$a_4\t\t# mul_add_c2(a[6],b[4],c2,c3,c1);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_1,$at\n-\t$MULTU\t$a_5,$a_5\t\t# mul_add_c(a[5],b[5],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,0,\n+\t\t$a_6,$a_4);\t\t# mul_add_c2(a[6],b[4],c2,c3,c1);\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,1,\n+\t\t$a_5,$a_5);\t\t# mul_add_c(a[5],b[5],c2,c3,c1);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_2,$t_1\n@@ -2319,52 +2073,17 @@\n \tsltu\t$at,$c_3,$t_2\n \t$ADDU\t$c_1,$at\n \t$ST\t$c_2,10*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_5,$a_6\t\t# mul_add_c2(a[5],b[6],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_2,$at\n-\t $MULTU\t$a_7,$a_5\t\t# mul_add_c2(a[7],b[5],c1,c2,c3);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_5,$a_6);\t\t# mul_add_c2(a[5],b[6],c3,c1,c2);\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,1,\n+\t\t$a_7,$a_5);\t\t# mul_add_c2(a[7],b[5],c1,c2,c3);\n+$code.=<<___;\n \t$ST\t$c_3,11*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_3,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_6,$a_6\t\t# mul_add_c(a[6],b[6],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,0,\n+\t\t$a_6,$a_6);\t\t# mul_add_c(a[6],b[6],c1,c2,c3);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_1,$t_1\n@@ -2375,21 +2094,10 @@\n \tsltu\t$at,$c_2,$t_2\n \t$ADDU\t$c_3,$at\n \t$ST\t$c_1,12*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_1,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t $MULTU\t$a_7,$a_7\t\t# mul_add_c(a[7],b[7],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,0,\n+\t\t$a_7,$a_7);\t\t# mul_add_c(a[7],b[7],c3,c1,c2);\n+$code.=<<___;\n \t$ST\t$c_2,13*$BNSZ($a0)\n \n \tmflo\t$t_1\n@@ -2457,21 +2165,10 @@\n \tsltu\t$at,$c_2,$t_1\n \t$ADDU\t$c_3,$t_2,$at\n \t$ST\t$c_2,$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_1\t\t# mul_add_c(a[1],b[1],c3,c1,c2);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_1,$a_1);\t\t# mul_add_c(a[1],b[1],c3,c1,c2);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_3,$t_1\n@@ -2482,52 +2179,17 @@\n \tsltu\t$at,$c_1,$t_2\n \t$ADDU\t$c_2,$at\n \t$ST\t$c_3,2*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_3,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_1,$a_2\t\t# mul_add_c(a2[1],b[2],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$at,$t_2,$zero\n-\t$ADDU\t$c_3,$at\n-\t $MULTU\t$a_3,$a_1\t\t# mul_add_c2(a[3],b[1],c2,c3,c1);\n-\t$SLL\t$t_2,1\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_1,$t_1\n-\tsltu\t$at,$c_1,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_2,$t_2\n-\tsltu\t$at,$c_2,$t_2\n-\t$ADDU\t$c_3,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,0,\n+\t\t$a_1,$a_2);\t\t# mul_add_c2(a2[1],b[2],c1,c2,c3);\n+\t&add_c2($t_2,$t_1,$c_1,$c_2,$c_3,1,\n+\t\t$a_3,$a_1);\t\t# mul_add_c2(a[3],b[1],c2,c3,c1);\n+$code.=<<___;\n \t$ST\t$c_1,3*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_1,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t$MULTU\t$a_2,$a_2\t\t# mul_add_c(a[2],b[2],c2,c3,c1);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_2,$t_1\n-\tsltu\t$at,$c_2,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_3,$t_2\n-\tsltu\t$at,$c_3,$t_2\n-\t$ADDU\t$c_1,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_2,$c_3,$c_1,0,\n+\t\t$a_2,$a_2);\t\t# mul_add_c(a[2],b[2],c2,c3,c1);\n+$code.=<<___;\n \tmflo\t$t_1\n \tmfhi\t$t_2\n \t$ADDU\t$c_2,$t_1\n@@ -2538,21 +2200,10 @@\n \tsltu\t$at,$c_3,$t_2\n \t$ADDU\t$c_1,$at\n \t$ST\t$c_2,4*$BNSZ($a0)\n-\n-\tmflo\t$t_1\n-\tmfhi\t$t_2\n-\tslt\t$c_2,$t_2,$zero\n-\t$SLL\t$t_2,1\n-\t $MULTU\t$a_3,$a_3\t\t# mul_add_c(a[3],b[3],c1,c2,c3);\n-\tslt\t$a2,$t_1,$zero\n-\t$ADDU\t$t_2,$a2\n-\t$SLL\t$t_1,1\n-\t$ADDU\t$c_3,$t_1\n-\tsltu\t$at,$c_3,$t_1\n-\t$ADDU\t$t_2,$at\n-\t$ADDU\t$c_1,$t_2\n-\tsltu\t$at,$c_1,$t_2\n-\t$ADDU\t$c_2,$at\n+___\n+\t&add_c2($t_2,$t_1,$c_3,$c_1,$c_2,0,\n+\t\t$a_3,$a_3);\t\t# mul_add_c(a[3],b[3],c1,c2,c3);\n+$code.=<<___;\n \t$ST\t$c_3,5*$BNSZ($a0)\n \n \tmflo\t$t_1""}<_**next**_>{""sha"": ""7f7e5c2f0ae57a3c82c80e566c04df94b25c1a6a"", ""filename"": ""crypto/bn/asm/x86_64-gcc.c"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 53, ""changes"": 101, ""blob_url"": ""https://github.com/openssl/openssl/blob/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/asm/x86_64-gcc.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/asm/x86_64-gcc.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/bn/asm/x86_64-gcc.c?ref=a7a44ba55cb4f884c6bc9ceac90072dea38e66d0"", ""patch"": ""@@ -276,77 +276,76 @@ BN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)\n /* sqr_add_c(a,i,c0,c1,c2)  -- c+=a[i]^2 for three word number c=(c2,c1,c0) */\n /* sqr_add_c2(a,i,c0,c1,c2) -- c+=2*a[i]*a[j] for three word number c=(c2,c1,c0) */\n \n+/*\n+ * Keep in mind that carrying into high part of multiplication result\n+ * can not overflow, because it cannot be all-ones.\n+ */\n #if 0\n /* original macros are kept for reference purposes */\n-#define mul_add_c(a,b,c0,c1,c2) {\t\\\n-\tBN_ULONG ta=(a),tb=(b);\t\t\\\n-\tt1 = ta * tb;\t\t\t\\\n-\tt2 = BN_UMULT_HIGH(ta,tb);\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n-\n-#define mul_add_c2(a,b,c0,c1,c2) {\t\\\n-\tBN_ULONG ta=(a),tb=(b),t0;\t\\\n-\tt1 = BN_UMULT_HIGH(ta,tb);\t\\\n-\tt0 = ta * tb;\t\t\t\\\n-\tt2 = t1+t1; c2 += (t2<t1)?1:0;\t\\\n-\tt1 = t0+t0; t2 += (t1<t0)?1:0;\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n+#define mul_add_c(a,b,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b);\t\t\\\n+\tBN_ULONG lo, hi;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,tb);\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define mul_add_c2(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b);\t\t\\\n+\tBN_ULONG lo, hi, tt;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,tb);\t\t\\\n+\tc0 += lo; tt = hi+((c0<lo)?1:0);\t\\\n+\tc1 += tt; c2 += (c1<tt)?1:0;\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define sqr_add_c(a,i,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a)[i];\t\t\t\\\n+\tBN_ULONG lo, hi;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,ta);\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n #else\n #define mul_add_c(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG t1,t2;\t\t\t\\\n \tasm (\""mulq %3\""\t\t\t\\\n \t\t: \""=a\""(t1),\""=d\""(t2)\t\\\n \t\t: \""a\""(a),\""m\""(b)\t\t\\\n \t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c0),\""+d\""(t2)\t\\\n-\t\t: \""a\""(t1),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c1),\""+r\""(c2)\t\\\n-\t\t: \""d\""(t2),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n+\tasm (\""addq %3,%0; adcq %4,%1; adcq %5,%2\""\t\\\n+\t\t: \""+r\""(c0),\""+r\""(c1),\""+r\""(c2)\t\t\\\n+\t\t: \""r\""(t1),\""r\""(t2),\""g\""(0)\t\t\\\n+\t\t: \""cc\"");\t\t\t\t\\\n \t} while (0)\n \n #define sqr_add_c(a,i,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG t1,t2;\t\t\t\\\n \tasm (\""mulq %2\""\t\t\t\\\n \t\t: \""=a\""(t1),\""=d\""(t2)\t\\\n \t\t: \""a\""(a[i])\t\t\\\n \t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c0),\""+d\""(t2)\t\\\n-\t\t: \""a\""(t1),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c1),\""+r\""(c2)\t\\\n-\t\t: \""d\""(t2),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n+\tasm (\""addq %3,%0; adcq %4,%1; adcq %5,%2\""\t\\\n+\t\t: \""+r\""(c0),\""+r\""(c1),\""+r\""(c2)\t\t\\\n+\t\t: \""r\""(t1),\""r\""(t2),\""g\""(0)\t\t\\\n+\t\t: \""cc\"");\t\t\t\t\\\n \t} while (0)\n \n #define mul_add_c2(a,b,c0,c1,c2) do {\t\\\n+\tBN_ULONG t1,t2;\t\t\t\\\n \tasm (\""mulq %3\""\t\t\t\\\n \t\t: \""=a\""(t1),\""=d\""(t2)\t\\\n \t\t: \""a\""(a),\""m\""(b)\t\t\\\n \t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %0,%0; adcq %2,%1\""\t\\\n-\t\t: \""+d\""(t2),\""+r\""(c2)\t\\\n-\t\t: \""g\""(0)\t\t\\\n-\t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %0,%0; adcq %2,%1\""\t\\\n-\t\t: \""+a\""(t1),\""+d\""(t2)\t\\\n-\t\t: \""g\""(0)\t\t\\\n-\t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c0),\""+d\""(t2)\t\\\n-\t\t: \""a\""(t1),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n-\tasm (\""addq %2,%0; adcq %3,%1\""\t\\\n-\t\t: \""+r\""(c1),\""+r\""(c2)\t\\\n-\t\t: \""d\""(t2),\""g\""(0)\t\\\n-\t\t: \""cc\"");\t\t\\\n+\tasm (\""addq %3,%0; adcq %4,%1; adcq %5,%2\""\t\\\n+\t\t: \""+r\""(c0),\""+r\""(c1),\""+r\""(c2)\t\t\\\n+\t\t: \""r\""(t1),\""r\""(t2),\""g\""(0)\t\t\\\n+\t\t: \""cc\"");\t\t\t\t\\\n+\tasm (\""addq %3,%0; adcq %4,%1; adcq %5,%2\""\t\\\n+\t\t: \""+r\""(c0),\""+r\""(c1),\""+r\""(c2)\t\t\\\n+\t\t: \""r\""(t1),\""r\""(t2),\""g\""(0)\t\t\\\n+\t\t: \""cc\"");\t\t\t\t\\\n \t} while (0)\n #endif\n \n@@ -355,7 +354,6 @@ BN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)\n \n void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \t{\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -459,7 +457,6 @@ void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \n void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \t{\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -499,7 +496,6 @@ void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \n void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\n \t{\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -575,7 +571,6 @@ void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\n \n void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n \t{\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;""}<_**next**_>{""sha"": ""5027a583205b53135bc4e3e44b09a8c05b1fbbe6"", ""filename"": ""crypto/bn/bn_asm.c"", ""status"": ""modified"", ""additions"": 122, ""deletions"": 119, ""changes"": 241, ""blob_url"": ""https://github.com/openssl/openssl/blob/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/bn_asm.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/bn_asm.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/bn/bn_asm.c?ref=a7a44ba55cb4f884c6bc9ceac90072dea38e66d0"", ""patch"": ""@@ -439,129 +439,150 @@ BN_ULONG bn_sub_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b, int n)\n /* sqr_add_c2(a,i,c0,c1,c2) -- c+=2*a[i]*a[j] for three word number c=(c2,c1,c0) */\n \n #ifdef BN_LLONG\n-#define mul_add_c(a,b,c0,c1,c2) \\\n-\tt=(BN_ULLONG)a*b; \\\n-\tt1=(BN_ULONG)Lw(t); \\\n-\tt2=(BN_ULONG)Hw(t); \\\n-\tc0=(c0+t1)&BN_MASK2; if ((c0) < t1) t2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n-\n-#define mul_add_c2(a,b,c0,c1,c2) \\\n-\tt=(BN_ULLONG)a*b; \\\n-\ttt=(t+t)&BN_MASK; \\\n-\tif (tt < t) c2++; \\\n-\tt1=(BN_ULONG)Lw(tt); \\\n-\tt2=(BN_ULONG)Hw(tt); \\\n-\tc0=(c0+t1)&BN_MASK2;  \\\n-\tif ((c0 < t1) && (((++t2)&BN_MASK2) == 0)) c2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n-\n-#define sqr_add_c(a,i,c0,c1,c2) \\\n-\tt=(BN_ULLONG)a[i]*a[i]; \\\n-\tt1=(BN_ULONG)Lw(t); \\\n-\tt2=(BN_ULONG)Hw(t); \\\n-\tc0=(c0+t1)&BN_MASK2; if ((c0) < t1) t2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n+/*\n+ * Keep in mind that additions to multiplication result can not\n+ * overflow, because its high half cannot be all-ones.\n+ */\n+#define mul_add_c(a,b,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG hi;\t\t\t\t\\\n+\tBN_ULLONG t = (BN_ULLONG)(a)*(b);\t\\\n+\tt += c0;\t\t/* no carry */\t\\\n+\tc0 = (BN_ULONG)Lw(t);\t\t\t\\\n+\thi = (BN_ULONG)Hw(t);\t\t\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n+\n+#define mul_add_c2(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG hi;\t\t\t\t\\\n+\tBN_ULLONG t = (BN_ULLONG)(a)*(b);\t\\\n+\tBN_ULLONG tt = t+c0;\t/* no carry */\t\\\n+\tc0 = (BN_ULONG)Lw(tt);\t\t\t\\\n+\thi = (BN_ULONG)Hw(tt);\t\t\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\tt += c0;\t\t/* no carry */\t\\\n+\tc0 = (BN_ULONG)Lw(t);\t\t\t\\\n+\thi = (BN_ULONG)Hw(t);\t\t\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n+\n+#define sqr_add_c(a,i,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG hi;\t\t\t\t\\\n+\tBN_ULLONG t = (BN_ULLONG)a[i]*a[i];\t\\\n+\tt += c0;\t\t/* no carry */\t\\\n+\tc0 = (BN_ULONG)Lw(t);\t\t\t\\\n+\thi = (BN_ULONG)Hw(t);\t\t\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n \n #define sqr_add_c2(a,i,j,c0,c1,c2) \\\n \tmul_add_c2((a)[i],(a)[j],c0,c1,c2)\n \n #elif defined(BN_UMULT_LOHI)\n-\n-#define mul_add_c(a,b,c0,c1,c2)\t{\t\\\n-\tBN_ULONG ta=(a),tb=(b);\t\t\\\n-\tBN_UMULT_LOHI(t1,t2,ta,tb);\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n-\n-#define mul_add_c2(a,b,c0,c1,c2) {\t\\\n-\tBN_ULONG ta=(a),tb=(b),t0;\t\\\n-\tBN_UMULT_LOHI(t0,t1,ta,tb);\t\\\n-\tt2 = t1+t1; c2 += (t2<t1)?1:0;\t\\\n-\tt1 = t0+t0; t2 += (t1<t0)?1:0;\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n-\n-#define sqr_add_c(a,i,c0,c1,c2)\t{\t\\\n-\tBN_ULONG ta=(a)[i];\t\t\\\n-\tBN_UMULT_LOHI(t1,t2,ta,ta);\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n+/*\n+ * Keep in mind that additions to hi can not overflow, because\n+ * the high word of a multiplication result cannot be all-ones.\n+ */\n+#define mul_add_c(a,b,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b);\t\t\\\n+\tBN_ULONG lo, hi;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,tb);\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define mul_add_c2(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b);\t\t\\\n+\tBN_ULONG lo, hi, tt;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,tb);\t\t\\\n+\tc0 += lo; tt = hi+((c0<lo)?1:0);\t\\\n+\tc1 += tt; c2 += (c1<tt)?1:0;\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define sqr_add_c(a,i,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a)[i];\t\t\t\\\n+\tBN_ULONG lo, hi;\t\t\t\\\n+\tBN_UMULT_LOHI(lo,hi,ta,ta);\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n \n #define sqr_add_c2(a,i,j,c0,c1,c2)\t\\\n \tmul_add_c2((a)[i],(a)[j],c0,c1,c2)\n \n #elif defined(BN_UMULT_HIGH)\n-\n-#define mul_add_c(a,b,c0,c1,c2)\t{\t\\\n-\tBN_ULONG ta=(a),tb=(b);\t\t\\\n-\tt1 = ta * tb;\t\t\t\\\n-\tt2 = BN_UMULT_HIGH(ta,tb);\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n-\n-#define mul_add_c2(a,b,c0,c1,c2) {\t\\\n-\tBN_ULONG ta=(a),tb=(b),t0;\t\\\n-\tt1 = BN_UMULT_HIGH(ta,tb);\t\\\n-\tt0 = ta * tb;\t\t\t\\\n-\tt2 = t1+t1; c2 += (t2<t1)?1:0;\t\\\n-\tt1 = t0+t0; t2 += (t1<t0)?1:0;\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n-\n-#define sqr_add_c(a,i,c0,c1,c2)\t{\t\\\n-\tBN_ULONG ta=(a)[i];\t\t\\\n-\tt1 = ta * ta;\t\t\t\\\n-\tt2 = BN_UMULT_HIGH(ta,ta);\t\\\n-\tc0 += t1; t2 += (c0<t1)?1:0;\t\\\n-\tc1 += t2; c2 += (c1<t2)?1:0;\t\\\n-\t}\n+/*\n+ * Keep in mind that additions to hi can not overflow, because\n+ * the high word of a multiplication result cannot be all-ones.\n+ */\n+#define mul_add_c(a,b,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b);\t\t\\\n+\tBN_ULONG lo = ta * tb;\t\t\t\\\n+\tBN_ULONG hi = BN_UMULT_HIGH(ta,tb);\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define mul_add_c2(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG ta = (a), tb = (b), tt;\t\\\n+\tBN_ULONG lo = ta * tb;\t\t\t\\\n+\tBN_ULONG hi = BN_UMULT_HIGH(ta,tb);\t\\\n+\tc0 += lo; tt = hi + ((c0<lo)?1:0);\t\\\n+\tc1 += tt; c2 += (c1<tt)?1:0;\t\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n+\n+#define sqr_add_c(a,i,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG ta = (a)[i];\t\t\t\\\n+\tBN_ULONG lo = ta * ta;\t\t\t\\\n+\tBN_ULONG hi = BN_UMULT_HIGH(ta,ta);\t\\\n+\tc0 += lo; hi += (c0<lo)?1:0;\t\t\\\n+\tc1 += hi; c2 += (c1<hi)?1:0;\t\t\\\n+\t} while(0)\n \n #define sqr_add_c2(a,i,j,c0,c1,c2)\t\\\n \tmul_add_c2((a)[i],(a)[j],c0,c1,c2)\n \n #else /* !BN_LLONG */\n-#define mul_add_c(a,b,c0,c1,c2) \\\n-\tt1=LBITS(a); t2=HBITS(a); \\\n-\tbl=LBITS(b); bh=HBITS(b); \\\n-\tmul64(t1,t2,bl,bh); \\\n-\tc0=(c0+t1)&BN_MASK2; if ((c0) < t1) t2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n-\n-#define mul_add_c2(a,b,c0,c1,c2) \\\n-\tt1=LBITS(a); t2=HBITS(a); \\\n-\tbl=LBITS(b); bh=HBITS(b); \\\n-\tmul64(t1,t2,bl,bh); \\\n-\tif (t2 & BN_TBIT) c2++; \\\n-\tt2=(t2+t2)&BN_MASK2; \\\n-\tif (t1 & BN_TBIT) t2++; \\\n-\tt1=(t1+t1)&BN_MASK2; \\\n-\tc0=(c0+t1)&BN_MASK2;  \\\n-\tif ((c0 < t1) && (((++t2)&BN_MASK2) == 0)) c2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n-\n-#define sqr_add_c(a,i,c0,c1,c2) \\\n-\tsqr64(t1,t2,(a)[i]); \\\n-\tc0=(c0+t1)&BN_MASK2; if ((c0) < t1) t2++; \\\n-\tc1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;\n+/*\n+ * Keep in mind that additions to hi can not overflow, because\n+ * the high word of a multiplication result cannot be all-ones.\n+ */\n+#define mul_add_c(a,b,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG lo = LBITS(a), hi = HBITS(a);\t\\\n+\tBN_ULONG bl = LBITS(b), bh = HBITS(b);\t\\\n+\tmul64(lo,hi,bl,bh);\t\t\t\\\n+\tc0 = (c0+lo)&BN_MASK2; if (c0<lo) hi++;\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n+\n+#define mul_add_c2(a,b,c0,c1,c2)\tdo {\t\\\n+\tBN_ULONG tt;\t\t\t\t\\\n+\tBN_ULONG lo = LBITS(a), hi = HBITS(a);\t\\\n+\tBN_ULONG bl = LBITS(b), bh = HBITS(b);\t\\\n+\tmul64(lo,hi,bl,bh);\t\t\t\\\n+\ttt = hi;\t\t\t\t\\\n+\tc0 = (c0+lo)&BN_MASK2; if (c0<lo) tt++;\t\\\n+\tc1 = (c1+tt)&BN_MASK2; if (c1<tt) c2++;\t\\\n+\tc0 = (c0+lo)&BN_MASK2; if (c0<lo) hi++;\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n+\n+#define sqr_add_c(a,i,c0,c1,c2)\t\tdo {\t\\\n+\tBN_ULONG lo, hi;\t\t\t\\\n+\tsqr64(lo,hi,(a)[i]);\t\t\t\\\n+\tc0 = (c0+lo)&BN_MASK2; if (c0<lo) hi++;\t\\\n+\tc1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;\t\\\n+\t} while(0)\n \n #define sqr_add_c2(a,i,j,c0,c1,c2) \\\n \tmul_add_c2((a)[i],(a)[j],c0,c1,c2)\n #endif /* !BN_LLONG */\n \n void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \t{\n-#ifdef BN_LLONG\n-\tBN_ULLONG t;\n-#else\n-\tBN_ULONG bl,bh;\n-#endif\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -665,12 +686,6 @@ void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \n void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \t{\n-#ifdef BN_LLONG\n-\tBN_ULLONG t;\n-#else\n-\tBN_ULONG bl,bh;\n-#endif\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -710,12 +725,6 @@ void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \n void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\n \t{\n-#ifdef BN_LLONG\n-\tBN_ULLONG t,tt;\n-#else\n-\tBN_ULONG bl,bh;\n-#endif\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n@@ -791,12 +800,6 @@ void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\n \n void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n \t{\n-#ifdef BN_LLONG\n-\tBN_ULLONG t,tt;\n-#else\n-\tBN_ULONG bl,bh;\n-#endif\n-\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;""}<_**next**_>{""sha"": ""869ae05a901d51ee69ad4d181337ba1d8c34e7a4"", ""filename"": ""crypto/bn/bntest.c"", ""status"": ""modified"", ""additions"": 78, ""deletions"": 24, ""changes"": 102, ""blob_url"": ""https://github.com/openssl/openssl/blob/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/bntest.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0/crypto/bn/bntest.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/bn/bntest.c?ref=a7a44ba55cb4f884c6bc9ceac90072dea38e66d0"", ""patch"": ""@@ -689,44 +689,98 @@ int test_mul(BIO *bp)\n \n int test_sqr(BIO *bp, BN_CTX *ctx)\n \t{\n-\tBIGNUM a,c,d,e;\n-\tint i;\n+\tBIGNUM *a,*c,*d,*e;\n+\tint i, ret = 0;\n \n-\tBN_init(&a);\n-\tBN_init(&c);\n-\tBN_init(&d);\n-\tBN_init(&e);\n+\ta = BN_new();\n+\tc = BN_new();\n+\td = BN_new();\n+\te = BN_new();\n+\tif (a == NULL || c == NULL || d == NULL || e == NULL)\n+\t\t{\n+\t\tgoto err;\n+\t\t}\n \n \tfor (i=0; i<num0; i++)\n \t\t{\n-\t\tBN_bntest_rand(&a,40+i*10,0,0);\n-\t\ta.neg=rand_neg();\n-\t\tBN_sqr(&c,&a,ctx);\n+\t\tBN_bntest_rand(a,40+i*10,0,0);\n+\t\ta->neg=rand_neg();\n+\t\tBN_sqr(c,a,ctx);\n \t\tif (bp != NULL)\n \t\t\t{\n \t\t\tif (!results)\n \t\t\t\t{\n-\t\t\t\tBN_print(bp,&a);\n+\t\t\t\tBN_print(bp,a);\n \t\t\t\tBIO_puts(bp,\"" * \"");\n-\t\t\t\tBN_print(bp,&a);\n+\t\t\t\tBN_print(bp,a);\n \t\t\t\tBIO_puts(bp,\"" - \"");\n \t\t\t\t}\n-\t\t\tBN_print(bp,&c);\n+\t\t\tBN_print(bp,c);\n \t\t\tBIO_puts(bp,\""\\n\"");\n \t\t\t}\n-\t\tBN_div(&d,&e,&c,&a,ctx);\n-\t\tBN_sub(&d,&d,&a);\n-\t\tif(!BN_is_zero(&d) || !BN_is_zero(&e))\n-\t\t    {\n-\t\t    fprintf(stderr,\""Square test failed!\\n\"");\n-\t\t    return 0;\n-\t\t    }\n+\t\tBN_div(d,e,c,a,ctx);\n+\t\tBN_sub(d,d,a);\n+\t\tif(!BN_is_zero(d) || !BN_is_zero(e))\n+\t\t\t{\n+\t\t\tfprintf(stderr,\""Square test failed!\\n\"");\n+\t\t\tgoto err;\n+\t\t\t}\n \t\t}\n-\tBN_free(&a);\n-\tBN_free(&c);\n-\tBN_free(&d);\n-\tBN_free(&e);\n-\treturn(1);\n+\n+\t/* Regression test for a BN_sqr overflow bug. */\n+\tBN_hex2bn(&a,\n+\t\t\""80000000000000008000000000000001FFFFFFFFFFFFFFFE0000000000000000\"");\n+\tBN_sqr(c, a, ctx);\n+\tif (bp != NULL)\n+\t\t{\n+\t\tif (!results)\n+\t\t\t{\n+\t\t\tBN_print(bp,a);\n+\t\t\tBIO_puts(bp,\"" * \"");\n+\t\t\tBN_print(bp,a);\n+\t\t\tBIO_puts(bp,\"" - \"");\n+\t\t\t}\n+\t\tBN_print(bp,c);\n+\t\tBIO_puts(bp,\""\\n\"");\n+\t\t}\n+\tBN_mul(d, a, a, ctx);\n+\tif (BN_cmp(c, d))\n+\t\t{\n+\t\tfprintf(stderr, \""Square test failed: BN_sqr and BN_mul produce \""\n+\t\t\t\""different results!\\n\"");\n+\t\tgoto err;\n+\t\t}\n+\n+\t/* Regression test for a BN_sqr overflow bug. */\n+\tBN_hex2bn(&a,\n+\t\t\""80000000000000000000000080000001FFFFFFFE000000000000000000000000\"");\n+\tBN_sqr(c, a, ctx);\n+\tif (bp != NULL)\n+\t\t{\n+\t\tif (!results)\n+\t\t\t{\n+\t\t\tBN_print(bp,a);\n+\t\t\tBIO_puts(bp,\"" * \"");\n+\t\t\tBN_print(bp,a);\n+\t\t\tBIO_puts(bp,\"" - \"");\n+\t\t\t}\n+\t\tBN_print(bp,c);\n+\t\tBIO_puts(bp,\""\\n\"");\n+\t\t}\n+\tBN_mul(d, a, a, ctx);\n+\tif (BN_cmp(c, d))\n+\t\t{\n+\t\tfprintf(stderr, \""Square test failed: BN_sqr and BN_mul produce \""\n+\t\t\t\""different results!\\n\"");\n+\t\tgoto err;\n+\t\t}\n+\tret = 1;\n+err:\n+\tif (a != NULL) BN_free(a);\n+\tif (c != NULL) BN_free(c);\n+\tif (d != NULL) BN_free(d);\n+\tif (e != NULL) BN_free(e);\n+\treturn ret;\n \t}\n \n int test_mont(BIO *bp, BN_CTX *ctx)""}"," int test_sqr(BIO *bp, BN_CTX *ctx)
 	{
	BIGNUM *a,*c,*d,*e;
	int i, ret = 0;
 
	a = BN_new();
	c = BN_new();
	d = BN_new();
	e = BN_new();
	if (a == NULL || c == NULL || d == NULL || e == NULL)
		{
		goto err;
		}
 
 	for (i=0; i<num0; i++)
 		{
		BN_bntest_rand(a,40+i*10,0,0);
		a->neg=rand_neg();
		BN_sqr(c,a,ctx);
 		if (bp != NULL)
 			{
 			if (!results)
 				{
				BN_print(bp,a);
 				BIO_puts(bp,"" * "");
				BN_print(bp,a);
 				BIO_puts(bp,"" - "");
 				}
			BN_print(bp,c);
 			BIO_puts(bp,""\n"");
 			}
		BN_div(d,e,c,a,ctx);
		BN_sub(d,d,a);
		if(!BN_is_zero(d) || !BN_is_zero(e))
			{
			fprintf(stderr,""Square test failed!\n"");
			goto err;
			}
 		}

	/* Regression test for a BN_sqr overflow bug. */
	BN_hex2bn(&a,
		""80000000000000008000000000000001FFFFFFFFFFFFFFFE0000000000000000"");
	BN_sqr(c, a, ctx);
	if (bp != NULL)
		{
		if (!results)
			{
			BN_print(bp,a);
			BIO_puts(bp,"" * "");
			BN_print(bp,a);
			BIO_puts(bp,"" - "");
			}
		BN_print(bp,c);
		BIO_puts(bp,""\n"");
		}
	BN_mul(d, a, a, ctx);
	if (BN_cmp(c, d))
		{
		fprintf(stderr, ""Square test failed: BN_sqr and BN_mul produce ""
			""different results!\n"");
		goto err;
		}

	/* Regression test for a BN_sqr overflow bug. */
	BN_hex2bn(&a,
		""80000000000000000000000080000001FFFFFFFE000000000000000000000000"");
	BN_sqr(c, a, ctx);
	if (bp != NULL)
		{
		if (!results)
			{
			BN_print(bp,a);
			BIO_puts(bp,"" * "");
			BN_print(bp,a);
			BIO_puts(bp,"" - "");
			}
		BN_print(bp,c);
		BIO_puts(bp,""\n"");
		}
	BN_mul(d, a, a, ctx);
	if (BN_cmp(c, d))
		{
		fprintf(stderr, ""Square test failed: BN_sqr and BN_mul produce ""
			""different results!\n"");
		goto err;
		}
	ret = 1;
err:
	if (a != NULL) BN_free(a);
	if (c != NULL) BN_free(c);
	if (d != NULL) BN_free(d);
	if (e != NULL) BN_free(e);
	return ret;
 	}
"," int test_sqr(BIO *bp, BN_CTX *ctx)
 	{
	BIGNUM a,c,d,e;
	int i;
 
	BN_init(&a);
	BN_init(&c);
	BN_init(&d);
	BN_init(&e);
 
 	for (i=0; i<num0; i++)
 		{
		BN_bntest_rand(&a,40+i*10,0,0);
		a.neg=rand_neg();
		BN_sqr(&c,&a,ctx);
 		if (bp != NULL)
 			{
 			if (!results)
 				{
				BN_print(bp,&a);
 				BIO_puts(bp,"" * "");
				BN_print(bp,&a);
 				BIO_puts(bp,"" - "");
 				}
			BN_print(bp,&c);
 			BIO_puts(bp,""\n"");
 			}
		BN_div(&d,&e,&c,&a,ctx);
		BN_sub(&d,&d,&a);
		if(!BN_is_zero(&d) || !BN_is_zero(&e))
		    {
		    fprintf(stderr,""Square test failed!\n"");
		    return 0;
		    }
 		}
	BN_free(&a);
	BN_free(&c);
	BN_free(&d);
	BN_free(&e);
	return(1);
 	}
",C,"	BIGNUM *a,*c,*d,*e;
	int i, ret = 0;
	a = BN_new();
	c = BN_new();
	d = BN_new();
	e = BN_new();
	if (a == NULL || c == NULL || d == NULL || e == NULL)
		{
		goto err;
		}
		BN_bntest_rand(a,40+i*10,0,0);
		a->neg=rand_neg();
		BN_sqr(c,a,ctx);
				BN_print(bp,a);
				BN_print(bp,a);
			BN_print(bp,c);
		BN_div(d,e,c,a,ctx);
		BN_sub(d,d,a);
		if(!BN_is_zero(d) || !BN_is_zero(e))
			{
			fprintf(stderr,""Square test failed!\n"");
			goto err;
			}

	/* Regression test for a BN_sqr overflow bug. */
	BN_hex2bn(&a,
		""80000000000000008000000000000001FFFFFFFFFFFFFFFE0000000000000000"");
	BN_sqr(c, a, ctx);
	if (bp != NULL)
		{
		if (!results)
			{
			BN_print(bp,a);
			BIO_puts(bp,"" * "");
			BN_print(bp,a);
			BIO_puts(bp,"" - "");
			}
		BN_print(bp,c);
		BIO_puts(bp,""\n"");
		}
	BN_mul(d, a, a, ctx);
	if (BN_cmp(c, d))
		{
		fprintf(stderr, ""Square test failed: BN_sqr and BN_mul produce ""
			""different results!\n"");
		goto err;
		}

	/* Regression test for a BN_sqr overflow bug. */
	BN_hex2bn(&a,
		""80000000000000000000000080000001FFFFFFFE000000000000000000000000"");
	BN_sqr(c, a, ctx);
	if (bp != NULL)
		{
		if (!results)
			{
			BN_print(bp,a);
			BIO_puts(bp,"" * "");
			BN_print(bp,a);
			BIO_puts(bp,"" - "");
			}
		BN_print(bp,c);
		BIO_puts(bp,""\n"");
		}
	BN_mul(d, a, a, ctx);
	if (BN_cmp(c, d))
		{
		fprintf(stderr, ""Square test failed: BN_sqr and BN_mul produce ""
			""different results!\n"");
		goto err;
		}
	ret = 1;
err:
	if (a != NULL) BN_free(a);
	if (c != NULL) BN_free(c);
	if (d != NULL) BN_free(d);
	if (e != NULL) BN_free(e);
	return ret;
","	BIGNUM a,c,d,e;
	int i;
	BN_init(&a);
	BN_init(&c);
	BN_init(&d);
	BN_init(&e);
		BN_bntest_rand(&a,40+i*10,0,0);
		a.neg=rand_neg();
		BN_sqr(&c,&a,ctx);
				BN_print(bp,&a);
				BN_print(bp,&a);
			BN_print(bp,&c);
		BN_div(&d,&e,&c,&a,ctx);
		BN_sub(&d,&d,&a);
		if(!BN_is_zero(&d) || !BN_is_zero(&e))
		    {
		    fprintf(stderr,""Square test failed!\n"");
		    return 0;
		    }
	BN_free(&a);
	BN_free(&c);
	BN_free(&d);
	BN_free(&e);
	return(1);
",,"@@ -689,44 +689,98 @@ int test_mul(BIO *bp)
 
 int test_sqr(BIO *bp, BN_CTX *ctx)
 	{
-	BIGNUM a,c,d,e;
-	int i;
+	BIGNUM *a,*c,*d,*e;
+	int i, ret = 0;
 
-	BN_init(&a);
-	BN_init(&c);
-	BN_init(&d);
-	BN_init(&e);
+	a = BN_new();
+	c = BN_new();
+	d = BN_new();
+	e = BN_new();
+	if (a == NULL || c == NULL || d == NULL || e == NULL)
+		{
+		goto err;
+		}
 
 	for (i=0; i<num0; i++)
 		{
-		BN_bntest_rand(&a,40+i*10,0,0);
-		a.neg=rand_neg();
-		BN_sqr(&c,&a,ctx);
+		BN_bntest_rand(a,40+i*10,0,0);
+		a->neg=rand_neg();
+		BN_sqr(c,a,ctx);
 		if (bp != NULL)
 			{
 			if (!results)
 				{
-				BN_print(bp,&a);
+				BN_print(bp,a);
 				BIO_puts(bp,"" * "");
-				BN_print(bp,&a);
+				BN_print(bp,a);
 				BIO_puts(bp,"" - "");
 				}
-			BN_print(bp,&c);
+			BN_print(bp,c);
 			BIO_puts(bp,""\n"");
 			}
-		BN_div(&d,&e,&c,&a,ctx);
-		BN_sub(&d,&d,&a);
-		if(!BN_is_zero(&d) || !BN_is_zero(&e))
-		    {
-		    fprintf(stderr,""Square test failed!\n"");
-		    return 0;
-		    }
+		BN_div(d,e,c,a,ctx);
+		BN_sub(d,d,a);
+		if(!BN_is_zero(d) || !BN_is_zero(e))
+			{
+			fprintf(stderr,""Square test failed!\n"");
+			goto err;
+			}
 		}
-	BN_free(&a);
-	BN_free(&c);
-	BN_free(&d);
-	BN_free(&e);
-	return(1);
+
+	/* Regression test for a BN_sqr overflow bug. */
+	BN_hex2bn(&a,
+		""80000000000000008000000000000001FFFFFFFFFFFFFFFE0000000000000000"");
+	BN_sqr(c, a, ctx);
+	if (bp != NULL)
+		{
+		if (!results)
+			{
+			BN_print(bp,a);
+			BIO_puts(bp,"" * "");
+			BN_print(bp,a);
+			BIO_puts(bp,"" - "");
+			}
+		BN_print(bp,c);
+		BIO_puts(bp,""\n"");
+		}
+	BN_mul(d, a, a, ctx);
+	if (BN_cmp(c, d))
+		{
+		fprintf(stderr, ""Square test failed: BN_sqr and BN_mul produce ""
+			""different results!\n"");
+		goto err;
+		}
+
+	/* Regression test for a BN_sqr overflow bug. */
+	BN_hex2bn(&a,
+		""80000000000000000000000080000001FFFFFFFE000000000000000000000000"");
+	BN_sqr(c, a, ctx);
+	if (bp != NULL)
+		{
+		if (!results)
+			{
+			BN_print(bp,a);
+			BIO_puts(bp,"" * "");
+			BN_print(bp,a);
+			BIO_puts(bp,"" - "");
+			}
+		BN_print(bp,c);
+		BIO_puts(bp,""\n"");
+		}
+	BN_mul(d, a, a, ctx);
+	if (BN_cmp(c, d))
+		{
+		fprintf(stderr, ""Square test failed: BN_sqr and BN_mul produce ""
+			""different results!\n"");
+		goto err;
+		}
+	ret = 1;
+err:
+	if (a != NULL) BN_free(a);
+	if (c != NULL) BN_free(c);
+	if (d != NULL) BN_free(d);
+	if (e != NULL) BN_free(e);
+	return ret;
 	}
 
 int test_mont(BIO *bp, BN_CTX *ctx)",openssl,a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,248385c606620b29ecc96ca9d3603463f879652b,1," int test_sqr(BIO *bp, BN_CTX *ctx)
 	{
//flaw_line_below:
	BIGNUM a,c,d,e;
//flaw_line_below:
	int i;
//fix_flaw_line_below:
//	BIGNUM *a,*c,*d,*e;
//fix_flaw_line_below:
//	int i, ret = 0;
 
//flaw_line_below:
	BN_init(&a);
//flaw_line_below:
	BN_init(&c);
//flaw_line_below:
	BN_init(&d);
//flaw_line_below:
	BN_init(&e);
//fix_flaw_line_below:
//	a = BN_new();
//fix_flaw_line_below:
//	c = BN_new();
//fix_flaw_line_below:
//	d = BN_new();
//fix_flaw_line_below:
//	e = BN_new();
//fix_flaw_line_below:
//	if (a == NULL || c == NULL || d == NULL || e == NULL)
//fix_flaw_line_below:
//		{
//fix_flaw_line_below:
//		goto err;
//fix_flaw_line_below:
//		}
 
 	for (i=0; i<num0; i++)
 		{
//flaw_line_below:
		BN_bntest_rand(&a,40+i*10,0,0);
//flaw_line_below:
		a.neg=rand_neg();
//flaw_line_below:
		BN_sqr(&c,&a,ctx);
//fix_flaw_line_below:
//		BN_bntest_rand(a,40+i*10,0,0);
//fix_flaw_line_below:
//		a->neg=rand_neg();
//fix_flaw_line_below:
//		BN_sqr(c,a,ctx);
 		if (bp != NULL)
 			{
 			if (!results)
 				{
//flaw_line_below:
				BN_print(bp,&a);
//fix_flaw_line_below:
//				BN_print(bp,a);
 				BIO_puts(bp,"" * "");
//flaw_line_below:
				BN_print(bp,&a);
//fix_flaw_line_below:
//				BN_print(bp,a);
 				BIO_puts(bp,"" - "");
 				}
//flaw_line_below:
			BN_print(bp,&c);
//fix_flaw_line_below:
//			BN_print(bp,c);
 			BIO_puts(bp,""\n"");
 			}
//flaw_line_below:
		BN_div(&d,&e,&c,&a,ctx);
//flaw_line_below:
		BN_sub(&d,&d,&a);
//flaw_line_below:
		if(!BN_is_zero(&d) || !BN_is_zero(&e))
//flaw_line_below:
		    {
//flaw_line_below:
		    fprintf(stderr,""Square test failed!\n"");
//flaw_line_below:
		    return 0;
//flaw_line_below:
		    }
//fix_flaw_line_below:
//		BN_div(d,e,c,a,ctx);
//fix_flaw_line_below:
//		BN_sub(d,d,a);
//fix_flaw_line_below:
//		if(!BN_is_zero(d) || !BN_is_zero(e))
//fix_flaw_line_below:
//			{
//fix_flaw_line_below:
//			fprintf(stderr,""Square test failed!\n"");
//fix_flaw_line_below:
//			goto err;
//fix_flaw_line_below:
//			}
 		}
//flaw_line_below:
	BN_free(&a);
//flaw_line_below:
	BN_free(&c);
//flaw_line_below:
	BN_free(&d);
//flaw_line_below:
	BN_free(&e);
//flaw_line_below:
	return(1);
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	/* Regression test for a BN_sqr overflow bug. */
//fix_flaw_line_below:
//	BN_hex2bn(&a,
//fix_flaw_line_below:
//		""80000000000000008000000000000001FFFFFFFFFFFFFFFE0000000000000000"");
//fix_flaw_line_below:
//	BN_sqr(c, a, ctx);
//fix_flaw_line_below:
//	if (bp != NULL)
//fix_flaw_line_below:
//		{
//fix_flaw_line_below:
//		if (!results)
//fix_flaw_line_below:
//			{
//fix_flaw_line_below:
//			BN_print(bp,a);
//fix_flaw_line_below:
//			BIO_puts(bp,"" * "");
//fix_flaw_line_below:
//			BN_print(bp,a);
//fix_flaw_line_below:
//			BIO_puts(bp,"" - "");
//fix_flaw_line_below:
//			}
//fix_flaw_line_below:
//		BN_print(bp,c);
//fix_flaw_line_below:
//		BIO_puts(bp,""\n"");
//fix_flaw_line_below:
//		}
//fix_flaw_line_below:
//	BN_mul(d, a, a, ctx);
//fix_flaw_line_below:
//	if (BN_cmp(c, d))
//fix_flaw_line_below:
//		{
//fix_flaw_line_below:
//		fprintf(stderr, ""Square test failed: BN_sqr and BN_mul produce ""
//fix_flaw_line_below:
//			""different results!\n"");
//fix_flaw_line_below:
//		goto err;
//fix_flaw_line_below:
//		}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	/* Regression test for a BN_sqr overflow bug. */
//fix_flaw_line_below:
//	BN_hex2bn(&a,
//fix_flaw_line_below:
//		""80000000000000000000000080000001FFFFFFFE000000000000000000000000"");
//fix_flaw_line_below:
//	BN_sqr(c, a, ctx);
//fix_flaw_line_below:
//	if (bp != NULL)
//fix_flaw_line_below:
//		{
//fix_flaw_line_below:
//		if (!results)
//fix_flaw_line_below:
//			{
//fix_flaw_line_below:
//			BN_print(bp,a);
//fix_flaw_line_below:
//			BIO_puts(bp,"" * "");
//fix_flaw_line_below:
//			BN_print(bp,a);
//fix_flaw_line_below:
//			BIO_puts(bp,"" - "");
//fix_flaw_line_below:
//			}
//fix_flaw_line_below:
//		BN_print(bp,c);
//fix_flaw_line_below:
//		BIO_puts(bp,""\n"");
//fix_flaw_line_below:
//		}
//fix_flaw_line_below:
//	BN_mul(d, a, a, ctx);
//fix_flaw_line_below:
//	if (BN_cmp(c, d))
//fix_flaw_line_below:
//		{
//fix_flaw_line_below:
//		fprintf(stderr, ""Square test failed: BN_sqr and BN_mul produce ""
//fix_flaw_line_below:
//			""different results!\n"");
//fix_flaw_line_below:
//		goto err;
//fix_flaw_line_below:
//		}
//fix_flaw_line_below:
//	ret = 1;
//fix_flaw_line_below:
//err:
//fix_flaw_line_below:
//	if (a != NULL) BN_free(a);
//fix_flaw_line_below:
//	if (c != NULL) BN_free(c);
//fix_flaw_line_below:
//	if (d != NULL) BN_free(d);
//fix_flaw_line_below:
//	if (e != NULL) BN_free(e);
//fix_flaw_line_below:
//	return ret;
 	}
"
2878,180614,,Local,Not required,Complete,CVE-2016-2053,https://www.cvedetails.com/cve/CVE-2016-2053/,CWE-310,Medium,,,,2016-05-02,4.7,"The asn1_ber_decoder function in lib/asn1_decoder.c in the Linux kernel before 4.3 allows attackers to cause a denial of service (panic) via an ASN.1 BER file that lacks a public key, leading to mishandling by the public_key_verify_signature function in crypto/asymmetric_keys/public_key.c.",2018-08-30,DoS ,2,https://github.com/torvalds/linux/commit/0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f,0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f,"ASN.1: Fix non-match detection failure on data overrun

If the ASN.1 decoder is asked to parse a sequence of objects, non-optional
matches get skipped if there's no more data to be had rather than a
data-overrun error being reported.

This is due to the code segment that decides whether to skip optional
matches (ie. matches that could get ignored because an element is marked
OPTIONAL in the grammar) due to a lack of data also skips non-optional
elements if the data pointer has reached the end of the buffer.

This can be tested with the data decoder for the new RSA akcipher algorithm
that takes three non-optional integers.  Currently, it skips the last
integer if there is insufficient data.

Without the fix, #defining DEBUG in asn1_decoder.c will show something
like:

	next_op: pc=0/13 dp=0/270 C=0 J=0
	- match? 30 30 00
	- TAG: 30 266 CONS
	next_op: pc=2/13 dp=4/270 C=1 J=0
	- match? 02 02 00
	- TAG: 02 257
	- LEAF: 257
	next_op: pc=5/13 dp=265/270 C=1 J=0
	- match? 02 02 00
	- TAG: 02 3
	- LEAF: 3
	next_op: pc=8/13 dp=270/270 C=1 J=0
	next_op: pc=11/13 dp=270/270 C=1 J=0
	- end cons t=4 dp=270 l=270/270

The next_op line for pc=8/13 should be followed by a match line.

This is not exploitable for X.509 certificates by means of shortening the
message and fixing up the ASN.1 CONS tags because:

 (1) The relevant records being built up are cleared before use.

 (2) If the message is shortened sufficiently to remove the public key, the
     ASN.1 parse of the RSA key will fail quickly due to a lack of data.

 (3) Extracted signature data is either turned into MPIs (which cope with a
     0 length) or is simpler integers specifying algoritms and suchlike
     (which can validly be 0); and

 (4) The AKID and SKID extensions are optional and their removal is handled
     without risking passing a NULL to asymmetric_key_generate_id().

 (5) If the certificate is truncated sufficiently to remove the subject,
     issuer or serialNumber then the ASN.1 decoder will fail with a 'Cons
     stack underflow' return.

This is not exploitable for PKCS#7 messages by means of removal of elements
from such a message from the tail end of a sequence:

 (1) Any shortened X.509 certs embedded in the PKCS#7 message are survivable
     as detailed above.

 (2) The message digest content isn't used if it shows a NULL pointer,
     similarly, the authattrs aren't used if that shows a NULL pointer.

 (3) A missing signature results in a NULL MPI - which the MPI routines deal
     with.

 (4) If data is NULL, it is expected that the message has detached content and
     that is handled appropriately.

 (5) If the serialNumber is excised, the unconditional action associated
     with it will pick up the containing SEQUENCE instead, so no NULL
     pointer will be seen here.

     If both the issuer and the serialNumber are excised, the ASN.1 decode
     will fail with an 'Unexpected tag' return.

     In either case, there's no way to get to asymmetric_key_generate_id()
     with a NULL pointer.

 (6) Other fields are decoded to simple integers.  Shortening the message
     to omit an algorithm ID field will cause checks on this to fail early
     in the verification process.


This can also be tested by snipping objects off of the end of the ASN.1 stream
such that mandatory tags are removed - or even from the end of internal
SEQUENCEs.  If any mandatory tag is missing, the error EBADMSG *should* be
produced.  Without this patch ERANGE or ENOPKG might be produced or the parse
may apparently succeed, perhaps with ENOKEY or EKEYREJECTED being produced
later, depending on what gets snipped.

Just snipping off the final BIT_STRING or OCTET_STRING from either sample
should be a start since both are mandatory and neither will cause an EBADMSG
without the patches

Reported-by: Marcel Holtmann <marcel@holtmann.org>
Signed-off-by: David Howells <dhowells@redhat.com>
Tested-by: Marcel Holtmann <marcel@holtmann.org>
Reviewed-by: David Woodhouse <David.Woodhouse@intel.com>",3,lib/asn1_decoder.c,"{""sha"": ""3f74dd3e29107fa407df14cc8a8b0cf05087e9eb"", ""filename"": ""lib/asn1_decoder.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 3, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f/lib/asn1_decoder.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f/lib/asn1_decoder.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/lib/asn1_decoder.c?ref=0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f"", ""patch"": ""@@ -210,9 +210,8 @@ int asn1_ber_decoder(const struct asn1_decoder *decoder,\n \t\tunsigned char tmp;\n \n \t\t/* Skip conditional matches if possible */\n-\t\tif ((op & ASN1_OP_MATCH__COND &&\n-\t\t     flags & FLAG_MATCHED) ||\n-\t\t    dp == datalen) {\n+\t\tif ((op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED) ||\n+\t\t    (op & ASN1_OP_MATCH__SKIP && dp == datalen)) {\n \t\t\tflags &= ~FLAG_LAST_MATCHED;\n \t\t\tpc += asn1_op_lengths[op];\n \t\t\tgoto next_op;""}","int asn1_ber_decoder(const struct asn1_decoder *decoder,
		     void *context,
		     const unsigned char *data,
		     size_t datalen)
{
	const unsigned char *machine = decoder->machine;
	const asn1_action_t *actions = decoder->actions;
	size_t machlen = decoder->machlen;
	enum asn1_opcode op;
	unsigned char tag = 0, csp = 0, jsp = 0, optag = 0, hdr = 0;
	const char *errmsg;
	size_t pc = 0, dp = 0, tdp = 0, len = 0;
	int ret;

	unsigned char flags = 0;
#define FLAG_INDEFINITE_LENGTH	0x01
#define FLAG_MATCHED		0x02
#define FLAG_LAST_MATCHED	0x04 /* Last tag matched */
#define FLAG_CONS		0x20 /* Corresponds to CONS bit in the opcode tag
				      * - ie. whether or not we are going to parse
				      *   a compound type.
				      */

#define NR_CONS_STACK 10
	unsigned short cons_dp_stack[NR_CONS_STACK];
	unsigned short cons_datalen_stack[NR_CONS_STACK];
	unsigned char cons_hdrlen_stack[NR_CONS_STACK];
#define NR_JUMP_STACK 10
	unsigned char jump_stack[NR_JUMP_STACK];

	if (datalen > 65535)
		return -EMSGSIZE;

next_op:
	pr_debug(""next_op: pc=\e[32m%zu\e[m/%zu dp=\e[33m%zu\e[m/%zu C=%d J=%d\n"",
		 pc, machlen, dp, datalen, csp, jsp);
	if (unlikely(pc >= machlen))
		goto machine_overrun_error;
	op = machine[pc];
	if (unlikely(pc + asn1_op_lengths[op] > machlen))
		goto machine_overrun_error;

	/* If this command is meant to match a tag, then do that before
	 * evaluating the command.
	 */
	if (op <= ASN1_OP__MATCHES_TAG) {
 		unsigned char tmp;
 
 		/* Skip conditional matches if possible */
		if ((op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED) ||
		    (op & ASN1_OP_MATCH__SKIP && dp == datalen)) {
 			flags &= ~FLAG_LAST_MATCHED;
 			pc += asn1_op_lengths[op];
 			goto next_op;
		}

		flags = 0;
		hdr = 2;

		/* Extract a tag from the data */
		if (unlikely(dp >= datalen - 1))
			goto data_overrun_error;
		tag = data[dp++];
		if (unlikely((tag & 0x1f) == ASN1_LONG_TAG))
			goto long_tag_not_supported;

		if (op & ASN1_OP_MATCH__ANY) {
			pr_debug(""- any %02x\n"", tag);
		} else {
			/* Extract the tag from the machine
			 * - Either CONS or PRIM are permitted in the data if
			 *   CONS is not set in the op stream, otherwise CONS
			 *   is mandatory.
			 */
			optag = machine[pc + 1];
			flags |= optag & FLAG_CONS;

			/* Determine whether the tag matched */
			tmp = optag ^ tag;
			tmp &= ~(optag & ASN1_CONS_BIT);
			pr_debug(""- match? %02x %02x %02x\n"", tag, optag, tmp);
			if (tmp != 0) {
				/* All odd-numbered tags are MATCH_OR_SKIP. */
				if (op & ASN1_OP_MATCH__SKIP) {
					pc += asn1_op_lengths[op];
					dp--;
					goto next_op;
				}
				goto tag_mismatch;
			}
		}
		flags |= FLAG_MATCHED;

		len = data[dp++];
		if (len > 0x7f) {
			if (unlikely(len == ASN1_INDEFINITE_LENGTH)) {
				/* Indefinite length */
				if (unlikely(!(tag & ASN1_CONS_BIT)))
					goto indefinite_len_primitive;
				flags |= FLAG_INDEFINITE_LENGTH;
				if (unlikely(2 > datalen - dp))
					goto data_overrun_error;
			} else {
				int n = len - 0x80;
				if (unlikely(n > 2))
					goto length_too_long;
				if (unlikely(dp >= datalen - n))
					goto data_overrun_error;
				hdr += n;
				for (len = 0; n > 0; n--) {
					len <<= 8;
					len |= data[dp++];
				}
				if (unlikely(len > datalen - dp))
					goto data_overrun_error;
			}
		}

		if (flags & FLAG_CONS) {
			/* For expected compound forms, we stack the positions
			 * of the start and end of the data.
			 */
			if (unlikely(csp >= NR_CONS_STACK))
				goto cons_stack_overflow;
			cons_dp_stack[csp] = dp;
			cons_hdrlen_stack[csp] = hdr;
			if (!(flags & FLAG_INDEFINITE_LENGTH)) {
				cons_datalen_stack[csp] = datalen;
				datalen = dp + len;
			} else {
				cons_datalen_stack[csp] = 0;
			}
			csp++;
		}

		pr_debug(""- TAG: %02x %zu%s\n"",
			 tag, len, flags & FLAG_CONS ? "" CONS"" : """");
		tdp = dp;
	}

	/* Decide how to handle the operation */
	switch (op) {
	case ASN1_OP_MATCH_ANY_ACT:
	case ASN1_OP_COND_MATCH_ANY_ACT:
		ret = actions[machine[pc + 1]](context, hdr, tag, data + dp, len);
		if (ret < 0)
			return ret;
		goto skip_data;

	case ASN1_OP_MATCH_ACT:
	case ASN1_OP_MATCH_ACT_OR_SKIP:
	case ASN1_OP_COND_MATCH_ACT_OR_SKIP:
		ret = actions[machine[pc + 2]](context, hdr, tag, data + dp, len);
		if (ret < 0)
			return ret;
		goto skip_data;

	case ASN1_OP_MATCH:
	case ASN1_OP_MATCH_OR_SKIP:
	case ASN1_OP_MATCH_ANY:
	case ASN1_OP_COND_MATCH_OR_SKIP:
	case ASN1_OP_COND_MATCH_ANY:
	skip_data:
		if (!(flags & FLAG_CONS)) {
			if (flags & FLAG_INDEFINITE_LENGTH) {
				ret = asn1_find_indefinite_length(
					data, datalen, &dp, &len, &errmsg);
				if (ret < 0)
					goto error;
			} else {
				dp += len;
			}
			pr_debug(""- LEAF: %zu\n"", len);
		}
		pc += asn1_op_lengths[op];
		goto next_op;

	case ASN1_OP_MATCH_JUMP:
	case ASN1_OP_MATCH_JUMP_OR_SKIP:
	case ASN1_OP_COND_MATCH_JUMP_OR_SKIP:
		pr_debug(""- MATCH_JUMP\n"");
		if (unlikely(jsp == NR_JUMP_STACK))
			goto jump_stack_overflow;
		jump_stack[jsp++] = pc + asn1_op_lengths[op];
		pc = machine[pc + 2];
		goto next_op;

	case ASN1_OP_COND_FAIL:
		if (unlikely(!(flags & FLAG_MATCHED)))
			goto tag_mismatch;
		pc += asn1_op_lengths[op];
		goto next_op;

	case ASN1_OP_COMPLETE:
		if (unlikely(jsp != 0 || csp != 0)) {
			pr_err(""ASN.1 decoder error: Stacks not empty at completion (%u, %u)\n"",
			       jsp, csp);
			return -EBADMSG;
		}
		return 0;

	case ASN1_OP_END_SET:
	case ASN1_OP_END_SET_ACT:
		if (unlikely(!(flags & FLAG_MATCHED)))
			goto tag_mismatch;
	case ASN1_OP_END_SEQ:
	case ASN1_OP_END_SET_OF:
	case ASN1_OP_END_SEQ_OF:
	case ASN1_OP_END_SEQ_ACT:
	case ASN1_OP_END_SET_OF_ACT:
	case ASN1_OP_END_SEQ_OF_ACT:
		if (unlikely(csp <= 0))
			goto cons_stack_underflow;
		csp--;
		tdp = cons_dp_stack[csp];
		hdr = cons_hdrlen_stack[csp];
		len = datalen;
		datalen = cons_datalen_stack[csp];
		pr_debug(""- end cons t=%zu dp=%zu l=%zu/%zu\n"",
			 tdp, dp, len, datalen);
		if (datalen == 0) {
			/* Indefinite length - check for the EOC. */
			datalen = len;
			if (unlikely(datalen - dp < 2))
				goto data_overrun_error;
			if (data[dp++] != 0) {
				if (op & ASN1_OP_END__OF) {
					dp--;
					csp++;
					pc = machine[pc + 1];
					pr_debug(""- continue\n"");
					goto next_op;
				}
				goto missing_eoc;
			}
			if (data[dp++] != 0)
				goto invalid_eoc;
			len = dp - tdp - 2;
		} else {
			if (dp < len && (op & ASN1_OP_END__OF)) {
				datalen = len;
				csp++;
				pc = machine[pc + 1];
				pr_debug(""- continue\n"");
				goto next_op;
			}
			if (dp != len)
				goto cons_length_error;
			len -= tdp;
			pr_debug(""- cons len l=%zu d=%zu\n"", len, dp - tdp);
		}

		if (op & ASN1_OP_END__ACT) {
			unsigned char act;
			if (op & ASN1_OP_END__OF)
				act = machine[pc + 2];
			else
				act = machine[pc + 1];
			ret = actions[act](context, hdr, 0, data + tdp, len);
		}
		pc += asn1_op_lengths[op];
		goto next_op;

	case ASN1_OP_MAYBE_ACT:
		if (!(flags & FLAG_LAST_MATCHED)) {
			pc += asn1_op_lengths[op];
			goto next_op;
		}
	case ASN1_OP_ACT:
		ret = actions[machine[pc + 1]](context, hdr, tag, data + tdp, len);
		if (ret < 0)
			return ret;
		pc += asn1_op_lengths[op];
		goto next_op;

	case ASN1_OP_RETURN:
		if (unlikely(jsp <= 0))
			goto jump_stack_underflow;
		pc = jump_stack[--jsp];
		flags |= FLAG_MATCHED | FLAG_LAST_MATCHED;
		goto next_op;

	default:
		break;
	}

	/* Shouldn't reach here */
	pr_err(""ASN.1 decoder error: Found reserved opcode (%u) pc=%zu\n"",
	       op, pc);
	return -EBADMSG;

data_overrun_error:
	errmsg = ""Data overrun error"";
	goto error;
machine_overrun_error:
	errmsg = ""Machine overrun error"";
	goto error;
jump_stack_underflow:
	errmsg = ""Jump stack underflow"";
	goto error;
jump_stack_overflow:
	errmsg = ""Jump stack overflow"";
	goto error;
cons_stack_underflow:
	errmsg = ""Cons stack underflow"";
	goto error;
cons_stack_overflow:
	errmsg = ""Cons stack overflow"";
	goto error;
cons_length_error:
	errmsg = ""Cons length error"";
	goto error;
missing_eoc:
	errmsg = ""Missing EOC in indefinite len cons"";
	goto error;
invalid_eoc:
	errmsg = ""Invalid length EOC"";
	goto error;
length_too_long:
	errmsg = ""Unsupported length"";
	goto error;
indefinite_len_primitive:
	errmsg = ""Indefinite len primitive not permitted"";
	goto error;
tag_mismatch:
	errmsg = ""Unexpected tag"";
	goto error;
long_tag_not_supported:
	errmsg = ""Long tag not supported"";
error:
	pr_debug(""\nASN1: %s [m=%zu d=%zu ot=%02x t=%02x l=%zu]\n"",
		 errmsg, pc, dp, optag, tag, len);
	return -EBADMSG;
}
","int asn1_ber_decoder(const struct asn1_decoder *decoder,
		     void *context,
		     const unsigned char *data,
		     size_t datalen)
{
	const unsigned char *machine = decoder->machine;
	const asn1_action_t *actions = decoder->actions;
	size_t machlen = decoder->machlen;
	enum asn1_opcode op;
	unsigned char tag = 0, csp = 0, jsp = 0, optag = 0, hdr = 0;
	const char *errmsg;
	size_t pc = 0, dp = 0, tdp = 0, len = 0;
	int ret;

	unsigned char flags = 0;
#define FLAG_INDEFINITE_LENGTH	0x01
#define FLAG_MATCHED		0x02
#define FLAG_LAST_MATCHED	0x04 /* Last tag matched */
#define FLAG_CONS		0x20 /* Corresponds to CONS bit in the opcode tag
				      * - ie. whether or not we are going to parse
				      *   a compound type.
				      */

#define NR_CONS_STACK 10
	unsigned short cons_dp_stack[NR_CONS_STACK];
	unsigned short cons_datalen_stack[NR_CONS_STACK];
	unsigned char cons_hdrlen_stack[NR_CONS_STACK];
#define NR_JUMP_STACK 10
	unsigned char jump_stack[NR_JUMP_STACK];

	if (datalen > 65535)
		return -EMSGSIZE;

next_op:
	pr_debug(""next_op: pc=\e[32m%zu\e[m/%zu dp=\e[33m%zu\e[m/%zu C=%d J=%d\n"",
		 pc, machlen, dp, datalen, csp, jsp);
	if (unlikely(pc >= machlen))
		goto machine_overrun_error;
	op = machine[pc];
	if (unlikely(pc + asn1_op_lengths[op] > machlen))
		goto machine_overrun_error;

	/* If this command is meant to match a tag, then do that before
	 * evaluating the command.
	 */
	if (op <= ASN1_OP__MATCHES_TAG) {
 		unsigned char tmp;
 
 		/* Skip conditional matches if possible */
		if ((op & ASN1_OP_MATCH__COND &&
		     flags & FLAG_MATCHED) ||
		    dp == datalen) {
 			flags &= ~FLAG_LAST_MATCHED;
 			pc += asn1_op_lengths[op];
 			goto next_op;
		}

		flags = 0;
		hdr = 2;

		/* Extract a tag from the data */
		if (unlikely(dp >= datalen - 1))
			goto data_overrun_error;
		tag = data[dp++];
		if (unlikely((tag & 0x1f) == ASN1_LONG_TAG))
			goto long_tag_not_supported;

		if (op & ASN1_OP_MATCH__ANY) {
			pr_debug(""- any %02x\n"", tag);
		} else {
			/* Extract the tag from the machine
			 * - Either CONS or PRIM are permitted in the data if
			 *   CONS is not set in the op stream, otherwise CONS
			 *   is mandatory.
			 */
			optag = machine[pc + 1];
			flags |= optag & FLAG_CONS;

			/* Determine whether the tag matched */
			tmp = optag ^ tag;
			tmp &= ~(optag & ASN1_CONS_BIT);
			pr_debug(""- match? %02x %02x %02x\n"", tag, optag, tmp);
			if (tmp != 0) {
				/* All odd-numbered tags are MATCH_OR_SKIP. */
				if (op & ASN1_OP_MATCH__SKIP) {
					pc += asn1_op_lengths[op];
					dp--;
					goto next_op;
				}
				goto tag_mismatch;
			}
		}
		flags |= FLAG_MATCHED;

		len = data[dp++];
		if (len > 0x7f) {
			if (unlikely(len == ASN1_INDEFINITE_LENGTH)) {
				/* Indefinite length */
				if (unlikely(!(tag & ASN1_CONS_BIT)))
					goto indefinite_len_primitive;
				flags |= FLAG_INDEFINITE_LENGTH;
				if (unlikely(2 > datalen - dp))
					goto data_overrun_error;
			} else {
				int n = len - 0x80;
				if (unlikely(n > 2))
					goto length_too_long;
				if (unlikely(dp >= datalen - n))
					goto data_overrun_error;
				hdr += n;
				for (len = 0; n > 0; n--) {
					len <<= 8;
					len |= data[dp++];
				}
				if (unlikely(len > datalen - dp))
					goto data_overrun_error;
			}
		}

		if (flags & FLAG_CONS) {
			/* For expected compound forms, we stack the positions
			 * of the start and end of the data.
			 */
			if (unlikely(csp >= NR_CONS_STACK))
				goto cons_stack_overflow;
			cons_dp_stack[csp] = dp;
			cons_hdrlen_stack[csp] = hdr;
			if (!(flags & FLAG_INDEFINITE_LENGTH)) {
				cons_datalen_stack[csp] = datalen;
				datalen = dp + len;
			} else {
				cons_datalen_stack[csp] = 0;
			}
			csp++;
		}

		pr_debug(""- TAG: %02x %zu%s\n"",
			 tag, len, flags & FLAG_CONS ? "" CONS"" : """");
		tdp = dp;
	}

	/* Decide how to handle the operation */
	switch (op) {
	case ASN1_OP_MATCH_ANY_ACT:
	case ASN1_OP_COND_MATCH_ANY_ACT:
		ret = actions[machine[pc + 1]](context, hdr, tag, data + dp, len);
		if (ret < 0)
			return ret;
		goto skip_data;

	case ASN1_OP_MATCH_ACT:
	case ASN1_OP_MATCH_ACT_OR_SKIP:
	case ASN1_OP_COND_MATCH_ACT_OR_SKIP:
		ret = actions[machine[pc + 2]](context, hdr, tag, data + dp, len);
		if (ret < 0)
			return ret;
		goto skip_data;

	case ASN1_OP_MATCH:
	case ASN1_OP_MATCH_OR_SKIP:
	case ASN1_OP_MATCH_ANY:
	case ASN1_OP_COND_MATCH_OR_SKIP:
	case ASN1_OP_COND_MATCH_ANY:
	skip_data:
		if (!(flags & FLAG_CONS)) {
			if (flags & FLAG_INDEFINITE_LENGTH) {
				ret = asn1_find_indefinite_length(
					data, datalen, &dp, &len, &errmsg);
				if (ret < 0)
					goto error;
			} else {
				dp += len;
			}
			pr_debug(""- LEAF: %zu\n"", len);
		}
		pc += asn1_op_lengths[op];
		goto next_op;

	case ASN1_OP_MATCH_JUMP:
	case ASN1_OP_MATCH_JUMP_OR_SKIP:
	case ASN1_OP_COND_MATCH_JUMP_OR_SKIP:
		pr_debug(""- MATCH_JUMP\n"");
		if (unlikely(jsp == NR_JUMP_STACK))
			goto jump_stack_overflow;
		jump_stack[jsp++] = pc + asn1_op_lengths[op];
		pc = machine[pc + 2];
		goto next_op;

	case ASN1_OP_COND_FAIL:
		if (unlikely(!(flags & FLAG_MATCHED)))
			goto tag_mismatch;
		pc += asn1_op_lengths[op];
		goto next_op;

	case ASN1_OP_COMPLETE:
		if (unlikely(jsp != 0 || csp != 0)) {
			pr_err(""ASN.1 decoder error: Stacks not empty at completion (%u, %u)\n"",
			       jsp, csp);
			return -EBADMSG;
		}
		return 0;

	case ASN1_OP_END_SET:
	case ASN1_OP_END_SET_ACT:
		if (unlikely(!(flags & FLAG_MATCHED)))
			goto tag_mismatch;
	case ASN1_OP_END_SEQ:
	case ASN1_OP_END_SET_OF:
	case ASN1_OP_END_SEQ_OF:
	case ASN1_OP_END_SEQ_ACT:
	case ASN1_OP_END_SET_OF_ACT:
	case ASN1_OP_END_SEQ_OF_ACT:
		if (unlikely(csp <= 0))
			goto cons_stack_underflow;
		csp--;
		tdp = cons_dp_stack[csp];
		hdr = cons_hdrlen_stack[csp];
		len = datalen;
		datalen = cons_datalen_stack[csp];
		pr_debug(""- end cons t=%zu dp=%zu l=%zu/%zu\n"",
			 tdp, dp, len, datalen);
		if (datalen == 0) {
			/* Indefinite length - check for the EOC. */
			datalen = len;
			if (unlikely(datalen - dp < 2))
				goto data_overrun_error;
			if (data[dp++] != 0) {
				if (op & ASN1_OP_END__OF) {
					dp--;
					csp++;
					pc = machine[pc + 1];
					pr_debug(""- continue\n"");
					goto next_op;
				}
				goto missing_eoc;
			}
			if (data[dp++] != 0)
				goto invalid_eoc;
			len = dp - tdp - 2;
		} else {
			if (dp < len && (op & ASN1_OP_END__OF)) {
				datalen = len;
				csp++;
				pc = machine[pc + 1];
				pr_debug(""- continue\n"");
				goto next_op;
			}
			if (dp != len)
				goto cons_length_error;
			len -= tdp;
			pr_debug(""- cons len l=%zu d=%zu\n"", len, dp - tdp);
		}

		if (op & ASN1_OP_END__ACT) {
			unsigned char act;
			if (op & ASN1_OP_END__OF)
				act = machine[pc + 2];
			else
				act = machine[pc + 1];
			ret = actions[act](context, hdr, 0, data + tdp, len);
		}
		pc += asn1_op_lengths[op];
		goto next_op;

	case ASN1_OP_MAYBE_ACT:
		if (!(flags & FLAG_LAST_MATCHED)) {
			pc += asn1_op_lengths[op];
			goto next_op;
		}
	case ASN1_OP_ACT:
		ret = actions[machine[pc + 1]](context, hdr, tag, data + tdp, len);
		if (ret < 0)
			return ret;
		pc += asn1_op_lengths[op];
		goto next_op;

	case ASN1_OP_RETURN:
		if (unlikely(jsp <= 0))
			goto jump_stack_underflow;
		pc = jump_stack[--jsp];
		flags |= FLAG_MATCHED | FLAG_LAST_MATCHED;
		goto next_op;

	default:
		break;
	}

	/* Shouldn't reach here */
	pr_err(""ASN.1 decoder error: Found reserved opcode (%u) pc=%zu\n"",
	       op, pc);
	return -EBADMSG;

data_overrun_error:
	errmsg = ""Data overrun error"";
	goto error;
machine_overrun_error:
	errmsg = ""Machine overrun error"";
	goto error;
jump_stack_underflow:
	errmsg = ""Jump stack underflow"";
	goto error;
jump_stack_overflow:
	errmsg = ""Jump stack overflow"";
	goto error;
cons_stack_underflow:
	errmsg = ""Cons stack underflow"";
	goto error;
cons_stack_overflow:
	errmsg = ""Cons stack overflow"";
	goto error;
cons_length_error:
	errmsg = ""Cons length error"";
	goto error;
missing_eoc:
	errmsg = ""Missing EOC in indefinite len cons"";
	goto error;
invalid_eoc:
	errmsg = ""Invalid length EOC"";
	goto error;
length_too_long:
	errmsg = ""Unsupported length"";
	goto error;
indefinite_len_primitive:
	errmsg = ""Indefinite len primitive not permitted"";
	goto error;
tag_mismatch:
	errmsg = ""Unexpected tag"";
	goto error;
long_tag_not_supported:
	errmsg = ""Long tag not supported"";
error:
	pr_debug(""\nASN1: %s [m=%zu d=%zu ot=%02x t=%02x l=%zu]\n"",
		 errmsg, pc, dp, optag, tag, len);
	return -EBADMSG;
}
",C,"		if ((op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED) ||
		    (op & ASN1_OP_MATCH__SKIP && dp == datalen)) {
","		if ((op & ASN1_OP_MATCH__COND &&
		     flags & FLAG_MATCHED) ||
		    dp == datalen) {
",,"@@ -210,9 +210,8 @@ int asn1_ber_decoder(const struct asn1_decoder *decoder,
 		unsigned char tmp;
 
 		/* Skip conditional matches if possible */
-		if ((op & ASN1_OP_MATCH__COND &&
-		     flags & FLAG_MATCHED) ||
-		    dp == datalen) {
+		if ((op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED) ||
+		    (op & ASN1_OP_MATCH__SKIP && dp == datalen)) {
 			flags &= ~FLAG_LAST_MATCHED;
 			pc += asn1_op_lengths[op];
 			goto next_op;",linux,0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f,3f3af97d8225a58ecdcde7217c030b17e5198226,1,"int asn1_ber_decoder(const struct asn1_decoder *decoder,
		     void *context,
		     const unsigned char *data,
		     size_t datalen)
{
	const unsigned char *machine = decoder->machine;
	const asn1_action_t *actions = decoder->actions;
	size_t machlen = decoder->machlen;
	enum asn1_opcode op;
	unsigned char tag = 0, csp = 0, jsp = 0, optag = 0, hdr = 0;
	const char *errmsg;
	size_t pc = 0, dp = 0, tdp = 0, len = 0;
	int ret;

	unsigned char flags = 0;
#define FLAG_INDEFINITE_LENGTH	0x01
#define FLAG_MATCHED		0x02
#define FLAG_LAST_MATCHED	0x04 /* Last tag matched */
#define FLAG_CONS		0x20 /* Corresponds to CONS bit in the opcode tag
				      * - ie. whether or not we are going to parse
				      *   a compound type.
				      */

#define NR_CONS_STACK 10
	unsigned short cons_dp_stack[NR_CONS_STACK];
	unsigned short cons_datalen_stack[NR_CONS_STACK];
	unsigned char cons_hdrlen_stack[NR_CONS_STACK];
#define NR_JUMP_STACK 10
	unsigned char jump_stack[NR_JUMP_STACK];

	if (datalen > 65535)
		return -EMSGSIZE;

next_op:
	pr_debug(""next_op: pc=\e[32m%zu\e[m/%zu dp=\e[33m%zu\e[m/%zu C=%d J=%d\n"",
		 pc, machlen, dp, datalen, csp, jsp);
	if (unlikely(pc >= machlen))
		goto machine_overrun_error;
	op = machine[pc];
	if (unlikely(pc + asn1_op_lengths[op] > machlen))
		goto machine_overrun_error;

	/* If this command is meant to match a tag, then do that before
	 * evaluating the command.
	 */
	if (op <= ASN1_OP__MATCHES_TAG) {
 		unsigned char tmp;
 
 		/* Skip conditional matches if possible */
//flaw_line_below:
		if ((op & ASN1_OP_MATCH__COND &&
//flaw_line_below:
		     flags & FLAG_MATCHED) ||
//flaw_line_below:
		    dp == datalen) {
//fix_flaw_line_below:
//		if ((op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED) ||
//fix_flaw_line_below:
//		    (op & ASN1_OP_MATCH__SKIP && dp == datalen)) {
 			flags &= ~FLAG_LAST_MATCHED;
 			pc += asn1_op_lengths[op];
 			goto next_op;
		}

		flags = 0;
		hdr = 2;

		/* Extract a tag from the data */
		if (unlikely(dp >= datalen - 1))
			goto data_overrun_error;
		tag = data[dp++];
		if (unlikely((tag & 0x1f) == ASN1_LONG_TAG))
			goto long_tag_not_supported;

		if (op & ASN1_OP_MATCH__ANY) {
			pr_debug(""- any %02x\n"", tag);
		} else {
			/* Extract the tag from the machine
			 * - Either CONS or PRIM are permitted in the data if
			 *   CONS is not set in the op stream, otherwise CONS
			 *   is mandatory.
			 */
			optag = machine[pc + 1];
			flags |= optag & FLAG_CONS;

			/* Determine whether the tag matched */
			tmp = optag ^ tag;
			tmp &= ~(optag & ASN1_CONS_BIT);
			pr_debug(""- match? %02x %02x %02x\n"", tag, optag, tmp);
			if (tmp != 0) {
				/* All odd-numbered tags are MATCH_OR_SKIP. */
				if (op & ASN1_OP_MATCH__SKIP) {
					pc += asn1_op_lengths[op];
					dp--;
					goto next_op;
				}
				goto tag_mismatch;
			}
		}
		flags |= FLAG_MATCHED;

		len = data[dp++];
		if (len > 0x7f) {
			if (unlikely(len == ASN1_INDEFINITE_LENGTH)) {
				/* Indefinite length */
				if (unlikely(!(tag & ASN1_CONS_BIT)))
					goto indefinite_len_primitive;
				flags |= FLAG_INDEFINITE_LENGTH;
				if (unlikely(2 > datalen - dp))
					goto data_overrun_error;
			} else {
				int n = len - 0x80;
				if (unlikely(n > 2))
					goto length_too_long;
				if (unlikely(dp >= datalen - n))
					goto data_overrun_error;
				hdr += n;
				for (len = 0; n > 0; n--) {
					len <<= 8;
					len |= data[dp++];
				}
				if (unlikely(len > datalen - dp))
					goto data_overrun_error;
			}
		}

		if (flags & FLAG_CONS) {
			/* For expected compound forms, we stack the positions
			 * of the start and end of the data.
			 */
			if (unlikely(csp >= NR_CONS_STACK))
				goto cons_stack_overflow;
			cons_dp_stack[csp] = dp;
			cons_hdrlen_stack[csp] = hdr;
			if (!(flags & FLAG_INDEFINITE_LENGTH)) {
				cons_datalen_stack[csp] = datalen;
				datalen = dp + len;
			} else {
				cons_datalen_stack[csp] = 0;
			}
			csp++;
		}

		pr_debug(""- TAG: %02x %zu%s\n"",
			 tag, len, flags & FLAG_CONS ? "" CONS"" : """");
		tdp = dp;
	}

	/* Decide how to handle the operation */
	switch (op) {
	case ASN1_OP_MATCH_ANY_ACT:
	case ASN1_OP_COND_MATCH_ANY_ACT:
		ret = actions[machine[pc + 1]](context, hdr, tag, data + dp, len);
		if (ret < 0)
			return ret;
		goto skip_data;

	case ASN1_OP_MATCH_ACT:
	case ASN1_OP_MATCH_ACT_OR_SKIP:
	case ASN1_OP_COND_MATCH_ACT_OR_SKIP:
		ret = actions[machine[pc + 2]](context, hdr, tag, data + dp, len);
		if (ret < 0)
			return ret;
		goto skip_data;

	case ASN1_OP_MATCH:
	case ASN1_OP_MATCH_OR_SKIP:
	case ASN1_OP_MATCH_ANY:
	case ASN1_OP_COND_MATCH_OR_SKIP:
	case ASN1_OP_COND_MATCH_ANY:
	skip_data:
		if (!(flags & FLAG_CONS)) {
			if (flags & FLAG_INDEFINITE_LENGTH) {
				ret = asn1_find_indefinite_length(
					data, datalen, &dp, &len, &errmsg);
				if (ret < 0)
					goto error;
			} else {
				dp += len;
			}
			pr_debug(""- LEAF: %zu\n"", len);
		}
		pc += asn1_op_lengths[op];
		goto next_op;

	case ASN1_OP_MATCH_JUMP:
	case ASN1_OP_MATCH_JUMP_OR_SKIP:
	case ASN1_OP_COND_MATCH_JUMP_OR_SKIP:
		pr_debug(""- MATCH_JUMP\n"");
		if (unlikely(jsp == NR_JUMP_STACK))
			goto jump_stack_overflow;
		jump_stack[jsp++] = pc + asn1_op_lengths[op];
		pc = machine[pc + 2];
		goto next_op;

	case ASN1_OP_COND_FAIL:
		if (unlikely(!(flags & FLAG_MATCHED)))
			goto tag_mismatch;
		pc += asn1_op_lengths[op];
		goto next_op;

	case ASN1_OP_COMPLETE:
		if (unlikely(jsp != 0 || csp != 0)) {
			pr_err(""ASN.1 decoder error: Stacks not empty at completion (%u, %u)\n"",
			       jsp, csp);
			return -EBADMSG;
		}
		return 0;

	case ASN1_OP_END_SET:
	case ASN1_OP_END_SET_ACT:
		if (unlikely(!(flags & FLAG_MATCHED)))
			goto tag_mismatch;
	case ASN1_OP_END_SEQ:
	case ASN1_OP_END_SET_OF:
	case ASN1_OP_END_SEQ_OF:
	case ASN1_OP_END_SEQ_ACT:
	case ASN1_OP_END_SET_OF_ACT:
	case ASN1_OP_END_SEQ_OF_ACT:
		if (unlikely(csp <= 0))
			goto cons_stack_underflow;
		csp--;
		tdp = cons_dp_stack[csp];
		hdr = cons_hdrlen_stack[csp];
		len = datalen;
		datalen = cons_datalen_stack[csp];
		pr_debug(""- end cons t=%zu dp=%zu l=%zu/%zu\n"",
			 tdp, dp, len, datalen);
		if (datalen == 0) {
			/* Indefinite length - check for the EOC. */
			datalen = len;
			if (unlikely(datalen - dp < 2))
				goto data_overrun_error;
			if (data[dp++] != 0) {
				if (op & ASN1_OP_END__OF) {
					dp--;
					csp++;
					pc = machine[pc + 1];
					pr_debug(""- continue\n"");
					goto next_op;
				}
				goto missing_eoc;
			}
			if (data[dp++] != 0)
				goto invalid_eoc;
			len = dp - tdp - 2;
		} else {
			if (dp < len && (op & ASN1_OP_END__OF)) {
				datalen = len;
				csp++;
				pc = machine[pc + 1];
				pr_debug(""- continue\n"");
				goto next_op;
			}
			if (dp != len)
				goto cons_length_error;
			len -= tdp;
			pr_debug(""- cons len l=%zu d=%zu\n"", len, dp - tdp);
		}

		if (op & ASN1_OP_END__ACT) {
			unsigned char act;
			if (op & ASN1_OP_END__OF)
				act = machine[pc + 2];
			else
				act = machine[pc + 1];
			ret = actions[act](context, hdr, 0, data + tdp, len);
		}
		pc += asn1_op_lengths[op];
		goto next_op;

	case ASN1_OP_MAYBE_ACT:
		if (!(flags & FLAG_LAST_MATCHED)) {
			pc += asn1_op_lengths[op];
			goto next_op;
		}
	case ASN1_OP_ACT:
		ret = actions[machine[pc + 1]](context, hdr, tag, data + tdp, len);
		if (ret < 0)
			return ret;
		pc += asn1_op_lengths[op];
		goto next_op;

	case ASN1_OP_RETURN:
		if (unlikely(jsp <= 0))
			goto jump_stack_underflow;
		pc = jump_stack[--jsp];
		flags |= FLAG_MATCHED | FLAG_LAST_MATCHED;
		goto next_op;

	default:
		break;
	}

	/* Shouldn't reach here */
	pr_err(""ASN.1 decoder error: Found reserved opcode (%u) pc=%zu\n"",
	       op, pc);
	return -EBADMSG;

data_overrun_error:
	errmsg = ""Data overrun error"";
	goto error;
machine_overrun_error:
	errmsg = ""Machine overrun error"";
	goto error;
jump_stack_underflow:
	errmsg = ""Jump stack underflow"";
	goto error;
jump_stack_overflow:
	errmsg = ""Jump stack overflow"";
	goto error;
cons_stack_underflow:
	errmsg = ""Cons stack underflow"";
	goto error;
cons_stack_overflow:
	errmsg = ""Cons stack overflow"";
	goto error;
cons_length_error:
	errmsg = ""Cons length error"";
	goto error;
missing_eoc:
	errmsg = ""Missing EOC in indefinite len cons"";
	goto error;
invalid_eoc:
	errmsg = ""Invalid length EOC"";
	goto error;
length_too_long:
	errmsg = ""Unsupported length"";
	goto error;
indefinite_len_primitive:
	errmsg = ""Indefinite len primitive not permitted"";
	goto error;
tag_mismatch:
	errmsg = ""Unexpected tag"";
	goto error;
long_tag_not_supported:
	errmsg = ""Long tag not supported"";
error:
	pr_debug(""\nASN1: %s [m=%zu d=%zu ot=%02x t=%02x l=%zu]\n"",
		 errmsg, pc, dp, optag, tag, len);
	return -EBADMSG;
}
"
3029,180765,,Remote,Not required,,CVE-2013-7449,https://www.cvedetails.com/cve/CVE-2013-7449/,CWE-310,Medium,Partial,Partial,,2016-04-21,5.8,"The ssl_do_connect function in common/server.c in HexChat before 2.10.2, XChat, and XChat-GNOME does not verify that the server hostname matches a domain name in the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.",2016-05-06,,15,https://github.com/hexchat/hexchat/commit/c9b63f7f9be01692b03fa15275135a4910a7e02d,c9b63f7f9be01692b03fa15275135a4910a7e02d,"ssl: Validate hostnames

Closes #524",1,src/common/server.c,"{""sha"": ""6432a2b9c51d8583d5e514bd7d1e1cf0850a91c5"", ""filename"": ""src/common/server.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 1, ""changes"": 16, ""blob_url"": ""https://github.com/hexchat/hexchat/blob/c9b63f7f9be01692b03fa15275135a4910a7e02d/src/common/server.c"", ""raw_url"": ""https://github.com/hexchat/hexchat/raw/c9b63f7f9be01692b03fa15275135a4910a7e02d/src/common/server.c"", ""contents_url"": ""https://api.github.com/repos/hexchat/hexchat/contents/src/common/server.c?ref=c9b63f7f9be01692b03fa15275135a4910a7e02d"", ""patch"": ""@@ -723,9 +723,22 @@ ssl_do_connect (server * serv)\n \t\tswitch (verify_error)\n \t\t{\n \t\tcase X509_V_OK:\n+\t\t\t{\n+\t\t\t\tX509 *cert = SSL_get_peer_certificate (serv->ssl);\n+\t\t\t\tint hostname_err;\n+\t\t\t\tif ((hostname_err = _SSL_check_hostname(cert, serv->hostname)) != 0)\n+\t\t\t\t{\n+\t\t\t\t\tsnprintf (buf, sizeof (buf), \""* Verify E: Failed to validate hostname? (%d)%s\"",\n+\t\t\t\t\t\t\t hostname_err, serv->accept_invalid_cert ? \"" -- Ignored\"" : \""\"");\n+\t\t\t\t\tif (serv->accept_invalid_cert)\n+\t\t\t\t\t\tEMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL, 0);\n+\t\t\t\t\telse\n+\t\t\t\t\t\tgoto conn_fail;\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t\t/* snprintf (buf, sizeof (buf), \""* Verify OK (?)\""); */\n \t\t\t/* EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL, 0); */\n-\t\t\tbreak;\n \t\tcase X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:\n \t\tcase X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE:\n \t\tcase X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:\n@@ -744,6 +757,7 @@ ssl_do_connect (server * serv)\n \t\t\tsnprintf (buf, sizeof (buf), \""%s.? (%d)\"",\n \t\t\t\t\t\t X509_verify_cert_error_string (verify_error),\n \t\t\t\t\t\t verify_error);\n+conn_fail:\n \t\t\tEMIT_SIGNAL (XP_TE_CONNFAIL, serv->server_session, buf, NULL, NULL,\n \t\t\t\t\t\t\t NULL, 0);\n ""}<_**next**_>{""sha"": ""04cd6673f55d15a60df2eab3d0d07c755c0c0e75"", ""filename"": ""src/common/ssl.c"", ""status"": ""modified"", ""additions"": 203, ""deletions"": 0, ""changes"": 203, ""blob_url"": ""https://github.com/hexchat/hexchat/blob/c9b63f7f9be01692b03fa15275135a4910a7e02d/src/common/ssl.c"", ""raw_url"": ""https://github.com/hexchat/hexchat/raw/c9b63f7f9be01692b03fa15275135a4910a7e02d/src/common/ssl.c"", ""contents_url"": ""https://api.github.com/repos/hexchat/hexchat/contents/src/common/ssl.c?ref=c9b63f7f9be01692b03fa15275135a4910a7e02d"", ""patch"": ""@@ -25,6 +25,7 @@\n #include \""inet.h\""\t\t\t\t  /* make it first to avoid macro redefinitions */\n #include <openssl/ssl.h>\t\t  /* SSL_() */\n #include <openssl/err.h>\t\t  /* ERR_() */\n+#include <openssl/x509v3.h>\n #ifdef WIN32\n #include <openssl/rand.h>\t\t  /* RAND_seed() */\n #endif\n@@ -35,6 +36,7 @@\n \n #include <glib.h>\n #include <glib/gprintf.h>\n+#include <gio/gio.h>\n #include \""util.h\""\n \n /* If openssl was built without ec */\n@@ -339,3 +341,204 @@ _SSL_close (SSL * ssl)\n \tSSL_free (ssl);\n \tERR_remove_state (0);\t\t  /* free state buffer */\n }\n+\n+/* Hostname validation code based on OpenBSD's libtls. */\n+\n+static int\n+_SSL_match_hostname (const char *cert_hostname, const char *hostname)\n+{\n+\tconst char *cert_domain, *domain, *next_dot;\n+\n+\tif (g_ascii_strcasecmp (cert_hostname, hostname) == 0)\n+\t\treturn 0;\n+\n+\t/* Wildcard match? */\n+\tif (cert_hostname[0] == '*')\n+\t{\n+\t\t/*\n+\t\t * Valid wildcards:\n+\t\t * - \""*.domain.tld\""\n+\t\t * - \""*.sub.domain.tld\""\n+\t\t * - etc.\n+\t\t * Reject \""*.tld\"".\n+\t\t * No attempt to prevent the use of eg. \""*.co.uk\"".\n+\t\t */\n+\t\tcert_domain = &cert_hostname[1];\n+\t\t/* Disallow \""*\""  */\n+\t\tif (cert_domain[0] == '\\0')\n+\t\t\treturn -1;\n+\t\t/* Disallow \""*foo\"" */\n+\t\tif (cert_domain[0] != '.')\n+\t\t\treturn -1;\n+\t\t/* Disallow \""*..\"" */\n+\t\tif (cert_domain[1] == '.')\n+\t\t\treturn -1;\n+\t\tnext_dot = strchr (&cert_domain[1], '.');\n+\t\t/* Disallow \""*.bar\"" */\n+\t\tif (next_dot == NULL)\n+\t\t\treturn -1;\n+\t\t/* Disallow \""*.bar..\"" */\n+\t\tif (next_dot[1] == '.')\n+\t\t\treturn -1;\n+\n+\t\tdomain = strchr (hostname, '.');\n+\n+\t\t/* No wildcard match against a hostname with no domain part. */\n+\t\tif (domain == NULL || strlen(domain) == 1)\n+\t\t\treturn -1;\n+\n+\t\tif (g_ascii_strcasecmp (cert_domain, domain) == 0)\n+\t\t\treturn 0;\n+\t}\n+\n+\treturn -1;\n+}\n+\n+static int\n+_SSL_check_subject_altname (X509 *cert, const char *host)\n+{\n+\tSTACK_OF(GENERAL_NAME) *altname_stack = NULL;\n+\tGInetAddress *addr;\n+\tGSocketFamily family;\n+\tint type = GEN_DNS;\n+\tint count, i;\n+\tint rv = -1;\n+\n+\taltname_stack = X509_get_ext_d2i (cert, NID_subject_alt_name, NULL, NULL);\n+\tif (altname_stack == NULL)\n+\t\treturn -1;\n+\n+\taddr = g_inet_address_new_from_string (host);\n+\tif (addr != NULL)\n+\t{\n+\t\tfamily = g_inet_address_get_family (addr);\n+\t\tif (family == G_SOCKET_FAMILY_IPV4 || family == G_SOCKET_FAMILY_IPV6)\n+\t\t\ttype = GEN_IPADD;\n+\t}\n+\n+\tcount = sk_GENERAL_NAME_num(altname_stack);\n+\tfor (i = 0; i < count; i++)\n+\t{\n+\t\tGENERAL_NAME *altname;\n+\n+\t\taltname = sk_GENERAL_NAME_value (altname_stack, i);\n+\n+\t\tif (altname->type != type)\n+\t\t\tcontinue;\n+\n+\t\tif (type == GEN_DNS)\n+\t\t{\n+\t\t\tunsigned char *data;\n+\t\t\tint format;\n+\n+\t\t\tformat = ASN1_STRING_type (altname->d.dNSName);\n+\t\t\tif (format == V_ASN1_IA5STRING)\n+\t\t\t{\n+\t\t\t\tdata = ASN1_STRING_data (altname->d.dNSName);\n+\n+\t\t\t\tif (ASN1_STRING_length (altname->d.dNSName) != (int)strlen(data))\n+\t\t\t\t{\n+\t\t\t\t\tg_warning(\""NUL byte in subjectAltName, probably a malicious certificate.\\n\"");\n+\t\t\t\t\trv = -2;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\n+\t\t\t\tif (_SSL_match_hostname (data, host) == 0)\n+\t\t\t\t{\n+\t\t\t\t\trv = 0;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse\n+\t\t\t\tg_warning (\""unhandled subjectAltName dNSName encoding (%d)\\n\"", format);\n+\n+\t\t}\n+\t\telse if (type == GEN_IPADD)\n+\t\t{\n+\t\t\tunsigned char *data;\n+\t\t\tconst guint8 *addr_bytes;\n+\t\t\tint datalen, addr_len;\n+\n+\t\t\tdatalen = ASN1_STRING_length (altname->d.iPAddress);\n+\t\t\tdata = ASN1_STRING_data (altname->d.iPAddress);\n+\n+\t\t\taddr_bytes = g_inet_address_to_bytes (addr);\n+\t\t\taddr_len = (int)g_inet_address_get_native_size (addr);\n+\n+\t\t\tif (datalen == addr_len && memcmp (data, addr_bytes, addr_len) == 0)\n+\t\t\t{\n+\t\t\t\trv = 0;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif (addr != NULL)\n+\t\tg_object_unref (addr);\n+\tsk_GENERAL_NAME_free (altname_stack);\n+\treturn rv;\n+}\n+\n+static int\n+_SSL_check_common_name (X509 *cert, const char *host)\n+{\n+\tX509_NAME *name;\n+\tchar *common_name = NULL;\n+\tint common_name_len;\n+\tint rv = -1;\n+\tGInetAddress *addr;\n+\n+\tname = X509_get_subject_name (cert);\n+\tif (name == NULL)\n+\t\treturn -1;\n+\n+\tcommon_name_len = X509_NAME_get_text_by_NID (name, NID_commonName, NULL, 0);\n+\tif (common_name_len < 0)\n+\t\treturn -1;\n+\n+\tcommon_name = calloc (common_name_len + 1, 1);\n+\tif (common_name == NULL)\n+\t\treturn -1;\n+\n+\tX509_NAME_get_text_by_NID (name, NID_commonName, common_name, common_name_len + 1);\n+\n+\t/* NUL bytes in CN? */\n+\tif (common_name_len != (int)strlen(common_name))\n+\t{\n+\t\tg_warning (\""NUL byte in Common Name field, probably a malicious certificate.\\n\"");\n+\t\trv = -2;\n+\t\tgoto out;\n+\t}\n+\n+\tif ((addr = g_inet_address_new_from_string (host)) != NULL)\n+\t{\n+\t\t/*\n+\t\t * We don't want to attempt wildcard matching against IP\n+\t\t * addresses, so perform a simple comparison here.\n+\t\t */\n+\t\tif (g_strcmp0 (common_name, host) == 0)\n+\t\t\trv = 0;\n+\t\telse\n+\t\t\trv = -1;\n+\n+\t\tg_object_unref (addr);\n+\t}\n+\telse if (_SSL_match_hostname (common_name, host) == 0)\n+\t\trv = 0;\n+\n+out:\n+\tfree(common_name);\n+\treturn rv;\n+}\n+\n+int\n+_SSL_check_hostname (X509 *cert, const char *host)\n+{\n+\tint rv;\n+\n+\trv = _SSL_check_subject_altname (cert, host);\n+\tif (rv == 0 || rv == -2)\n+\t\treturn rv;\n+\n+\treturn _SSL_check_common_name (cert, host);\n+}\n\\ No newline at end of file""}<_**next**_>{""sha"": ""ce2f616c4649ca7b3a851e78a807602a4c89272c"", ""filename"": ""src/common/ssl.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/hexchat/hexchat/blob/c9b63f7f9be01692b03fa15275135a4910a7e02d/src/common/ssl.h"", ""raw_url"": ""https://github.com/hexchat/hexchat/raw/c9b63f7f9be01692b03fa15275135a4910a7e02d/src/common/ssl.h"", ""contents_url"": ""https://api.github.com/repos/hexchat/hexchat/contents/src/common/ssl.h?ref=c9b63f7f9be01692b03fa15275135a4910a7e02d"", ""patch"": ""@@ -52,7 +52,7 @@ char *_SSL_set_verify (SSL_CTX *ctx, void *(verify_callback), char *cacert);\n     int SSL_get_fd(SSL *);\n */\n void _SSL_close (SSL * ssl);\n-\n+int _SSL_check_hostname(X509 *cert, const char *host);\n int _SSL_get_cert_info (struct cert_info *cert_info, SSL * ssl);\n struct chiper_info *_SSL_get_cipher_info (SSL * ssl);\n ""}","ssl_do_connect (server * serv)
{
	char buf[128];

	g_sess = serv->server_session;
	if (SSL_connect (serv->ssl) <= 0)
	{
		char err_buf[128];
		int err;

		g_sess = NULL;
		if ((err = ERR_get_error ()) > 0)
		{
			ERR_error_string (err, err_buf);
			snprintf (buf, sizeof (buf), ""(%d) %s"", err, err_buf);
			EMIT_SIGNAL (XP_TE_CONNFAIL, serv->server_session, buf, NULL,
							 NULL, NULL, 0);

			if (ERR_GET_REASON (err) == SSL_R_WRONG_VERSION_NUMBER)
				PrintText (serv->server_session, _(""Are you sure this is a SSL capable server and port?\n""));

			server_cleanup (serv);

			if (prefs.hex_net_auto_reconnectonfail)
				auto_reconnect (serv, FALSE, -1);

			return (0);				  /* remove it (0) */
		}
	}
	g_sess = NULL;

	if (SSL_is_init_finished (serv->ssl))
	{
		struct cert_info cert_info;
		struct chiper_info *chiper_info;
		int verify_error;
		int i;

		if (!_SSL_get_cert_info (&cert_info, serv->ssl))
		{
			snprintf (buf, sizeof (buf), ""* Certification info:"");
			EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
							 NULL, 0);
			snprintf (buf, sizeof (buf), ""  Subject:"");
			EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
							 NULL, 0);
			for (i = 0; cert_info.subject_word[i]; i++)
			{
				snprintf (buf, sizeof (buf), ""    %s"", cert_info.subject_word[i]);
				EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
								 NULL, 0);
			}
			snprintf (buf, sizeof (buf), ""  Issuer:"");
			EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
							 NULL, 0);
			for (i = 0; cert_info.issuer_word[i]; i++)
			{
				snprintf (buf, sizeof (buf), ""    %s"", cert_info.issuer_word[i]);
				EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
								 NULL, 0);
			}
			snprintf (buf, sizeof (buf), ""  Public key algorithm: %s (%d bits)"",
						 cert_info.algorithm, cert_info.algorithm_bits);
			EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
							 NULL, 0);
			/*if (cert_info.rsa_tmp_bits)
			{
				snprintf (buf, sizeof (buf),
							 ""  Public key algorithm uses ephemeral key with %d bits"",
							 cert_info.rsa_tmp_bits);
				EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
								 NULL, 0);
			}*/
			snprintf (buf, sizeof (buf), ""  Sign algorithm %s"",
						 cert_info.sign_algorithm/*, cert_info.sign_algorithm_bits*/);
			EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
							 NULL, 0);
			snprintf (buf, sizeof (buf), ""  Valid since %s to %s"",
						 cert_info.notbefore, cert_info.notafter);
			EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
							 NULL, 0);
		} else
		{
			snprintf (buf, sizeof (buf), "" * No Certificate"");
			EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
							 NULL, 0);
		}

		chiper_info = _SSL_get_cipher_info (serv->ssl);	/* static buffer */
		snprintf (buf, sizeof (buf), ""* Cipher info:"");
		EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL,
						 0);
		snprintf (buf, sizeof (buf), ""  Version: %s, cipher %s (%u bits)"",
					 chiper_info->version, chiper_info->chiper,
					 chiper_info->chiper_bits);
		EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL,
						 0);

		verify_error = SSL_get_verify_result (serv->ssl);
 		switch (verify_error)
 		{
 		case X509_V_OK:
			{
				X509 *cert = SSL_get_peer_certificate (serv->ssl);
				int hostname_err;
				if ((hostname_err = _SSL_check_hostname(cert, serv->hostname)) != 0)
				{
					snprintf (buf, sizeof (buf), ""* Verify E: Failed to validate hostname? (%d)%s"",
							 hostname_err, serv->accept_invalid_cert ? "" -- Ignored"" : """");
					if (serv->accept_invalid_cert)
						EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL, 0);
					else
						goto conn_fail;
				}
				break;
			}
 			/* snprintf (buf, sizeof (buf), ""* Verify OK (?)""); */
 			/* EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL, 0); */
 		case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:
 		case X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE:
 		case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:
		case X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN:
		case X509_V_ERR_CERT_HAS_EXPIRED:
			if (serv->accept_invalid_cert)
			{
				snprintf (buf, sizeof (buf), ""* Verify E: %s.? (%d) -- Ignored"",
							 X509_verify_cert_error_string (verify_error),
							 verify_error);
				EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
								 NULL, 0);
				break;
			}
		default:
 			snprintf (buf, sizeof (buf), ""%s.? (%d)"",
 						 X509_verify_cert_error_string (verify_error),
 						 verify_error);
conn_fail:
 			EMIT_SIGNAL (XP_TE_CONNFAIL, serv->server_session, buf, NULL, NULL,
 							 NULL, 0);
 
			server_cleanup (serv);

			return (0);
		}

		server_stopconnecting (serv);

		/* activate gtk poll */
		server_connected (serv);

		return (0);					  /* remove it (0) */
	} else
	{
		if (serv->ssl->session && serv->ssl->session->time + SSLTMOUT < time (NULL))
		{
			snprintf (buf, sizeof (buf), ""SSL handshake timed out"");
			EMIT_SIGNAL (XP_TE_CONNFAIL, serv->server_session, buf, NULL,
							 NULL, NULL, 0);
			server_cleanup (serv); /* ->connecting = FALSE */

			if (prefs.hex_net_auto_reconnectonfail)
				auto_reconnect (serv, FALSE, -1);

			return (0);				  /* remove it (0) */
		}

		return (1);					  /* call it more (1) */
	}
}
","ssl_do_connect (server * serv)
{
	char buf[128];

	g_sess = serv->server_session;
	if (SSL_connect (serv->ssl) <= 0)
	{
		char err_buf[128];
		int err;

		g_sess = NULL;
		if ((err = ERR_get_error ()) > 0)
		{
			ERR_error_string (err, err_buf);
			snprintf (buf, sizeof (buf), ""(%d) %s"", err, err_buf);
			EMIT_SIGNAL (XP_TE_CONNFAIL, serv->server_session, buf, NULL,
							 NULL, NULL, 0);

			if (ERR_GET_REASON (err) == SSL_R_WRONG_VERSION_NUMBER)
				PrintText (serv->server_session, _(""Are you sure this is a SSL capable server and port?\n""));

			server_cleanup (serv);

			if (prefs.hex_net_auto_reconnectonfail)
				auto_reconnect (serv, FALSE, -1);

			return (0);				  /* remove it (0) */
		}
	}
	g_sess = NULL;

	if (SSL_is_init_finished (serv->ssl))
	{
		struct cert_info cert_info;
		struct chiper_info *chiper_info;
		int verify_error;
		int i;

		if (!_SSL_get_cert_info (&cert_info, serv->ssl))
		{
			snprintf (buf, sizeof (buf), ""* Certification info:"");
			EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
							 NULL, 0);
			snprintf (buf, sizeof (buf), ""  Subject:"");
			EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
							 NULL, 0);
			for (i = 0; cert_info.subject_word[i]; i++)
			{
				snprintf (buf, sizeof (buf), ""    %s"", cert_info.subject_word[i]);
				EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
								 NULL, 0);
			}
			snprintf (buf, sizeof (buf), ""  Issuer:"");
			EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
							 NULL, 0);
			for (i = 0; cert_info.issuer_word[i]; i++)
			{
				snprintf (buf, sizeof (buf), ""    %s"", cert_info.issuer_word[i]);
				EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
								 NULL, 0);
			}
			snprintf (buf, sizeof (buf), ""  Public key algorithm: %s (%d bits)"",
						 cert_info.algorithm, cert_info.algorithm_bits);
			EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
							 NULL, 0);
			/*if (cert_info.rsa_tmp_bits)
			{
				snprintf (buf, sizeof (buf),
							 ""  Public key algorithm uses ephemeral key with %d bits"",
							 cert_info.rsa_tmp_bits);
				EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
								 NULL, 0);
			}*/
			snprintf (buf, sizeof (buf), ""  Sign algorithm %s"",
						 cert_info.sign_algorithm/*, cert_info.sign_algorithm_bits*/);
			EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
							 NULL, 0);
			snprintf (buf, sizeof (buf), ""  Valid since %s to %s"",
						 cert_info.notbefore, cert_info.notafter);
			EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
							 NULL, 0);
		} else
		{
			snprintf (buf, sizeof (buf), "" * No Certificate"");
			EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
							 NULL, 0);
		}

		chiper_info = _SSL_get_cipher_info (serv->ssl);	/* static buffer */
		snprintf (buf, sizeof (buf), ""* Cipher info:"");
		EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL,
						 0);
		snprintf (buf, sizeof (buf), ""  Version: %s, cipher %s (%u bits)"",
					 chiper_info->version, chiper_info->chiper,
					 chiper_info->chiper_bits);
		EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL,
						 0);

		verify_error = SSL_get_verify_result (serv->ssl);
 		switch (verify_error)
 		{
 		case X509_V_OK:
 			/* snprintf (buf, sizeof (buf), ""* Verify OK (?)""); */
 			/* EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL, 0); */
			break;
 		case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:
 		case X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE:
 		case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:
		case X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN:
		case X509_V_ERR_CERT_HAS_EXPIRED:
			if (serv->accept_invalid_cert)
			{
				snprintf (buf, sizeof (buf), ""* Verify E: %s.? (%d) -- Ignored"",
							 X509_verify_cert_error_string (verify_error),
							 verify_error);
				EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
								 NULL, 0);
				break;
			}
		default:
 			snprintf (buf, sizeof (buf), ""%s.? (%d)"",
 						 X509_verify_cert_error_string (verify_error),
 						 verify_error);
 			EMIT_SIGNAL (XP_TE_CONNFAIL, serv->server_session, buf, NULL, NULL,
 							 NULL, 0);
 
			server_cleanup (serv);

			return (0);
		}

		server_stopconnecting (serv);

		/* activate gtk poll */
		server_connected (serv);

		return (0);					  /* remove it (0) */
	} else
	{
		if (serv->ssl->session && serv->ssl->session->time + SSLTMOUT < time (NULL))
		{
			snprintf (buf, sizeof (buf), ""SSL handshake timed out"");
			EMIT_SIGNAL (XP_TE_CONNFAIL, serv->server_session, buf, NULL,
							 NULL, NULL, 0);
			server_cleanup (serv); /* ->connecting = FALSE */

			if (prefs.hex_net_auto_reconnectonfail)
				auto_reconnect (serv, FALSE, -1);

			return (0);				  /* remove it (0) */
		}

		return (1);					  /* call it more (1) */
	}
}
",C,"			{
				X509 *cert = SSL_get_peer_certificate (serv->ssl);
				int hostname_err;
				if ((hostname_err = _SSL_check_hostname(cert, serv->hostname)) != 0)
				{
					snprintf (buf, sizeof (buf), ""* Verify E: Failed to validate hostname? (%d)%s"",
							 hostname_err, serv->accept_invalid_cert ? "" -- Ignored"" : """");
					if (serv->accept_invalid_cert)
						EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL, 0);
					else
						goto conn_fail;
				}
				break;
			}
conn_fail:
","			break;
",,"@@ -723,9 +723,22 @@ ssl_do_connect (server * serv)
 		switch (verify_error)
 		{
 		case X509_V_OK:
+			{
+				X509 *cert = SSL_get_peer_certificate (serv->ssl);
+				int hostname_err;
+				if ((hostname_err = _SSL_check_hostname(cert, serv->hostname)) != 0)
+				{
+					snprintf (buf, sizeof (buf), ""* Verify E: Failed to validate hostname? (%d)%s"",
+							 hostname_err, serv->accept_invalid_cert ? "" -- Ignored"" : """");
+					if (serv->accept_invalid_cert)
+						EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL, 0);
+					else
+						goto conn_fail;
+				}
+				break;
+			}
 			/* snprintf (buf, sizeof (buf), ""* Verify OK (?)""); */
 			/* EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL, 0); */
-			break;
 		case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:
 		case X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE:
 		case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:
@@ -744,6 +757,7 @@ ssl_do_connect (server * serv)
 			snprintf (buf, sizeof (buf), ""%s.? (%d)"",
 						 X509_verify_cert_error_string (verify_error),
 						 verify_error);
+conn_fail:
 			EMIT_SIGNAL (XP_TE_CONNFAIL, serv->server_session, buf, NULL, NULL,
 							 NULL, 0);
 ",hexchat,c9b63f7f9be01692b03fa15275135a4910a7e02d,ebaaf466bf42aec26f05e71f06c39a0b19e32e77,1,"ssl_do_connect (server * serv)
{
	char buf[128];

	g_sess = serv->server_session;
	if (SSL_connect (serv->ssl) <= 0)
	{
		char err_buf[128];
		int err;

		g_sess = NULL;
		if ((err = ERR_get_error ()) > 0)
		{
			ERR_error_string (err, err_buf);
			snprintf (buf, sizeof (buf), ""(%d) %s"", err, err_buf);
			EMIT_SIGNAL (XP_TE_CONNFAIL, serv->server_session, buf, NULL,
							 NULL, NULL, 0);

			if (ERR_GET_REASON (err) == SSL_R_WRONG_VERSION_NUMBER)
				PrintText (serv->server_session, _(""Are you sure this is a SSL capable server and port?\n""));

			server_cleanup (serv);

			if (prefs.hex_net_auto_reconnectonfail)
				auto_reconnect (serv, FALSE, -1);

			return (0);				  /* remove it (0) */
		}
	}
	g_sess = NULL;

	if (SSL_is_init_finished (serv->ssl))
	{
		struct cert_info cert_info;
		struct chiper_info *chiper_info;
		int verify_error;
		int i;

		if (!_SSL_get_cert_info (&cert_info, serv->ssl))
		{
			snprintf (buf, sizeof (buf), ""* Certification info:"");
			EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
							 NULL, 0);
			snprintf (buf, sizeof (buf), ""  Subject:"");
			EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
							 NULL, 0);
			for (i = 0; cert_info.subject_word[i]; i++)
			{
				snprintf (buf, sizeof (buf), ""    %s"", cert_info.subject_word[i]);
				EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
								 NULL, 0);
			}
			snprintf (buf, sizeof (buf), ""  Issuer:"");
			EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
							 NULL, 0);
			for (i = 0; cert_info.issuer_word[i]; i++)
			{
				snprintf (buf, sizeof (buf), ""    %s"", cert_info.issuer_word[i]);
				EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
								 NULL, 0);
			}
			snprintf (buf, sizeof (buf), ""  Public key algorithm: %s (%d bits)"",
						 cert_info.algorithm, cert_info.algorithm_bits);
			EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
							 NULL, 0);
			/*if (cert_info.rsa_tmp_bits)
			{
				snprintf (buf, sizeof (buf),
							 ""  Public key algorithm uses ephemeral key with %d bits"",
							 cert_info.rsa_tmp_bits);
				EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
								 NULL, 0);
			}*/
			snprintf (buf, sizeof (buf), ""  Sign algorithm %s"",
						 cert_info.sign_algorithm/*, cert_info.sign_algorithm_bits*/);
			EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
							 NULL, 0);
			snprintf (buf, sizeof (buf), ""  Valid since %s to %s"",
						 cert_info.notbefore, cert_info.notafter);
			EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
							 NULL, 0);
		} else
		{
			snprintf (buf, sizeof (buf), "" * No Certificate"");
			EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
							 NULL, 0);
		}

		chiper_info = _SSL_get_cipher_info (serv->ssl);	/* static buffer */
		snprintf (buf, sizeof (buf), ""* Cipher info:"");
		EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL,
						 0);
		snprintf (buf, sizeof (buf), ""  Version: %s, cipher %s (%u bits)"",
					 chiper_info->version, chiper_info->chiper,
					 chiper_info->chiper_bits);
		EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL,
						 0);

		verify_error = SSL_get_verify_result (serv->ssl);
 		switch (verify_error)
 		{
 		case X509_V_OK:
//fix_flaw_line_below:
//			{
//fix_flaw_line_below:
//				X509 *cert = SSL_get_peer_certificate (serv->ssl);
//fix_flaw_line_below:
//				int hostname_err;
//fix_flaw_line_below:
//				if ((hostname_err = _SSL_check_hostname(cert, serv->hostname)) != 0)
//fix_flaw_line_below:
//				{
//fix_flaw_line_below:
//					snprintf (buf, sizeof (buf), ""* Verify E: Failed to validate hostname? (%d)%s"",
//fix_flaw_line_below:
//							 hostname_err, serv->accept_invalid_cert ? "" -- Ignored"" : """");
//fix_flaw_line_below:
//					if (serv->accept_invalid_cert)
//fix_flaw_line_below:
//						EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL, 0);
//fix_flaw_line_below:
//					else
//fix_flaw_line_below:
//						goto conn_fail;
//fix_flaw_line_below:
//				}
//fix_flaw_line_below:
//				break;
//fix_flaw_line_below:
//			}
 			/* snprintf (buf, sizeof (buf), ""* Verify OK (?)""); */
 			/* EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL, 0); */
//flaw_line_below:
			break;
 		case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:
 		case X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE:
 		case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:
		case X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN:
		case X509_V_ERR_CERT_HAS_EXPIRED:
			if (serv->accept_invalid_cert)
			{
				snprintf (buf, sizeof (buf), ""* Verify E: %s.? (%d) -- Ignored"",
							 X509_verify_cert_error_string (verify_error),
							 verify_error);
				EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL,
								 NULL, 0);
				break;
			}
		default:
 			snprintf (buf, sizeof (buf), ""%s.? (%d)"",
 						 X509_verify_cert_error_string (verify_error),
 						 verify_error);
//fix_flaw_line_below:
//conn_fail:
 			EMIT_SIGNAL (XP_TE_CONNFAIL, serv->server_session, buf, NULL, NULL,
 							 NULL, 0);
 
			server_cleanup (serv);

			return (0);
		}

		server_stopconnecting (serv);

		/* activate gtk poll */
		server_connected (serv);

		return (0);					  /* remove it (0) */
	} else
	{
		if (serv->ssl->session && serv->ssl->session->time + SSLTMOUT < time (NULL))
		{
			snprintf (buf, sizeof (buf), ""SSL handshake timed out"");
			EMIT_SIGNAL (XP_TE_CONNFAIL, serv->server_session, buf, NULL,
							 NULL, NULL, 0);
			server_cleanup (serv); /* ->connecting = FALSE */

			if (prefs.hex_net_auto_reconnectonfail)
				auto_reconnect (serv, FALSE, -1);

			return (0);				  /* remove it (0) */
		}

		return (1);					  /* call it more (1) */
	}
}
"
4214,181950,,Remote,Not required,,CVE-2016-7798,https://www.cvedetails.com/cve/CVE-2016-7798/,CWE-310,Low,Partial,,,2017-01-30,5.0,"The openssl gem for Ruby uses the same initialization vector (IV) in GCM Mode (aes-*-gcm) when the IV is set before the key, which makes it easier for context-dependent attackers to bypass the encryption protection mechanism.",2018-07-14,Bypass ,1,https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062,8108e0a6db133f3375608303fdd2083eb5115062,"cipher: don't set dummy encryption key in Cipher#initialize

Remove the encryption key initialization from Cipher#initialize. This
is effectively a revert of r32723 (""Avoid possible SEGV from AES
encryption/decryption"", 2011-07-28).

r32723, which added the key initialization, was a workaround for
Ruby Bug #2768. For some certain ciphers, calling EVP_CipherUpdate()
before setting an encryption key caused segfault. It was not a problem
until OpenSSL implemented GCM mode - the encryption key could be
overridden by repeated calls of EVP_CipherInit_ex(). But, it is not the
case for AES-GCM ciphers. Setting a key, an IV, a key, in this order
causes the IV to be reset to an all-zero IV.

The problem of Bug #2768 persists on the current versions of OpenSSL.
So, make Cipher#update raise an exception if a key is not yet set by the
user. Since encrypting or decrypting without key does not make any
sense, this should not break existing applications.

Users can still call Cipher#key= and Cipher#iv= multiple times with
their own responsibility.

Reference: https://bugs.ruby-lang.org/issues/2768
Reference: https://bugs.ruby-lang.org/issues/8221
Reference: https://github.com/ruby/openssl/issues/49",0,ext/openssl/ossl_cipher.c,"{""sha"": ""ffa080b555c09e6d24d341d5c1aff3818f93dbf9"", ""filename"": ""ext/openssl/ossl_cipher.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 12, ""changes"": 25, ""blob_url"": ""https://github.com/ruby/openssl/blob/8108e0a6db133f3375608303fdd2083eb5115062/ext/openssl/ossl_cipher.c"", ""raw_url"": ""https://github.com/ruby/openssl/raw/8108e0a6db133f3375608303fdd2083eb5115062/ext/openssl/ossl_cipher.c"", ""contents_url"": ""https://api.github.com/repos/ruby/openssl/contents/ext/openssl/ossl_cipher.c?ref=8108e0a6db133f3375608303fdd2083eb5115062"", ""patch"": ""@@ -36,7 +36,7 @@\n  */\n VALUE cCipher;\n VALUE eCipherError;\n-static ID id_auth_tag_len;\n+static ID id_auth_tag_len, id_key_set;\n \n static VALUE ossl_cipher_alloc(VALUE klass);\n static void ossl_cipher_free(void *ptr);\n@@ -118,7 +118,6 @@ ossl_cipher_initialize(VALUE self, VALUE str)\n     EVP_CIPHER_CTX *ctx;\n     const EVP_CIPHER *cipher;\n     char *name;\n-    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };\n \n     name = StringValueCStr(str);\n     GetCipherInit(self, ctx);\n@@ -129,16 +128,7 @@ ossl_cipher_initialize(VALUE self, VALUE str)\n     if (!(cipher = EVP_get_cipherbyname(name))) {\n \tossl_raise(rb_eRuntimeError, \""unsupported cipher algorithm (%\""PRIsVALUE\"")\"", str);\n     }\n-    /*\n-     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some\n-     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]\n-     *\n-     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows\n-     * uninitialized key, but other EVPs (such as AES) does not allow it.\n-     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we\n-     * set the data filled with \""\\0\"" as the key by default.\n-     */\n-    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)\n+    if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)\n \tossl_raise(eCipherError, NULL);\n \n     return self;\n@@ -251,6 +241,9 @@ ossl_cipher_init(int argc, VALUE *argv, VALUE self, int mode)\n \tossl_raise(eCipherError, NULL);\n     }\n \n+    if (p_key)\n+\trb_ivar_set(self, id_key_set, Qtrue);\n+\n     return self;\n }\n \n@@ -337,6 +330,8 @@ ossl_cipher_pkcs5_keyivgen(int argc, VALUE *argv, VALUE self)\n     OPENSSL_cleanse(key, sizeof key);\n     OPENSSL_cleanse(iv, sizeof iv);\n \n+    rb_ivar_set(self, id_key_set, Qtrue);\n+\n     return Qnil;\n }\n \n@@ -387,6 +382,9 @@ ossl_cipher_update(int argc, VALUE *argv, VALUE self)\n \n     rb_scan_args(argc, argv, \""11\"", &data, &str);\n \n+    if (!RTEST(rb_attr_get(self, id_key_set)))\n+\tossl_raise(eCipherError, \""key not set\"");\n+\n     StringValue(data);\n     in = (unsigned char *)RSTRING_PTR(data);\n     if ((in_len = RSTRING_LEN(data)) == 0)\n@@ -488,6 +486,8 @@ ossl_cipher_set_key(VALUE self, VALUE key)\n     if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)\n \tossl_raise(eCipherError, NULL);\n \n+    rb_ivar_set(self, id_key_set, Qtrue);\n+\n     return key;\n }\n \n@@ -1082,4 +1082,5 @@ Init_ossl_cipher(void)\n     rb_define_method(cCipher, \""padding=\"", ossl_cipher_set_padding, 1);\n \n     id_auth_tag_len = rb_intern_const(\""auth_tag_len\"");\n+    id_key_set = rb_intern_const(\""key_set\"");\n }""}<_**next**_>{""sha"": ""015bb56170498e65882040c8a480209ee509bc47"", ""filename"": ""test/test_cipher.rb"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 6, ""changes"": 29, ""blob_url"": ""https://github.com/ruby/openssl/blob/8108e0a6db133f3375608303fdd2083eb5115062/test/test_cipher.rb"", ""raw_url"": ""https://github.com/ruby/openssl/raw/8108e0a6db133f3375608303fdd2083eb5115062/test/test_cipher.rb"", ""contents_url"": ""https://api.github.com/repos/ruby/openssl/contents/test/test_cipher.rb?ref=8108e0a6db133f3375608303fdd2083eb5115062"", ""patch"": ""@@ -90,6 +90,7 @@ def test_key_iv_set\n \n   def test_empty_data\n     @c1.encrypt\n+    @c1.random_key\n     assert_raise(ArgumentError){ @c1.update(\""\"") }\n   end\n \n@@ -136,12 +137,10 @@ def test_AES\n     }\n   end\n \n-  def test_AES_crush\n-    500.times do\n-      assert_nothing_raised(\""[Bug #2768]\"") do\n-        # it caused OpenSSL SEGV by uninitialized key\n-        OpenSSL::Cipher::AES128.new(\""ECB\"").update \"".\"" * 17\n-      end\n+  def test_update_raise_if_key_not_set\n+    assert_raise(OpenSSL::Cipher::CipherError) do\n+      # it caused OpenSSL SEGV by uninitialized key [Bug #2768]\n+      OpenSSL::Cipher::AES128.new(\""ECB\"").update \"".\"" * 17\n     end\n   end\n \n@@ -317,6 +316,24 @@ def test_aes_ocb_tag_len\n     }\n   end if has_cipher?(\""aes-128-ocb\"")\n \n+  def test_aes_gcm_key_iv_order_issue\n+    pt = \""[ruby/openssl#49]\""\n+    cipher = OpenSSL::Cipher.new(\""aes-128-gcm\"").encrypt\n+    cipher.key = \""x\"" * 16\n+    cipher.iv = \""a\"" * 12\n+    ct1 = cipher.update(pt) << cipher.final\n+    tag1 = cipher.auth_tag\n+\n+    cipher = OpenSSL::Cipher.new(\""aes-128-gcm\"").encrypt\n+    cipher.iv = \""a\"" * 12\n+    cipher.key = \""x\"" * 16\n+    ct2 = cipher.update(pt) << cipher.final\n+    tag2 = cipher.auth_tag\n+\n+    assert_equal ct1, ct2\n+    assert_equal tag1, tag2\n+  end if has_cipher?(\""aes-128-gcm\"")\n+\n   private\n \n   def new_encryptor(algo)""}","Init_ossl_cipher(void)
{
#if 0
    mOSSL = rb_define_module(""OpenSSL"");
    eOSSLError = rb_define_class_under(mOSSL, ""OpenSSLError"", rb_eStandardError);
#endif

    /* Document-class: OpenSSL::Cipher
     *
     * Provides symmetric algorithms for encryption and decryption. The
     * algorithms that are available depend on the particular version
     * of OpenSSL that is installed.
     *
     * === Listing all supported algorithms
     *
     * A list of supported algorithms can be obtained by
     *
     *   puts OpenSSL::Cipher.ciphers
     *
     * === Instantiating a Cipher
     *
     * There are several ways to create a Cipher instance. Generally, a
     * Cipher algorithm is categorized by its name, the key length in bits
     * and the cipher mode to be used. The most generic way to create a
     * Cipher is the following
     *
     *   cipher = OpenSSL::Cipher.new('<name>-<key length>-<mode>')
     *
     * That is, a string consisting of the hyphenated concatenation of the
     * individual components name, key length and mode. Either all uppercase
     * or all lowercase strings may be used, for example:
     *
     *  cipher = OpenSSL::Cipher.new('AES-128-CBC')
     *
     * For each algorithm supported, there is a class defined under the
     * Cipher class that goes by the name of the cipher, e.g. to obtain an
     * instance of AES, you could also use
     *
     *   # these are equivalent
     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)
     *   cipher = OpenSSL::Cipher::AES.new(128, 'CBC')
     *   cipher = OpenSSL::Cipher::AES.new('128-CBC')
     *
     * Finally, due to its wide-spread use, there are also extra classes
     * defined for the different key sizes of AES
     *
     *   cipher = OpenSSL::Cipher::AES128.new(:CBC)
     *   cipher = OpenSSL::Cipher::AES192.new(:CBC)
     *   cipher = OpenSSL::Cipher::AES256.new(:CBC)
     *
     * === Choosing either encryption or decryption mode
     *
     * Encryption and decryption are often very similar operations for
     * symmetric algorithms, this is reflected by not having to choose
     * different classes for either operation, both can be done using the
     * same class. Still, after obtaining a Cipher instance, we need to
     * tell the instance what it is that we intend to do with it, so we
     * need to call either
     *
     *   cipher.encrypt
     *
     * or
     *
     *   cipher.decrypt
     *
     * on the Cipher instance. This should be the first call after creating
     * the instance, otherwise configuration that has already been set could
     * get lost in the process.
     *
     * === Choosing a key
     *
     * Symmetric encryption requires a key that is the same for the encrypting
     * and for the decrypting party and after initial key establishment should
     * be kept as private information. There are a lot of ways to create
     * insecure keys, the most notable is to simply take a password as the key
     * without processing the password further. A simple and secure way to
     * create a key for a particular Cipher is
     *
     *  cipher = OpenSSL::AES256.new(:CFB)
     *  cipher.encrypt
     *  key = cipher.random_key # also sets the generated key on the Cipher
     *
     * If you absolutely need to use passwords as encryption keys, you
     * should use Password-Based Key Derivation Function 2 (PBKDF2) by
     * generating the key with the help of the functionality provided by
     * OpenSSL::PKCS5.pbkdf2_hmac_sha1 or OpenSSL::PKCS5.pbkdf2_hmac.
     *
     * Although there is Cipher#pkcs5_keyivgen, its use is deprecated and
     * it should only be used in legacy applications because it does not use
     * the newer PKCS#5 v2 algorithms.
     *
     * === Choosing an IV
     *
     * The cipher modes CBC, CFB, OFB and CTR all need an ""initialization
     * vector"", or short, IV. ECB mode is the only mode that does not require
     * an IV, but there is almost no legitimate use case for this mode
     * because of the fact that it does not sufficiently hide plaintext
     * patterns. Therefore
     *
     * <b>You should never use ECB mode unless you are absolutely sure that
     * you absolutely need it</b>
     *
     * Because of this, you will end up with a mode that explicitly requires
     * an IV in any case. Note that for backwards compatibility reasons,
     * setting an IV is not explicitly mandated by the Cipher API. If not
     * set, OpenSSL itself defaults to an all-zeroes IV (""\\0"", not the
     * character). Although the IV can be seen as public information, i.e.
     * it may be transmitted in public once generated, it should still stay
     * unpredictable to prevent certain kinds of attacks. Therefore, ideally
     *
     * <b>Always create a secure random IV for every encryption of your
     * Cipher</b>
     *
     * A new, random IV should be created for every encryption of data. Think
     * of the IV as a nonce (number used once) - it's public but random and
     * unpredictable. A secure random IV can be created as follows
     *
     *   cipher = ...
     *   cipher.encrypt
     *   key = cipher.random_key
     *   iv = cipher.random_iv # also sets the generated IV on the Cipher
     *
     * Although the key is generally a random value, too, it is a bad choice
     * as an IV. There are elaborate ways how an attacker can take advantage
     * of such an IV. As a general rule of thumb, exposing the key directly
     * or indirectly should be avoided at all cost and exceptions only be
     * made with good reason.
     *
     * === Calling Cipher#final
     *
     * ECB (which should not be used) and CBC are both block-based modes.
     * This means that unlike for the other streaming-based modes, they
     * operate on fixed-size blocks of data, and therefore they require a
     * ""finalization"" step to produce or correctly decrypt the last block of
     * data by appropriately handling some form of padding. Therefore it is
     * essential to add the output of OpenSSL::Cipher#final to your
     * encryption/decryption buffer or you will end up with decryption errors
     * or truncated data.
     *
     * Although this is not really necessary for streaming-mode ciphers, it is
     * still recommended to apply the same pattern of adding the output of
     * Cipher#final there as well - it also enables you to switch between
     * modes more easily in the future.
     *
     * === Encrypting and decrypting some data
     *
     *   data = ""Very, very confidential data""
     *
     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)
     *   cipher.encrypt
     *   key = cipher.random_key
     *   iv = cipher.random_iv
     *
     *   encrypted = cipher.update(data) + cipher.final
     *   ...
     *   decipher = OpenSSL::Cipher::AES.new(128, :CBC)
     *   decipher.decrypt
     *   decipher.key = key
     *   decipher.iv = iv
     *
     *   plain = decipher.update(encrypted) + decipher.final
     *
     *   puts data == plain #=> true
     *
     * === Authenticated Encryption and Associated Data (AEAD)
     *
     * If the OpenSSL version used supports it, an Authenticated Encryption
     * mode (such as GCM or CCM) should always be preferred over any
     * unauthenticated mode. Currently, OpenSSL supports AE only in combination
     * with Associated Data (AEAD) where additional associated data is included
     * in the encryption process to compute a tag at the end of the encryption.
     * This tag will also be used in the decryption process and by verifying
     * its validity, the authenticity of a given ciphertext is established.
     *
     * This is superior to unauthenticated modes in that it allows to detect
     * if somebody effectively changed the ciphertext after it had been
     * encrypted. This prevents malicious modifications of the ciphertext that
     * could otherwise be exploited to modify ciphertexts in ways beneficial to
     * potential attackers.
     *
     * An associated data is used where there is additional information, such as
     * headers or some metadata, that must be also authenticated but not
     * necessarily need to be encrypted. If no associated data is needed for
     * encryption and later decryption, the OpenSSL library still requires a
     * value to be set - """" may be used in case none is available.
     *
     * An example using the GCM (Galois/Counter Mode). You have 16 bytes +key+,
     * 12 bytes (96 bits) +nonce+ and the associated data +auth_data+. Be sure
     * not to reuse the +key+ and +nonce+ pair. Reusing an nonce ruins the
     * security gurantees of GCM mode.
     *
     *   cipher = OpenSSL::Cipher::AES.new(128, :GCM).encrypt
     *   cipher.key = key
     *   cipher.iv = nonce
     *   cipher.auth_data = auth_data
     *
     *   encrypted = cipher.update(data) + cipher.final
     *   tag = cipher.auth_tag # produces 16 bytes tag by default
     *
     * Now you are the receiver. You know the +key+ and have received +nonce+,
     * +auth_data+, +encrypted+ and +tag+ through an untrusted network. Note
     * that GCM accepts an arbitrary length tag between 1 and 16 bytes. You may
     * additionally need to check that the received tag has the correct length,
     * or you allow attackers to forge a valid single byte tag for the tampered
     * ciphertext with a probability of 1/256.
     *
     *   raise ""tag is truncated!"" unless tag.bytesize == 16
     *   decipher = OpenSSL::Cipher::AES.new(128, :GCM).decrypt
     *   decipher.key = key
     *   decipher.iv = nonce
     *   decipher.auth_tag = tag
     *   decipher.auth_data = auth_data
     *
     *   decrypted = decipher.update(encrypted) + decipher.final
     *
     *   puts data == decrypted #=> true
     */
    cCipher = rb_define_class_under(mOSSL, ""Cipher"", rb_cObject);
    eCipherError = rb_define_class_under(cCipher, ""CipherError"", eOSSLError);

    rb_define_alloc_func(cCipher, ossl_cipher_alloc);
    rb_define_copy_func(cCipher, ossl_cipher_copy);
    rb_define_module_function(cCipher, ""ciphers"", ossl_s_ciphers, 0);
    rb_define_method(cCipher, ""initialize"", ossl_cipher_initialize, 1);
    rb_define_method(cCipher, ""reset"", ossl_cipher_reset, 0);
    rb_define_method(cCipher, ""encrypt"", ossl_cipher_encrypt, -1);
    rb_define_method(cCipher, ""decrypt"", ossl_cipher_decrypt, -1);
    rb_define_method(cCipher, ""pkcs5_keyivgen"", ossl_cipher_pkcs5_keyivgen, -1);
    rb_define_method(cCipher, ""update"", ossl_cipher_update, -1);
    rb_define_method(cCipher, ""final"", ossl_cipher_final, 0);
    rb_define_method(cCipher, ""name"", ossl_cipher_name, 0);
    rb_define_method(cCipher, ""key="", ossl_cipher_set_key, 1);
    rb_define_method(cCipher, ""auth_data="", ossl_cipher_set_auth_data, 1);
    rb_define_method(cCipher, ""auth_tag="", ossl_cipher_set_auth_tag, 1);
    rb_define_method(cCipher, ""auth_tag"", ossl_cipher_get_auth_tag, -1);
    rb_define_method(cCipher, ""auth_tag_len="", ossl_cipher_set_auth_tag_len, 1);
    rb_define_method(cCipher, ""authenticated?"", ossl_cipher_is_authenticated, 0);
    rb_define_method(cCipher, ""key_len="", ossl_cipher_set_key_length, 1);
    rb_define_method(cCipher, ""key_len"", ossl_cipher_key_length, 0);
    rb_define_method(cCipher, ""iv="", ossl_cipher_set_iv, 1);
    rb_define_method(cCipher, ""iv_len="", ossl_cipher_set_iv_length, 1);
    rb_define_method(cCipher, ""iv_len"", ossl_cipher_iv_length, 0);
    rb_define_method(cCipher, ""block_size"", ossl_cipher_block_size, 0);
     rb_define_method(cCipher, ""padding="", ossl_cipher_set_padding, 1);
 
     id_auth_tag_len = rb_intern_const(""auth_tag_len"");
    id_key_set = rb_intern_const(""key_set"");
 }
","Init_ossl_cipher(void)
{
#if 0
    mOSSL = rb_define_module(""OpenSSL"");
    eOSSLError = rb_define_class_under(mOSSL, ""OpenSSLError"", rb_eStandardError);
#endif

    /* Document-class: OpenSSL::Cipher
     *
     * Provides symmetric algorithms for encryption and decryption. The
     * algorithms that are available depend on the particular version
     * of OpenSSL that is installed.
     *
     * === Listing all supported algorithms
     *
     * A list of supported algorithms can be obtained by
     *
     *   puts OpenSSL::Cipher.ciphers
     *
     * === Instantiating a Cipher
     *
     * There are several ways to create a Cipher instance. Generally, a
     * Cipher algorithm is categorized by its name, the key length in bits
     * and the cipher mode to be used. The most generic way to create a
     * Cipher is the following
     *
     *   cipher = OpenSSL::Cipher.new('<name>-<key length>-<mode>')
     *
     * That is, a string consisting of the hyphenated concatenation of the
     * individual components name, key length and mode. Either all uppercase
     * or all lowercase strings may be used, for example:
     *
     *  cipher = OpenSSL::Cipher.new('AES-128-CBC')
     *
     * For each algorithm supported, there is a class defined under the
     * Cipher class that goes by the name of the cipher, e.g. to obtain an
     * instance of AES, you could also use
     *
     *   # these are equivalent
     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)
     *   cipher = OpenSSL::Cipher::AES.new(128, 'CBC')
     *   cipher = OpenSSL::Cipher::AES.new('128-CBC')
     *
     * Finally, due to its wide-spread use, there are also extra classes
     * defined for the different key sizes of AES
     *
     *   cipher = OpenSSL::Cipher::AES128.new(:CBC)
     *   cipher = OpenSSL::Cipher::AES192.new(:CBC)
     *   cipher = OpenSSL::Cipher::AES256.new(:CBC)
     *
     * === Choosing either encryption or decryption mode
     *
     * Encryption and decryption are often very similar operations for
     * symmetric algorithms, this is reflected by not having to choose
     * different classes for either operation, both can be done using the
     * same class. Still, after obtaining a Cipher instance, we need to
     * tell the instance what it is that we intend to do with it, so we
     * need to call either
     *
     *   cipher.encrypt
     *
     * or
     *
     *   cipher.decrypt
     *
     * on the Cipher instance. This should be the first call after creating
     * the instance, otherwise configuration that has already been set could
     * get lost in the process.
     *
     * === Choosing a key
     *
     * Symmetric encryption requires a key that is the same for the encrypting
     * and for the decrypting party and after initial key establishment should
     * be kept as private information. There are a lot of ways to create
     * insecure keys, the most notable is to simply take a password as the key
     * without processing the password further. A simple and secure way to
     * create a key for a particular Cipher is
     *
     *  cipher = OpenSSL::AES256.new(:CFB)
     *  cipher.encrypt
     *  key = cipher.random_key # also sets the generated key on the Cipher
     *
     * If you absolutely need to use passwords as encryption keys, you
     * should use Password-Based Key Derivation Function 2 (PBKDF2) by
     * generating the key with the help of the functionality provided by
     * OpenSSL::PKCS5.pbkdf2_hmac_sha1 or OpenSSL::PKCS5.pbkdf2_hmac.
     *
     * Although there is Cipher#pkcs5_keyivgen, its use is deprecated and
     * it should only be used in legacy applications because it does not use
     * the newer PKCS#5 v2 algorithms.
     *
     * === Choosing an IV
     *
     * The cipher modes CBC, CFB, OFB and CTR all need an ""initialization
     * vector"", or short, IV. ECB mode is the only mode that does not require
     * an IV, but there is almost no legitimate use case for this mode
     * because of the fact that it does not sufficiently hide plaintext
     * patterns. Therefore
     *
     * <b>You should never use ECB mode unless you are absolutely sure that
     * you absolutely need it</b>
     *
     * Because of this, you will end up with a mode that explicitly requires
     * an IV in any case. Note that for backwards compatibility reasons,
     * setting an IV is not explicitly mandated by the Cipher API. If not
     * set, OpenSSL itself defaults to an all-zeroes IV (""\\0"", not the
     * character). Although the IV can be seen as public information, i.e.
     * it may be transmitted in public once generated, it should still stay
     * unpredictable to prevent certain kinds of attacks. Therefore, ideally
     *
     * <b>Always create a secure random IV for every encryption of your
     * Cipher</b>
     *
     * A new, random IV should be created for every encryption of data. Think
     * of the IV as a nonce (number used once) - it's public but random and
     * unpredictable. A secure random IV can be created as follows
     *
     *   cipher = ...
     *   cipher.encrypt
     *   key = cipher.random_key
     *   iv = cipher.random_iv # also sets the generated IV on the Cipher
     *
     * Although the key is generally a random value, too, it is a bad choice
     * as an IV. There are elaborate ways how an attacker can take advantage
     * of such an IV. As a general rule of thumb, exposing the key directly
     * or indirectly should be avoided at all cost and exceptions only be
     * made with good reason.
     *
     * === Calling Cipher#final
     *
     * ECB (which should not be used) and CBC are both block-based modes.
     * This means that unlike for the other streaming-based modes, they
     * operate on fixed-size blocks of data, and therefore they require a
     * ""finalization"" step to produce or correctly decrypt the last block of
     * data by appropriately handling some form of padding. Therefore it is
     * essential to add the output of OpenSSL::Cipher#final to your
     * encryption/decryption buffer or you will end up with decryption errors
     * or truncated data.
     *
     * Although this is not really necessary for streaming-mode ciphers, it is
     * still recommended to apply the same pattern of adding the output of
     * Cipher#final there as well - it also enables you to switch between
     * modes more easily in the future.
     *
     * === Encrypting and decrypting some data
     *
     *   data = ""Very, very confidential data""
     *
     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)
     *   cipher.encrypt
     *   key = cipher.random_key
     *   iv = cipher.random_iv
     *
     *   encrypted = cipher.update(data) + cipher.final
     *   ...
     *   decipher = OpenSSL::Cipher::AES.new(128, :CBC)
     *   decipher.decrypt
     *   decipher.key = key
     *   decipher.iv = iv
     *
     *   plain = decipher.update(encrypted) + decipher.final
     *
     *   puts data == plain #=> true
     *
     * === Authenticated Encryption and Associated Data (AEAD)
     *
     * If the OpenSSL version used supports it, an Authenticated Encryption
     * mode (such as GCM or CCM) should always be preferred over any
     * unauthenticated mode. Currently, OpenSSL supports AE only in combination
     * with Associated Data (AEAD) where additional associated data is included
     * in the encryption process to compute a tag at the end of the encryption.
     * This tag will also be used in the decryption process and by verifying
     * its validity, the authenticity of a given ciphertext is established.
     *
     * This is superior to unauthenticated modes in that it allows to detect
     * if somebody effectively changed the ciphertext after it had been
     * encrypted. This prevents malicious modifications of the ciphertext that
     * could otherwise be exploited to modify ciphertexts in ways beneficial to
     * potential attackers.
     *
     * An associated data is used where there is additional information, such as
     * headers or some metadata, that must be also authenticated but not
     * necessarily need to be encrypted. If no associated data is needed for
     * encryption and later decryption, the OpenSSL library still requires a
     * value to be set - """" may be used in case none is available.
     *
     * An example using the GCM (Galois/Counter Mode). You have 16 bytes +key+,
     * 12 bytes (96 bits) +nonce+ and the associated data +auth_data+. Be sure
     * not to reuse the +key+ and +nonce+ pair. Reusing an nonce ruins the
     * security gurantees of GCM mode.
     *
     *   cipher = OpenSSL::Cipher::AES.new(128, :GCM).encrypt
     *   cipher.key = key
     *   cipher.iv = nonce
     *   cipher.auth_data = auth_data
     *
     *   encrypted = cipher.update(data) + cipher.final
     *   tag = cipher.auth_tag # produces 16 bytes tag by default
     *
     * Now you are the receiver. You know the +key+ and have received +nonce+,
     * +auth_data+, +encrypted+ and +tag+ through an untrusted network. Note
     * that GCM accepts an arbitrary length tag between 1 and 16 bytes. You may
     * additionally need to check that the received tag has the correct length,
     * or you allow attackers to forge a valid single byte tag for the tampered
     * ciphertext with a probability of 1/256.
     *
     *   raise ""tag is truncated!"" unless tag.bytesize == 16
     *   decipher = OpenSSL::Cipher::AES.new(128, :GCM).decrypt
     *   decipher.key = key
     *   decipher.iv = nonce
     *   decipher.auth_tag = tag
     *   decipher.auth_data = auth_data
     *
     *   decrypted = decipher.update(encrypted) + decipher.final
     *
     *   puts data == decrypted #=> true
     */
    cCipher = rb_define_class_under(mOSSL, ""Cipher"", rb_cObject);
    eCipherError = rb_define_class_under(cCipher, ""CipherError"", eOSSLError);

    rb_define_alloc_func(cCipher, ossl_cipher_alloc);
    rb_define_copy_func(cCipher, ossl_cipher_copy);
    rb_define_module_function(cCipher, ""ciphers"", ossl_s_ciphers, 0);
    rb_define_method(cCipher, ""initialize"", ossl_cipher_initialize, 1);
    rb_define_method(cCipher, ""reset"", ossl_cipher_reset, 0);
    rb_define_method(cCipher, ""encrypt"", ossl_cipher_encrypt, -1);
    rb_define_method(cCipher, ""decrypt"", ossl_cipher_decrypt, -1);
    rb_define_method(cCipher, ""pkcs5_keyivgen"", ossl_cipher_pkcs5_keyivgen, -1);
    rb_define_method(cCipher, ""update"", ossl_cipher_update, -1);
    rb_define_method(cCipher, ""final"", ossl_cipher_final, 0);
    rb_define_method(cCipher, ""name"", ossl_cipher_name, 0);
    rb_define_method(cCipher, ""key="", ossl_cipher_set_key, 1);
    rb_define_method(cCipher, ""auth_data="", ossl_cipher_set_auth_data, 1);
    rb_define_method(cCipher, ""auth_tag="", ossl_cipher_set_auth_tag, 1);
    rb_define_method(cCipher, ""auth_tag"", ossl_cipher_get_auth_tag, -1);
    rb_define_method(cCipher, ""auth_tag_len="", ossl_cipher_set_auth_tag_len, 1);
    rb_define_method(cCipher, ""authenticated?"", ossl_cipher_is_authenticated, 0);
    rb_define_method(cCipher, ""key_len="", ossl_cipher_set_key_length, 1);
    rb_define_method(cCipher, ""key_len"", ossl_cipher_key_length, 0);
    rb_define_method(cCipher, ""iv="", ossl_cipher_set_iv, 1);
    rb_define_method(cCipher, ""iv_len="", ossl_cipher_set_iv_length, 1);
    rb_define_method(cCipher, ""iv_len"", ossl_cipher_iv_length, 0);
    rb_define_method(cCipher, ""block_size"", ossl_cipher_block_size, 0);
     rb_define_method(cCipher, ""padding="", ossl_cipher_set_padding, 1);
 
     id_auth_tag_len = rb_intern_const(""auth_tag_len"");
 }
",C,"    id_key_set = rb_intern_const(""key_set"");
",,,"@@ -36,7 +36,7 @@
  */
 VALUE cCipher;
 VALUE eCipherError;
-static ID id_auth_tag_len;
+static ID id_auth_tag_len, id_key_set;
 
 static VALUE ossl_cipher_alloc(VALUE klass);
 static void ossl_cipher_free(void *ptr);
@@ -118,7 +118,6 @@ ossl_cipher_initialize(VALUE self, VALUE str)
     EVP_CIPHER_CTX *ctx;
     const EVP_CIPHER *cipher;
     char *name;
-    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };
 
     name = StringValueCStr(str);
     GetCipherInit(self, ctx);
@@ -129,16 +128,7 @@ ossl_cipher_initialize(VALUE self, VALUE str)
     if (!(cipher = EVP_get_cipherbyname(name))) {
 	ossl_raise(rb_eRuntimeError, ""unsupported cipher algorithm (%""PRIsVALUE"")"", str);
     }
-    /*
-     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some
-     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]
-     *
-     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows
-     * uninitialized key, but other EVPs (such as AES) does not allow it.
-     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we
-     * set the data filled with ""\0"" as the key by default.
-     */
-    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)
+    if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)
 	ossl_raise(eCipherError, NULL);
 
     return self;
@@ -251,6 +241,9 @@ ossl_cipher_init(int argc, VALUE *argv, VALUE self, int mode)
 	ossl_raise(eCipherError, NULL);
     }
 
+    if (p_key)
+	rb_ivar_set(self, id_key_set, Qtrue);
+
     return self;
 }
 
@@ -337,6 +330,8 @@ ossl_cipher_pkcs5_keyivgen(int argc, VALUE *argv, VALUE self)
     OPENSSL_cleanse(key, sizeof key);
     OPENSSL_cleanse(iv, sizeof iv);
 
+    rb_ivar_set(self, id_key_set, Qtrue);
+
     return Qnil;
 }
 
@@ -387,6 +382,9 @@ ossl_cipher_update(int argc, VALUE *argv, VALUE self)
 
     rb_scan_args(argc, argv, ""11"", &data, &str);
 
+    if (!RTEST(rb_attr_get(self, id_key_set)))
+	ossl_raise(eCipherError, ""key not set"");
+
     StringValue(data);
     in = (unsigned char *)RSTRING_PTR(data);
     if ((in_len = RSTRING_LEN(data)) == 0)
@@ -488,6 +486,8 @@ ossl_cipher_set_key(VALUE self, VALUE key)
     if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)
 	ossl_raise(eCipherError, NULL);
 
+    rb_ivar_set(self, id_key_set, Qtrue);
+
     return key;
 }
 
@@ -1082,4 +1082,5 @@ Init_ossl_cipher(void)
     rb_define_method(cCipher, ""padding="", ossl_cipher_set_padding, 1);
 
     id_auth_tag_len = rb_intern_const(""auth_tag_len"");
+    id_key_set = rb_intern_const(""key_set"");
 }",openssl,8108e0a6db133f3375608303fdd2083eb5115062,4eda40878fc42ac5bad6dd7b1ebc8f0eac796b94,1,"Init_ossl_cipher(void)
{
#if 0
    mOSSL = rb_define_module(""OpenSSL"");
    eOSSLError = rb_define_class_under(mOSSL, ""OpenSSLError"", rb_eStandardError);
#endif

    /* Document-class: OpenSSL::Cipher
     *
     * Provides symmetric algorithms for encryption and decryption. The
     * algorithms that are available depend on the particular version
     * of OpenSSL that is installed.
     *
     * === Listing all supported algorithms
     *
     * A list of supported algorithms can be obtained by
     *
     *   puts OpenSSL::Cipher.ciphers
     *
     * === Instantiating a Cipher
     *
     * There are several ways to create a Cipher instance. Generally, a
     * Cipher algorithm is categorized by its name, the key length in bits
     * and the cipher mode to be used. The most generic way to create a
     * Cipher is the following
     *
     *   cipher = OpenSSL::Cipher.new('<name>-<key length>-<mode>')
     *
     * That is, a string consisting of the hyphenated concatenation of the
     * individual components name, key length and mode. Either all uppercase
     * or all lowercase strings may be used, for example:
     *
     *  cipher = OpenSSL::Cipher.new('AES-128-CBC')
     *
     * For each algorithm supported, there is a class defined under the
     * Cipher class that goes by the name of the cipher, e.g. to obtain an
     * instance of AES, you could also use
     *
     *   # these are equivalent
     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)
     *   cipher = OpenSSL::Cipher::AES.new(128, 'CBC')
     *   cipher = OpenSSL::Cipher::AES.new('128-CBC')
     *
     * Finally, due to its wide-spread use, there are also extra classes
     * defined for the different key sizes of AES
     *
     *   cipher = OpenSSL::Cipher::AES128.new(:CBC)
     *   cipher = OpenSSL::Cipher::AES192.new(:CBC)
     *   cipher = OpenSSL::Cipher::AES256.new(:CBC)
     *
     * === Choosing either encryption or decryption mode
     *
     * Encryption and decryption are often very similar operations for
     * symmetric algorithms, this is reflected by not having to choose
     * different classes for either operation, both can be done using the
     * same class. Still, after obtaining a Cipher instance, we need to
     * tell the instance what it is that we intend to do with it, so we
     * need to call either
     *
     *   cipher.encrypt
     *
     * or
     *
     *   cipher.decrypt
     *
     * on the Cipher instance. This should be the first call after creating
     * the instance, otherwise configuration that has already been set could
     * get lost in the process.
     *
     * === Choosing a key
     *
     * Symmetric encryption requires a key that is the same for the encrypting
     * and for the decrypting party and after initial key establishment should
     * be kept as private information. There are a lot of ways to create
     * insecure keys, the most notable is to simply take a password as the key
     * without processing the password further. A simple and secure way to
     * create a key for a particular Cipher is
     *
     *  cipher = OpenSSL::AES256.new(:CFB)
     *  cipher.encrypt
     *  key = cipher.random_key # also sets the generated key on the Cipher
     *
     * If you absolutely need to use passwords as encryption keys, you
     * should use Password-Based Key Derivation Function 2 (PBKDF2) by
     * generating the key with the help of the functionality provided by
     * OpenSSL::PKCS5.pbkdf2_hmac_sha1 or OpenSSL::PKCS5.pbkdf2_hmac.
     *
     * Although there is Cipher#pkcs5_keyivgen, its use is deprecated and
     * it should only be used in legacy applications because it does not use
     * the newer PKCS#5 v2 algorithms.
     *
     * === Choosing an IV
     *
     * The cipher modes CBC, CFB, OFB and CTR all need an ""initialization
     * vector"", or short, IV. ECB mode is the only mode that does not require
     * an IV, but there is almost no legitimate use case for this mode
     * because of the fact that it does not sufficiently hide plaintext
     * patterns. Therefore
     *
     * <b>You should never use ECB mode unless you are absolutely sure that
     * you absolutely need it</b>
     *
     * Because of this, you will end up with a mode that explicitly requires
     * an IV in any case. Note that for backwards compatibility reasons,
     * setting an IV is not explicitly mandated by the Cipher API. If not
     * set, OpenSSL itself defaults to an all-zeroes IV (""\\0"", not the
     * character). Although the IV can be seen as public information, i.e.
     * it may be transmitted in public once generated, it should still stay
     * unpredictable to prevent certain kinds of attacks. Therefore, ideally
     *
     * <b>Always create a secure random IV for every encryption of your
     * Cipher</b>
     *
     * A new, random IV should be created for every encryption of data. Think
     * of the IV as a nonce (number used once) - it's public but random and
     * unpredictable. A secure random IV can be created as follows
     *
     *   cipher = ...
     *   cipher.encrypt
     *   key = cipher.random_key
     *   iv = cipher.random_iv # also sets the generated IV on the Cipher
     *
     * Although the key is generally a random value, too, it is a bad choice
     * as an IV. There are elaborate ways how an attacker can take advantage
     * of such an IV. As a general rule of thumb, exposing the key directly
     * or indirectly should be avoided at all cost and exceptions only be
     * made with good reason.
     *
     * === Calling Cipher#final
     *
     * ECB (which should not be used) and CBC are both block-based modes.
     * This means that unlike for the other streaming-based modes, they
     * operate on fixed-size blocks of data, and therefore they require a
     * ""finalization"" step to produce or correctly decrypt the last block of
     * data by appropriately handling some form of padding. Therefore it is
     * essential to add the output of OpenSSL::Cipher#final to your
     * encryption/decryption buffer or you will end up with decryption errors
     * or truncated data.
     *
     * Although this is not really necessary for streaming-mode ciphers, it is
     * still recommended to apply the same pattern of adding the output of
     * Cipher#final there as well - it also enables you to switch between
     * modes more easily in the future.
     *
     * === Encrypting and decrypting some data
     *
     *   data = ""Very, very confidential data""
     *
     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)
     *   cipher.encrypt
     *   key = cipher.random_key
     *   iv = cipher.random_iv
     *
     *   encrypted = cipher.update(data) + cipher.final
     *   ...
     *   decipher = OpenSSL::Cipher::AES.new(128, :CBC)
     *   decipher.decrypt
     *   decipher.key = key
     *   decipher.iv = iv
     *
     *   plain = decipher.update(encrypted) + decipher.final
     *
     *   puts data == plain #=> true
     *
     * === Authenticated Encryption and Associated Data (AEAD)
     *
     * If the OpenSSL version used supports it, an Authenticated Encryption
     * mode (such as GCM or CCM) should always be preferred over any
     * unauthenticated mode. Currently, OpenSSL supports AE only in combination
     * with Associated Data (AEAD) where additional associated data is included
     * in the encryption process to compute a tag at the end of the encryption.
     * This tag will also be used in the decryption process and by verifying
     * its validity, the authenticity of a given ciphertext is established.
     *
     * This is superior to unauthenticated modes in that it allows to detect
     * if somebody effectively changed the ciphertext after it had been
     * encrypted. This prevents malicious modifications of the ciphertext that
     * could otherwise be exploited to modify ciphertexts in ways beneficial to
     * potential attackers.
     *
     * An associated data is used where there is additional information, such as
     * headers or some metadata, that must be also authenticated but not
     * necessarily need to be encrypted. If no associated data is needed for
     * encryption and later decryption, the OpenSSL library still requires a
     * value to be set - """" may be used in case none is available.
     *
     * An example using the GCM (Galois/Counter Mode). You have 16 bytes +key+,
     * 12 bytes (96 bits) +nonce+ and the associated data +auth_data+. Be sure
     * not to reuse the +key+ and +nonce+ pair. Reusing an nonce ruins the
     * security gurantees of GCM mode.
     *
     *   cipher = OpenSSL::Cipher::AES.new(128, :GCM).encrypt
     *   cipher.key = key
     *   cipher.iv = nonce
     *   cipher.auth_data = auth_data
     *
     *   encrypted = cipher.update(data) + cipher.final
     *   tag = cipher.auth_tag # produces 16 bytes tag by default
     *
     * Now you are the receiver. You know the +key+ and have received +nonce+,
     * +auth_data+, +encrypted+ and +tag+ through an untrusted network. Note
     * that GCM accepts an arbitrary length tag between 1 and 16 bytes. You may
     * additionally need to check that the received tag has the correct length,
     * or you allow attackers to forge a valid single byte tag for the tampered
     * ciphertext with a probability of 1/256.
     *
     *   raise ""tag is truncated!"" unless tag.bytesize == 16
     *   decipher = OpenSSL::Cipher::AES.new(128, :GCM).decrypt
     *   decipher.key = key
     *   decipher.iv = nonce
     *   decipher.auth_tag = tag
     *   decipher.auth_data = auth_data
     *
     *   decrypted = decipher.update(encrypted) + decipher.final
     *
     *   puts data == decrypted #=> true
     */
    cCipher = rb_define_class_under(mOSSL, ""Cipher"", rb_cObject);
    eCipherError = rb_define_class_under(cCipher, ""CipherError"", eOSSLError);

    rb_define_alloc_func(cCipher, ossl_cipher_alloc);
    rb_define_copy_func(cCipher, ossl_cipher_copy);
    rb_define_module_function(cCipher, ""ciphers"", ossl_s_ciphers, 0);
    rb_define_method(cCipher, ""initialize"", ossl_cipher_initialize, 1);
    rb_define_method(cCipher, ""reset"", ossl_cipher_reset, 0);
    rb_define_method(cCipher, ""encrypt"", ossl_cipher_encrypt, -1);
    rb_define_method(cCipher, ""decrypt"", ossl_cipher_decrypt, -1);
    rb_define_method(cCipher, ""pkcs5_keyivgen"", ossl_cipher_pkcs5_keyivgen, -1);
    rb_define_method(cCipher, ""update"", ossl_cipher_update, -1);
    rb_define_method(cCipher, ""final"", ossl_cipher_final, 0);
    rb_define_method(cCipher, ""name"", ossl_cipher_name, 0);
    rb_define_method(cCipher, ""key="", ossl_cipher_set_key, 1);
    rb_define_method(cCipher, ""auth_data="", ossl_cipher_set_auth_data, 1);
    rb_define_method(cCipher, ""auth_tag="", ossl_cipher_set_auth_tag, 1);
    rb_define_method(cCipher, ""auth_tag"", ossl_cipher_get_auth_tag, -1);
    rb_define_method(cCipher, ""auth_tag_len="", ossl_cipher_set_auth_tag_len, 1);
    rb_define_method(cCipher, ""authenticated?"", ossl_cipher_is_authenticated, 0);
    rb_define_method(cCipher, ""key_len="", ossl_cipher_set_key_length, 1);
    rb_define_method(cCipher, ""key_len"", ossl_cipher_key_length, 0);
    rb_define_method(cCipher, ""iv="", ossl_cipher_set_iv, 1);
    rb_define_method(cCipher, ""iv_len="", ossl_cipher_set_iv_length, 1);
    rb_define_method(cCipher, ""iv_len"", ossl_cipher_iv_length, 0);
    rb_define_method(cCipher, ""block_size"", ossl_cipher_block_size, 0);
     rb_define_method(cCipher, ""padding="", ossl_cipher_set_padding, 1);
 
     id_auth_tag_len = rb_intern_const(""auth_tag_len"");
//fix_flaw_line_below:
//    id_key_set = rb_intern_const(""key_set"");
 }
"
4215,181951,,Remote,Not required,,CVE-2016-7798,https://www.cvedetails.com/cve/CVE-2016-7798/,CWE-310,Low,Partial,,,2017-01-30,5.0,"The openssl gem for Ruby uses the same initialization vector (IV) in GCM Mode (aes-*-gcm) when the IV is set before the key, which makes it easier for context-dependent attackers to bypass the encryption protection mechanism.",2018-07-14,Bypass ,3,https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062,8108e0a6db133f3375608303fdd2083eb5115062,"cipher: don't set dummy encryption key in Cipher#initialize

Remove the encryption key initialization from Cipher#initialize. This
is effectively a revert of r32723 (""Avoid possible SEGV from AES
encryption/decryption"", 2011-07-28).

r32723, which added the key initialization, was a workaround for
Ruby Bug #2768. For some certain ciphers, calling EVP_CipherUpdate()
before setting an encryption key caused segfault. It was not a problem
until OpenSSL implemented GCM mode - the encryption key could be
overridden by repeated calls of EVP_CipherInit_ex(). But, it is not the
case for AES-GCM ciphers. Setting a key, an IV, a key, in this order
causes the IV to be reset to an all-zero IV.

The problem of Bug #2768 persists on the current versions of OpenSSL.
So, make Cipher#update raise an exception if a key is not yet set by the
user. Since encrypting or decrypting without key does not make any
sense, this should not break existing applications.

Users can still call Cipher#key= and Cipher#iv= multiple times with
their own responsibility.

Reference: https://bugs.ruby-lang.org/issues/2768
Reference: https://bugs.ruby-lang.org/issues/8221
Reference: https://github.com/ruby/openssl/issues/49",0,ext/openssl/ossl_cipher.c,"{""sha"": ""ffa080b555c09e6d24d341d5c1aff3818f93dbf9"", ""filename"": ""ext/openssl/ossl_cipher.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 12, ""changes"": 25, ""blob_url"": ""https://github.com/ruby/openssl/blob/8108e0a6db133f3375608303fdd2083eb5115062/ext/openssl/ossl_cipher.c"", ""raw_url"": ""https://github.com/ruby/openssl/raw/8108e0a6db133f3375608303fdd2083eb5115062/ext/openssl/ossl_cipher.c"", ""contents_url"": ""https://api.github.com/repos/ruby/openssl/contents/ext/openssl/ossl_cipher.c?ref=8108e0a6db133f3375608303fdd2083eb5115062"", ""patch"": ""@@ -36,7 +36,7 @@\n  */\n VALUE cCipher;\n VALUE eCipherError;\n-static ID id_auth_tag_len;\n+static ID id_auth_tag_len, id_key_set;\n \n static VALUE ossl_cipher_alloc(VALUE klass);\n static void ossl_cipher_free(void *ptr);\n@@ -118,7 +118,6 @@ ossl_cipher_initialize(VALUE self, VALUE str)\n     EVP_CIPHER_CTX *ctx;\n     const EVP_CIPHER *cipher;\n     char *name;\n-    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };\n \n     name = StringValueCStr(str);\n     GetCipherInit(self, ctx);\n@@ -129,16 +128,7 @@ ossl_cipher_initialize(VALUE self, VALUE str)\n     if (!(cipher = EVP_get_cipherbyname(name))) {\n \tossl_raise(rb_eRuntimeError, \""unsupported cipher algorithm (%\""PRIsVALUE\"")\"", str);\n     }\n-    /*\n-     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some\n-     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]\n-     *\n-     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows\n-     * uninitialized key, but other EVPs (such as AES) does not allow it.\n-     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we\n-     * set the data filled with \""\\0\"" as the key by default.\n-     */\n-    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)\n+    if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)\n \tossl_raise(eCipherError, NULL);\n \n     return self;\n@@ -251,6 +241,9 @@ ossl_cipher_init(int argc, VALUE *argv, VALUE self, int mode)\n \tossl_raise(eCipherError, NULL);\n     }\n \n+    if (p_key)\n+\trb_ivar_set(self, id_key_set, Qtrue);\n+\n     return self;\n }\n \n@@ -337,6 +330,8 @@ ossl_cipher_pkcs5_keyivgen(int argc, VALUE *argv, VALUE self)\n     OPENSSL_cleanse(key, sizeof key);\n     OPENSSL_cleanse(iv, sizeof iv);\n \n+    rb_ivar_set(self, id_key_set, Qtrue);\n+\n     return Qnil;\n }\n \n@@ -387,6 +382,9 @@ ossl_cipher_update(int argc, VALUE *argv, VALUE self)\n \n     rb_scan_args(argc, argv, \""11\"", &data, &str);\n \n+    if (!RTEST(rb_attr_get(self, id_key_set)))\n+\tossl_raise(eCipherError, \""key not set\"");\n+\n     StringValue(data);\n     in = (unsigned char *)RSTRING_PTR(data);\n     if ((in_len = RSTRING_LEN(data)) == 0)\n@@ -488,6 +486,8 @@ ossl_cipher_set_key(VALUE self, VALUE key)\n     if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)\n \tossl_raise(eCipherError, NULL);\n \n+    rb_ivar_set(self, id_key_set, Qtrue);\n+\n     return key;\n }\n \n@@ -1082,4 +1082,5 @@ Init_ossl_cipher(void)\n     rb_define_method(cCipher, \""padding=\"", ossl_cipher_set_padding, 1);\n \n     id_auth_tag_len = rb_intern_const(\""auth_tag_len\"");\n+    id_key_set = rb_intern_const(\""key_set\"");\n }""}<_**next**_>{""sha"": ""015bb56170498e65882040c8a480209ee509bc47"", ""filename"": ""test/test_cipher.rb"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 6, ""changes"": 29, ""blob_url"": ""https://github.com/ruby/openssl/blob/8108e0a6db133f3375608303fdd2083eb5115062/test/test_cipher.rb"", ""raw_url"": ""https://github.com/ruby/openssl/raw/8108e0a6db133f3375608303fdd2083eb5115062/test/test_cipher.rb"", ""contents_url"": ""https://api.github.com/repos/ruby/openssl/contents/test/test_cipher.rb?ref=8108e0a6db133f3375608303fdd2083eb5115062"", ""patch"": ""@@ -90,6 +90,7 @@ def test_key_iv_set\n \n   def test_empty_data\n     @c1.encrypt\n+    @c1.random_key\n     assert_raise(ArgumentError){ @c1.update(\""\"") }\n   end\n \n@@ -136,12 +137,10 @@ def test_AES\n     }\n   end\n \n-  def test_AES_crush\n-    500.times do\n-      assert_nothing_raised(\""[Bug #2768]\"") do\n-        # it caused OpenSSL SEGV by uninitialized key\n-        OpenSSL::Cipher::AES128.new(\""ECB\"").update \"".\"" * 17\n-      end\n+  def test_update_raise_if_key_not_set\n+    assert_raise(OpenSSL::Cipher::CipherError) do\n+      # it caused OpenSSL SEGV by uninitialized key [Bug #2768]\n+      OpenSSL::Cipher::AES128.new(\""ECB\"").update \"".\"" * 17\n     end\n   end\n \n@@ -317,6 +316,24 @@ def test_aes_ocb_tag_len\n     }\n   end if has_cipher?(\""aes-128-ocb\"")\n \n+  def test_aes_gcm_key_iv_order_issue\n+    pt = \""[ruby/openssl#49]\""\n+    cipher = OpenSSL::Cipher.new(\""aes-128-gcm\"").encrypt\n+    cipher.key = \""x\"" * 16\n+    cipher.iv = \""a\"" * 12\n+    ct1 = cipher.update(pt) << cipher.final\n+    tag1 = cipher.auth_tag\n+\n+    cipher = OpenSSL::Cipher.new(\""aes-128-gcm\"").encrypt\n+    cipher.iv = \""a\"" * 12\n+    cipher.key = \""x\"" * 16\n+    ct2 = cipher.update(pt) << cipher.final\n+    tag2 = cipher.auth_tag\n+\n+    assert_equal ct1, ct2\n+    assert_equal tag1, tag2\n+  end if has_cipher?(\""aes-128-gcm\"")\n+\n   private\n \n   def new_encryptor(algo)""}","ossl_cipher_init(int argc, VALUE *argv, VALUE self, int mode)
{
    EVP_CIPHER_CTX *ctx;
    unsigned char key[EVP_MAX_KEY_LENGTH], *p_key = NULL;
    unsigned char iv[EVP_MAX_IV_LENGTH], *p_iv = NULL;
    VALUE pass, init_v;

    if(rb_scan_args(argc, argv, ""02"", &pass, &init_v) > 0){
	/*
	 * oops. this code mistakes salt for IV.
	 * We deprecated the arguments for this method, but we decided
	 * keeping this behaviour for backward compatibility.
	 */
	VALUE cname  = rb_class_path(rb_obj_class(self));
	rb_warn(""arguments for %""PRIsVALUE""#encrypt and %""PRIsVALUE""#decrypt were deprecated; ""
                ""use %""PRIsVALUE""#pkcs5_keyivgen to derive key and IV"",
                cname, cname, cname);
	StringValue(pass);
	GetCipher(self, ctx);
	if (NIL_P(init_v)) memcpy(iv, ""OpenSSL for Ruby rulez!"", sizeof(iv));
	else{
	    StringValue(init_v);
	    if (EVP_MAX_IV_LENGTH > RSTRING_LEN(init_v)) {
		memset(iv, 0, EVP_MAX_IV_LENGTH);
		memcpy(iv, RSTRING_PTR(init_v), RSTRING_LEN(init_v));
	    }
	    else memcpy(iv, RSTRING_PTR(init_v), sizeof(iv));
	}
	EVP_BytesToKey(EVP_CIPHER_CTX_cipher(ctx), EVP_md5(), iv,
		       (unsigned char *)RSTRING_PTR(pass), RSTRING_LENINT(pass), 1, key, NULL);
	p_key = key;
	p_iv = iv;
    }
    else {
	GetCipher(self, ctx);
    }
    if (EVP_CipherInit_ex(ctx, NULL, NULL, p_key, p_iv, mode) != 1) {
 	ossl_raise(eCipherError, NULL);
     }
 
    if (p_key)
	rb_ivar_set(self, id_key_set, Qtrue);

     return self;
 }
","ossl_cipher_init(int argc, VALUE *argv, VALUE self, int mode)
{
    EVP_CIPHER_CTX *ctx;
    unsigned char key[EVP_MAX_KEY_LENGTH], *p_key = NULL;
    unsigned char iv[EVP_MAX_IV_LENGTH], *p_iv = NULL;
    VALUE pass, init_v;

    if(rb_scan_args(argc, argv, ""02"", &pass, &init_v) > 0){
	/*
	 * oops. this code mistakes salt for IV.
	 * We deprecated the arguments for this method, but we decided
	 * keeping this behaviour for backward compatibility.
	 */
	VALUE cname  = rb_class_path(rb_obj_class(self));
	rb_warn(""arguments for %""PRIsVALUE""#encrypt and %""PRIsVALUE""#decrypt were deprecated; ""
                ""use %""PRIsVALUE""#pkcs5_keyivgen to derive key and IV"",
                cname, cname, cname);
	StringValue(pass);
	GetCipher(self, ctx);
	if (NIL_P(init_v)) memcpy(iv, ""OpenSSL for Ruby rulez!"", sizeof(iv));
	else{
	    StringValue(init_v);
	    if (EVP_MAX_IV_LENGTH > RSTRING_LEN(init_v)) {
		memset(iv, 0, EVP_MAX_IV_LENGTH);
		memcpy(iv, RSTRING_PTR(init_v), RSTRING_LEN(init_v));
	    }
	    else memcpy(iv, RSTRING_PTR(init_v), sizeof(iv));
	}
	EVP_BytesToKey(EVP_CIPHER_CTX_cipher(ctx), EVP_md5(), iv,
		       (unsigned char *)RSTRING_PTR(pass), RSTRING_LENINT(pass), 1, key, NULL);
	p_key = key;
	p_iv = iv;
    }
    else {
	GetCipher(self, ctx);
    }
    if (EVP_CipherInit_ex(ctx, NULL, NULL, p_key, p_iv, mode) != 1) {
 	ossl_raise(eCipherError, NULL);
     }
 
     return self;
 }
",C,"    if (p_key)
	rb_ivar_set(self, id_key_set, Qtrue);

",,,"@@ -36,7 +36,7 @@
  */
 VALUE cCipher;
 VALUE eCipherError;
-static ID id_auth_tag_len;
+static ID id_auth_tag_len, id_key_set;
 
 static VALUE ossl_cipher_alloc(VALUE klass);
 static void ossl_cipher_free(void *ptr);
@@ -118,7 +118,6 @@ ossl_cipher_initialize(VALUE self, VALUE str)
     EVP_CIPHER_CTX *ctx;
     const EVP_CIPHER *cipher;
     char *name;
-    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };
 
     name = StringValueCStr(str);
     GetCipherInit(self, ctx);
@@ -129,16 +128,7 @@ ossl_cipher_initialize(VALUE self, VALUE str)
     if (!(cipher = EVP_get_cipherbyname(name))) {
 	ossl_raise(rb_eRuntimeError, ""unsupported cipher algorithm (%""PRIsVALUE"")"", str);
     }
-    /*
-     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some
-     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]
-     *
-     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows
-     * uninitialized key, but other EVPs (such as AES) does not allow it.
-     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we
-     * set the data filled with ""\0"" as the key by default.
-     */
-    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)
+    if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)
 	ossl_raise(eCipherError, NULL);
 
     return self;
@@ -251,6 +241,9 @@ ossl_cipher_init(int argc, VALUE *argv, VALUE self, int mode)
 	ossl_raise(eCipherError, NULL);
     }
 
+    if (p_key)
+	rb_ivar_set(self, id_key_set, Qtrue);
+
     return self;
 }
 
@@ -337,6 +330,8 @@ ossl_cipher_pkcs5_keyivgen(int argc, VALUE *argv, VALUE self)
     OPENSSL_cleanse(key, sizeof key);
     OPENSSL_cleanse(iv, sizeof iv);
 
+    rb_ivar_set(self, id_key_set, Qtrue);
+
     return Qnil;
 }
 
@@ -387,6 +382,9 @@ ossl_cipher_update(int argc, VALUE *argv, VALUE self)
 
     rb_scan_args(argc, argv, ""11"", &data, &str);
 
+    if (!RTEST(rb_attr_get(self, id_key_set)))
+	ossl_raise(eCipherError, ""key not set"");
+
     StringValue(data);
     in = (unsigned char *)RSTRING_PTR(data);
     if ((in_len = RSTRING_LEN(data)) == 0)
@@ -488,6 +486,8 @@ ossl_cipher_set_key(VALUE self, VALUE key)
     if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)
 	ossl_raise(eCipherError, NULL);
 
+    rb_ivar_set(self, id_key_set, Qtrue);
+
     return key;
 }
 
@@ -1082,4 +1082,5 @@ Init_ossl_cipher(void)
     rb_define_method(cCipher, ""padding="", ossl_cipher_set_padding, 1);
 
     id_auth_tag_len = rb_intern_const(""auth_tag_len"");
+    id_key_set = rb_intern_const(""key_set"");
 }",openssl,8108e0a6db133f3375608303fdd2083eb5115062,4eda40878fc42ac5bad6dd7b1ebc8f0eac796b94,1,"ossl_cipher_init(int argc, VALUE *argv, VALUE self, int mode)
{
    EVP_CIPHER_CTX *ctx;
    unsigned char key[EVP_MAX_KEY_LENGTH], *p_key = NULL;
    unsigned char iv[EVP_MAX_IV_LENGTH], *p_iv = NULL;
    VALUE pass, init_v;

    if(rb_scan_args(argc, argv, ""02"", &pass, &init_v) > 0){
	/*
	 * oops. this code mistakes salt for IV.
	 * We deprecated the arguments for this method, but we decided
	 * keeping this behaviour for backward compatibility.
	 */
	VALUE cname  = rb_class_path(rb_obj_class(self));
	rb_warn(""arguments for %""PRIsVALUE""#encrypt and %""PRIsVALUE""#decrypt were deprecated; ""
                ""use %""PRIsVALUE""#pkcs5_keyivgen to derive key and IV"",
                cname, cname, cname);
	StringValue(pass);
	GetCipher(self, ctx);
	if (NIL_P(init_v)) memcpy(iv, ""OpenSSL for Ruby rulez!"", sizeof(iv));
	else{
	    StringValue(init_v);
	    if (EVP_MAX_IV_LENGTH > RSTRING_LEN(init_v)) {
		memset(iv, 0, EVP_MAX_IV_LENGTH);
		memcpy(iv, RSTRING_PTR(init_v), RSTRING_LEN(init_v));
	    }
	    else memcpy(iv, RSTRING_PTR(init_v), sizeof(iv));
	}
	EVP_BytesToKey(EVP_CIPHER_CTX_cipher(ctx), EVP_md5(), iv,
		       (unsigned char *)RSTRING_PTR(pass), RSTRING_LENINT(pass), 1, key, NULL);
	p_key = key;
	p_iv = iv;
    }
    else {
	GetCipher(self, ctx);
    }
    if (EVP_CipherInit_ex(ctx, NULL, NULL, p_key, p_iv, mode) != 1) {
 	ossl_raise(eCipherError, NULL);
     }
 
//fix_flaw_line_below:
//    if (p_key)
//fix_flaw_line_below:
//	rb_ivar_set(self, id_key_set, Qtrue);
//fix_flaw_line_below:
//
     return self;
 }
"
4216,181952,,Remote,Not required,,CVE-2016-7798,https://www.cvedetails.com/cve/CVE-2016-7798/,CWE-310,Low,Partial,,,2017-01-30,5.0,"The openssl gem for Ruby uses the same initialization vector (IV) in GCM Mode (aes-*-gcm) when the IV is set before the key, which makes it easier for context-dependent attackers to bypass the encryption protection mechanism.",2018-07-14,Bypass ,1,https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062,8108e0a6db133f3375608303fdd2083eb5115062,"cipher: don't set dummy encryption key in Cipher#initialize

Remove the encryption key initialization from Cipher#initialize. This
is effectively a revert of r32723 (""Avoid possible SEGV from AES
encryption/decryption"", 2011-07-28).

r32723, which added the key initialization, was a workaround for
Ruby Bug #2768. For some certain ciphers, calling EVP_CipherUpdate()
before setting an encryption key caused segfault. It was not a problem
until OpenSSL implemented GCM mode - the encryption key could be
overridden by repeated calls of EVP_CipherInit_ex(). But, it is not the
case for AES-GCM ciphers. Setting a key, an IV, a key, in this order
causes the IV to be reset to an all-zero IV.

The problem of Bug #2768 persists on the current versions of OpenSSL.
So, make Cipher#update raise an exception if a key is not yet set by the
user. Since encrypting or decrypting without key does not make any
sense, this should not break existing applications.

Users can still call Cipher#key= and Cipher#iv= multiple times with
their own responsibility.

Reference: https://bugs.ruby-lang.org/issues/2768
Reference: https://bugs.ruby-lang.org/issues/8221
Reference: https://github.com/ruby/openssl/issues/49",11,ext/openssl/ossl_cipher.c,"{""sha"": ""ffa080b555c09e6d24d341d5c1aff3818f93dbf9"", ""filename"": ""ext/openssl/ossl_cipher.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 12, ""changes"": 25, ""blob_url"": ""https://github.com/ruby/openssl/blob/8108e0a6db133f3375608303fdd2083eb5115062/ext/openssl/ossl_cipher.c"", ""raw_url"": ""https://github.com/ruby/openssl/raw/8108e0a6db133f3375608303fdd2083eb5115062/ext/openssl/ossl_cipher.c"", ""contents_url"": ""https://api.github.com/repos/ruby/openssl/contents/ext/openssl/ossl_cipher.c?ref=8108e0a6db133f3375608303fdd2083eb5115062"", ""patch"": ""@@ -36,7 +36,7 @@\n  */\n VALUE cCipher;\n VALUE eCipherError;\n-static ID id_auth_tag_len;\n+static ID id_auth_tag_len, id_key_set;\n \n static VALUE ossl_cipher_alloc(VALUE klass);\n static void ossl_cipher_free(void *ptr);\n@@ -118,7 +118,6 @@ ossl_cipher_initialize(VALUE self, VALUE str)\n     EVP_CIPHER_CTX *ctx;\n     const EVP_CIPHER *cipher;\n     char *name;\n-    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };\n \n     name = StringValueCStr(str);\n     GetCipherInit(self, ctx);\n@@ -129,16 +128,7 @@ ossl_cipher_initialize(VALUE self, VALUE str)\n     if (!(cipher = EVP_get_cipherbyname(name))) {\n \tossl_raise(rb_eRuntimeError, \""unsupported cipher algorithm (%\""PRIsVALUE\"")\"", str);\n     }\n-    /*\n-     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some\n-     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]\n-     *\n-     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows\n-     * uninitialized key, but other EVPs (such as AES) does not allow it.\n-     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we\n-     * set the data filled with \""\\0\"" as the key by default.\n-     */\n-    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)\n+    if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)\n \tossl_raise(eCipherError, NULL);\n \n     return self;\n@@ -251,6 +241,9 @@ ossl_cipher_init(int argc, VALUE *argv, VALUE self, int mode)\n \tossl_raise(eCipherError, NULL);\n     }\n \n+    if (p_key)\n+\trb_ivar_set(self, id_key_set, Qtrue);\n+\n     return self;\n }\n \n@@ -337,6 +330,8 @@ ossl_cipher_pkcs5_keyivgen(int argc, VALUE *argv, VALUE self)\n     OPENSSL_cleanse(key, sizeof key);\n     OPENSSL_cleanse(iv, sizeof iv);\n \n+    rb_ivar_set(self, id_key_set, Qtrue);\n+\n     return Qnil;\n }\n \n@@ -387,6 +382,9 @@ ossl_cipher_update(int argc, VALUE *argv, VALUE self)\n \n     rb_scan_args(argc, argv, \""11\"", &data, &str);\n \n+    if (!RTEST(rb_attr_get(self, id_key_set)))\n+\tossl_raise(eCipherError, \""key not set\"");\n+\n     StringValue(data);\n     in = (unsigned char *)RSTRING_PTR(data);\n     if ((in_len = RSTRING_LEN(data)) == 0)\n@@ -488,6 +486,8 @@ ossl_cipher_set_key(VALUE self, VALUE key)\n     if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)\n \tossl_raise(eCipherError, NULL);\n \n+    rb_ivar_set(self, id_key_set, Qtrue);\n+\n     return key;\n }\n \n@@ -1082,4 +1082,5 @@ Init_ossl_cipher(void)\n     rb_define_method(cCipher, \""padding=\"", ossl_cipher_set_padding, 1);\n \n     id_auth_tag_len = rb_intern_const(\""auth_tag_len\"");\n+    id_key_set = rb_intern_const(\""key_set\"");\n }""}<_**next**_>{""sha"": ""015bb56170498e65882040c8a480209ee509bc47"", ""filename"": ""test/test_cipher.rb"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 6, ""changes"": 29, ""blob_url"": ""https://github.com/ruby/openssl/blob/8108e0a6db133f3375608303fdd2083eb5115062/test/test_cipher.rb"", ""raw_url"": ""https://github.com/ruby/openssl/raw/8108e0a6db133f3375608303fdd2083eb5115062/test/test_cipher.rb"", ""contents_url"": ""https://api.github.com/repos/ruby/openssl/contents/test/test_cipher.rb?ref=8108e0a6db133f3375608303fdd2083eb5115062"", ""patch"": ""@@ -90,6 +90,7 @@ def test_key_iv_set\n \n   def test_empty_data\n     @c1.encrypt\n+    @c1.random_key\n     assert_raise(ArgumentError){ @c1.update(\""\"") }\n   end\n \n@@ -136,12 +137,10 @@ def test_AES\n     }\n   end\n \n-  def test_AES_crush\n-    500.times do\n-      assert_nothing_raised(\""[Bug #2768]\"") do\n-        # it caused OpenSSL SEGV by uninitialized key\n-        OpenSSL::Cipher::AES128.new(\""ECB\"").update \"".\"" * 17\n-      end\n+  def test_update_raise_if_key_not_set\n+    assert_raise(OpenSSL::Cipher::CipherError) do\n+      # it caused OpenSSL SEGV by uninitialized key [Bug #2768]\n+      OpenSSL::Cipher::AES128.new(\""ECB\"").update \"".\"" * 17\n     end\n   end\n \n@@ -317,6 +316,24 @@ def test_aes_ocb_tag_len\n     }\n   end if has_cipher?(\""aes-128-ocb\"")\n \n+  def test_aes_gcm_key_iv_order_issue\n+    pt = \""[ruby/openssl#49]\""\n+    cipher = OpenSSL::Cipher.new(\""aes-128-gcm\"").encrypt\n+    cipher.key = \""x\"" * 16\n+    cipher.iv = \""a\"" * 12\n+    ct1 = cipher.update(pt) << cipher.final\n+    tag1 = cipher.auth_tag\n+\n+    cipher = OpenSSL::Cipher.new(\""aes-128-gcm\"").encrypt\n+    cipher.iv = \""a\"" * 12\n+    cipher.key = \""x\"" * 16\n+    ct2 = cipher.update(pt) << cipher.final\n+    tag2 = cipher.auth_tag\n+\n+    assert_equal ct1, ct2\n+    assert_equal tag1, tag2\n+  end if has_cipher?(\""aes-128-gcm\"")\n+\n   private\n \n   def new_encryptor(algo)""}","ossl_cipher_initialize(VALUE self, VALUE str)
{
     EVP_CIPHER_CTX *ctx;
     const EVP_CIPHER *cipher;
     char *name;
 
     name = StringValueCStr(str);
     GetCipherInit(self, ctx);
    if (ctx) {
	ossl_raise(rb_eRuntimeError, ""Cipher already inititalized!"");
    }
    AllocCipher(self, ctx);
     if (!(cipher = EVP_get_cipherbyname(name))) {
 	ossl_raise(rb_eRuntimeError, ""unsupported cipher algorithm (%""PRIsVALUE"")"", str);
     }
    if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)
 	ossl_raise(eCipherError, NULL);
 
     return self;
}
","ossl_cipher_initialize(VALUE self, VALUE str)
{
     EVP_CIPHER_CTX *ctx;
     const EVP_CIPHER *cipher;
     char *name;
    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };
 
     name = StringValueCStr(str);
     GetCipherInit(self, ctx);
    if (ctx) {
	ossl_raise(rb_eRuntimeError, ""Cipher already inititalized!"");
    }
    AllocCipher(self, ctx);
     if (!(cipher = EVP_get_cipherbyname(name))) {
 	ossl_raise(rb_eRuntimeError, ""unsupported cipher algorithm (%""PRIsVALUE"")"", str);
     }
    /*
     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some
     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]
     *
     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows
     * uninitialized key, but other EVPs (such as AES) does not allow it.
     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we
     * set the data filled with ""\0"" as the key by default.
     */
    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)
 	ossl_raise(eCipherError, NULL);
 
     return self;
}
",C,"    if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)
","    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };
    /*
     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some
     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]
     *
     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows
     * uninitialized key, but other EVPs (such as AES) does not allow it.
     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we
     * set the data filled with ""\0"" as the key by default.
     */
    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)
",,"@@ -36,7 +36,7 @@
  */
 VALUE cCipher;
 VALUE eCipherError;
-static ID id_auth_tag_len;
+static ID id_auth_tag_len, id_key_set;
 
 static VALUE ossl_cipher_alloc(VALUE klass);
 static void ossl_cipher_free(void *ptr);
@@ -118,7 +118,6 @@ ossl_cipher_initialize(VALUE self, VALUE str)
     EVP_CIPHER_CTX *ctx;
     const EVP_CIPHER *cipher;
     char *name;
-    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };
 
     name = StringValueCStr(str);
     GetCipherInit(self, ctx);
@@ -129,16 +128,7 @@ ossl_cipher_initialize(VALUE self, VALUE str)
     if (!(cipher = EVP_get_cipherbyname(name))) {
 	ossl_raise(rb_eRuntimeError, ""unsupported cipher algorithm (%""PRIsVALUE"")"", str);
     }
-    /*
-     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some
-     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]
-     *
-     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows
-     * uninitialized key, but other EVPs (such as AES) does not allow it.
-     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we
-     * set the data filled with ""\0"" as the key by default.
-     */
-    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)
+    if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)
 	ossl_raise(eCipherError, NULL);
 
     return self;
@@ -251,6 +241,9 @@ ossl_cipher_init(int argc, VALUE *argv, VALUE self, int mode)
 	ossl_raise(eCipherError, NULL);
     }
 
+    if (p_key)
+	rb_ivar_set(self, id_key_set, Qtrue);
+
     return self;
 }
 
@@ -337,6 +330,8 @@ ossl_cipher_pkcs5_keyivgen(int argc, VALUE *argv, VALUE self)
     OPENSSL_cleanse(key, sizeof key);
     OPENSSL_cleanse(iv, sizeof iv);
 
+    rb_ivar_set(self, id_key_set, Qtrue);
+
     return Qnil;
 }
 
@@ -387,6 +382,9 @@ ossl_cipher_update(int argc, VALUE *argv, VALUE self)
 
     rb_scan_args(argc, argv, ""11"", &data, &str);
 
+    if (!RTEST(rb_attr_get(self, id_key_set)))
+	ossl_raise(eCipherError, ""key not set"");
+
     StringValue(data);
     in = (unsigned char *)RSTRING_PTR(data);
     if ((in_len = RSTRING_LEN(data)) == 0)
@@ -488,6 +486,8 @@ ossl_cipher_set_key(VALUE self, VALUE key)
     if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)
 	ossl_raise(eCipherError, NULL);
 
+    rb_ivar_set(self, id_key_set, Qtrue);
+
     return key;
 }
 
@@ -1082,4 +1082,5 @@ Init_ossl_cipher(void)
     rb_define_method(cCipher, ""padding="", ossl_cipher_set_padding, 1);
 
     id_auth_tag_len = rb_intern_const(""auth_tag_len"");
+    id_key_set = rb_intern_const(""key_set"");
 }",openssl,8108e0a6db133f3375608303fdd2083eb5115062,4eda40878fc42ac5bad6dd7b1ebc8f0eac796b94,1,"ossl_cipher_initialize(VALUE self, VALUE str)
{
     EVP_CIPHER_CTX *ctx;
     const EVP_CIPHER *cipher;
     char *name;
//flaw_line_below:
    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };
 
     name = StringValueCStr(str);
     GetCipherInit(self, ctx);
    if (ctx) {
	ossl_raise(rb_eRuntimeError, ""Cipher already inititalized!"");
    }
    AllocCipher(self, ctx);
     if (!(cipher = EVP_get_cipherbyname(name))) {
 	ossl_raise(rb_eRuntimeError, ""unsupported cipher algorithm (%""PRIsVALUE"")"", str);
     }
//flaw_line_below:
    /*
//flaw_line_below:
     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some
//flaw_line_below:
     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]
//flaw_line_below:
     *
//flaw_line_below:
     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows
//flaw_line_below:
     * uninitialized key, but other EVPs (such as AES) does not allow it.
//flaw_line_below:
     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we
//flaw_line_below:
     * set the data filled with ""\0"" as the key by default.
//flaw_line_below:
     */
//flaw_line_below:
    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)
//fix_flaw_line_below:
//    if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)
 	ossl_raise(eCipherError, NULL);
 
     return self;
}
"
4217,181953,,Remote,Not required,,CVE-2016-7798,https://www.cvedetails.com/cve/CVE-2016-7798/,CWE-310,Low,Partial,,,2017-01-30,5.0,"The openssl gem for Ruby uses the same initialization vector (IV) in GCM Mode (aes-*-gcm) when the IV is set before the key, which makes it easier for context-dependent attackers to bypass the encryption protection mechanism.",2018-07-14,Bypass ,2,https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062,8108e0a6db133f3375608303fdd2083eb5115062,"cipher: don't set dummy encryption key in Cipher#initialize

Remove the encryption key initialization from Cipher#initialize. This
is effectively a revert of r32723 (""Avoid possible SEGV from AES
encryption/decryption"", 2011-07-28).

r32723, which added the key initialization, was a workaround for
Ruby Bug #2768. For some certain ciphers, calling EVP_CipherUpdate()
before setting an encryption key caused segfault. It was not a problem
until OpenSSL implemented GCM mode - the encryption key could be
overridden by repeated calls of EVP_CipherInit_ex(). But, it is not the
case for AES-GCM ciphers. Setting a key, an IV, a key, in this order
causes the IV to be reset to an all-zero IV.

The problem of Bug #2768 persists on the current versions of OpenSSL.
So, make Cipher#update raise an exception if a key is not yet set by the
user. Since encrypting or decrypting without key does not make any
sense, this should not break existing applications.

Users can still call Cipher#key= and Cipher#iv= multiple times with
their own responsibility.

Reference: https://bugs.ruby-lang.org/issues/2768
Reference: https://bugs.ruby-lang.org/issues/8221
Reference: https://github.com/ruby/openssl/issues/49",0,ext/openssl/ossl_cipher.c,"{""sha"": ""ffa080b555c09e6d24d341d5c1aff3818f93dbf9"", ""filename"": ""ext/openssl/ossl_cipher.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 12, ""changes"": 25, ""blob_url"": ""https://github.com/ruby/openssl/blob/8108e0a6db133f3375608303fdd2083eb5115062/ext/openssl/ossl_cipher.c"", ""raw_url"": ""https://github.com/ruby/openssl/raw/8108e0a6db133f3375608303fdd2083eb5115062/ext/openssl/ossl_cipher.c"", ""contents_url"": ""https://api.github.com/repos/ruby/openssl/contents/ext/openssl/ossl_cipher.c?ref=8108e0a6db133f3375608303fdd2083eb5115062"", ""patch"": ""@@ -36,7 +36,7 @@\n  */\n VALUE cCipher;\n VALUE eCipherError;\n-static ID id_auth_tag_len;\n+static ID id_auth_tag_len, id_key_set;\n \n static VALUE ossl_cipher_alloc(VALUE klass);\n static void ossl_cipher_free(void *ptr);\n@@ -118,7 +118,6 @@ ossl_cipher_initialize(VALUE self, VALUE str)\n     EVP_CIPHER_CTX *ctx;\n     const EVP_CIPHER *cipher;\n     char *name;\n-    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };\n \n     name = StringValueCStr(str);\n     GetCipherInit(self, ctx);\n@@ -129,16 +128,7 @@ ossl_cipher_initialize(VALUE self, VALUE str)\n     if (!(cipher = EVP_get_cipherbyname(name))) {\n \tossl_raise(rb_eRuntimeError, \""unsupported cipher algorithm (%\""PRIsVALUE\"")\"", str);\n     }\n-    /*\n-     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some\n-     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]\n-     *\n-     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows\n-     * uninitialized key, but other EVPs (such as AES) does not allow it.\n-     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we\n-     * set the data filled with \""\\0\"" as the key by default.\n-     */\n-    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)\n+    if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)\n \tossl_raise(eCipherError, NULL);\n \n     return self;\n@@ -251,6 +241,9 @@ ossl_cipher_init(int argc, VALUE *argv, VALUE self, int mode)\n \tossl_raise(eCipherError, NULL);\n     }\n \n+    if (p_key)\n+\trb_ivar_set(self, id_key_set, Qtrue);\n+\n     return self;\n }\n \n@@ -337,6 +330,8 @@ ossl_cipher_pkcs5_keyivgen(int argc, VALUE *argv, VALUE self)\n     OPENSSL_cleanse(key, sizeof key);\n     OPENSSL_cleanse(iv, sizeof iv);\n \n+    rb_ivar_set(self, id_key_set, Qtrue);\n+\n     return Qnil;\n }\n \n@@ -387,6 +382,9 @@ ossl_cipher_update(int argc, VALUE *argv, VALUE self)\n \n     rb_scan_args(argc, argv, \""11\"", &data, &str);\n \n+    if (!RTEST(rb_attr_get(self, id_key_set)))\n+\tossl_raise(eCipherError, \""key not set\"");\n+\n     StringValue(data);\n     in = (unsigned char *)RSTRING_PTR(data);\n     if ((in_len = RSTRING_LEN(data)) == 0)\n@@ -488,6 +486,8 @@ ossl_cipher_set_key(VALUE self, VALUE key)\n     if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)\n \tossl_raise(eCipherError, NULL);\n \n+    rb_ivar_set(self, id_key_set, Qtrue);\n+\n     return key;\n }\n \n@@ -1082,4 +1082,5 @@ Init_ossl_cipher(void)\n     rb_define_method(cCipher, \""padding=\"", ossl_cipher_set_padding, 1);\n \n     id_auth_tag_len = rb_intern_const(\""auth_tag_len\"");\n+    id_key_set = rb_intern_const(\""key_set\"");\n }""}<_**next**_>{""sha"": ""015bb56170498e65882040c8a480209ee509bc47"", ""filename"": ""test/test_cipher.rb"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 6, ""changes"": 29, ""blob_url"": ""https://github.com/ruby/openssl/blob/8108e0a6db133f3375608303fdd2083eb5115062/test/test_cipher.rb"", ""raw_url"": ""https://github.com/ruby/openssl/raw/8108e0a6db133f3375608303fdd2083eb5115062/test/test_cipher.rb"", ""contents_url"": ""https://api.github.com/repos/ruby/openssl/contents/test/test_cipher.rb?ref=8108e0a6db133f3375608303fdd2083eb5115062"", ""patch"": ""@@ -90,6 +90,7 @@ def test_key_iv_set\n \n   def test_empty_data\n     @c1.encrypt\n+    @c1.random_key\n     assert_raise(ArgumentError){ @c1.update(\""\"") }\n   end\n \n@@ -136,12 +137,10 @@ def test_AES\n     }\n   end\n \n-  def test_AES_crush\n-    500.times do\n-      assert_nothing_raised(\""[Bug #2768]\"") do\n-        # it caused OpenSSL SEGV by uninitialized key\n-        OpenSSL::Cipher::AES128.new(\""ECB\"").update \"".\"" * 17\n-      end\n+  def test_update_raise_if_key_not_set\n+    assert_raise(OpenSSL::Cipher::CipherError) do\n+      # it caused OpenSSL SEGV by uninitialized key [Bug #2768]\n+      OpenSSL::Cipher::AES128.new(\""ECB\"").update \"".\"" * 17\n     end\n   end\n \n@@ -317,6 +316,24 @@ def test_aes_ocb_tag_len\n     }\n   end if has_cipher?(\""aes-128-ocb\"")\n \n+  def test_aes_gcm_key_iv_order_issue\n+    pt = \""[ruby/openssl#49]\""\n+    cipher = OpenSSL::Cipher.new(\""aes-128-gcm\"").encrypt\n+    cipher.key = \""x\"" * 16\n+    cipher.iv = \""a\"" * 12\n+    ct1 = cipher.update(pt) << cipher.final\n+    tag1 = cipher.auth_tag\n+\n+    cipher = OpenSSL::Cipher.new(\""aes-128-gcm\"").encrypt\n+    cipher.iv = \""a\"" * 12\n+    cipher.key = \""x\"" * 16\n+    ct2 = cipher.update(pt) << cipher.final\n+    tag2 = cipher.auth_tag\n+\n+    assert_equal ct1, ct2\n+    assert_equal tag1, tag2\n+  end if has_cipher?(\""aes-128-gcm\"")\n+\n   private\n \n   def new_encryptor(algo)""}","ossl_cipher_pkcs5_keyivgen(int argc, VALUE *argv, VALUE self)
{
    EVP_CIPHER_CTX *ctx;
    const EVP_MD *digest;
    VALUE vpass, vsalt, viter, vdigest;
    unsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH], *salt = NULL;
    int iter;

    rb_scan_args(argc, argv, ""13"", &vpass, &vsalt, &viter, &vdigest);
    StringValue(vpass);
    if(!NIL_P(vsalt)){
	StringValue(vsalt);
	if(RSTRING_LEN(vsalt) != PKCS5_SALT_LEN)
	    ossl_raise(eCipherError, ""salt must be an 8-octet string"");
	salt = (unsigned char *)RSTRING_PTR(vsalt);
    }
    iter = NIL_P(viter) ? 2048 : NUM2INT(viter);
    digest = NIL_P(vdigest) ? EVP_md5() : GetDigestPtr(vdigest);
    GetCipher(self, ctx);
    EVP_BytesToKey(EVP_CIPHER_CTX_cipher(ctx), digest, salt,
		   (unsigned char *)RSTRING_PTR(vpass), RSTRING_LENINT(vpass), iter, key, iv);
    if (EVP_CipherInit_ex(ctx, NULL, NULL, key, iv, -1) != 1)
	ossl_raise(eCipherError, NULL);
     OPENSSL_cleanse(key, sizeof key);
     OPENSSL_cleanse(iv, sizeof iv);
 
    rb_ivar_set(self, id_key_set, Qtrue);

     return Qnil;
 }
","ossl_cipher_pkcs5_keyivgen(int argc, VALUE *argv, VALUE self)
{
    EVP_CIPHER_CTX *ctx;
    const EVP_MD *digest;
    VALUE vpass, vsalt, viter, vdigest;
    unsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH], *salt = NULL;
    int iter;

    rb_scan_args(argc, argv, ""13"", &vpass, &vsalt, &viter, &vdigest);
    StringValue(vpass);
    if(!NIL_P(vsalt)){
	StringValue(vsalt);
	if(RSTRING_LEN(vsalt) != PKCS5_SALT_LEN)
	    ossl_raise(eCipherError, ""salt must be an 8-octet string"");
	salt = (unsigned char *)RSTRING_PTR(vsalt);
    }
    iter = NIL_P(viter) ? 2048 : NUM2INT(viter);
    digest = NIL_P(vdigest) ? EVP_md5() : GetDigestPtr(vdigest);
    GetCipher(self, ctx);
    EVP_BytesToKey(EVP_CIPHER_CTX_cipher(ctx), digest, salt,
		   (unsigned char *)RSTRING_PTR(vpass), RSTRING_LENINT(vpass), iter, key, iv);
    if (EVP_CipherInit_ex(ctx, NULL, NULL, key, iv, -1) != 1)
	ossl_raise(eCipherError, NULL);
     OPENSSL_cleanse(key, sizeof key);
     OPENSSL_cleanse(iv, sizeof iv);
 
     return Qnil;
 }
",C,"    rb_ivar_set(self, id_key_set, Qtrue);

",,,"@@ -36,7 +36,7 @@
  */
 VALUE cCipher;
 VALUE eCipherError;
-static ID id_auth_tag_len;
+static ID id_auth_tag_len, id_key_set;
 
 static VALUE ossl_cipher_alloc(VALUE klass);
 static void ossl_cipher_free(void *ptr);
@@ -118,7 +118,6 @@ ossl_cipher_initialize(VALUE self, VALUE str)
     EVP_CIPHER_CTX *ctx;
     const EVP_CIPHER *cipher;
     char *name;
-    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };
 
     name = StringValueCStr(str);
     GetCipherInit(self, ctx);
@@ -129,16 +128,7 @@ ossl_cipher_initialize(VALUE self, VALUE str)
     if (!(cipher = EVP_get_cipherbyname(name))) {
 	ossl_raise(rb_eRuntimeError, ""unsupported cipher algorithm (%""PRIsVALUE"")"", str);
     }
-    /*
-     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some
-     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]
-     *
-     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows
-     * uninitialized key, but other EVPs (such as AES) does not allow it.
-     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we
-     * set the data filled with ""\0"" as the key by default.
-     */
-    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)
+    if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)
 	ossl_raise(eCipherError, NULL);
 
     return self;
@@ -251,6 +241,9 @@ ossl_cipher_init(int argc, VALUE *argv, VALUE self, int mode)
 	ossl_raise(eCipherError, NULL);
     }
 
+    if (p_key)
+	rb_ivar_set(self, id_key_set, Qtrue);
+
     return self;
 }
 
@@ -337,6 +330,8 @@ ossl_cipher_pkcs5_keyivgen(int argc, VALUE *argv, VALUE self)
     OPENSSL_cleanse(key, sizeof key);
     OPENSSL_cleanse(iv, sizeof iv);
 
+    rb_ivar_set(self, id_key_set, Qtrue);
+
     return Qnil;
 }
 
@@ -387,6 +382,9 @@ ossl_cipher_update(int argc, VALUE *argv, VALUE self)
 
     rb_scan_args(argc, argv, ""11"", &data, &str);
 
+    if (!RTEST(rb_attr_get(self, id_key_set)))
+	ossl_raise(eCipherError, ""key not set"");
+
     StringValue(data);
     in = (unsigned char *)RSTRING_PTR(data);
     if ((in_len = RSTRING_LEN(data)) == 0)
@@ -488,6 +486,8 @@ ossl_cipher_set_key(VALUE self, VALUE key)
     if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)
 	ossl_raise(eCipherError, NULL);
 
+    rb_ivar_set(self, id_key_set, Qtrue);
+
     return key;
 }
 
@@ -1082,4 +1082,5 @@ Init_ossl_cipher(void)
     rb_define_method(cCipher, ""padding="", ossl_cipher_set_padding, 1);
 
     id_auth_tag_len = rb_intern_const(""auth_tag_len"");
+    id_key_set = rb_intern_const(""key_set"");
 }",openssl,8108e0a6db133f3375608303fdd2083eb5115062,4eda40878fc42ac5bad6dd7b1ebc8f0eac796b94,1,"ossl_cipher_pkcs5_keyivgen(int argc, VALUE *argv, VALUE self)
{
    EVP_CIPHER_CTX *ctx;
    const EVP_MD *digest;
    VALUE vpass, vsalt, viter, vdigest;
    unsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH], *salt = NULL;
    int iter;

    rb_scan_args(argc, argv, ""13"", &vpass, &vsalt, &viter, &vdigest);
    StringValue(vpass);
    if(!NIL_P(vsalt)){
	StringValue(vsalt);
	if(RSTRING_LEN(vsalt) != PKCS5_SALT_LEN)
	    ossl_raise(eCipherError, ""salt must be an 8-octet string"");
	salt = (unsigned char *)RSTRING_PTR(vsalt);
    }
    iter = NIL_P(viter) ? 2048 : NUM2INT(viter);
    digest = NIL_P(vdigest) ? EVP_md5() : GetDigestPtr(vdigest);
    GetCipher(self, ctx);
    EVP_BytesToKey(EVP_CIPHER_CTX_cipher(ctx), digest, salt,
		   (unsigned char *)RSTRING_PTR(vpass), RSTRING_LENINT(vpass), iter, key, iv);
    if (EVP_CipherInit_ex(ctx, NULL, NULL, key, iv, -1) != 1)
	ossl_raise(eCipherError, NULL);
     OPENSSL_cleanse(key, sizeof key);
     OPENSSL_cleanse(iv, sizeof iv);
 
//fix_flaw_line_below:
//    rb_ivar_set(self, id_key_set, Qtrue);
//fix_flaw_line_below:
//
     return Qnil;
 }
"
4218,181954,,Remote,Not required,,CVE-2016-7798,https://www.cvedetails.com/cve/CVE-2016-7798/,CWE-310,Low,Partial,,,2017-01-30,5.0,"The openssl gem for Ruby uses the same initialization vector (IV) in GCM Mode (aes-*-gcm) when the IV is set before the key, which makes it easier for context-dependent attackers to bypass the encryption protection mechanism.",2018-07-14,Bypass ,2,https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062,8108e0a6db133f3375608303fdd2083eb5115062,"cipher: don't set dummy encryption key in Cipher#initialize

Remove the encryption key initialization from Cipher#initialize. This
is effectively a revert of r32723 (""Avoid possible SEGV from AES
encryption/decryption"", 2011-07-28).

r32723, which added the key initialization, was a workaround for
Ruby Bug #2768. For some certain ciphers, calling EVP_CipherUpdate()
before setting an encryption key caused segfault. It was not a problem
until OpenSSL implemented GCM mode - the encryption key could be
overridden by repeated calls of EVP_CipherInit_ex(). But, it is not the
case for AES-GCM ciphers. Setting a key, an IV, a key, in this order
causes the IV to be reset to an all-zero IV.

The problem of Bug #2768 persists on the current versions of OpenSSL.
So, make Cipher#update raise an exception if a key is not yet set by the
user. Since encrypting or decrypting without key does not make any
sense, this should not break existing applications.

Users can still call Cipher#key= and Cipher#iv= multiple times with
their own responsibility.

Reference: https://bugs.ruby-lang.org/issues/2768
Reference: https://bugs.ruby-lang.org/issues/8221
Reference: https://github.com/ruby/openssl/issues/49",0,ext/openssl/ossl_cipher.c,"{""sha"": ""ffa080b555c09e6d24d341d5c1aff3818f93dbf9"", ""filename"": ""ext/openssl/ossl_cipher.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 12, ""changes"": 25, ""blob_url"": ""https://github.com/ruby/openssl/blob/8108e0a6db133f3375608303fdd2083eb5115062/ext/openssl/ossl_cipher.c"", ""raw_url"": ""https://github.com/ruby/openssl/raw/8108e0a6db133f3375608303fdd2083eb5115062/ext/openssl/ossl_cipher.c"", ""contents_url"": ""https://api.github.com/repos/ruby/openssl/contents/ext/openssl/ossl_cipher.c?ref=8108e0a6db133f3375608303fdd2083eb5115062"", ""patch"": ""@@ -36,7 +36,7 @@\n  */\n VALUE cCipher;\n VALUE eCipherError;\n-static ID id_auth_tag_len;\n+static ID id_auth_tag_len, id_key_set;\n \n static VALUE ossl_cipher_alloc(VALUE klass);\n static void ossl_cipher_free(void *ptr);\n@@ -118,7 +118,6 @@ ossl_cipher_initialize(VALUE self, VALUE str)\n     EVP_CIPHER_CTX *ctx;\n     const EVP_CIPHER *cipher;\n     char *name;\n-    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };\n \n     name = StringValueCStr(str);\n     GetCipherInit(self, ctx);\n@@ -129,16 +128,7 @@ ossl_cipher_initialize(VALUE self, VALUE str)\n     if (!(cipher = EVP_get_cipherbyname(name))) {\n \tossl_raise(rb_eRuntimeError, \""unsupported cipher algorithm (%\""PRIsVALUE\"")\"", str);\n     }\n-    /*\n-     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some\n-     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]\n-     *\n-     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows\n-     * uninitialized key, but other EVPs (such as AES) does not allow it.\n-     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we\n-     * set the data filled with \""\\0\"" as the key by default.\n-     */\n-    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)\n+    if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)\n \tossl_raise(eCipherError, NULL);\n \n     return self;\n@@ -251,6 +241,9 @@ ossl_cipher_init(int argc, VALUE *argv, VALUE self, int mode)\n \tossl_raise(eCipherError, NULL);\n     }\n \n+    if (p_key)\n+\trb_ivar_set(self, id_key_set, Qtrue);\n+\n     return self;\n }\n \n@@ -337,6 +330,8 @@ ossl_cipher_pkcs5_keyivgen(int argc, VALUE *argv, VALUE self)\n     OPENSSL_cleanse(key, sizeof key);\n     OPENSSL_cleanse(iv, sizeof iv);\n \n+    rb_ivar_set(self, id_key_set, Qtrue);\n+\n     return Qnil;\n }\n \n@@ -387,6 +382,9 @@ ossl_cipher_update(int argc, VALUE *argv, VALUE self)\n \n     rb_scan_args(argc, argv, \""11\"", &data, &str);\n \n+    if (!RTEST(rb_attr_get(self, id_key_set)))\n+\tossl_raise(eCipherError, \""key not set\"");\n+\n     StringValue(data);\n     in = (unsigned char *)RSTRING_PTR(data);\n     if ((in_len = RSTRING_LEN(data)) == 0)\n@@ -488,6 +486,8 @@ ossl_cipher_set_key(VALUE self, VALUE key)\n     if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)\n \tossl_raise(eCipherError, NULL);\n \n+    rb_ivar_set(self, id_key_set, Qtrue);\n+\n     return key;\n }\n \n@@ -1082,4 +1082,5 @@ Init_ossl_cipher(void)\n     rb_define_method(cCipher, \""padding=\"", ossl_cipher_set_padding, 1);\n \n     id_auth_tag_len = rb_intern_const(\""auth_tag_len\"");\n+    id_key_set = rb_intern_const(\""key_set\"");\n }""}<_**next**_>{""sha"": ""015bb56170498e65882040c8a480209ee509bc47"", ""filename"": ""test/test_cipher.rb"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 6, ""changes"": 29, ""blob_url"": ""https://github.com/ruby/openssl/blob/8108e0a6db133f3375608303fdd2083eb5115062/test/test_cipher.rb"", ""raw_url"": ""https://github.com/ruby/openssl/raw/8108e0a6db133f3375608303fdd2083eb5115062/test/test_cipher.rb"", ""contents_url"": ""https://api.github.com/repos/ruby/openssl/contents/test/test_cipher.rb?ref=8108e0a6db133f3375608303fdd2083eb5115062"", ""patch"": ""@@ -90,6 +90,7 @@ def test_key_iv_set\n \n   def test_empty_data\n     @c1.encrypt\n+    @c1.random_key\n     assert_raise(ArgumentError){ @c1.update(\""\"") }\n   end\n \n@@ -136,12 +137,10 @@ def test_AES\n     }\n   end\n \n-  def test_AES_crush\n-    500.times do\n-      assert_nothing_raised(\""[Bug #2768]\"") do\n-        # it caused OpenSSL SEGV by uninitialized key\n-        OpenSSL::Cipher::AES128.new(\""ECB\"").update \"".\"" * 17\n-      end\n+  def test_update_raise_if_key_not_set\n+    assert_raise(OpenSSL::Cipher::CipherError) do\n+      # it caused OpenSSL SEGV by uninitialized key [Bug #2768]\n+      OpenSSL::Cipher::AES128.new(\""ECB\"").update \"".\"" * 17\n     end\n   end\n \n@@ -317,6 +316,24 @@ def test_aes_ocb_tag_len\n     }\n   end if has_cipher?(\""aes-128-ocb\"")\n \n+  def test_aes_gcm_key_iv_order_issue\n+    pt = \""[ruby/openssl#49]\""\n+    cipher = OpenSSL::Cipher.new(\""aes-128-gcm\"").encrypt\n+    cipher.key = \""x\"" * 16\n+    cipher.iv = \""a\"" * 12\n+    ct1 = cipher.update(pt) << cipher.final\n+    tag1 = cipher.auth_tag\n+\n+    cipher = OpenSSL::Cipher.new(\""aes-128-gcm\"").encrypt\n+    cipher.iv = \""a\"" * 12\n+    cipher.key = \""x\"" * 16\n+    ct2 = cipher.update(pt) << cipher.final\n+    tag2 = cipher.auth_tag\n+\n+    assert_equal ct1, ct2\n+    assert_equal tag1, tag2\n+  end if has_cipher?(\""aes-128-gcm\"")\n+\n   private\n \n   def new_encryptor(algo)""}","ossl_cipher_set_key(VALUE self, VALUE key)
{
    EVP_CIPHER_CTX *ctx;
    int key_len;

    StringValue(key);
    GetCipher(self, ctx);

    key_len = EVP_CIPHER_CTX_key_length(ctx);
    if (RSTRING_LEN(key) != key_len)
	ossl_raise(rb_eArgError, ""key must be %d bytes"", key_len);

     if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)
 	ossl_raise(eCipherError, NULL);
 
    rb_ivar_set(self, id_key_set, Qtrue);

     return key;
 }
","ossl_cipher_set_key(VALUE self, VALUE key)
{
    EVP_CIPHER_CTX *ctx;
    int key_len;

    StringValue(key);
    GetCipher(self, ctx);

    key_len = EVP_CIPHER_CTX_key_length(ctx);
    if (RSTRING_LEN(key) != key_len)
	ossl_raise(rb_eArgError, ""key must be %d bytes"", key_len);

     if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)
 	ossl_raise(eCipherError, NULL);
 
     return key;
 }
",C,"    rb_ivar_set(self, id_key_set, Qtrue);

",,,"@@ -36,7 +36,7 @@
  */
 VALUE cCipher;
 VALUE eCipherError;
-static ID id_auth_tag_len;
+static ID id_auth_tag_len, id_key_set;
 
 static VALUE ossl_cipher_alloc(VALUE klass);
 static void ossl_cipher_free(void *ptr);
@@ -118,7 +118,6 @@ ossl_cipher_initialize(VALUE self, VALUE str)
     EVP_CIPHER_CTX *ctx;
     const EVP_CIPHER *cipher;
     char *name;
-    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };
 
     name = StringValueCStr(str);
     GetCipherInit(self, ctx);
@@ -129,16 +128,7 @@ ossl_cipher_initialize(VALUE self, VALUE str)
     if (!(cipher = EVP_get_cipherbyname(name))) {
 	ossl_raise(rb_eRuntimeError, ""unsupported cipher algorithm (%""PRIsVALUE"")"", str);
     }
-    /*
-     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some
-     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]
-     *
-     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows
-     * uninitialized key, but other EVPs (such as AES) does not allow it.
-     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we
-     * set the data filled with ""\0"" as the key by default.
-     */
-    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)
+    if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)
 	ossl_raise(eCipherError, NULL);
 
     return self;
@@ -251,6 +241,9 @@ ossl_cipher_init(int argc, VALUE *argv, VALUE self, int mode)
 	ossl_raise(eCipherError, NULL);
     }
 
+    if (p_key)
+	rb_ivar_set(self, id_key_set, Qtrue);
+
     return self;
 }
 
@@ -337,6 +330,8 @@ ossl_cipher_pkcs5_keyivgen(int argc, VALUE *argv, VALUE self)
     OPENSSL_cleanse(key, sizeof key);
     OPENSSL_cleanse(iv, sizeof iv);
 
+    rb_ivar_set(self, id_key_set, Qtrue);
+
     return Qnil;
 }
 
@@ -387,6 +382,9 @@ ossl_cipher_update(int argc, VALUE *argv, VALUE self)
 
     rb_scan_args(argc, argv, ""11"", &data, &str);
 
+    if (!RTEST(rb_attr_get(self, id_key_set)))
+	ossl_raise(eCipherError, ""key not set"");
+
     StringValue(data);
     in = (unsigned char *)RSTRING_PTR(data);
     if ((in_len = RSTRING_LEN(data)) == 0)
@@ -488,6 +486,8 @@ ossl_cipher_set_key(VALUE self, VALUE key)
     if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)
 	ossl_raise(eCipherError, NULL);
 
+    rb_ivar_set(self, id_key_set, Qtrue);
+
     return key;
 }
 
@@ -1082,4 +1082,5 @@ Init_ossl_cipher(void)
     rb_define_method(cCipher, ""padding="", ossl_cipher_set_padding, 1);
 
     id_auth_tag_len = rb_intern_const(""auth_tag_len"");
+    id_key_set = rb_intern_const(""key_set"");
 }",openssl,8108e0a6db133f3375608303fdd2083eb5115062,4eda40878fc42ac5bad6dd7b1ebc8f0eac796b94,1,"ossl_cipher_set_key(VALUE self, VALUE key)
{
    EVP_CIPHER_CTX *ctx;
    int key_len;

    StringValue(key);
    GetCipher(self, ctx);

    key_len = EVP_CIPHER_CTX_key_length(ctx);
    if (RSTRING_LEN(key) != key_len)
	ossl_raise(rb_eArgError, ""key must be %d bytes"", key_len);

     if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)
 	ossl_raise(eCipherError, NULL);
 
//fix_flaw_line_below:
//    rb_ivar_set(self, id_key_set, Qtrue);
//fix_flaw_line_below:
//
     return key;
 }
"
4219,181955,,Remote,Not required,,CVE-2016-7798,https://www.cvedetails.com/cve/CVE-2016-7798/,CWE-310,Low,Partial,,,2017-01-30,5.0,"The openssl gem for Ruby uses the same initialization vector (IV) in GCM Mode (aes-*-gcm) when the IV is set before the key, which makes it easier for context-dependent attackers to bypass the encryption protection mechanism.",2018-07-14,Bypass ,3,https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062,8108e0a6db133f3375608303fdd2083eb5115062,"cipher: don't set dummy encryption key in Cipher#initialize

Remove the encryption key initialization from Cipher#initialize. This
is effectively a revert of r32723 (""Avoid possible SEGV from AES
encryption/decryption"", 2011-07-28).

r32723, which added the key initialization, was a workaround for
Ruby Bug #2768. For some certain ciphers, calling EVP_CipherUpdate()
before setting an encryption key caused segfault. It was not a problem
until OpenSSL implemented GCM mode - the encryption key could be
overridden by repeated calls of EVP_CipherInit_ex(). But, it is not the
case for AES-GCM ciphers. Setting a key, an IV, a key, in this order
causes the IV to be reset to an all-zero IV.

The problem of Bug #2768 persists on the current versions of OpenSSL.
So, make Cipher#update raise an exception if a key is not yet set by the
user. Since encrypting or decrypting without key does not make any
sense, this should not break existing applications.

Users can still call Cipher#key= and Cipher#iv= multiple times with
their own responsibility.

Reference: https://bugs.ruby-lang.org/issues/2768
Reference: https://bugs.ruby-lang.org/issues/8221
Reference: https://github.com/ruby/openssl/issues/49",0,ext/openssl/ossl_cipher.c,"{""sha"": ""ffa080b555c09e6d24d341d5c1aff3818f93dbf9"", ""filename"": ""ext/openssl/ossl_cipher.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 12, ""changes"": 25, ""blob_url"": ""https://github.com/ruby/openssl/blob/8108e0a6db133f3375608303fdd2083eb5115062/ext/openssl/ossl_cipher.c"", ""raw_url"": ""https://github.com/ruby/openssl/raw/8108e0a6db133f3375608303fdd2083eb5115062/ext/openssl/ossl_cipher.c"", ""contents_url"": ""https://api.github.com/repos/ruby/openssl/contents/ext/openssl/ossl_cipher.c?ref=8108e0a6db133f3375608303fdd2083eb5115062"", ""patch"": ""@@ -36,7 +36,7 @@\n  */\n VALUE cCipher;\n VALUE eCipherError;\n-static ID id_auth_tag_len;\n+static ID id_auth_tag_len, id_key_set;\n \n static VALUE ossl_cipher_alloc(VALUE klass);\n static void ossl_cipher_free(void *ptr);\n@@ -118,7 +118,6 @@ ossl_cipher_initialize(VALUE self, VALUE str)\n     EVP_CIPHER_CTX *ctx;\n     const EVP_CIPHER *cipher;\n     char *name;\n-    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };\n \n     name = StringValueCStr(str);\n     GetCipherInit(self, ctx);\n@@ -129,16 +128,7 @@ ossl_cipher_initialize(VALUE self, VALUE str)\n     if (!(cipher = EVP_get_cipherbyname(name))) {\n \tossl_raise(rb_eRuntimeError, \""unsupported cipher algorithm (%\""PRIsVALUE\"")\"", str);\n     }\n-    /*\n-     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some\n-     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]\n-     *\n-     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows\n-     * uninitialized key, but other EVPs (such as AES) does not allow it.\n-     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we\n-     * set the data filled with \""\\0\"" as the key by default.\n-     */\n-    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)\n+    if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)\n \tossl_raise(eCipherError, NULL);\n \n     return self;\n@@ -251,6 +241,9 @@ ossl_cipher_init(int argc, VALUE *argv, VALUE self, int mode)\n \tossl_raise(eCipherError, NULL);\n     }\n \n+    if (p_key)\n+\trb_ivar_set(self, id_key_set, Qtrue);\n+\n     return self;\n }\n \n@@ -337,6 +330,8 @@ ossl_cipher_pkcs5_keyivgen(int argc, VALUE *argv, VALUE self)\n     OPENSSL_cleanse(key, sizeof key);\n     OPENSSL_cleanse(iv, sizeof iv);\n \n+    rb_ivar_set(self, id_key_set, Qtrue);\n+\n     return Qnil;\n }\n \n@@ -387,6 +382,9 @@ ossl_cipher_update(int argc, VALUE *argv, VALUE self)\n \n     rb_scan_args(argc, argv, \""11\"", &data, &str);\n \n+    if (!RTEST(rb_attr_get(self, id_key_set)))\n+\tossl_raise(eCipherError, \""key not set\"");\n+\n     StringValue(data);\n     in = (unsigned char *)RSTRING_PTR(data);\n     if ((in_len = RSTRING_LEN(data)) == 0)\n@@ -488,6 +486,8 @@ ossl_cipher_set_key(VALUE self, VALUE key)\n     if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)\n \tossl_raise(eCipherError, NULL);\n \n+    rb_ivar_set(self, id_key_set, Qtrue);\n+\n     return key;\n }\n \n@@ -1082,4 +1082,5 @@ Init_ossl_cipher(void)\n     rb_define_method(cCipher, \""padding=\"", ossl_cipher_set_padding, 1);\n \n     id_auth_tag_len = rb_intern_const(\""auth_tag_len\"");\n+    id_key_set = rb_intern_const(\""key_set\"");\n }""}<_**next**_>{""sha"": ""015bb56170498e65882040c8a480209ee509bc47"", ""filename"": ""test/test_cipher.rb"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 6, ""changes"": 29, ""blob_url"": ""https://github.com/ruby/openssl/blob/8108e0a6db133f3375608303fdd2083eb5115062/test/test_cipher.rb"", ""raw_url"": ""https://github.com/ruby/openssl/raw/8108e0a6db133f3375608303fdd2083eb5115062/test/test_cipher.rb"", ""contents_url"": ""https://api.github.com/repos/ruby/openssl/contents/test/test_cipher.rb?ref=8108e0a6db133f3375608303fdd2083eb5115062"", ""patch"": ""@@ -90,6 +90,7 @@ def test_key_iv_set\n \n   def test_empty_data\n     @c1.encrypt\n+    @c1.random_key\n     assert_raise(ArgumentError){ @c1.update(\""\"") }\n   end\n \n@@ -136,12 +137,10 @@ def test_AES\n     }\n   end\n \n-  def test_AES_crush\n-    500.times do\n-      assert_nothing_raised(\""[Bug #2768]\"") do\n-        # it caused OpenSSL SEGV by uninitialized key\n-        OpenSSL::Cipher::AES128.new(\""ECB\"").update \"".\"" * 17\n-      end\n+  def test_update_raise_if_key_not_set\n+    assert_raise(OpenSSL::Cipher::CipherError) do\n+      # it caused OpenSSL SEGV by uninitialized key [Bug #2768]\n+      OpenSSL::Cipher::AES128.new(\""ECB\"").update \"".\"" * 17\n     end\n   end\n \n@@ -317,6 +316,24 @@ def test_aes_ocb_tag_len\n     }\n   end if has_cipher?(\""aes-128-ocb\"")\n \n+  def test_aes_gcm_key_iv_order_issue\n+    pt = \""[ruby/openssl#49]\""\n+    cipher = OpenSSL::Cipher.new(\""aes-128-gcm\"").encrypt\n+    cipher.key = \""x\"" * 16\n+    cipher.iv = \""a\"" * 12\n+    ct1 = cipher.update(pt) << cipher.final\n+    tag1 = cipher.auth_tag\n+\n+    cipher = OpenSSL::Cipher.new(\""aes-128-gcm\"").encrypt\n+    cipher.iv = \""a\"" * 12\n+    cipher.key = \""x\"" * 16\n+    ct2 = cipher.update(pt) << cipher.final\n+    tag2 = cipher.auth_tag\n+\n+    assert_equal ct1, ct2\n+    assert_equal tag1, tag2\n+  end if has_cipher?(\""aes-128-gcm\"")\n+\n   private\n \n   def new_encryptor(algo)""}","ossl_cipher_update(int argc, VALUE *argv, VALUE self)
{
    EVP_CIPHER_CTX *ctx;
    unsigned char *in;
    long in_len, out_len;
    VALUE data, str;
 
     rb_scan_args(argc, argv, ""11"", &data, &str);
 
    if (!RTEST(rb_attr_get(self, id_key_set)))
	ossl_raise(eCipherError, ""key not set"");

     StringValue(data);
     in = (unsigned char *)RSTRING_PTR(data);
     if ((in_len = RSTRING_LEN(data)) == 0)
        ossl_raise(rb_eArgError, ""data must not be empty"");
    GetCipher(self, ctx);
    out_len = in_len+EVP_CIPHER_CTX_block_size(ctx);
    if (out_len <= 0) {
	ossl_raise(rb_eRangeError,
		   ""data too big to make output buffer: %ld bytes"", in_len);
    }

    if (NIL_P(str)) {
        str = rb_str_new(0, out_len);
    } else {
        StringValue(str);
        rb_str_resize(str, out_len);
    }

    if (!ossl_cipher_update_long(ctx, (unsigned char *)RSTRING_PTR(str), &out_len, in, in_len))
	ossl_raise(eCipherError, NULL);
    assert(out_len < RSTRING_LEN(str));
    rb_str_set_len(str, out_len);

    return str;
}
","ossl_cipher_update(int argc, VALUE *argv, VALUE self)
{
    EVP_CIPHER_CTX *ctx;
    unsigned char *in;
    long in_len, out_len;
    VALUE data, str;
 
     rb_scan_args(argc, argv, ""11"", &data, &str);
 
     StringValue(data);
     in = (unsigned char *)RSTRING_PTR(data);
     if ((in_len = RSTRING_LEN(data)) == 0)
        ossl_raise(rb_eArgError, ""data must not be empty"");
    GetCipher(self, ctx);
    out_len = in_len+EVP_CIPHER_CTX_block_size(ctx);
    if (out_len <= 0) {
	ossl_raise(rb_eRangeError,
		   ""data too big to make output buffer: %ld bytes"", in_len);
    }

    if (NIL_P(str)) {
        str = rb_str_new(0, out_len);
    } else {
        StringValue(str);
        rb_str_resize(str, out_len);
    }

    if (!ossl_cipher_update_long(ctx, (unsigned char *)RSTRING_PTR(str), &out_len, in, in_len))
	ossl_raise(eCipherError, NULL);
    assert(out_len < RSTRING_LEN(str));
    rb_str_set_len(str, out_len);

    return str;
}
",C,"    if (!RTEST(rb_attr_get(self, id_key_set)))
	ossl_raise(eCipherError, ""key not set"");

",,,"@@ -36,7 +36,7 @@
  */
 VALUE cCipher;
 VALUE eCipherError;
-static ID id_auth_tag_len;
+static ID id_auth_tag_len, id_key_set;
 
 static VALUE ossl_cipher_alloc(VALUE klass);
 static void ossl_cipher_free(void *ptr);
@@ -118,7 +118,6 @@ ossl_cipher_initialize(VALUE self, VALUE str)
     EVP_CIPHER_CTX *ctx;
     const EVP_CIPHER *cipher;
     char *name;
-    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };
 
     name = StringValueCStr(str);
     GetCipherInit(self, ctx);
@@ -129,16 +128,7 @@ ossl_cipher_initialize(VALUE self, VALUE str)
     if (!(cipher = EVP_get_cipherbyname(name))) {
 	ossl_raise(rb_eRuntimeError, ""unsupported cipher algorithm (%""PRIsVALUE"")"", str);
     }
-    /*
-     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some
-     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]
-     *
-     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows
-     * uninitialized key, but other EVPs (such as AES) does not allow it.
-     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we
-     * set the data filled with ""\0"" as the key by default.
-     */
-    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)
+    if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)
 	ossl_raise(eCipherError, NULL);
 
     return self;
@@ -251,6 +241,9 @@ ossl_cipher_init(int argc, VALUE *argv, VALUE self, int mode)
 	ossl_raise(eCipherError, NULL);
     }
 
+    if (p_key)
+	rb_ivar_set(self, id_key_set, Qtrue);
+
     return self;
 }
 
@@ -337,6 +330,8 @@ ossl_cipher_pkcs5_keyivgen(int argc, VALUE *argv, VALUE self)
     OPENSSL_cleanse(key, sizeof key);
     OPENSSL_cleanse(iv, sizeof iv);
 
+    rb_ivar_set(self, id_key_set, Qtrue);
+
     return Qnil;
 }
 
@@ -387,6 +382,9 @@ ossl_cipher_update(int argc, VALUE *argv, VALUE self)
 
     rb_scan_args(argc, argv, ""11"", &data, &str);
 
+    if (!RTEST(rb_attr_get(self, id_key_set)))
+	ossl_raise(eCipherError, ""key not set"");
+
     StringValue(data);
     in = (unsigned char *)RSTRING_PTR(data);
     if ((in_len = RSTRING_LEN(data)) == 0)
@@ -488,6 +486,8 @@ ossl_cipher_set_key(VALUE self, VALUE key)
     if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)
 	ossl_raise(eCipherError, NULL);
 
+    rb_ivar_set(self, id_key_set, Qtrue);
+
     return key;
 }
 
@@ -1082,4 +1082,5 @@ Init_ossl_cipher(void)
     rb_define_method(cCipher, ""padding="", ossl_cipher_set_padding, 1);
 
     id_auth_tag_len = rb_intern_const(""auth_tag_len"");
+    id_key_set = rb_intern_const(""key_set"");
 }",openssl,8108e0a6db133f3375608303fdd2083eb5115062,4eda40878fc42ac5bad6dd7b1ebc8f0eac796b94,1,"ossl_cipher_update(int argc, VALUE *argv, VALUE self)
{
    EVP_CIPHER_CTX *ctx;
    unsigned char *in;
    long in_len, out_len;
    VALUE data, str;
 
     rb_scan_args(argc, argv, ""11"", &data, &str);
 
//fix_flaw_line_below:
//    if (!RTEST(rb_attr_get(self, id_key_set)))
//fix_flaw_line_below:
//	ossl_raise(eCipherError, ""key not set"");
//fix_flaw_line_below:
//
     StringValue(data);
     in = (unsigned char *)RSTRING_PTR(data);
     if ((in_len = RSTRING_LEN(data)) == 0)
        ossl_raise(rb_eArgError, ""data must not be empty"");
    GetCipher(self, ctx);
    out_len = in_len+EVP_CIPHER_CTX_block_size(ctx);
    if (out_len <= 0) {
	ossl_raise(rb_eRangeError,
		   ""data too big to make output buffer: %ld bytes"", in_len);
    }

    if (NIL_P(str)) {
        str = rb_str_new(0, out_len);
    } else {
        StringValue(str);
        rb_str_resize(str, out_len);
    }

    if (!ossl_cipher_update_long(ctx, (unsigned char *)RSTRING_PTR(str), &out_len, in, in_len))
	ossl_raise(eCipherError, NULL);
    assert(out_len < RSTRING_LEN(str));
    rb_str_set_len(str, out_len);

    return str;
}
"
5086,182822,,Remote,Not required,,CVE-2019-12904,https://www.cvedetails.com/cve/CVE-2019-12904/,CWE-310,Medium,Partial,,,2019-06-19,4.3,"In Libgcrypt 1.8.4, the C implementation of AES is vulnerable to a flush-and-reload side-channel attack because physical addresses are available to other processes. (The C implementation is used on platforms where an assembly-language implementation is unavailable.)",2019-07-23,,9,https://github.com/gpg/libgcrypt/commit/a4c561aab1014c3630bc88faf6f5246fee16b020,a4c561aab1014c3630bc88faf6f5246fee16b020,"GCM: move look-up table to .data section and unshare between processes

* cipher/cipher-gcm.c (ATTR_ALIGNED_64): New.
(gcmR): Move to 'gcm_table' structure.
(gcm_table): New structure for look-up table with counters before and
after.
(gcmR): New macro.
(prefetch_table): Handle input with length not multiple of 256.
(do_prefetch_tables): Modify pre- and post-table counters to unshare
look-up table pages between processes.
--

GnuPG-bug-id: 4541
Signed-off-by: Jussi Kivilinna <jussi.kivilinna@iki.fi>",1,cipher/cipher-gcm.c,"{""sha"": ""194e2ec9d6e3ab434638e878f151124e3915b4ca"", ""filename"": ""cipher/cipher-gcm.c"", ""status"": ""modified"", ""additions"": 70, ""deletions"": 36, ""changes"": 106, ""blob_url"": ""https://github.com/gpg/libgcrypt/blob/a4c561aab1014c3630bc88faf6f5246fee16b020/cipher/cipher-gcm.c"", ""raw_url"": ""https://github.com/gpg/libgcrypt/raw/a4c561aab1014c3630bc88faf6f5246fee16b020/cipher/cipher-gcm.c"", ""contents_url"": ""https://api.github.com/repos/gpg/libgcrypt/contents/cipher/cipher-gcm.c?ref=a4c561aab1014c3630bc88faf6f5246fee16b020"", ""patch"": ""@@ -30,6 +30,14 @@\n #include \""./cipher-internal.h\""\n \n \n+/* Helper macro to force alignment to 16 or 64 bytes.  */\n+#ifdef HAVE_GCC_ATTRIBUTE_ALIGNED\n+# define ATTR_ALIGNED_64  __attribute__ ((aligned (64)))\n+#else\n+# define ATTR_ALIGNED_64\n+#endif\n+\n+\n #ifdef GCM_USE_INTEL_PCLMUL\n extern void _gcry_ghash_setup_intel_pclmul (gcry_cipher_hd_t c);\n \n@@ -83,48 +91,62 @@ ghash_armv7_neon (gcry_cipher_hd_t c, byte *result, const byte *buf,\n \n \n #ifdef GCM_USE_TABLES\n-static const u16 gcmR[256] = {\n-  0x0000, 0x01c2, 0x0384, 0x0246, 0x0708, 0x06ca, 0x048c, 0x054e,\n-  0x0e10, 0x0fd2, 0x0d94, 0x0c56, 0x0918, 0x08da, 0x0a9c, 0x0b5e,\n-  0x1c20, 0x1de2, 0x1fa4, 0x1e66, 0x1b28, 0x1aea, 0x18ac, 0x196e,\n-  0x1230, 0x13f2, 0x11b4, 0x1076, 0x1538, 0x14fa, 0x16bc, 0x177e,\n-  0x3840, 0x3982, 0x3bc4, 0x3a06, 0x3f48, 0x3e8a, 0x3ccc, 0x3d0e,\n-  0x3650, 0x3792, 0x35d4, 0x3416, 0x3158, 0x309a, 0x32dc, 0x331e,\n-  0x2460, 0x25a2, 0x27e4, 0x2626, 0x2368, 0x22aa, 0x20ec, 0x212e,\n-  0x2a70, 0x2bb2, 0x29f4, 0x2836, 0x2d78, 0x2cba, 0x2efc, 0x2f3e,\n-  0x7080, 0x7142, 0x7304, 0x72c6, 0x7788, 0x764a, 0x740c, 0x75ce,\n-  0x7e90, 0x7f52, 0x7d14, 0x7cd6, 0x7998, 0x785a, 0x7a1c, 0x7bde,\n-  0x6ca0, 0x6d62, 0x6f24, 0x6ee6, 0x6ba8, 0x6a6a, 0x682c, 0x69ee,\n-  0x62b0, 0x6372, 0x6134, 0x60f6, 0x65b8, 0x647a, 0x663c, 0x67fe,\n-  0x48c0, 0x4902, 0x4b44, 0x4a86, 0x4fc8, 0x4e0a, 0x4c4c, 0x4d8e,\n-  0x46d0, 0x4712, 0x4554, 0x4496, 0x41d8, 0x401a, 0x425c, 0x439e,\n-  0x54e0, 0x5522, 0x5764, 0x56a6, 0x53e8, 0x522a, 0x506c, 0x51ae,\n-  0x5af0, 0x5b32, 0x5974, 0x58b6, 0x5df8, 0x5c3a, 0x5e7c, 0x5fbe,\n-  0xe100, 0xe0c2, 0xe284, 0xe346, 0xe608, 0xe7ca, 0xe58c, 0xe44e,\n-  0xef10, 0xeed2, 0xec94, 0xed56, 0xe818, 0xe9da, 0xeb9c, 0xea5e,\n-  0xfd20, 0xfce2, 0xfea4, 0xff66, 0xfa28, 0xfbea, 0xf9ac, 0xf86e,\n-  0xf330, 0xf2f2, 0xf0b4, 0xf176, 0xf438, 0xf5fa, 0xf7bc, 0xf67e,\n-  0xd940, 0xd882, 0xdac4, 0xdb06, 0xde48, 0xdf8a, 0xddcc, 0xdc0e,\n-  0xd750, 0xd692, 0xd4d4, 0xd516, 0xd058, 0xd19a, 0xd3dc, 0xd21e,\n-  0xc560, 0xc4a2, 0xc6e4, 0xc726, 0xc268, 0xc3aa, 0xc1ec, 0xc02e,\n-  0xcb70, 0xcab2, 0xc8f4, 0xc936, 0xcc78, 0xcdba, 0xcffc, 0xce3e,\n-  0x9180, 0x9042, 0x9204, 0x93c6, 0x9688, 0x974a, 0x950c, 0x94ce,\n-  0x9f90, 0x9e52, 0x9c14, 0x9dd6, 0x9898, 0x995a, 0x9b1c, 0x9ade,\n-  0x8da0, 0x8c62, 0x8e24, 0x8fe6, 0x8aa8, 0x8b6a, 0x892c, 0x88ee,\n-  0x83b0, 0x8272, 0x8034, 0x81f6, 0x84b8, 0x857a, 0x873c, 0x86fe,\n-  0xa9c0, 0xa802, 0xaa44, 0xab86, 0xaec8, 0xaf0a, 0xad4c, 0xac8e,\n-  0xa7d0, 0xa612, 0xa454, 0xa596, 0xa0d8, 0xa11a, 0xa35c, 0xa29e,\n-  0xb5e0, 0xb422, 0xb664, 0xb7a6, 0xb2e8, 0xb32a, 0xb16c, 0xb0ae,\n-  0xbbf0, 0xba32, 0xb874, 0xb9b6, 0xbcf8, 0xbd3a, 0xbf7c, 0xbebe,\n-};\n+static struct\n+{\n+  volatile u32 counter_head;\n+  u32 cacheline_align[64 / 4 - 1];\n+  u16 R[256];\n+  volatile u32 counter_tail;\n+} gcm_table ATTR_ALIGNED_64 =\n+  {\n+    0,\n+    { 0, },\n+    {\n+      0x0000, 0x01c2, 0x0384, 0x0246, 0x0708, 0x06ca, 0x048c, 0x054e,\n+      0x0e10, 0x0fd2, 0x0d94, 0x0c56, 0x0918, 0x08da, 0x0a9c, 0x0b5e,\n+      0x1c20, 0x1de2, 0x1fa4, 0x1e66, 0x1b28, 0x1aea, 0x18ac, 0x196e,\n+      0x1230, 0x13f2, 0x11b4, 0x1076, 0x1538, 0x14fa, 0x16bc, 0x177e,\n+      0x3840, 0x3982, 0x3bc4, 0x3a06, 0x3f48, 0x3e8a, 0x3ccc, 0x3d0e,\n+      0x3650, 0x3792, 0x35d4, 0x3416, 0x3158, 0x309a, 0x32dc, 0x331e,\n+      0x2460, 0x25a2, 0x27e4, 0x2626, 0x2368, 0x22aa, 0x20ec, 0x212e,\n+      0x2a70, 0x2bb2, 0x29f4, 0x2836, 0x2d78, 0x2cba, 0x2efc, 0x2f3e,\n+      0x7080, 0x7142, 0x7304, 0x72c6, 0x7788, 0x764a, 0x740c, 0x75ce,\n+      0x7e90, 0x7f52, 0x7d14, 0x7cd6, 0x7998, 0x785a, 0x7a1c, 0x7bde,\n+      0x6ca0, 0x6d62, 0x6f24, 0x6ee6, 0x6ba8, 0x6a6a, 0x682c, 0x69ee,\n+      0x62b0, 0x6372, 0x6134, 0x60f6, 0x65b8, 0x647a, 0x663c, 0x67fe,\n+      0x48c0, 0x4902, 0x4b44, 0x4a86, 0x4fc8, 0x4e0a, 0x4c4c, 0x4d8e,\n+      0x46d0, 0x4712, 0x4554, 0x4496, 0x41d8, 0x401a, 0x425c, 0x439e,\n+      0x54e0, 0x5522, 0x5764, 0x56a6, 0x53e8, 0x522a, 0x506c, 0x51ae,\n+      0x5af0, 0x5b32, 0x5974, 0x58b6, 0x5df8, 0x5c3a, 0x5e7c, 0x5fbe,\n+      0xe100, 0xe0c2, 0xe284, 0xe346, 0xe608, 0xe7ca, 0xe58c, 0xe44e,\n+      0xef10, 0xeed2, 0xec94, 0xed56, 0xe818, 0xe9da, 0xeb9c, 0xea5e,\n+      0xfd20, 0xfce2, 0xfea4, 0xff66, 0xfa28, 0xfbea, 0xf9ac, 0xf86e,\n+      0xf330, 0xf2f2, 0xf0b4, 0xf176, 0xf438, 0xf5fa, 0xf7bc, 0xf67e,\n+      0xd940, 0xd882, 0xdac4, 0xdb06, 0xde48, 0xdf8a, 0xddcc, 0xdc0e,\n+      0xd750, 0xd692, 0xd4d4, 0xd516, 0xd058, 0xd19a, 0xd3dc, 0xd21e,\n+      0xc560, 0xc4a2, 0xc6e4, 0xc726, 0xc268, 0xc3aa, 0xc1ec, 0xc02e,\n+      0xcb70, 0xcab2, 0xc8f4, 0xc936, 0xcc78, 0xcdba, 0xcffc, 0xce3e,\n+      0x9180, 0x9042, 0x9204, 0x93c6, 0x9688, 0x974a, 0x950c, 0x94ce,\n+      0x9f90, 0x9e52, 0x9c14, 0x9dd6, 0x9898, 0x995a, 0x9b1c, 0x9ade,\n+      0x8da0, 0x8c62, 0x8e24, 0x8fe6, 0x8aa8, 0x8b6a, 0x892c, 0x88ee,\n+      0x83b0, 0x8272, 0x8034, 0x81f6, 0x84b8, 0x857a, 0x873c, 0x86fe,\n+      0xa9c0, 0xa802, 0xaa44, 0xab86, 0xaec8, 0xaf0a, 0xad4c, 0xac8e,\n+      0xa7d0, 0xa612, 0xa454, 0xa596, 0xa0d8, 0xa11a, 0xa35c, 0xa29e,\n+      0xb5e0, 0xb422, 0xb664, 0xb7a6, 0xb2e8, 0xb32a, 0xb16c, 0xb0ae,\n+      0xbbf0, 0xba32, 0xb874, 0xb9b6, 0xbcf8, 0xbd3a, 0xbf7c, 0xbebe,\n+    },\n+    0\n+  };\n+\n+#define gcmR gcm_table.R\n \n static inline\n void prefetch_table(const void *tab, size_t len)\n {\n   const volatile byte *vtab = tab;\n   size_t i;\n \n-  for (i = 0; i < len; i += 8 * 32)\n+  for (i = 0; len - i >= 8 * 32; i += 8 * 32)\n     {\n       (void)vtab[i + 0 * 32];\n       (void)vtab[i + 1 * 32];\n@@ -135,15 +157,27 @@ void prefetch_table(const void *tab, size_t len)\n       (void)vtab[i + 6 * 32];\n       (void)vtab[i + 7 * 32];\n     }\n+  for (; i < len; i += 32)\n+    {\n+      (void)vtab[i];\n+    }\n \n   (void)vtab[len - 1];\n }\n \n static inline void\n do_prefetch_tables (const void *gcmM, size_t gcmM_size)\n {\n+  /* Modify counters to trigger copy-on-write and unsharing if physical pages\n+   * of look-up table are shared between processes.  Modifying counters also\n+   * causes checksums for pages to change and hint same-page merging algorithm\n+   * that these pages are frequently changing.  */\n+  gcm_table.counter_head++;\n+  gcm_table.counter_tail++;\n+\n+  /* Prefetch look-up tables to cache.  */\n   prefetch_table(gcmM, gcmM_size);\n-  prefetch_table(gcmR, sizeof(gcmR));\n+  prefetch_table(&gcm_table, sizeof(gcm_table));\n }\n \n #ifdef GCM_TABLES_USE_U64""}"," do_prefetch_tables (const void *gcmM, size_t gcmM_size)
 {
  /* Modify counters to trigger copy-on-write and unsharing if physical pages
   * of look-up table are shared between processes.  Modifying counters also
   * causes checksums for pages to change and hint same-page merging algorithm
   * that these pages are frequently changing.  */
  gcm_table.counter_head++;
  gcm_table.counter_tail++;

  /* Prefetch look-up tables to cache.  */
   prefetch_table(gcmM, gcmM_size);
  prefetch_table(&gcm_table, sizeof(gcm_table));
 }
"," do_prefetch_tables (const void *gcmM, size_t gcmM_size)
 {
   prefetch_table(gcmM, gcmM_size);
  prefetch_table(gcmR, sizeof(gcmR));
 }
",C,"  /* Modify counters to trigger copy-on-write and unsharing if physical pages
   * of look-up table are shared between processes.  Modifying counters also
   * causes checksums for pages to change and hint same-page merging algorithm
   * that these pages are frequently changing.  */
  gcm_table.counter_head++;
  gcm_table.counter_tail++;

  /* Prefetch look-up tables to cache.  */
  prefetch_table(&gcm_table, sizeof(gcm_table));
","  prefetch_table(gcmR, sizeof(gcmR));
",,"@@ -30,6 +30,14 @@
 #include ""./cipher-internal.h""
 
 
+/* Helper macro to force alignment to 16 or 64 bytes.  */
+#ifdef HAVE_GCC_ATTRIBUTE_ALIGNED
+# define ATTR_ALIGNED_64  __attribute__ ((aligned (64)))
+#else
+# define ATTR_ALIGNED_64
+#endif
+
+
 #ifdef GCM_USE_INTEL_PCLMUL
 extern void _gcry_ghash_setup_intel_pclmul (gcry_cipher_hd_t c);
 
@@ -83,48 +91,62 @@ ghash_armv7_neon (gcry_cipher_hd_t c, byte *result, const byte *buf,
 
 
 #ifdef GCM_USE_TABLES
-static const u16 gcmR[256] = {
-  0x0000, 0x01c2, 0x0384, 0x0246, 0x0708, 0x06ca, 0x048c, 0x054e,
-  0x0e10, 0x0fd2, 0x0d94, 0x0c56, 0x0918, 0x08da, 0x0a9c, 0x0b5e,
-  0x1c20, 0x1de2, 0x1fa4, 0x1e66, 0x1b28, 0x1aea, 0x18ac, 0x196e,
-  0x1230, 0x13f2, 0x11b4, 0x1076, 0x1538, 0x14fa, 0x16bc, 0x177e,
-  0x3840, 0x3982, 0x3bc4, 0x3a06, 0x3f48, 0x3e8a, 0x3ccc, 0x3d0e,
-  0x3650, 0x3792, 0x35d4, 0x3416, 0x3158, 0x309a, 0x32dc, 0x331e,
-  0x2460, 0x25a2, 0x27e4, 0x2626, 0x2368, 0x22aa, 0x20ec, 0x212e,
-  0x2a70, 0x2bb2, 0x29f4, 0x2836, 0x2d78, 0x2cba, 0x2efc, 0x2f3e,
-  0x7080, 0x7142, 0x7304, 0x72c6, 0x7788, 0x764a, 0x740c, 0x75ce,
-  0x7e90, 0x7f52, 0x7d14, 0x7cd6, 0x7998, 0x785a, 0x7a1c, 0x7bde,
-  0x6ca0, 0x6d62, 0x6f24, 0x6ee6, 0x6ba8, 0x6a6a, 0x682c, 0x69ee,
-  0x62b0, 0x6372, 0x6134, 0x60f6, 0x65b8, 0x647a, 0x663c, 0x67fe,
-  0x48c0, 0x4902, 0x4b44, 0x4a86, 0x4fc8, 0x4e0a, 0x4c4c, 0x4d8e,
-  0x46d0, 0x4712, 0x4554, 0x4496, 0x41d8, 0x401a, 0x425c, 0x439e,
-  0x54e0, 0x5522, 0x5764, 0x56a6, 0x53e8, 0x522a, 0x506c, 0x51ae,
-  0x5af0, 0x5b32, 0x5974, 0x58b6, 0x5df8, 0x5c3a, 0x5e7c, 0x5fbe,
-  0xe100, 0xe0c2, 0xe284, 0xe346, 0xe608, 0xe7ca, 0xe58c, 0xe44e,
-  0xef10, 0xeed2, 0xec94, 0xed56, 0xe818, 0xe9da, 0xeb9c, 0xea5e,
-  0xfd20, 0xfce2, 0xfea4, 0xff66, 0xfa28, 0xfbea, 0xf9ac, 0xf86e,
-  0xf330, 0xf2f2, 0xf0b4, 0xf176, 0xf438, 0xf5fa, 0xf7bc, 0xf67e,
-  0xd940, 0xd882, 0xdac4, 0xdb06, 0xde48, 0xdf8a, 0xddcc, 0xdc0e,
-  0xd750, 0xd692, 0xd4d4, 0xd516, 0xd058, 0xd19a, 0xd3dc, 0xd21e,
-  0xc560, 0xc4a2, 0xc6e4, 0xc726, 0xc268, 0xc3aa, 0xc1ec, 0xc02e,
-  0xcb70, 0xcab2, 0xc8f4, 0xc936, 0xcc78, 0xcdba, 0xcffc, 0xce3e,
-  0x9180, 0x9042, 0x9204, 0x93c6, 0x9688, 0x974a, 0x950c, 0x94ce,
-  0x9f90, 0x9e52, 0x9c14, 0x9dd6, 0x9898, 0x995a, 0x9b1c, 0x9ade,
-  0x8da0, 0x8c62, 0x8e24, 0x8fe6, 0x8aa8, 0x8b6a, 0x892c, 0x88ee,
-  0x83b0, 0x8272, 0x8034, 0x81f6, 0x84b8, 0x857a, 0x873c, 0x86fe,
-  0xa9c0, 0xa802, 0xaa44, 0xab86, 0xaec8, 0xaf0a, 0xad4c, 0xac8e,
-  0xa7d0, 0xa612, 0xa454, 0xa596, 0xa0d8, 0xa11a, 0xa35c, 0xa29e,
-  0xb5e0, 0xb422, 0xb664, 0xb7a6, 0xb2e8, 0xb32a, 0xb16c, 0xb0ae,
-  0xbbf0, 0xba32, 0xb874, 0xb9b6, 0xbcf8, 0xbd3a, 0xbf7c, 0xbebe,
-};
+static struct
+{
+  volatile u32 counter_head;
+  u32 cacheline_align[64 / 4 - 1];
+  u16 R[256];
+  volatile u32 counter_tail;
+} gcm_table ATTR_ALIGNED_64 =
+  {
+    0,
+    { 0, },
+    {
+      0x0000, 0x01c2, 0x0384, 0x0246, 0x0708, 0x06ca, 0x048c, 0x054e,
+      0x0e10, 0x0fd2, 0x0d94, 0x0c56, 0x0918, 0x08da, 0x0a9c, 0x0b5e,
+      0x1c20, 0x1de2, 0x1fa4, 0x1e66, 0x1b28, 0x1aea, 0x18ac, 0x196e,
+      0x1230, 0x13f2, 0x11b4, 0x1076, 0x1538, 0x14fa, 0x16bc, 0x177e,
+      0x3840, 0x3982, 0x3bc4, 0x3a06, 0x3f48, 0x3e8a, 0x3ccc, 0x3d0e,
+      0x3650, 0x3792, 0x35d4, 0x3416, 0x3158, 0x309a, 0x32dc, 0x331e,
+      0x2460, 0x25a2, 0x27e4, 0x2626, 0x2368, 0x22aa, 0x20ec, 0x212e,
+      0x2a70, 0x2bb2, 0x29f4, 0x2836, 0x2d78, 0x2cba, 0x2efc, 0x2f3e,
+      0x7080, 0x7142, 0x7304, 0x72c6, 0x7788, 0x764a, 0x740c, 0x75ce,
+      0x7e90, 0x7f52, 0x7d14, 0x7cd6, 0x7998, 0x785a, 0x7a1c, 0x7bde,
+      0x6ca0, 0x6d62, 0x6f24, 0x6ee6, 0x6ba8, 0x6a6a, 0x682c, 0x69ee,
+      0x62b0, 0x6372, 0x6134, 0x60f6, 0x65b8, 0x647a, 0x663c, 0x67fe,
+      0x48c0, 0x4902, 0x4b44, 0x4a86, 0x4fc8, 0x4e0a, 0x4c4c, 0x4d8e,
+      0x46d0, 0x4712, 0x4554, 0x4496, 0x41d8, 0x401a, 0x425c, 0x439e,
+      0x54e0, 0x5522, 0x5764, 0x56a6, 0x53e8, 0x522a, 0x506c, 0x51ae,
+      0x5af0, 0x5b32, 0x5974, 0x58b6, 0x5df8, 0x5c3a, 0x5e7c, 0x5fbe,
+      0xe100, 0xe0c2, 0xe284, 0xe346, 0xe608, 0xe7ca, 0xe58c, 0xe44e,
+      0xef10, 0xeed2, 0xec94, 0xed56, 0xe818, 0xe9da, 0xeb9c, 0xea5e,
+      0xfd20, 0xfce2, 0xfea4, 0xff66, 0xfa28, 0xfbea, 0xf9ac, 0xf86e,
+      0xf330, 0xf2f2, 0xf0b4, 0xf176, 0xf438, 0xf5fa, 0xf7bc, 0xf67e,
+      0xd940, 0xd882, 0xdac4, 0xdb06, 0xde48, 0xdf8a, 0xddcc, 0xdc0e,
+      0xd750, 0xd692, 0xd4d4, 0xd516, 0xd058, 0xd19a, 0xd3dc, 0xd21e,
+      0xc560, 0xc4a2, 0xc6e4, 0xc726, 0xc268, 0xc3aa, 0xc1ec, 0xc02e,
+      0xcb70, 0xcab2, 0xc8f4, 0xc936, 0xcc78, 0xcdba, 0xcffc, 0xce3e,
+      0x9180, 0x9042, 0x9204, 0x93c6, 0x9688, 0x974a, 0x950c, 0x94ce,
+      0x9f90, 0x9e52, 0x9c14, 0x9dd6, 0x9898, 0x995a, 0x9b1c, 0x9ade,
+      0x8da0, 0x8c62, 0x8e24, 0x8fe6, 0x8aa8, 0x8b6a, 0x892c, 0x88ee,
+      0x83b0, 0x8272, 0x8034, 0x81f6, 0x84b8, 0x857a, 0x873c, 0x86fe,
+      0xa9c0, 0xa802, 0xaa44, 0xab86, 0xaec8, 0xaf0a, 0xad4c, 0xac8e,
+      0xa7d0, 0xa612, 0xa454, 0xa596, 0xa0d8, 0xa11a, 0xa35c, 0xa29e,
+      0xb5e0, 0xb422, 0xb664, 0xb7a6, 0xb2e8, 0xb32a, 0xb16c, 0xb0ae,
+      0xbbf0, 0xba32, 0xb874, 0xb9b6, 0xbcf8, 0xbd3a, 0xbf7c, 0xbebe,
+    },
+    0
+  };
+
+#define gcmR gcm_table.R
 
 static inline
 void prefetch_table(const void *tab, size_t len)
 {
   const volatile byte *vtab = tab;
   size_t i;
 
-  for (i = 0; i < len; i += 8 * 32)
+  for (i = 0; len - i >= 8 * 32; i += 8 * 32)
     {
       (void)vtab[i + 0 * 32];
       (void)vtab[i + 1 * 32];
@@ -135,15 +157,27 @@ void prefetch_table(const void *tab, size_t len)
       (void)vtab[i + 6 * 32];
       (void)vtab[i + 7 * 32];
     }
+  for (; i < len; i += 32)
+    {
+      (void)vtab[i];
+    }
 
   (void)vtab[len - 1];
 }
 
 static inline void
 do_prefetch_tables (const void *gcmM, size_t gcmM_size)
 {
+  /* Modify counters to trigger copy-on-write and unsharing if physical pages
+   * of look-up table are shared between processes.  Modifying counters also
+   * causes checksums for pages to change and hint same-page merging algorithm
+   * that these pages are frequently changing.  */
+  gcm_table.counter_head++;
+  gcm_table.counter_tail++;
+
+  /* Prefetch look-up tables to cache.  */
   prefetch_table(gcmM, gcmM_size);
-  prefetch_table(gcmR, sizeof(gcmR));
+  prefetch_table(&gcm_table, sizeof(gcm_table));
 }
 
 #ifdef GCM_TABLES_USE_U64",libgcrypt,a4c561aab1014c3630bc88faf6f5246fee16b020,daedbbb5541cd8ecda1459d3b843ea4d92788762,1," do_prefetch_tables (const void *gcmM, size_t gcmM_size)
 {
//fix_flaw_line_below:
//  /* Modify counters to trigger copy-on-write and unsharing if physical pages
//fix_flaw_line_below:
//   * of look-up table are shared between processes.  Modifying counters also
//fix_flaw_line_below:
//   * causes checksums for pages to change and hint same-page merging algorithm
//fix_flaw_line_below:
//   * that these pages are frequently changing.  */
//fix_flaw_line_below:
//  gcm_table.counter_head++;
//fix_flaw_line_below:
//  gcm_table.counter_tail++;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  /* Prefetch look-up tables to cache.  */
   prefetch_table(gcmM, gcmM_size);
//flaw_line_below:
  prefetch_table(gcmR, sizeof(gcmR));
//fix_flaw_line_below:
//  prefetch_table(&gcm_table, sizeof(gcm_table));
 }
"
5087,182823,,Remote,Not required,,CVE-2019-12904,https://www.cvedetails.com/cve/CVE-2019-12904/,CWE-310,Medium,Partial,,,2019-06-19,4.3,"In Libgcrypt 1.8.4, the C implementation of AES is vulnerable to a flush-and-reload side-channel attack because physical addresses are available to other processes. (The C implementation is used on platforms where an assembly-language implementation is unavailable.)",2019-07-23,,5,https://github.com/gpg/libgcrypt/commit/a4c561aab1014c3630bc88faf6f5246fee16b020,a4c561aab1014c3630bc88faf6f5246fee16b020,"GCM: move look-up table to .data section and unshare between processes

* cipher/cipher-gcm.c (ATTR_ALIGNED_64): New.
(gcmR): Move to 'gcm_table' structure.
(gcm_table): New structure for look-up table with counters before and
after.
(gcmR): New macro.
(prefetch_table): Handle input with length not multiple of 256.
(do_prefetch_tables): Modify pre- and post-table counters to unshare
look-up table pages between processes.
--

GnuPG-bug-id: 4541
Signed-off-by: Jussi Kivilinna <jussi.kivilinna@iki.fi>",1,cipher/cipher-gcm.c,"{""sha"": ""194e2ec9d6e3ab434638e878f151124e3915b4ca"", ""filename"": ""cipher/cipher-gcm.c"", ""status"": ""modified"", ""additions"": 70, ""deletions"": 36, ""changes"": 106, ""blob_url"": ""https://github.com/gpg/libgcrypt/blob/a4c561aab1014c3630bc88faf6f5246fee16b020/cipher/cipher-gcm.c"", ""raw_url"": ""https://github.com/gpg/libgcrypt/raw/a4c561aab1014c3630bc88faf6f5246fee16b020/cipher/cipher-gcm.c"", ""contents_url"": ""https://api.github.com/repos/gpg/libgcrypt/contents/cipher/cipher-gcm.c?ref=a4c561aab1014c3630bc88faf6f5246fee16b020"", ""patch"": ""@@ -30,6 +30,14 @@\n #include \""./cipher-internal.h\""\n \n \n+/* Helper macro to force alignment to 16 or 64 bytes.  */\n+#ifdef HAVE_GCC_ATTRIBUTE_ALIGNED\n+# define ATTR_ALIGNED_64  __attribute__ ((aligned (64)))\n+#else\n+# define ATTR_ALIGNED_64\n+#endif\n+\n+\n #ifdef GCM_USE_INTEL_PCLMUL\n extern void _gcry_ghash_setup_intel_pclmul (gcry_cipher_hd_t c);\n \n@@ -83,48 +91,62 @@ ghash_armv7_neon (gcry_cipher_hd_t c, byte *result, const byte *buf,\n \n \n #ifdef GCM_USE_TABLES\n-static const u16 gcmR[256] = {\n-  0x0000, 0x01c2, 0x0384, 0x0246, 0x0708, 0x06ca, 0x048c, 0x054e,\n-  0x0e10, 0x0fd2, 0x0d94, 0x0c56, 0x0918, 0x08da, 0x0a9c, 0x0b5e,\n-  0x1c20, 0x1de2, 0x1fa4, 0x1e66, 0x1b28, 0x1aea, 0x18ac, 0x196e,\n-  0x1230, 0x13f2, 0x11b4, 0x1076, 0x1538, 0x14fa, 0x16bc, 0x177e,\n-  0x3840, 0x3982, 0x3bc4, 0x3a06, 0x3f48, 0x3e8a, 0x3ccc, 0x3d0e,\n-  0x3650, 0x3792, 0x35d4, 0x3416, 0x3158, 0x309a, 0x32dc, 0x331e,\n-  0x2460, 0x25a2, 0x27e4, 0x2626, 0x2368, 0x22aa, 0x20ec, 0x212e,\n-  0x2a70, 0x2bb2, 0x29f4, 0x2836, 0x2d78, 0x2cba, 0x2efc, 0x2f3e,\n-  0x7080, 0x7142, 0x7304, 0x72c6, 0x7788, 0x764a, 0x740c, 0x75ce,\n-  0x7e90, 0x7f52, 0x7d14, 0x7cd6, 0x7998, 0x785a, 0x7a1c, 0x7bde,\n-  0x6ca0, 0x6d62, 0x6f24, 0x6ee6, 0x6ba8, 0x6a6a, 0x682c, 0x69ee,\n-  0x62b0, 0x6372, 0x6134, 0x60f6, 0x65b8, 0x647a, 0x663c, 0x67fe,\n-  0x48c0, 0x4902, 0x4b44, 0x4a86, 0x4fc8, 0x4e0a, 0x4c4c, 0x4d8e,\n-  0x46d0, 0x4712, 0x4554, 0x4496, 0x41d8, 0x401a, 0x425c, 0x439e,\n-  0x54e0, 0x5522, 0x5764, 0x56a6, 0x53e8, 0x522a, 0x506c, 0x51ae,\n-  0x5af0, 0x5b32, 0x5974, 0x58b6, 0x5df8, 0x5c3a, 0x5e7c, 0x5fbe,\n-  0xe100, 0xe0c2, 0xe284, 0xe346, 0xe608, 0xe7ca, 0xe58c, 0xe44e,\n-  0xef10, 0xeed2, 0xec94, 0xed56, 0xe818, 0xe9da, 0xeb9c, 0xea5e,\n-  0xfd20, 0xfce2, 0xfea4, 0xff66, 0xfa28, 0xfbea, 0xf9ac, 0xf86e,\n-  0xf330, 0xf2f2, 0xf0b4, 0xf176, 0xf438, 0xf5fa, 0xf7bc, 0xf67e,\n-  0xd940, 0xd882, 0xdac4, 0xdb06, 0xde48, 0xdf8a, 0xddcc, 0xdc0e,\n-  0xd750, 0xd692, 0xd4d4, 0xd516, 0xd058, 0xd19a, 0xd3dc, 0xd21e,\n-  0xc560, 0xc4a2, 0xc6e4, 0xc726, 0xc268, 0xc3aa, 0xc1ec, 0xc02e,\n-  0xcb70, 0xcab2, 0xc8f4, 0xc936, 0xcc78, 0xcdba, 0xcffc, 0xce3e,\n-  0x9180, 0x9042, 0x9204, 0x93c6, 0x9688, 0x974a, 0x950c, 0x94ce,\n-  0x9f90, 0x9e52, 0x9c14, 0x9dd6, 0x9898, 0x995a, 0x9b1c, 0x9ade,\n-  0x8da0, 0x8c62, 0x8e24, 0x8fe6, 0x8aa8, 0x8b6a, 0x892c, 0x88ee,\n-  0x83b0, 0x8272, 0x8034, 0x81f6, 0x84b8, 0x857a, 0x873c, 0x86fe,\n-  0xa9c0, 0xa802, 0xaa44, 0xab86, 0xaec8, 0xaf0a, 0xad4c, 0xac8e,\n-  0xa7d0, 0xa612, 0xa454, 0xa596, 0xa0d8, 0xa11a, 0xa35c, 0xa29e,\n-  0xb5e0, 0xb422, 0xb664, 0xb7a6, 0xb2e8, 0xb32a, 0xb16c, 0xb0ae,\n-  0xbbf0, 0xba32, 0xb874, 0xb9b6, 0xbcf8, 0xbd3a, 0xbf7c, 0xbebe,\n-};\n+static struct\n+{\n+  volatile u32 counter_head;\n+  u32 cacheline_align[64 / 4 - 1];\n+  u16 R[256];\n+  volatile u32 counter_tail;\n+} gcm_table ATTR_ALIGNED_64 =\n+  {\n+    0,\n+    { 0, },\n+    {\n+      0x0000, 0x01c2, 0x0384, 0x0246, 0x0708, 0x06ca, 0x048c, 0x054e,\n+      0x0e10, 0x0fd2, 0x0d94, 0x0c56, 0x0918, 0x08da, 0x0a9c, 0x0b5e,\n+      0x1c20, 0x1de2, 0x1fa4, 0x1e66, 0x1b28, 0x1aea, 0x18ac, 0x196e,\n+      0x1230, 0x13f2, 0x11b4, 0x1076, 0x1538, 0x14fa, 0x16bc, 0x177e,\n+      0x3840, 0x3982, 0x3bc4, 0x3a06, 0x3f48, 0x3e8a, 0x3ccc, 0x3d0e,\n+      0x3650, 0x3792, 0x35d4, 0x3416, 0x3158, 0x309a, 0x32dc, 0x331e,\n+      0x2460, 0x25a2, 0x27e4, 0x2626, 0x2368, 0x22aa, 0x20ec, 0x212e,\n+      0x2a70, 0x2bb2, 0x29f4, 0x2836, 0x2d78, 0x2cba, 0x2efc, 0x2f3e,\n+      0x7080, 0x7142, 0x7304, 0x72c6, 0x7788, 0x764a, 0x740c, 0x75ce,\n+      0x7e90, 0x7f52, 0x7d14, 0x7cd6, 0x7998, 0x785a, 0x7a1c, 0x7bde,\n+      0x6ca0, 0x6d62, 0x6f24, 0x6ee6, 0x6ba8, 0x6a6a, 0x682c, 0x69ee,\n+      0x62b0, 0x6372, 0x6134, 0x60f6, 0x65b8, 0x647a, 0x663c, 0x67fe,\n+      0x48c0, 0x4902, 0x4b44, 0x4a86, 0x4fc8, 0x4e0a, 0x4c4c, 0x4d8e,\n+      0x46d0, 0x4712, 0x4554, 0x4496, 0x41d8, 0x401a, 0x425c, 0x439e,\n+      0x54e0, 0x5522, 0x5764, 0x56a6, 0x53e8, 0x522a, 0x506c, 0x51ae,\n+      0x5af0, 0x5b32, 0x5974, 0x58b6, 0x5df8, 0x5c3a, 0x5e7c, 0x5fbe,\n+      0xe100, 0xe0c2, 0xe284, 0xe346, 0xe608, 0xe7ca, 0xe58c, 0xe44e,\n+      0xef10, 0xeed2, 0xec94, 0xed56, 0xe818, 0xe9da, 0xeb9c, 0xea5e,\n+      0xfd20, 0xfce2, 0xfea4, 0xff66, 0xfa28, 0xfbea, 0xf9ac, 0xf86e,\n+      0xf330, 0xf2f2, 0xf0b4, 0xf176, 0xf438, 0xf5fa, 0xf7bc, 0xf67e,\n+      0xd940, 0xd882, 0xdac4, 0xdb06, 0xde48, 0xdf8a, 0xddcc, 0xdc0e,\n+      0xd750, 0xd692, 0xd4d4, 0xd516, 0xd058, 0xd19a, 0xd3dc, 0xd21e,\n+      0xc560, 0xc4a2, 0xc6e4, 0xc726, 0xc268, 0xc3aa, 0xc1ec, 0xc02e,\n+      0xcb70, 0xcab2, 0xc8f4, 0xc936, 0xcc78, 0xcdba, 0xcffc, 0xce3e,\n+      0x9180, 0x9042, 0x9204, 0x93c6, 0x9688, 0x974a, 0x950c, 0x94ce,\n+      0x9f90, 0x9e52, 0x9c14, 0x9dd6, 0x9898, 0x995a, 0x9b1c, 0x9ade,\n+      0x8da0, 0x8c62, 0x8e24, 0x8fe6, 0x8aa8, 0x8b6a, 0x892c, 0x88ee,\n+      0x83b0, 0x8272, 0x8034, 0x81f6, 0x84b8, 0x857a, 0x873c, 0x86fe,\n+      0xa9c0, 0xa802, 0xaa44, 0xab86, 0xaec8, 0xaf0a, 0xad4c, 0xac8e,\n+      0xa7d0, 0xa612, 0xa454, 0xa596, 0xa0d8, 0xa11a, 0xa35c, 0xa29e,\n+      0xb5e0, 0xb422, 0xb664, 0xb7a6, 0xb2e8, 0xb32a, 0xb16c, 0xb0ae,\n+      0xbbf0, 0xba32, 0xb874, 0xb9b6, 0xbcf8, 0xbd3a, 0xbf7c, 0xbebe,\n+    },\n+    0\n+  };\n+\n+#define gcmR gcm_table.R\n \n static inline\n void prefetch_table(const void *tab, size_t len)\n {\n   const volatile byte *vtab = tab;\n   size_t i;\n \n-  for (i = 0; i < len; i += 8 * 32)\n+  for (i = 0; len - i >= 8 * 32; i += 8 * 32)\n     {\n       (void)vtab[i + 0 * 32];\n       (void)vtab[i + 1 * 32];\n@@ -135,15 +157,27 @@ void prefetch_table(const void *tab, size_t len)\n       (void)vtab[i + 6 * 32];\n       (void)vtab[i + 7 * 32];\n     }\n+  for (; i < len; i += 32)\n+    {\n+      (void)vtab[i];\n+    }\n \n   (void)vtab[len - 1];\n }\n \n static inline void\n do_prefetch_tables (const void *gcmM, size_t gcmM_size)\n {\n+  /* Modify counters to trigger copy-on-write and unsharing if physical pages\n+   * of look-up table are shared between processes.  Modifying counters also\n+   * causes checksums for pages to change and hint same-page merging algorithm\n+   * that these pages are frequently changing.  */\n+  gcm_table.counter_head++;\n+  gcm_table.counter_tail++;\n+\n+  /* Prefetch look-up tables to cache.  */\n   prefetch_table(gcmM, gcmM_size);\n-  prefetch_table(gcmR, sizeof(gcmR));\n+  prefetch_table(&gcm_table, sizeof(gcm_table));\n }\n \n #ifdef GCM_TABLES_USE_U64""}"," void prefetch_table(const void *tab, size_t len)
 {
   const volatile byte *vtab = tab;
   size_t i;
 
  for (i = 0; len - i >= 8 * 32; i += 8 * 32)
     {
       (void)vtab[i + 0 * 32];
       (void)vtab[i + 1 * 32];
      (void)vtab[i + 2 * 32];
      (void)vtab[i + 3 * 32];
      (void)vtab[i + 4 * 32];
      (void)vtab[i + 5 * 32];
       (void)vtab[i + 6 * 32];
       (void)vtab[i + 7 * 32];
     }
  for (; i < len; i += 32)
    {
      (void)vtab[i];
    }
 
   (void)vtab[len - 1];
 }
"," void prefetch_table(const void *tab, size_t len)
 {
   const volatile byte *vtab = tab;
   size_t i;
 
  for (i = 0; i < len; i += 8 * 32)
     {
       (void)vtab[i + 0 * 32];
       (void)vtab[i + 1 * 32];
      (void)vtab[i + 2 * 32];
      (void)vtab[i + 3 * 32];
      (void)vtab[i + 4 * 32];
      (void)vtab[i + 5 * 32];
       (void)vtab[i + 6 * 32];
       (void)vtab[i + 7 * 32];
     }
 
   (void)vtab[len - 1];
 }
",C,"  for (i = 0; len - i >= 8 * 32; i += 8 * 32)
  for (; i < len; i += 32)
    {
      (void)vtab[i];
    }
","  for (i = 0; i < len; i += 8 * 32)
",,"@@ -30,6 +30,14 @@
 #include ""./cipher-internal.h""
 
 
+/* Helper macro to force alignment to 16 or 64 bytes.  */
+#ifdef HAVE_GCC_ATTRIBUTE_ALIGNED
+# define ATTR_ALIGNED_64  __attribute__ ((aligned (64)))
+#else
+# define ATTR_ALIGNED_64
+#endif
+
+
 #ifdef GCM_USE_INTEL_PCLMUL
 extern void _gcry_ghash_setup_intel_pclmul (gcry_cipher_hd_t c);
 
@@ -83,48 +91,62 @@ ghash_armv7_neon (gcry_cipher_hd_t c, byte *result, const byte *buf,
 
 
 #ifdef GCM_USE_TABLES
-static const u16 gcmR[256] = {
-  0x0000, 0x01c2, 0x0384, 0x0246, 0x0708, 0x06ca, 0x048c, 0x054e,
-  0x0e10, 0x0fd2, 0x0d94, 0x0c56, 0x0918, 0x08da, 0x0a9c, 0x0b5e,
-  0x1c20, 0x1de2, 0x1fa4, 0x1e66, 0x1b28, 0x1aea, 0x18ac, 0x196e,
-  0x1230, 0x13f2, 0x11b4, 0x1076, 0x1538, 0x14fa, 0x16bc, 0x177e,
-  0x3840, 0x3982, 0x3bc4, 0x3a06, 0x3f48, 0x3e8a, 0x3ccc, 0x3d0e,
-  0x3650, 0x3792, 0x35d4, 0x3416, 0x3158, 0x309a, 0x32dc, 0x331e,
-  0x2460, 0x25a2, 0x27e4, 0x2626, 0x2368, 0x22aa, 0x20ec, 0x212e,
-  0x2a70, 0x2bb2, 0x29f4, 0x2836, 0x2d78, 0x2cba, 0x2efc, 0x2f3e,
-  0x7080, 0x7142, 0x7304, 0x72c6, 0x7788, 0x764a, 0x740c, 0x75ce,
-  0x7e90, 0x7f52, 0x7d14, 0x7cd6, 0x7998, 0x785a, 0x7a1c, 0x7bde,
-  0x6ca0, 0x6d62, 0x6f24, 0x6ee6, 0x6ba8, 0x6a6a, 0x682c, 0x69ee,
-  0x62b0, 0x6372, 0x6134, 0x60f6, 0x65b8, 0x647a, 0x663c, 0x67fe,
-  0x48c0, 0x4902, 0x4b44, 0x4a86, 0x4fc8, 0x4e0a, 0x4c4c, 0x4d8e,
-  0x46d0, 0x4712, 0x4554, 0x4496, 0x41d8, 0x401a, 0x425c, 0x439e,
-  0x54e0, 0x5522, 0x5764, 0x56a6, 0x53e8, 0x522a, 0x506c, 0x51ae,
-  0x5af0, 0x5b32, 0x5974, 0x58b6, 0x5df8, 0x5c3a, 0x5e7c, 0x5fbe,
-  0xe100, 0xe0c2, 0xe284, 0xe346, 0xe608, 0xe7ca, 0xe58c, 0xe44e,
-  0xef10, 0xeed2, 0xec94, 0xed56, 0xe818, 0xe9da, 0xeb9c, 0xea5e,
-  0xfd20, 0xfce2, 0xfea4, 0xff66, 0xfa28, 0xfbea, 0xf9ac, 0xf86e,
-  0xf330, 0xf2f2, 0xf0b4, 0xf176, 0xf438, 0xf5fa, 0xf7bc, 0xf67e,
-  0xd940, 0xd882, 0xdac4, 0xdb06, 0xde48, 0xdf8a, 0xddcc, 0xdc0e,
-  0xd750, 0xd692, 0xd4d4, 0xd516, 0xd058, 0xd19a, 0xd3dc, 0xd21e,
-  0xc560, 0xc4a2, 0xc6e4, 0xc726, 0xc268, 0xc3aa, 0xc1ec, 0xc02e,
-  0xcb70, 0xcab2, 0xc8f4, 0xc936, 0xcc78, 0xcdba, 0xcffc, 0xce3e,
-  0x9180, 0x9042, 0x9204, 0x93c6, 0x9688, 0x974a, 0x950c, 0x94ce,
-  0x9f90, 0x9e52, 0x9c14, 0x9dd6, 0x9898, 0x995a, 0x9b1c, 0x9ade,
-  0x8da0, 0x8c62, 0x8e24, 0x8fe6, 0x8aa8, 0x8b6a, 0x892c, 0x88ee,
-  0x83b0, 0x8272, 0x8034, 0x81f6, 0x84b8, 0x857a, 0x873c, 0x86fe,
-  0xa9c0, 0xa802, 0xaa44, 0xab86, 0xaec8, 0xaf0a, 0xad4c, 0xac8e,
-  0xa7d0, 0xa612, 0xa454, 0xa596, 0xa0d8, 0xa11a, 0xa35c, 0xa29e,
-  0xb5e0, 0xb422, 0xb664, 0xb7a6, 0xb2e8, 0xb32a, 0xb16c, 0xb0ae,
-  0xbbf0, 0xba32, 0xb874, 0xb9b6, 0xbcf8, 0xbd3a, 0xbf7c, 0xbebe,
-};
+static struct
+{
+  volatile u32 counter_head;
+  u32 cacheline_align[64 / 4 - 1];
+  u16 R[256];
+  volatile u32 counter_tail;
+} gcm_table ATTR_ALIGNED_64 =
+  {
+    0,
+    { 0, },
+    {
+      0x0000, 0x01c2, 0x0384, 0x0246, 0x0708, 0x06ca, 0x048c, 0x054e,
+      0x0e10, 0x0fd2, 0x0d94, 0x0c56, 0x0918, 0x08da, 0x0a9c, 0x0b5e,
+      0x1c20, 0x1de2, 0x1fa4, 0x1e66, 0x1b28, 0x1aea, 0x18ac, 0x196e,
+      0x1230, 0x13f2, 0x11b4, 0x1076, 0x1538, 0x14fa, 0x16bc, 0x177e,
+      0x3840, 0x3982, 0x3bc4, 0x3a06, 0x3f48, 0x3e8a, 0x3ccc, 0x3d0e,
+      0x3650, 0x3792, 0x35d4, 0x3416, 0x3158, 0x309a, 0x32dc, 0x331e,
+      0x2460, 0x25a2, 0x27e4, 0x2626, 0x2368, 0x22aa, 0x20ec, 0x212e,
+      0x2a70, 0x2bb2, 0x29f4, 0x2836, 0x2d78, 0x2cba, 0x2efc, 0x2f3e,
+      0x7080, 0x7142, 0x7304, 0x72c6, 0x7788, 0x764a, 0x740c, 0x75ce,
+      0x7e90, 0x7f52, 0x7d14, 0x7cd6, 0x7998, 0x785a, 0x7a1c, 0x7bde,
+      0x6ca0, 0x6d62, 0x6f24, 0x6ee6, 0x6ba8, 0x6a6a, 0x682c, 0x69ee,
+      0x62b0, 0x6372, 0x6134, 0x60f6, 0x65b8, 0x647a, 0x663c, 0x67fe,
+      0x48c0, 0x4902, 0x4b44, 0x4a86, 0x4fc8, 0x4e0a, 0x4c4c, 0x4d8e,
+      0x46d0, 0x4712, 0x4554, 0x4496, 0x41d8, 0x401a, 0x425c, 0x439e,
+      0x54e0, 0x5522, 0x5764, 0x56a6, 0x53e8, 0x522a, 0x506c, 0x51ae,
+      0x5af0, 0x5b32, 0x5974, 0x58b6, 0x5df8, 0x5c3a, 0x5e7c, 0x5fbe,
+      0xe100, 0xe0c2, 0xe284, 0xe346, 0xe608, 0xe7ca, 0xe58c, 0xe44e,
+      0xef10, 0xeed2, 0xec94, 0xed56, 0xe818, 0xe9da, 0xeb9c, 0xea5e,
+      0xfd20, 0xfce2, 0xfea4, 0xff66, 0xfa28, 0xfbea, 0xf9ac, 0xf86e,
+      0xf330, 0xf2f2, 0xf0b4, 0xf176, 0xf438, 0xf5fa, 0xf7bc, 0xf67e,
+      0xd940, 0xd882, 0xdac4, 0xdb06, 0xde48, 0xdf8a, 0xddcc, 0xdc0e,
+      0xd750, 0xd692, 0xd4d4, 0xd516, 0xd058, 0xd19a, 0xd3dc, 0xd21e,
+      0xc560, 0xc4a2, 0xc6e4, 0xc726, 0xc268, 0xc3aa, 0xc1ec, 0xc02e,
+      0xcb70, 0xcab2, 0xc8f4, 0xc936, 0xcc78, 0xcdba, 0xcffc, 0xce3e,
+      0x9180, 0x9042, 0x9204, 0x93c6, 0x9688, 0x974a, 0x950c, 0x94ce,
+      0x9f90, 0x9e52, 0x9c14, 0x9dd6, 0x9898, 0x995a, 0x9b1c, 0x9ade,
+      0x8da0, 0x8c62, 0x8e24, 0x8fe6, 0x8aa8, 0x8b6a, 0x892c, 0x88ee,
+      0x83b0, 0x8272, 0x8034, 0x81f6, 0x84b8, 0x857a, 0x873c, 0x86fe,
+      0xa9c0, 0xa802, 0xaa44, 0xab86, 0xaec8, 0xaf0a, 0xad4c, 0xac8e,
+      0xa7d0, 0xa612, 0xa454, 0xa596, 0xa0d8, 0xa11a, 0xa35c, 0xa29e,
+      0xb5e0, 0xb422, 0xb664, 0xb7a6, 0xb2e8, 0xb32a, 0xb16c, 0xb0ae,
+      0xbbf0, 0xba32, 0xb874, 0xb9b6, 0xbcf8, 0xbd3a, 0xbf7c, 0xbebe,
+    },
+    0
+  };
+
+#define gcmR gcm_table.R
 
 static inline
 void prefetch_table(const void *tab, size_t len)
 {
   const volatile byte *vtab = tab;
   size_t i;
 
-  for (i = 0; i < len; i += 8 * 32)
+  for (i = 0; len - i >= 8 * 32; i += 8 * 32)
     {
       (void)vtab[i + 0 * 32];
       (void)vtab[i + 1 * 32];
@@ -135,15 +157,27 @@ void prefetch_table(const void *tab, size_t len)
       (void)vtab[i + 6 * 32];
       (void)vtab[i + 7 * 32];
     }
+  for (; i < len; i += 32)
+    {
+      (void)vtab[i];
+    }
 
   (void)vtab[len - 1];
 }
 
 static inline void
 do_prefetch_tables (const void *gcmM, size_t gcmM_size)
 {
+  /* Modify counters to trigger copy-on-write and unsharing if physical pages
+   * of look-up table are shared between processes.  Modifying counters also
+   * causes checksums for pages to change and hint same-page merging algorithm
+   * that these pages are frequently changing.  */
+  gcm_table.counter_head++;
+  gcm_table.counter_tail++;
+
+  /* Prefetch look-up tables to cache.  */
   prefetch_table(gcmM, gcmM_size);
-  prefetch_table(gcmR, sizeof(gcmR));
+  prefetch_table(&gcm_table, sizeof(gcm_table));
 }
 
 #ifdef GCM_TABLES_USE_U64",libgcrypt,a4c561aab1014c3630bc88faf6f5246fee16b020,daedbbb5541cd8ecda1459d3b843ea4d92788762,1," void prefetch_table(const void *tab, size_t len)
 {
   const volatile byte *vtab = tab;
   size_t i;
 
//flaw_line_below:
  for (i = 0; i < len; i += 8 * 32)
//fix_flaw_line_below:
//  for (i = 0; len - i >= 8 * 32; i += 8 * 32)
     {
       (void)vtab[i + 0 * 32];
       (void)vtab[i + 1 * 32];
      (void)vtab[i + 2 * 32];
      (void)vtab[i + 3 * 32];
      (void)vtab[i + 4 * 32];
      (void)vtab[i + 5 * 32];
       (void)vtab[i + 6 * 32];
       (void)vtab[i + 7 * 32];
     }
//fix_flaw_line_below:
//  for (; i < len; i += 32)
//fix_flaw_line_below:
//    {
//fix_flaw_line_below:
//      (void)vtab[i];
//fix_flaw_line_below:
//    }
 
   (void)vtab[len - 1];
 }
"
5367,183103,,Remote,Not required,,CVE-2014-8275,https://www.cvedetails.com/cve/CVE-2014-8275/,CWE-310,Low,,Partial,,2015-01-08,5.0,"OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not enforce certain constraints on certificate data, which allows remote attackers to defeat a fingerprint-based certificate-blacklist protection mechanism by including crafted data within a certificate's unsigned portion, related to crypto/asn1/a_verify.c, crypto/dsa/dsa_asn1.c, crypto/ecdsa/ecs_vrf.c, and crypto/x509/x_all.c.",2017-11-14,,6,https://github.com/openssl/openssl/commit/684400ce192dac51df3d3e92b61830a6ef90be3e,684400ce192dac51df3d3e92b61830a6ef90be3e,"Fix various certificate fingerprint issues.

By using non-DER or invalid encodings outside the signed portion of a
certificate the fingerprint can be changed without breaking the signature.
Although no details of the signed portion of the certificate can be changed
this can cause problems with some applications: e.g. those using the
certificate fingerprint for blacklists.

1. Reject signatures with non zero unused bits.

If the BIT STRING containing the signature has non zero unused bits reject
the signature. All current signature algorithms require zero unused bits.

2. Check certificate algorithm consistency.

Check the AlgorithmIdentifier inside TBS matches the one in the
certificate signature. NB: this will result in signature failure
errors for some broken certificates.

3. Check DSA/ECDSA signatures use DER.

Reencode DSA/ECDSA signatures and compare with the original received
signature. Return an error if there is a mismatch.

This will reject various cases including garbage after signature
(thanks to Antti Karjalainen and Tuomo Untinen from the Codenomicon CROSS
program for discovering this case) and use of BER or invalid ASN.1 INTEGERs
(negative or with leading zeroes).

CVE-2014-8275
Reviewed-by: Emilia Ksper <emilia@openssl.org>",0,crypto/asn1/a_verify.c,"{""sha"": ""c076df8f2ec39fe6e54336bf886ec8e7d518c332"", ""filename"": ""CHANGES"", ""status"": ""modified"", ""additions"": 37, ""deletions"": 0, ""changes"": 37, ""blob_url"": ""https://github.com/openssl/openssl/blob/684400ce192dac51df3d3e92b61830a6ef90be3e/CHANGES"", ""raw_url"": ""https://github.com/openssl/openssl/raw/684400ce192dac51df3d3e92b61830a6ef90be3e/CHANGES"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/CHANGES?ref=684400ce192dac51df3d3e92b61830a6ef90be3e"", ""patch"": ""@@ -659,6 +659,43 @@\n \n  Changes between 1.0.1j and 1.0.1k [xx XXX xxxx]\n \n+  *) Fix various certificate fingerprint issues.\n+\n+     By using non-DER or invalid encodings outside the signed portion of a\n+     certificate the fingerprint can be changed without breaking the signature.\n+     Although no details of the signed portion of the certificate can be changed\n+     this can cause problems with some applications: e.g. those using the\n+     certificate fingerprint for blacklists.\n+\n+     1. Reject signatures with non zero unused bits.\n+\n+     If the BIT STRING containing the signature has non zero unused bits reject\n+     the signature. All current signature algorithms require zero unused bits.\n+\n+     2. Check certificate algorithm consistency.\n+\n+     Check the AlgorithmIdentifier inside TBS matches the one in the\n+     certificate signature. NB: this will result in signature failure\n+     errors for some broken certificates.\n+\n+     Thanks to Konrad Kraszewski from Google for reporting this issue.\n+\n+     3. Check DSA/ECDSA signatures use DER.\n+\n+     Reencode DSA/ECDSA signatures and compare with the original received\n+     signature. Return an error if there is a mismatch.\n+\n+     This will reject various cases including garbage after signature\n+     (thanks to Antti Karjalainen and Tuomo Untinen from the Codenomicon CROSS\n+     program for discovering this case) and use of BER or invalid ASN.1 INTEGERs\n+     (negative or with leading zeroes).\n+\n+     Further analysis was conducted and fixes were developed by Stephen Henson\n+     of the OpenSSL core team.\n+\n+     (CVE-2014-8275)\n+     [Steve Henson]\n+\n    *) Do not resume sessions on the server if the negotiated protocol\n       version does not match the session's version. Resuming with a different\n       version, while not strictly forbidden by the RFC, is of questionable""}<_**next**_>{""sha"": ""fdeeef6761e65fdd2b3c28deea66a52f4233354d"", ""filename"": ""crypto/asn1/a_verify.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/openssl/openssl/blob/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/asn1/a_verify.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/asn1/a_verify.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/asn1/a_verify.c?ref=684400ce192dac51df3d3e92b61830a6ef90be3e"", ""patch"": ""@@ -90,6 +90,12 @@ int ASN1_verify(i2d_of_void *i2d, X509_ALGOR *a, ASN1_BIT_STRING *signature,\n \t\tASN1err(ASN1_F_ASN1_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);\n \t\tgoto err;\n \t\t}\n+\n+\tif (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)\n+\t\t{\n+\t\tASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);\n+\t\tgoto err;\n+\t\t}\n \t\n \tinl=i2d(data,NULL);\n \tbuf_in=OPENSSL_malloc((unsigned int)inl);\n@@ -150,6 +156,12 @@ int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,\n \t\treturn -1;\n \t\t}\n \n+\tif (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)\n+\t\t{\n+\t\tASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);\n+\t\treturn -1;\n+\t\t}\n+\n \tEVP_MD_CTX_init(&ctx);\n \n \t/* Convert signature OID into digest and public key OIDs */""}<_**next**_>{""sha"": ""58559e54b1ece20eab0a04fdf475ac139e1fa65a"", ""filename"": ""crypto/dsa/dsa_asn1.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 1, ""changes"": 14, ""blob_url"": ""https://github.com/openssl/openssl/blob/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/dsa/dsa_asn1.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/dsa/dsa_asn1.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/dsa/dsa_asn1.c?ref=684400ce192dac51df3d3e92b61830a6ef90be3e"", ""patch"": ""@@ -177,13 +177,25 @@ int DSA_verify(int type, const unsigned char *dgst, int dgst_len,\n \t     const unsigned char *sigbuf, int siglen, DSA *dsa)\n \t{\n \tDSA_SIG *s;\n+\tconst unsigned char *p = sigbuf;\n+\tunsigned char *der = NULL;\n+\tint derlen = -1;\n \tint ret=-1;\n \n \ts = DSA_SIG_new();\n \tif (s == NULL) return(ret);\n-\tif (d2i_DSA_SIG(&s,&sigbuf,siglen) == NULL) goto err;\n+\tif (d2i_DSA_SIG(&s,&p,siglen) == NULL) goto err;\n+\t/* Ensure signature uses DER and doesn't have trailing garbage */\n+\tderlen = i2d_DSA_SIG(s, &der);\n+\tif (derlen != siglen || memcmp(sigbuf, der, derlen))\n+\t\tgoto err;\n \tret=DSA_do_verify(dgst,dgst_len,s,dsa);\n err:\n+\tif (derlen > 0)\n+\t\t{\n+\t\tOPENSSL_cleanse(der, derlen);\n+\t\tOPENSSL_free(der);\n+\t\t}\n \tDSA_SIG_free(s);\n \treturn(ret);\n \t}""}<_**next**_>{""sha"": ""7191b8ab0aea2c3631c1504fdc810a7364d98d56"", ""filename"": ""crypto/ecdsa/ecs_vrf.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 1, ""changes"": 15, ""blob_url"": ""https://github.com/openssl/openssl/blob/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/ecdsa/ecs_vrf.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/ecdsa/ecs_vrf.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/ecdsa/ecs_vrf.c?ref=684400ce192dac51df3d3e92b61830a6ef90be3e"", ""patch"": ""@@ -57,6 +57,7 @@\n  */\n \n #include \""ecs_locl.h\""\n+#include \""cryptlib.h\""\n #ifndef OPENSSL_NO_ENGINE\n #include <openssl/engine.h>\n #endif\n@@ -86,13 +87,25 @@ int ECDSA_verify(int type, const unsigned char *dgst, int dgst_len,\n \t\tconst unsigned char *sigbuf, int sig_len, EC_KEY *eckey)\n  \t{\n \tECDSA_SIG *s;\n+\tconst unsigned char *p = sigbuf;\n+\tunsigned char *der = NULL;\n+\tint derlen = -1;\n \tint ret=-1;\n \n \ts = ECDSA_SIG_new();\n \tif (s == NULL) return(ret);\n-\tif (d2i_ECDSA_SIG(&s, &sigbuf, sig_len) == NULL) goto err;\n+\tif (d2i_ECDSA_SIG(&s, &p, sig_len) == NULL) goto err;\n+\t/* Ensure signature uses DER and doesn't have trailing garbage */\n+\tderlen = i2d_ECDSA_SIG(s, &der);\n+\tif (derlen != sig_len || memcmp(sigbuf, der, derlen))\n+\t\tgoto err;\n \tret=ECDSA_do_verify(dgst, dgst_len, s, eckey);\n err:\n+\tif (derlen > 0)\n+\t\t{\n+\t\tOPENSSL_cleanse(der, derlen);\n+\t\tOPENSSL_free(der);\n+\t\t}\n \tECDSA_SIG_free(s);\n \treturn(ret);\n \t}""}<_**next**_>{""sha"": ""d7229506f644e8b52b2203da88909622d1d2417a"", ""filename"": ""crypto/x509/x_all.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/openssl/openssl/blob/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/x509/x_all.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/x509/x_all.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/x509/x_all.c?ref=684400ce192dac51df3d3e92b61830a6ef90be3e"", ""patch"": ""@@ -73,6 +73,8 @@\n \n int X509_verify(X509 *a, EVP_PKEY *r)\n \t{\n+\tif (X509_ALGOR_cmp(a->sig_alg, a->cert_info->signature))\n+\t\treturn 0;\n \treturn(ASN1_item_verify(ASN1_ITEM_rptr(X509_CINF),a->sig_alg,\n \t\ta->signature,a->cert_info,r));\n \t}""}","int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,
		ASN1_BIT_STRING *signature, void *asn, EVP_PKEY *pkey)
	{
	EVP_MD_CTX ctx;
	unsigned char *buf_in=NULL;
	int ret= -1,inl;

	int mdnid, pknid;

	if (!pkey)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);
 		return -1;
 		}
 
	if (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)
		{
		ASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);
		return -1;
		}

 	EVP_MD_CTX_init(&ctx);
 
 	/* Convert signature OID into digest and public key OIDs */
	if (!OBJ_find_sigid_algs(OBJ_obj2nid(a->algorithm), &mdnid, &pknid))
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);
		goto err;
		}
	if (mdnid == NID_undef)
		{
		if (!pkey->ameth || !pkey->ameth->item_verify)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);
			goto err;
			}
		ret = pkey->ameth->item_verify(&ctx, it, asn, a,
							signature, pkey);
		/* Return value of 2 means carry on, anything else means we
		 * exit straight away: either a fatal error of the underlying
		 * verification routine handles all verification.
		 */
		if (ret != 2)
			goto err;
		ret = -1;
		}
	else
		{
		const EVP_MD *type;
		type=EVP_get_digestbynid(mdnid);
		if (type == NULL)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);
			goto err;
			}

		/* Check public key OID matches public key type */
		if (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);
			goto err;
			}

		if (!EVP_DigestVerifyInit(&ctx, NULL, type, NULL, pkey))
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
			ret=0;
			goto err;
			}

		}

	inl = ASN1_item_i2d(asn, &buf_in, it);
	
	if (buf_in == NULL)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);
		goto err;
		}

	ret = EVP_DigestVerifyUpdate(&ctx,buf_in,inl);

	OPENSSL_cleanse(buf_in,(unsigned int)inl);
	OPENSSL_free(buf_in);

	if (!ret)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		goto err;
		}
	ret = -1;

	if (EVP_DigestVerifyFinal(&ctx,signature->data,
			(size_t)signature->length) <= 0)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}
	/* we don't need to zero the 'ctx' because we just checked
	 * public information */
	/* memset(&ctx,0,sizeof(ctx)); */
	ret=1;
err:
	EVP_MD_CTX_cleanup(&ctx);
	return(ret);
	}
","int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,
		ASN1_BIT_STRING *signature, void *asn, EVP_PKEY *pkey)
	{
	EVP_MD_CTX ctx;
	unsigned char *buf_in=NULL;
	int ret= -1,inl;

	int mdnid, pknid;

	if (!pkey)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);
 		return -1;
 		}
 
 	EVP_MD_CTX_init(&ctx);
 
 	/* Convert signature OID into digest and public key OIDs */
	if (!OBJ_find_sigid_algs(OBJ_obj2nid(a->algorithm), &mdnid, &pknid))
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);
		goto err;
		}
	if (mdnid == NID_undef)
		{
		if (!pkey->ameth || !pkey->ameth->item_verify)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);
			goto err;
			}
		ret = pkey->ameth->item_verify(&ctx, it, asn, a,
							signature, pkey);
		/* Return value of 2 means carry on, anything else means we
		 * exit straight away: either a fatal error of the underlying
		 * verification routine handles all verification.
		 */
		if (ret != 2)
			goto err;
		ret = -1;
		}
	else
		{
		const EVP_MD *type;
		type=EVP_get_digestbynid(mdnid);
		if (type == NULL)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);
			goto err;
			}

		/* Check public key OID matches public key type */
		if (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);
			goto err;
			}

		if (!EVP_DigestVerifyInit(&ctx, NULL, type, NULL, pkey))
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
			ret=0;
			goto err;
			}

		}

	inl = ASN1_item_i2d(asn, &buf_in, it);
	
	if (buf_in == NULL)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);
		goto err;
		}

	ret = EVP_DigestVerifyUpdate(&ctx,buf_in,inl);

	OPENSSL_cleanse(buf_in,(unsigned int)inl);
	OPENSSL_free(buf_in);

	if (!ret)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		goto err;
		}
	ret = -1;

	if (EVP_DigestVerifyFinal(&ctx,signature->data,
			(size_t)signature->length) <= 0)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}
	/* we don't need to zero the 'ctx' because we just checked
	 * public information */
	/* memset(&ctx,0,sizeof(ctx)); */
	ret=1;
err:
	EVP_MD_CTX_cleanup(&ctx);
	return(ret);
	}
",C,"	if (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)
		{
		ASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);
		return -1;
		}

",,,"@@ -90,6 +90,12 @@ int ASN1_verify(i2d_of_void *i2d, X509_ALGOR *a, ASN1_BIT_STRING *signature,
 		ASN1err(ASN1_F_ASN1_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);
 		goto err;
 		}
+
+	if (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)
+		{
+		ASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);
+		goto err;
+		}
 	
 	inl=i2d(data,NULL);
 	buf_in=OPENSSL_malloc((unsigned int)inl);
@@ -150,6 +156,12 @@ int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,
 		return -1;
 		}
 
+	if (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)
+		{
+		ASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);
+		return -1;
+		}
+
 	EVP_MD_CTX_init(&ctx);
 
 	/* Convert signature OID into digest and public key OIDs */",openssl,684400ce192dac51df3d3e92b61830a6ef90be3e,32b07f5a80d22b34cfcd6df76d425bed771b0146,1,"int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,
		ASN1_BIT_STRING *signature, void *asn, EVP_PKEY *pkey)
	{
	EVP_MD_CTX ctx;
	unsigned char *buf_in=NULL;
	int ret= -1,inl;

	int mdnid, pknid;

	if (!pkey)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);
 		return -1;
 		}
 
//fix_flaw_line_below:
//	if (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)
//fix_flaw_line_below:
//		{
//fix_flaw_line_below:
//		ASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);
//fix_flaw_line_below:
//		return -1;
//fix_flaw_line_below:
//		}
//fix_flaw_line_below:
//
 	EVP_MD_CTX_init(&ctx);
 
 	/* Convert signature OID into digest and public key OIDs */
	if (!OBJ_find_sigid_algs(OBJ_obj2nid(a->algorithm), &mdnid, &pknid))
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);
		goto err;
		}
	if (mdnid == NID_undef)
		{
		if (!pkey->ameth || !pkey->ameth->item_verify)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);
			goto err;
			}
		ret = pkey->ameth->item_verify(&ctx, it, asn, a,
							signature, pkey);
		/* Return value of 2 means carry on, anything else means we
		 * exit straight away: either a fatal error of the underlying
		 * verification routine handles all verification.
		 */
		if (ret != 2)
			goto err;
		ret = -1;
		}
	else
		{
		const EVP_MD *type;
		type=EVP_get_digestbynid(mdnid);
		if (type == NULL)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);
			goto err;
			}

		/* Check public key OID matches public key type */
		if (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);
			goto err;
			}

		if (!EVP_DigestVerifyInit(&ctx, NULL, type, NULL, pkey))
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
			ret=0;
			goto err;
			}

		}

	inl = ASN1_item_i2d(asn, &buf_in, it);
	
	if (buf_in == NULL)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);
		goto err;
		}

	ret = EVP_DigestVerifyUpdate(&ctx,buf_in,inl);

	OPENSSL_cleanse(buf_in,(unsigned int)inl);
	OPENSSL_free(buf_in);

	if (!ret)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		goto err;
		}
	ret = -1;

	if (EVP_DigestVerifyFinal(&ctx,signature->data,
			(size_t)signature->length) <= 0)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}
	/* we don't need to zero the 'ctx' because we just checked
	 * public information */
	/* memset(&ctx,0,sizeof(ctx)); */
	ret=1;
err:
	EVP_MD_CTX_cleanup(&ctx);
	return(ret);
	}
"
5368,183104,,Remote,Not required,,CVE-2014-8275,https://www.cvedetails.com/cve/CVE-2014-8275/,CWE-310,Low,,Partial,,2015-01-08,5.0,"OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not enforce certain constraints on certificate data, which allows remote attackers to defeat a fingerprint-based certificate-blacklist protection mechanism by including crafted data within a certificate's unsigned portion, related to crypto/asn1/a_verify.c, crypto/dsa/dsa_asn1.c, crypto/ecdsa/ecs_vrf.c, and crypto/x509/x_all.c.",2017-11-14,,6,https://github.com/openssl/openssl/commit/684400ce192dac51df3d3e92b61830a6ef90be3e,684400ce192dac51df3d3e92b61830a6ef90be3e,"Fix various certificate fingerprint issues.

By using non-DER or invalid encodings outside the signed portion of a
certificate the fingerprint can be changed without breaking the signature.
Although no details of the signed portion of the certificate can be changed
this can cause problems with some applications: e.g. those using the
certificate fingerprint for blacklists.

1. Reject signatures with non zero unused bits.

If the BIT STRING containing the signature has non zero unused bits reject
the signature. All current signature algorithms require zero unused bits.

2. Check certificate algorithm consistency.

Check the AlgorithmIdentifier inside TBS matches the one in the
certificate signature. NB: this will result in signature failure
errors for some broken certificates.

3. Check DSA/ECDSA signatures use DER.

Reencode DSA/ECDSA signatures and compare with the original received
signature. Return an error if there is a mismatch.

This will reject various cases including garbage after signature
(thanks to Antti Karjalainen and Tuomo Untinen from the Codenomicon CROSS
program for discovering this case) and use of BER or invalid ASN.1 INTEGERs
(negative or with leading zeroes).

CVE-2014-8275
Reviewed-by: Emilia Ksper <emilia@openssl.org>",0,crypto/asn1/a_verify.c,"{""sha"": ""c076df8f2ec39fe6e54336bf886ec8e7d518c332"", ""filename"": ""CHANGES"", ""status"": ""modified"", ""additions"": 37, ""deletions"": 0, ""changes"": 37, ""blob_url"": ""https://github.com/openssl/openssl/blob/684400ce192dac51df3d3e92b61830a6ef90be3e/CHANGES"", ""raw_url"": ""https://github.com/openssl/openssl/raw/684400ce192dac51df3d3e92b61830a6ef90be3e/CHANGES"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/CHANGES?ref=684400ce192dac51df3d3e92b61830a6ef90be3e"", ""patch"": ""@@ -659,6 +659,43 @@\n \n  Changes between 1.0.1j and 1.0.1k [xx XXX xxxx]\n \n+  *) Fix various certificate fingerprint issues.\n+\n+     By using non-DER or invalid encodings outside the signed portion of a\n+     certificate the fingerprint can be changed without breaking the signature.\n+     Although no details of the signed portion of the certificate can be changed\n+     this can cause problems with some applications: e.g. those using the\n+     certificate fingerprint for blacklists.\n+\n+     1. Reject signatures with non zero unused bits.\n+\n+     If the BIT STRING containing the signature has non zero unused bits reject\n+     the signature. All current signature algorithms require zero unused bits.\n+\n+     2. Check certificate algorithm consistency.\n+\n+     Check the AlgorithmIdentifier inside TBS matches the one in the\n+     certificate signature. NB: this will result in signature failure\n+     errors for some broken certificates.\n+\n+     Thanks to Konrad Kraszewski from Google for reporting this issue.\n+\n+     3. Check DSA/ECDSA signatures use DER.\n+\n+     Reencode DSA/ECDSA signatures and compare with the original received\n+     signature. Return an error if there is a mismatch.\n+\n+     This will reject various cases including garbage after signature\n+     (thanks to Antti Karjalainen and Tuomo Untinen from the Codenomicon CROSS\n+     program for discovering this case) and use of BER or invalid ASN.1 INTEGERs\n+     (negative or with leading zeroes).\n+\n+     Further analysis was conducted and fixes were developed by Stephen Henson\n+     of the OpenSSL core team.\n+\n+     (CVE-2014-8275)\n+     [Steve Henson]\n+\n    *) Do not resume sessions on the server if the negotiated protocol\n       version does not match the session's version. Resuming with a different\n       version, while not strictly forbidden by the RFC, is of questionable""}<_**next**_>{""sha"": ""fdeeef6761e65fdd2b3c28deea66a52f4233354d"", ""filename"": ""crypto/asn1/a_verify.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/openssl/openssl/blob/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/asn1/a_verify.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/asn1/a_verify.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/asn1/a_verify.c?ref=684400ce192dac51df3d3e92b61830a6ef90be3e"", ""patch"": ""@@ -90,6 +90,12 @@ int ASN1_verify(i2d_of_void *i2d, X509_ALGOR *a, ASN1_BIT_STRING *signature,\n \t\tASN1err(ASN1_F_ASN1_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);\n \t\tgoto err;\n \t\t}\n+\n+\tif (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)\n+\t\t{\n+\t\tASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);\n+\t\tgoto err;\n+\t\t}\n \t\n \tinl=i2d(data,NULL);\n \tbuf_in=OPENSSL_malloc((unsigned int)inl);\n@@ -150,6 +156,12 @@ int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,\n \t\treturn -1;\n \t\t}\n \n+\tif (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)\n+\t\t{\n+\t\tASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);\n+\t\treturn -1;\n+\t\t}\n+\n \tEVP_MD_CTX_init(&ctx);\n \n \t/* Convert signature OID into digest and public key OIDs */""}<_**next**_>{""sha"": ""58559e54b1ece20eab0a04fdf475ac139e1fa65a"", ""filename"": ""crypto/dsa/dsa_asn1.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 1, ""changes"": 14, ""blob_url"": ""https://github.com/openssl/openssl/blob/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/dsa/dsa_asn1.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/dsa/dsa_asn1.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/dsa/dsa_asn1.c?ref=684400ce192dac51df3d3e92b61830a6ef90be3e"", ""patch"": ""@@ -177,13 +177,25 @@ int DSA_verify(int type, const unsigned char *dgst, int dgst_len,\n \t     const unsigned char *sigbuf, int siglen, DSA *dsa)\n \t{\n \tDSA_SIG *s;\n+\tconst unsigned char *p = sigbuf;\n+\tunsigned char *der = NULL;\n+\tint derlen = -1;\n \tint ret=-1;\n \n \ts = DSA_SIG_new();\n \tif (s == NULL) return(ret);\n-\tif (d2i_DSA_SIG(&s,&sigbuf,siglen) == NULL) goto err;\n+\tif (d2i_DSA_SIG(&s,&p,siglen) == NULL) goto err;\n+\t/* Ensure signature uses DER and doesn't have trailing garbage */\n+\tderlen = i2d_DSA_SIG(s, &der);\n+\tif (derlen != siglen || memcmp(sigbuf, der, derlen))\n+\t\tgoto err;\n \tret=DSA_do_verify(dgst,dgst_len,s,dsa);\n err:\n+\tif (derlen > 0)\n+\t\t{\n+\t\tOPENSSL_cleanse(der, derlen);\n+\t\tOPENSSL_free(der);\n+\t\t}\n \tDSA_SIG_free(s);\n \treturn(ret);\n \t}""}<_**next**_>{""sha"": ""7191b8ab0aea2c3631c1504fdc810a7364d98d56"", ""filename"": ""crypto/ecdsa/ecs_vrf.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 1, ""changes"": 15, ""blob_url"": ""https://github.com/openssl/openssl/blob/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/ecdsa/ecs_vrf.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/ecdsa/ecs_vrf.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/ecdsa/ecs_vrf.c?ref=684400ce192dac51df3d3e92b61830a6ef90be3e"", ""patch"": ""@@ -57,6 +57,7 @@\n  */\n \n #include \""ecs_locl.h\""\n+#include \""cryptlib.h\""\n #ifndef OPENSSL_NO_ENGINE\n #include <openssl/engine.h>\n #endif\n@@ -86,13 +87,25 @@ int ECDSA_verify(int type, const unsigned char *dgst, int dgst_len,\n \t\tconst unsigned char *sigbuf, int sig_len, EC_KEY *eckey)\n  \t{\n \tECDSA_SIG *s;\n+\tconst unsigned char *p = sigbuf;\n+\tunsigned char *der = NULL;\n+\tint derlen = -1;\n \tint ret=-1;\n \n \ts = ECDSA_SIG_new();\n \tif (s == NULL) return(ret);\n-\tif (d2i_ECDSA_SIG(&s, &sigbuf, sig_len) == NULL) goto err;\n+\tif (d2i_ECDSA_SIG(&s, &p, sig_len) == NULL) goto err;\n+\t/* Ensure signature uses DER and doesn't have trailing garbage */\n+\tderlen = i2d_ECDSA_SIG(s, &der);\n+\tif (derlen != sig_len || memcmp(sigbuf, der, derlen))\n+\t\tgoto err;\n \tret=ECDSA_do_verify(dgst, dgst_len, s, eckey);\n err:\n+\tif (derlen > 0)\n+\t\t{\n+\t\tOPENSSL_cleanse(der, derlen);\n+\t\tOPENSSL_free(der);\n+\t\t}\n \tECDSA_SIG_free(s);\n \treturn(ret);\n \t}""}<_**next**_>{""sha"": ""d7229506f644e8b52b2203da88909622d1d2417a"", ""filename"": ""crypto/x509/x_all.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/openssl/openssl/blob/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/x509/x_all.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/x509/x_all.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/x509/x_all.c?ref=684400ce192dac51df3d3e92b61830a6ef90be3e"", ""patch"": ""@@ -73,6 +73,8 @@\n \n int X509_verify(X509 *a, EVP_PKEY *r)\n \t{\n+\tif (X509_ALGOR_cmp(a->sig_alg, a->cert_info->signature))\n+\t\treturn 0;\n \treturn(ASN1_item_verify(ASN1_ITEM_rptr(X509_CINF),a->sig_alg,\n \t\ta->signature,a->cert_info,r));\n \t}""}","int ASN1_verify(i2d_of_void *i2d, X509_ALGOR *a, ASN1_BIT_STRING *signature,
		char *data, EVP_PKEY *pkey)
	{
	EVP_MD_CTX ctx;
	const EVP_MD *type;
	unsigned char *p,*buf_in=NULL;
	int ret= -1,i,inl;

	EVP_MD_CTX_init(&ctx);
	i=OBJ_obj2nid(a->algorithm);
	type=EVP_get_digestbyname(OBJ_nid2sn(i));
	if (type == NULL)
		{
 		ASN1err(ASN1_F_ASN1_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);
 		goto err;
 		}

	if (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)
		{
		ASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);
		goto err;
		}
 	
 	inl=i2d(data,NULL);
 	buf_in=OPENSSL_malloc((unsigned int)inl);
	if (buf_in == NULL)
		{
		ASN1err(ASN1_F_ASN1_VERIFY,ERR_R_MALLOC_FAILURE);
		goto err;
		}
	p=buf_in;

	i2d(data,&p);
	ret=
		EVP_VerifyInit_ex(&ctx,type, NULL)
		&& EVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);

	OPENSSL_cleanse(buf_in,(unsigned int)inl);
	OPENSSL_free(buf_in);

	if (!ret)
		{
		ASN1err(ASN1_F_ASN1_VERIFY,ERR_R_EVP_LIB);
		goto err;
		}
	ret = -1;


	if (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,
			(unsigned int)signature->length,pkey) <= 0)
		{
		ASN1err(ASN1_F_ASN1_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}
	/* we don't need to zero the 'ctx' because we just checked
	 * public information */
	/* memset(&ctx,0,sizeof(ctx)); */
	ret=1;
err:
	EVP_MD_CTX_cleanup(&ctx);
	return(ret);
	}
","int ASN1_verify(i2d_of_void *i2d, X509_ALGOR *a, ASN1_BIT_STRING *signature,
		char *data, EVP_PKEY *pkey)
	{
	EVP_MD_CTX ctx;
	const EVP_MD *type;
	unsigned char *p,*buf_in=NULL;
	int ret= -1,i,inl;

	EVP_MD_CTX_init(&ctx);
	i=OBJ_obj2nid(a->algorithm);
	type=EVP_get_digestbyname(OBJ_nid2sn(i));
	if (type == NULL)
		{
 		ASN1err(ASN1_F_ASN1_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);
 		goto err;
 		}
 	
 	inl=i2d(data,NULL);
 	buf_in=OPENSSL_malloc((unsigned int)inl);
	if (buf_in == NULL)
		{
		ASN1err(ASN1_F_ASN1_VERIFY,ERR_R_MALLOC_FAILURE);
		goto err;
		}
	p=buf_in;

	i2d(data,&p);
	ret=
		EVP_VerifyInit_ex(&ctx,type, NULL)
		&& EVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);

	OPENSSL_cleanse(buf_in,(unsigned int)inl);
	OPENSSL_free(buf_in);

	if (!ret)
		{
		ASN1err(ASN1_F_ASN1_VERIFY,ERR_R_EVP_LIB);
		goto err;
		}
	ret = -1;


	if (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,
			(unsigned int)signature->length,pkey) <= 0)
		{
		ASN1err(ASN1_F_ASN1_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}
	/* we don't need to zero the 'ctx' because we just checked
	 * public information */
	/* memset(&ctx,0,sizeof(ctx)); */
	ret=1;
err:
	EVP_MD_CTX_cleanup(&ctx);
	return(ret);
	}
",C,"
	if (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)
		{
		ASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);
		goto err;
		}
",,,"@@ -90,6 +90,12 @@ int ASN1_verify(i2d_of_void *i2d, X509_ALGOR *a, ASN1_BIT_STRING *signature,
 		ASN1err(ASN1_F_ASN1_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);
 		goto err;
 		}
+
+	if (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)
+		{
+		ASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);
+		goto err;
+		}
 	
 	inl=i2d(data,NULL);
 	buf_in=OPENSSL_malloc((unsigned int)inl);
@@ -150,6 +156,12 @@ int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,
 		return -1;
 		}
 
+	if (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)
+		{
+		ASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);
+		return -1;
+		}
+
 	EVP_MD_CTX_init(&ctx);
 
 	/* Convert signature OID into digest and public key OIDs */",openssl,684400ce192dac51df3d3e92b61830a6ef90be3e,32b07f5a80d22b34cfcd6df76d425bed771b0146,1,"int ASN1_verify(i2d_of_void *i2d, X509_ALGOR *a, ASN1_BIT_STRING *signature,
		char *data, EVP_PKEY *pkey)
	{
	EVP_MD_CTX ctx;
	const EVP_MD *type;
	unsigned char *p,*buf_in=NULL;
	int ret= -1,i,inl;

	EVP_MD_CTX_init(&ctx);
	i=OBJ_obj2nid(a->algorithm);
	type=EVP_get_digestbyname(OBJ_nid2sn(i));
	if (type == NULL)
		{
 		ASN1err(ASN1_F_ASN1_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);
 		goto err;
 		}
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//	if (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)
//fix_flaw_line_below:
//		{
//fix_flaw_line_below:
//		ASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);
//fix_flaw_line_below:
//		goto err;
//fix_flaw_line_below:
//		}
 	
 	inl=i2d(data,NULL);
 	buf_in=OPENSSL_malloc((unsigned int)inl);
	if (buf_in == NULL)
		{
		ASN1err(ASN1_F_ASN1_VERIFY,ERR_R_MALLOC_FAILURE);
		goto err;
		}
	p=buf_in;

	i2d(data,&p);
	ret=
		EVP_VerifyInit_ex(&ctx,type, NULL)
		&& EVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);

	OPENSSL_cleanse(buf_in,(unsigned int)inl);
	OPENSSL_free(buf_in);

	if (!ret)
		{
		ASN1err(ASN1_F_ASN1_VERIFY,ERR_R_EVP_LIB);
		goto err;
		}
	ret = -1;


	if (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,
			(unsigned int)signature->length,pkey) <= 0)
		{
		ASN1err(ASN1_F_ASN1_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}
	/* we don't need to zero the 'ctx' because we just checked
	 * public information */
	/* memset(&ctx,0,sizeof(ctx)); */
	ret=1;
err:
	EVP_MD_CTX_cleanup(&ctx);
	return(ret);
	}
"
5369,183105,,Remote,Not required,,CVE-2014-8275,https://www.cvedetails.com/cve/CVE-2014-8275/,CWE-310,Low,,Partial,,2015-01-08,5.0,"OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not enforce certain constraints on certificate data, which allows remote attackers to defeat a fingerprint-based certificate-blacklist protection mechanism by including crafted data within a certificate's unsigned portion, related to crypto/asn1/a_verify.c, crypto/dsa/dsa_asn1.c, crypto/ecdsa/ecs_vrf.c, and crypto/x509/x_all.c.",2017-11-14,,13,https://github.com/openssl/openssl/commit/684400ce192dac51df3d3e92b61830a6ef90be3e,684400ce192dac51df3d3e92b61830a6ef90be3e,"Fix various certificate fingerprint issues.

By using non-DER or invalid encodings outside the signed portion of a
certificate the fingerprint can be changed without breaking the signature.
Although no details of the signed portion of the certificate can be changed
this can cause problems with some applications: e.g. those using the
certificate fingerprint for blacklists.

1. Reject signatures with non zero unused bits.

If the BIT STRING containing the signature has non zero unused bits reject
the signature. All current signature algorithms require zero unused bits.

2. Check certificate algorithm consistency.

Check the AlgorithmIdentifier inside TBS matches the one in the
certificate signature. NB: this will result in signature failure
errors for some broken certificates.

3. Check DSA/ECDSA signatures use DER.

Reencode DSA/ECDSA signatures and compare with the original received
signature. Return an error if there is a mismatch.

This will reject various cases including garbage after signature
(thanks to Antti Karjalainen and Tuomo Untinen from the Codenomicon CROSS
program for discovering this case) and use of BER or invalid ASN.1 INTEGERs
(negative or with leading zeroes).

CVE-2014-8275
Reviewed-by: Emilia Ksper <emilia@openssl.org>",1,crypto/ecdsa/ecs_vrf.c,"{""sha"": ""c076df8f2ec39fe6e54336bf886ec8e7d518c332"", ""filename"": ""CHANGES"", ""status"": ""modified"", ""additions"": 37, ""deletions"": 0, ""changes"": 37, ""blob_url"": ""https://github.com/openssl/openssl/blob/684400ce192dac51df3d3e92b61830a6ef90be3e/CHANGES"", ""raw_url"": ""https://github.com/openssl/openssl/raw/684400ce192dac51df3d3e92b61830a6ef90be3e/CHANGES"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/CHANGES?ref=684400ce192dac51df3d3e92b61830a6ef90be3e"", ""patch"": ""@@ -659,6 +659,43 @@\n \n  Changes between 1.0.1j and 1.0.1k [xx XXX xxxx]\n \n+  *) Fix various certificate fingerprint issues.\n+\n+     By using non-DER or invalid encodings outside the signed portion of a\n+     certificate the fingerprint can be changed without breaking the signature.\n+     Although no details of the signed portion of the certificate can be changed\n+     this can cause problems with some applications: e.g. those using the\n+     certificate fingerprint for blacklists.\n+\n+     1. Reject signatures with non zero unused bits.\n+\n+     If the BIT STRING containing the signature has non zero unused bits reject\n+     the signature. All current signature algorithms require zero unused bits.\n+\n+     2. Check certificate algorithm consistency.\n+\n+     Check the AlgorithmIdentifier inside TBS matches the one in the\n+     certificate signature. NB: this will result in signature failure\n+     errors for some broken certificates.\n+\n+     Thanks to Konrad Kraszewski from Google for reporting this issue.\n+\n+     3. Check DSA/ECDSA signatures use DER.\n+\n+     Reencode DSA/ECDSA signatures and compare with the original received\n+     signature. Return an error if there is a mismatch.\n+\n+     This will reject various cases including garbage after signature\n+     (thanks to Antti Karjalainen and Tuomo Untinen from the Codenomicon CROSS\n+     program for discovering this case) and use of BER or invalid ASN.1 INTEGERs\n+     (negative or with leading zeroes).\n+\n+     Further analysis was conducted and fixes were developed by Stephen Henson\n+     of the OpenSSL core team.\n+\n+     (CVE-2014-8275)\n+     [Steve Henson]\n+\n    *) Do not resume sessions on the server if the negotiated protocol\n       version does not match the session's version. Resuming with a different\n       version, while not strictly forbidden by the RFC, is of questionable""}<_**next**_>{""sha"": ""fdeeef6761e65fdd2b3c28deea66a52f4233354d"", ""filename"": ""crypto/asn1/a_verify.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/openssl/openssl/blob/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/asn1/a_verify.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/asn1/a_verify.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/asn1/a_verify.c?ref=684400ce192dac51df3d3e92b61830a6ef90be3e"", ""patch"": ""@@ -90,6 +90,12 @@ int ASN1_verify(i2d_of_void *i2d, X509_ALGOR *a, ASN1_BIT_STRING *signature,\n \t\tASN1err(ASN1_F_ASN1_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);\n \t\tgoto err;\n \t\t}\n+\n+\tif (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)\n+\t\t{\n+\t\tASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);\n+\t\tgoto err;\n+\t\t}\n \t\n \tinl=i2d(data,NULL);\n \tbuf_in=OPENSSL_malloc((unsigned int)inl);\n@@ -150,6 +156,12 @@ int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,\n \t\treturn -1;\n \t\t}\n \n+\tif (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)\n+\t\t{\n+\t\tASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);\n+\t\treturn -1;\n+\t\t}\n+\n \tEVP_MD_CTX_init(&ctx);\n \n \t/* Convert signature OID into digest and public key OIDs */""}<_**next**_>{""sha"": ""58559e54b1ece20eab0a04fdf475ac139e1fa65a"", ""filename"": ""crypto/dsa/dsa_asn1.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 1, ""changes"": 14, ""blob_url"": ""https://github.com/openssl/openssl/blob/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/dsa/dsa_asn1.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/dsa/dsa_asn1.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/dsa/dsa_asn1.c?ref=684400ce192dac51df3d3e92b61830a6ef90be3e"", ""patch"": ""@@ -177,13 +177,25 @@ int DSA_verify(int type, const unsigned char *dgst, int dgst_len,\n \t     const unsigned char *sigbuf, int siglen, DSA *dsa)\n \t{\n \tDSA_SIG *s;\n+\tconst unsigned char *p = sigbuf;\n+\tunsigned char *der = NULL;\n+\tint derlen = -1;\n \tint ret=-1;\n \n \ts = DSA_SIG_new();\n \tif (s == NULL) return(ret);\n-\tif (d2i_DSA_SIG(&s,&sigbuf,siglen) == NULL) goto err;\n+\tif (d2i_DSA_SIG(&s,&p,siglen) == NULL) goto err;\n+\t/* Ensure signature uses DER and doesn't have trailing garbage */\n+\tderlen = i2d_DSA_SIG(s, &der);\n+\tif (derlen != siglen || memcmp(sigbuf, der, derlen))\n+\t\tgoto err;\n \tret=DSA_do_verify(dgst,dgst_len,s,dsa);\n err:\n+\tif (derlen > 0)\n+\t\t{\n+\t\tOPENSSL_cleanse(der, derlen);\n+\t\tOPENSSL_free(der);\n+\t\t}\n \tDSA_SIG_free(s);\n \treturn(ret);\n \t}""}<_**next**_>{""sha"": ""7191b8ab0aea2c3631c1504fdc810a7364d98d56"", ""filename"": ""crypto/ecdsa/ecs_vrf.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 1, ""changes"": 15, ""blob_url"": ""https://github.com/openssl/openssl/blob/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/ecdsa/ecs_vrf.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/ecdsa/ecs_vrf.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/ecdsa/ecs_vrf.c?ref=684400ce192dac51df3d3e92b61830a6ef90be3e"", ""patch"": ""@@ -57,6 +57,7 @@\n  */\n \n #include \""ecs_locl.h\""\n+#include \""cryptlib.h\""\n #ifndef OPENSSL_NO_ENGINE\n #include <openssl/engine.h>\n #endif\n@@ -86,13 +87,25 @@ int ECDSA_verify(int type, const unsigned char *dgst, int dgst_len,\n \t\tconst unsigned char *sigbuf, int sig_len, EC_KEY *eckey)\n  \t{\n \tECDSA_SIG *s;\n+\tconst unsigned char *p = sigbuf;\n+\tunsigned char *der = NULL;\n+\tint derlen = -1;\n \tint ret=-1;\n \n \ts = ECDSA_SIG_new();\n \tif (s == NULL) return(ret);\n-\tif (d2i_ECDSA_SIG(&s, &sigbuf, sig_len) == NULL) goto err;\n+\tif (d2i_ECDSA_SIG(&s, &p, sig_len) == NULL) goto err;\n+\t/* Ensure signature uses DER and doesn't have trailing garbage */\n+\tderlen = i2d_ECDSA_SIG(s, &der);\n+\tif (derlen != sig_len || memcmp(sigbuf, der, derlen))\n+\t\tgoto err;\n \tret=ECDSA_do_verify(dgst, dgst_len, s, eckey);\n err:\n+\tif (derlen > 0)\n+\t\t{\n+\t\tOPENSSL_cleanse(der, derlen);\n+\t\tOPENSSL_free(der);\n+\t\t}\n \tECDSA_SIG_free(s);\n \treturn(ret);\n \t}""}<_**next**_>{""sha"": ""d7229506f644e8b52b2203da88909622d1d2417a"", ""filename"": ""crypto/x509/x_all.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/openssl/openssl/blob/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/x509/x_all.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/x509/x_all.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/x509/x_all.c?ref=684400ce192dac51df3d3e92b61830a6ef90be3e"", ""patch"": ""@@ -73,6 +73,8 @@\n \n int X509_verify(X509 *a, EVP_PKEY *r)\n \t{\n+\tif (X509_ALGOR_cmp(a->sig_alg, a->cert_info->signature))\n+\t\treturn 0;\n \treturn(ASN1_item_verify(ASN1_ITEM_rptr(X509_CINF),a->sig_alg,\n \t\ta->signature,a->cert_info,r));\n \t}""}","int ECDSA_verify(int type, const unsigned char *dgst, int dgst_len,
 		const unsigned char *sigbuf, int sig_len, EC_KEY *eckey)
  	{
 	ECDSA_SIG *s;
	const unsigned char *p = sigbuf;
	unsigned char *der = NULL;
	int derlen = -1;
 	int ret=-1;
 
 	s = ECDSA_SIG_new();
 	if (s == NULL) return(ret);
	if (d2i_ECDSA_SIG(&s, &p, sig_len) == NULL) goto err;
	/* Ensure signature uses DER and doesn't have trailing garbage */
	derlen = i2d_ECDSA_SIG(s, &der);
	if (derlen != sig_len || memcmp(sigbuf, der, derlen))
		goto err;
 	ret=ECDSA_do_verify(dgst, dgst_len, s, eckey);
 err:
	if (derlen > 0)
		{
		OPENSSL_cleanse(der, derlen);
		OPENSSL_free(der);
		}
 	ECDSA_SIG_free(s);
 	return(ret);
 	}
","int ECDSA_verify(int type, const unsigned char *dgst, int dgst_len,
 		const unsigned char *sigbuf, int sig_len, EC_KEY *eckey)
  	{
 	ECDSA_SIG *s;
 	int ret=-1;
 
 	s = ECDSA_SIG_new();
 	if (s == NULL) return(ret);
	if (d2i_ECDSA_SIG(&s, &sigbuf, sig_len) == NULL) goto err;
 	ret=ECDSA_do_verify(dgst, dgst_len, s, eckey);
 err:
 	ECDSA_SIG_free(s);
 	return(ret);
 	}
",C,"	const unsigned char *p = sigbuf;
	unsigned char *der = NULL;
	int derlen = -1;
	if (d2i_ECDSA_SIG(&s, &p, sig_len) == NULL) goto err;
	/* Ensure signature uses DER and doesn't have trailing garbage */
	derlen = i2d_ECDSA_SIG(s, &der);
	if (derlen != sig_len || memcmp(sigbuf, der, derlen))
		goto err;
	if (derlen > 0)
		{
		OPENSSL_cleanse(der, derlen);
		OPENSSL_free(der);
		}
","	if (d2i_ECDSA_SIG(&s, &sigbuf, sig_len) == NULL) goto err;
",,"@@ -57,6 +57,7 @@
  */
 
 #include ""ecs_locl.h""
+#include ""cryptlib.h""
 #ifndef OPENSSL_NO_ENGINE
 #include <openssl/engine.h>
 #endif
@@ -86,13 +87,25 @@ int ECDSA_verify(int type, const unsigned char *dgst, int dgst_len,
 		const unsigned char *sigbuf, int sig_len, EC_KEY *eckey)
  	{
 	ECDSA_SIG *s;
+	const unsigned char *p = sigbuf;
+	unsigned char *der = NULL;
+	int derlen = -1;
 	int ret=-1;
 
 	s = ECDSA_SIG_new();
 	if (s == NULL) return(ret);
-	if (d2i_ECDSA_SIG(&s, &sigbuf, sig_len) == NULL) goto err;
+	if (d2i_ECDSA_SIG(&s, &p, sig_len) == NULL) goto err;
+	/* Ensure signature uses DER and doesn't have trailing garbage */
+	derlen = i2d_ECDSA_SIG(s, &der);
+	if (derlen != sig_len || memcmp(sigbuf, der, derlen))
+		goto err;
 	ret=ECDSA_do_verify(dgst, dgst_len, s, eckey);
 err:
+	if (derlen > 0)
+		{
+		OPENSSL_cleanse(der, derlen);
+		OPENSSL_free(der);
+		}
 	ECDSA_SIG_free(s);
 	return(ret);
 	}",openssl,684400ce192dac51df3d3e92b61830a6ef90be3e,32b07f5a80d22b34cfcd6df76d425bed771b0146,1,"int ECDSA_verify(int type, const unsigned char *dgst, int dgst_len,
 		const unsigned char *sigbuf, int sig_len, EC_KEY *eckey)
  	{
 	ECDSA_SIG *s;
//fix_flaw_line_below:
//	const unsigned char *p = sigbuf;
//fix_flaw_line_below:
//	unsigned char *der = NULL;
//fix_flaw_line_below:
//	int derlen = -1;
 	int ret=-1;
 
 	s = ECDSA_SIG_new();
 	if (s == NULL) return(ret);
//flaw_line_below:
	if (d2i_ECDSA_SIG(&s, &sigbuf, sig_len) == NULL) goto err;
//fix_flaw_line_below:
//	if (d2i_ECDSA_SIG(&s, &p, sig_len) == NULL) goto err;
//fix_flaw_line_below:
//	/* Ensure signature uses DER and doesn't have trailing garbage */
//fix_flaw_line_below:
//	derlen = i2d_ECDSA_SIG(s, &der);
//fix_flaw_line_below:
//	if (derlen != sig_len || memcmp(sigbuf, der, derlen))
//fix_flaw_line_below:
//		goto err;
 	ret=ECDSA_do_verify(dgst, dgst_len, s, eckey);
 err:
//fix_flaw_line_below:
//	if (derlen > 0)
//fix_flaw_line_below:
//		{
//fix_flaw_line_below:
//		OPENSSL_cleanse(der, derlen);
//fix_flaw_line_below:
//		OPENSSL_free(der);
//fix_flaw_line_below:
//		}
 	ECDSA_SIG_free(s);
 	return(ret);
 	}
"
5370,183106,,Remote,Not required,,CVE-2014-8275,https://www.cvedetails.com/cve/CVE-2014-8275/,CWE-310,Low,,Partial,,2015-01-08,5.0,"OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not enforce certain constraints on certificate data, which allows remote attackers to defeat a fingerprint-based certificate-blacklist protection mechanism by including crafted data within a certificate's unsigned portion, related to crypto/asn1/a_verify.c, crypto/dsa/dsa_asn1.c, crypto/ecdsa/ecs_vrf.c, and crypto/x509/x_all.c.",2017-11-14,,2,https://github.com/openssl/openssl/commit/684400ce192dac51df3d3e92b61830a6ef90be3e,684400ce192dac51df3d3e92b61830a6ef90be3e,"Fix various certificate fingerprint issues.

By using non-DER or invalid encodings outside the signed portion of a
certificate the fingerprint can be changed without breaking the signature.
Although no details of the signed portion of the certificate can be changed
this can cause problems with some applications: e.g. those using the
certificate fingerprint for blacklists.

1. Reject signatures with non zero unused bits.

If the BIT STRING containing the signature has non zero unused bits reject
the signature. All current signature algorithms require zero unused bits.

2. Check certificate algorithm consistency.

Check the AlgorithmIdentifier inside TBS matches the one in the
certificate signature. NB: this will result in signature failure
errors for some broken certificates.

3. Check DSA/ECDSA signatures use DER.

Reencode DSA/ECDSA signatures and compare with the original received
signature. Return an error if there is a mismatch.

This will reject various cases including garbage after signature
(thanks to Antti Karjalainen and Tuomo Untinen from the Codenomicon CROSS
program for discovering this case) and use of BER or invalid ASN.1 INTEGERs
(negative or with leading zeroes).

CVE-2014-8275
Reviewed-by: Emilia Ksper <emilia@openssl.org>",0,crypto/x509/x_all.c,"{""sha"": ""c076df8f2ec39fe6e54336bf886ec8e7d518c332"", ""filename"": ""CHANGES"", ""status"": ""modified"", ""additions"": 37, ""deletions"": 0, ""changes"": 37, ""blob_url"": ""https://github.com/openssl/openssl/blob/684400ce192dac51df3d3e92b61830a6ef90be3e/CHANGES"", ""raw_url"": ""https://github.com/openssl/openssl/raw/684400ce192dac51df3d3e92b61830a6ef90be3e/CHANGES"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/CHANGES?ref=684400ce192dac51df3d3e92b61830a6ef90be3e"", ""patch"": ""@@ -659,6 +659,43 @@\n \n  Changes between 1.0.1j and 1.0.1k [xx XXX xxxx]\n \n+  *) Fix various certificate fingerprint issues.\n+\n+     By using non-DER or invalid encodings outside the signed portion of a\n+     certificate the fingerprint can be changed without breaking the signature.\n+     Although no details of the signed portion of the certificate can be changed\n+     this can cause problems with some applications: e.g. those using the\n+     certificate fingerprint for blacklists.\n+\n+     1. Reject signatures with non zero unused bits.\n+\n+     If the BIT STRING containing the signature has non zero unused bits reject\n+     the signature. All current signature algorithms require zero unused bits.\n+\n+     2. Check certificate algorithm consistency.\n+\n+     Check the AlgorithmIdentifier inside TBS matches the one in the\n+     certificate signature. NB: this will result in signature failure\n+     errors for some broken certificates.\n+\n+     Thanks to Konrad Kraszewski from Google for reporting this issue.\n+\n+     3. Check DSA/ECDSA signatures use DER.\n+\n+     Reencode DSA/ECDSA signatures and compare with the original received\n+     signature. Return an error if there is a mismatch.\n+\n+     This will reject various cases including garbage after signature\n+     (thanks to Antti Karjalainen and Tuomo Untinen from the Codenomicon CROSS\n+     program for discovering this case) and use of BER or invalid ASN.1 INTEGERs\n+     (negative or with leading zeroes).\n+\n+     Further analysis was conducted and fixes were developed by Stephen Henson\n+     of the OpenSSL core team.\n+\n+     (CVE-2014-8275)\n+     [Steve Henson]\n+\n    *) Do not resume sessions on the server if the negotiated protocol\n       version does not match the session's version. Resuming with a different\n       version, while not strictly forbidden by the RFC, is of questionable""}<_**next**_>{""sha"": ""fdeeef6761e65fdd2b3c28deea66a52f4233354d"", ""filename"": ""crypto/asn1/a_verify.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/openssl/openssl/blob/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/asn1/a_verify.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/asn1/a_verify.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/asn1/a_verify.c?ref=684400ce192dac51df3d3e92b61830a6ef90be3e"", ""patch"": ""@@ -90,6 +90,12 @@ int ASN1_verify(i2d_of_void *i2d, X509_ALGOR *a, ASN1_BIT_STRING *signature,\n \t\tASN1err(ASN1_F_ASN1_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);\n \t\tgoto err;\n \t\t}\n+\n+\tif (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)\n+\t\t{\n+\t\tASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);\n+\t\tgoto err;\n+\t\t}\n \t\n \tinl=i2d(data,NULL);\n \tbuf_in=OPENSSL_malloc((unsigned int)inl);\n@@ -150,6 +156,12 @@ int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,\n \t\treturn -1;\n \t\t}\n \n+\tif (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)\n+\t\t{\n+\t\tASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);\n+\t\treturn -1;\n+\t\t}\n+\n \tEVP_MD_CTX_init(&ctx);\n \n \t/* Convert signature OID into digest and public key OIDs */""}<_**next**_>{""sha"": ""58559e54b1ece20eab0a04fdf475ac139e1fa65a"", ""filename"": ""crypto/dsa/dsa_asn1.c"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 1, ""changes"": 14, ""blob_url"": ""https://github.com/openssl/openssl/blob/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/dsa/dsa_asn1.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/dsa/dsa_asn1.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/dsa/dsa_asn1.c?ref=684400ce192dac51df3d3e92b61830a6ef90be3e"", ""patch"": ""@@ -177,13 +177,25 @@ int DSA_verify(int type, const unsigned char *dgst, int dgst_len,\n \t     const unsigned char *sigbuf, int siglen, DSA *dsa)\n \t{\n \tDSA_SIG *s;\n+\tconst unsigned char *p = sigbuf;\n+\tunsigned char *der = NULL;\n+\tint derlen = -1;\n \tint ret=-1;\n \n \ts = DSA_SIG_new();\n \tif (s == NULL) return(ret);\n-\tif (d2i_DSA_SIG(&s,&sigbuf,siglen) == NULL) goto err;\n+\tif (d2i_DSA_SIG(&s,&p,siglen) == NULL) goto err;\n+\t/* Ensure signature uses DER and doesn't have trailing garbage */\n+\tderlen = i2d_DSA_SIG(s, &der);\n+\tif (derlen != siglen || memcmp(sigbuf, der, derlen))\n+\t\tgoto err;\n \tret=DSA_do_verify(dgst,dgst_len,s,dsa);\n err:\n+\tif (derlen > 0)\n+\t\t{\n+\t\tOPENSSL_cleanse(der, derlen);\n+\t\tOPENSSL_free(der);\n+\t\t}\n \tDSA_SIG_free(s);\n \treturn(ret);\n \t}""}<_**next**_>{""sha"": ""7191b8ab0aea2c3631c1504fdc810a7364d98d56"", ""filename"": ""crypto/ecdsa/ecs_vrf.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 1, ""changes"": 15, ""blob_url"": ""https://github.com/openssl/openssl/blob/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/ecdsa/ecs_vrf.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/ecdsa/ecs_vrf.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/ecdsa/ecs_vrf.c?ref=684400ce192dac51df3d3e92b61830a6ef90be3e"", ""patch"": ""@@ -57,6 +57,7 @@\n  */\n \n #include \""ecs_locl.h\""\n+#include \""cryptlib.h\""\n #ifndef OPENSSL_NO_ENGINE\n #include <openssl/engine.h>\n #endif\n@@ -86,13 +87,25 @@ int ECDSA_verify(int type, const unsigned char *dgst, int dgst_len,\n \t\tconst unsigned char *sigbuf, int sig_len, EC_KEY *eckey)\n  \t{\n \tECDSA_SIG *s;\n+\tconst unsigned char *p = sigbuf;\n+\tunsigned char *der = NULL;\n+\tint derlen = -1;\n \tint ret=-1;\n \n \ts = ECDSA_SIG_new();\n \tif (s == NULL) return(ret);\n-\tif (d2i_ECDSA_SIG(&s, &sigbuf, sig_len) == NULL) goto err;\n+\tif (d2i_ECDSA_SIG(&s, &p, sig_len) == NULL) goto err;\n+\t/* Ensure signature uses DER and doesn't have trailing garbage */\n+\tderlen = i2d_ECDSA_SIG(s, &der);\n+\tif (derlen != sig_len || memcmp(sigbuf, der, derlen))\n+\t\tgoto err;\n \tret=ECDSA_do_verify(dgst, dgst_len, s, eckey);\n err:\n+\tif (derlen > 0)\n+\t\t{\n+\t\tOPENSSL_cleanse(der, derlen);\n+\t\tOPENSSL_free(der);\n+\t\t}\n \tECDSA_SIG_free(s);\n \treturn(ret);\n \t}""}<_**next**_>{""sha"": ""d7229506f644e8b52b2203da88909622d1d2417a"", ""filename"": ""crypto/x509/x_all.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/openssl/openssl/blob/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/x509/x_all.c"", ""raw_url"": ""https://github.com/openssl/openssl/raw/684400ce192dac51df3d3e92b61830a6ef90be3e/crypto/x509/x_all.c"", ""contents_url"": ""https://api.github.com/repos/openssl/openssl/contents/crypto/x509/x_all.c?ref=684400ce192dac51df3d3e92b61830a6ef90be3e"", ""patch"": ""@@ -73,6 +73,8 @@\n \n int X509_verify(X509 *a, EVP_PKEY *r)\n \t{\n+\tif (X509_ALGOR_cmp(a->sig_alg, a->cert_info->signature))\n+\t\treturn 0;\n \treturn(ASN1_item_verify(ASN1_ITEM_rptr(X509_CINF),a->sig_alg,\n \t\ta->signature,a->cert_info,r));\n \t}""}"," int X509_verify(X509 *a, EVP_PKEY *r)
 	{
	if (X509_ALGOR_cmp(a->sig_alg, a->cert_info->signature))
		return 0;
 	return(ASN1_item_verify(ASN1_ITEM_rptr(X509_CINF),a->sig_alg,
 		a->signature,a->cert_info,r));
 	}
"," int X509_verify(X509 *a, EVP_PKEY *r)
 	{
 	return(ASN1_item_verify(ASN1_ITEM_rptr(X509_CINF),a->sig_alg,
 		a->signature,a->cert_info,r));
 	}
",C,"	if (X509_ALGOR_cmp(a->sig_alg, a->cert_info->signature))
		return 0;
",,,"@@ -73,6 +73,8 @@
 
 int X509_verify(X509 *a, EVP_PKEY *r)
 	{
+	if (X509_ALGOR_cmp(a->sig_alg, a->cert_info->signature))
+		return 0;
 	return(ASN1_item_verify(ASN1_ITEM_rptr(X509_CINF),a->sig_alg,
 		a->signature,a->cert_info,r));
 	}",openssl,684400ce192dac51df3d3e92b61830a6ef90be3e,32b07f5a80d22b34cfcd6df76d425bed771b0146,1," int X509_verify(X509 *a, EVP_PKEY *r)
 	{
//fix_flaw_line_below:
//	if (X509_ALGOR_cmp(a->sig_alg, a->cert_info->signature))
//fix_flaw_line_below:
//		return 0;
 	return(ASN1_item_verify(ASN1_ITEM_rptr(X509_CINF),a->sig_alg,
 		a->signature,a->cert_info,r));
 	}
"
5647,183383,,Remote,Not required,,CVE-2019-12904,https://www.cvedetails.com/cve/CVE-2019-12904/,CWE-310,Medium,Partial,,,2019-06-19,4.3,"In Libgcrypt 1.8.4, the C implementation of AES is vulnerable to a flush-and-reload side-channel attack because physical addresses are available to other processes. (The C implementation is used on platforms where an assembly-language implementation is unavailable.)",2019-07-23,,2,https://github.com/gpg/libgcrypt/commit/daedbbb5541cd8ecda1459d3b843ea4d92788762,daedbbb5541cd8ecda1459d3b843ea4d92788762,"AES: move look-up tables to .data section and unshare between processes

* cipher/rijndael-internal.h (ATTR_ALIGNED_64): New.
* cipher/rijndael-tables.h (encT): Move to 'enc_tables' structure.
(enc_tables): New structure for encryption table with counters before
and after.
(encT): New macro.
(dec_tables): Add counters before and after encryption table; Move
from .rodata to .data section.
(do_encrypt): Change 'encT' to 'enc_tables.T'.
(do_decrypt): Change '&dec_tables' to 'dec_tables.T'.
* cipher/cipher-gcm.c (prefetch_table): Make inline; Handle input
with length not multiple of 256.
(prefetch_enc, prefetch_dec): Modify pre- and post-table counters
to unshare look-up table pages between processes.
--

GnuPG-bug-id: 4541
Signed-off-by: Jussi Kivilinna <jussi.kivilinna@iki.fi>",2,cipher/rijndael.c,"{""sha"": ""78b08e8f8c40fae9db0d047d87ab3bd509295565"", ""filename"": ""cipher/rijndael-internal.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/gpg/libgcrypt/blob/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael-internal.h"", ""raw_url"": ""https://github.com/gpg/libgcrypt/raw/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael-internal.h"", ""contents_url"": ""https://api.github.com/repos/gpg/libgcrypt/contents/cipher/rijndael-internal.h?ref=daedbbb5541cd8ecda1459d3b843ea4d92788762"", ""patch"": ""@@ -29,11 +29,13 @@\n #define BLOCKSIZE               (128/8)\n \n \n-/* Helper macro to force alignment to 16 bytes.  */\n+/* Helper macro to force alignment to 16 or 64 bytes.  */\n #ifdef HAVE_GCC_ATTRIBUTE_ALIGNED\n # define ATTR_ALIGNED_16  __attribute__ ((aligned (16)))\n+# define ATTR_ALIGNED_64  __attribute__ ((aligned (64)))\n #else\n # define ATTR_ALIGNED_16\n+# define ATTR_ALIGNED_64\n #endif\n \n ""}<_**next**_>{""sha"": ""b54d95939353ee760ee2d69d0c268998162f8ba3"", ""filename"": ""cipher/rijndael-tables.h"", ""status"": ""modified"", ""additions"": 87, ""deletions"": 68, ""changes"": 155, ""blob_url"": ""https://github.com/gpg/libgcrypt/blob/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael-tables.h"", ""raw_url"": ""https://github.com/gpg/libgcrypt/raw/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael-tables.h"", ""contents_url"": ""https://api.github.com/repos/gpg/libgcrypt/contents/cipher/rijndael-tables.h?ref=daedbbb5541cd8ecda1459d3b843ea4d92788762"", ""patch"": ""@@ -21,80 +21,98 @@\n /* To keep the actual implementation at a readable size we use this\n    include file to define the tables.  */\n \n-static const u32 encT[256] =\n+static struct\n+{\n+  volatile u32 counter_head;\n+  u32 cacheline_align[64 / 4 - 1];\n+  u32 T[256];\n+  volatile u32 counter_tail;\n+} enc_tables ATTR_ALIGNED_64 =\n   {\n-    0xa56363c6, 0x847c7cf8, 0x997777ee, 0x8d7b7bf6,\n-    0x0df2f2ff, 0xbd6b6bd6, 0xb16f6fde, 0x54c5c591,\n-    0x50303060, 0x03010102, 0xa96767ce, 0x7d2b2b56,\n-    0x19fefee7, 0x62d7d7b5, 0xe6abab4d, 0x9a7676ec,\n-    0x45caca8f, 0x9d82821f, 0x40c9c989, 0x877d7dfa,\n-    0x15fafaef, 0xeb5959b2, 0xc947478e, 0x0bf0f0fb,\n-    0xecadad41, 0x67d4d4b3, 0xfda2a25f, 0xeaafaf45,\n-    0xbf9c9c23, 0xf7a4a453, 0x967272e4, 0x5bc0c09b,\n-    0xc2b7b775, 0x1cfdfde1, 0xae93933d, 0x6a26264c,\n-    0x5a36366c, 0x413f3f7e, 0x02f7f7f5, 0x4fcccc83,\n-    0x5c343468, 0xf4a5a551, 0x34e5e5d1, 0x08f1f1f9,\n-    0x937171e2, 0x73d8d8ab, 0x53313162, 0x3f15152a,\n-    0x0c040408, 0x52c7c795, 0x65232346, 0x5ec3c39d,\n-    0x28181830, 0xa1969637, 0x0f05050a, 0xb59a9a2f,\n-    0x0907070e, 0x36121224, 0x9b80801b, 0x3de2e2df,\n-    0x26ebebcd, 0x6927274e, 0xcdb2b27f, 0x9f7575ea,\n-    0x1b090912, 0x9e83831d, 0x742c2c58, 0x2e1a1a34,\n-    0x2d1b1b36, 0xb26e6edc, 0xee5a5ab4, 0xfba0a05b,\n-    0xf65252a4, 0x4d3b3b76, 0x61d6d6b7, 0xceb3b37d,\n-    0x7b292952, 0x3ee3e3dd, 0x712f2f5e, 0x97848413,\n-    0xf55353a6, 0x68d1d1b9, 0x00000000, 0x2cededc1,\n-    0x60202040, 0x1ffcfce3, 0xc8b1b179, 0xed5b5bb6,\n-    0xbe6a6ad4, 0x46cbcb8d, 0xd9bebe67, 0x4b393972,\n-    0xde4a4a94, 0xd44c4c98, 0xe85858b0, 0x4acfcf85,\n-    0x6bd0d0bb, 0x2aefefc5, 0xe5aaaa4f, 0x16fbfbed,\n-    0xc5434386, 0xd74d4d9a, 0x55333366, 0x94858511,\n-    0xcf45458a, 0x10f9f9e9, 0x06020204, 0x817f7ffe,\n-    0xf05050a0, 0x443c3c78, 0xba9f9f25, 0xe3a8a84b,\n-    0xf35151a2, 0xfea3a35d, 0xc0404080, 0x8a8f8f05,\n-    0xad92923f, 0xbc9d9d21, 0x48383870, 0x04f5f5f1,\n-    0xdfbcbc63, 0xc1b6b677, 0x75dadaaf, 0x63212142,\n-    0x30101020, 0x1affffe5, 0x0ef3f3fd, 0x6dd2d2bf,\n-    0x4ccdcd81, 0x140c0c18, 0x35131326, 0x2fececc3,\n-    0xe15f5fbe, 0xa2979735, 0xcc444488, 0x3917172e,\n-    0x57c4c493, 0xf2a7a755, 0x827e7efc, 0x473d3d7a,\n-    0xac6464c8, 0xe75d5dba, 0x2b191932, 0x957373e6,\n-    0xa06060c0, 0x98818119, 0xd14f4f9e, 0x7fdcdca3,\n-    0x66222244, 0x7e2a2a54, 0xab90903b, 0x8388880b,\n-    0xca46468c, 0x29eeeec7, 0xd3b8b86b, 0x3c141428,\n-    0x79dedea7, 0xe25e5ebc, 0x1d0b0b16, 0x76dbdbad,\n-    0x3be0e0db, 0x56323264, 0x4e3a3a74, 0x1e0a0a14,\n-    0xdb494992, 0x0a06060c, 0x6c242448, 0xe45c5cb8,\n-    0x5dc2c29f, 0x6ed3d3bd, 0xefacac43, 0xa66262c4,\n-    0xa8919139, 0xa4959531, 0x37e4e4d3, 0x8b7979f2,\n-    0x32e7e7d5, 0x43c8c88b, 0x5937376e, 0xb76d6dda,\n-    0x8c8d8d01, 0x64d5d5b1, 0xd24e4e9c, 0xe0a9a949,\n-    0xb46c6cd8, 0xfa5656ac, 0x07f4f4f3, 0x25eaeacf,\n-    0xaf6565ca, 0x8e7a7af4, 0xe9aeae47, 0x18080810,\n-    0xd5baba6f, 0x887878f0, 0x6f25254a, 0x722e2e5c,\n-    0x241c1c38, 0xf1a6a657, 0xc7b4b473, 0x51c6c697,\n-    0x23e8e8cb, 0x7cdddda1, 0x9c7474e8, 0x211f1f3e,\n-    0xdd4b4b96, 0xdcbdbd61, 0x868b8b0d, 0x858a8a0f,\n-    0x907070e0, 0x423e3e7c, 0xc4b5b571, 0xaa6666cc,\n-    0xd8484890, 0x05030306, 0x01f6f6f7, 0x120e0e1c,\n-    0xa36161c2, 0x5f35356a, 0xf95757ae, 0xd0b9b969,\n-    0x91868617, 0x58c1c199, 0x271d1d3a, 0xb99e9e27,\n-    0x38e1e1d9, 0x13f8f8eb, 0xb398982b, 0x33111122,\n-    0xbb6969d2, 0x70d9d9a9, 0x898e8e07, 0xa7949433,\n-    0xb69b9b2d, 0x221e1e3c, 0x92878715, 0x20e9e9c9,\n-    0x49cece87, 0xff5555aa, 0x78282850, 0x7adfdfa5,\n-    0x8f8c8c03, 0xf8a1a159, 0x80898909, 0x170d0d1a,\n-    0xdabfbf65, 0x31e6e6d7, 0xc6424284, 0xb86868d0,\n-    0xc3414182, 0xb0999929, 0x772d2d5a, 0x110f0f1e,\n-    0xcbb0b07b, 0xfc5454a8, 0xd6bbbb6d, 0x3a16162c\n+    0,\n+    { 0, },\n+    {\n+      0xa56363c6, 0x847c7cf8, 0x997777ee, 0x8d7b7bf6,\n+      0x0df2f2ff, 0xbd6b6bd6, 0xb16f6fde, 0x54c5c591,\n+      0x50303060, 0x03010102, 0xa96767ce, 0x7d2b2b56,\n+      0x19fefee7, 0x62d7d7b5, 0xe6abab4d, 0x9a7676ec,\n+      0x45caca8f, 0x9d82821f, 0x40c9c989, 0x877d7dfa,\n+      0x15fafaef, 0xeb5959b2, 0xc947478e, 0x0bf0f0fb,\n+      0xecadad41, 0x67d4d4b3, 0xfda2a25f, 0xeaafaf45,\n+      0xbf9c9c23, 0xf7a4a453, 0x967272e4, 0x5bc0c09b,\n+      0xc2b7b775, 0x1cfdfde1, 0xae93933d, 0x6a26264c,\n+      0x5a36366c, 0x413f3f7e, 0x02f7f7f5, 0x4fcccc83,\n+      0x5c343468, 0xf4a5a551, 0x34e5e5d1, 0x08f1f1f9,\n+      0x937171e2, 0x73d8d8ab, 0x53313162, 0x3f15152a,\n+      0x0c040408, 0x52c7c795, 0x65232346, 0x5ec3c39d,\n+      0x28181830, 0xa1969637, 0x0f05050a, 0xb59a9a2f,\n+      0x0907070e, 0x36121224, 0x9b80801b, 0x3de2e2df,\n+      0x26ebebcd, 0x6927274e, 0xcdb2b27f, 0x9f7575ea,\n+      0x1b090912, 0x9e83831d, 0x742c2c58, 0x2e1a1a34,\n+      0x2d1b1b36, 0xb26e6edc, 0xee5a5ab4, 0xfba0a05b,\n+      0xf65252a4, 0x4d3b3b76, 0x61d6d6b7, 0xceb3b37d,\n+      0x7b292952, 0x3ee3e3dd, 0x712f2f5e, 0x97848413,\n+      0xf55353a6, 0x68d1d1b9, 0x00000000, 0x2cededc1,\n+      0x60202040, 0x1ffcfce3, 0xc8b1b179, 0xed5b5bb6,\n+      0xbe6a6ad4, 0x46cbcb8d, 0xd9bebe67, 0x4b393972,\n+      0xde4a4a94, 0xd44c4c98, 0xe85858b0, 0x4acfcf85,\n+      0x6bd0d0bb, 0x2aefefc5, 0xe5aaaa4f, 0x16fbfbed,\n+      0xc5434386, 0xd74d4d9a, 0x55333366, 0x94858511,\n+      0xcf45458a, 0x10f9f9e9, 0x06020204, 0x817f7ffe,\n+      0xf05050a0, 0x443c3c78, 0xba9f9f25, 0xe3a8a84b,\n+      0xf35151a2, 0xfea3a35d, 0xc0404080, 0x8a8f8f05,\n+      0xad92923f, 0xbc9d9d21, 0x48383870, 0x04f5f5f1,\n+      0xdfbcbc63, 0xc1b6b677, 0x75dadaaf, 0x63212142,\n+      0x30101020, 0x1affffe5, 0x0ef3f3fd, 0x6dd2d2bf,\n+      0x4ccdcd81, 0x140c0c18, 0x35131326, 0x2fececc3,\n+      0xe15f5fbe, 0xa2979735, 0xcc444488, 0x3917172e,\n+      0x57c4c493, 0xf2a7a755, 0x827e7efc, 0x473d3d7a,\n+      0xac6464c8, 0xe75d5dba, 0x2b191932, 0x957373e6,\n+      0xa06060c0, 0x98818119, 0xd14f4f9e, 0x7fdcdca3,\n+      0x66222244, 0x7e2a2a54, 0xab90903b, 0x8388880b,\n+      0xca46468c, 0x29eeeec7, 0xd3b8b86b, 0x3c141428,\n+      0x79dedea7, 0xe25e5ebc, 0x1d0b0b16, 0x76dbdbad,\n+      0x3be0e0db, 0x56323264, 0x4e3a3a74, 0x1e0a0a14,\n+      0xdb494992, 0x0a06060c, 0x6c242448, 0xe45c5cb8,\n+      0x5dc2c29f, 0x6ed3d3bd, 0xefacac43, 0xa66262c4,\n+      0xa8919139, 0xa4959531, 0x37e4e4d3, 0x8b7979f2,\n+      0x32e7e7d5, 0x43c8c88b, 0x5937376e, 0xb76d6dda,\n+      0x8c8d8d01, 0x64d5d5b1, 0xd24e4e9c, 0xe0a9a949,\n+      0xb46c6cd8, 0xfa5656ac, 0x07f4f4f3, 0x25eaeacf,\n+      0xaf6565ca, 0x8e7a7af4, 0xe9aeae47, 0x18080810,\n+      0xd5baba6f, 0x887878f0, 0x6f25254a, 0x722e2e5c,\n+      0x241c1c38, 0xf1a6a657, 0xc7b4b473, 0x51c6c697,\n+      0x23e8e8cb, 0x7cdddda1, 0x9c7474e8, 0x211f1f3e,\n+      0xdd4b4b96, 0xdcbdbd61, 0x868b8b0d, 0x858a8a0f,\n+      0x907070e0, 0x423e3e7c, 0xc4b5b571, 0xaa6666cc,\n+      0xd8484890, 0x05030306, 0x01f6f6f7, 0x120e0e1c,\n+      0xa36161c2, 0x5f35356a, 0xf95757ae, 0xd0b9b969,\n+      0x91868617, 0x58c1c199, 0x271d1d3a, 0xb99e9e27,\n+      0x38e1e1d9, 0x13f8f8eb, 0xb398982b, 0x33111122,\n+      0xbb6969d2, 0x70d9d9a9, 0x898e8e07, 0xa7949433,\n+      0xb69b9b2d, 0x221e1e3c, 0x92878715, 0x20e9e9c9,\n+      0x49cece87, 0xff5555aa, 0x78282850, 0x7adfdfa5,\n+      0x8f8c8c03, 0xf8a1a159, 0x80898909, 0x170d0d1a,\n+      0xdabfbf65, 0x31e6e6d7, 0xc6424284, 0xb86868d0,\n+      0xc3414182, 0xb0999929, 0x772d2d5a, 0x110f0f1e,\n+      0xcbb0b07b, 0xfc5454a8, 0xd6bbbb6d, 0x3a16162c\n+    },\n+    0\n   };\n \n-static const struct\n+#define encT enc_tables.T\n+\n+static struct\n {\n+  volatile u32 counter_head;\n+  u32 cacheline_align[64 / 4 - 1];\n   u32 T[256];\n   byte inv_sbox[256];\n-} dec_tables =\n+  volatile u32 counter_tail;\n+} dec_tables ATTR_ALIGNED_64 =\n   {\n+    0,\n+    { 0, },\n     {\n       0x50a7f451, 0x5365417e, 0xc3a4171a, 0x965e273a,\n       0xcb6bab3b, 0xf1459d1f, 0xab58faac, 0x9303e34b,\n@@ -194,7 +212,8 @@ static const struct\n       0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,\n       0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,\n       0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d\n-    }\n+    },\n+    0\n   };\n \n #define decT dec_tables.T""}<_**next**_>{""sha"": ""2c9aa6733a5a8abcd6143d1a5071d8bc3f763325"", ""filename"": ""cipher/rijndael.c"", ""status"": ""modified"", ""additions"": 28, ""deletions"": 7, ""changes"": 35, ""blob_url"": ""https://github.com/gpg/libgcrypt/blob/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael.c"", ""raw_url"": ""https://github.com/gpg/libgcrypt/raw/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael.c"", ""contents_url"": ""https://api.github.com/repos/gpg/libgcrypt/contents/cipher/rijndael.c?ref=daedbbb5541cd8ecda1459d3b843ea4d92788762"", ""patch"": ""@@ -218,11 +218,11 @@ static const char *selftest(void);\n \n \f\n /* Prefetching for encryption/decryption tables. */\n-static void prefetch_table(const volatile byte *tab, size_t len)\n+static inline void prefetch_table(const volatile byte *tab, size_t len)\n {\n   size_t i;\n \n-  for (i = 0; i < len; i += 8 * 32)\n+  for (i = 0; len - i >= 8 * 32; i += 8 * 32)\n     {\n       (void)tab[i + 0 * 32];\n       (void)tab[i + 1 * 32];\n@@ -233,17 +233,37 @@ static void prefetch_table(const volatile byte *tab, size_t len)\n       (void)tab[i + 6 * 32];\n       (void)tab[i + 7 * 32];\n     }\n+  for (; i < len; i += 32)\n+    {\n+      (void)tab[i];\n+    }\n \n   (void)tab[len - 1];\n }\n \n static void prefetch_enc(void)\n {\n-  prefetch_table((const void *)encT, sizeof(encT));\n+  /* Modify counters to trigger copy-on-write and unsharing if physical pages\n+   * of look-up table are shared between processes.  Modifying counters also\n+   * causes checksums for pages to change and hint same-page merging algorithm\n+   * that these pages are frequently changing.  */\n+  enc_tables.counter_head++;\n+  enc_tables.counter_tail++;\n+\n+  /* Prefetch look-up tables to cache.  */\n+  prefetch_table((const void *)&enc_tables, sizeof(enc_tables));\n }\n \n static void prefetch_dec(void)\n {\n+  /* Modify counters to trigger copy-on-write and unsharing if physical pages\n+   * of look-up table are shared between processes.  Modifying counters also\n+   * causes checksums for pages to change and hint same-page merging algorithm\n+   * that these pages are frequently changing.  */\n+  dec_tables.counter_head++;\n+  dec_tables.counter_tail++;\n+\n+  /* Prefetch look-up tables to cache.  */\n   prefetch_table((const void *)&dec_tables, sizeof(dec_tables));\n }\n \n@@ -765,9 +785,10 @@ do_encrypt (const RIJNDAEL_context *ctx,\n {\n #ifdef USE_AMD64_ASM\n   return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,\n-\t\t\t\t       encT);\n+\t\t\t\t       enc_tables.T);\n #elif defined(USE_ARM_ASM)\n-  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);\n+  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,\n+\t\t\t\t     enc_tables.T);\n #else\n   return do_encrypt_fn (ctx, bx, ax);\n #endif /* !USE_ARM_ASM && !USE_AMD64_ASM*/\n@@ -1123,10 +1144,10 @@ do_decrypt (const RIJNDAEL_context *ctx, unsigned char *bx,\n {\n #ifdef USE_AMD64_ASM\n   return _gcry_aes_amd64_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n-\t\t\t\t       &dec_tables);\n+\t\t\t\t       dec_tables.T);\n #elif defined(USE_ARM_ASM)\n   return _gcry_aes_arm_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n-\t\t\t\t     &dec_tables);\n+\t\t\t\t     dec_tables.T);\n #else\n   return do_decrypt_fn (ctx, bx, ax);\n #endif /*!USE_ARM_ASM && !USE_AMD64_ASM*/""}","do_decrypt (const RIJNDAEL_context *ctx, unsigned char *bx,
            const unsigned char *ax)
 {
 #ifdef USE_AMD64_ASM
   return _gcry_aes_amd64_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,
				       dec_tables.T);
 #elif defined(USE_ARM_ASM)
   return _gcry_aes_arm_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,
				     dec_tables.T);
 #else
   return do_decrypt_fn (ctx, bx, ax);
 #endif /*!USE_ARM_ASM && !USE_AMD64_ASM*/
}
","do_decrypt (const RIJNDAEL_context *ctx, unsigned char *bx,
            const unsigned char *ax)
 {
 #ifdef USE_AMD64_ASM
   return _gcry_aes_amd64_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,
				       &dec_tables);
 #elif defined(USE_ARM_ASM)
   return _gcry_aes_arm_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,
				     &dec_tables);
 #else
   return do_decrypt_fn (ctx, bx, ax);
 #endif /*!USE_ARM_ASM && !USE_AMD64_ASM*/
}
",C,"				       dec_tables.T);
				     dec_tables.T);
","				       &dec_tables);
				     &dec_tables);
",,"@@ -218,11 +218,11 @@ static const char *selftest(void);
 
 
 /* Prefetching for encryption/decryption tables. */
-static void prefetch_table(const volatile byte *tab, size_t len)
+static inline void prefetch_table(const volatile byte *tab, size_t len)
 {
   size_t i;
 
-  for (i = 0; i < len; i += 8 * 32)
+  for (i = 0; len - i >= 8 * 32; i += 8 * 32)
     {
       (void)tab[i + 0 * 32];
       (void)tab[i + 1 * 32];
@@ -233,17 +233,37 @@ static void prefetch_table(const volatile byte *tab, size_t len)
       (void)tab[i + 6 * 32];
       (void)tab[i + 7 * 32];
     }
+  for (; i < len; i += 32)
+    {
+      (void)tab[i];
+    }
 
   (void)tab[len - 1];
 }
 
 static void prefetch_enc(void)
 {
-  prefetch_table((const void *)encT, sizeof(encT));
+  /* Modify counters to trigger copy-on-write and unsharing if physical pages
+   * of look-up table are shared between processes.  Modifying counters also
+   * causes checksums for pages to change and hint same-page merging algorithm
+   * that these pages are frequently changing.  */
+  enc_tables.counter_head++;
+  enc_tables.counter_tail++;
+
+  /* Prefetch look-up tables to cache.  */
+  prefetch_table((const void *)&enc_tables, sizeof(enc_tables));
 }
 
 static void prefetch_dec(void)
 {
+  /* Modify counters to trigger copy-on-write and unsharing if physical pages
+   * of look-up table are shared between processes.  Modifying counters also
+   * causes checksums for pages to change and hint same-page merging algorithm
+   * that these pages are frequently changing.  */
+  dec_tables.counter_head++;
+  dec_tables.counter_tail++;
+
+  /* Prefetch look-up tables to cache.  */
   prefetch_table((const void *)&dec_tables, sizeof(dec_tables));
 }
 
@@ -765,9 +785,10 @@ do_encrypt (const RIJNDAEL_context *ctx,
 {
 #ifdef USE_AMD64_ASM
   return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,
-				       encT);
+				       enc_tables.T);
 #elif defined(USE_ARM_ASM)
-  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);
+  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,
+				     enc_tables.T);
 #else
   return do_encrypt_fn (ctx, bx, ax);
 #endif /* !USE_ARM_ASM && !USE_AMD64_ASM*/
@@ -1123,10 +1144,10 @@ do_decrypt (const RIJNDAEL_context *ctx, unsigned char *bx,
 {
 #ifdef USE_AMD64_ASM
   return _gcry_aes_amd64_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,
-				       &dec_tables);
+				       dec_tables.T);
 #elif defined(USE_ARM_ASM)
   return _gcry_aes_arm_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,
-				     &dec_tables);
+				     dec_tables.T);
 #else
   return do_decrypt_fn (ctx, bx, ax);
 #endif /*!USE_ARM_ASM && !USE_AMD64_ASM*/",libgcrypt,daedbbb5541cd8ecda1459d3b843ea4d92788762,c6ffa216976d80a13486b13f64d6776cdb8b6ccf,1,"do_decrypt (const RIJNDAEL_context *ctx, unsigned char *bx,
            const unsigned char *ax)
 {
 #ifdef USE_AMD64_ASM
   return _gcry_aes_amd64_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,
//flaw_line_below:
				       &dec_tables);
//fix_flaw_line_below:
//				       dec_tables.T);
 #elif defined(USE_ARM_ASM)
   return _gcry_aes_arm_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,
//flaw_line_below:
				     &dec_tables);
//fix_flaw_line_below:
//				     dec_tables.T);
 #else
   return do_decrypt_fn (ctx, bx, ax);
 #endif /*!USE_ARM_ASM && !USE_AMD64_ASM*/
}
"
5648,183384,,Remote,Not required,,CVE-2019-12904,https://www.cvedetails.com/cve/CVE-2019-12904/,CWE-310,Medium,Partial,,,2019-06-19,4.3,"In Libgcrypt 1.8.4, the C implementation of AES is vulnerable to a flush-and-reload side-channel attack because physical addresses are available to other processes. (The C implementation is used on platforms where an assembly-language implementation is unavailable.)",2019-07-23,,3,https://github.com/gpg/libgcrypt/commit/daedbbb5541cd8ecda1459d3b843ea4d92788762,daedbbb5541cd8ecda1459d3b843ea4d92788762,"AES: move look-up tables to .data section and unshare between processes

* cipher/rijndael-internal.h (ATTR_ALIGNED_64): New.
* cipher/rijndael-tables.h (encT): Move to 'enc_tables' structure.
(enc_tables): New structure for encryption table with counters before
and after.
(encT): New macro.
(dec_tables): Add counters before and after encryption table; Move
from .rodata to .data section.
(do_encrypt): Change 'encT' to 'enc_tables.T'.
(do_decrypt): Change '&dec_tables' to 'dec_tables.T'.
* cipher/cipher-gcm.c (prefetch_table): Make inline; Handle input
with length not multiple of 256.
(prefetch_enc, prefetch_dec): Modify pre- and post-table counters
to unshare look-up table pages between processes.
--

GnuPG-bug-id: 4541
Signed-off-by: Jussi Kivilinna <jussi.kivilinna@iki.fi>",2,cipher/rijndael.c,"{""sha"": ""78b08e8f8c40fae9db0d047d87ab3bd509295565"", ""filename"": ""cipher/rijndael-internal.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/gpg/libgcrypt/blob/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael-internal.h"", ""raw_url"": ""https://github.com/gpg/libgcrypt/raw/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael-internal.h"", ""contents_url"": ""https://api.github.com/repos/gpg/libgcrypt/contents/cipher/rijndael-internal.h?ref=daedbbb5541cd8ecda1459d3b843ea4d92788762"", ""patch"": ""@@ -29,11 +29,13 @@\n #define BLOCKSIZE               (128/8)\n \n \n-/* Helper macro to force alignment to 16 bytes.  */\n+/* Helper macro to force alignment to 16 or 64 bytes.  */\n #ifdef HAVE_GCC_ATTRIBUTE_ALIGNED\n # define ATTR_ALIGNED_16  __attribute__ ((aligned (16)))\n+# define ATTR_ALIGNED_64  __attribute__ ((aligned (64)))\n #else\n # define ATTR_ALIGNED_16\n+# define ATTR_ALIGNED_64\n #endif\n \n ""}<_**next**_>{""sha"": ""b54d95939353ee760ee2d69d0c268998162f8ba3"", ""filename"": ""cipher/rijndael-tables.h"", ""status"": ""modified"", ""additions"": 87, ""deletions"": 68, ""changes"": 155, ""blob_url"": ""https://github.com/gpg/libgcrypt/blob/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael-tables.h"", ""raw_url"": ""https://github.com/gpg/libgcrypt/raw/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael-tables.h"", ""contents_url"": ""https://api.github.com/repos/gpg/libgcrypt/contents/cipher/rijndael-tables.h?ref=daedbbb5541cd8ecda1459d3b843ea4d92788762"", ""patch"": ""@@ -21,80 +21,98 @@\n /* To keep the actual implementation at a readable size we use this\n    include file to define the tables.  */\n \n-static const u32 encT[256] =\n+static struct\n+{\n+  volatile u32 counter_head;\n+  u32 cacheline_align[64 / 4 - 1];\n+  u32 T[256];\n+  volatile u32 counter_tail;\n+} enc_tables ATTR_ALIGNED_64 =\n   {\n-    0xa56363c6, 0x847c7cf8, 0x997777ee, 0x8d7b7bf6,\n-    0x0df2f2ff, 0xbd6b6bd6, 0xb16f6fde, 0x54c5c591,\n-    0x50303060, 0x03010102, 0xa96767ce, 0x7d2b2b56,\n-    0x19fefee7, 0x62d7d7b5, 0xe6abab4d, 0x9a7676ec,\n-    0x45caca8f, 0x9d82821f, 0x40c9c989, 0x877d7dfa,\n-    0x15fafaef, 0xeb5959b2, 0xc947478e, 0x0bf0f0fb,\n-    0xecadad41, 0x67d4d4b3, 0xfda2a25f, 0xeaafaf45,\n-    0xbf9c9c23, 0xf7a4a453, 0x967272e4, 0x5bc0c09b,\n-    0xc2b7b775, 0x1cfdfde1, 0xae93933d, 0x6a26264c,\n-    0x5a36366c, 0x413f3f7e, 0x02f7f7f5, 0x4fcccc83,\n-    0x5c343468, 0xf4a5a551, 0x34e5e5d1, 0x08f1f1f9,\n-    0x937171e2, 0x73d8d8ab, 0x53313162, 0x3f15152a,\n-    0x0c040408, 0x52c7c795, 0x65232346, 0x5ec3c39d,\n-    0x28181830, 0xa1969637, 0x0f05050a, 0xb59a9a2f,\n-    0x0907070e, 0x36121224, 0x9b80801b, 0x3de2e2df,\n-    0x26ebebcd, 0x6927274e, 0xcdb2b27f, 0x9f7575ea,\n-    0x1b090912, 0x9e83831d, 0x742c2c58, 0x2e1a1a34,\n-    0x2d1b1b36, 0xb26e6edc, 0xee5a5ab4, 0xfba0a05b,\n-    0xf65252a4, 0x4d3b3b76, 0x61d6d6b7, 0xceb3b37d,\n-    0x7b292952, 0x3ee3e3dd, 0x712f2f5e, 0x97848413,\n-    0xf55353a6, 0x68d1d1b9, 0x00000000, 0x2cededc1,\n-    0x60202040, 0x1ffcfce3, 0xc8b1b179, 0xed5b5bb6,\n-    0xbe6a6ad4, 0x46cbcb8d, 0xd9bebe67, 0x4b393972,\n-    0xde4a4a94, 0xd44c4c98, 0xe85858b0, 0x4acfcf85,\n-    0x6bd0d0bb, 0x2aefefc5, 0xe5aaaa4f, 0x16fbfbed,\n-    0xc5434386, 0xd74d4d9a, 0x55333366, 0x94858511,\n-    0xcf45458a, 0x10f9f9e9, 0x06020204, 0x817f7ffe,\n-    0xf05050a0, 0x443c3c78, 0xba9f9f25, 0xe3a8a84b,\n-    0xf35151a2, 0xfea3a35d, 0xc0404080, 0x8a8f8f05,\n-    0xad92923f, 0xbc9d9d21, 0x48383870, 0x04f5f5f1,\n-    0xdfbcbc63, 0xc1b6b677, 0x75dadaaf, 0x63212142,\n-    0x30101020, 0x1affffe5, 0x0ef3f3fd, 0x6dd2d2bf,\n-    0x4ccdcd81, 0x140c0c18, 0x35131326, 0x2fececc3,\n-    0xe15f5fbe, 0xa2979735, 0xcc444488, 0x3917172e,\n-    0x57c4c493, 0xf2a7a755, 0x827e7efc, 0x473d3d7a,\n-    0xac6464c8, 0xe75d5dba, 0x2b191932, 0x957373e6,\n-    0xa06060c0, 0x98818119, 0xd14f4f9e, 0x7fdcdca3,\n-    0x66222244, 0x7e2a2a54, 0xab90903b, 0x8388880b,\n-    0xca46468c, 0x29eeeec7, 0xd3b8b86b, 0x3c141428,\n-    0x79dedea7, 0xe25e5ebc, 0x1d0b0b16, 0x76dbdbad,\n-    0x3be0e0db, 0x56323264, 0x4e3a3a74, 0x1e0a0a14,\n-    0xdb494992, 0x0a06060c, 0x6c242448, 0xe45c5cb8,\n-    0x5dc2c29f, 0x6ed3d3bd, 0xefacac43, 0xa66262c4,\n-    0xa8919139, 0xa4959531, 0x37e4e4d3, 0x8b7979f2,\n-    0x32e7e7d5, 0x43c8c88b, 0x5937376e, 0xb76d6dda,\n-    0x8c8d8d01, 0x64d5d5b1, 0xd24e4e9c, 0xe0a9a949,\n-    0xb46c6cd8, 0xfa5656ac, 0x07f4f4f3, 0x25eaeacf,\n-    0xaf6565ca, 0x8e7a7af4, 0xe9aeae47, 0x18080810,\n-    0xd5baba6f, 0x887878f0, 0x6f25254a, 0x722e2e5c,\n-    0x241c1c38, 0xf1a6a657, 0xc7b4b473, 0x51c6c697,\n-    0x23e8e8cb, 0x7cdddda1, 0x9c7474e8, 0x211f1f3e,\n-    0xdd4b4b96, 0xdcbdbd61, 0x868b8b0d, 0x858a8a0f,\n-    0x907070e0, 0x423e3e7c, 0xc4b5b571, 0xaa6666cc,\n-    0xd8484890, 0x05030306, 0x01f6f6f7, 0x120e0e1c,\n-    0xa36161c2, 0x5f35356a, 0xf95757ae, 0xd0b9b969,\n-    0x91868617, 0x58c1c199, 0x271d1d3a, 0xb99e9e27,\n-    0x38e1e1d9, 0x13f8f8eb, 0xb398982b, 0x33111122,\n-    0xbb6969d2, 0x70d9d9a9, 0x898e8e07, 0xa7949433,\n-    0xb69b9b2d, 0x221e1e3c, 0x92878715, 0x20e9e9c9,\n-    0x49cece87, 0xff5555aa, 0x78282850, 0x7adfdfa5,\n-    0x8f8c8c03, 0xf8a1a159, 0x80898909, 0x170d0d1a,\n-    0xdabfbf65, 0x31e6e6d7, 0xc6424284, 0xb86868d0,\n-    0xc3414182, 0xb0999929, 0x772d2d5a, 0x110f0f1e,\n-    0xcbb0b07b, 0xfc5454a8, 0xd6bbbb6d, 0x3a16162c\n+    0,\n+    { 0, },\n+    {\n+      0xa56363c6, 0x847c7cf8, 0x997777ee, 0x8d7b7bf6,\n+      0x0df2f2ff, 0xbd6b6bd6, 0xb16f6fde, 0x54c5c591,\n+      0x50303060, 0x03010102, 0xa96767ce, 0x7d2b2b56,\n+      0x19fefee7, 0x62d7d7b5, 0xe6abab4d, 0x9a7676ec,\n+      0x45caca8f, 0x9d82821f, 0x40c9c989, 0x877d7dfa,\n+      0x15fafaef, 0xeb5959b2, 0xc947478e, 0x0bf0f0fb,\n+      0xecadad41, 0x67d4d4b3, 0xfda2a25f, 0xeaafaf45,\n+      0xbf9c9c23, 0xf7a4a453, 0x967272e4, 0x5bc0c09b,\n+      0xc2b7b775, 0x1cfdfde1, 0xae93933d, 0x6a26264c,\n+      0x5a36366c, 0x413f3f7e, 0x02f7f7f5, 0x4fcccc83,\n+      0x5c343468, 0xf4a5a551, 0x34e5e5d1, 0x08f1f1f9,\n+      0x937171e2, 0x73d8d8ab, 0x53313162, 0x3f15152a,\n+      0x0c040408, 0x52c7c795, 0x65232346, 0x5ec3c39d,\n+      0x28181830, 0xa1969637, 0x0f05050a, 0xb59a9a2f,\n+      0x0907070e, 0x36121224, 0x9b80801b, 0x3de2e2df,\n+      0x26ebebcd, 0x6927274e, 0xcdb2b27f, 0x9f7575ea,\n+      0x1b090912, 0x9e83831d, 0x742c2c58, 0x2e1a1a34,\n+      0x2d1b1b36, 0xb26e6edc, 0xee5a5ab4, 0xfba0a05b,\n+      0xf65252a4, 0x4d3b3b76, 0x61d6d6b7, 0xceb3b37d,\n+      0x7b292952, 0x3ee3e3dd, 0x712f2f5e, 0x97848413,\n+      0xf55353a6, 0x68d1d1b9, 0x00000000, 0x2cededc1,\n+      0x60202040, 0x1ffcfce3, 0xc8b1b179, 0xed5b5bb6,\n+      0xbe6a6ad4, 0x46cbcb8d, 0xd9bebe67, 0x4b393972,\n+      0xde4a4a94, 0xd44c4c98, 0xe85858b0, 0x4acfcf85,\n+      0x6bd0d0bb, 0x2aefefc5, 0xe5aaaa4f, 0x16fbfbed,\n+      0xc5434386, 0xd74d4d9a, 0x55333366, 0x94858511,\n+      0xcf45458a, 0x10f9f9e9, 0x06020204, 0x817f7ffe,\n+      0xf05050a0, 0x443c3c78, 0xba9f9f25, 0xe3a8a84b,\n+      0xf35151a2, 0xfea3a35d, 0xc0404080, 0x8a8f8f05,\n+      0xad92923f, 0xbc9d9d21, 0x48383870, 0x04f5f5f1,\n+      0xdfbcbc63, 0xc1b6b677, 0x75dadaaf, 0x63212142,\n+      0x30101020, 0x1affffe5, 0x0ef3f3fd, 0x6dd2d2bf,\n+      0x4ccdcd81, 0x140c0c18, 0x35131326, 0x2fececc3,\n+      0xe15f5fbe, 0xa2979735, 0xcc444488, 0x3917172e,\n+      0x57c4c493, 0xf2a7a755, 0x827e7efc, 0x473d3d7a,\n+      0xac6464c8, 0xe75d5dba, 0x2b191932, 0x957373e6,\n+      0xa06060c0, 0x98818119, 0xd14f4f9e, 0x7fdcdca3,\n+      0x66222244, 0x7e2a2a54, 0xab90903b, 0x8388880b,\n+      0xca46468c, 0x29eeeec7, 0xd3b8b86b, 0x3c141428,\n+      0x79dedea7, 0xe25e5ebc, 0x1d0b0b16, 0x76dbdbad,\n+      0x3be0e0db, 0x56323264, 0x4e3a3a74, 0x1e0a0a14,\n+      0xdb494992, 0x0a06060c, 0x6c242448, 0xe45c5cb8,\n+      0x5dc2c29f, 0x6ed3d3bd, 0xefacac43, 0xa66262c4,\n+      0xa8919139, 0xa4959531, 0x37e4e4d3, 0x8b7979f2,\n+      0x32e7e7d5, 0x43c8c88b, 0x5937376e, 0xb76d6dda,\n+      0x8c8d8d01, 0x64d5d5b1, 0xd24e4e9c, 0xe0a9a949,\n+      0xb46c6cd8, 0xfa5656ac, 0x07f4f4f3, 0x25eaeacf,\n+      0xaf6565ca, 0x8e7a7af4, 0xe9aeae47, 0x18080810,\n+      0xd5baba6f, 0x887878f0, 0x6f25254a, 0x722e2e5c,\n+      0x241c1c38, 0xf1a6a657, 0xc7b4b473, 0x51c6c697,\n+      0x23e8e8cb, 0x7cdddda1, 0x9c7474e8, 0x211f1f3e,\n+      0xdd4b4b96, 0xdcbdbd61, 0x868b8b0d, 0x858a8a0f,\n+      0x907070e0, 0x423e3e7c, 0xc4b5b571, 0xaa6666cc,\n+      0xd8484890, 0x05030306, 0x01f6f6f7, 0x120e0e1c,\n+      0xa36161c2, 0x5f35356a, 0xf95757ae, 0xd0b9b969,\n+      0x91868617, 0x58c1c199, 0x271d1d3a, 0xb99e9e27,\n+      0x38e1e1d9, 0x13f8f8eb, 0xb398982b, 0x33111122,\n+      0xbb6969d2, 0x70d9d9a9, 0x898e8e07, 0xa7949433,\n+      0xb69b9b2d, 0x221e1e3c, 0x92878715, 0x20e9e9c9,\n+      0x49cece87, 0xff5555aa, 0x78282850, 0x7adfdfa5,\n+      0x8f8c8c03, 0xf8a1a159, 0x80898909, 0x170d0d1a,\n+      0xdabfbf65, 0x31e6e6d7, 0xc6424284, 0xb86868d0,\n+      0xc3414182, 0xb0999929, 0x772d2d5a, 0x110f0f1e,\n+      0xcbb0b07b, 0xfc5454a8, 0xd6bbbb6d, 0x3a16162c\n+    },\n+    0\n   };\n \n-static const struct\n+#define encT enc_tables.T\n+\n+static struct\n {\n+  volatile u32 counter_head;\n+  u32 cacheline_align[64 / 4 - 1];\n   u32 T[256];\n   byte inv_sbox[256];\n-} dec_tables =\n+  volatile u32 counter_tail;\n+} dec_tables ATTR_ALIGNED_64 =\n   {\n+    0,\n+    { 0, },\n     {\n       0x50a7f451, 0x5365417e, 0xc3a4171a, 0x965e273a,\n       0xcb6bab3b, 0xf1459d1f, 0xab58faac, 0x9303e34b,\n@@ -194,7 +212,8 @@ static const struct\n       0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,\n       0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,\n       0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d\n-    }\n+    },\n+    0\n   };\n \n #define decT dec_tables.T""}<_**next**_>{""sha"": ""2c9aa6733a5a8abcd6143d1a5071d8bc3f763325"", ""filename"": ""cipher/rijndael.c"", ""status"": ""modified"", ""additions"": 28, ""deletions"": 7, ""changes"": 35, ""blob_url"": ""https://github.com/gpg/libgcrypt/blob/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael.c"", ""raw_url"": ""https://github.com/gpg/libgcrypt/raw/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael.c"", ""contents_url"": ""https://api.github.com/repos/gpg/libgcrypt/contents/cipher/rijndael.c?ref=daedbbb5541cd8ecda1459d3b843ea4d92788762"", ""patch"": ""@@ -218,11 +218,11 @@ static const char *selftest(void);\n \n \f\n /* Prefetching for encryption/decryption tables. */\n-static void prefetch_table(const volatile byte *tab, size_t len)\n+static inline void prefetch_table(const volatile byte *tab, size_t len)\n {\n   size_t i;\n \n-  for (i = 0; i < len; i += 8 * 32)\n+  for (i = 0; len - i >= 8 * 32; i += 8 * 32)\n     {\n       (void)tab[i + 0 * 32];\n       (void)tab[i + 1 * 32];\n@@ -233,17 +233,37 @@ static void prefetch_table(const volatile byte *tab, size_t len)\n       (void)tab[i + 6 * 32];\n       (void)tab[i + 7 * 32];\n     }\n+  for (; i < len; i += 32)\n+    {\n+      (void)tab[i];\n+    }\n \n   (void)tab[len - 1];\n }\n \n static void prefetch_enc(void)\n {\n-  prefetch_table((const void *)encT, sizeof(encT));\n+  /* Modify counters to trigger copy-on-write and unsharing if physical pages\n+   * of look-up table are shared between processes.  Modifying counters also\n+   * causes checksums for pages to change and hint same-page merging algorithm\n+   * that these pages are frequently changing.  */\n+  enc_tables.counter_head++;\n+  enc_tables.counter_tail++;\n+\n+  /* Prefetch look-up tables to cache.  */\n+  prefetch_table((const void *)&enc_tables, sizeof(enc_tables));\n }\n \n static void prefetch_dec(void)\n {\n+  /* Modify counters to trigger copy-on-write and unsharing if physical pages\n+   * of look-up table are shared between processes.  Modifying counters also\n+   * causes checksums for pages to change and hint same-page merging algorithm\n+   * that these pages are frequently changing.  */\n+  dec_tables.counter_head++;\n+  dec_tables.counter_tail++;\n+\n+  /* Prefetch look-up tables to cache.  */\n   prefetch_table((const void *)&dec_tables, sizeof(dec_tables));\n }\n \n@@ -765,9 +785,10 @@ do_encrypt (const RIJNDAEL_context *ctx,\n {\n #ifdef USE_AMD64_ASM\n   return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,\n-\t\t\t\t       encT);\n+\t\t\t\t       enc_tables.T);\n #elif defined(USE_ARM_ASM)\n-  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);\n+  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,\n+\t\t\t\t     enc_tables.T);\n #else\n   return do_encrypt_fn (ctx, bx, ax);\n #endif /* !USE_ARM_ASM && !USE_AMD64_ASM*/\n@@ -1123,10 +1144,10 @@ do_decrypt (const RIJNDAEL_context *ctx, unsigned char *bx,\n {\n #ifdef USE_AMD64_ASM\n   return _gcry_aes_amd64_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n-\t\t\t\t       &dec_tables);\n+\t\t\t\t       dec_tables.T);\n #elif defined(USE_ARM_ASM)\n   return _gcry_aes_arm_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n-\t\t\t\t     &dec_tables);\n+\t\t\t\t     dec_tables.T);\n #else\n   return do_decrypt_fn (ctx, bx, ax);\n #endif /*!USE_ARM_ASM && !USE_AMD64_ASM*/""}","do_encrypt (const RIJNDAEL_context *ctx,
            unsigned char *bx, const unsigned char *ax)
 {
 #ifdef USE_AMD64_ASM
   return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,
				       enc_tables.T);
 #elif defined(USE_ARM_ASM)
  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,
				     enc_tables.T);
 #else
   return do_encrypt_fn (ctx, bx, ax);
 #endif /* !USE_ARM_ASM && !USE_AMD64_ASM*/
}
","do_encrypt (const RIJNDAEL_context *ctx,
            unsigned char *bx, const unsigned char *ax)
 {
 #ifdef USE_AMD64_ASM
   return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,
				       encT);
 #elif defined(USE_ARM_ASM)
  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);
 #else
   return do_encrypt_fn (ctx, bx, ax);
 #endif /* !USE_ARM_ASM && !USE_AMD64_ASM*/
}
",C,"				       enc_tables.T);
  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,
				     enc_tables.T);
","				       encT);
  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);
",,"@@ -218,11 +218,11 @@ static const char *selftest(void);
 
 
 /* Prefetching for encryption/decryption tables. */
-static void prefetch_table(const volatile byte *tab, size_t len)
+static inline void prefetch_table(const volatile byte *tab, size_t len)
 {
   size_t i;
 
-  for (i = 0; i < len; i += 8 * 32)
+  for (i = 0; len - i >= 8 * 32; i += 8 * 32)
     {
       (void)tab[i + 0 * 32];
       (void)tab[i + 1 * 32];
@@ -233,17 +233,37 @@ static void prefetch_table(const volatile byte *tab, size_t len)
       (void)tab[i + 6 * 32];
       (void)tab[i + 7 * 32];
     }
+  for (; i < len; i += 32)
+    {
+      (void)tab[i];
+    }
 
   (void)tab[len - 1];
 }
 
 static void prefetch_enc(void)
 {
-  prefetch_table((const void *)encT, sizeof(encT));
+  /* Modify counters to trigger copy-on-write and unsharing if physical pages
+   * of look-up table are shared between processes.  Modifying counters also
+   * causes checksums for pages to change and hint same-page merging algorithm
+   * that these pages are frequently changing.  */
+  enc_tables.counter_head++;
+  enc_tables.counter_tail++;
+
+  /* Prefetch look-up tables to cache.  */
+  prefetch_table((const void *)&enc_tables, sizeof(enc_tables));
 }
 
 static void prefetch_dec(void)
 {
+  /* Modify counters to trigger copy-on-write and unsharing if physical pages
+   * of look-up table are shared between processes.  Modifying counters also
+   * causes checksums for pages to change and hint same-page merging algorithm
+   * that these pages are frequently changing.  */
+  dec_tables.counter_head++;
+  dec_tables.counter_tail++;
+
+  /* Prefetch look-up tables to cache.  */
   prefetch_table((const void *)&dec_tables, sizeof(dec_tables));
 }
 
@@ -765,9 +785,10 @@ do_encrypt (const RIJNDAEL_context *ctx,
 {
 #ifdef USE_AMD64_ASM
   return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,
-				       encT);
+				       enc_tables.T);
 #elif defined(USE_ARM_ASM)
-  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);
+  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,
+				     enc_tables.T);
 #else
   return do_encrypt_fn (ctx, bx, ax);
 #endif /* !USE_ARM_ASM && !USE_AMD64_ASM*/
@@ -1123,10 +1144,10 @@ do_decrypt (const RIJNDAEL_context *ctx, unsigned char *bx,
 {
 #ifdef USE_AMD64_ASM
   return _gcry_aes_amd64_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,
-				       &dec_tables);
+				       dec_tables.T);
 #elif defined(USE_ARM_ASM)
   return _gcry_aes_arm_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,
-				     &dec_tables);
+				     dec_tables.T);
 #else
   return do_decrypt_fn (ctx, bx, ax);
 #endif /*!USE_ARM_ASM && !USE_AMD64_ASM*/",libgcrypt,daedbbb5541cd8ecda1459d3b843ea4d92788762,c6ffa216976d80a13486b13f64d6776cdb8b6ccf,1,"do_encrypt (const RIJNDAEL_context *ctx,
            unsigned char *bx, const unsigned char *ax)
 {
 #ifdef USE_AMD64_ASM
   return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,
//flaw_line_below:
				       encT);
//fix_flaw_line_below:
//				       enc_tables.T);
 #elif defined(USE_ARM_ASM)
//flaw_line_below:
  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);
//fix_flaw_line_below:
//  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,
//fix_flaw_line_below:
//				     enc_tables.T);
 #else
   return do_encrypt_fn (ctx, bx, ax);
 #endif /* !USE_ARM_ASM && !USE_AMD64_ASM*/
}
"
5649,183385,,Remote,Not required,,CVE-2019-12904,https://www.cvedetails.com/cve/CVE-2019-12904/,CWE-310,Medium,Partial,,,2019-06-19,4.3,"In Libgcrypt 1.8.4, the C implementation of AES is vulnerable to a flush-and-reload side-channel attack because physical addresses are available to other processes. (The C implementation is used on platforms where an assembly-language implementation is unavailable.)",2019-07-23,,8,https://github.com/gpg/libgcrypt/commit/daedbbb5541cd8ecda1459d3b843ea4d92788762,daedbbb5541cd8ecda1459d3b843ea4d92788762,"AES: move look-up tables to .data section and unshare between processes

* cipher/rijndael-internal.h (ATTR_ALIGNED_64): New.
* cipher/rijndael-tables.h (encT): Move to 'enc_tables' structure.
(enc_tables): New structure for encryption table with counters before
and after.
(encT): New macro.
(dec_tables): Add counters before and after encryption table; Move
from .rodata to .data section.
(do_encrypt): Change 'encT' to 'enc_tables.T'.
(do_decrypt): Change '&dec_tables' to 'dec_tables.T'.
* cipher/cipher-gcm.c (prefetch_table): Make inline; Handle input
with length not multiple of 256.
(prefetch_enc, prefetch_dec): Modify pre- and post-table counters
to unshare look-up table pages between processes.
--

GnuPG-bug-id: 4541
Signed-off-by: Jussi Kivilinna <jussi.kivilinna@iki.fi>",0,cipher/rijndael.c,"{""sha"": ""78b08e8f8c40fae9db0d047d87ab3bd509295565"", ""filename"": ""cipher/rijndael-internal.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/gpg/libgcrypt/blob/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael-internal.h"", ""raw_url"": ""https://github.com/gpg/libgcrypt/raw/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael-internal.h"", ""contents_url"": ""https://api.github.com/repos/gpg/libgcrypt/contents/cipher/rijndael-internal.h?ref=daedbbb5541cd8ecda1459d3b843ea4d92788762"", ""patch"": ""@@ -29,11 +29,13 @@\n #define BLOCKSIZE               (128/8)\n \n \n-/* Helper macro to force alignment to 16 bytes.  */\n+/* Helper macro to force alignment to 16 or 64 bytes.  */\n #ifdef HAVE_GCC_ATTRIBUTE_ALIGNED\n # define ATTR_ALIGNED_16  __attribute__ ((aligned (16)))\n+# define ATTR_ALIGNED_64  __attribute__ ((aligned (64)))\n #else\n # define ATTR_ALIGNED_16\n+# define ATTR_ALIGNED_64\n #endif\n \n ""}<_**next**_>{""sha"": ""b54d95939353ee760ee2d69d0c268998162f8ba3"", ""filename"": ""cipher/rijndael-tables.h"", ""status"": ""modified"", ""additions"": 87, ""deletions"": 68, ""changes"": 155, ""blob_url"": ""https://github.com/gpg/libgcrypt/blob/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael-tables.h"", ""raw_url"": ""https://github.com/gpg/libgcrypt/raw/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael-tables.h"", ""contents_url"": ""https://api.github.com/repos/gpg/libgcrypt/contents/cipher/rijndael-tables.h?ref=daedbbb5541cd8ecda1459d3b843ea4d92788762"", ""patch"": ""@@ -21,80 +21,98 @@\n /* To keep the actual implementation at a readable size we use this\n    include file to define the tables.  */\n \n-static const u32 encT[256] =\n+static struct\n+{\n+  volatile u32 counter_head;\n+  u32 cacheline_align[64 / 4 - 1];\n+  u32 T[256];\n+  volatile u32 counter_tail;\n+} enc_tables ATTR_ALIGNED_64 =\n   {\n-    0xa56363c6, 0x847c7cf8, 0x997777ee, 0x8d7b7bf6,\n-    0x0df2f2ff, 0xbd6b6bd6, 0xb16f6fde, 0x54c5c591,\n-    0x50303060, 0x03010102, 0xa96767ce, 0x7d2b2b56,\n-    0x19fefee7, 0x62d7d7b5, 0xe6abab4d, 0x9a7676ec,\n-    0x45caca8f, 0x9d82821f, 0x40c9c989, 0x877d7dfa,\n-    0x15fafaef, 0xeb5959b2, 0xc947478e, 0x0bf0f0fb,\n-    0xecadad41, 0x67d4d4b3, 0xfda2a25f, 0xeaafaf45,\n-    0xbf9c9c23, 0xf7a4a453, 0x967272e4, 0x5bc0c09b,\n-    0xc2b7b775, 0x1cfdfde1, 0xae93933d, 0x6a26264c,\n-    0x5a36366c, 0x413f3f7e, 0x02f7f7f5, 0x4fcccc83,\n-    0x5c343468, 0xf4a5a551, 0x34e5e5d1, 0x08f1f1f9,\n-    0x937171e2, 0x73d8d8ab, 0x53313162, 0x3f15152a,\n-    0x0c040408, 0x52c7c795, 0x65232346, 0x5ec3c39d,\n-    0x28181830, 0xa1969637, 0x0f05050a, 0xb59a9a2f,\n-    0x0907070e, 0x36121224, 0x9b80801b, 0x3de2e2df,\n-    0x26ebebcd, 0x6927274e, 0xcdb2b27f, 0x9f7575ea,\n-    0x1b090912, 0x9e83831d, 0x742c2c58, 0x2e1a1a34,\n-    0x2d1b1b36, 0xb26e6edc, 0xee5a5ab4, 0xfba0a05b,\n-    0xf65252a4, 0x4d3b3b76, 0x61d6d6b7, 0xceb3b37d,\n-    0x7b292952, 0x3ee3e3dd, 0x712f2f5e, 0x97848413,\n-    0xf55353a6, 0x68d1d1b9, 0x00000000, 0x2cededc1,\n-    0x60202040, 0x1ffcfce3, 0xc8b1b179, 0xed5b5bb6,\n-    0xbe6a6ad4, 0x46cbcb8d, 0xd9bebe67, 0x4b393972,\n-    0xde4a4a94, 0xd44c4c98, 0xe85858b0, 0x4acfcf85,\n-    0x6bd0d0bb, 0x2aefefc5, 0xe5aaaa4f, 0x16fbfbed,\n-    0xc5434386, 0xd74d4d9a, 0x55333366, 0x94858511,\n-    0xcf45458a, 0x10f9f9e9, 0x06020204, 0x817f7ffe,\n-    0xf05050a0, 0x443c3c78, 0xba9f9f25, 0xe3a8a84b,\n-    0xf35151a2, 0xfea3a35d, 0xc0404080, 0x8a8f8f05,\n-    0xad92923f, 0xbc9d9d21, 0x48383870, 0x04f5f5f1,\n-    0xdfbcbc63, 0xc1b6b677, 0x75dadaaf, 0x63212142,\n-    0x30101020, 0x1affffe5, 0x0ef3f3fd, 0x6dd2d2bf,\n-    0x4ccdcd81, 0x140c0c18, 0x35131326, 0x2fececc3,\n-    0xe15f5fbe, 0xa2979735, 0xcc444488, 0x3917172e,\n-    0x57c4c493, 0xf2a7a755, 0x827e7efc, 0x473d3d7a,\n-    0xac6464c8, 0xe75d5dba, 0x2b191932, 0x957373e6,\n-    0xa06060c0, 0x98818119, 0xd14f4f9e, 0x7fdcdca3,\n-    0x66222244, 0x7e2a2a54, 0xab90903b, 0x8388880b,\n-    0xca46468c, 0x29eeeec7, 0xd3b8b86b, 0x3c141428,\n-    0x79dedea7, 0xe25e5ebc, 0x1d0b0b16, 0x76dbdbad,\n-    0x3be0e0db, 0x56323264, 0x4e3a3a74, 0x1e0a0a14,\n-    0xdb494992, 0x0a06060c, 0x6c242448, 0xe45c5cb8,\n-    0x5dc2c29f, 0x6ed3d3bd, 0xefacac43, 0xa66262c4,\n-    0xa8919139, 0xa4959531, 0x37e4e4d3, 0x8b7979f2,\n-    0x32e7e7d5, 0x43c8c88b, 0x5937376e, 0xb76d6dda,\n-    0x8c8d8d01, 0x64d5d5b1, 0xd24e4e9c, 0xe0a9a949,\n-    0xb46c6cd8, 0xfa5656ac, 0x07f4f4f3, 0x25eaeacf,\n-    0xaf6565ca, 0x8e7a7af4, 0xe9aeae47, 0x18080810,\n-    0xd5baba6f, 0x887878f0, 0x6f25254a, 0x722e2e5c,\n-    0x241c1c38, 0xf1a6a657, 0xc7b4b473, 0x51c6c697,\n-    0x23e8e8cb, 0x7cdddda1, 0x9c7474e8, 0x211f1f3e,\n-    0xdd4b4b96, 0xdcbdbd61, 0x868b8b0d, 0x858a8a0f,\n-    0x907070e0, 0x423e3e7c, 0xc4b5b571, 0xaa6666cc,\n-    0xd8484890, 0x05030306, 0x01f6f6f7, 0x120e0e1c,\n-    0xa36161c2, 0x5f35356a, 0xf95757ae, 0xd0b9b969,\n-    0x91868617, 0x58c1c199, 0x271d1d3a, 0xb99e9e27,\n-    0x38e1e1d9, 0x13f8f8eb, 0xb398982b, 0x33111122,\n-    0xbb6969d2, 0x70d9d9a9, 0x898e8e07, 0xa7949433,\n-    0xb69b9b2d, 0x221e1e3c, 0x92878715, 0x20e9e9c9,\n-    0x49cece87, 0xff5555aa, 0x78282850, 0x7adfdfa5,\n-    0x8f8c8c03, 0xf8a1a159, 0x80898909, 0x170d0d1a,\n-    0xdabfbf65, 0x31e6e6d7, 0xc6424284, 0xb86868d0,\n-    0xc3414182, 0xb0999929, 0x772d2d5a, 0x110f0f1e,\n-    0xcbb0b07b, 0xfc5454a8, 0xd6bbbb6d, 0x3a16162c\n+    0,\n+    { 0, },\n+    {\n+      0xa56363c6, 0x847c7cf8, 0x997777ee, 0x8d7b7bf6,\n+      0x0df2f2ff, 0xbd6b6bd6, 0xb16f6fde, 0x54c5c591,\n+      0x50303060, 0x03010102, 0xa96767ce, 0x7d2b2b56,\n+      0x19fefee7, 0x62d7d7b5, 0xe6abab4d, 0x9a7676ec,\n+      0x45caca8f, 0x9d82821f, 0x40c9c989, 0x877d7dfa,\n+      0x15fafaef, 0xeb5959b2, 0xc947478e, 0x0bf0f0fb,\n+      0xecadad41, 0x67d4d4b3, 0xfda2a25f, 0xeaafaf45,\n+      0xbf9c9c23, 0xf7a4a453, 0x967272e4, 0x5bc0c09b,\n+      0xc2b7b775, 0x1cfdfde1, 0xae93933d, 0x6a26264c,\n+      0x5a36366c, 0x413f3f7e, 0x02f7f7f5, 0x4fcccc83,\n+      0x5c343468, 0xf4a5a551, 0x34e5e5d1, 0x08f1f1f9,\n+      0x937171e2, 0x73d8d8ab, 0x53313162, 0x3f15152a,\n+      0x0c040408, 0x52c7c795, 0x65232346, 0x5ec3c39d,\n+      0x28181830, 0xa1969637, 0x0f05050a, 0xb59a9a2f,\n+      0x0907070e, 0x36121224, 0x9b80801b, 0x3de2e2df,\n+      0x26ebebcd, 0x6927274e, 0xcdb2b27f, 0x9f7575ea,\n+      0x1b090912, 0x9e83831d, 0x742c2c58, 0x2e1a1a34,\n+      0x2d1b1b36, 0xb26e6edc, 0xee5a5ab4, 0xfba0a05b,\n+      0xf65252a4, 0x4d3b3b76, 0x61d6d6b7, 0xceb3b37d,\n+      0x7b292952, 0x3ee3e3dd, 0x712f2f5e, 0x97848413,\n+      0xf55353a6, 0x68d1d1b9, 0x00000000, 0x2cededc1,\n+      0x60202040, 0x1ffcfce3, 0xc8b1b179, 0xed5b5bb6,\n+      0xbe6a6ad4, 0x46cbcb8d, 0xd9bebe67, 0x4b393972,\n+      0xde4a4a94, 0xd44c4c98, 0xe85858b0, 0x4acfcf85,\n+      0x6bd0d0bb, 0x2aefefc5, 0xe5aaaa4f, 0x16fbfbed,\n+      0xc5434386, 0xd74d4d9a, 0x55333366, 0x94858511,\n+      0xcf45458a, 0x10f9f9e9, 0x06020204, 0x817f7ffe,\n+      0xf05050a0, 0x443c3c78, 0xba9f9f25, 0xe3a8a84b,\n+      0xf35151a2, 0xfea3a35d, 0xc0404080, 0x8a8f8f05,\n+      0xad92923f, 0xbc9d9d21, 0x48383870, 0x04f5f5f1,\n+      0xdfbcbc63, 0xc1b6b677, 0x75dadaaf, 0x63212142,\n+      0x30101020, 0x1affffe5, 0x0ef3f3fd, 0x6dd2d2bf,\n+      0x4ccdcd81, 0x140c0c18, 0x35131326, 0x2fececc3,\n+      0xe15f5fbe, 0xa2979735, 0xcc444488, 0x3917172e,\n+      0x57c4c493, 0xf2a7a755, 0x827e7efc, 0x473d3d7a,\n+      0xac6464c8, 0xe75d5dba, 0x2b191932, 0x957373e6,\n+      0xa06060c0, 0x98818119, 0xd14f4f9e, 0x7fdcdca3,\n+      0x66222244, 0x7e2a2a54, 0xab90903b, 0x8388880b,\n+      0xca46468c, 0x29eeeec7, 0xd3b8b86b, 0x3c141428,\n+      0x79dedea7, 0xe25e5ebc, 0x1d0b0b16, 0x76dbdbad,\n+      0x3be0e0db, 0x56323264, 0x4e3a3a74, 0x1e0a0a14,\n+      0xdb494992, 0x0a06060c, 0x6c242448, 0xe45c5cb8,\n+      0x5dc2c29f, 0x6ed3d3bd, 0xefacac43, 0xa66262c4,\n+      0xa8919139, 0xa4959531, 0x37e4e4d3, 0x8b7979f2,\n+      0x32e7e7d5, 0x43c8c88b, 0x5937376e, 0xb76d6dda,\n+      0x8c8d8d01, 0x64d5d5b1, 0xd24e4e9c, 0xe0a9a949,\n+      0xb46c6cd8, 0xfa5656ac, 0x07f4f4f3, 0x25eaeacf,\n+      0xaf6565ca, 0x8e7a7af4, 0xe9aeae47, 0x18080810,\n+      0xd5baba6f, 0x887878f0, 0x6f25254a, 0x722e2e5c,\n+      0x241c1c38, 0xf1a6a657, 0xc7b4b473, 0x51c6c697,\n+      0x23e8e8cb, 0x7cdddda1, 0x9c7474e8, 0x211f1f3e,\n+      0xdd4b4b96, 0xdcbdbd61, 0x868b8b0d, 0x858a8a0f,\n+      0x907070e0, 0x423e3e7c, 0xc4b5b571, 0xaa6666cc,\n+      0xd8484890, 0x05030306, 0x01f6f6f7, 0x120e0e1c,\n+      0xa36161c2, 0x5f35356a, 0xf95757ae, 0xd0b9b969,\n+      0x91868617, 0x58c1c199, 0x271d1d3a, 0xb99e9e27,\n+      0x38e1e1d9, 0x13f8f8eb, 0xb398982b, 0x33111122,\n+      0xbb6969d2, 0x70d9d9a9, 0x898e8e07, 0xa7949433,\n+      0xb69b9b2d, 0x221e1e3c, 0x92878715, 0x20e9e9c9,\n+      0x49cece87, 0xff5555aa, 0x78282850, 0x7adfdfa5,\n+      0x8f8c8c03, 0xf8a1a159, 0x80898909, 0x170d0d1a,\n+      0xdabfbf65, 0x31e6e6d7, 0xc6424284, 0xb86868d0,\n+      0xc3414182, 0xb0999929, 0x772d2d5a, 0x110f0f1e,\n+      0xcbb0b07b, 0xfc5454a8, 0xd6bbbb6d, 0x3a16162c\n+    },\n+    0\n   };\n \n-static const struct\n+#define encT enc_tables.T\n+\n+static struct\n {\n+  volatile u32 counter_head;\n+  u32 cacheline_align[64 / 4 - 1];\n   u32 T[256];\n   byte inv_sbox[256];\n-} dec_tables =\n+  volatile u32 counter_tail;\n+} dec_tables ATTR_ALIGNED_64 =\n   {\n+    0,\n+    { 0, },\n     {\n       0x50a7f451, 0x5365417e, 0xc3a4171a, 0x965e273a,\n       0xcb6bab3b, 0xf1459d1f, 0xab58faac, 0x9303e34b,\n@@ -194,7 +212,8 @@ static const struct\n       0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,\n       0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,\n       0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d\n-    }\n+    },\n+    0\n   };\n \n #define decT dec_tables.T""}<_**next**_>{""sha"": ""2c9aa6733a5a8abcd6143d1a5071d8bc3f763325"", ""filename"": ""cipher/rijndael.c"", ""status"": ""modified"", ""additions"": 28, ""deletions"": 7, ""changes"": 35, ""blob_url"": ""https://github.com/gpg/libgcrypt/blob/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael.c"", ""raw_url"": ""https://github.com/gpg/libgcrypt/raw/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael.c"", ""contents_url"": ""https://api.github.com/repos/gpg/libgcrypt/contents/cipher/rijndael.c?ref=daedbbb5541cd8ecda1459d3b843ea4d92788762"", ""patch"": ""@@ -218,11 +218,11 @@ static const char *selftest(void);\n \n \f\n /* Prefetching for encryption/decryption tables. */\n-static void prefetch_table(const volatile byte *tab, size_t len)\n+static inline void prefetch_table(const volatile byte *tab, size_t len)\n {\n   size_t i;\n \n-  for (i = 0; i < len; i += 8 * 32)\n+  for (i = 0; len - i >= 8 * 32; i += 8 * 32)\n     {\n       (void)tab[i + 0 * 32];\n       (void)tab[i + 1 * 32];\n@@ -233,17 +233,37 @@ static void prefetch_table(const volatile byte *tab, size_t len)\n       (void)tab[i + 6 * 32];\n       (void)tab[i + 7 * 32];\n     }\n+  for (; i < len; i += 32)\n+    {\n+      (void)tab[i];\n+    }\n \n   (void)tab[len - 1];\n }\n \n static void prefetch_enc(void)\n {\n-  prefetch_table((const void *)encT, sizeof(encT));\n+  /* Modify counters to trigger copy-on-write and unsharing if physical pages\n+   * of look-up table are shared between processes.  Modifying counters also\n+   * causes checksums for pages to change and hint same-page merging algorithm\n+   * that these pages are frequently changing.  */\n+  enc_tables.counter_head++;\n+  enc_tables.counter_tail++;\n+\n+  /* Prefetch look-up tables to cache.  */\n+  prefetch_table((const void *)&enc_tables, sizeof(enc_tables));\n }\n \n static void prefetch_dec(void)\n {\n+  /* Modify counters to trigger copy-on-write and unsharing if physical pages\n+   * of look-up table are shared between processes.  Modifying counters also\n+   * causes checksums for pages to change and hint same-page merging algorithm\n+   * that these pages are frequently changing.  */\n+  dec_tables.counter_head++;\n+  dec_tables.counter_tail++;\n+\n+  /* Prefetch look-up tables to cache.  */\n   prefetch_table((const void *)&dec_tables, sizeof(dec_tables));\n }\n \n@@ -765,9 +785,10 @@ do_encrypt (const RIJNDAEL_context *ctx,\n {\n #ifdef USE_AMD64_ASM\n   return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,\n-\t\t\t\t       encT);\n+\t\t\t\t       enc_tables.T);\n #elif defined(USE_ARM_ASM)\n-  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);\n+  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,\n+\t\t\t\t     enc_tables.T);\n #else\n   return do_encrypt_fn (ctx, bx, ax);\n #endif /* !USE_ARM_ASM && !USE_AMD64_ASM*/\n@@ -1123,10 +1144,10 @@ do_decrypt (const RIJNDAEL_context *ctx, unsigned char *bx,\n {\n #ifdef USE_AMD64_ASM\n   return _gcry_aes_amd64_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n-\t\t\t\t       &dec_tables);\n+\t\t\t\t       dec_tables.T);\n #elif defined(USE_ARM_ASM)\n   return _gcry_aes_arm_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n-\t\t\t\t     &dec_tables);\n+\t\t\t\t     dec_tables.T);\n #else\n   return do_decrypt_fn (ctx, bx, ax);\n #endif /*!USE_ARM_ASM && !USE_AMD64_ASM*/""}"," static void prefetch_dec(void)
 {
  /* Modify counters to trigger copy-on-write and unsharing if physical pages
   * of look-up table are shared between processes.  Modifying counters also
   * causes checksums for pages to change and hint same-page merging algorithm
   * that these pages are frequently changing.  */
  dec_tables.counter_head++;
  dec_tables.counter_tail++;

  /* Prefetch look-up tables to cache.  */
   prefetch_table((const void *)&dec_tables, sizeof(dec_tables));
 }
"," static void prefetch_dec(void)
 {
   prefetch_table((const void *)&dec_tables, sizeof(dec_tables));
 }
",C,"  /* Modify counters to trigger copy-on-write and unsharing if physical pages
   * of look-up table are shared between processes.  Modifying counters also
   * causes checksums for pages to change and hint same-page merging algorithm
   * that these pages are frequently changing.  */
  dec_tables.counter_head++;
  dec_tables.counter_tail++;

  /* Prefetch look-up tables to cache.  */
",,,"@@ -218,11 +218,11 @@ static const char *selftest(void);
 
 
 /* Prefetching for encryption/decryption tables. */
-static void prefetch_table(const volatile byte *tab, size_t len)
+static inline void prefetch_table(const volatile byte *tab, size_t len)
 {
   size_t i;
 
-  for (i = 0; i < len; i += 8 * 32)
+  for (i = 0; len - i >= 8 * 32; i += 8 * 32)
     {
       (void)tab[i + 0 * 32];
       (void)tab[i + 1 * 32];
@@ -233,17 +233,37 @@ static void prefetch_table(const volatile byte *tab, size_t len)
       (void)tab[i + 6 * 32];
       (void)tab[i + 7 * 32];
     }
+  for (; i < len; i += 32)
+    {
+      (void)tab[i];
+    }
 
   (void)tab[len - 1];
 }
 
 static void prefetch_enc(void)
 {
-  prefetch_table((const void *)encT, sizeof(encT));
+  /* Modify counters to trigger copy-on-write and unsharing if physical pages
+   * of look-up table are shared between processes.  Modifying counters also
+   * causes checksums for pages to change and hint same-page merging algorithm
+   * that these pages are frequently changing.  */
+  enc_tables.counter_head++;
+  enc_tables.counter_tail++;
+
+  /* Prefetch look-up tables to cache.  */
+  prefetch_table((const void *)&enc_tables, sizeof(enc_tables));
 }
 
 static void prefetch_dec(void)
 {
+  /* Modify counters to trigger copy-on-write and unsharing if physical pages
+   * of look-up table are shared between processes.  Modifying counters also
+   * causes checksums for pages to change and hint same-page merging algorithm
+   * that these pages are frequently changing.  */
+  dec_tables.counter_head++;
+  dec_tables.counter_tail++;
+
+  /* Prefetch look-up tables to cache.  */
   prefetch_table((const void *)&dec_tables, sizeof(dec_tables));
 }
 
@@ -765,9 +785,10 @@ do_encrypt (const RIJNDAEL_context *ctx,
 {
 #ifdef USE_AMD64_ASM
   return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,
-				       encT);
+				       enc_tables.T);
 #elif defined(USE_ARM_ASM)
-  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);
+  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,
+				     enc_tables.T);
 #else
   return do_encrypt_fn (ctx, bx, ax);
 #endif /* !USE_ARM_ASM && !USE_AMD64_ASM*/
@@ -1123,10 +1144,10 @@ do_decrypt (const RIJNDAEL_context *ctx, unsigned char *bx,
 {
 #ifdef USE_AMD64_ASM
   return _gcry_aes_amd64_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,
-				       &dec_tables);
+				       dec_tables.T);
 #elif defined(USE_ARM_ASM)
   return _gcry_aes_arm_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,
-				     &dec_tables);
+				     dec_tables.T);
 #else
   return do_decrypt_fn (ctx, bx, ax);
 #endif /*!USE_ARM_ASM && !USE_AMD64_ASM*/",libgcrypt,daedbbb5541cd8ecda1459d3b843ea4d92788762,c6ffa216976d80a13486b13f64d6776cdb8b6ccf,1," static void prefetch_dec(void)
 {
//fix_flaw_line_below:
//  /* Modify counters to trigger copy-on-write and unsharing if physical pages
//fix_flaw_line_below:
//   * of look-up table are shared between processes.  Modifying counters also
//fix_flaw_line_below:
//   * causes checksums for pages to change and hint same-page merging algorithm
//fix_flaw_line_below:
//   * that these pages are frequently changing.  */
//fix_flaw_line_below:
//  dec_tables.counter_head++;
//fix_flaw_line_below:
//  dec_tables.counter_tail++;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  /* Prefetch look-up tables to cache.  */
   prefetch_table((const void *)&dec_tables, sizeof(dec_tables));
 }
"
5650,183386,,Remote,Not required,,CVE-2019-12904,https://www.cvedetails.com/cve/CVE-2019-12904/,CWE-310,Medium,Partial,,,2019-06-19,4.3,"In Libgcrypt 1.8.4, the C implementation of AES is vulnerable to a flush-and-reload side-channel attack because physical addresses are available to other processes. (The C implementation is used on platforms where an assembly-language implementation is unavailable.)",2019-07-23,,9,https://github.com/gpg/libgcrypt/commit/daedbbb5541cd8ecda1459d3b843ea4d92788762,daedbbb5541cd8ecda1459d3b843ea4d92788762,"AES: move look-up tables to .data section and unshare between processes

* cipher/rijndael-internal.h (ATTR_ALIGNED_64): New.
* cipher/rijndael-tables.h (encT): Move to 'enc_tables' structure.
(enc_tables): New structure for encryption table with counters before
and after.
(encT): New macro.
(dec_tables): Add counters before and after encryption table; Move
from .rodata to .data section.
(do_encrypt): Change 'encT' to 'enc_tables.T'.
(do_decrypt): Change '&dec_tables' to 'dec_tables.T'.
* cipher/cipher-gcm.c (prefetch_table): Make inline; Handle input
with length not multiple of 256.
(prefetch_enc, prefetch_dec): Modify pre- and post-table counters
to unshare look-up table pages between processes.
--

GnuPG-bug-id: 4541
Signed-off-by: Jussi Kivilinna <jussi.kivilinna@iki.fi>",1,cipher/rijndael.c,"{""sha"": ""78b08e8f8c40fae9db0d047d87ab3bd509295565"", ""filename"": ""cipher/rijndael-internal.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/gpg/libgcrypt/blob/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael-internal.h"", ""raw_url"": ""https://github.com/gpg/libgcrypt/raw/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael-internal.h"", ""contents_url"": ""https://api.github.com/repos/gpg/libgcrypt/contents/cipher/rijndael-internal.h?ref=daedbbb5541cd8ecda1459d3b843ea4d92788762"", ""patch"": ""@@ -29,11 +29,13 @@\n #define BLOCKSIZE               (128/8)\n \n \n-/* Helper macro to force alignment to 16 bytes.  */\n+/* Helper macro to force alignment to 16 or 64 bytes.  */\n #ifdef HAVE_GCC_ATTRIBUTE_ALIGNED\n # define ATTR_ALIGNED_16  __attribute__ ((aligned (16)))\n+# define ATTR_ALIGNED_64  __attribute__ ((aligned (64)))\n #else\n # define ATTR_ALIGNED_16\n+# define ATTR_ALIGNED_64\n #endif\n \n ""}<_**next**_>{""sha"": ""b54d95939353ee760ee2d69d0c268998162f8ba3"", ""filename"": ""cipher/rijndael-tables.h"", ""status"": ""modified"", ""additions"": 87, ""deletions"": 68, ""changes"": 155, ""blob_url"": ""https://github.com/gpg/libgcrypt/blob/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael-tables.h"", ""raw_url"": ""https://github.com/gpg/libgcrypt/raw/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael-tables.h"", ""contents_url"": ""https://api.github.com/repos/gpg/libgcrypt/contents/cipher/rijndael-tables.h?ref=daedbbb5541cd8ecda1459d3b843ea4d92788762"", ""patch"": ""@@ -21,80 +21,98 @@\n /* To keep the actual implementation at a readable size we use this\n    include file to define the tables.  */\n \n-static const u32 encT[256] =\n+static struct\n+{\n+  volatile u32 counter_head;\n+  u32 cacheline_align[64 / 4 - 1];\n+  u32 T[256];\n+  volatile u32 counter_tail;\n+} enc_tables ATTR_ALIGNED_64 =\n   {\n-    0xa56363c6, 0x847c7cf8, 0x997777ee, 0x8d7b7bf6,\n-    0x0df2f2ff, 0xbd6b6bd6, 0xb16f6fde, 0x54c5c591,\n-    0x50303060, 0x03010102, 0xa96767ce, 0x7d2b2b56,\n-    0x19fefee7, 0x62d7d7b5, 0xe6abab4d, 0x9a7676ec,\n-    0x45caca8f, 0x9d82821f, 0x40c9c989, 0x877d7dfa,\n-    0x15fafaef, 0xeb5959b2, 0xc947478e, 0x0bf0f0fb,\n-    0xecadad41, 0x67d4d4b3, 0xfda2a25f, 0xeaafaf45,\n-    0xbf9c9c23, 0xf7a4a453, 0x967272e4, 0x5bc0c09b,\n-    0xc2b7b775, 0x1cfdfde1, 0xae93933d, 0x6a26264c,\n-    0x5a36366c, 0x413f3f7e, 0x02f7f7f5, 0x4fcccc83,\n-    0x5c343468, 0xf4a5a551, 0x34e5e5d1, 0x08f1f1f9,\n-    0x937171e2, 0x73d8d8ab, 0x53313162, 0x3f15152a,\n-    0x0c040408, 0x52c7c795, 0x65232346, 0x5ec3c39d,\n-    0x28181830, 0xa1969637, 0x0f05050a, 0xb59a9a2f,\n-    0x0907070e, 0x36121224, 0x9b80801b, 0x3de2e2df,\n-    0x26ebebcd, 0x6927274e, 0xcdb2b27f, 0x9f7575ea,\n-    0x1b090912, 0x9e83831d, 0x742c2c58, 0x2e1a1a34,\n-    0x2d1b1b36, 0xb26e6edc, 0xee5a5ab4, 0xfba0a05b,\n-    0xf65252a4, 0x4d3b3b76, 0x61d6d6b7, 0xceb3b37d,\n-    0x7b292952, 0x3ee3e3dd, 0x712f2f5e, 0x97848413,\n-    0xf55353a6, 0x68d1d1b9, 0x00000000, 0x2cededc1,\n-    0x60202040, 0x1ffcfce3, 0xc8b1b179, 0xed5b5bb6,\n-    0xbe6a6ad4, 0x46cbcb8d, 0xd9bebe67, 0x4b393972,\n-    0xde4a4a94, 0xd44c4c98, 0xe85858b0, 0x4acfcf85,\n-    0x6bd0d0bb, 0x2aefefc5, 0xe5aaaa4f, 0x16fbfbed,\n-    0xc5434386, 0xd74d4d9a, 0x55333366, 0x94858511,\n-    0xcf45458a, 0x10f9f9e9, 0x06020204, 0x817f7ffe,\n-    0xf05050a0, 0x443c3c78, 0xba9f9f25, 0xe3a8a84b,\n-    0xf35151a2, 0xfea3a35d, 0xc0404080, 0x8a8f8f05,\n-    0xad92923f, 0xbc9d9d21, 0x48383870, 0x04f5f5f1,\n-    0xdfbcbc63, 0xc1b6b677, 0x75dadaaf, 0x63212142,\n-    0x30101020, 0x1affffe5, 0x0ef3f3fd, 0x6dd2d2bf,\n-    0x4ccdcd81, 0x140c0c18, 0x35131326, 0x2fececc3,\n-    0xe15f5fbe, 0xa2979735, 0xcc444488, 0x3917172e,\n-    0x57c4c493, 0xf2a7a755, 0x827e7efc, 0x473d3d7a,\n-    0xac6464c8, 0xe75d5dba, 0x2b191932, 0x957373e6,\n-    0xa06060c0, 0x98818119, 0xd14f4f9e, 0x7fdcdca3,\n-    0x66222244, 0x7e2a2a54, 0xab90903b, 0x8388880b,\n-    0xca46468c, 0x29eeeec7, 0xd3b8b86b, 0x3c141428,\n-    0x79dedea7, 0xe25e5ebc, 0x1d0b0b16, 0x76dbdbad,\n-    0x3be0e0db, 0x56323264, 0x4e3a3a74, 0x1e0a0a14,\n-    0xdb494992, 0x0a06060c, 0x6c242448, 0xe45c5cb8,\n-    0x5dc2c29f, 0x6ed3d3bd, 0xefacac43, 0xa66262c4,\n-    0xa8919139, 0xa4959531, 0x37e4e4d3, 0x8b7979f2,\n-    0x32e7e7d5, 0x43c8c88b, 0x5937376e, 0xb76d6dda,\n-    0x8c8d8d01, 0x64d5d5b1, 0xd24e4e9c, 0xe0a9a949,\n-    0xb46c6cd8, 0xfa5656ac, 0x07f4f4f3, 0x25eaeacf,\n-    0xaf6565ca, 0x8e7a7af4, 0xe9aeae47, 0x18080810,\n-    0xd5baba6f, 0x887878f0, 0x6f25254a, 0x722e2e5c,\n-    0x241c1c38, 0xf1a6a657, 0xc7b4b473, 0x51c6c697,\n-    0x23e8e8cb, 0x7cdddda1, 0x9c7474e8, 0x211f1f3e,\n-    0xdd4b4b96, 0xdcbdbd61, 0x868b8b0d, 0x858a8a0f,\n-    0x907070e0, 0x423e3e7c, 0xc4b5b571, 0xaa6666cc,\n-    0xd8484890, 0x05030306, 0x01f6f6f7, 0x120e0e1c,\n-    0xa36161c2, 0x5f35356a, 0xf95757ae, 0xd0b9b969,\n-    0x91868617, 0x58c1c199, 0x271d1d3a, 0xb99e9e27,\n-    0x38e1e1d9, 0x13f8f8eb, 0xb398982b, 0x33111122,\n-    0xbb6969d2, 0x70d9d9a9, 0x898e8e07, 0xa7949433,\n-    0xb69b9b2d, 0x221e1e3c, 0x92878715, 0x20e9e9c9,\n-    0x49cece87, 0xff5555aa, 0x78282850, 0x7adfdfa5,\n-    0x8f8c8c03, 0xf8a1a159, 0x80898909, 0x170d0d1a,\n-    0xdabfbf65, 0x31e6e6d7, 0xc6424284, 0xb86868d0,\n-    0xc3414182, 0xb0999929, 0x772d2d5a, 0x110f0f1e,\n-    0xcbb0b07b, 0xfc5454a8, 0xd6bbbb6d, 0x3a16162c\n+    0,\n+    { 0, },\n+    {\n+      0xa56363c6, 0x847c7cf8, 0x997777ee, 0x8d7b7bf6,\n+      0x0df2f2ff, 0xbd6b6bd6, 0xb16f6fde, 0x54c5c591,\n+      0x50303060, 0x03010102, 0xa96767ce, 0x7d2b2b56,\n+      0x19fefee7, 0x62d7d7b5, 0xe6abab4d, 0x9a7676ec,\n+      0x45caca8f, 0x9d82821f, 0x40c9c989, 0x877d7dfa,\n+      0x15fafaef, 0xeb5959b2, 0xc947478e, 0x0bf0f0fb,\n+      0xecadad41, 0x67d4d4b3, 0xfda2a25f, 0xeaafaf45,\n+      0xbf9c9c23, 0xf7a4a453, 0x967272e4, 0x5bc0c09b,\n+      0xc2b7b775, 0x1cfdfde1, 0xae93933d, 0x6a26264c,\n+      0x5a36366c, 0x413f3f7e, 0x02f7f7f5, 0x4fcccc83,\n+      0x5c343468, 0xf4a5a551, 0x34e5e5d1, 0x08f1f1f9,\n+      0x937171e2, 0x73d8d8ab, 0x53313162, 0x3f15152a,\n+      0x0c040408, 0x52c7c795, 0x65232346, 0x5ec3c39d,\n+      0x28181830, 0xa1969637, 0x0f05050a, 0xb59a9a2f,\n+      0x0907070e, 0x36121224, 0x9b80801b, 0x3de2e2df,\n+      0x26ebebcd, 0x6927274e, 0xcdb2b27f, 0x9f7575ea,\n+      0x1b090912, 0x9e83831d, 0x742c2c58, 0x2e1a1a34,\n+      0x2d1b1b36, 0xb26e6edc, 0xee5a5ab4, 0xfba0a05b,\n+      0xf65252a4, 0x4d3b3b76, 0x61d6d6b7, 0xceb3b37d,\n+      0x7b292952, 0x3ee3e3dd, 0x712f2f5e, 0x97848413,\n+      0xf55353a6, 0x68d1d1b9, 0x00000000, 0x2cededc1,\n+      0x60202040, 0x1ffcfce3, 0xc8b1b179, 0xed5b5bb6,\n+      0xbe6a6ad4, 0x46cbcb8d, 0xd9bebe67, 0x4b393972,\n+      0xde4a4a94, 0xd44c4c98, 0xe85858b0, 0x4acfcf85,\n+      0x6bd0d0bb, 0x2aefefc5, 0xe5aaaa4f, 0x16fbfbed,\n+      0xc5434386, 0xd74d4d9a, 0x55333366, 0x94858511,\n+      0xcf45458a, 0x10f9f9e9, 0x06020204, 0x817f7ffe,\n+      0xf05050a0, 0x443c3c78, 0xba9f9f25, 0xe3a8a84b,\n+      0xf35151a2, 0xfea3a35d, 0xc0404080, 0x8a8f8f05,\n+      0xad92923f, 0xbc9d9d21, 0x48383870, 0x04f5f5f1,\n+      0xdfbcbc63, 0xc1b6b677, 0x75dadaaf, 0x63212142,\n+      0x30101020, 0x1affffe5, 0x0ef3f3fd, 0x6dd2d2bf,\n+      0x4ccdcd81, 0x140c0c18, 0x35131326, 0x2fececc3,\n+      0xe15f5fbe, 0xa2979735, 0xcc444488, 0x3917172e,\n+      0x57c4c493, 0xf2a7a755, 0x827e7efc, 0x473d3d7a,\n+      0xac6464c8, 0xe75d5dba, 0x2b191932, 0x957373e6,\n+      0xa06060c0, 0x98818119, 0xd14f4f9e, 0x7fdcdca3,\n+      0x66222244, 0x7e2a2a54, 0xab90903b, 0x8388880b,\n+      0xca46468c, 0x29eeeec7, 0xd3b8b86b, 0x3c141428,\n+      0x79dedea7, 0xe25e5ebc, 0x1d0b0b16, 0x76dbdbad,\n+      0x3be0e0db, 0x56323264, 0x4e3a3a74, 0x1e0a0a14,\n+      0xdb494992, 0x0a06060c, 0x6c242448, 0xe45c5cb8,\n+      0x5dc2c29f, 0x6ed3d3bd, 0xefacac43, 0xa66262c4,\n+      0xa8919139, 0xa4959531, 0x37e4e4d3, 0x8b7979f2,\n+      0x32e7e7d5, 0x43c8c88b, 0x5937376e, 0xb76d6dda,\n+      0x8c8d8d01, 0x64d5d5b1, 0xd24e4e9c, 0xe0a9a949,\n+      0xb46c6cd8, 0xfa5656ac, 0x07f4f4f3, 0x25eaeacf,\n+      0xaf6565ca, 0x8e7a7af4, 0xe9aeae47, 0x18080810,\n+      0xd5baba6f, 0x887878f0, 0x6f25254a, 0x722e2e5c,\n+      0x241c1c38, 0xf1a6a657, 0xc7b4b473, 0x51c6c697,\n+      0x23e8e8cb, 0x7cdddda1, 0x9c7474e8, 0x211f1f3e,\n+      0xdd4b4b96, 0xdcbdbd61, 0x868b8b0d, 0x858a8a0f,\n+      0x907070e0, 0x423e3e7c, 0xc4b5b571, 0xaa6666cc,\n+      0xd8484890, 0x05030306, 0x01f6f6f7, 0x120e0e1c,\n+      0xa36161c2, 0x5f35356a, 0xf95757ae, 0xd0b9b969,\n+      0x91868617, 0x58c1c199, 0x271d1d3a, 0xb99e9e27,\n+      0x38e1e1d9, 0x13f8f8eb, 0xb398982b, 0x33111122,\n+      0xbb6969d2, 0x70d9d9a9, 0x898e8e07, 0xa7949433,\n+      0xb69b9b2d, 0x221e1e3c, 0x92878715, 0x20e9e9c9,\n+      0x49cece87, 0xff5555aa, 0x78282850, 0x7adfdfa5,\n+      0x8f8c8c03, 0xf8a1a159, 0x80898909, 0x170d0d1a,\n+      0xdabfbf65, 0x31e6e6d7, 0xc6424284, 0xb86868d0,\n+      0xc3414182, 0xb0999929, 0x772d2d5a, 0x110f0f1e,\n+      0xcbb0b07b, 0xfc5454a8, 0xd6bbbb6d, 0x3a16162c\n+    },\n+    0\n   };\n \n-static const struct\n+#define encT enc_tables.T\n+\n+static struct\n {\n+  volatile u32 counter_head;\n+  u32 cacheline_align[64 / 4 - 1];\n   u32 T[256];\n   byte inv_sbox[256];\n-} dec_tables =\n+  volatile u32 counter_tail;\n+} dec_tables ATTR_ALIGNED_64 =\n   {\n+    0,\n+    { 0, },\n     {\n       0x50a7f451, 0x5365417e, 0xc3a4171a, 0x965e273a,\n       0xcb6bab3b, 0xf1459d1f, 0xab58faac, 0x9303e34b,\n@@ -194,7 +212,8 @@ static const struct\n       0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,\n       0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,\n       0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d\n-    }\n+    },\n+    0\n   };\n \n #define decT dec_tables.T""}<_**next**_>{""sha"": ""2c9aa6733a5a8abcd6143d1a5071d8bc3f763325"", ""filename"": ""cipher/rijndael.c"", ""status"": ""modified"", ""additions"": 28, ""deletions"": 7, ""changes"": 35, ""blob_url"": ""https://github.com/gpg/libgcrypt/blob/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael.c"", ""raw_url"": ""https://github.com/gpg/libgcrypt/raw/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael.c"", ""contents_url"": ""https://api.github.com/repos/gpg/libgcrypt/contents/cipher/rijndael.c?ref=daedbbb5541cd8ecda1459d3b843ea4d92788762"", ""patch"": ""@@ -218,11 +218,11 @@ static const char *selftest(void);\n \n \f\n /* Prefetching for encryption/decryption tables. */\n-static void prefetch_table(const volatile byte *tab, size_t len)\n+static inline void prefetch_table(const volatile byte *tab, size_t len)\n {\n   size_t i;\n \n-  for (i = 0; i < len; i += 8 * 32)\n+  for (i = 0; len - i >= 8 * 32; i += 8 * 32)\n     {\n       (void)tab[i + 0 * 32];\n       (void)tab[i + 1 * 32];\n@@ -233,17 +233,37 @@ static void prefetch_table(const volatile byte *tab, size_t len)\n       (void)tab[i + 6 * 32];\n       (void)tab[i + 7 * 32];\n     }\n+  for (; i < len; i += 32)\n+    {\n+      (void)tab[i];\n+    }\n \n   (void)tab[len - 1];\n }\n \n static void prefetch_enc(void)\n {\n-  prefetch_table((const void *)encT, sizeof(encT));\n+  /* Modify counters to trigger copy-on-write and unsharing if physical pages\n+   * of look-up table are shared between processes.  Modifying counters also\n+   * causes checksums for pages to change and hint same-page merging algorithm\n+   * that these pages are frequently changing.  */\n+  enc_tables.counter_head++;\n+  enc_tables.counter_tail++;\n+\n+  /* Prefetch look-up tables to cache.  */\n+  prefetch_table((const void *)&enc_tables, sizeof(enc_tables));\n }\n \n static void prefetch_dec(void)\n {\n+  /* Modify counters to trigger copy-on-write and unsharing if physical pages\n+   * of look-up table are shared between processes.  Modifying counters also\n+   * causes checksums for pages to change and hint same-page merging algorithm\n+   * that these pages are frequently changing.  */\n+  dec_tables.counter_head++;\n+  dec_tables.counter_tail++;\n+\n+  /* Prefetch look-up tables to cache.  */\n   prefetch_table((const void *)&dec_tables, sizeof(dec_tables));\n }\n \n@@ -765,9 +785,10 @@ do_encrypt (const RIJNDAEL_context *ctx,\n {\n #ifdef USE_AMD64_ASM\n   return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,\n-\t\t\t\t       encT);\n+\t\t\t\t       enc_tables.T);\n #elif defined(USE_ARM_ASM)\n-  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);\n+  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,\n+\t\t\t\t     enc_tables.T);\n #else\n   return do_encrypt_fn (ctx, bx, ax);\n #endif /* !USE_ARM_ASM && !USE_AMD64_ASM*/\n@@ -1123,10 +1144,10 @@ do_decrypt (const RIJNDAEL_context *ctx, unsigned char *bx,\n {\n #ifdef USE_AMD64_ASM\n   return _gcry_aes_amd64_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n-\t\t\t\t       &dec_tables);\n+\t\t\t\t       dec_tables.T);\n #elif defined(USE_ARM_ASM)\n   return _gcry_aes_arm_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n-\t\t\t\t     &dec_tables);\n+\t\t\t\t     dec_tables.T);\n #else\n   return do_decrypt_fn (ctx, bx, ax);\n #endif /*!USE_ARM_ASM && !USE_AMD64_ASM*/""}"," static void prefetch_enc(void)
 {
  /* Modify counters to trigger copy-on-write and unsharing if physical pages
   * of look-up table are shared between processes.  Modifying counters also
   * causes checksums for pages to change and hint same-page merging algorithm
   * that these pages are frequently changing.  */
  enc_tables.counter_head++;
  enc_tables.counter_tail++;

  /* Prefetch look-up tables to cache.  */
  prefetch_table((const void *)&enc_tables, sizeof(enc_tables));
 }
"," static void prefetch_enc(void)
 {
  prefetch_table((const void *)encT, sizeof(encT));
 }
",C,"  /* Modify counters to trigger copy-on-write and unsharing if physical pages
   * of look-up table are shared between processes.  Modifying counters also
   * causes checksums for pages to change and hint same-page merging algorithm
   * that these pages are frequently changing.  */
  enc_tables.counter_head++;
  enc_tables.counter_tail++;

  /* Prefetch look-up tables to cache.  */
  prefetch_table((const void *)&enc_tables, sizeof(enc_tables));
","  prefetch_table((const void *)encT, sizeof(encT));
",,"@@ -218,11 +218,11 @@ static const char *selftest(void);
 
 
 /* Prefetching for encryption/decryption tables. */
-static void prefetch_table(const volatile byte *tab, size_t len)
+static inline void prefetch_table(const volatile byte *tab, size_t len)
 {
   size_t i;
 
-  for (i = 0; i < len; i += 8 * 32)
+  for (i = 0; len - i >= 8 * 32; i += 8 * 32)
     {
       (void)tab[i + 0 * 32];
       (void)tab[i + 1 * 32];
@@ -233,17 +233,37 @@ static void prefetch_table(const volatile byte *tab, size_t len)
       (void)tab[i + 6 * 32];
       (void)tab[i + 7 * 32];
     }
+  for (; i < len; i += 32)
+    {
+      (void)tab[i];
+    }
 
   (void)tab[len - 1];
 }
 
 static void prefetch_enc(void)
 {
-  prefetch_table((const void *)encT, sizeof(encT));
+  /* Modify counters to trigger copy-on-write and unsharing if physical pages
+   * of look-up table are shared between processes.  Modifying counters also
+   * causes checksums for pages to change and hint same-page merging algorithm
+   * that these pages are frequently changing.  */
+  enc_tables.counter_head++;
+  enc_tables.counter_tail++;
+
+  /* Prefetch look-up tables to cache.  */
+  prefetch_table((const void *)&enc_tables, sizeof(enc_tables));
 }
 
 static void prefetch_dec(void)
 {
+  /* Modify counters to trigger copy-on-write and unsharing if physical pages
+   * of look-up table are shared between processes.  Modifying counters also
+   * causes checksums for pages to change and hint same-page merging algorithm
+   * that these pages are frequently changing.  */
+  dec_tables.counter_head++;
+  dec_tables.counter_tail++;
+
+  /* Prefetch look-up tables to cache.  */
   prefetch_table((const void *)&dec_tables, sizeof(dec_tables));
 }
 
@@ -765,9 +785,10 @@ do_encrypt (const RIJNDAEL_context *ctx,
 {
 #ifdef USE_AMD64_ASM
   return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,
-				       encT);
+				       enc_tables.T);
 #elif defined(USE_ARM_ASM)
-  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);
+  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,
+				     enc_tables.T);
 #else
   return do_encrypt_fn (ctx, bx, ax);
 #endif /* !USE_ARM_ASM && !USE_AMD64_ASM*/
@@ -1123,10 +1144,10 @@ do_decrypt (const RIJNDAEL_context *ctx, unsigned char *bx,
 {
 #ifdef USE_AMD64_ASM
   return _gcry_aes_amd64_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,
-				       &dec_tables);
+				       dec_tables.T);
 #elif defined(USE_ARM_ASM)
   return _gcry_aes_arm_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,
-				     &dec_tables);
+				     dec_tables.T);
 #else
   return do_decrypt_fn (ctx, bx, ax);
 #endif /*!USE_ARM_ASM && !USE_AMD64_ASM*/",libgcrypt,daedbbb5541cd8ecda1459d3b843ea4d92788762,c6ffa216976d80a13486b13f64d6776cdb8b6ccf,1," static void prefetch_enc(void)
 {
//flaw_line_below:
  prefetch_table((const void *)encT, sizeof(encT));
//fix_flaw_line_below:
//  /* Modify counters to trigger copy-on-write and unsharing if physical pages
//fix_flaw_line_below:
//   * of look-up table are shared between processes.  Modifying counters also
//fix_flaw_line_below:
//   * causes checksums for pages to change and hint same-page merging algorithm
//fix_flaw_line_below:
//   * that these pages are frequently changing.  */
//fix_flaw_line_below:
//  enc_tables.counter_head++;
//fix_flaw_line_below:
//  enc_tables.counter_tail++;
//fix_flaw_line_below:
//
//fix_flaw_line_below:
//  /* Prefetch look-up tables to cache.  */
//fix_flaw_line_below:
//  prefetch_table((const void *)&enc_tables, sizeof(enc_tables));
 }
"
5651,183387,,Remote,Not required,,CVE-2019-12904,https://www.cvedetails.com/cve/CVE-2019-12904/,CWE-310,Medium,Partial,,,2019-06-19,4.3,"In Libgcrypt 1.8.4, the C implementation of AES is vulnerable to a flush-and-reload side-channel attack because physical addresses are available to other processes. (The C implementation is used on platforms where an assembly-language implementation is unavailable.)",2019-07-23,,6,https://github.com/gpg/libgcrypt/commit/daedbbb5541cd8ecda1459d3b843ea4d92788762,daedbbb5541cd8ecda1459d3b843ea4d92788762,"AES: move look-up tables to .data section and unshare between processes

* cipher/rijndael-internal.h (ATTR_ALIGNED_64): New.
* cipher/rijndael-tables.h (encT): Move to 'enc_tables' structure.
(enc_tables): New structure for encryption table with counters before
and after.
(encT): New macro.
(dec_tables): Add counters before and after encryption table; Move
from .rodata to .data section.
(do_encrypt): Change 'encT' to 'enc_tables.T'.
(do_decrypt): Change '&dec_tables' to 'dec_tables.T'.
* cipher/cipher-gcm.c (prefetch_table): Make inline; Handle input
with length not multiple of 256.
(prefetch_enc, prefetch_dec): Modify pre- and post-table counters
to unshare look-up table pages between processes.
--

GnuPG-bug-id: 4541
Signed-off-by: Jussi Kivilinna <jussi.kivilinna@iki.fi>",1,cipher/rijndael.c,"{""sha"": ""78b08e8f8c40fae9db0d047d87ab3bd509295565"", ""filename"": ""cipher/rijndael-internal.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/gpg/libgcrypt/blob/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael-internal.h"", ""raw_url"": ""https://github.com/gpg/libgcrypt/raw/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael-internal.h"", ""contents_url"": ""https://api.github.com/repos/gpg/libgcrypt/contents/cipher/rijndael-internal.h?ref=daedbbb5541cd8ecda1459d3b843ea4d92788762"", ""patch"": ""@@ -29,11 +29,13 @@\n #define BLOCKSIZE               (128/8)\n \n \n-/* Helper macro to force alignment to 16 bytes.  */\n+/* Helper macro to force alignment to 16 or 64 bytes.  */\n #ifdef HAVE_GCC_ATTRIBUTE_ALIGNED\n # define ATTR_ALIGNED_16  __attribute__ ((aligned (16)))\n+# define ATTR_ALIGNED_64  __attribute__ ((aligned (64)))\n #else\n # define ATTR_ALIGNED_16\n+# define ATTR_ALIGNED_64\n #endif\n \n ""}<_**next**_>{""sha"": ""b54d95939353ee760ee2d69d0c268998162f8ba3"", ""filename"": ""cipher/rijndael-tables.h"", ""status"": ""modified"", ""additions"": 87, ""deletions"": 68, ""changes"": 155, ""blob_url"": ""https://github.com/gpg/libgcrypt/blob/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael-tables.h"", ""raw_url"": ""https://github.com/gpg/libgcrypt/raw/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael-tables.h"", ""contents_url"": ""https://api.github.com/repos/gpg/libgcrypt/contents/cipher/rijndael-tables.h?ref=daedbbb5541cd8ecda1459d3b843ea4d92788762"", ""patch"": ""@@ -21,80 +21,98 @@\n /* To keep the actual implementation at a readable size we use this\n    include file to define the tables.  */\n \n-static const u32 encT[256] =\n+static struct\n+{\n+  volatile u32 counter_head;\n+  u32 cacheline_align[64 / 4 - 1];\n+  u32 T[256];\n+  volatile u32 counter_tail;\n+} enc_tables ATTR_ALIGNED_64 =\n   {\n-    0xa56363c6, 0x847c7cf8, 0x997777ee, 0x8d7b7bf6,\n-    0x0df2f2ff, 0xbd6b6bd6, 0xb16f6fde, 0x54c5c591,\n-    0x50303060, 0x03010102, 0xa96767ce, 0x7d2b2b56,\n-    0x19fefee7, 0x62d7d7b5, 0xe6abab4d, 0x9a7676ec,\n-    0x45caca8f, 0x9d82821f, 0x40c9c989, 0x877d7dfa,\n-    0x15fafaef, 0xeb5959b2, 0xc947478e, 0x0bf0f0fb,\n-    0xecadad41, 0x67d4d4b3, 0xfda2a25f, 0xeaafaf45,\n-    0xbf9c9c23, 0xf7a4a453, 0x967272e4, 0x5bc0c09b,\n-    0xc2b7b775, 0x1cfdfde1, 0xae93933d, 0x6a26264c,\n-    0x5a36366c, 0x413f3f7e, 0x02f7f7f5, 0x4fcccc83,\n-    0x5c343468, 0xf4a5a551, 0x34e5e5d1, 0x08f1f1f9,\n-    0x937171e2, 0x73d8d8ab, 0x53313162, 0x3f15152a,\n-    0x0c040408, 0x52c7c795, 0x65232346, 0x5ec3c39d,\n-    0x28181830, 0xa1969637, 0x0f05050a, 0xb59a9a2f,\n-    0x0907070e, 0x36121224, 0x9b80801b, 0x3de2e2df,\n-    0x26ebebcd, 0x6927274e, 0xcdb2b27f, 0x9f7575ea,\n-    0x1b090912, 0x9e83831d, 0x742c2c58, 0x2e1a1a34,\n-    0x2d1b1b36, 0xb26e6edc, 0xee5a5ab4, 0xfba0a05b,\n-    0xf65252a4, 0x4d3b3b76, 0x61d6d6b7, 0xceb3b37d,\n-    0x7b292952, 0x3ee3e3dd, 0x712f2f5e, 0x97848413,\n-    0xf55353a6, 0x68d1d1b9, 0x00000000, 0x2cededc1,\n-    0x60202040, 0x1ffcfce3, 0xc8b1b179, 0xed5b5bb6,\n-    0xbe6a6ad4, 0x46cbcb8d, 0xd9bebe67, 0x4b393972,\n-    0xde4a4a94, 0xd44c4c98, 0xe85858b0, 0x4acfcf85,\n-    0x6bd0d0bb, 0x2aefefc5, 0xe5aaaa4f, 0x16fbfbed,\n-    0xc5434386, 0xd74d4d9a, 0x55333366, 0x94858511,\n-    0xcf45458a, 0x10f9f9e9, 0x06020204, 0x817f7ffe,\n-    0xf05050a0, 0x443c3c78, 0xba9f9f25, 0xe3a8a84b,\n-    0xf35151a2, 0xfea3a35d, 0xc0404080, 0x8a8f8f05,\n-    0xad92923f, 0xbc9d9d21, 0x48383870, 0x04f5f5f1,\n-    0xdfbcbc63, 0xc1b6b677, 0x75dadaaf, 0x63212142,\n-    0x30101020, 0x1affffe5, 0x0ef3f3fd, 0x6dd2d2bf,\n-    0x4ccdcd81, 0x140c0c18, 0x35131326, 0x2fececc3,\n-    0xe15f5fbe, 0xa2979735, 0xcc444488, 0x3917172e,\n-    0x57c4c493, 0xf2a7a755, 0x827e7efc, 0x473d3d7a,\n-    0xac6464c8, 0xe75d5dba, 0x2b191932, 0x957373e6,\n-    0xa06060c0, 0x98818119, 0xd14f4f9e, 0x7fdcdca3,\n-    0x66222244, 0x7e2a2a54, 0xab90903b, 0x8388880b,\n-    0xca46468c, 0x29eeeec7, 0xd3b8b86b, 0x3c141428,\n-    0x79dedea7, 0xe25e5ebc, 0x1d0b0b16, 0x76dbdbad,\n-    0x3be0e0db, 0x56323264, 0x4e3a3a74, 0x1e0a0a14,\n-    0xdb494992, 0x0a06060c, 0x6c242448, 0xe45c5cb8,\n-    0x5dc2c29f, 0x6ed3d3bd, 0xefacac43, 0xa66262c4,\n-    0xa8919139, 0xa4959531, 0x37e4e4d3, 0x8b7979f2,\n-    0x32e7e7d5, 0x43c8c88b, 0x5937376e, 0xb76d6dda,\n-    0x8c8d8d01, 0x64d5d5b1, 0xd24e4e9c, 0xe0a9a949,\n-    0xb46c6cd8, 0xfa5656ac, 0x07f4f4f3, 0x25eaeacf,\n-    0xaf6565ca, 0x8e7a7af4, 0xe9aeae47, 0x18080810,\n-    0xd5baba6f, 0x887878f0, 0x6f25254a, 0x722e2e5c,\n-    0x241c1c38, 0xf1a6a657, 0xc7b4b473, 0x51c6c697,\n-    0x23e8e8cb, 0x7cdddda1, 0x9c7474e8, 0x211f1f3e,\n-    0xdd4b4b96, 0xdcbdbd61, 0x868b8b0d, 0x858a8a0f,\n-    0x907070e0, 0x423e3e7c, 0xc4b5b571, 0xaa6666cc,\n-    0xd8484890, 0x05030306, 0x01f6f6f7, 0x120e0e1c,\n-    0xa36161c2, 0x5f35356a, 0xf95757ae, 0xd0b9b969,\n-    0x91868617, 0x58c1c199, 0x271d1d3a, 0xb99e9e27,\n-    0x38e1e1d9, 0x13f8f8eb, 0xb398982b, 0x33111122,\n-    0xbb6969d2, 0x70d9d9a9, 0x898e8e07, 0xa7949433,\n-    0xb69b9b2d, 0x221e1e3c, 0x92878715, 0x20e9e9c9,\n-    0x49cece87, 0xff5555aa, 0x78282850, 0x7adfdfa5,\n-    0x8f8c8c03, 0xf8a1a159, 0x80898909, 0x170d0d1a,\n-    0xdabfbf65, 0x31e6e6d7, 0xc6424284, 0xb86868d0,\n-    0xc3414182, 0xb0999929, 0x772d2d5a, 0x110f0f1e,\n-    0xcbb0b07b, 0xfc5454a8, 0xd6bbbb6d, 0x3a16162c\n+    0,\n+    { 0, },\n+    {\n+      0xa56363c6, 0x847c7cf8, 0x997777ee, 0x8d7b7bf6,\n+      0x0df2f2ff, 0xbd6b6bd6, 0xb16f6fde, 0x54c5c591,\n+      0x50303060, 0x03010102, 0xa96767ce, 0x7d2b2b56,\n+      0x19fefee7, 0x62d7d7b5, 0xe6abab4d, 0x9a7676ec,\n+      0x45caca8f, 0x9d82821f, 0x40c9c989, 0x877d7dfa,\n+      0x15fafaef, 0xeb5959b2, 0xc947478e, 0x0bf0f0fb,\n+      0xecadad41, 0x67d4d4b3, 0xfda2a25f, 0xeaafaf45,\n+      0xbf9c9c23, 0xf7a4a453, 0x967272e4, 0x5bc0c09b,\n+      0xc2b7b775, 0x1cfdfde1, 0xae93933d, 0x6a26264c,\n+      0x5a36366c, 0x413f3f7e, 0x02f7f7f5, 0x4fcccc83,\n+      0x5c343468, 0xf4a5a551, 0x34e5e5d1, 0x08f1f1f9,\n+      0x937171e2, 0x73d8d8ab, 0x53313162, 0x3f15152a,\n+      0x0c040408, 0x52c7c795, 0x65232346, 0x5ec3c39d,\n+      0x28181830, 0xa1969637, 0x0f05050a, 0xb59a9a2f,\n+      0x0907070e, 0x36121224, 0x9b80801b, 0x3de2e2df,\n+      0x26ebebcd, 0x6927274e, 0xcdb2b27f, 0x9f7575ea,\n+      0x1b090912, 0x9e83831d, 0x742c2c58, 0x2e1a1a34,\n+      0x2d1b1b36, 0xb26e6edc, 0xee5a5ab4, 0xfba0a05b,\n+      0xf65252a4, 0x4d3b3b76, 0x61d6d6b7, 0xceb3b37d,\n+      0x7b292952, 0x3ee3e3dd, 0x712f2f5e, 0x97848413,\n+      0xf55353a6, 0x68d1d1b9, 0x00000000, 0x2cededc1,\n+      0x60202040, 0x1ffcfce3, 0xc8b1b179, 0xed5b5bb6,\n+      0xbe6a6ad4, 0x46cbcb8d, 0xd9bebe67, 0x4b393972,\n+      0xde4a4a94, 0xd44c4c98, 0xe85858b0, 0x4acfcf85,\n+      0x6bd0d0bb, 0x2aefefc5, 0xe5aaaa4f, 0x16fbfbed,\n+      0xc5434386, 0xd74d4d9a, 0x55333366, 0x94858511,\n+      0xcf45458a, 0x10f9f9e9, 0x06020204, 0x817f7ffe,\n+      0xf05050a0, 0x443c3c78, 0xba9f9f25, 0xe3a8a84b,\n+      0xf35151a2, 0xfea3a35d, 0xc0404080, 0x8a8f8f05,\n+      0xad92923f, 0xbc9d9d21, 0x48383870, 0x04f5f5f1,\n+      0xdfbcbc63, 0xc1b6b677, 0x75dadaaf, 0x63212142,\n+      0x30101020, 0x1affffe5, 0x0ef3f3fd, 0x6dd2d2bf,\n+      0x4ccdcd81, 0x140c0c18, 0x35131326, 0x2fececc3,\n+      0xe15f5fbe, 0xa2979735, 0xcc444488, 0x3917172e,\n+      0x57c4c493, 0xf2a7a755, 0x827e7efc, 0x473d3d7a,\n+      0xac6464c8, 0xe75d5dba, 0x2b191932, 0x957373e6,\n+      0xa06060c0, 0x98818119, 0xd14f4f9e, 0x7fdcdca3,\n+      0x66222244, 0x7e2a2a54, 0xab90903b, 0x8388880b,\n+      0xca46468c, 0x29eeeec7, 0xd3b8b86b, 0x3c141428,\n+      0x79dedea7, 0xe25e5ebc, 0x1d0b0b16, 0x76dbdbad,\n+      0x3be0e0db, 0x56323264, 0x4e3a3a74, 0x1e0a0a14,\n+      0xdb494992, 0x0a06060c, 0x6c242448, 0xe45c5cb8,\n+      0x5dc2c29f, 0x6ed3d3bd, 0xefacac43, 0xa66262c4,\n+      0xa8919139, 0xa4959531, 0x37e4e4d3, 0x8b7979f2,\n+      0x32e7e7d5, 0x43c8c88b, 0x5937376e, 0xb76d6dda,\n+      0x8c8d8d01, 0x64d5d5b1, 0xd24e4e9c, 0xe0a9a949,\n+      0xb46c6cd8, 0xfa5656ac, 0x07f4f4f3, 0x25eaeacf,\n+      0xaf6565ca, 0x8e7a7af4, 0xe9aeae47, 0x18080810,\n+      0xd5baba6f, 0x887878f0, 0x6f25254a, 0x722e2e5c,\n+      0x241c1c38, 0xf1a6a657, 0xc7b4b473, 0x51c6c697,\n+      0x23e8e8cb, 0x7cdddda1, 0x9c7474e8, 0x211f1f3e,\n+      0xdd4b4b96, 0xdcbdbd61, 0x868b8b0d, 0x858a8a0f,\n+      0x907070e0, 0x423e3e7c, 0xc4b5b571, 0xaa6666cc,\n+      0xd8484890, 0x05030306, 0x01f6f6f7, 0x120e0e1c,\n+      0xa36161c2, 0x5f35356a, 0xf95757ae, 0xd0b9b969,\n+      0x91868617, 0x58c1c199, 0x271d1d3a, 0xb99e9e27,\n+      0x38e1e1d9, 0x13f8f8eb, 0xb398982b, 0x33111122,\n+      0xbb6969d2, 0x70d9d9a9, 0x898e8e07, 0xa7949433,\n+      0xb69b9b2d, 0x221e1e3c, 0x92878715, 0x20e9e9c9,\n+      0x49cece87, 0xff5555aa, 0x78282850, 0x7adfdfa5,\n+      0x8f8c8c03, 0xf8a1a159, 0x80898909, 0x170d0d1a,\n+      0xdabfbf65, 0x31e6e6d7, 0xc6424284, 0xb86868d0,\n+      0xc3414182, 0xb0999929, 0x772d2d5a, 0x110f0f1e,\n+      0xcbb0b07b, 0xfc5454a8, 0xd6bbbb6d, 0x3a16162c\n+    },\n+    0\n   };\n \n-static const struct\n+#define encT enc_tables.T\n+\n+static struct\n {\n+  volatile u32 counter_head;\n+  u32 cacheline_align[64 / 4 - 1];\n   u32 T[256];\n   byte inv_sbox[256];\n-} dec_tables =\n+  volatile u32 counter_tail;\n+} dec_tables ATTR_ALIGNED_64 =\n   {\n+    0,\n+    { 0, },\n     {\n       0x50a7f451, 0x5365417e, 0xc3a4171a, 0x965e273a,\n       0xcb6bab3b, 0xf1459d1f, 0xab58faac, 0x9303e34b,\n@@ -194,7 +212,8 @@ static const struct\n       0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,\n       0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,\n       0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d\n-    }\n+    },\n+    0\n   };\n \n #define decT dec_tables.T""}<_**next**_>{""sha"": ""2c9aa6733a5a8abcd6143d1a5071d8bc3f763325"", ""filename"": ""cipher/rijndael.c"", ""status"": ""modified"", ""additions"": 28, ""deletions"": 7, ""changes"": 35, ""blob_url"": ""https://github.com/gpg/libgcrypt/blob/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael.c"", ""raw_url"": ""https://github.com/gpg/libgcrypt/raw/daedbbb5541cd8ecda1459d3b843ea4d92788762/cipher/rijndael.c"", ""contents_url"": ""https://api.github.com/repos/gpg/libgcrypt/contents/cipher/rijndael.c?ref=daedbbb5541cd8ecda1459d3b843ea4d92788762"", ""patch"": ""@@ -218,11 +218,11 @@ static const char *selftest(void);\n \n \f\n /* Prefetching for encryption/decryption tables. */\n-static void prefetch_table(const volatile byte *tab, size_t len)\n+static inline void prefetch_table(const volatile byte *tab, size_t len)\n {\n   size_t i;\n \n-  for (i = 0; i < len; i += 8 * 32)\n+  for (i = 0; len - i >= 8 * 32; i += 8 * 32)\n     {\n       (void)tab[i + 0 * 32];\n       (void)tab[i + 1 * 32];\n@@ -233,17 +233,37 @@ static void prefetch_table(const volatile byte *tab, size_t len)\n       (void)tab[i + 6 * 32];\n       (void)tab[i + 7 * 32];\n     }\n+  for (; i < len; i += 32)\n+    {\n+      (void)tab[i];\n+    }\n \n   (void)tab[len - 1];\n }\n \n static void prefetch_enc(void)\n {\n-  prefetch_table((const void *)encT, sizeof(encT));\n+  /* Modify counters to trigger copy-on-write and unsharing if physical pages\n+   * of look-up table are shared between processes.  Modifying counters also\n+   * causes checksums for pages to change and hint same-page merging algorithm\n+   * that these pages are frequently changing.  */\n+  enc_tables.counter_head++;\n+  enc_tables.counter_tail++;\n+\n+  /* Prefetch look-up tables to cache.  */\n+  prefetch_table((const void *)&enc_tables, sizeof(enc_tables));\n }\n \n static void prefetch_dec(void)\n {\n+  /* Modify counters to trigger copy-on-write and unsharing if physical pages\n+   * of look-up table are shared between processes.  Modifying counters also\n+   * causes checksums for pages to change and hint same-page merging algorithm\n+   * that these pages are frequently changing.  */\n+  dec_tables.counter_head++;\n+  dec_tables.counter_tail++;\n+\n+  /* Prefetch look-up tables to cache.  */\n   prefetch_table((const void *)&dec_tables, sizeof(dec_tables));\n }\n \n@@ -765,9 +785,10 @@ do_encrypt (const RIJNDAEL_context *ctx,\n {\n #ifdef USE_AMD64_ASM\n   return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,\n-\t\t\t\t       encT);\n+\t\t\t\t       enc_tables.T);\n #elif defined(USE_ARM_ASM)\n-  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);\n+  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,\n+\t\t\t\t     enc_tables.T);\n #else\n   return do_encrypt_fn (ctx, bx, ax);\n #endif /* !USE_ARM_ASM && !USE_AMD64_ASM*/\n@@ -1123,10 +1144,10 @@ do_decrypt (const RIJNDAEL_context *ctx, unsigned char *bx,\n {\n #ifdef USE_AMD64_ASM\n   return _gcry_aes_amd64_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n-\t\t\t\t       &dec_tables);\n+\t\t\t\t       dec_tables.T);\n #elif defined(USE_ARM_ASM)\n   return _gcry_aes_arm_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n-\t\t\t\t     &dec_tables);\n+\t\t\t\t     dec_tables.T);\n #else\n   return do_decrypt_fn (ctx, bx, ax);\n #endif /*!USE_ARM_ASM && !USE_AMD64_ASM*/""}","static void prefetch_table(const volatile byte *tab, size_t len)
static inline void prefetch_table(const volatile byte *tab, size_t len)
 {
   size_t i;
 
  for (i = 0; len - i >= 8 * 32; i += 8 * 32)
     {
       (void)tab[i + 0 * 32];
       (void)tab[i + 1 * 32];
      (void)tab[i + 2 * 32];
      (void)tab[i + 3 * 32];
      (void)tab[i + 4 * 32];
      (void)tab[i + 5 * 32];
       (void)tab[i + 6 * 32];
       (void)tab[i + 7 * 32];
     }
  for (; i < len; i += 32)
    {
      (void)tab[i];
    }
 
   (void)tab[len - 1];
 }
","static void prefetch_table(const volatile byte *tab, size_t len)
 {
   size_t i;
 
  for (i = 0; i < len; i += 8 * 32)
     {
       (void)tab[i + 0 * 32];
       (void)tab[i + 1 * 32];
      (void)tab[i + 2 * 32];
      (void)tab[i + 3 * 32];
      (void)tab[i + 4 * 32];
      (void)tab[i + 5 * 32];
       (void)tab[i + 6 * 32];
       (void)tab[i + 7 * 32];
     }
 
   (void)tab[len - 1];
 }
",C,"static inline void prefetch_table(const volatile byte *tab, size_t len)
  for (i = 0; len - i >= 8 * 32; i += 8 * 32)
  for (; i < len; i += 32)
    {
      (void)tab[i];
    }
","  for (i = 0; i < len; i += 8 * 32)
",,"@@ -218,11 +218,11 @@ static const char *selftest(void);
 
 
 /* Prefetching for encryption/decryption tables. */
-static void prefetch_table(const volatile byte *tab, size_t len)
+static inline void prefetch_table(const volatile byte *tab, size_t len)
 {
   size_t i;
 
-  for (i = 0; i < len; i += 8 * 32)
+  for (i = 0; len - i >= 8 * 32; i += 8 * 32)
     {
       (void)tab[i + 0 * 32];
       (void)tab[i + 1 * 32];
@@ -233,17 +233,37 @@ static void prefetch_table(const volatile byte *tab, size_t len)
       (void)tab[i + 6 * 32];
       (void)tab[i + 7 * 32];
     }
+  for (; i < len; i += 32)
+    {
+      (void)tab[i];
+    }
 
   (void)tab[len - 1];
 }
 
 static void prefetch_enc(void)
 {
-  prefetch_table((const void *)encT, sizeof(encT));
+  /* Modify counters to trigger copy-on-write and unsharing if physical pages
+   * of look-up table are shared between processes.  Modifying counters also
+   * causes checksums for pages to change and hint same-page merging algorithm
+   * that these pages are frequently changing.  */
+  enc_tables.counter_head++;
+  enc_tables.counter_tail++;
+
+  /* Prefetch look-up tables to cache.  */
+  prefetch_table((const void *)&enc_tables, sizeof(enc_tables));
 }
 
 static void prefetch_dec(void)
 {
+  /* Modify counters to trigger copy-on-write and unsharing if physical pages
+   * of look-up table are shared between processes.  Modifying counters also
+   * causes checksums for pages to change and hint same-page merging algorithm
+   * that these pages are frequently changing.  */
+  dec_tables.counter_head++;
+  dec_tables.counter_tail++;
+
+  /* Prefetch look-up tables to cache.  */
   prefetch_table((const void *)&dec_tables, sizeof(dec_tables));
 }
 
@@ -765,9 +785,10 @@ do_encrypt (const RIJNDAEL_context *ctx,
 {
 #ifdef USE_AMD64_ASM
   return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,
-				       encT);
+				       enc_tables.T);
 #elif defined(USE_ARM_ASM)
-  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);
+  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,
+				     enc_tables.T);
 #else
   return do_encrypt_fn (ctx, bx, ax);
 #endif /* !USE_ARM_ASM && !USE_AMD64_ASM*/
@@ -1123,10 +1144,10 @@ do_decrypt (const RIJNDAEL_context *ctx, unsigned char *bx,
 {
 #ifdef USE_AMD64_ASM
   return _gcry_aes_amd64_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,
-				       &dec_tables);
+				       dec_tables.T);
 #elif defined(USE_ARM_ASM)
   return _gcry_aes_arm_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,
-				     &dec_tables);
+				     dec_tables.T);
 #else
   return do_decrypt_fn (ctx, bx, ax);
 #endif /*!USE_ARM_ASM && !USE_AMD64_ASM*/",libgcrypt,daedbbb5541cd8ecda1459d3b843ea4d92788762,c6ffa216976d80a13486b13f64d6776cdb8b6ccf,1,"static void prefetch_table(const volatile byte *tab, size_t len)
//fix_flaw_line_below:
//static inline void prefetch_table(const volatile byte *tab, size_t len)
 {
   size_t i;
 
//flaw_line_below:
  for (i = 0; i < len; i += 8 * 32)
//fix_flaw_line_below:
//  for (i = 0; len - i >= 8 * 32; i += 8 * 32)
     {
       (void)tab[i + 0 * 32];
       (void)tab[i + 1 * 32];
      (void)tab[i + 2 * 32];
      (void)tab[i + 3 * 32];
      (void)tab[i + 4 * 32];
      (void)tab[i + 5 * 32];
       (void)tab[i + 6 * 32];
       (void)tab[i + 7 * 32];
     }
//fix_flaw_line_below:
//  for (; i < len; i += 32)
//fix_flaw_line_below:
//    {
//fix_flaw_line_below:
//      (void)tab[i];
//fix_flaw_line_below:
//    }
 
   (void)tab[len - 1];
 }
"
8470,186206,,Remote,Not required,,CVE-2016-1618,https://www.cvedetails.com/cve/CVE-2016-1618/,CWE-310,Medium,Partial,,,2016-01-25,4.3,"Blink, as used in Google Chrome before 48.0.2564.82, does not ensure that a proper cryptographicallyRandomValues random number generator is used, which makes it easier for remote attackers to defeat cryptographic protection mechanisms via unspecified vectors.",2016-12-07,,1,https://github.com/chromium/chromium/commit/0d151e09e13a704e9738ea913d117df7282e6c7d,0d151e09e13a704e9738ea913d117df7282e6c7d,"Add assertions that the empty Platform::cryptographicallyRandomValues() overrides are not being used.

These implementations are not safe and look scary if not accompanied by an assertion. Also one of the comments was incorrect.

BUG=552749

Review URL: https://codereview.chromium.org/1419293005

Cr-Commit-Position: refs/heads/master@{#359229}",0,media/blink/run_all_unittests.cc,"{""sha"": ""8a096d6c7ca21a8a7365d54c0ef3781aad8c65ef"", ""filename"": ""components/test_runner/test_common.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/components/test_runner/test_common.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/components/test_runner/test_common.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/test_runner/test_common.cc?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -6,6 +6,7 @@\n \n #include \""base/lazy_instance.h\""\n #include \""base/macros.h\""\n+#include \""base/rand_util.h\""\n #include \""third_party/WebKit/public/platform/Platform.h\""\n #include \""third_party/WebKit/public/web/WebKit.h\""\n \n@@ -30,7 +31,10 @@ class MockBlinkPlatform : NON_EXPORTED_BASE(public blink::Platform) {\n   }\n   ~MockBlinkPlatform() override {}\n   void cryptographicallyRandomValues(unsigned char* buffer,\n-                                     size_t length) override {}\n+                                     size_t length) override {\n+    base::RandBytes(buffer, length);\n+  }\n+\n  private:\n   DISALLOW_COPY_AND_ASSIGN(MockBlinkPlatform);\n };""}<_**next**_>{""sha"": ""cc8c0ed327547be6a21bb9563a7562e0ca00b698"", ""filename"": ""media/blink/run_all_unittests.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/media/blink/run_all_unittests.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/media/blink/run_all_unittests.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/run_all_unittests.cc?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -4,6 +4,7 @@\n \n #include \""base/bind.h\""\n #include \""base/message_loop/message_loop.h\""\n+#include \""base/rand_util.h\""\n #include \""base/test/launcher/unit_test_launcher.h\""\n #include \""base/test/test_suite.h\""\n #include \""build/build_config.h\""\n@@ -82,6 +83,7 @@ TestBlinkPlatformSupport::~TestBlinkPlatformSupport() {}\n void TestBlinkPlatformSupport::cryptographicallyRandomValues(\n     unsigned char* buffer,\n     size_t length) {\n+  base::RandBytes(buffer, length);\n }\n \n const unsigned char* TestBlinkPlatformSupport::getTraceCategoryEnabledFlag(""}<_**next**_>{""sha"": ""857c4a4a6f738990d82f2e5abf49e58822217058"", ""filename"": ""third_party/WebKit/Source/core/dom/ScriptRunnerTest.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/core/dom/ScriptRunnerTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/core/dom/ScriptRunnerTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/ScriptRunnerTest.cpp?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -103,7 +103,10 @@ class MockPlatform : public Platform, public WebScheduler {\n     {\n     }\n \n-    void cryptographicallyRandomValues(unsigned char* buffer, size_t length) override { }\n+    void cryptographicallyRandomValues(unsigned char* buffer, size_t length) override\n+    {\n+        RELEASE_ASSERT_NOT_REACHED();\n+    }\n \n     const unsigned char* getTraceCategoryEnabledFlag(const char* categoryName) override\n     {""}<_**next**_>{""sha"": ""260b95f123c19f362c457a7c9a238a32c5286f61"", ""filename"": ""third_party/WebKit/Source/core/fetch/CachingCorrectnessTest.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/core/fetch/CachingCorrectnessTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/core/fetch/CachingCorrectnessTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/fetch/CachingCorrectnessTest.cpp?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -147,7 +147,10 @@ class CachingCorrectnessTest : public ::testing::Test {\n         }\n \n         // These blink::Platform methods must be overriden to make a usable object.\n-        virtual void cryptographicallyRandomValues(unsigned char* buffer, size_t length) { ASSERT_NOT_REACHED(); }\n+        virtual void cryptographicallyRandomValues(unsigned char* buffer, size_t length)\n+        {\n+            RELEASE_ASSERT_NOT_REACHED();\n+        }\n         virtual const unsigned char* getTraceCategoryEnabledFlag(const char* categoryName)\n         {\n             return &kAConstUnsignedCharZero;""}<_**next**_>{""sha"": ""96fed1a842ee992ce21271e022cf5f23e793f3d9"", ""filename"": ""third_party/WebKit/Source/platform/TestingPlatformSupport.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/TestingPlatformSupport.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/TestingPlatformSupport.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/TestingPlatformSupport.cpp?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -88,6 +88,7 @@ WebDiscardableMemory* TestingPlatformSupport::allocateAndLockDiscardableMemory(s\n \n void TestingPlatformSupport::cryptographicallyRandomValues(unsigned char* buffer, size_t length)\n {\n+    RELEASE_ASSERT_NOT_REACHED();\n }\n \n const unsigned char* TestingPlatformSupport::getTraceCategoryEnabledFlag(const char* categoryName)""}<_**next**_>{""sha"": ""cafdcae19833cfbbad2a9cf5b64352a2cdafc2cf"", ""filename"": ""third_party/WebKit/Source/platform/fonts/FontCacheTest.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/fonts/FontCacheTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/fonts/FontCacheTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/fonts/FontCacheTest.cpp?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -16,7 +16,10 @@ class EmptyPlatform : public Platform {\n public:\n     EmptyPlatform() {}\n     ~EmptyPlatform() override {}\n-    void cryptographicallyRandomValues(unsigned char* buffer, size_t length) override { }\n+    void cryptographicallyRandomValues(unsigned char* buffer, size_t length) override\n+    {\n+        RELEASE_ASSERT_NOT_REACHED();\n+    }\n };\n \n TEST(FontCache, getLastResortFallbackFont)""}<_**next**_>{""sha"": ""a6fd744a4a7631c7b9bd3ae7b27a952b6ccd1ff9"", ""filename"": ""third_party/WebKit/Source/platform/graphics/RecordingImageBufferSurfaceTest.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/graphics/RecordingImageBufferSurfaceTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/graphics/RecordingImageBufferSurfaceTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/graphics/RecordingImageBufferSurfaceTest.cpp?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -338,7 +338,10 @@ class AutoInstallCurrentThreadPlatformMock {\n     class CurrentThreadPlatformMock : public Platform {\n     public:\n         CurrentThreadPlatformMock() { }\n-        virtual void cryptographicallyRandomValues(unsigned char* buffer, size_t length) { ASSERT_NOT_REACHED(); }\n+        virtual void cryptographicallyRandomValues(unsigned char* buffer, size_t length)\n+        {\n+            RELEASE_ASSERT_NOT_REACHED();\n+        }\n         WebThread* currentThread() override { return &m_currentThread; }\n \n         void enterRunLoop() { m_currentThread.enterRunLoop(); }""}<_**next**_>{""sha"": ""3a74f38940afe1be7120d62f6cf61355ef8c5b54"", ""filename"": ""third_party/WebKit/Source/platform/heap/RunAllTests.cpp"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/heap/RunAllTests.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/heap/RunAllTests.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/heap/RunAllTests.cpp?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -32,7 +32,6 @@\n \n #include \""platform/EventTracer.h\""\n #include \""platform/heap/Heap.h\""\n-#include \""wtf/CryptographicallyRandomNumber.h\""\n #include \""wtf/MainThread.h\""\n #include <base/bind.h>\n #include <base/test/launcher/unit_test_launcher.h>""}<_**next**_>{""sha"": ""e500aa4f3b7e3e592064448efc308644221ca35b"", ""filename"": ""third_party/WebKit/Source/platform/weborigin/OriginAccessEntryTest.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/weborigin/OriginAccessEntryTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/weborigin/OriginAccessEntryTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/weborigin/OriginAccessEntryTest.cpp?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -63,7 +63,10 @@ class OriginAccessEntryTestPlatform : public blink::Platform {\n     }\n \n     // Stub for pure virtual method.\n-    void cryptographicallyRandomValues(unsigned char*, size_t) override { ASSERT_NOT_REACHED(); }\n+    void cryptographicallyRandomValues(unsigned char*, size_t) override\n+    {\n+        RELEASE_ASSERT_NOT_REACHED();\n+    }\n \n     void setPublicSuffix(const blink::WebString& suffix)\n     {""}<_**next**_>{""sha"": ""988f2e8f87c89077dc604a2db175ade5901016f3"", ""filename"": ""third_party/WebKit/Source/web/ImageDecodeBench.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/web/ImageDecodeBench.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/web/ImageDecodeBench.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/web/ImageDecodeBench.cpp?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -369,7 +369,7 @@ int main(int argc, char* argv[])\n \n         void cryptographicallyRandomValues(unsigned char*, size_t) override\n         {\n-            // Do nothing: make blink::Platform use the default crypto-randoms.\n+            RELEASE_ASSERT_NOT_REACHED();\n         }\n \n         void screenColorProfile(WebVector<char>* profile) override""}"," void TestBlinkPlatformSupport::cryptographicallyRandomValues(
     unsigned char* buffer,
     size_t length) {
  base::RandBytes(buffer, length);
 }
"," void TestBlinkPlatformSupport::cryptographicallyRandomValues(
     unsigned char* buffer,
     size_t length) {
 }
",C,"  base::RandBytes(buffer, length);
",,,"@@ -4,6 +4,7 @@
 
 #include ""base/bind.h""
 #include ""base/message_loop/message_loop.h""
+#include ""base/rand_util.h""
 #include ""base/test/launcher/unit_test_launcher.h""
 #include ""base/test/test_suite.h""
 #include ""build/build_config.h""
@@ -82,6 +83,7 @@ TestBlinkPlatformSupport::~TestBlinkPlatformSupport() {}
 void TestBlinkPlatformSupport::cryptographicallyRandomValues(
     unsigned char* buffer,
     size_t length) {
+  base::RandBytes(buffer, length);
 }
 
 const unsigned char* TestBlinkPlatformSupport::getTraceCategoryEnabledFlag(",Chrome,0d151e09e13a704e9738ea913d117df7282e6c7d,438f52c765ac1e4d170e7feed3a9024f04e170ef,1," void TestBlinkPlatformSupport::cryptographicallyRandomValues(
     unsigned char* buffer,
     size_t length) {
//fix_flaw_line_below:
//  base::RandBytes(buffer, length);
 }
"
8471,186207,,Remote,Not required,,CVE-2016-1618,https://www.cvedetails.com/cve/CVE-2016-1618/,CWE-310,Medium,Partial,,,2016-01-25,4.3,"Blink, as used in Google Chrome before 48.0.2564.82, does not ensure that a proper cryptographicallyRandomValues random number generator is used, which makes it easier for remote attackers to defeat cryptographic protection mechanisms via unspecified vectors.",2016-12-07,,1,https://github.com/chromium/chromium/commit/0d151e09e13a704e9738ea913d117df7282e6c7d,0d151e09e13a704e9738ea913d117df7282e6c7d,"Add assertions that the empty Platform::cryptographicallyRandomValues() overrides are not being used.

These implementations are not safe and look scary if not accompanied by an assertion. Also one of the comments was incorrect.

BUG=552749

Review URL: https://codereview.chromium.org/1419293005

Cr-Commit-Position: refs/heads/master@{#359229}",0,third_party/WebKit/Source/platform/TestingPlatformSupport.cpp,"{""sha"": ""8a096d6c7ca21a8a7365d54c0ef3781aad8c65ef"", ""filename"": ""components/test_runner/test_common.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/components/test_runner/test_common.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/components/test_runner/test_common.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/test_runner/test_common.cc?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -6,6 +6,7 @@\n \n #include \""base/lazy_instance.h\""\n #include \""base/macros.h\""\n+#include \""base/rand_util.h\""\n #include \""third_party/WebKit/public/platform/Platform.h\""\n #include \""third_party/WebKit/public/web/WebKit.h\""\n \n@@ -30,7 +31,10 @@ class MockBlinkPlatform : NON_EXPORTED_BASE(public blink::Platform) {\n   }\n   ~MockBlinkPlatform() override {}\n   void cryptographicallyRandomValues(unsigned char* buffer,\n-                                     size_t length) override {}\n+                                     size_t length) override {\n+    base::RandBytes(buffer, length);\n+  }\n+\n  private:\n   DISALLOW_COPY_AND_ASSIGN(MockBlinkPlatform);\n };""}<_**next**_>{""sha"": ""cc8c0ed327547be6a21bb9563a7562e0ca00b698"", ""filename"": ""media/blink/run_all_unittests.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/media/blink/run_all_unittests.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/media/blink/run_all_unittests.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/run_all_unittests.cc?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -4,6 +4,7 @@\n \n #include \""base/bind.h\""\n #include \""base/message_loop/message_loop.h\""\n+#include \""base/rand_util.h\""\n #include \""base/test/launcher/unit_test_launcher.h\""\n #include \""base/test/test_suite.h\""\n #include \""build/build_config.h\""\n@@ -82,6 +83,7 @@ TestBlinkPlatformSupport::~TestBlinkPlatformSupport() {}\n void TestBlinkPlatformSupport::cryptographicallyRandomValues(\n     unsigned char* buffer,\n     size_t length) {\n+  base::RandBytes(buffer, length);\n }\n \n const unsigned char* TestBlinkPlatformSupport::getTraceCategoryEnabledFlag(""}<_**next**_>{""sha"": ""857c4a4a6f738990d82f2e5abf49e58822217058"", ""filename"": ""third_party/WebKit/Source/core/dom/ScriptRunnerTest.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/core/dom/ScriptRunnerTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/core/dom/ScriptRunnerTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/ScriptRunnerTest.cpp?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -103,7 +103,10 @@ class MockPlatform : public Platform, public WebScheduler {\n     {\n     }\n \n-    void cryptographicallyRandomValues(unsigned char* buffer, size_t length) override { }\n+    void cryptographicallyRandomValues(unsigned char* buffer, size_t length) override\n+    {\n+        RELEASE_ASSERT_NOT_REACHED();\n+    }\n \n     const unsigned char* getTraceCategoryEnabledFlag(const char* categoryName) override\n     {""}<_**next**_>{""sha"": ""260b95f123c19f362c457a7c9a238a32c5286f61"", ""filename"": ""third_party/WebKit/Source/core/fetch/CachingCorrectnessTest.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/core/fetch/CachingCorrectnessTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/core/fetch/CachingCorrectnessTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/fetch/CachingCorrectnessTest.cpp?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -147,7 +147,10 @@ class CachingCorrectnessTest : public ::testing::Test {\n         }\n \n         // These blink::Platform methods must be overriden to make a usable object.\n-        virtual void cryptographicallyRandomValues(unsigned char* buffer, size_t length) { ASSERT_NOT_REACHED(); }\n+        virtual void cryptographicallyRandomValues(unsigned char* buffer, size_t length)\n+        {\n+            RELEASE_ASSERT_NOT_REACHED();\n+        }\n         virtual const unsigned char* getTraceCategoryEnabledFlag(const char* categoryName)\n         {\n             return &kAConstUnsignedCharZero;""}<_**next**_>{""sha"": ""96fed1a842ee992ce21271e022cf5f23e793f3d9"", ""filename"": ""third_party/WebKit/Source/platform/TestingPlatformSupport.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/TestingPlatformSupport.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/TestingPlatformSupport.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/TestingPlatformSupport.cpp?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -88,6 +88,7 @@ WebDiscardableMemory* TestingPlatformSupport::allocateAndLockDiscardableMemory(s\n \n void TestingPlatformSupport::cryptographicallyRandomValues(unsigned char* buffer, size_t length)\n {\n+    RELEASE_ASSERT_NOT_REACHED();\n }\n \n const unsigned char* TestingPlatformSupport::getTraceCategoryEnabledFlag(const char* categoryName)""}<_**next**_>{""sha"": ""cafdcae19833cfbbad2a9cf5b64352a2cdafc2cf"", ""filename"": ""third_party/WebKit/Source/platform/fonts/FontCacheTest.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/fonts/FontCacheTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/fonts/FontCacheTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/fonts/FontCacheTest.cpp?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -16,7 +16,10 @@ class EmptyPlatform : public Platform {\n public:\n     EmptyPlatform() {}\n     ~EmptyPlatform() override {}\n-    void cryptographicallyRandomValues(unsigned char* buffer, size_t length) override { }\n+    void cryptographicallyRandomValues(unsigned char* buffer, size_t length) override\n+    {\n+        RELEASE_ASSERT_NOT_REACHED();\n+    }\n };\n \n TEST(FontCache, getLastResortFallbackFont)""}<_**next**_>{""sha"": ""a6fd744a4a7631c7b9bd3ae7b27a952b6ccd1ff9"", ""filename"": ""third_party/WebKit/Source/platform/graphics/RecordingImageBufferSurfaceTest.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/graphics/RecordingImageBufferSurfaceTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/graphics/RecordingImageBufferSurfaceTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/graphics/RecordingImageBufferSurfaceTest.cpp?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -338,7 +338,10 @@ class AutoInstallCurrentThreadPlatformMock {\n     class CurrentThreadPlatformMock : public Platform {\n     public:\n         CurrentThreadPlatformMock() { }\n-        virtual void cryptographicallyRandomValues(unsigned char* buffer, size_t length) { ASSERT_NOT_REACHED(); }\n+        virtual void cryptographicallyRandomValues(unsigned char* buffer, size_t length)\n+        {\n+            RELEASE_ASSERT_NOT_REACHED();\n+        }\n         WebThread* currentThread() override { return &m_currentThread; }\n \n         void enterRunLoop() { m_currentThread.enterRunLoop(); }""}<_**next**_>{""sha"": ""3a74f38940afe1be7120d62f6cf61355ef8c5b54"", ""filename"": ""third_party/WebKit/Source/platform/heap/RunAllTests.cpp"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/heap/RunAllTests.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/heap/RunAllTests.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/heap/RunAllTests.cpp?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -32,7 +32,6 @@\n \n #include \""platform/EventTracer.h\""\n #include \""platform/heap/Heap.h\""\n-#include \""wtf/CryptographicallyRandomNumber.h\""\n #include \""wtf/MainThread.h\""\n #include <base/bind.h>\n #include <base/test/launcher/unit_test_launcher.h>""}<_**next**_>{""sha"": ""e500aa4f3b7e3e592064448efc308644221ca35b"", ""filename"": ""third_party/WebKit/Source/platform/weborigin/OriginAccessEntryTest.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/weborigin/OriginAccessEntryTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/weborigin/OriginAccessEntryTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/weborigin/OriginAccessEntryTest.cpp?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -63,7 +63,10 @@ class OriginAccessEntryTestPlatform : public blink::Platform {\n     }\n \n     // Stub for pure virtual method.\n-    void cryptographicallyRandomValues(unsigned char*, size_t) override { ASSERT_NOT_REACHED(); }\n+    void cryptographicallyRandomValues(unsigned char*, size_t) override\n+    {\n+        RELEASE_ASSERT_NOT_REACHED();\n+    }\n \n     void setPublicSuffix(const blink::WebString& suffix)\n     {""}<_**next**_>{""sha"": ""988f2e8f87c89077dc604a2db175ade5901016f3"", ""filename"": ""third_party/WebKit/Source/web/ImageDecodeBench.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/web/ImageDecodeBench.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/web/ImageDecodeBench.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/web/ImageDecodeBench.cpp?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -369,7 +369,7 @@ int main(int argc, char* argv[])\n \n         void cryptographicallyRandomValues(unsigned char*, size_t) override\n         {\n-            // Do nothing: make blink::Platform use the default crypto-randoms.\n+            RELEASE_ASSERT_NOT_REACHED();\n         }\n \n         void screenColorProfile(WebVector<char>* profile) override""}"," void TestingPlatformSupport::cryptographicallyRandomValues(unsigned char* buffer, size_t length)
 {
    RELEASE_ASSERT_NOT_REACHED();
 }
"," void TestingPlatformSupport::cryptographicallyRandomValues(unsigned char* buffer, size_t length)
 {
 }
",C,"    RELEASE_ASSERT_NOT_REACHED();
",,,"@@ -88,6 +88,7 @@ WebDiscardableMemory* TestingPlatformSupport::allocateAndLockDiscardableMemory(s
 
 void TestingPlatformSupport::cryptographicallyRandomValues(unsigned char* buffer, size_t length)
 {
+    RELEASE_ASSERT_NOT_REACHED();
 }
 
 const unsigned char* TestingPlatformSupport::getTraceCategoryEnabledFlag(const char* categoryName)",Chrome,0d151e09e13a704e9738ea913d117df7282e6c7d,438f52c765ac1e4d170e7feed3a9024f04e170ef,1," void TestingPlatformSupport::cryptographicallyRandomValues(unsigned char* buffer, size_t length)
 {
//fix_flaw_line_below:
//    RELEASE_ASSERT_NOT_REACHED();
 }
"
8472,186208,,Remote,Not required,,CVE-2016-1618,https://www.cvedetails.com/cve/CVE-2016-1618/,CWE-310,Medium,Partial,,,2016-01-25,4.3,"Blink, as used in Google Chrome before 48.0.2564.82, does not ensure that a proper cryptographicallyRandomValues random number generator is used, which makes it easier for remote attackers to defeat cryptographic protection mechanisms via unspecified vectors.",2016-12-07,,1,https://github.com/chromium/chromium/commit/0d151e09e13a704e9738ea913d117df7282e6c7d,0d151e09e13a704e9738ea913d117df7282e6c7d,"Add assertions that the empty Platform::cryptographicallyRandomValues() overrides are not being used.

These implementations are not safe and look scary if not accompanied by an assertion. Also one of the comments was incorrect.

BUG=552749

Review URL: https://codereview.chromium.org/1419293005

Cr-Commit-Position: refs/heads/master@{#359229}",0,third_party/WebKit/Source/web/ImageDecodeBench.cpp,"{""sha"": ""8a096d6c7ca21a8a7365d54c0ef3781aad8c65ef"", ""filename"": ""components/test_runner/test_common.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/components/test_runner/test_common.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/components/test_runner/test_common.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/test_runner/test_common.cc?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -6,6 +6,7 @@\n \n #include \""base/lazy_instance.h\""\n #include \""base/macros.h\""\n+#include \""base/rand_util.h\""\n #include \""third_party/WebKit/public/platform/Platform.h\""\n #include \""third_party/WebKit/public/web/WebKit.h\""\n \n@@ -30,7 +31,10 @@ class MockBlinkPlatform : NON_EXPORTED_BASE(public blink::Platform) {\n   }\n   ~MockBlinkPlatform() override {}\n   void cryptographicallyRandomValues(unsigned char* buffer,\n-                                     size_t length) override {}\n+                                     size_t length) override {\n+    base::RandBytes(buffer, length);\n+  }\n+\n  private:\n   DISALLOW_COPY_AND_ASSIGN(MockBlinkPlatform);\n };""}<_**next**_>{""sha"": ""cc8c0ed327547be6a21bb9563a7562e0ca00b698"", ""filename"": ""media/blink/run_all_unittests.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/media/blink/run_all_unittests.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/media/blink/run_all_unittests.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/media/blink/run_all_unittests.cc?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -4,6 +4,7 @@\n \n #include \""base/bind.h\""\n #include \""base/message_loop/message_loop.h\""\n+#include \""base/rand_util.h\""\n #include \""base/test/launcher/unit_test_launcher.h\""\n #include \""base/test/test_suite.h\""\n #include \""build/build_config.h\""\n@@ -82,6 +83,7 @@ TestBlinkPlatformSupport::~TestBlinkPlatformSupport() {}\n void TestBlinkPlatformSupport::cryptographicallyRandomValues(\n     unsigned char* buffer,\n     size_t length) {\n+  base::RandBytes(buffer, length);\n }\n \n const unsigned char* TestBlinkPlatformSupport::getTraceCategoryEnabledFlag(""}<_**next**_>{""sha"": ""857c4a4a6f738990d82f2e5abf49e58822217058"", ""filename"": ""third_party/WebKit/Source/core/dom/ScriptRunnerTest.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/core/dom/ScriptRunnerTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/core/dom/ScriptRunnerTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/ScriptRunnerTest.cpp?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -103,7 +103,10 @@ class MockPlatform : public Platform, public WebScheduler {\n     {\n     }\n \n-    void cryptographicallyRandomValues(unsigned char* buffer, size_t length) override { }\n+    void cryptographicallyRandomValues(unsigned char* buffer, size_t length) override\n+    {\n+        RELEASE_ASSERT_NOT_REACHED();\n+    }\n \n     const unsigned char* getTraceCategoryEnabledFlag(const char* categoryName) override\n     {""}<_**next**_>{""sha"": ""260b95f123c19f362c457a7c9a238a32c5286f61"", ""filename"": ""third_party/WebKit/Source/core/fetch/CachingCorrectnessTest.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/core/fetch/CachingCorrectnessTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/core/fetch/CachingCorrectnessTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/fetch/CachingCorrectnessTest.cpp?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -147,7 +147,10 @@ class CachingCorrectnessTest : public ::testing::Test {\n         }\n \n         // These blink::Platform methods must be overriden to make a usable object.\n-        virtual void cryptographicallyRandomValues(unsigned char* buffer, size_t length) { ASSERT_NOT_REACHED(); }\n+        virtual void cryptographicallyRandomValues(unsigned char* buffer, size_t length)\n+        {\n+            RELEASE_ASSERT_NOT_REACHED();\n+        }\n         virtual const unsigned char* getTraceCategoryEnabledFlag(const char* categoryName)\n         {\n             return &kAConstUnsignedCharZero;""}<_**next**_>{""sha"": ""96fed1a842ee992ce21271e022cf5f23e793f3d9"", ""filename"": ""third_party/WebKit/Source/platform/TestingPlatformSupport.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/TestingPlatformSupport.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/TestingPlatformSupport.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/TestingPlatformSupport.cpp?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -88,6 +88,7 @@ WebDiscardableMemory* TestingPlatformSupport::allocateAndLockDiscardableMemory(s\n \n void TestingPlatformSupport::cryptographicallyRandomValues(unsigned char* buffer, size_t length)\n {\n+    RELEASE_ASSERT_NOT_REACHED();\n }\n \n const unsigned char* TestingPlatformSupport::getTraceCategoryEnabledFlag(const char* categoryName)""}<_**next**_>{""sha"": ""cafdcae19833cfbbad2a9cf5b64352a2cdafc2cf"", ""filename"": ""third_party/WebKit/Source/platform/fonts/FontCacheTest.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/fonts/FontCacheTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/fonts/FontCacheTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/fonts/FontCacheTest.cpp?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -16,7 +16,10 @@ class EmptyPlatform : public Platform {\n public:\n     EmptyPlatform() {}\n     ~EmptyPlatform() override {}\n-    void cryptographicallyRandomValues(unsigned char* buffer, size_t length) override { }\n+    void cryptographicallyRandomValues(unsigned char* buffer, size_t length) override\n+    {\n+        RELEASE_ASSERT_NOT_REACHED();\n+    }\n };\n \n TEST(FontCache, getLastResortFallbackFont)""}<_**next**_>{""sha"": ""a6fd744a4a7631c7b9bd3ae7b27a952b6ccd1ff9"", ""filename"": ""third_party/WebKit/Source/platform/graphics/RecordingImageBufferSurfaceTest.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/graphics/RecordingImageBufferSurfaceTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/graphics/RecordingImageBufferSurfaceTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/graphics/RecordingImageBufferSurfaceTest.cpp?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -338,7 +338,10 @@ class AutoInstallCurrentThreadPlatformMock {\n     class CurrentThreadPlatformMock : public Platform {\n     public:\n         CurrentThreadPlatformMock() { }\n-        virtual void cryptographicallyRandomValues(unsigned char* buffer, size_t length) { ASSERT_NOT_REACHED(); }\n+        virtual void cryptographicallyRandomValues(unsigned char* buffer, size_t length)\n+        {\n+            RELEASE_ASSERT_NOT_REACHED();\n+        }\n         WebThread* currentThread() override { return &m_currentThread; }\n \n         void enterRunLoop() { m_currentThread.enterRunLoop(); }""}<_**next**_>{""sha"": ""3a74f38940afe1be7120d62f6cf61355ef8c5b54"", ""filename"": ""third_party/WebKit/Source/platform/heap/RunAllTests.cpp"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/heap/RunAllTests.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/heap/RunAllTests.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/heap/RunAllTests.cpp?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -32,7 +32,6 @@\n \n #include \""platform/EventTracer.h\""\n #include \""platform/heap/Heap.h\""\n-#include \""wtf/CryptographicallyRandomNumber.h\""\n #include \""wtf/MainThread.h\""\n #include <base/bind.h>\n #include <base/test/launcher/unit_test_launcher.h>""}<_**next**_>{""sha"": ""e500aa4f3b7e3e592064448efc308644221ca35b"", ""filename"": ""third_party/WebKit/Source/platform/weborigin/OriginAccessEntryTest.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/weborigin/OriginAccessEntryTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/platform/weborigin/OriginAccessEntryTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/weborigin/OriginAccessEntryTest.cpp?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -63,7 +63,10 @@ class OriginAccessEntryTestPlatform : public blink::Platform {\n     }\n \n     // Stub for pure virtual method.\n-    void cryptographicallyRandomValues(unsigned char*, size_t) override { ASSERT_NOT_REACHED(); }\n+    void cryptographicallyRandomValues(unsigned char*, size_t) override\n+    {\n+        RELEASE_ASSERT_NOT_REACHED();\n+    }\n \n     void setPublicSuffix(const blink::WebString& suffix)\n     {""}<_**next**_>{""sha"": ""988f2e8f87c89077dc604a2db175ade5901016f3"", ""filename"": ""third_party/WebKit/Source/web/ImageDecodeBench.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/web/ImageDecodeBench.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0d151e09e13a704e9738ea913d117df7282e6c7d/third_party/WebKit/Source/web/ImageDecodeBench.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/web/ImageDecodeBench.cpp?ref=0d151e09e13a704e9738ea913d117df7282e6c7d"", ""patch"": ""@@ -369,7 +369,7 @@ int main(int argc, char* argv[])\n \n         void cryptographicallyRandomValues(unsigned char*, size_t) override\n         {\n-            // Do nothing: make blink::Platform use the default crypto-randoms.\n+            RELEASE_ASSERT_NOT_REACHED();\n         }\n \n         void screenColorProfile(WebVector<char>* profile) override""}","int main(int argc, char* argv[])
{
    char* name = argv[0];


    bool applyColorCorrection = false;

#if USE(QCMSLIB)
    if (argc >= 2 && strcmp(argv[1], ""--color-correct"") == 0)
        applyColorCorrection = (--argc, ++argv, true);

    if (argc < 2) {
        fprintf(stderr, ""Usage: %s [--color-correct] file [iterations] [packetSize]\n"", name);
        exit(1);
    }
#else
    if (argc < 2) {
        fprintf(stderr, ""Usage: %s file [iterations] [packetSize]\n"", name);
        exit(1);
    }
#endif


    size_t iterations = 1;
    if (argc >= 3) {
        char* end = 0;
        iterations = strtol(argv[2], &end, 10);
        if (*end != '\0' || !iterations) {
            fprintf(stderr, ""Second argument should be number of iterations. ""
                ""The default is 1. You supplied %s\n"", argv[2]);
            exit(1);
        }
    }

    size_t packetSize = 0;
    if (argc >= 4) {
        char* end = 0;
        packetSize = strtol(argv[3], &end, 10);
        if (*end != '\0') {
            fprintf(stderr, ""Third argument should be packet size. Default is ""
                ""0, meaning to decode the entire image in one packet. You ""
                ""supplied %s\n"", argv[3]);
            exit(1);
        }
    }


    class WebPlatform : public blink::Platform {
    public:
        const unsigned char* getTraceCategoryEnabledFlag(const char*) override
        {
            return reinterpret_cast<const unsigned char *>(""nope-none-nada"");
        }
 
         void cryptographicallyRandomValues(unsigned char*, size_t) override
         {
            RELEASE_ASSERT_NOT_REACHED();
         }
 
         void screenColorProfile(WebVector<char>* profile) override
        {
            getScreenColorProfile(profile); // Returns a whacked color profile.
        }
    };

    blink::initializeWithoutV8(new WebPlatform());


#if USE(QCMSLIB)
    ImageDecoder::qcmsOutputDeviceProfile(); // Initialize screen colorProfile.
#endif


    RefPtr<SharedBuffer> data = readFile(argv[1]);
    if (!data.get() || !data->size()) {
        fprintf(stderr, ""Error reading image data from [%s]\n"", argv[1]);
        exit(2);
    }

    data->data();


    double totalTime = 0.0;

    for (size_t i = 0; i < iterations; ++i) {
        double startTime = getCurrentTime();
        bool decoded = decodeImageData(data.get(), applyColorCorrection, packetSize);
        double elapsedTime = getCurrentTime() - startTime;
        totalTime += elapsedTime;
        if (!decoded) {
            fprintf(stderr, ""Image decode failed [%s]\n"", argv[1]);
            exit(3);
        }
    }


    double averageTime = totalTime / static_cast<double>(iterations);
    printf(""%f %f\n"", totalTime, averageTime);
    return 0;
}
","int main(int argc, char* argv[])
{
    char* name = argv[0];


    bool applyColorCorrection = false;

#if USE(QCMSLIB)
    if (argc >= 2 && strcmp(argv[1], ""--color-correct"") == 0)
        applyColorCorrection = (--argc, ++argv, true);

    if (argc < 2) {
        fprintf(stderr, ""Usage: %s [--color-correct] file [iterations] [packetSize]\n"", name);
        exit(1);
    }
#else
    if (argc < 2) {
        fprintf(stderr, ""Usage: %s file [iterations] [packetSize]\n"", name);
        exit(1);
    }
#endif


    size_t iterations = 1;
    if (argc >= 3) {
        char* end = 0;
        iterations = strtol(argv[2], &end, 10);
        if (*end != '\0' || !iterations) {
            fprintf(stderr, ""Second argument should be number of iterations. ""
                ""The default is 1. You supplied %s\n"", argv[2]);
            exit(1);
        }
    }

    size_t packetSize = 0;
    if (argc >= 4) {
        char* end = 0;
        packetSize = strtol(argv[3], &end, 10);
        if (*end != '\0') {
            fprintf(stderr, ""Third argument should be packet size. Default is ""
                ""0, meaning to decode the entire image in one packet. You ""
                ""supplied %s\n"", argv[3]);
            exit(1);
        }
    }


    class WebPlatform : public blink::Platform {
    public:
        const unsigned char* getTraceCategoryEnabledFlag(const char*) override
        {
            return reinterpret_cast<const unsigned char *>(""nope-none-nada"");
        }
 
         void cryptographicallyRandomValues(unsigned char*, size_t) override
         {
         }
 
         void screenColorProfile(WebVector<char>* profile) override
        {
            getScreenColorProfile(profile); // Returns a whacked color profile.
        }
    };

    blink::initializeWithoutV8(new WebPlatform());


#if USE(QCMSLIB)
    ImageDecoder::qcmsOutputDeviceProfile(); // Initialize screen colorProfile.
#endif


    RefPtr<SharedBuffer> data = readFile(argv[1]);
    if (!data.get() || !data->size()) {
        fprintf(stderr, ""Error reading image data from [%s]\n"", argv[1]);
        exit(2);
    }

    data->data();


    double totalTime = 0.0;

    for (size_t i = 0; i < iterations; ++i) {
        double startTime = getCurrentTime();
        bool decoded = decodeImageData(data.get(), applyColorCorrection, packetSize);
        double elapsedTime = getCurrentTime() - startTime;
        totalTime += elapsedTime;
        if (!decoded) {
            fprintf(stderr, ""Image decode failed [%s]\n"", argv[1]);
            exit(3);
        }
    }


    double averageTime = totalTime / static_cast<double>(iterations);
    printf(""%f %f\n"", totalTime, averageTime);
    return 0;
}
",C,"            RELEASE_ASSERT_NOT_REACHED();
",,,"@@ -369,7 +369,7 @@ int main(int argc, char* argv[])
 
         void cryptographicallyRandomValues(unsigned char*, size_t) override
         {
-            // Do nothing: make blink::Platform use the default crypto-randoms.
+            RELEASE_ASSERT_NOT_REACHED();
         }
 
         void screenColorProfile(WebVector<char>* profile) override",Chrome,0d151e09e13a704e9738ea913d117df7282e6c7d,438f52c765ac1e4d170e7feed3a9024f04e170ef,1,"int main(int argc, char* argv[])
{
    char* name = argv[0];

    // If the platform supports color correction, allow it to be controlled.

    bool applyColorCorrection = false;

#if USE(QCMSLIB)
    if (argc >= 2 && strcmp(argv[1], ""--color-correct"") == 0)
        applyColorCorrection = (--argc, ++argv, true);

    if (argc < 2) {
        fprintf(stderr, ""Usage: %s [--color-correct] file [iterations] [packetSize]\n"", name);
        exit(1);
    }
#else
    if (argc < 2) {
        fprintf(stderr, ""Usage: %s file [iterations] [packetSize]\n"", name);
        exit(1);
    }
#endif

    // Control decode bench iterations and packet size.

    size_t iterations = 1;
    if (argc >= 3) {
        char* end = 0;
        iterations = strtol(argv[2], &end, 10);
        if (*end != '\0' || !iterations) {
            fprintf(stderr, ""Second argument should be number of iterations. ""
                ""The default is 1. You supplied %s\n"", argv[2]);
            exit(1);
        }
    }

    size_t packetSize = 0;
    if (argc >= 4) {
        char* end = 0;
        packetSize = strtol(argv[3], &end, 10);
        if (*end != '\0') {
            fprintf(stderr, ""Third argument should be packet size. Default is ""
                ""0, meaning to decode the entire image in one packet. You ""
                ""supplied %s\n"", argv[3]);
            exit(1);
        }
    }

    // Create a web platform without V8.

    class WebPlatform : public blink::Platform {
    public:
        const unsigned char* getTraceCategoryEnabledFlag(const char*) override
        {
            return reinterpret_cast<const unsigned char *>(""nope-none-nada"");
        }
 
         void cryptographicallyRandomValues(unsigned char*, size_t) override
         {
//flaw_line_below:
            // Do nothing: make blink::Platform use the default crypto-randoms.
//fix_flaw_line_below:
//            RELEASE_ASSERT_NOT_REACHED();
         }
 
         void screenColorProfile(WebVector<char>* profile) override
        {
            getScreenColorProfile(profile); // Returns a whacked color profile.
        }
    };

    blink::initializeWithoutV8(new WebPlatform());

    // Set image decoding Platform options.

#if USE(QCMSLIB)
    ImageDecoder::qcmsOutputDeviceProfile(); // Initialize screen colorProfile.
#endif

    // Read entire file content to data.

    RefPtr<SharedBuffer> data = readFile(argv[1]);
    if (!data.get() || !data->size()) {
        fprintf(stderr, ""Error reading image data from [%s]\n"", argv[1]);
        exit(2);
    }

    // Consolidate the SharedBuffer data segments into one, contiguous block of memory.
    data->data();

    // Image decode bench for iterations.

    double totalTime = 0.0;

    for (size_t i = 0; i < iterations; ++i) {
        double startTime = getCurrentTime();
        bool decoded = decodeImageData(data.get(), applyColorCorrection, packetSize);
        double elapsedTime = getCurrentTime() - startTime;
        totalTime += elapsedTime;
        if (!decoded) {
            fprintf(stderr, ""Image decode failed [%s]\n"", argv[1]);
            exit(3);
        }
    }

    // Results to stdout.

    double averageTime = totalTime / static_cast<double>(iterations);
    printf(""%f %f\n"", totalTime, averageTime);
    return 0;
}
"
9174,186910,,Remote,Not required,,CVE-2017-15423,https://www.cvedetails.com/cve/CVE-2017-15423/,CWE-310,Low,Partial,,,2018-08-28,5.0,Inappropriate implementation in BoringSSL SPAKE2 in Google Chrome prior to 63.0.3239.84 allowed a remote attacker to leak the low-order bits of SHA512(password) by inspecting protocol traffic.,2018-11-02,,0,https://github.com/chromium/chromium/commit/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2,a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2,"Roll src/third_party/boringssl/src 664e99a64..696c13bd6

https://boringssl.googlesource.com/boringssl/+log/664e99a6486c293728097c661332f92bf2d847c6..696c13bd6ab78011adfe7b775519c8b7cc82b604

BUG=778101

Change-Id: I8dda4f3db952597148e3c7937319584698d00e1c
Reviewed-on: https://chromium-review.googlesource.com/747941
Reviewed-by: Avi Drissman <avi@chromium.org>
Reviewed-by: David Benjamin <davidben@chromium.org>
Commit-Queue: Steven Valdez <svaldez@chromium.org>
Cr-Commit-Position: refs/heads/master@{#513774}",2,content/browser/browser_main_loop.cc,"{""sha"": ""7574d5f80ec19444322f211bc11c16f21d8f8a26"", ""filename"": ""DEPS"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/DEPS"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/DEPS"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/DEPS?ref=a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2"", ""patch"": ""@@ -100,7 +100,7 @@ vars = {\n   # Three lines of non-changing comments so that\n   # the commit queue can handle CLs rolling BoringSSL\n   # and whatever else without interference from each other.\n-  'boringssl_revision': '664e99a6486c293728097c661332f92bf2d847c6',\n+  'boringssl_revision': '696c13bd6ab78011adfe7b775519c8b7cc82b604',\n   # Three lines of non-changing comments so that\n   # the commit queue can handle CLs rolling google-toolbox-for-mac\n   # and whatever else without interference from each other.""}<_**next**_>{""sha"": ""6e6758151e1f1534655acf314c658c795c65ccf8"", ""filename"": ""content/browser/browser_main_loop.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/content/browser/browser_main_loop.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/content/browser/browser_main_loop.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/browser_main_loop.cc?ref=a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2"", ""patch"": ""@@ -920,9 +920,6 @@ int BrowserMainLoop::PreCreateThreads() {\n   for (auto origin : origins)\n     policy->AddIsolatedOrigin(origin);\n \n-  EVP_set_buggy_rsa_parser(\n-      base::FeatureList::IsEnabled(features::kBuggyRSAParser));\n-\n   return result_code_;\n }\n ""}<_**next**_>{""sha"": ""d0486ee21cb644cbe3b6c3a830e76183eb1be940"", ""filename"": ""content/public/common/content_features.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/content/public/common/content_features.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/content/public/common/content_features.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/public/common/content_features.cc?ref=a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2"", ""patch"": ""@@ -49,13 +49,6 @@ const base::Feature kBrotliEncoding{\""brotli-encoding\"",\n const base::Feature kBrowserSideNavigation{\""browser-side-navigation\"",\n                                            base::FEATURE_ENABLED_BY_DEFAULT};\n \n-// Toggles whether the buggy RSA parser is used.\n-//\n-// TODO(davidben): Remove this after Chrome 61 is released to\n-// stable. https://crbug.com/735616.\n-const base::Feature kBuggyRSAParser{\""BuggyRSAParser\"",\n-                                    base::FEATURE_DISABLED_BY_DEFAULT};\n-\n // If Canvas2D Image Chromium is allowed, this feature controls whether it is\n // enabled.\n const base::Feature kCanvas2DImageChromium {""}<_**next**_>{""sha"": ""dcaa1f64c3a15a7512f71013669103c1232bbbd0"", ""filename"": ""content/public/common/content_features.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/content/public/common/content_features.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/content/public/common/content_features.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/public/common/content_features.h?ref=a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2"", ""patch"": ""@@ -25,7 +25,6 @@ CONTENT_EXPORT extern const base::Feature kBlockCredentialedSubresources;\n CONTENT_EXPORT extern const base::Feature kDataSaverHoldback;\n CONTENT_EXPORT extern const base::Feature kBrotliEncoding;\n CONTENT_EXPORT extern const base::Feature kBrowserSideNavigation;\n-CONTENT_EXPORT extern const base::Feature kBuggyRSAParser;\n CONTENT_EXPORT extern const base::Feature kCanvas2DImageChromium;\n CONTENT_EXPORT extern const base::Feature kCheckerImaging;\n CONTENT_EXPORT extern const base::Feature kCompositeOpaqueFixedPosition;""}<_**next**_>{""sha"": ""58fd6b523dcc08d643ef8b813714cf4a0d0a64d7"", ""filename"": ""content/renderer/render_thread_impl.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/content/renderer/render_thread_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/content/renderer/render_thread_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/render_thread_impl.cc?ref=a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2"", ""patch"": ""@@ -994,9 +994,6 @@ void RenderThreadImpl::Init(\n   if (!command_line.HasSwitch(switches::kSingleProcess))\n     base::SequencedWorkerPool::EnableForProcess();\n \n-  EVP_set_buggy_rsa_parser(\n-      base::FeatureList::IsEnabled(features::kBuggyRSAParser));\n-\n   GetConnector()->BindInterface(mojom::kBrowserServiceName,\n                                 mojo::MakeRequest(&frame_sink_provider_));\n ""}<_**next**_>{""sha"": ""dcf3bbe994f98f94429ab9cc018d3df4c47a6cbd"", ""filename"": ""third_party/boringssl/BUILD.generated.gni"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/third_party/boringssl/BUILD.generated.gni"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/third_party/boringssl/BUILD.generated.gni"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/boringssl/BUILD.generated.gni?ref=a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2"", ""patch"": ""@@ -537,6 +537,8 @@ crypto_sources_win_x86_64 = [\n ]\n \n fuzzers = [\n+  \""bn_div\"",\n+  \""bn_mod_exp\"",\n   \""cert\"",\n   \""client\"",\n   \""dtls_client\"",""}<_**next**_>{""sha"": ""44d653d2817ea1b49cfd0659f3eace1eb636288b"", ""filename"": ""third_party/boringssl/BUILD.generated_tests.gni"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/third_party/boringssl/BUILD.generated_tests.gni"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/third_party/boringssl/BUILD.generated_tests.gni"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/boringssl/BUILD.generated_tests.gni?ref=a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2"", ""patch"": ""@@ -23,6 +23,7 @@ crypto_test_sources = [\n   \""src/crypto/asn1/asn1_test.cc\"",\n   \""src/crypto/base64/base64_test.cc\"",\n   \""src/crypto/bio/bio_test.cc\"",\n+  \""src/crypto/buf/buf_test.cc\"",\n   \""src/crypto/bytestring/bytestring_test.cc\"",\n   \""src/crypto/chacha/chacha_test.cc\"",\n   \""src/crypto/cipher_extra/aead_test.cc\"",""}","int BrowserMainLoop::PreCreateThreads() {

  if (parts_) {
    TRACE_EVENT0(""startup"",
        ""BrowserMainLoop::CreateThreads:PreCreateThreads"");

    result_code_ = parts_->PreCreateThreads();
  }

  if (!base::SequencedWorkerPool::IsEnabled())
    base::SequencedWorkerPool::EnableForProcess();

  const base::CommandLine* command_line =
      base::CommandLine::ForCurrentProcess();
  base::FeatureList::InitializeInstance(
      command_line->GetSwitchValueASCII(switches::kEnableFeatures),
      command_line->GetSwitchValueASCII(switches::kDisableFeatures));

  InitializeMemoryManagementComponent();

#if defined(OS_MACOSX)
  if (base::CommandLine::InitializedForCurrentProcess() &&
      base::CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kEnableHeapProfiling)) {
    base::allocator::PeriodicallyShimNewMallocZones();
  }
#endif

#if BUILDFLAG(ENABLE_PLUGINS)
  {
    TRACE_EVENT0(""startup"", ""BrowserMainLoop::CreateThreads:PluginService"");
    PluginService::GetInstance()->Init();
  }
#endif

#if BUILDFLAG(ENABLE_LIBRARY_CDMS)
  CdmRegistry::GetInstance()->Init();
#endif

#if defined(OS_MACOSX)
  ui::WindowResizeHelperMac::Get()->Init(base::ThreadTaskRunnerHandle::Get());
#endif

  GpuDataManagerImpl* gpu_data_manager = GpuDataManagerImpl::GetInstance();

#if defined(USE_X11)
  gpu_data_manager_visual_proxy_.reset(
      new internal::GpuDataManagerVisualProxy(gpu_data_manager));
#endif

  gpu_data_manager->Initialize();

#if !defined(GOOGLE_CHROME_BUILD) || defined(OS_ANDROID)
  if (parsed_command_line_.HasSwitch(switches::kSingleProcess))
    RenderProcessHost::SetRunRendererInProcess(true);
#endif

  std::vector<url::Origin> origins =
      GetContentClient()->browser()->GetOriginsRequiringDedicatedProcess();
  ChildProcessSecurityPolicyImpl* policy =
      ChildProcessSecurityPolicyImpl::GetInstance();
   for (auto origin : origins)
     policy->AddIsolatedOrigin(origin);
 
   return result_code_;
 }
","int BrowserMainLoop::PreCreateThreads() {

  if (parts_) {
    TRACE_EVENT0(""startup"",
        ""BrowserMainLoop::CreateThreads:PreCreateThreads"");

    result_code_ = parts_->PreCreateThreads();
  }

  if (!base::SequencedWorkerPool::IsEnabled())
    base::SequencedWorkerPool::EnableForProcess();

  const base::CommandLine* command_line =
      base::CommandLine::ForCurrentProcess();
  base::FeatureList::InitializeInstance(
      command_line->GetSwitchValueASCII(switches::kEnableFeatures),
      command_line->GetSwitchValueASCII(switches::kDisableFeatures));

  InitializeMemoryManagementComponent();

#if defined(OS_MACOSX)
  if (base::CommandLine::InitializedForCurrentProcess() &&
      base::CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kEnableHeapProfiling)) {
    base::allocator::PeriodicallyShimNewMallocZones();
  }
#endif

#if BUILDFLAG(ENABLE_PLUGINS)
  {
    TRACE_EVENT0(""startup"", ""BrowserMainLoop::CreateThreads:PluginService"");
    PluginService::GetInstance()->Init();
  }
#endif

#if BUILDFLAG(ENABLE_LIBRARY_CDMS)
  CdmRegistry::GetInstance()->Init();
#endif

#if defined(OS_MACOSX)
  ui::WindowResizeHelperMac::Get()->Init(base::ThreadTaskRunnerHandle::Get());
#endif

  GpuDataManagerImpl* gpu_data_manager = GpuDataManagerImpl::GetInstance();

#if defined(USE_X11)
  gpu_data_manager_visual_proxy_.reset(
      new internal::GpuDataManagerVisualProxy(gpu_data_manager));
#endif

  gpu_data_manager->Initialize();

#if !defined(GOOGLE_CHROME_BUILD) || defined(OS_ANDROID)
  if (parsed_command_line_.HasSwitch(switches::kSingleProcess))
    RenderProcessHost::SetRunRendererInProcess(true);
#endif

  std::vector<url::Origin> origins =
      GetContentClient()->browser()->GetOriginsRequiringDedicatedProcess();
  ChildProcessSecurityPolicyImpl* policy =
      ChildProcessSecurityPolicyImpl::GetInstance();
   for (auto origin : origins)
     policy->AddIsolatedOrigin(origin);
 
  EVP_set_buggy_rsa_parser(
      base::FeatureList::IsEnabled(features::kBuggyRSAParser));
   return result_code_;
 }
",C,,"  EVP_set_buggy_rsa_parser(
      base::FeatureList::IsEnabled(features::kBuggyRSAParser));
",,"@@ -920,9 +920,6 @@ int BrowserMainLoop::PreCreateThreads() {
   for (auto origin : origins)
     policy->AddIsolatedOrigin(origin);
 
-  EVP_set_buggy_rsa_parser(
-      base::FeatureList::IsEnabled(features::kBuggyRSAParser));
-
   return result_code_;
 }
 ",Chrome,a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2,0fe9417f1d39231fa41c41d8eeaa1afde8d364a3,1,"int BrowserMainLoop::PreCreateThreads() {
  // SequencedWorkerPool shouldn't be enabled yet. It should be enabled below by
  // either |parts_|->PreCreateThreads() or
  // base::SequencedWorkerPool::EnableForProcess().
  // TODO(fdoray): Uncomment this line.
  // DCHECK(!base::SequencedWorkerPool::IsEnabled());

  if (parts_) {
    TRACE_EVENT0(""startup"",
        ""BrowserMainLoop::CreateThreads:PreCreateThreads"");

    result_code_ = parts_->PreCreateThreads();
  }

  // Enable SequencedWorkerPool if |parts_|->PreCreateThreads() hasn't enabled
  // it.
  // TODO(fdoray): Remove this once the SequencedWorkerPool to TaskScheduler
  // redirection experiment concludes https://crbug.com/622400.
  if (!base::SequencedWorkerPool::IsEnabled())
    base::SequencedWorkerPool::EnableForProcess();

  const base::CommandLine* command_line =
      base::CommandLine::ForCurrentProcess();
  // Note that we do not initialize a new FeatureList when calling this for
  // the second time.
  base::FeatureList::InitializeInstance(
      command_line->GetSwitchValueASCII(switches::kEnableFeatures),
      command_line->GetSwitchValueASCII(switches::kDisableFeatures));

  InitializeMemoryManagementComponent();

#if defined(OS_MACOSX)
  if (base::CommandLine::InitializedForCurrentProcess() &&
      base::CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kEnableHeapProfiling)) {
    base::allocator::PeriodicallyShimNewMallocZones();
  }
#endif

#if BUILDFLAG(ENABLE_PLUGINS)
  // Prior to any processing happening on the IO thread, we create the
  // plugin service as it is predominantly used from the IO thread,
  // but must be created on the main thread. The service ctor is
  // inexpensive and does not invoke the io_thread() accessor.
  {
    TRACE_EVENT0(""startup"", ""BrowserMainLoop::CreateThreads:PluginService"");
    PluginService::GetInstance()->Init();
  }
#endif

#if BUILDFLAG(ENABLE_LIBRARY_CDMS)
  // Prior to any processing happening on the IO thread, we create the
  // CDM service as it is predominantly used from the IO thread. This must
  // be called on the main thread since it involves file path checks.
  CdmRegistry::GetInstance()->Init();
#endif

#if defined(OS_MACOSX)
  // The WindowResizeHelper allows the UI thread to wait on specific renderer
  // and GPU messages from the IO thread. Initializing it before the IO thread
  // starts ensures the affected IO thread messages always have somewhere to go.
  ui::WindowResizeHelperMac::Get()->Init(base::ThreadTaskRunnerHandle::Get());
#endif

  GpuDataManagerImpl* gpu_data_manager = GpuDataManagerImpl::GetInstance();

#if defined(USE_X11)
  // GpuDataManagerVisualProxy() just adds itself as an observer of
  // |gpu_data_manager|, which is safe to do before Initialize().
  gpu_data_manager_visual_proxy_.reset(
      new internal::GpuDataManagerVisualProxy(gpu_data_manager));
#endif

  // 1) Need to initialize in-process GpuDataManager before creating threads.
  // It's unsafe to append the gpu command line switches to the global
  // CommandLine::ForCurrentProcess object after threads are created.
  // 2) Must be after parts_->PreCreateThreads to pick up chrome://flags.
  gpu_data_manager->Initialize();

#if !defined(GOOGLE_CHROME_BUILD) || defined(OS_ANDROID)
  // Single-process is an unsupported and not fully tested mode, so
  // don't enable it for official Chrome builds (except on Android).
  if (parsed_command_line_.HasSwitch(switches::kSingleProcess))
    RenderProcessHost::SetRunRendererInProcess(true);
#endif

  // Initialize origins that are whitelisted for process isolation.  Must be
  // done after base::FeatureList is initialized, but before any navigations
  // can happen.
  std::vector<url::Origin> origins =
      GetContentClient()->browser()->GetOriginsRequiringDedicatedProcess();
  ChildProcessSecurityPolicyImpl* policy =
      ChildProcessSecurityPolicyImpl::GetInstance();
   for (auto origin : origins)
     policy->AddIsolatedOrigin(origin);
 
//flaw_line_below:
  EVP_set_buggy_rsa_parser(
//flaw_line_below:
      base::FeatureList::IsEnabled(features::kBuggyRSAParser));
//flaw_line_below:

   return result_code_;
 }
"
9175,186911,,Remote,Not required,,CVE-2017-15423,https://www.cvedetails.com/cve/CVE-2017-15423/,CWE-310,Low,Partial,,,2018-08-28,5.0,Inappropriate implementation in BoringSSL SPAKE2 in Google Chrome prior to 63.0.3239.84 allowed a remote attacker to leak the low-order bits of SHA512(password) by inspecting protocol traffic.,2018-11-02,,0,https://github.com/chromium/chromium/commit/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2,a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2,"Roll src/third_party/boringssl/src 664e99a64..696c13bd6

https://boringssl.googlesource.com/boringssl/+log/664e99a6486c293728097c661332f92bf2d847c6..696c13bd6ab78011adfe7b775519c8b7cc82b604

BUG=778101

Change-Id: I8dda4f3db952597148e3c7937319584698d00e1c
Reviewed-on: https://chromium-review.googlesource.com/747941
Reviewed-by: Avi Drissman <avi@chromium.org>
Reviewed-by: David Benjamin <davidben@chromium.org>
Commit-Queue: Steven Valdez <svaldez@chromium.org>
Cr-Commit-Position: refs/heads/master@{#513774}",2,content/renderer/render_thread_impl.cc,"{""sha"": ""7574d5f80ec19444322f211bc11c16f21d8f8a26"", ""filename"": ""DEPS"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/DEPS"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/DEPS"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/DEPS?ref=a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2"", ""patch"": ""@@ -100,7 +100,7 @@ vars = {\n   # Three lines of non-changing comments so that\n   # the commit queue can handle CLs rolling BoringSSL\n   # and whatever else without interference from each other.\n-  'boringssl_revision': '664e99a6486c293728097c661332f92bf2d847c6',\n+  'boringssl_revision': '696c13bd6ab78011adfe7b775519c8b7cc82b604',\n   # Three lines of non-changing comments so that\n   # the commit queue can handle CLs rolling google-toolbox-for-mac\n   # and whatever else without interference from each other.""}<_**next**_>{""sha"": ""6e6758151e1f1534655acf314c658c795c65ccf8"", ""filename"": ""content/browser/browser_main_loop.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/content/browser/browser_main_loop.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/content/browser/browser_main_loop.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/browser_main_loop.cc?ref=a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2"", ""patch"": ""@@ -920,9 +920,6 @@ int BrowserMainLoop::PreCreateThreads() {\n   for (auto origin : origins)\n     policy->AddIsolatedOrigin(origin);\n \n-  EVP_set_buggy_rsa_parser(\n-      base::FeatureList::IsEnabled(features::kBuggyRSAParser));\n-\n   return result_code_;\n }\n ""}<_**next**_>{""sha"": ""d0486ee21cb644cbe3b6c3a830e76183eb1be940"", ""filename"": ""content/public/common/content_features.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 7, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/content/public/common/content_features.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/content/public/common/content_features.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/public/common/content_features.cc?ref=a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2"", ""patch"": ""@@ -49,13 +49,6 @@ const base::Feature kBrotliEncoding{\""brotli-encoding\"",\n const base::Feature kBrowserSideNavigation{\""browser-side-navigation\"",\n                                            base::FEATURE_ENABLED_BY_DEFAULT};\n \n-// Toggles whether the buggy RSA parser is used.\n-//\n-// TODO(davidben): Remove this after Chrome 61 is released to\n-// stable. https://crbug.com/735616.\n-const base::Feature kBuggyRSAParser{\""BuggyRSAParser\"",\n-                                    base::FEATURE_DISABLED_BY_DEFAULT};\n-\n // If Canvas2D Image Chromium is allowed, this feature controls whether it is\n // enabled.\n const base::Feature kCanvas2DImageChromium {""}<_**next**_>{""sha"": ""dcaa1f64c3a15a7512f71013669103c1232bbbd0"", ""filename"": ""content/public/common/content_features.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/content/public/common/content_features.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/content/public/common/content_features.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/public/common/content_features.h?ref=a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2"", ""patch"": ""@@ -25,7 +25,6 @@ CONTENT_EXPORT extern const base::Feature kBlockCredentialedSubresources;\n CONTENT_EXPORT extern const base::Feature kDataSaverHoldback;\n CONTENT_EXPORT extern const base::Feature kBrotliEncoding;\n CONTENT_EXPORT extern const base::Feature kBrowserSideNavigation;\n-CONTENT_EXPORT extern const base::Feature kBuggyRSAParser;\n CONTENT_EXPORT extern const base::Feature kCanvas2DImageChromium;\n CONTENT_EXPORT extern const base::Feature kCheckerImaging;\n CONTENT_EXPORT extern const base::Feature kCompositeOpaqueFixedPosition;""}<_**next**_>{""sha"": ""58fd6b523dcc08d643ef8b813714cf4a0d0a64d7"", ""filename"": ""content/renderer/render_thread_impl.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/content/renderer/render_thread_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/content/renderer/render_thread_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/render_thread_impl.cc?ref=a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2"", ""patch"": ""@@ -994,9 +994,6 @@ void RenderThreadImpl::Init(\n   if (!command_line.HasSwitch(switches::kSingleProcess))\n     base::SequencedWorkerPool::EnableForProcess();\n \n-  EVP_set_buggy_rsa_parser(\n-      base::FeatureList::IsEnabled(features::kBuggyRSAParser));\n-\n   GetConnector()->BindInterface(mojom::kBrowserServiceName,\n                                 mojo::MakeRequest(&frame_sink_provider_));\n ""}<_**next**_>{""sha"": ""dcf3bbe994f98f94429ab9cc018d3df4c47a6cbd"", ""filename"": ""third_party/boringssl/BUILD.generated.gni"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/third_party/boringssl/BUILD.generated.gni"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/third_party/boringssl/BUILD.generated.gni"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/boringssl/BUILD.generated.gni?ref=a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2"", ""patch"": ""@@ -537,6 +537,8 @@ crypto_sources_win_x86_64 = [\n ]\n \n fuzzers = [\n+  \""bn_div\"",\n+  \""bn_mod_exp\"",\n   \""cert\"",\n   \""client\"",\n   \""dtls_client\"",""}<_**next**_>{""sha"": ""44d653d2817ea1b49cfd0659f3eace1eb636288b"", ""filename"": ""third_party/boringssl/BUILD.generated_tests.gni"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/third_party/boringssl/BUILD.generated_tests.gni"", ""raw_url"": ""https://github.com/chromium/chromium/raw/a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2/third_party/boringssl/BUILD.generated_tests.gni"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/boringssl/BUILD.generated_tests.gni?ref=a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2"", ""patch"": ""@@ -23,6 +23,7 @@ crypto_test_sources = [\n   \""src/crypto/asn1/asn1_test.cc\"",\n   \""src/crypto/base64/base64_test.cc\"",\n   \""src/crypto/bio/bio_test.cc\"",\n+  \""src/crypto/buf/buf_test.cc\"",\n   \""src/crypto/bytestring/bytestring_test.cc\"",\n   \""src/crypto/chacha/chacha_test.cc\"",\n   \""src/crypto/cipher_extra/aead_test.cc\"",""}","void RenderThreadImpl::Init(
    const scoped_refptr<base::SingleThreadTaskRunner>& resource_task_queue) {
  TRACE_EVENT0(""startup"", ""RenderThreadImpl::Init"");

  base::trace_event::TraceLog::GetInstance()->SetThreadSortIndex(
      base::PlatformThread::CurrentId(),
      kTraceEventRendererMainThreadSortIndex);

#if BUILDFLAG(USE_EXTERNAL_POPUP_MENU)
  blink::WebView::SetUseExternalPopupMenus(true);
#endif

  lazy_tls.Pointer()->Set(this);

  ChildProcess::current()->set_main_thread(this);

  metrics::InitializeSingleSampleMetricsFactory(
      base::BindRepeating(&CreateSingleSampleMetricsProvider,
                          message_loop()->task_runner(), GetConnector()));

  gpu_ = ui::Gpu::Create(
      GetConnector(),
      IsRunningInMash() ? ui::mojom::kServiceName : mojom::kBrowserServiceName,
      GetIOTaskRunner());

  viz::mojom::SharedBitmapAllocationNotifierPtr
      shared_bitmap_allocation_notifier_ptr;
  GetConnector()->BindInterface(
      mojom::kBrowserServiceName,
      mojo::MakeRequest(&shared_bitmap_allocation_notifier_ptr));
  shared_bitmap_manager_ = std::make_unique<viz::ClientSharedBitmapManager>(
      viz::mojom::ThreadSafeSharedBitmapAllocationNotifierPtr::Create(
          shared_bitmap_allocation_notifier_ptr.PassInterface(),
          GetChannel()->ipc_task_runner_refptr()));

  notification_dispatcher_ =
      new NotificationDispatcher(thread_safe_sender());
  AddFilter(notification_dispatcher_->GetFilter());

  resource_dispatcher_.reset(new ResourceDispatcher(
      this, message_loop()->task_runner()));
  resource_message_filter_ =
      new ChildResourceMessageFilter(resource_dispatcher_.get());
  AddFilter(resource_message_filter_.get());
  quota_message_filter_ =
      new QuotaMessageFilter(thread_safe_sender());
  quota_dispatcher_.reset(new QuotaDispatcher(thread_safe_sender(),
                                              quota_message_filter_.get()));

  AddFilter(quota_message_filter_->GetFilter());

  auto registry = std::make_unique<service_manager::BinderRegistry>();
  BlinkInterfaceRegistryImpl interface_registry(registry->GetWeakPtr());

  InitializeWebKit(resource_task_queue, &interface_registry);
  blink_initialized_time_ = base::TimeTicks::Now();

  webkit_shared_timer_suspended_ = false;
  widget_count_ = 0;
  hidden_widget_count_ = 0;
  idle_notification_delay_in_ms_ = kInitialIdleHandlerDelayMs;
  idle_notifications_to_skip_ = 0;

  appcache_dispatcher_.reset(
      new AppCacheDispatcher(Get(), new AppCacheFrontendImpl()));
  dom_storage_dispatcher_.reset(new DomStorageDispatcher());
  main_thread_indexed_db_dispatcher_.reset(new IndexedDBDispatcher());
  main_thread_cache_storage_dispatcher_.reset(
      new CacheStorageDispatcher(thread_safe_sender()));
  file_system_dispatcher_.reset(new FileSystemDispatcher());

  resource_dispatch_throttler_.reset(new ResourceDispatchThrottler(
      static_cast<RenderThread*>(this), renderer_scheduler_.get(),
      base::TimeDelta::FromSecondsD(kThrottledResourceRequestFlushPeriodS),
      kMaxResourceRequestsPerFlushWhenThrottled));
  resource_dispatcher_->set_message_sender(resource_dispatch_throttler_.get());

  blob_message_filter_ = new BlobMessageFilter(GetFileThreadTaskRunner());
  AddFilter(blob_message_filter_.get());
  vc_manager_.reset(new VideoCaptureImplManager());

  browser_plugin_manager_.reset(new BrowserPluginManager());
  AddObserver(browser_plugin_manager_.get());

#if BUILDFLAG(ENABLE_WEBRTC)
  peer_connection_tracker_.reset(new PeerConnectionTracker());
  AddObserver(peer_connection_tracker_.get());

  p2p_socket_dispatcher_ = new P2PSocketDispatcher(GetIOTaskRunner().get());
  AddFilter(p2p_socket_dispatcher_.get());

  peer_connection_factory_.reset(
      new PeerConnectionDependencyFactory(p2p_socket_dispatcher_.get()));

  aec_dump_message_filter_ = new AecDumpMessageFilter(
      GetIOTaskRunner(), message_loop()->task_runner());

  AddFilter(aec_dump_message_filter_.get());

#endif  // BUILDFLAG(ENABLE_WEBRTC)

  audio_input_message_filter_ = new AudioInputMessageFilter(GetIOTaskRunner());
  AddFilter(audio_input_message_filter_.get());

  scoped_refptr<AudioMessageFilter> audio_message_filter;
  if (!base::FeatureList::IsEnabled(
          features::kUseMojoAudioOutputStreamFactory)) {
    audio_message_filter =
        base::MakeRefCounted<AudioMessageFilter>(GetIOTaskRunner());
    AddFilter(audio_message_filter.get());
  }

  audio_ipc_factory_.emplace(std::move(audio_message_filter),
                             GetIOTaskRunner());

  midi_message_filter_ = new MidiMessageFilter(GetIOTaskRunner());
  AddFilter(midi_message_filter_.get());

  AddFilter((new CacheStorageMessageFilter(thread_safe_sender()))->GetFilter());

  AddFilter((new ServiceWorkerContextMessageFilter())->GetFilter());


#if defined(USE_AURA)
  if (IsRunningInMash()) {
    CreateRenderWidgetWindowTreeClientFactory(GetServiceManagerConnection());
  }
#endif

  registry->AddInterface(base::Bind(&SharedWorkerFactoryImpl::Create),
                         base::ThreadTaskRunnerHandle::Get());
  GetServiceManagerConnection()->AddConnectionFilter(
      std::make_unique<SimpleConnectionFilter>(std::move(registry)));

  {
    auto registry_with_source_info =
        std::make_unique<service_manager::BinderRegistryWithArgs<
            const service_manager::BindSourceInfo&>>();
    registry_with_source_info->AddInterface(
        base::Bind(&CreateFrameFactory), base::ThreadTaskRunnerHandle::Get());
    GetServiceManagerConnection()->AddConnectionFilter(
        std::make_unique<SimpleConnectionFilterWithSourceInfo>(
            std::move(registry_with_source_info)));
  }

  GetContentClient()->renderer()->RenderThreadStarted();

  StartServiceManagerConnection();

  GetAssociatedInterfaceRegistry()->AddInterface(
      base::Bind(&RenderThreadImpl::OnRendererInterfaceRequest,
                 base::Unretained(this)));

  InitSkiaEventTracer();
  base::trace_event::MemoryDumpManager::GetInstance()->RegisterDumpProvider(
      skia::SkiaMemoryDumpProvider::GetInstance(), ""Skia"", nullptr);

  const base::CommandLine& command_line =
      *base::CommandLine::ForCurrentProcess();

#if defined(ENABLE_IPC_FUZZER)
  if (command_line.HasSwitch(switches::kIpcDumpDirectory)) {
    base::FilePath dump_directory =
        command_line.GetSwitchValuePath(switches::kIpcDumpDirectory);
    IPC::ChannelProxy::OutgoingMessageFilter* filter =
        LoadExternalIPCDumper(dump_directory);
    GetChannel()->set_outgoing_message_filter(filter);
  }
#endif

  cc::SetClientNameForMetrics(""Renderer"");

  is_threaded_animation_enabled_ =
      !command_line.HasSwitch(cc::switches::kDisableThreadedAnimation);

  is_zero_copy_enabled_ = command_line.HasSwitch(switches::kEnableZeroCopy);
  is_partial_raster_enabled_ =
      !command_line.HasSwitch(switches::kDisablePartialRaster);
  is_gpu_memory_buffer_compositor_resources_enabled_ = command_line.HasSwitch(
      switches::kEnableGpuMemoryBufferCompositorResources);

#if defined(OS_MACOSX)
  is_elastic_overscroll_enabled_ = true;
#else
  is_elastic_overscroll_enabled_ = false;
#endif

  std::string image_texture_target_string =
      command_line.GetSwitchValueASCII(switches::kContentImageTextureTarget);
  buffer_to_texture_target_map_ =
      viz::StringToBufferToTextureTargetMap(image_texture_target_string);

  if (command_line.HasSwitch(switches::kDisableLCDText)) {
    is_lcd_text_enabled_ = false;
  } else if (command_line.HasSwitch(switches::kEnableLCDText)) {
    is_lcd_text_enabled_ = true;
  } else {
#if defined(OS_ANDROID)
    is_lcd_text_enabled_ = false;
#else
    is_lcd_text_enabled_ = true;
#endif
  }

  if (command_line.HasSwitch(switches::kDisableGpuCompositing))
    is_gpu_compositing_disabled_ = true;

  is_gpu_rasterization_forced_ =
      command_line.HasSwitch(switches::kForceGpuRasterization);
  is_async_worker_context_enabled_ =
      command_line.HasSwitch(switches::kEnableGpuAsyncWorkerContext);

  if (command_line.HasSwitch(switches::kGpuRasterizationMSAASampleCount)) {
    std::string string_value = command_line.GetSwitchValueASCII(
        switches::kGpuRasterizationMSAASampleCount);
    bool parsed_msaa_sample_count =
        base::StringToInt(string_value, &gpu_rasterization_msaa_sample_count_);
    DCHECK(parsed_msaa_sample_count) << string_value;
    DCHECK_GE(gpu_rasterization_msaa_sample_count_, 0);
  } else {
    gpu_rasterization_msaa_sample_count_ = -1;
  }

  if (command_line.HasSwitch(switches::kDisableDistanceFieldText)) {
    is_distance_field_text_enabled_ = false;
  } else if (command_line.HasSwitch(switches::kEnableDistanceFieldText)) {
    is_distance_field_text_enabled_ = true;
  } else {
    is_distance_field_text_enabled_ = false;
  }

  WebRuntimeFeatures::EnableCompositorImageAnimations(
      command_line.HasSwitch(switches::kEnableCompositorImageAnimations));

  media::InitializeMediaLibrary();

#if defined(OS_ANDROID)
  if (!command_line.HasSwitch(switches::kDisableAcceleratedVideoDecode) &&
      media::MediaCodecUtil::IsMediaCodecAvailable()) {
    media::EnablePlatformDecoderSupport();
  }
#endif

  memory_pressure_listener_.reset(new base::MemoryPressureListener(
      base::Bind(&RenderThreadImpl::OnMemoryPressure, base::Unretained(this)),
      base::Bind(&RenderThreadImpl::OnSyncMemoryPressure,
                 base::Unretained(this))));

  if (base::FeatureList::IsEnabled(features::kMemoryCoordinator)) {
    base::MemoryPressureListener::SetNotificationsSuppressed(true);

    mojom::MemoryCoordinatorHandlePtr parent_coordinator;
    GetConnector()->BindInterface(mojom::kBrowserServiceName,
                                  mojo::MakeRequest(&parent_coordinator));
    memory_coordinator_ = CreateChildMemoryCoordinator(
        std::move(parent_coordinator), this);
  }

  int num_raster_threads = 0;
  std::string string_value =
      command_line.GetSwitchValueASCII(switches::kNumRasterThreads);
  bool parsed_num_raster_threads =
      base::StringToInt(string_value, &num_raster_threads);
  DCHECK(parsed_num_raster_threads) << string_value;
  DCHECK_GT(num_raster_threads, 0);

  categorized_worker_pool_->Start(num_raster_threads);

  discardable_memory::mojom::DiscardableSharedMemoryManagerPtr manager_ptr;
  if (IsRunningInMash()) {
#if defined(USE_AURA)
    GetServiceManagerConnection()->GetConnector()->BindInterface(
        ui::mojom::kServiceName, &manager_ptr);
#else
    NOTREACHED();
#endif
  } else {
    ChildThread::Get()->GetConnector()->BindInterface(
        mojom::kBrowserServiceName, mojo::MakeRequest(&manager_ptr));
  }

  discardable_shared_memory_manager_ = std::make_unique<
      discardable_memory::ClientDiscardableSharedMemoryManager>(
      std::move(manager_ptr), GetIOTaskRunner());

  base::DiscardableMemoryAllocator::SetInstance(
      discardable_shared_memory_manager_.get());

  GetConnector()->BindInterface(mojom::kBrowserServiceName,
                                mojo::MakeRequest(&storage_partition_service_));

#if defined(OS_LINUX)
  ChildProcess::current()->SetIOThreadPriority(base::ThreadPriority::DISPLAY);
  ChildThreadImpl::current()->SetThreadPriority(
      categorized_worker_pool_->background_worker_thread_id(),
      base::ThreadPriority::BACKGROUND);
#endif

  process_foregrounded_count_ = 0;
  needs_to_record_first_active_paint_ = false;
  was_backgrounded_time_ = base::TimeTicks::Min();

  base::MemoryCoordinatorClientRegistry::GetInstance()->Register(this);

   if (!command_line.HasSwitch(switches::kSingleProcess))
     base::SequencedWorkerPool::EnableForProcess();
 
   GetConnector()->BindInterface(mojom::kBrowserServiceName,
                                 mojo::MakeRequest(&frame_sink_provider_));
 
  if (!is_gpu_compositing_disabled_) {
    GetConnector()->BindInterface(
        mojom::kBrowserServiceName,
        mojo::MakeRequest(&compositing_mode_reporter_));

    viz::mojom::CompositingModeWatcherPtr watcher_ptr;
    compositing_mode_watcher_binding_.Bind(mojo::MakeRequest(&watcher_ptr));
    compositing_mode_reporter_->AddCompositingModeWatcher(
        std::move(watcher_ptr));
  }
}
","void RenderThreadImpl::Init(
    const scoped_refptr<base::SingleThreadTaskRunner>& resource_task_queue) {
  TRACE_EVENT0(""startup"", ""RenderThreadImpl::Init"");

  base::trace_event::TraceLog::GetInstance()->SetThreadSortIndex(
      base::PlatformThread::CurrentId(),
      kTraceEventRendererMainThreadSortIndex);

#if BUILDFLAG(USE_EXTERNAL_POPUP_MENU)
  blink::WebView::SetUseExternalPopupMenus(true);
#endif

  lazy_tls.Pointer()->Set(this);

  ChildProcess::current()->set_main_thread(this);

  metrics::InitializeSingleSampleMetricsFactory(
      base::BindRepeating(&CreateSingleSampleMetricsProvider,
                          message_loop()->task_runner(), GetConnector()));

  gpu_ = ui::Gpu::Create(
      GetConnector(),
      IsRunningInMash() ? ui::mojom::kServiceName : mojom::kBrowserServiceName,
      GetIOTaskRunner());

  viz::mojom::SharedBitmapAllocationNotifierPtr
      shared_bitmap_allocation_notifier_ptr;
  GetConnector()->BindInterface(
      mojom::kBrowserServiceName,
      mojo::MakeRequest(&shared_bitmap_allocation_notifier_ptr));
  shared_bitmap_manager_ = std::make_unique<viz::ClientSharedBitmapManager>(
      viz::mojom::ThreadSafeSharedBitmapAllocationNotifierPtr::Create(
          shared_bitmap_allocation_notifier_ptr.PassInterface(),
          GetChannel()->ipc_task_runner_refptr()));

  notification_dispatcher_ =
      new NotificationDispatcher(thread_safe_sender());
  AddFilter(notification_dispatcher_->GetFilter());

  resource_dispatcher_.reset(new ResourceDispatcher(
      this, message_loop()->task_runner()));
  resource_message_filter_ =
      new ChildResourceMessageFilter(resource_dispatcher_.get());
  AddFilter(resource_message_filter_.get());
  quota_message_filter_ =
      new QuotaMessageFilter(thread_safe_sender());
  quota_dispatcher_.reset(new QuotaDispatcher(thread_safe_sender(),
                                              quota_message_filter_.get()));

  AddFilter(quota_message_filter_->GetFilter());

  auto registry = std::make_unique<service_manager::BinderRegistry>();
  BlinkInterfaceRegistryImpl interface_registry(registry->GetWeakPtr());

  InitializeWebKit(resource_task_queue, &interface_registry);
  blink_initialized_time_ = base::TimeTicks::Now();

  webkit_shared_timer_suspended_ = false;
  widget_count_ = 0;
  hidden_widget_count_ = 0;
  idle_notification_delay_in_ms_ = kInitialIdleHandlerDelayMs;
  idle_notifications_to_skip_ = 0;

  appcache_dispatcher_.reset(
      new AppCacheDispatcher(Get(), new AppCacheFrontendImpl()));
  dom_storage_dispatcher_.reset(new DomStorageDispatcher());
  main_thread_indexed_db_dispatcher_.reset(new IndexedDBDispatcher());
  main_thread_cache_storage_dispatcher_.reset(
      new CacheStorageDispatcher(thread_safe_sender()));
  file_system_dispatcher_.reset(new FileSystemDispatcher());

  resource_dispatch_throttler_.reset(new ResourceDispatchThrottler(
      static_cast<RenderThread*>(this), renderer_scheduler_.get(),
      base::TimeDelta::FromSecondsD(kThrottledResourceRequestFlushPeriodS),
      kMaxResourceRequestsPerFlushWhenThrottled));
  resource_dispatcher_->set_message_sender(resource_dispatch_throttler_.get());

  blob_message_filter_ = new BlobMessageFilter(GetFileThreadTaskRunner());
  AddFilter(blob_message_filter_.get());
  vc_manager_.reset(new VideoCaptureImplManager());

  browser_plugin_manager_.reset(new BrowserPluginManager());
  AddObserver(browser_plugin_manager_.get());

#if BUILDFLAG(ENABLE_WEBRTC)
  peer_connection_tracker_.reset(new PeerConnectionTracker());
  AddObserver(peer_connection_tracker_.get());

  p2p_socket_dispatcher_ = new P2PSocketDispatcher(GetIOTaskRunner().get());
  AddFilter(p2p_socket_dispatcher_.get());

  peer_connection_factory_.reset(
      new PeerConnectionDependencyFactory(p2p_socket_dispatcher_.get()));

  aec_dump_message_filter_ = new AecDumpMessageFilter(
      GetIOTaskRunner(), message_loop()->task_runner());

  AddFilter(aec_dump_message_filter_.get());

#endif  // BUILDFLAG(ENABLE_WEBRTC)

  audio_input_message_filter_ = new AudioInputMessageFilter(GetIOTaskRunner());
  AddFilter(audio_input_message_filter_.get());

  scoped_refptr<AudioMessageFilter> audio_message_filter;
  if (!base::FeatureList::IsEnabled(
          features::kUseMojoAudioOutputStreamFactory)) {
    audio_message_filter =
        base::MakeRefCounted<AudioMessageFilter>(GetIOTaskRunner());
    AddFilter(audio_message_filter.get());
  }

  audio_ipc_factory_.emplace(std::move(audio_message_filter),
                             GetIOTaskRunner());

  midi_message_filter_ = new MidiMessageFilter(GetIOTaskRunner());
  AddFilter(midi_message_filter_.get());

  AddFilter((new CacheStorageMessageFilter(thread_safe_sender()))->GetFilter());

  AddFilter((new ServiceWorkerContextMessageFilter())->GetFilter());


#if defined(USE_AURA)
  if (IsRunningInMash()) {
    CreateRenderWidgetWindowTreeClientFactory(GetServiceManagerConnection());
  }
#endif

  registry->AddInterface(base::Bind(&SharedWorkerFactoryImpl::Create),
                         base::ThreadTaskRunnerHandle::Get());
  GetServiceManagerConnection()->AddConnectionFilter(
      std::make_unique<SimpleConnectionFilter>(std::move(registry)));

  {
    auto registry_with_source_info =
        std::make_unique<service_manager::BinderRegistryWithArgs<
            const service_manager::BindSourceInfo&>>();
    registry_with_source_info->AddInterface(
        base::Bind(&CreateFrameFactory), base::ThreadTaskRunnerHandle::Get());
    GetServiceManagerConnection()->AddConnectionFilter(
        std::make_unique<SimpleConnectionFilterWithSourceInfo>(
            std::move(registry_with_source_info)));
  }

  GetContentClient()->renderer()->RenderThreadStarted();

  StartServiceManagerConnection();

  GetAssociatedInterfaceRegistry()->AddInterface(
      base::Bind(&RenderThreadImpl::OnRendererInterfaceRequest,
                 base::Unretained(this)));

  InitSkiaEventTracer();
  base::trace_event::MemoryDumpManager::GetInstance()->RegisterDumpProvider(
      skia::SkiaMemoryDumpProvider::GetInstance(), ""Skia"", nullptr);

  const base::CommandLine& command_line =
      *base::CommandLine::ForCurrentProcess();

#if defined(ENABLE_IPC_FUZZER)
  if (command_line.HasSwitch(switches::kIpcDumpDirectory)) {
    base::FilePath dump_directory =
        command_line.GetSwitchValuePath(switches::kIpcDumpDirectory);
    IPC::ChannelProxy::OutgoingMessageFilter* filter =
        LoadExternalIPCDumper(dump_directory);
    GetChannel()->set_outgoing_message_filter(filter);
  }
#endif

  cc::SetClientNameForMetrics(""Renderer"");

  is_threaded_animation_enabled_ =
      !command_line.HasSwitch(cc::switches::kDisableThreadedAnimation);

  is_zero_copy_enabled_ = command_line.HasSwitch(switches::kEnableZeroCopy);
  is_partial_raster_enabled_ =
      !command_line.HasSwitch(switches::kDisablePartialRaster);
  is_gpu_memory_buffer_compositor_resources_enabled_ = command_line.HasSwitch(
      switches::kEnableGpuMemoryBufferCompositorResources);

#if defined(OS_MACOSX)
  is_elastic_overscroll_enabled_ = true;
#else
  is_elastic_overscroll_enabled_ = false;
#endif

  std::string image_texture_target_string =
      command_line.GetSwitchValueASCII(switches::kContentImageTextureTarget);
  buffer_to_texture_target_map_ =
      viz::StringToBufferToTextureTargetMap(image_texture_target_string);

  if (command_line.HasSwitch(switches::kDisableLCDText)) {
    is_lcd_text_enabled_ = false;
  } else if (command_line.HasSwitch(switches::kEnableLCDText)) {
    is_lcd_text_enabled_ = true;
  } else {
#if defined(OS_ANDROID)
    is_lcd_text_enabled_ = false;
#else
    is_lcd_text_enabled_ = true;
#endif
  }

  if (command_line.HasSwitch(switches::kDisableGpuCompositing))
    is_gpu_compositing_disabled_ = true;

  is_gpu_rasterization_forced_ =
      command_line.HasSwitch(switches::kForceGpuRasterization);
  is_async_worker_context_enabled_ =
      command_line.HasSwitch(switches::kEnableGpuAsyncWorkerContext);

  if (command_line.HasSwitch(switches::kGpuRasterizationMSAASampleCount)) {
    std::string string_value = command_line.GetSwitchValueASCII(
        switches::kGpuRasterizationMSAASampleCount);
    bool parsed_msaa_sample_count =
        base::StringToInt(string_value, &gpu_rasterization_msaa_sample_count_);
    DCHECK(parsed_msaa_sample_count) << string_value;
    DCHECK_GE(gpu_rasterization_msaa_sample_count_, 0);
  } else {
    gpu_rasterization_msaa_sample_count_ = -1;
  }

  if (command_line.HasSwitch(switches::kDisableDistanceFieldText)) {
    is_distance_field_text_enabled_ = false;
  } else if (command_line.HasSwitch(switches::kEnableDistanceFieldText)) {
    is_distance_field_text_enabled_ = true;
  } else {
    is_distance_field_text_enabled_ = false;
  }

  WebRuntimeFeatures::EnableCompositorImageAnimations(
      command_line.HasSwitch(switches::kEnableCompositorImageAnimations));

  media::InitializeMediaLibrary();

#if defined(OS_ANDROID)
  if (!command_line.HasSwitch(switches::kDisableAcceleratedVideoDecode) &&
      media::MediaCodecUtil::IsMediaCodecAvailable()) {
    media::EnablePlatformDecoderSupport();
  }
#endif

  memory_pressure_listener_.reset(new base::MemoryPressureListener(
      base::Bind(&RenderThreadImpl::OnMemoryPressure, base::Unretained(this)),
      base::Bind(&RenderThreadImpl::OnSyncMemoryPressure,
                 base::Unretained(this))));

  if (base::FeatureList::IsEnabled(features::kMemoryCoordinator)) {
    base::MemoryPressureListener::SetNotificationsSuppressed(true);

    mojom::MemoryCoordinatorHandlePtr parent_coordinator;
    GetConnector()->BindInterface(mojom::kBrowserServiceName,
                                  mojo::MakeRequest(&parent_coordinator));
    memory_coordinator_ = CreateChildMemoryCoordinator(
        std::move(parent_coordinator), this);
  }

  int num_raster_threads = 0;
  std::string string_value =
      command_line.GetSwitchValueASCII(switches::kNumRasterThreads);
  bool parsed_num_raster_threads =
      base::StringToInt(string_value, &num_raster_threads);
  DCHECK(parsed_num_raster_threads) << string_value;
  DCHECK_GT(num_raster_threads, 0);

  categorized_worker_pool_->Start(num_raster_threads);

  discardable_memory::mojom::DiscardableSharedMemoryManagerPtr manager_ptr;
  if (IsRunningInMash()) {
#if defined(USE_AURA)
    GetServiceManagerConnection()->GetConnector()->BindInterface(
        ui::mojom::kServiceName, &manager_ptr);
#else
    NOTREACHED();
#endif
  } else {
    ChildThread::Get()->GetConnector()->BindInterface(
        mojom::kBrowserServiceName, mojo::MakeRequest(&manager_ptr));
  }

  discardable_shared_memory_manager_ = std::make_unique<
      discardable_memory::ClientDiscardableSharedMemoryManager>(
      std::move(manager_ptr), GetIOTaskRunner());

  base::DiscardableMemoryAllocator::SetInstance(
      discardable_shared_memory_manager_.get());

  GetConnector()->BindInterface(mojom::kBrowserServiceName,
                                mojo::MakeRequest(&storage_partition_service_));

#if defined(OS_LINUX)
  ChildProcess::current()->SetIOThreadPriority(base::ThreadPriority::DISPLAY);
  ChildThreadImpl::current()->SetThreadPriority(
      categorized_worker_pool_->background_worker_thread_id(),
      base::ThreadPriority::BACKGROUND);
#endif

  process_foregrounded_count_ = 0;
  needs_to_record_first_active_paint_ = false;
  was_backgrounded_time_ = base::TimeTicks::Min();

  base::MemoryCoordinatorClientRegistry::GetInstance()->Register(this);

   if (!command_line.HasSwitch(switches::kSingleProcess))
     base::SequencedWorkerPool::EnableForProcess();
 
  EVP_set_buggy_rsa_parser(
      base::FeatureList::IsEnabled(features::kBuggyRSAParser));
   GetConnector()->BindInterface(mojom::kBrowserServiceName,
                                 mojo::MakeRequest(&frame_sink_provider_));
 
  if (!is_gpu_compositing_disabled_) {
    GetConnector()->BindInterface(
        mojom::kBrowserServiceName,
        mojo::MakeRequest(&compositing_mode_reporter_));

    viz::mojom::CompositingModeWatcherPtr watcher_ptr;
    compositing_mode_watcher_binding_.Bind(mojo::MakeRequest(&watcher_ptr));
    compositing_mode_reporter_->AddCompositingModeWatcher(
        std::move(watcher_ptr));
  }
}
",C,,"  EVP_set_buggy_rsa_parser(
      base::FeatureList::IsEnabled(features::kBuggyRSAParser));
",,"@@ -994,9 +994,6 @@ void RenderThreadImpl::Init(
   if (!command_line.HasSwitch(switches::kSingleProcess))
     base::SequencedWorkerPool::EnableForProcess();
 
-  EVP_set_buggy_rsa_parser(
-      base::FeatureList::IsEnabled(features::kBuggyRSAParser));
-
   GetConnector()->BindInterface(mojom::kBrowserServiceName,
                                 mojo::MakeRequest(&frame_sink_provider_));
 ",Chrome,a263d1cf62a9c75be6aaafdec88aacfcef1e8fd2,0fe9417f1d39231fa41c41d8eeaa1afde8d364a3,1,"void RenderThreadImpl::Init(
    const scoped_refptr<base::SingleThreadTaskRunner>& resource_task_queue) {
  TRACE_EVENT0(""startup"", ""RenderThreadImpl::Init"");

  base::trace_event::TraceLog::GetInstance()->SetThreadSortIndex(
      base::PlatformThread::CurrentId(),
      kTraceEventRendererMainThreadSortIndex);

#if BUILDFLAG(USE_EXTERNAL_POPUP_MENU)
  // On Mac and Android Java UI, the select popups are rendered by the browser.
  blink::WebView::SetUseExternalPopupMenus(true);
#endif

  lazy_tls.Pointer()->Set(this);

  // Register this object as the main thread.
  ChildProcess::current()->set_main_thread(this);

  metrics::InitializeSingleSampleMetricsFactory(
      base::BindRepeating(&CreateSingleSampleMetricsProvider,
                          message_loop()->task_runner(), GetConnector()));

  gpu_ = ui::Gpu::Create(
      GetConnector(),
      IsRunningInMash() ? ui::mojom::kServiceName : mojom::kBrowserServiceName,
      GetIOTaskRunner());

  viz::mojom::SharedBitmapAllocationNotifierPtr
      shared_bitmap_allocation_notifier_ptr;
  GetConnector()->BindInterface(
      mojom::kBrowserServiceName,
      mojo::MakeRequest(&shared_bitmap_allocation_notifier_ptr));
  shared_bitmap_manager_ = std::make_unique<viz::ClientSharedBitmapManager>(
      viz::mojom::ThreadSafeSharedBitmapAllocationNotifierPtr::Create(
          shared_bitmap_allocation_notifier_ptr.PassInterface(),
          GetChannel()->ipc_task_runner_refptr()));

  notification_dispatcher_ =
      new NotificationDispatcher(thread_safe_sender());
  AddFilter(notification_dispatcher_->GetFilter());

  resource_dispatcher_.reset(new ResourceDispatcher(
      this, message_loop()->task_runner()));
  resource_message_filter_ =
      new ChildResourceMessageFilter(resource_dispatcher_.get());
  AddFilter(resource_message_filter_.get());
  quota_message_filter_ =
      new QuotaMessageFilter(thread_safe_sender());
  quota_dispatcher_.reset(new QuotaDispatcher(thread_safe_sender(),
                                              quota_message_filter_.get()));

  AddFilter(quota_message_filter_->GetFilter());

  auto registry = std::make_unique<service_manager::BinderRegistry>();
  BlinkInterfaceRegistryImpl interface_registry(registry->GetWeakPtr());

  InitializeWebKit(resource_task_queue, &interface_registry);
  blink_initialized_time_ = base::TimeTicks::Now();

  // In single process the single process is all there is.
  webkit_shared_timer_suspended_ = false;
  widget_count_ = 0;
  hidden_widget_count_ = 0;
  idle_notification_delay_in_ms_ = kInitialIdleHandlerDelayMs;
  idle_notifications_to_skip_ = 0;

  appcache_dispatcher_.reset(
      new AppCacheDispatcher(Get(), new AppCacheFrontendImpl()));
  dom_storage_dispatcher_.reset(new DomStorageDispatcher());
  main_thread_indexed_db_dispatcher_.reset(new IndexedDBDispatcher());
  main_thread_cache_storage_dispatcher_.reset(
      new CacheStorageDispatcher(thread_safe_sender()));
  file_system_dispatcher_.reset(new FileSystemDispatcher());

  // Note: This may reorder messages from the ResourceDispatcher with respect to
  // other subsystems.
  resource_dispatch_throttler_.reset(new ResourceDispatchThrottler(
      static_cast<RenderThread*>(this), renderer_scheduler_.get(),
      base::TimeDelta::FromSecondsD(kThrottledResourceRequestFlushPeriodS),
      kMaxResourceRequestsPerFlushWhenThrottled));
  resource_dispatcher_->set_message_sender(resource_dispatch_throttler_.get());

  blob_message_filter_ = new BlobMessageFilter(GetFileThreadTaskRunner());
  AddFilter(blob_message_filter_.get());
  vc_manager_.reset(new VideoCaptureImplManager());

  browser_plugin_manager_.reset(new BrowserPluginManager());
  AddObserver(browser_plugin_manager_.get());

#if BUILDFLAG(ENABLE_WEBRTC)
  peer_connection_tracker_.reset(new PeerConnectionTracker());
  AddObserver(peer_connection_tracker_.get());

  p2p_socket_dispatcher_ = new P2PSocketDispatcher(GetIOTaskRunner().get());
  AddFilter(p2p_socket_dispatcher_.get());

  peer_connection_factory_.reset(
      new PeerConnectionDependencyFactory(p2p_socket_dispatcher_.get()));

  aec_dump_message_filter_ = new AecDumpMessageFilter(
      GetIOTaskRunner(), message_loop()->task_runner());

  AddFilter(aec_dump_message_filter_.get());

#endif  // BUILDFLAG(ENABLE_WEBRTC)

  audio_input_message_filter_ = new AudioInputMessageFilter(GetIOTaskRunner());
  AddFilter(audio_input_message_filter_.get());

  scoped_refptr<AudioMessageFilter> audio_message_filter;
  if (!base::FeatureList::IsEnabled(
          features::kUseMojoAudioOutputStreamFactory)) {
    // In case we shouldn't use mojo factories, we need to create an
    // AudioMessageFilter which |audio_ipc_factory_| can use for IPC.
    audio_message_filter =
        base::MakeRefCounted<AudioMessageFilter>(GetIOTaskRunner());
    AddFilter(audio_message_filter.get());
  }

  audio_ipc_factory_.emplace(std::move(audio_message_filter),
                             GetIOTaskRunner());

  midi_message_filter_ = new MidiMessageFilter(GetIOTaskRunner());
  AddFilter(midi_message_filter_.get());

  AddFilter((new CacheStorageMessageFilter(thread_safe_sender()))->GetFilter());

  AddFilter((new ServiceWorkerContextMessageFilter())->GetFilter());

// Register exported services:

#if defined(USE_AURA)
  if (IsRunningInMash()) {
    CreateRenderWidgetWindowTreeClientFactory(GetServiceManagerConnection());
  }
#endif

  registry->AddInterface(base::Bind(&SharedWorkerFactoryImpl::Create),
                         base::ThreadTaskRunnerHandle::Get());
  GetServiceManagerConnection()->AddConnectionFilter(
      std::make_unique<SimpleConnectionFilter>(std::move(registry)));

  {
    auto registry_with_source_info =
        std::make_unique<service_manager::BinderRegistryWithArgs<
            const service_manager::BindSourceInfo&>>();
    registry_with_source_info->AddInterface(
        base::Bind(&CreateFrameFactory), base::ThreadTaskRunnerHandle::Get());
    GetServiceManagerConnection()->AddConnectionFilter(
        std::make_unique<SimpleConnectionFilterWithSourceInfo>(
            std::move(registry_with_source_info)));
  }

  GetContentClient()->renderer()->RenderThreadStarted();

  StartServiceManagerConnection();

  GetAssociatedInterfaceRegistry()->AddInterface(
      base::Bind(&RenderThreadImpl::OnRendererInterfaceRequest,
                 base::Unretained(this)));

  InitSkiaEventTracer();
  base::trace_event::MemoryDumpManager::GetInstance()->RegisterDumpProvider(
      skia::SkiaMemoryDumpProvider::GetInstance(), ""Skia"", nullptr);

  const base::CommandLine& command_line =
      *base::CommandLine::ForCurrentProcess();

#if defined(ENABLE_IPC_FUZZER)
  if (command_line.HasSwitch(switches::kIpcDumpDirectory)) {
    base::FilePath dump_directory =
        command_line.GetSwitchValuePath(switches::kIpcDumpDirectory);
    IPC::ChannelProxy::OutgoingMessageFilter* filter =
        LoadExternalIPCDumper(dump_directory);
    GetChannel()->set_outgoing_message_filter(filter);
  }
#endif

  cc::SetClientNameForMetrics(""Renderer"");

  is_threaded_animation_enabled_ =
      !command_line.HasSwitch(cc::switches::kDisableThreadedAnimation);

  is_zero_copy_enabled_ = command_line.HasSwitch(switches::kEnableZeroCopy);
  is_partial_raster_enabled_ =
      !command_line.HasSwitch(switches::kDisablePartialRaster);
  is_gpu_memory_buffer_compositor_resources_enabled_ = command_line.HasSwitch(
      switches::kEnableGpuMemoryBufferCompositorResources);

// On macOS this value is adjusted in `UpdateScrollbarTheme()`,
// but the system default is true.
#if defined(OS_MACOSX)
  is_elastic_overscroll_enabled_ = true;
#else
  is_elastic_overscroll_enabled_ = false;
#endif

  std::string image_texture_target_string =
      command_line.GetSwitchValueASCII(switches::kContentImageTextureTarget);
  buffer_to_texture_target_map_ =
      viz::StringToBufferToTextureTargetMap(image_texture_target_string);

  if (command_line.HasSwitch(switches::kDisableLCDText)) {
    is_lcd_text_enabled_ = false;
  } else if (command_line.HasSwitch(switches::kEnableLCDText)) {
    is_lcd_text_enabled_ = true;
  } else {
#if defined(OS_ANDROID)
    is_lcd_text_enabled_ = false;
#else
    is_lcd_text_enabled_ = true;
#endif
  }

  if (command_line.HasSwitch(switches::kDisableGpuCompositing))
    is_gpu_compositing_disabled_ = true;

  is_gpu_rasterization_forced_ =
      command_line.HasSwitch(switches::kForceGpuRasterization);
  is_async_worker_context_enabled_ =
      command_line.HasSwitch(switches::kEnableGpuAsyncWorkerContext);

  if (command_line.HasSwitch(switches::kGpuRasterizationMSAASampleCount)) {
    std::string string_value = command_line.GetSwitchValueASCII(
        switches::kGpuRasterizationMSAASampleCount);
    bool parsed_msaa_sample_count =
        base::StringToInt(string_value, &gpu_rasterization_msaa_sample_count_);
    DCHECK(parsed_msaa_sample_count) << string_value;
    DCHECK_GE(gpu_rasterization_msaa_sample_count_, 0);
  } else {
    gpu_rasterization_msaa_sample_count_ = -1;
  }

  if (command_line.HasSwitch(switches::kDisableDistanceFieldText)) {
    is_distance_field_text_enabled_ = false;
  } else if (command_line.HasSwitch(switches::kEnableDistanceFieldText)) {
    is_distance_field_text_enabled_ = true;
  } else {
    is_distance_field_text_enabled_ = false;
  }

  WebRuntimeFeatures::EnableCompositorImageAnimations(
      command_line.HasSwitch(switches::kEnableCompositorImageAnimations));

  // Note that under Linux, the media library will normally already have
  // been initialized by the Zygote before this instance became a Renderer.
  media::InitializeMediaLibrary();

#if defined(OS_ANDROID)
  if (!command_line.HasSwitch(switches::kDisableAcceleratedVideoDecode) &&
      media::MediaCodecUtil::IsMediaCodecAvailable()) {
    media::EnablePlatformDecoderSupport();
  }
#endif

  memory_pressure_listener_.reset(new base::MemoryPressureListener(
      base::Bind(&RenderThreadImpl::OnMemoryPressure, base::Unretained(this)),
      base::Bind(&RenderThreadImpl::OnSyncMemoryPressure,
                 base::Unretained(this))));

  if (base::FeatureList::IsEnabled(features::kMemoryCoordinator)) {
    // Disable MemoryPressureListener when memory coordinator is enabled.
    base::MemoryPressureListener::SetNotificationsSuppressed(true);

    // TODO(bashi): Revisit how to manage the lifetime of
    // ChildMemoryCoordinatorImpl.
    // https://codereview.chromium.org/2094583002/#msg52
    mojom::MemoryCoordinatorHandlePtr parent_coordinator;
    GetConnector()->BindInterface(mojom::kBrowserServiceName,
                                  mojo::MakeRequest(&parent_coordinator));
    memory_coordinator_ = CreateChildMemoryCoordinator(
        std::move(parent_coordinator), this);
  }

  int num_raster_threads = 0;
  std::string string_value =
      command_line.GetSwitchValueASCII(switches::kNumRasterThreads);
  bool parsed_num_raster_threads =
      base::StringToInt(string_value, &num_raster_threads);
  DCHECK(parsed_num_raster_threads) << string_value;
  DCHECK_GT(num_raster_threads, 0);

  categorized_worker_pool_->Start(num_raster_threads);

  discardable_memory::mojom::DiscardableSharedMemoryManagerPtr manager_ptr;
  if (IsRunningInMash()) {
#if defined(USE_AURA)
    GetServiceManagerConnection()->GetConnector()->BindInterface(
        ui::mojom::kServiceName, &manager_ptr);
#else
    NOTREACHED();
#endif
  } else {
    ChildThread::Get()->GetConnector()->BindInterface(
        mojom::kBrowserServiceName, mojo::MakeRequest(&manager_ptr));
  }

  discardable_shared_memory_manager_ = std::make_unique<
      discardable_memory::ClientDiscardableSharedMemoryManager>(
      std::move(manager_ptr), GetIOTaskRunner());

  // TODO(boliu): In single process, browser main loop should set up the
  // discardable memory manager, and should skip this if kSingleProcess.
  // See crbug.com/503724.
  base::DiscardableMemoryAllocator::SetInstance(
      discardable_shared_memory_manager_.get());

  GetConnector()->BindInterface(mojom::kBrowserServiceName,
                                mojo::MakeRequest(&storage_partition_service_));

#if defined(OS_LINUX)
  ChildProcess::current()->SetIOThreadPriority(base::ThreadPriority::DISPLAY);
  ChildThreadImpl::current()->SetThreadPriority(
      categorized_worker_pool_->background_worker_thread_id(),
      base::ThreadPriority::BACKGROUND);
#endif

  process_foregrounded_count_ = 0;
  needs_to_record_first_active_paint_ = false;
  was_backgrounded_time_ = base::TimeTicks::Min();

  base::MemoryCoordinatorClientRegistry::GetInstance()->Register(this);

  // If this renderer doesn't run inside the browser process, enable
  // SequencedWorkerPool. Otherwise, it should already have been enabled.
  // TODO(fdoray): Remove this once the SequencedWorkerPool to TaskScheduler
  // redirection experiment concludes https://crbug.com/622400.
   if (!command_line.HasSwitch(switches::kSingleProcess))
     base::SequencedWorkerPool::EnableForProcess();
 
//flaw_line_below:
  EVP_set_buggy_rsa_parser(
//flaw_line_below:
      base::FeatureList::IsEnabled(features::kBuggyRSAParser));
//flaw_line_below:

   GetConnector()->BindInterface(mojom::kBrowserServiceName,
                                 mojo::MakeRequest(&frame_sink_provider_));
 
  if (!is_gpu_compositing_disabled_) {
    GetConnector()->BindInterface(
        mojom::kBrowserServiceName,
        mojo::MakeRequest(&compositing_mode_reporter_));

    // Make |this| a CompositingModeWatcher for the
    // |compositing_mode_reporter_|.
    viz::mojom::CompositingModeWatcherPtr watcher_ptr;
    compositing_mode_watcher_binding_.Bind(mojo::MakeRequest(&watcher_ptr));
    compositing_mode_reporter_->AddCompositingModeWatcher(
        std::move(watcher_ptr));
  }
}
"
9312,187048,,Remote,Not required,,CVE-2019-5754,https://www.cvedetails.com/cve/CVE-2019-5754/,CWE-310,Medium,Partial,,,2019-02-19,4.3,Implementation error in QUIC Networking in Google Chrome prior to 72.0.3626.81 allowed an attacker running or able to cause use of a proxy server to obtain cleartext of transport encryption via malicious network proxy.,2019-04-17,,0,https://github.com/chromium/chromium/commit/fd2335678e96c34d14f4b20f0d9613dfbd1ccdb4,fd2335678e96c34d14f4b20f0d9613dfbd1ccdb4,"Fix a bug in network_session_configurator.cc in which support for HTTPS URLS in QUIC proxies was always set to false.

BUG=914497

Change-Id: I56ad16088168302598bb448553ba32795eee3756
Reviewed-on: https://chromium-review.googlesource.com/c/1417356
Auto-Submit: Ryan Hamilton <rch@chromium.org>
Commit-Queue: Zhongyi Shi <zhongyi@chromium.org>
Reviewed-by: Zhongyi Shi <zhongyi@chromium.org>
Cr-Commit-Position: refs/heads/master@{#623763}",1,components/network_session_configurator/browser/network_session_configurator.cc,"{""sha"": ""95e2d1194bd40e99a9399903d880944fdd5e3afd"", ""filename"": ""components/network_session_configurator/browser/network_session_configurator.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/fd2335678e96c34d14f4b20f0d9613dfbd1ccdb4/components/network_session_configurator/browser/network_session_configurator.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fd2335678e96c34d14f4b20f0d9613dfbd1ccdb4/components/network_session_configurator/browser/network_session_configurator.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/network_session_configurator/browser/network_session_configurator.cc?ref=fd2335678e96c34d14f4b20f0d9613dfbd1ccdb4"", ""patch"": ""@@ -431,7 +431,6 @@ void ConfigureQuicParams(base::StringPiece quic_trial_group,\n   if (params->enable_quic) {\n     params->enable_quic_proxies_for_https_urls =\n         ShouldEnableQuicProxiesForHttpsUrls(quic_trial_params);\n-    params->enable_quic_proxies_for_https_urls = false;\n     params->quic_connection_options =\n         GetQuicConnectionOptions(quic_trial_params);\n     params->quic_client_connection_options =""}<_**next**_>{""sha"": ""1f3c98b7ce0102ecec792375d1a6323a5934f744"", ""filename"": ""components/network_session_configurator/browser/network_session_configurator_unittest.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/fd2335678e96c34d14f4b20f0d9613dfbd1ccdb4/components/network_session_configurator/browser/network_session_configurator_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/fd2335678e96c34d14f4b20f0d9613dfbd1ccdb4/components/network_session_configurator/browser/network_session_configurator_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/network_session_configurator/browser/network_session_configurator_unittest.cc?ref=fd2335678e96c34d14f4b20f0d9613dfbd1ccdb4"", ""patch"": ""@@ -153,6 +153,17 @@ TEST_F(NetworkSessionConfiguratorTest, EnableQuicForDataReductionProxy) {\n   EXPECT_TRUE(params_.enable_quic);\n }\n \n+TEST_F(NetworkSessionConfiguratorTest, EnableQuicProxiesForHttpsUrls) {\n+  std::map<std::string, std::string> field_trial_params;\n+  field_trial_params[\""enable_quic_proxies_for_https_urls\""] = \""true\"";\n+  variations::AssociateVariationParams(\""QUIC\"", \""Enabled\"", field_trial_params);\n+  base::FieldTrialList::CreateFieldTrial(\""QUIC\"", \""Enabled\"");\n+\n+  ParseFieldTrials();\n+\n+  EXPECT_TRUE(params_.enable_quic_proxies_for_https_urls);\n+}\n+\n TEST_F(NetworkSessionConfiguratorTest,\n        MarkQuicBrokenWhenNetworkBlackholesFromFieldTrialParams) {\n   std::map<std::string, std::string> field_trial_params;""}","void ConfigureQuicParams(base::StringPiece quic_trial_group,
                         const VariationParameters& quic_trial_params,
                         bool is_quic_force_disabled,
                         bool is_quic_force_enabled,
                         const std::string& quic_user_agent_id,
                         net::HttpNetworkSession::Params* params) {
  params->enable_quic =
      ShouldEnableQuic(quic_trial_group, quic_trial_params,
                       is_quic_force_disabled, is_quic_force_enabled);
  params->mark_quic_broken_when_network_blackholes =
      ShouldMarkQuicBrokenWhenNetworkBlackholes(quic_trial_params);

  params->enable_server_push_cancellation =
      ShouldEnableServerPushCancelation(quic_trial_params);

  params->retry_without_alt_svc_on_quic_errors =
      ShouldRetryWithoutAltSvcOnQuicErrors(quic_trial_params);

  params->support_ietf_format_quic_altsvc =
      ShouldSupportIetfFormatQuicAltSvc(quic_trial_params);

   if (params->enable_quic) {
     params->enable_quic_proxies_for_https_urls =
         ShouldEnableQuicProxiesForHttpsUrls(quic_trial_params);
     params->quic_connection_options =
         GetQuicConnectionOptions(quic_trial_params);
     params->quic_client_connection_options =
        GetQuicClientConnectionOptions(quic_trial_params);
    params->quic_close_sessions_on_ip_change =
        ShouldQuicCloseSessionsOnIpChange(quic_trial_params);
    params->quic_goaway_sessions_on_ip_change =
        ShouldQuicGoAwaySessionsOnIpChange(quic_trial_params);
    int idle_connection_timeout_seconds =
        GetQuicIdleConnectionTimeoutSeconds(quic_trial_params);
    if (idle_connection_timeout_seconds != 0) {
      params->quic_idle_connection_timeout_seconds =
          idle_connection_timeout_seconds;
    }
    int reduced_ping_timeout_seconds =
        GetQuicReducedPingTimeoutSeconds(quic_trial_params);
    if (reduced_ping_timeout_seconds > 0 &&
        reduced_ping_timeout_seconds < quic::kPingTimeoutSecs) {
      params->quic_reduced_ping_timeout_seconds = reduced_ping_timeout_seconds;
    }
    int max_time_before_crypto_handshake_seconds =
        GetQuicMaxTimeBeforeCryptoHandshakeSeconds(quic_trial_params);
    if (max_time_before_crypto_handshake_seconds > 0) {
      params->quic_max_time_before_crypto_handshake_seconds =
          max_time_before_crypto_handshake_seconds;
    }
    int max_idle_time_before_crypto_handshake_seconds =
        GetQuicMaxIdleTimeBeforeCryptoHandshakeSeconds(quic_trial_params);
    if (max_idle_time_before_crypto_handshake_seconds > 0) {
      params->quic_max_idle_time_before_crypto_handshake_seconds =
          max_idle_time_before_crypto_handshake_seconds;
    }
    params->quic_race_cert_verification =
        ShouldQuicRaceCertVerification(quic_trial_params);
    params->quic_estimate_initial_rtt =
        ShouldQuicEstimateInitialRtt(quic_trial_params);
    params->quic_headers_include_h2_stream_dependency =
        ShouldQuicHeadersIncludeH2StreamDependencies(quic_trial_params);
    params->quic_migrate_sessions_on_network_change_v2 =
        ShouldQuicMigrateSessionsOnNetworkChangeV2(quic_trial_params);
    params->quic_migrate_sessions_early_v2 =
        ShouldQuicMigrateSessionsEarlyV2(quic_trial_params);
    params->quic_retry_on_alternate_network_before_handshake =
        ShouldQuicRetryOnAlternateNetworkBeforeHandshake(quic_trial_params);
    params->quic_go_away_on_path_degrading =
        ShouldQuicGoawayOnPathDegrading(quic_trial_params);
    params->quic_race_stale_dns_on_connection =
        ShouldQuicRaceStaleDNSOnConnection(quic_trial_params);
    int max_time_on_non_default_network_seconds =
        GetQuicMaxTimeOnNonDefaultNetworkSeconds(quic_trial_params);
    if (max_time_on_non_default_network_seconds > 0) {
      params->quic_max_time_on_non_default_network =
          base::TimeDelta::FromSeconds(max_time_on_non_default_network_seconds);
    }
    int max_migrations_to_non_default_network_on_write_error =
        GetQuicMaxNumMigrationsToNonDefaultNetworkOnWriteError(
            quic_trial_params);
    if (max_migrations_to_non_default_network_on_write_error > 0) {
      params->quic_max_migrations_to_non_default_network_on_write_error =
          max_migrations_to_non_default_network_on_write_error;
    }
    int max_migrations_to_non_default_network_on_path_degrading =
        GetQuicMaxNumMigrationsToNonDefaultNetworkOnPathDegrading(
            quic_trial_params);
    if (max_migrations_to_non_default_network_on_path_degrading > 0) {
      params->quic_max_migrations_to_non_default_network_on_path_degrading =
          max_migrations_to_non_default_network_on_path_degrading;
    }
    params->quic_allow_server_migration =
        ShouldQuicAllowServerMigration(quic_trial_params);
    params->quic_host_whitelist = GetQuicHostWhitelist(quic_trial_params);
  }

  size_t max_packet_length = GetQuicMaxPacketLength(quic_trial_params);
  if (max_packet_length != 0) {
    params->quic_max_packet_length = max_packet_length;
  }

  params->quic_user_agent_id = quic_user_agent_id;

  quic::QuicTransportVersionVector supported_versions =
      GetQuicVersions(quic_trial_params);
  if (!supported_versions.empty())
    params->quic_supported_versions = supported_versions;
}
","void ConfigureQuicParams(base::StringPiece quic_trial_group,
                         const VariationParameters& quic_trial_params,
                         bool is_quic_force_disabled,
                         bool is_quic_force_enabled,
                         const std::string& quic_user_agent_id,
                         net::HttpNetworkSession::Params* params) {
  params->enable_quic =
      ShouldEnableQuic(quic_trial_group, quic_trial_params,
                       is_quic_force_disabled, is_quic_force_enabled);
  params->mark_quic_broken_when_network_blackholes =
      ShouldMarkQuicBrokenWhenNetworkBlackholes(quic_trial_params);

  params->enable_server_push_cancellation =
      ShouldEnableServerPushCancelation(quic_trial_params);

  params->retry_without_alt_svc_on_quic_errors =
      ShouldRetryWithoutAltSvcOnQuicErrors(quic_trial_params);

  params->support_ietf_format_quic_altsvc =
      ShouldSupportIetfFormatQuicAltSvc(quic_trial_params);

   if (params->enable_quic) {
     params->enable_quic_proxies_for_https_urls =
         ShouldEnableQuicProxiesForHttpsUrls(quic_trial_params);
    params->enable_quic_proxies_for_https_urls = false;
     params->quic_connection_options =
         GetQuicConnectionOptions(quic_trial_params);
     params->quic_client_connection_options =
        GetQuicClientConnectionOptions(quic_trial_params);
    params->quic_close_sessions_on_ip_change =
        ShouldQuicCloseSessionsOnIpChange(quic_trial_params);
    params->quic_goaway_sessions_on_ip_change =
        ShouldQuicGoAwaySessionsOnIpChange(quic_trial_params);
    int idle_connection_timeout_seconds =
        GetQuicIdleConnectionTimeoutSeconds(quic_trial_params);
    if (idle_connection_timeout_seconds != 0) {
      params->quic_idle_connection_timeout_seconds =
          idle_connection_timeout_seconds;
    }
    int reduced_ping_timeout_seconds =
        GetQuicReducedPingTimeoutSeconds(quic_trial_params);
    if (reduced_ping_timeout_seconds > 0 &&
        reduced_ping_timeout_seconds < quic::kPingTimeoutSecs) {
      params->quic_reduced_ping_timeout_seconds = reduced_ping_timeout_seconds;
    }
    int max_time_before_crypto_handshake_seconds =
        GetQuicMaxTimeBeforeCryptoHandshakeSeconds(quic_trial_params);
    if (max_time_before_crypto_handshake_seconds > 0) {
      params->quic_max_time_before_crypto_handshake_seconds =
          max_time_before_crypto_handshake_seconds;
    }
    int max_idle_time_before_crypto_handshake_seconds =
        GetQuicMaxIdleTimeBeforeCryptoHandshakeSeconds(quic_trial_params);
    if (max_idle_time_before_crypto_handshake_seconds > 0) {
      params->quic_max_idle_time_before_crypto_handshake_seconds =
          max_idle_time_before_crypto_handshake_seconds;
    }
    params->quic_race_cert_verification =
        ShouldQuicRaceCertVerification(quic_trial_params);
    params->quic_estimate_initial_rtt =
        ShouldQuicEstimateInitialRtt(quic_trial_params);
    params->quic_headers_include_h2_stream_dependency =
        ShouldQuicHeadersIncludeH2StreamDependencies(quic_trial_params);
    params->quic_migrate_sessions_on_network_change_v2 =
        ShouldQuicMigrateSessionsOnNetworkChangeV2(quic_trial_params);
    params->quic_migrate_sessions_early_v2 =
        ShouldQuicMigrateSessionsEarlyV2(quic_trial_params);
    params->quic_retry_on_alternate_network_before_handshake =
        ShouldQuicRetryOnAlternateNetworkBeforeHandshake(quic_trial_params);
    params->quic_go_away_on_path_degrading =
        ShouldQuicGoawayOnPathDegrading(quic_trial_params);
    params->quic_race_stale_dns_on_connection =
        ShouldQuicRaceStaleDNSOnConnection(quic_trial_params);
    int max_time_on_non_default_network_seconds =
        GetQuicMaxTimeOnNonDefaultNetworkSeconds(quic_trial_params);
    if (max_time_on_non_default_network_seconds > 0) {
      params->quic_max_time_on_non_default_network =
          base::TimeDelta::FromSeconds(max_time_on_non_default_network_seconds);
    }
    int max_migrations_to_non_default_network_on_write_error =
        GetQuicMaxNumMigrationsToNonDefaultNetworkOnWriteError(
            quic_trial_params);
    if (max_migrations_to_non_default_network_on_write_error > 0) {
      params->quic_max_migrations_to_non_default_network_on_write_error =
          max_migrations_to_non_default_network_on_write_error;
    }
    int max_migrations_to_non_default_network_on_path_degrading =
        GetQuicMaxNumMigrationsToNonDefaultNetworkOnPathDegrading(
            quic_trial_params);
    if (max_migrations_to_non_default_network_on_path_degrading > 0) {
      params->quic_max_migrations_to_non_default_network_on_path_degrading =
          max_migrations_to_non_default_network_on_path_degrading;
    }
    params->quic_allow_server_migration =
        ShouldQuicAllowServerMigration(quic_trial_params);
    params->quic_host_whitelist = GetQuicHostWhitelist(quic_trial_params);
  }

  size_t max_packet_length = GetQuicMaxPacketLength(quic_trial_params);
  if (max_packet_length != 0) {
    params->quic_max_packet_length = max_packet_length;
  }

  params->quic_user_agent_id = quic_user_agent_id;

  quic::QuicTransportVersionVector supported_versions =
      GetQuicVersions(quic_trial_params);
  if (!supported_versions.empty())
    params->quic_supported_versions = supported_versions;
}
",C,,"    params->enable_quic_proxies_for_https_urls = false;
",,"@@ -431,7 +431,6 @@ void ConfigureQuicParams(base::StringPiece quic_trial_group,
   if (params->enable_quic) {
     params->enable_quic_proxies_for_https_urls =
         ShouldEnableQuicProxiesForHttpsUrls(quic_trial_params);
-    params->enable_quic_proxies_for_https_urls = false;
     params->quic_connection_options =
         GetQuicConnectionOptions(quic_trial_params);
     params->quic_client_connection_options =",Chrome,fd2335678e96c34d14f4b20f0d9613dfbd1ccdb4,34cc34f209ff9a9c32258853554886b381b4d0e6,1,"void ConfigureQuicParams(base::StringPiece quic_trial_group,
                         const VariationParameters& quic_trial_params,
                         bool is_quic_force_disabled,
                         bool is_quic_force_enabled,
                         const std::string& quic_user_agent_id,
                         net::HttpNetworkSession::Params* params) {
  params->enable_quic =
      ShouldEnableQuic(quic_trial_group, quic_trial_params,
                       is_quic_force_disabled, is_quic_force_enabled);
  params->mark_quic_broken_when_network_blackholes =
      ShouldMarkQuicBrokenWhenNetworkBlackholes(quic_trial_params);

  params->enable_server_push_cancellation =
      ShouldEnableServerPushCancelation(quic_trial_params);

  params->retry_without_alt_svc_on_quic_errors =
      ShouldRetryWithoutAltSvcOnQuicErrors(quic_trial_params);

  params->support_ietf_format_quic_altsvc =
      ShouldSupportIetfFormatQuicAltSvc(quic_trial_params);

   if (params->enable_quic) {
     params->enable_quic_proxies_for_https_urls =
         ShouldEnableQuicProxiesForHttpsUrls(quic_trial_params);
//flaw_line_below:
    params->enable_quic_proxies_for_https_urls = false;
     params->quic_connection_options =
         GetQuicConnectionOptions(quic_trial_params);
     params->quic_client_connection_options =
        GetQuicClientConnectionOptions(quic_trial_params);
    params->quic_close_sessions_on_ip_change =
        ShouldQuicCloseSessionsOnIpChange(quic_trial_params);
    params->quic_goaway_sessions_on_ip_change =
        ShouldQuicGoAwaySessionsOnIpChange(quic_trial_params);
    int idle_connection_timeout_seconds =
        GetQuicIdleConnectionTimeoutSeconds(quic_trial_params);
    if (idle_connection_timeout_seconds != 0) {
      params->quic_idle_connection_timeout_seconds =
          idle_connection_timeout_seconds;
    }
    int reduced_ping_timeout_seconds =
        GetQuicReducedPingTimeoutSeconds(quic_trial_params);
    if (reduced_ping_timeout_seconds > 0 &&
        reduced_ping_timeout_seconds < quic::kPingTimeoutSecs) {
      params->quic_reduced_ping_timeout_seconds = reduced_ping_timeout_seconds;
    }
    int max_time_before_crypto_handshake_seconds =
        GetQuicMaxTimeBeforeCryptoHandshakeSeconds(quic_trial_params);
    if (max_time_before_crypto_handshake_seconds > 0) {
      params->quic_max_time_before_crypto_handshake_seconds =
          max_time_before_crypto_handshake_seconds;
    }
    int max_idle_time_before_crypto_handshake_seconds =
        GetQuicMaxIdleTimeBeforeCryptoHandshakeSeconds(quic_trial_params);
    if (max_idle_time_before_crypto_handshake_seconds > 0) {
      params->quic_max_idle_time_before_crypto_handshake_seconds =
          max_idle_time_before_crypto_handshake_seconds;
    }
    params->quic_race_cert_verification =
        ShouldQuicRaceCertVerification(quic_trial_params);
    params->quic_estimate_initial_rtt =
        ShouldQuicEstimateInitialRtt(quic_trial_params);
    params->quic_headers_include_h2_stream_dependency =
        ShouldQuicHeadersIncludeH2StreamDependencies(quic_trial_params);
    params->quic_migrate_sessions_on_network_change_v2 =
        ShouldQuicMigrateSessionsOnNetworkChangeV2(quic_trial_params);
    params->quic_migrate_sessions_early_v2 =
        ShouldQuicMigrateSessionsEarlyV2(quic_trial_params);
    params->quic_retry_on_alternate_network_before_handshake =
        ShouldQuicRetryOnAlternateNetworkBeforeHandshake(quic_trial_params);
    params->quic_go_away_on_path_degrading =
        ShouldQuicGoawayOnPathDegrading(quic_trial_params);
    params->quic_race_stale_dns_on_connection =
        ShouldQuicRaceStaleDNSOnConnection(quic_trial_params);
    int max_time_on_non_default_network_seconds =
        GetQuicMaxTimeOnNonDefaultNetworkSeconds(quic_trial_params);
    if (max_time_on_non_default_network_seconds > 0) {
      params->quic_max_time_on_non_default_network =
          base::TimeDelta::FromSeconds(max_time_on_non_default_network_seconds);
    }
    int max_migrations_to_non_default_network_on_write_error =
        GetQuicMaxNumMigrationsToNonDefaultNetworkOnWriteError(
            quic_trial_params);
    if (max_migrations_to_non_default_network_on_write_error > 0) {
      params->quic_max_migrations_to_non_default_network_on_write_error =
          max_migrations_to_non_default_network_on_write_error;
    }
    int max_migrations_to_non_default_network_on_path_degrading =
        GetQuicMaxNumMigrationsToNonDefaultNetworkOnPathDegrading(
            quic_trial_params);
    if (max_migrations_to_non_default_network_on_path_degrading > 0) {
      params->quic_max_migrations_to_non_default_network_on_path_degrading =
          max_migrations_to_non_default_network_on_path_degrading;
    }
    params->quic_allow_server_migration =
        ShouldQuicAllowServerMigration(quic_trial_params);
    params->quic_host_whitelist = GetQuicHostWhitelist(quic_trial_params);
  }

  size_t max_packet_length = GetQuicMaxPacketLength(quic_trial_params);
  if (max_packet_length != 0) {
    params->quic_max_packet_length = max_packet_length;
  }

  params->quic_user_agent_id = quic_user_agent_id;

  quic::QuicTransportVersionVector supported_versions =
      GetQuicVersions(quic_trial_params);
  if (!supported_versions.empty())
    params->quic_supported_versions = supported_versions;
}
"
